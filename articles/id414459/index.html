<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👋 👩🏼‍⚖️ 🙆🏽 Detektor dan deskriptor poin tunggal CEPAT, SINGKAT, ORB ⚠️ 🧓🏻 🉑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Artikel ini akan fokus pada beberapa algoritma pencarian dan deskripsi poin gambar tertentu. Di sini topik ini telah diangkat , dan lebih dari sekali ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Detektor dan deskriptor poin tunggal CEPAT, SINGKAT, ORB</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414459/">  Artikel ini akan fokus pada beberapa algoritma pencarian dan deskripsi poin gambar tertentu.  Di sini topik ini telah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diangkat</a> , dan lebih <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari sekali</a> .  Saya akan mempertimbangkan bahwa definisi dasar sudah akrab bagi pembaca, kami akan memeriksa secara detail algoritma heuristik CEPAT, CEPAT-9, CEPAT-ER, SINGKAT, rBRIEF, ORB, dan membahas ide-ide cemerlang yang mendasari mereka.  Sebagian, ini akan menjadi terjemahan gratis dari esensi beberapa artikel [1,2,3,4,5], akan ada beberapa kode untuk "coba". <br><br><img src="https://pp.userapi.com/c846418/v846418322/73b6d/09CAYMQuFMs.jpg" alt="gambar"><br><a name="habracut"></a><br><h1>  Algoritma CEPAT </h1><br>  FAST, pertama kali diusulkan pada 2005 di [1], adalah salah satu metode heuristik pertama untuk menemukan titik tunggal, yang memperoleh popularitas besar karena efisiensi komputasinya.  Untuk membuat keputusan tentang mempertimbangkan suatu titik C sebagai istimewa atau tidak, metode ini menganggap kecerahan piksel pada lingkaran yang berpusat pada titik C dan jari-jari 3: <br><br><img src="https://pp.userapi.com/c848536/v848536622/5559/qPxNkhmqJSU.jpg" alt="gambar"><br><br>  Membandingkan kecerahan piksel lingkaran dengan kecerahan pusat C, untuk masing-masing kita mendapatkan tiga kemungkinan hasil (tampaknya lebih terang, lebih gelap): <br><br><math> </math> $ sebaris $ \ begin {array} {l} {I_p}&gt; {I_C} + t \\ {I_p} &lt;{I_C} -t \\ {I_C} -t &lt;{I_p} &lt;{I_C} + t \ end {array} $ inline $ <br><br>  Di sini saya adalah kecerahan piksel, t adalah ambang batas kecerahan yang telah ditentukan. <br>  Suatu titik ditandai sebagai spesial jika ada n = 12 piksel dalam satu baris yang lebih gelap, atau 12 piksel yang lebih terang dari pusat. <br><br>  Seperti yang telah ditunjukkan oleh praktik, secara rata-rata, untuk membuat keputusan, perlu memeriksa sekitar 9 poin.  Untuk mempercepat proses, penulis menyarankan terlebih dahulu memeriksa hanya empat piksel dengan angka: 1, 5, 9, 13. Jika di antara mereka ada 3 piksel lebih terang atau lebih gelap, maka pemeriksaan penuh dilakukan pada 16 titik, jika tidak, titik tersebut segera ditandai sebagai " tidak spesial. "  Ini sangat mengurangi waktu kerja, untuk membuat keputusan rata-rata cukup untuk polling hanya sekitar 4 poin lingkaran. <br><br>  Sedikit kode naif terletak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di sini</a> <br>  Parameter variabel (dijelaskan dalam kode): jari-jari lingkaran (mengambil nilai 1,2,3), parameter n (dalam aslinya, n = 12), parameter t.  Kode membuka file in.bmp, memproses gambar, menyimpannya ke out.bmp.  Gambar biasa 24-bit. <br><br><h1>  Membangun pohon keputusan, Pohon CEPAT, CEPAT-9 </h1><br>  Pada tahun 2006, pada [2], adalah mungkin untuk mengembangkan ide orisinal menggunakan pembelajaran mesin dan pohon keputusan. <br><br>  CEPAT asli memiliki kelemahan berikut: <br><br><ul><li>  Beberapa piksel yang berdekatan dapat ditandai sebagai titik khusus.  Kami membutuhkan beberapa ukuran "kekuatan" fitur.  Salah satu langkah pertama yang diusulkan adalah nilai maksimum t di mana titik tersebut masih diambil sebagai tindakan khusus. </li><li>  Tes 4-titik cepat tidak digeneralisasikan untuk n kurang dari 12. Jadi, misalnya, secara visual hasil terbaik dari metode ini dicapai dengan n = 9, bukan 12. </li><li>  Saya juga ingin mempercepat algoritme! </li></ul><br>  Alih-alih menggunakan kaskade dua tes dari 4 dan 16 poin, itu diusulkan untuk melakukan segalanya dalam satu melewati pohon keputusan.  Demikian pula dengan metode asli, kita akan membandingkan kecerahan titik tengah dengan titik-titik pada lingkaran, tetapi dalam urutan ini untuk membuat keputusan secepat mungkin.  Dan ternyata Anda bisa membuat keputusan hanya untuk perbandingan ~ 2 (!!!) rata-rata. <br><br>  Garam utama adalah bagaimana menemukan urutan yang tepat untuk membandingkan poin.  Temukan menggunakan pembelajaran mesin.  Misalkan seseorang terkenal untuk kita dalam gambar banyak poin khusus.  Kami akan menggunakannya sebagai satu set contoh pelatihan, dan idenya adalah untuk <u>dengan penuh semangat</u> memilih yang akan memberikan jumlah informasi terbesar pada langkah ini sebagai poin berikutnya.  Sebagai contoh, misalkan pada awalnya dalam sampel kami ada 5 poin tunggal dan 5 poin non-tunggal.  Dalam bentuk tablet seperti ini: <br><br><img src="https://pp.userapi.com/c848536/v848536622/5596/A83hqZFlbWY.jpg" alt="gambar"><br><br>  Sekarang kita memilih salah satu piksel p dari lingkaran dan untuk semua titik singular kita membandingkan piksel pusat dengan yang dipilih.  Bergantung pada kecerahan piksel yang dipilih di dekat setiap titik tertentu, tabel mungkin memiliki hasil sebagai berikut: <br><br><img src="https://pp.userapi.com/c848536/v848536622/559d/A1CIWhE_LV8.jpg" alt="gambar"><br><br>  Idenya adalah untuk memilih titik p sehingga angka-angka di kolom tabel berbeda mungkin.  Dan jika sekarang untuk titik yang tidak diketahui baru kita mendapatkan hasil perbandingan "Lebih Ringan", maka kita sudah dapat langsung mengatakan bahwa titik itu "tidak istimewa" (lihat tabel).  Proses ini berlanjut secara rekursif sampai titik-titik dari hanya satu kelas jatuh ke masing-masing kelompok setelah dibagi menjadi "gelap-seperti-lebih ringan".  Ternyata pohon dengan bentuk berikut: <br><br><img src="https://pp.userapi.com/c848536/v848536622/55a4/W7idq5TQQZ4.jpg" alt="gambar"><br><br>  Nilai biner ada di daun pohon (merah adalah khusus, hijau tidak istimewa), dan di simpul lain dari pohon adalah jumlah titik yang perlu dianalisis.  Lebih khusus lagi, dalam artikel asli, mereka mengusulkan membuat pilihan nomor poin dengan mengubah entropi.  Entropi himpunan poin dihitung: <br><br><p><math> </math> $$ menampilkan $$ H = \ kiri ({c + \ overline c} \ kanan) {\ log _2} \ kiri ({c + \ overline c} \ kanan) - c {\ log _2} c - \ overline c {\ log _2} \ overline c $$ menampilkan $$ </p><br><br>  c adalah jumlah titik tunggal, <math> </math> $ inline $ {\ bar c} $ inline $   Apakah jumlah titik non-tunggal himpunan <br><br>  Ubah entropi setelah titik pemrosesan p: <br><br><p><math> </math> $$ tampilkan $$ \ Delta H = H - {H_ {dark}} - {H_ {equal}} - {H_ {bright}} $$ tampilkan $$ </p><br><br>  Dengan demikian, suatu titik dipilih dimana perubahan dalam entropi akan menjadi maksimum.  Proses pemisahan berhenti ketika entropi nol, yang berarti bahwa semua titik adalah tunggal, atau sebaliknya - semua tidak istimewa.  Dengan implementasi perangkat lunak, setelah semua ini, pohon keputusan yang ditemukan dikonversi menjadi seperangkat konstruksi dari tipe "jika-lain". <br><br>  Langkah terakhir dari algoritma adalah operasi menekan non-maksimum untuk mendapatkan satu dari beberapa titik yang berdekatan.  Pengembang menyarankan menggunakan ukuran asli berdasarkan jumlah perbedaan mutlak antara titik pusat dan titik-titik lingkaran dalam formulir ini: <br><br><p><math> </math> $$ menampilkan $$ V = \ maks \ kiri ({\ jumlah \ limit_ {x \ dalam {S_ {cerah}}} {\ kiri | {{I_x} - {I_p}} \ kanan | - t, \ jumlah \ limit_ {x \ in {S_ {dark}}} {\ kiri | {{I_p} - {I_x}} \ kanan | - t}}} \ kanan) $$ tampilkan $$ </p><br><br>  Di sini <math> </math> $ inline $ {S_ {bright}} $ inline $   dan <math> </math> $ inline $ {S_ {dark}} $ inline $   masing-masing, kelompok piksel lebih terang dan lebih gelap, t adalah nilai kecerahan ambang, <math> </math> $ inline $ {I_p} $ inline $   - Kecerahan piksel pusat, <math> </math> $ inline $ {{I_x}} $ inline $   - Kecerahan piksel pada lingkaran.  Anda dapat mencoba algoritme dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode berikut</a> .  Kode diambil dari OpenCV dan dibebaskan dari semua dependensi, jalankan saja. <br><br><h1>  Mengoptimalkan pohon keputusan - FAST-ER </h1><br>  FAST-ER [3] adalah algoritma dari penulis yang sama dengan yang sebelumnya, detektor cepat dibangun dengan cara yang sama, urutan titik yang optimal juga dicari untuk perbandingan, pohon keputusan juga dibangun, tetapi menggunakan metode yang berbeda - metode optimisasi. <br><br>  Kami sudah memahami bahwa detektor dapat direpresentasikan sebagai pohon keputusan.  Jika kita memiliki kriteria untuk membandingkan kinerja pohon yang berbeda, maka kita dapat memaksimalkan kriteria ini dengan memilah-milah varian pohon yang berbeda.  Dan sebagai kriteria seperti itu, diusulkan untuk menggunakan "Repeatability". <br><br>  Repeatability menunjukkan seberapa baik titik-titik singular dari suatu adegan terdeteksi dari sudut yang berbeda.  Untuk sepasang gambar, suatu titik disebut "berguna" jika ditemukan pada satu bingkai dan secara teoritis dapat ditemukan pada yang lain, mis.  Jangan menghalangi elemen adegan.  Dan intinya disebut "diulang" (diulang), jika ditemukan di bingkai kedua juga.  Karena optik kamera tidak ideal, titik pada frame kedua mungkin tidak dalam piksel yang dihitung, tetapi di suatu tempat di sekitarnya.  Pengembang mengambil lingkungan 5 piksel.  Kami mendefinisikan pengulangan sebagai rasio jumlah poin berulang dengan jumlah poin yang berguna: <br><br><p><math> </math> $$ menampilkan $$ R = \ frac {{{N_ {diulang}}}} {{{N_ {berguna}}}} $$ menampilkan $$ </p><br><br>  Untuk menemukan detektor terbaik, metode simulasi anil digunakan.  Sudah ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel bagus</a> tentang Habré tentang dia.  Secara singkat, inti dari metode ini adalah sebagai berikut: <br><br><ul><li>  Beberapa solusi awal untuk masalah dipilih (dalam kasus kami, ini adalah semacam pohon detektor). </li><li>  Pengulangan dianggap. </li><li>  Pohon itu dimodifikasi secara acak. </li><li>  Jika versi modifikasi lebih baik dengan kriteria pengulangan, maka modifikasi diterima, dan jika lebih buruk, itu dapat diterima atau tidak, dengan beberapa kemungkinan, yang tergantung pada bilangan real yang disebut "suhu".  Saat jumlah iterasi meningkat, suhu turun ke nol. </li></ul><br>  Selain itu, konstruksi detektor sekarang tidak melibatkan 16 titik lingkaran, seperti sebelumnya, tetapi 47, tetapi artinya tidak berubah sama sekali: <br><br><img src="https://pp.userapi.com/c824411/v824411841/1607f1/5szVOBYHeck.jpg" alt="gambar"><br><br>  Menurut metode anil simulasi, kami mendefinisikan tiga fungsi: <br><br>  • Fungsi biaya k.  Dalam kasus kami, kami menggunakan pengulangan sebagai nilai.  Tapi ada satu masalah.  Bayangkan bahwa semua titik pada masing-masing dari dua gambar terdeteksi sebagai tunggal.  Kemudian ternyata pengulangan 100% - absurditas.  Di sisi lain, bahkan jika kita telah menemukan satu titik tertentu dalam dua gambar, dan titik-titik ini bertepatan - pengulangan juga 100%, tetapi ini juga tidak menarik bagi kita.  Dan oleh karena itu, penulis mengusulkan untuk menggunakan ini sebagai kriteria kualitas: <br><br><p><math> </math> $$ menampilkan $$ k = \ kiri ({1 + {{\ kiri ({\ frac {{{w_r}}} {R}} \ kanan)} ^ 2}} \ kanan) \ kiri ({1 + \ frac {1} {N} \ jumlah \ Limit_ {i = 1} {{{\ kiri ({\ frac {{{d_i}}} {{{w_n}}}} kanan)} ^ 2}}} \ kanan) \ kiri ({1 + {{\ kiri ({\ frac {s} {{{w_s}}}} kanan)} ^ 2}} \ kanan) $$ tampilkan $$ </p><br><br>  r adalah pengulangan <math> </math> $ inline $ {{d_i}} $ inline $   Apakah jumlah sudut yang terdeteksi pada frame i, N adalah jumlah frame, dan s adalah ukuran pohon (jumlah simpul).  W adalah parameter metode khusus.] <br><br>  • Fungsi perubahan suhu seiring waktu: <br><br><p><math> </math> $$ menampilkan $$ T \ kiri (I \ kanan) = \ beta \ exp \ kiri ({- \ frac {{\ alpha I}} {{{I _ {\ max}}}} \ kanan) $$ tampilan $$ </p><br><br>  dimana <math> </math> $ inline $ \ alpha, \ beta $ inline $   Apakah koefisien, Imax adalah jumlah iterasi. <br><br>  • Fungsi yang menghasilkan solusi baru.  Algoritma membuat modifikasi acak ke pohon.  Pertama, pilih beberapa titik.  Jika simpul yang dipilih adalah daun pohon, maka dengan probabilitas yang sama kita lakukan hal berikut: <br><br><ol><li>  Ganti vertex dengan subtree acak dengan kedalaman 1 </li><li>  Ubah kelas sheet ini (poin singular-nonsingular) </li></ol><br>  Jika ini BUKAN selembar: <br><br><ol><li>  Ganti jumlah titik yang diuji dengan angka acak dari 0 hingga 47 </li><li>  Ganti simpul dengan lembar dengan kelas acak </li><li>  Tukar dua subtree dari vertex ini </li></ol><br>  Probabilitas P menerima perubahan pada iterasi I adalah: <br><math> </math> $ inline $ P = \ exp \ kiri ({\ frac {{k \ kiri ({i - 1} \ kanan) - k \ kiri (i \ kanan)}} {T}} \ kanan) $ inline $ <br>  k adalah fungsi biaya, T adalah suhu, i adalah angka iterasi. <br><br>  Modifikasi pada pohon ini memungkinkan pertumbuhan pohon dan pengurangannya.  Metode ini acak, tidak menjamin bahwa pohon terbaik akan diperoleh.  Jalankan metode berkali-kali, pilih solusi terbaik.  Dalam artikel asli, misalnya, mereka menjalankan 100 kali per 100.000 iterasi masing-masing, yang membutuhkan waktu prosesor 200 jam.  Seperti yang ditunjukkan hasilnya, hasilnya lebih baik daripada Tree FAST, terutama pada gambar yang berisik. <br><br><h1>  Deskriptor SINGKAT </h1><br>  Setelah titik tunggal ditemukan, deskriptornya dihitung, mis.  set fitur yang menandai lingkungan dari setiap titik tunggal.  SINGKAT [4] adalah deskriptor heuristik yang cepat, dibangun dari 256 perbandingan biner antara kecerahan piksel dalam gambar <u>buram</u> .  Tes biner antara titik x dan y didefinisikan sebagai berikut: <br><br><p><math> </math> $$ menampilkan $$ \ tau \ kiri ({P, x, y} \ kanan): = \ kiri \ {{\ begin {array} {* {20} {c}} {1: p \ kiri (x \ kanan) &lt;p \ kiri (y \ kanan)} \\ {0: p \ kiri (x \ kanan) \ ge p \ kiri (y \ kanan)} \ end {array}} \ kanan. $$ display $$ </p><br><br><img src="https://pp.userapi.com/c824411/v824411841/160801/dMWJxyV422c.jpg" alt="gambar"><br><br>  Dalam artikel asli, beberapa metode untuk memilih poin untuk perbandingan biner dipertimbangkan.  Ternyata, salah satu cara terbaik adalah memilih titik secara acak menggunakan distribusi Gaussian di sekitar piksel pusat.  Urutan titik acak ini dipilih satu kali dan tidak berubah lebih lanjut.  Ukuran lingkungan yang dianggap sebagai titik adalah 31x31 piksel, dan aperture blur adalah 5. <br><br>  Deskriptor biner yang dihasilkan tahan terhadap perubahan pencahayaan, distorsi perspektif, cepat dihitung dan dibandingkan, tetapi sangat tidak stabil terhadap rotasi pada bidang gambar. <br><br><h1>  ORB - cepat dan efisien </h1><br>  Pengembangan semua ide ini adalah algoritma ORB (Oriented FAST dan Rotated BRIEF) [5], di mana upaya dilakukan untuk meningkatkan kinerja BRIEF selama rotasi gambar.  Diusulkan untuk pertama-tama menghitung orientasi titik singular dan kemudian melakukan perbandingan biner sesuai dengan orientasi ini.  Algoritma bekerja seperti ini: <br><br>  1) Poin fitur terdeteksi dengan menggunakan pohon CEPAT cepat pada gambar asli dan dalam beberapa gambar dari piramida gambar kecil. <br><br>  2) Untuk titik yang terdeteksi, pengukuran Harris dihitung, kandidat dengan nilai rendah pengukuran Harris dibuang. <br><br>  3) Sudut orientasi titik singular dihitung.  Untuk ini, momen kecerahan untuk lingkungan titik singular pertama kali dihitung: <br><br><math> </math> $ inline $ {m_ {pq}} = \ jumlah \ limit_ {x, y} {{x ^ p} {y ^ q} I \ kiri ({x, y} \ kanan)} $ inline $ <br>  koordinat x, y - pixel, I - brightness.  Dan kemudian sudut orientasi titik singular: <br><math> </math> $ inline $ \ theta = {\ rm {atan2}} \ kiri ({{m_ {01}}, {m_ {10}}} \ kanan) $ inline $ <br><br>  Semua ini, penulis menyebutnya "orientasi centroid."  Sebagai hasilnya, kami memperoleh arah tertentu untuk lingkungan titik singular. <br><br>  4) Memiliki sudut orientasi titik singular, urutan titik untuk perbandingan biner dalam deskriptor BRIEF berputar sesuai dengan sudut ini, misalnya: <br><br><img src="https://pp.userapi.com/c824411/v824411841/160813/y5R3uZYvsfQ.jpg" alt="gambar"><br><br>  Secara lebih formal, posisi baru untuk titik uji biner dihitung sebagai berikut: <br><br><p><math> </math> $$ menampilkan $$ \ kiri ({\ begin {array} {* {20} {c}} {{x_i} '} \\ {{y_i}'} \ end {array}} \ kanan) = R \ kiri (\ theta \ kanan) \ cdot \ kiri ({\ begin {array} {* {20} {c}} {{x_i}} \\ {{y_i}} \ end {array}} \ kanan) $$ tampilan $$ </p><br><br>  5) Berdasarkan poin yang diterima, deskriptor biner SINGKAT dihitung <br><br>  Dan itu ... tidak semua!  Ada detail menarik lainnya di ORB yang membutuhkan penjelasan terpisah.  Faktanya adalah bahwa pada saat kita "mengubah" semua titik tunggal ke sudut nol, pilihan acak perbandingan biner dalam deskriptor berhenti menjadi acak.  Ini mengarah pada fakta bahwa, pertama, beberapa perbandingan biner ternyata saling bergantung satu sama lain, dan kedua, rata-rata mereka tidak lagi sama dengan 0,5 (1 lebih ringan, 0 lebih gelap ketika pilihannya acak, itu rata-rata 0,5) semua ini secara signifikan mengurangi kemampuan deskriptor untuk membedakan titik tunggal di antara mereka sendiri. <br><br>  Solusi - Anda perlu memilih tes biner "benar" dalam proses pembelajaran, ide ini meniup rasa yang sama dengan pelatihan pohon untuk algoritma FAST-9.  Misalkan kita memiliki banyak titik tunggal yang sudah ditemukan.  Pertimbangkan semua opsi yang memungkinkan untuk pengujian biner.  Jika lingkungan adalah 31 x 31, dan uji biner adalah sepasang subset 5 x 5 (karena kabur), maka ada banyak pilihan untuk memilih N = (31-5) ^ 2.  Algoritma pencarian untuk tes "baik" adalah sebagai berikut: <br><br><ol><li>  Kami menghitung hasil semua tes untuk semua poin tunggal </li><li>  Atur seluruh rangkaian tes sesuai dengan jaraknya dari rata-rata 0,5 </li><li>  Buat daftar yang akan berisi tes "baik" yang dipilih, mari panggil daftar R. </li><li>  Tambahkan ke R tes pertama dari set yang diurutkan </li><li>  Kami mengambil tes berikutnya dan membandingkannya dengan semua tes dalam R. Jika korelasinya lebih besar dari ambang, maka kami membuang tes baru, jika tidak kami menambahkannya. </li><li>  Ulangi langkah 5 hingga kami mengetik jumlah tes yang diperlukan. </li></ol><br>  Ternyata tes dipilih sehingga, di satu sisi, nilai rata-rata tes ini sedekat mungkin menjadi 0,5, di sisi lain, sehingga korelasi antara tes yang berbeda minimal.  Dan inilah yang kami butuhkan.  Bandingkan bagaimana itu dan bagaimana jadinya: <br><br><img src="https://pp.userapi.com/c824411/v824411841/160829/ozQhEUvtdBs.jpg" alt="gambar"><br><br>  Untungnya, algoritma ORB diimplementasikan di perpustakaan OpenCV di kelas cv :: ORB.  Saya menggunakan versi 2.4.13.  Konstruktor kelas menerima parameter berikut: <br><br>  nfeatures - jumlah poin singular maksimum <br>  scaleFactor - pengganda untuk piramida gambar, lebih dari satu.  Nilai 2 mengimplementasikan piramida klasik. <br>  nlevels - jumlah level dalam piramida gambar. <br>  edgeThreshold - jumlah piksel di batas gambar tempat titik tunggal tidak terdeteksi. <br>  firstLevel - biarkan nol. <br>  WTA_K - jumlah poin yang diperlukan untuk satu elemen deskriptor.  Jika sama dengan 2, maka kecerahan dua piksel yang dipilih secara acak dibandingkan.  Inilah yang dibutuhkan. <br>  scoreType - jika 0, maka harris digunakan sebagai ukuran fitur, jika tidak - ukuran CEPAT (berdasarkan jumlah moduli dari perbedaan kecerahan pada titik-titik lingkaran).  Ukuran FAST sedikit kurang stabil, tetapi lebih cepat. <br>  patchSize - ukuran lingkungan tempat piksel acak dipilih untuk perbandingan.  Kode mencari dan membandingkan titik-titik tunggal dalam dua gambar, "templ.bmp" dan "img.bmp" <br><br><div class="spoiler">  <b class="spoiler_title">Kode</b> <div class="spoiler_text"><pre><code class="cpp hljs">cv::Mat img_object=cv::imread(<span class="hljs-string"><span class="hljs-string">"templ.bmp"</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;cv::KeyPoint&gt; keypoints_object, keypoints_scene; cv::Mat descriptors_object, descriptors_scene; cv::<span class="hljs-function"><span class="hljs-function">ORB </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">orb</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">500</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1.2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">4</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">31</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">31</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//    orb.detect(img_object, keypoints_object); orb.compute(img_object, keypoints_object, descriptors_object); //    cv::Mat img = cv::imread("img.bmp", 1); cv::Mat img_scene = cv::Mat(img.size(), CV_8UC1); orb.detect(img, keypoints_scene); orb.compute(img, keypoints_scene, descriptors_scene); cv::imshow("desrs", descriptors_scene); cvWaitKey(); int test[10]; for (int q = 0; q&lt;10 ; q++) test[q]=descriptors_scene.data[q]; //-- matching descriptor vectors using FLANN matcher cv::BFMatcher matcher; std::vector&lt;cv::DMatch&gt; matches; cv::Mat img_matches; if(!descriptors_object.empty() &amp;&amp; !descriptors_scene.empty()) { matcher.match (descriptors_object, descriptors_scene, matches); double max_dist = 0; double min_dist = 100; // calculation of max and min idstance between keypoints for( int i = 0; i &lt; descriptors_object.rows; i++) { double dist = matches[i].distance; if( dist &lt; min_dist ) min_dist = dist; if( dist &gt; max_dist ) max_dist = dist; } //-- Draw only good matches (ie whose distance is less than 3*min_dist) std::vector&lt; cv::DMatch &gt;good_matches; for( int i = 0; i &lt; descriptors_object.rows; i++ ) if( matches[i].distance &lt; (max_dist/1.6) ) good_matches.push_back(matches[i]); cv::drawMatches(img_object, keypoints_object, img_scene, keypoints_scene, good_matches, img_matches, cv::Scalar::all(-1), cv::Scalar::all(-1), std::vector&lt;char&gt;(), cv::DrawMatchesFlags::NOT_DRAW_SINGLE_POINTS); } cv::imshow("match result", img_matches ); cv::waitKey(); return 0;</span></span></code> </pre> <br></div></div><br>  Jika seseorang membantu memahami esensi dari algoritma, maka itu tidak sia-sia.  Untuk semua Habr. <br><br>  Referensi: <br><br>  1. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fusing Points dan Lines untuk Pelacakan Berkinerja Tinggi</a> <br>  2. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pembelajaran mesin untuk deteksi sudut kecepatan tinggi</a> <br>  3. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lebih cepat dan lebih baik: pendekatan pembelajaran mesin untuk deteksi sudut</a> <br>  4. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SINGKAT: Fitur Dasar Biner Independen</a> <br>  5. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ORB: alternatif efisien untuk SIFT atau SURF</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id414459/">https://habr.com/ru/post/id414459/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id414447/index.html">Macam-macam sepanjang masa</a></li>
<li><a href="../id414449/index.html">Cara berteman dengan semua operator di stadion dan tidak menaburnya dengan ratusan antena</a></li>
<li><a href="../id414451/index.html">"Kalender Tester" untuk bulan Juni. Penguji harus menangkap bug, membaca Caner dan mengatur gerakan.</a></li>
<li><a href="../id414453/index.html">Menerapkan Path Finder untuk Agen AI dengan NavMesh</a></li>
<li><a href="../id414455/index.html">Algoritma Generasi Palet Warna</a></li>
<li><a href="../id414463/index.html">AI sendiri belajar cara membangun Rubik's Cube</a></li>
<li><a href="../id414465/index.html">Meta Crush Saga: game kompilasi-waktu</a></li>
<li><a href="../id414467/index.html">Makalah dari Minsk C ++ Conference CoreHard Spring 2018</a></li>
<li><a href="../id414469/index.html">Minggu Keamanan 22: Dua Kunci Cerdas Kedua</a></li>
<li><a href="../id414471/index.html">11 lingkaran neraka bagi mereka yang tidak memiliki pengalaman dalam pekerjaan baru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>