<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§Ωüèº üíÜüèæ üèØ ViewPager 2 - nova funcionalidade no antigo inv√≥lucro ü§òüèæ üìÄ üë®üèΩ‚Äçüé§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O ViewPager √© um dos componentes mais famosos e amplamente usados ‚Äã‚Äãda Biblioteca de suporte do Android. Todos os carross√©is, onboardings e sliders ma...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ViewPager 2 - nova funcionalidade no antigo inv√≥lucro</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/surfstudio/blog/461873/">  O ViewPager √© um dos componentes mais famosos e amplamente usados ‚Äã‚Äãda Biblioteca de suporte do Android.  Todos os carross√©is, onboardings e sliders mais simples s√£o feitos nele.  Em fevereiro de 2019, a equipe de desenvolvimento do AndroidX lan√ßou o ViewPager2.  Vejamos quais eram esses pr√©-requisitos e quais as vantagens da vers√£o atualizada do componente. <br><br><img src="https://habrastorage.org/webt/eu/aw/ss/euawsscpwdgkcngbjdjqabx1uhc.png"><br><a name="habracut"></a><br><h3>  ViewPager 2 </h3><br>  No momento da reda√ß√£o da publica√ß√£o (julho de 2019), uma vers√£o beta do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ViewPager2 estava dispon√≠vel</a> , o que significa que os problemas mencionados abaixo podem ser corrigidos e a funcionalidade aprimorada e expandida.  Os desenvolvedores prometem no futuro adicionar suporte ao TabLayout (embora ele possa funcionar apenas com a primeira vers√£o), otimizar o desempenho do adaptador, fazer muitas pequenas corre√ß√µes e finalizar a documenta√ß√£o. <br><br><h3>  Integra√ß√£o </h3><br>  O componente n√£o √© fornecido com pacotes padr√£o, mas √© conectado separadamente.  Para fazer isso, adicione a seguinte linha ao bloco de depend√™ncias no script gradle do seu m√≥dulo: <br><br><pre><code class="java hljs">implementation <span class="hljs-string"><span class="hljs-string">"androidx.viewpager2:viewpager2:1.0.0-beta02"</span></span></code> </pre> <br><h3>  Implementa√ß√£o </h3><br>  Vamos come√ßar com as boas not√≠cias: a transi√ß√£o da primeira para a segunda vers√£o √© a mais simples poss√≠vel e se resume a uma mudan√ßa nas importa√ß√µes.  A boa e antiga sintaxe n√£o foi tocada: o <i>m√©todo getCurrentItem ()</i> retorna a p√°gina atual, <i>ViewPager2.onPageChangeCallback</i> permite que <i>voc√™</i> assine o <i>estado</i> do pager, o adaptador ainda est√° instalado via <i>setAdapter ().</i> <br><br><hr><br>  Vale a pena ir mais fundo, pois fica claro que o primeiro e o segundo pagers n√£o t√™m nada em comum, exceto as interfaces.  A familiaridade com a implementa√ß√£o do m√©todo setAdapter () n√£o deixa margem para d√∫vidas: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">final</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setAdapter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@Nullable Adapter adapter)</span></span></span><span class="hljs-function"> </span></span>{ mRecyclerView.setAdapter(adapter); }</code> </pre><br>  Sim, o ViewPager2 √© apenas um inv√≥lucro do <b>RecyclerView</b> .  Por um lado, essa √© uma grande vantagem, por outro - acrescenta dor de cabe√ßa.  Disfar√ßar o <i>RecyclerView</i> como um folheto tornou-se poss√≠vel com o advento do <b>PagerSnapHelper</b> .  Esta classe muda a f√≠sica do scroll.  Quando o usu√°rio solta o dedo, <i>PagerSnapHelper</i> calcula qual item da lista est√° mais pr√≥ximo da linha central da lista e, com uma anima√ß√£o suave, o alinha exatamente no centro.  Assim, se o furto foi n√≠tido o suficiente, a lista rola para o pr√≥ximo elemento, caso contr√°rio - com a anima√ß√£o retorna ao seu estado original. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PagerSnapHelper().attachToRecyclerView(mRecyclerView);</code> </pre><br><img src="https://habrastorage.org/getpro/habr/post_images/737/962/b7a/737962b7a5620216a2a6d0c71353a2a1.gif" alt="imagem"><br><blockquote>  Ao usar o PagerSnapHelper, verifique se a largura e a altura do pr√≥prio RecyclerView, bem como de todos os seus ViewHolders, est√£o definidas como MATCH_PARENT.  Caso contr√°rio, o comportamento do SnapHelper ser√° imprevis√≠vel, podem ocorrer erros em locais completamente inesperados.  Tudo isso torna a cria√ß√£o de um carrossel de elementos de pequena estatura bastante demorada, embora poss√≠vel. </blockquote><br>  Dado todo o exposto, no layout o widget ser√° semelhante a este: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">androidx.viewpager2.widget.ViewPager2</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"@+id/main_pager"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:layout_width</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"match_parent"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">android:layout_height</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"match_parent"</span></span></span><span class="hljs-tag"> /&gt;</span></span></code> </pre><br>  No mesmo pacote que o <i>ViewPager2,</i> tamb√©m podemos encontrar a classe <b>ScrollEventAdapter</b> , que ajuda a manter a continuidade da sintaxe.  <i>ScrollEventAdapter</i> implementa <b>RecyclerView.OnScrollListener</b> e transforma eventos de rolagem <b>em</b> eventos <b>OnPageChangeCallback</b> . <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onScrollStateChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull RecyclerView recyclerView, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newState)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mAdapterState != STATE_IN_PROGRESS_MANUAL_DRAG &amp;&amp; newState == RecyclerView.SCROLL_STATE_DRAGGING) { ... dispatchStateChanged(SCROLL_STATE_DRAGGING); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } ... }</code> </pre><br>  Agora <i>OnPageChangeCallback</i> √© representado n√£o por uma interface, mas por uma classe abstrata, que permite substituir apenas os m√©todos necess√°rios (na maioria dos casos, voc√™ s√≥ precisa do <i>nPageSelected (Int)</i> , que funciona quando uma p√°gina espec√≠fica √© selecionada): <br><br><pre> <code class="java hljs">main_pager.registerOnPageChangeCallback( object : ViewPager2.OnPageChangeCallback() { <span class="hljs-function"><span class="hljs-function">override fun </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onPageSelected</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(position: Int)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//do your stuff } } )</span></span></code> </pre><br><h3>  Funcionalidades </h3><br>  <b>Digno de nota √© o</b> m√©todo <b>setPageTransformer ()</b> , que usa o <b>ViewPager2.PageTransformer</b> como par√¢metro.  Ele define um <i>retorno</i> de <i>chamada</i> para cada evento de sele√ß√£o de p√°gina e serve para definir sua pr√≥pria anima√ß√£o para esta p√°gina.  <i>O retorno de chamada</i> recebe a <i>visualiza√ß√£o da</i> p√°gina atual e seu n√∫mero como entrada.  O an√°logo mais pr√≥ximo desse m√©todo √© o <i>ItemAnimator</i> do <i>RecyclerView</i> . <br><br>  Nas novas vers√µes da biblioteca, duas implementa√ß√µes do transformador foram adicionadas: <br><br>  <b>CompositePageTransformer</b> e <b>MarginPageTransformer</b> .  O primeiro √© respons√°vel pela combina√ß√£o de transformadores para aplicar v√°rias transforma√ß√µes em um pager de uma vez e o segundo pelo recuo entre p√°ginas: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/53d/c0d/49b/53dc0d49b39527079355f55a5c5cf4e0.gif" alt="imagem"><br><br>  Al√©m disso, o novo widget suporta altera√ß√µes de orienta√ß√£o: basta chamar o <b>m√©todo setOrientation ()</b> , voc√™ pode transformar seu pager em uma lista vertical com furtos de cima para baixo: <br><br><pre> <code class="kotlin hljs">main_pager.setOrientation(ViewPager2.ORIENTATION_VERTICAL)</code> </pre><br>  Isso acontece novamente gra√ßas √† transi√ß√£o para o <i>RecyclerView</i> : sob o cap√¥, uma mudan√ßa na orienta√ß√£o do <i>LayoutManager √© chamada</i> , respons√°vel pela exibi√ß√£o dos itens da lista.  Note-se que delegar um grande n√∫mero de tarefas para outras classes beneficiou o novo componente: sua listagem se tornou muito mais compacta e leg√≠vel. <br><br>  Este n√£o √© o fim da divers√£o.  Em uma atualiza√ß√£o, o <i>ViewPager2</i> recebeu suporte para o <i>ItemDecoration</i> : uma classe <i>auxiliar</i> para decorar o <i>View</i> filho.  Este mecanismo pode ser usado para desenhar separadores entre elementos, bordas e destaque de c√©lulas. <br><br>  J√° existem muitas implementa√ß√µes prontas de decoradores, porque por muitos anos elas foram usadas com sucesso ao trabalhar com o <i>RecyclerView</i> usual.  Todos os desenvolvimentos agora s√£o aplic√°veis ‚Äã‚Äãaos pagers.  Pronto para uso, est√° dispon√≠vel uma implementa√ß√£o padr√£o de separadores de pager: <br><br><pre> <code class="kotlin hljs">main_pager.addItemDecoration( DividerItemDecoration(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, RecyclerView.HORIZONTAL) )</code> </pre><br>  Juntamente com a pr√≥xima atualiza√ß√£o em maio de 2019, o <i>ViewPager2</i> adicionou outro m√©todo importante: <b>setOffscreenPageLimit (Int)</b> .  Ele √© respons√°vel por quantos elementos √† direita e √† esquerda da central ser√£o inicializados no pager.  Embora o <i>RecyclerView</i> seja respons√°vel por armazenar em cache e exibir a <i>Visualiza√ß√£o por</i> padr√£o, usando este m√©todo, voc√™ pode definir explicitamente o n√∫mero desejado de itens a serem carregados. <br><br><h3>  Adaptador </h3><br>  O sucessor ideol√≥gico do primeiro adaptador de pager √© o <i>FragmentStateAdapter</i> : as interfaces de intera√ß√£o e a nomea√ß√£o de classes s√£o quase as mesmas.  As altera√ß√µes afetaram apenas a nomea√ß√£o de alguns m√©todos.  Se anteriormente era necess√°rio implementar a fun√ß√£o abstrata <i>getItem (position)</i> para retornar a inst√¢ncia do <i>Fragment</i> desejada para a posi√ß√£o especificada e essa nomea√ß√£o poderia ser interpretada de duas maneiras, agora essa fun√ß√£o foi renomeada para <i>createFragment (position)</i> .  O n√∫mero total de fragmentos √© fornecido como antes pela fun√ß√£o <i>getCount ()</i> . <br><br>  Das importantes mudan√ßas estruturais na interface, tamb√©m deve ser observado que o adaptador agora tem a capacidade de controlar o ciclo de vida de seus elementos; portanto, junto com o <i>FragmentManager</i> no construtor, ele aceita um <i>objeto de Ciclo de Vida</i> , uma <i>Atividade</i> ou um <i>Fragmento</i> .  Por esse <i>motivo</i> , por seguran√ßa, os <i>m√©todos saveState ()</i> e <i>restoreState ()</i> foram declarados finais e fechados para heran√ßa. <br>  A classe <b>FragmentViewHolder</b> √© respons√°vel por armazenar fragmentos dentro do <i>RecyclerView</i> .  O m√©todo <b>onCreateViewHolder ()</b> de <b>FragmentStateAdapter</b> chama <b>FragmentViewHolder.create ()</b> . <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> FragmentViewHolder </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">create</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ViewGroup parent)</span></span></span><span class="hljs-function"> </span></span>{ FrameLayout container = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FrameLayout(parent.getContext()); container.setLayoutParams( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ViewGroup.LayoutParams( ViewGroup.LayoutParams.MATCH_PARENT, ViewGroup.LayoutParams.MATCH_PARENT ) ); container.setId(ViewCompat.generateViewId()); container.setSaveEnabled(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FragmentViewHolder(container); }</code> </pre><br>  Quando o m√©todo <b>onBindViewHolder ()</b> √© <b>chamado</b> , o identificador do elemento na posi√ß√£o atual e o identificador <i>ViewHolder</i> s√£o <i>associados</i> , para anexar ainda mais o fragmento a ele: <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> itemId = holder.getItemId(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> viewHolderId = holder.getContainer().getId(); <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Long boundItemId = itemForViewHolder(viewHolderId); ... mItemIdToViewHolder.put(itemId, viewHolderId); ensureFragment(position); <span class="hljs-comment"><span class="hljs-comment">//  </span></span></code> </pre><br>  E, finalmente, ao anexar um cont√™iner do <i>ViewHolder</i> √† hierarquia do <i>View</i> , uma <i>FragmentTransaction</i> √© executada, adicionando um <i>Fragment</i> ao cont√™iner: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">placeFragmentInViewHolder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(@NonNull </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> FragmentViewHolder holder)</span></span></span><span class="hljs-function"> </span></span>{ Fragment fragment = mFragments.get(holder.getItemId()); ... scheduleViewAttach(fragment, container); mFragmentManager.beginTransaction() .add(fragment, <span class="hljs-string"><span class="hljs-string">"f"</span></span> + holder.getItemId()) .setMaxLifecycle(fragment, STARTED) .commitNow(); ... }</code> </pre><br>  Assim, <i>surgem</i> dois usos do <i>ViewPager2</i> : herdando a classe do adaptador, diretamente do <i>RecyclerView.Adapter</i> ou do <i>FragmentStateAdapter</i> . <br><br><hr><br>  Certamente voc√™ ter√° uma pergunta: por que usar um segundo pager com fragmentos e um adaptador para eles quando existe uma primeira vers√£o normalmente funcionando?  <i>O ViewPager</i> est√° longe de ser uma ‚Äúbala de prata‚Äù ao trabalhar com grandes listas de dados din√¢micos.  √â √≥timo para criar carross√©is com um conjunto est√°tico de fotos ou banners, mas feeds de not√≠cias paginados com o carregamento de postagens de publicidade, a filtragem d√° origem a monstros feios e com forte suporte.  Mais cedo ou mais tarde, voc√™ certamente encontrar√° um desejo ardente de reescrever tudo no <i>RecyclerView</i> .  Agora voc√™ n√£o precisa fazer isso, porque o pager se transformou nele, emprestando seus poderosos recursos para trabalhar com listas din√¢micas, enquanto os agrupa na sintaxe usual. <br><br>  A √∫nica coisa que o <i>PagerAdapter</i> pode <i>nos</i> oferecer √© o m√©todo <b>notifyDataSetChanged ()</b> , que for√ßa o <i>ViewPager a</i> redesenhar todos os itens da lista renderizada.  Voc√™ pode razoavelmente perceber que ningu√©m est√° nos impedindo de armazenar uma lista de posi√ß√µes para elementos existentes e retornando <i>POSITION_UNCHANGED</i> do m√©todo <i>getItemPosition ()</i> para eles, √© isso.  No entanto, essa solu√ß√£o n√£o pode ser chamada de bonita; √© bastante complicada; al√©m disso, √© dif√≠cil expandir os casos em que os elementos da lista est√£o constantemente mudando e n√£o apenas adicionados sequencialmente ao final.  <i>O FragmentStateAdapter</i> possui um arsenal completo de m√©todos <i>RecyclerView.Adapter</i> , para que a l√≥gica dos elementos redesenhados possa ser configurada com muito mais flexibilidade.  Al√©m disso, junto com o <i>FragmentStateAdapter,</i> voc√™ pode usar o <i>DiffUtil</i> , que permite automatizar quase completamente o trabalho de notifica√ß√£o de altera√ß√µes. <br><br><img src="https://habrastorage.org/webt/8s/j9/xg/8sj9xgon6lnfcn1thlzbhox2jtw.png"><br><blockquote>  <b>Aten√ß√£o!</b>  Para que os m√©todos <i>notify</i> ... funcionem corretamente (exceto para <i>notifyDataSetChanged</i> ), os <b>m√©todos getItemId (Int)</b> ec <b>ontainsItem (Long)</b> devem ser redefinidos.  Isso √© feito porque a implementa√ß√£o padr√£o olha apenas para o n√∫mero da p√°gina e, por exemplo, se voc√™ adicionar um novo elemento ap√≥s o atual, ele n√£o ser√° adicionado, pois o <i>getItemId</i> permanecer√° inalterado.  Um exemplo de substitui√ß√£o desses dois m√©todos com base em uma lista de elementos do tipo <i>Int</i> : </blockquote><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getItemId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(position: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Long</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items[position].toLong() } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">containsItem</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(itemId: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Long</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> items.contains(itemId.toInt()) }</code> </pre><br><hr><br>  A principal raz√£o para a apar√™ncia do <i>ViewPager2</i> √© a relut√¢ncia em reinventar a roda.  Por um lado, a <b>equipe de</b> desenvolvimento do <b>AndroidX est√°</b> claramente pronta para abandonar o obsoleto <i>ViewPager</i> agora e certamente n√£o vai investir na expans√£o de sua funcionalidade.  Sim e porque?  Afinal, o <i>RecyclerView</i> j√° sabe tudo o que √© necess√°rio.  Por outro lado, a remo√ß√£o e o t√©rmino do suporte a um componente t√£o amplamente usado obviamente n√£o acrescentam lealdade √† comunidade. <br><br>  Para resumir: o <i>ViewPager2 √©</i> definitivamente digno de aten√ß√£o, embora no momento n√£o esteja isento de falhas s√©rias. <br><br><h3>  Contras </h3><br><ul><li>  Umidade e um grande n√∫mero de bugs (desculp√°vel pela vers√£o beta); </li><li>  Proximidade.  <i>O RecyclerView</i> √© um campo <i>privado</i> do <i>ViewPager2</i> , que nos priva de muitas oportunidades: √© imposs√≠vel implementar <i>deslizar para dispensar</i> ou <i>arrastar e soltar</i> (o <b>ItemTouchHelper se</b> conecta diretamente ao <i>RecyclerView</i> ), voc√™ n√£o pode redefinir o <b>ItemAnimator</b> de nenhuma forma, n√£o acesse o <b>LayoutManager</b> diretamente e use o <b>RecycledViewPool</b> .  No entanto, com o lan√ßamento de novas vers√µes do componente, o n√∫mero de m√©todos de interface herdados do <i>RecyclerView</i> est√° aumentando (por exemplo, <i>ItemDecoration</i> ), e podemos esperar adicionar os m√©todos ausentes no futuro. </li></ul><br><h3>  Pr√≥s </h3><br><ul><li>  Suporte para todas as vantagens do <i>RecyclerView.Adapter</i> : combinando elementos de diferentes tipos em uma lista, adicionando e removendo elementos diretamente durante o furto, redesenhando animado o conte√∫do da lista ao mudar; </li><li>  Suporte para todo o espectro de m√©todos de <i>notifica√ß√£o</i> ... e c√°lculo autom√°tico de altera√ß√µes usando o <i>DiffUtil</i> ; </li><li>  Facilidade de transi√ß√£o devido √† continuidade da sintaxe; </li><li>  Suporte para orienta√ß√£o vertical e horizontal "fora da caixa"; </li><li>  Suporte a <i>RTL</i> ; </li><li>  <i>ItemDecorator de</i> suporte; </li><li>  Suporte para <i>rolagem de</i> software atrav√©s de <i>fakeScrollBy ()</i> ; </li><li>  Capacidade de definir manualmente o n√∫mero de itens carregados; </li><li>  A capacidade de usar qualquer uma das solu√ß√µes de c√≥digo aberto prontas para reduzir <i>o c√≥digo padr√£o</i> , o que √© inevit√°vel ao escrever o <i>RecyclerView.Adapter</i> personalizado.  Por exemplo, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><i>EasyAdapter</i></a> . </li></ul><br>  Como resumo, quero dizer que o <b>ViewPager2</b> realmente vale a pena olhar <b>mais de perto</b> .  Esta √© uma solu√ß√£o promissora, extens√≠vel e funcional.  E embora seja muito cedo para lan√ßar um <i>novo widget</i> em produ√ß√£o, √© seguro dizer que, ap√≥s um lan√ßamento completo, ele pode e deve suplantar completamente seu ancestral. <br><br>  Para aqueles ousados ‚Äã‚Äãe decisivos, que o artigo inspirou para experimentar, o <i>PagerSnapHelper</i> apareceu na 28¬™ vers√£o da <b>Biblioteca de suporte</b> , o que significa que voc√™ pode us√°-lo junto com o <i>RecyclerView</i> criando o <i>ViewPager2</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A</a> opera√ß√£o de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">exemplo</a> do <i>ViewPager2</i> e <i>FragmentStateAdapter</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Notas de vers√£o</a> oficiais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">do</a> ViewPager2 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt461873/">https://habr.com/ru/post/pt461873/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt461859/index.html">Voc√™ n√£o sabe nada sobre tecnologia alimentar</a></li>
<li><a href="../pt461861/index.html">Office 365 Cloud Security: teste de ponto de verifica√ß√£o CloudGuard SaaS</a></li>
<li><a href="../pt461865/index.html">Curso em v√≠deo ‚ÄúIntrodu√ß√£o √† revers√£o do zero usando o IDA PRO. Cap√≠tulo 1</a></li>
<li><a href="../pt461867/index.html">Como reconhecer imagens e textos no seu telefone usando o ML Kit</a></li>
<li><a href="../pt461871/index.html">101 dicas para se tornar um bom programador (e humano)</a></li>
<li><a href="../pt461875/index.html">5 nm vs 3 nm</a></li>
<li><a href="../pt461877/index.html">Java vs Kotlin para Android: opini√µes dos desenvolvedores</a></li>
<li><a href="../pt461879/index.html">O livro "Linux em a√ß√£o"</a></li>
<li><a href="../pt461881/index.html">Guia de registro do Node.js.</a></li>
<li><a href="../pt461885/index.html">EDS √© outro tipo de fraude</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>