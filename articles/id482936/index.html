<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ“¥ ğŸ‘©ğŸ¿â€ğŸ¨ ğŸ‘©ğŸ»â€âš–ï¸ Pengantar ASGI: Membangun Ekosistem Web Python Asynchronous ğŸŠ ğŸ‘¨ğŸ¿â€ğŸŒ¾ ğŸ§‘ğŸ¾â€ğŸ¤â€ğŸ§‘ğŸ»</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo, Habr! Saya mempersembahkan kepada Anda terjemahan artikel "Pengantar ASGI: Munculnya Async Python Web Ecosystem" oleh Florimond Manca. 



 "Tur...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pengantar ASGI: Membangun Ekosistem Web Python Asynchronous</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482936/"><p>  Halo, Habr!  Saya mempersembahkan kepada Anda terjemahan artikel <a href="https://florimond.dev/blog/articles/2019/08/introduction-to-asgi-async-python-web/" rel="nofollow">"Pengantar ASGI: Munculnya Async Python Web Ecosystem"</a> oleh Florimond Manca. </p><br><p><img src="https://habrastorage.org/webt/_f/wj/ns/_fwjnsbv7x23ocxkywukxkhn_pu.jpeg"><br>  <em>"Turtles Near The Pond," Ricard Baraham di <a href="https://images.unsplash.com/photo-1482642302383-7ba0f8012849%3Fixlib%3Drb-1.2.1%26ixid%3DeyJhcHBfaWQiOjEyMDd9%26auto%3Dformat%26fit%3Dcrop%26w%3D1051%26q%3D80" rel="nofollow">unsplash.com</a></em> </p><br><p>  Python tidak terbatas pada Ilmu Data, pengembangan web Python telah kembali dengan giliran asinkron baru dalam pengembangan bahasa! </p><br><p>  Banyak peristiwa penting yang terjadi di ekosistem pengembangan web Python.  Salah satu penggerak utama dari perubahan ini adalah <a href="https://asgi.readthedocs.io/en/latest/" rel="nofollow">ASGI</a> - Asynchronous Standard Gateway Interface. </p><br><p>  Saya telah menyebutkan ASGI beberapa kali di blog saya, khususnya, ketika saya mengumumkan <a href="https://florimond.dev/blog/articles/2018/12/how-i-built-a-web-framework-and-became-an-open-source-maintainer/" rel="nofollow">Bocadillo</a> ( <em>kerangka kerja web Python open-source asinkron - kira-kira</em> <a href="https://florimond.dev/blog/articles/2019/07/introducing-tartiflette-starlette/" rel="nofollow">Per</a> <em>.</em> ) Dan <a href="https://florimond.dev/blog/articles/2019/07/introducing-tartiflette-starlette/" rel="nofollow">tartiflette-starlette</a> ( <em>pustaka untuk membangun GraphQL API melalui HTTP melalui ASGI - kira-kira. .</em> ), tapi saya tidak pernah menulis pengantar terperinci tentang dia.  Sekarang saya akan melakukannya. </p><br><p>  Artikel ini ditujukan untuk orang yang tertarik dengan tren terbaru dalam pengembangan web Python.  Saya ingin mengajak Anda bertamasya dari mana Anda akan belajar apa ASGI itu dan apa artinya bagi pengembangan web modern di dunia Python. </p><br><p>  Sebelum kita mulai, saya ingin memberi tahu Anda bahwa saya baru saja membuat <a href="https://github.com/florimondmanca/awesome-asgi" rel="nofollow">awesome-asgi</a> - daftar hebat untuk melacak ekosistem ASGI yang terus berkembang. </p><a name="habracut"></a><br><h3 id="vse-nachalos-s-asyncawait">  Semuanya dimulai dengan async / menunggu </h3><br><p> Tidak seperti JavaScript atau Go, pada saat kemunculannya, Python tidak memberikan kemampuan untuk mengeksekusi kode secara tidak sinkron.  Untuk waktu yang lama, eksekusi kode paralel di Python hanya dapat direalisasikan dengan bantuan multithreaded atau multiprocessing, atau menggunakan pustaka jaringan khusus seperti eventlet, gevent atau Twisted.  (Kembali pada 2008, Twisted memiliki API untuk coroutine asinkron, misalnya, dalam bentuk <a href="http://blog.mekk.waw.pl/archives/14-Twisted-inlineCallbacks-and-deferredGenerator.html" rel="nofollow"><code>inlineCallbacks</code> dan <code>deferredGenerator</code></a> ) </p><br><p>  Semuanya telah berubah dalam Python 3.4+.  Dalam Python 3.4, <a href="https://www.python.org/dev/peps/pep-3156" rel="nofollow">asyncio</a> dimasukkan dalam perpustakaan standar, menghasilkan dukungan untuk multitasking kooperatif berdasarkan generator dan <code>yield from</code> sintaksis. </p><br><p>  Kemudian dalam Python 3.5 <a href="https://www.python.org/dev/peps/pep-0492/" rel="nofollow">, sintaks</a> <code>async/await</code> <a href="https://www.python.org/dev/peps/pep-0492/" rel="nofollow">ditambahkan</a> .  Berkat ini, coroutine asli muncul, terlepas dari implementasi yang mendasari, yang menyebabkan demam emas di sekitar concurrency di Python. </p><br><p>  Perlombaan gila telah dimulai!  Sejak rilis versi 3.5, komunitas telah benar-benar menyinkronkan semua yang ada di sekitarnya.  Jika Anda tertarik, banyak proyek yang dihasilkan terdaftar dalam <a href="https://github.com/aio-libs" rel="nofollow">aio-libs</a> dan <a href="https://github.com/timofurrer/awesome-asyncio" rel="nofollow">awesome-asyncio</a> . </p><br><p>  Seperti yang Anda duga, ini juga berarti bahwa server web dan aplikasi Python bergerak ke arah sinkronisasi.  Faktanya, semua pria keren melakukannya!  ( <a href="" rel="nofollow">Even Django</a> ) ( <em>Habr: <a href="https://habr.com/ru/post/461493/">Django 3.0 akan asinkron</a> , sudah dirilis pada 12/02/2019 - kira-kira.</em> ) </p><br><h3 id="obzor-asgi">  Ulasan ASGI </h3><br><p>  Jadi bagaimana ASGI cocok dengan semua ini? </p><br><p>  ASGI tingkat atas dapat dianggap sebagai tautan yang memungkinkan server dan aplikasi Python asinkron berinteraksi satu sama lain.  Dia mengulangi banyak ide arsitektur dari <a href="https://www.python.org/dev/peps/pep-3333" rel="nofollow">WSGI</a> , dan sering disajikan sebagai penggantinya dengan built-in asynchrony. </p><br><p>  Ini adalah bagaimana itu dapat diwakili pada diagram: </p><br><p><img src="https://habrastorage.org/webt/cw/uz/ji/cwuzjibslnldwwt37-ucuh5v6by.png"></p><br><p>  Pada tingkat yang sangat tinggi, ASGI adalah antarmuka untuk komunikasi antara aplikasi dan server.  Namun pada kenyataannya, semuanya sedikit lebih rumit. </p><br><p>  Untuk memahami bagaimana ASGI benar-benar bekerja, mari kita lihat <a href="https://asgi.readthedocs.io/en/latest/specs/main.html" rel="nofollow">spesifikasi ASGI</a> . </p><br><p>  ASGI terdiri dari dua komponen berbeda: </p><br><ol><li>  Protokol Server - mendengarkan pada soket dan mengubahnya menjadi koneksi dan pesan acara dalam setiap koneksi. </li><li>  Sebuah aplikasi ( <em>aplikasi</em> ), yang hidup di dalam server protokol, instance-nya dibuat satu kali untuk setiap koneksi dan memproses pesan-pesan event ketika terjadi. </li></ol><br><p>  Dengan demikian, sesuai dengan spesifikasi, apa yang sebenarnya ditunjukkan ASGI adalah format pesan dan bagaimana pesan-pesan ini harus ditransfer antara aplikasi dan server protokol yang menjalankannya. </p><br><p>  Sekarang kita dapat membuat versi diagram yang lebih rinci: </p><br><p><img src="https://habrastorage.org/webt/mx/8p/vd/mx8pvdbvnscbq28i8mwmuj5ntu0.png"></p><br><p>  Ada banyak detail lebih menarik dalam protokol.  Misalnya, Anda dapat melihat <a href="https://asgi.readthedocs.io/en/latest/specs/www.html" rel="nofollow">spesifikasi HTTP dan WebSocket</a> . </p><br><p>  Selain itu, meskipun spesifikasinya sangat terfokus pada interaksi antara server dan aplikasi, ASGI berhasil mencakup lebih banyak aspek. </p><br><p>  Kita sampai dalam satu menit, tapi pertama ... </p><br><h3 id="osnovy-asgi">  ASGI Basics </h3><br><p>  Sekarang kita telah melihat bagaimana ASGI masuk ke ekosistem web Python, mari kita lihat lebih dekat bagaimana ini diterjemahkan ke dalam kode. </p><br><p>  ASGI bergantung pada model sederhana: ketika klien terhubung ke server, instance aplikasi dibuat.  Kemudian data yang masuk ditransfer ke aplikasi dan semua data yang dikembalikan dikirim kembali. </p><br><p>  Mengirim data ke aplikasi di sini sebenarnya berarti <em>memanggil aplikasi</em> seolah-olah itu adalah fungsi, mis.  sesuatu yang mengambil input dan mengembalikan output. </p><br><p>  Faktanya, semua yang diwakili oleh aplikasi ASGI adalah <em>callable</em> (disebut objek).  Parameter objek yang disebut ini, sekali lagi, <a href="https://asgi.readthedocs.io/en/latest/specs/main.html" rel="nofollow">ditentukan oleh spesifikasi ASGI</a> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">app</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(scope, receive, send)</span></span></span><span class="hljs-function">:</span></span> ...</code> </pre> <br><p>  Tanda tangan dari fungsi ini adalah persis apa yang berarti "I" dalam "ASGI": antarmuka yang harus diimplementasikan aplikasi agar server dapat memanggilnya. </p><br><p>  Mari kita lihat parameter fungsi: </p><br><ul><li>  <code>scope</code> adalah kamus yang berisi informasi tentang permintaan yang masuk.  Isinya berbeda untuk koneksi <a href="https://asgi.readthedocs.io/en/latest/specs/www.html" rel="nofollow">HTTP</a> dan <a href="https://asgi.readthedocs.io/en/latest/specs/www.html" rel="nofollow">WebSocket</a> . </li><li>  accept adalah fungsi asinkron untuk menerima pesan tentang peristiwa ASGI. </li><li>  <code>send</code> adalah fungsi asinkron untuk mengirim pesan tentang peristiwa ASGI. </li></ul><br><p>  Bahkan, parameter ini memungkinkan Anda untuk menerima ( <code>receive()</code> ) dan mengirimkan ( <code>send()</code> ) data melalui saluran komunikasi yang didukung oleh server protokol, serta memahami dalam konteks (atau <code>scope</code> ) saluran mana yang dibuat saluran ini. </p><br><p>  Saya tidak tahu tentang Anda, tetapi saya sangat suka tampilan umum dan struktur antarmuka ini.  Bagaimanapun, sekarang mari kita lihat kode sampel. </p><br><h3 id="pokazhite-kod">  Tunjukkan kodenya! </h3><br><p>  Untuk mendapatkan gambaran praktis seperti apa ASGI itu, saya membuat proyek minimal pada ASGI telanjang yang menunjukkan aplikasi HTTP yang dilayani oleh <a href="https://www.uvicorn.org/" rel="nofollow">uvicorn</a> (server ASGI populer): </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">app</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(scope, receive, send)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> scope[<span class="hljs-string"><span class="hljs-string">"type"</span></span>] == <span class="hljs-string"><span class="hljs-string">"http"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> send({ <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"http.response.start"</span></span>, <span class="hljs-string"><span class="hljs-string">"status"</span></span>: <span class="hljs-number"><span class="hljs-number">200</span></span>, <span class="hljs-string"><span class="hljs-string">"headers"</span></span>: [ [<span class="hljs-string"><span class="hljs-string">b"content-type"</span></span>, <span class="hljs-string"><span class="hljs-string">b"text/plain"</span></span>], ] }) <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> send({ <span class="hljs-string"><span class="hljs-string">"type"</span></span>: <span class="hljs-string"><span class="hljs-string">"http.response.body"</span></span>, <span class="hljs-string"><span class="hljs-string">"body"</span></span>: <span class="hljs-string"><span class="hljs-string">b"Hello, world!"</span></span>, })</code> </pre> <br><p>  <em>Kode sumber - <a href="https://glitch.com/edit/" rel="nofollow">https://glitch.com/edit/#!/asgi-hello-world</a></em> </p><br><p>  Di sini kami menggunakan <code>send()</code> untuk mengirim respons HTTP ke klien: pertama kami mengirim header, dan kemudian badan respons. </p><br><p>  Saya akui bahwa karena semua kamus dan data biner mentah ini, ASGI telanjang tidak nyaman untuk bekerja. </p><br><p>  Untungnya, ada opsi tingkat yang lebih tinggi - dan saat itulah saya mulai berbicara tentang <a href="https://www.starlette.io/" rel="nofollow">Starlette</a> . </p><br><p>  Starlette adalah proyek yang benar-benar fantastis, dan, menurut pendapat saya, merupakan bagian mendasar dari ekosistem ASGI. </p><br><p>  Secara singkat, ini menyediakan satu set komponen tingkat tinggi, seperti permintaan dan jawaban, yang dapat Anda gunakan untuk abstrak dari beberapa detail ASGI.  Di sini, lihat "hello world" di Starlette: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># app.py from starlette.responses import PlainTextResponse async def app(scope, receive, send): assert scope["type"] == "http" response = PlainTextResponse("Hello, world!") await response(scope, receive, send)</span></span></code> </pre> <br><p>  Starlette memiliki semua yang Anda harapkan dari kerangka kerja nyata - perutean, middleware, dll.  Tapi saya memutuskan untuk menunjukkan versi ini untuk mengisyaratkan kekuatan ASGI yang sebenarnya, yaitu ... </p><br><h3 id="cherepahi-na-vsem-puti">  Kura-kura sepanjang jalan </h3><br><p>  Konsep yang menarik dan mengubah aturan untuk ASGI adalah <a href="https://simonwillison.net/2019/Jun/23/datasette-asgi/" rel="nofollow">Turtles All the Way</a> , sebuah ekspresi yang awalnya diciptakan (menurut saya?) Oleh Andrew Godwin, yang menciptakan Django Migrations dan saat ini sedang mengerjakan <a href="https://www.youtube.com/watch%3Fv%3DoMHrDy62kgE" rel="nofollow">Django untuk mendukung asynchrony</a> . </p><br><p>  Tapi apa sebenarnya artinya ini? </p><br><p>  Karena ASGI adalah abstraksi yang memungkinkan kita untuk mengatakan dalam konteks apa kita berada dan untuk menerima dan mengirim data kapan saja, ada ide bahwa ASGI dapat digunakan tidak hanya antara server dan aplikasi, tetapi juga benar-benar di mana saja di tumpukan. </p><br><p>  Misalnya, objek <code>Response</code> Starlette adalah aplikasi ASGI itu sendiri.  Bahkan, kita dapat mempersingkat kode dalam contoh aplikasi di atas menjadi ini: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># app.py app = PlainTextResponse("Hello, world!")</span></span></code> </pre> <br><p>  Betapa konyolnya itu terlihat ?! </p><br><p>  Tapi tunggu, itu belum semuanya. </p><br><p>  Konsekuensi yang lebih dalam dari "turtles all the way" adalah bahwa kita dapat membuat semua jenis aplikasi, middleware, perpustakaan dan proyek lainnya dan memastikan bahwa mereka kompatibel selama mereka semua mengimplementasikan antarmuka aplikasi ASGI. </p><br><p>  (Selain itu, dari pengalaman pribadi saya membangun <a href="https://bocadilloproject.github.io/" rel="nofollow">Bocadillo</a> , sangat sering menerima antarmuka ASGI (jika tidak selalu) mengarah ke kode yang lebih bersih) </p><br><p>  Misalnya, kita dapat membuat middleware ASGI (mis. Aplikasi yang membungkus aplikasi lain) untuk menampilkan waktu yang dibutuhkan untuk permintaan untuk diselesaikan: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># app.py import time class TimingMiddleware: def __init__(self, app): self.app = app async def __call__(self, scope, receive, send): start_time = time.time() await self.app(scope, receive, send) end_time = time.time() print(f"Took {end_time - start_time:.2f} seconds")</span></span></code> </pre> <br><p>  Untuk menggunakannya, kami cukup membungkus aplikasi dengan itu ... </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># app.py import asyncio from starlette.responses import PlainTextResponse async def app(scope, receive, send): await asyncio.sleep(1) response = PlainTextResponse("Hello, world!") await response(scope, receive, send) app = TimingMiddleware(app)</span></span></code> </pre> <br><p>  ... dan secara ajaib itu hanya akan berfungsi. </p><br><pre> <code class="plaintext hljs">$ uvicorn app:app INFO: Started server process [59405] INFO: Waiting for application startup. INFO: Uvicorn running on http://127.0.0.1:8000 (Press CTRL+C to quit) ... INFO: ('127.0.0.1', 62718) - "GET / HTTP/1.1" 200 Took 1.00 seconds</code> </pre> <br><p>  Sungguh <code>TimingMiddleware</code> bahwa di <code>TimingMiddleware</code> Anda dapat membungkus aplikasi ASGI.  Aplikasi internal dalam contoh ini sangat sederhana, tetapi bisa menjadi proyek nyata yang lengkap (bayangkan ratusan API dan titik akhir WebSocket) - tidak masalah selama antarmuka kompatibel dengan ASGI. </p><br><p>  (Ada versi middleware ini yang lebih siap untuk keperluan industri: <a href="https://github.com/steinnes/timing-asgi" rel="nofollow">timing-asgi</a> .) </p><br><h3 id="pochemu-eto-dolzhno-volnovat">  Kenapa harus repot? </h3><br><p>  Sementara saya pikir kompatibilitas adalah argumen yang sangat kuat, ada banyak keuntungan menggunakan komponen berbasis ASGI untuk membangun aplikasi web Python. </p><br><ul><li>  Kecepatan: Sifat asinkron dari aplikasi dan server ASGI membuatnya <a href="https://www.techempower.com/benchmarks/" rel="nofollow">sangat cepat</a> (setidaknya untuk Python) - kita berbicara tentang permintaan 60k-70k per detik (dengan asumsi bahwa Flask dan Django hanya mencapai 10-20k dalam situasi yang sama). </li><li>  Fitur: Server dan platform ASGI memberi Anda akses ke fungsi-fungsi paralel yang esensial (WebSocket, Server-Sent Events, HTTP / 2) yang tidak dapat diimplementasikan menggunakan kode sinkron dan WSGI. </li><li>  Stabilitas: ASGI sebagai spesifikasi telah ada selama 3 tahun, dan versi 3.0 dianggap sangat stabil.  Akibatnya, bagian utama ekosistem menjadi stabil. </li></ul><br><p>  Dari sudut pandang perpustakaan dan alat, saya tidak berpikir bahwa kita dapat mengatakan bahwa kita telah mencapai tingkat yang diperlukan.  Tetapi berkat komunitas yang sangat aktif, saya memiliki harapan besar bahwa ekosistem ASGI akan segera mencapai kesamaan fungsi dengan ekosistem sinkron / WSGI tradisional. </p><br><h3 id="gde-mozhno-nayti-komponenty-sovmestimye-s-asgi">  Di mana saya dapat menemukan komponen yang kompatibel dengan ASGI? </h3><br><p>  Bahkan, semakin banyak orang membangun dan meningkatkan proyek berdasarkan ASGI.  Jelas ini adalah server dan kerangka kerja web, tetapi ada aplikasi middleware dan berorientasi produk seperti <a href="https://github.com/simonw/datasette" rel="nofollow">Datasette</a> juga. </p><br><p>  Berikut adalah beberapa contoh komponen non-web yang menarik minat saya: </p><br><ul><li>  <a href="https://github.com/erm/mangum" rel="nofollow">Mangum</a> : Dukungan ASGI untuk AWS Lambda. </li><li>  <a href="https://github.com/simonw/datasette-auth-github" rel="nofollow">datasetette-auth-github</a> : otentikasi GitHub untuk aplikasi ASGI. </li><li>  <a href="https://github.com/tartiflette/tartiflette-starlette" rel="nofollow">tartiflette-starlette</a> (saya menulisnya!): Dukungan ASGI untuk Tartiflette, sebuah mesin GraphQL asinkron. </li></ul><br><p>  Sungguh menakjubkan untuk mengamati bahwa ekosistem berkembang dengan sukses, namun, secara pribadi sulit bagi saya secara pribadi untuk mengikuti perubahan. </p><br><p>  Itu sebabnya saya membuat <a href="https://github.com/florimondmanca/awesome-asgi" rel="nofollow">asgi yang luar biasa</a> .  Saya harap ini membantu semua orang mengikuti semua hal menakjubkan yang terjadi di dunia ASGI.  (Dan melihat bahwa ia hampir mencapai 100 bintang dalam beberapa hari, saya merasa bahwa benar-benar ada kebutuhan untuk mengumpulkan informasi tentang sumber daya ASGI di satu tempat.) </p><br><h3 id="vyvody">  Kesimpulan </h3><br><p>  Meskipun ini mungkin terlihat seperti detail implementasi, saya yakin ASGI telah meletakkan dasar untuk era baru dalam pengembangan web Python. </p><br><p>  Jika Anda ingin mempelajari lebih lanjut tentang ASGI, periksa berbagai <a href="https://github.com/florimondmanca/awesome-asgi" rel="nofollow">publikasi</a> (artikel dan pidato) yang terdaftar di <code>awesome-asgi</code> .  Jika Anda ingin menyentuhnya, coba salah satu proyek berikut: </p><br><ul><li>  <a href="https://www.uvicorn.org/" rel="nofollow">uvicorn</a> : server <a href="https://www.uvicorn.org/" rel="nofollow">ASGI</a> . </li><li>  <a href="https://www.starlette.io/" rel="nofollow">Starlette</a> : framework ASGI. </li><li>  <em><a href="https://fastapi.tiangolo.com/" rel="nofollow">FastAPI</a> , <a href="https://habr.com/ru/post/478620/">sebuah artikel tentang Habr</a> : kerangka kerja yang didasarkan pada Starlette dan Pydantic (terima kasih <a href="https://habr.com/ru/users/morz3/" class="user_link">morz3</a> , <a href="https://habr.com/ru/users/morz3/" class="user_link">kira-kira Per</a> .)</em> </li><li>  <a href="https://www.encode.io/typesystem/" rel="nofollow">TypeSystem</a> : validasi data dan rendering formulir. </li><li>  <a href="https://www.encode.io/databases/" rel="nofollow">Basis data</a> : pustaka database asinkron. </li><li>  <a href="https://github.com/encode/orm" rel="nofollow">orm</a> : ORM sinkron. </li><li>  <a href="httpx/" rel="nofollow">HTTPX</a> : klien HTTP asinkron dengan dukungan untuk memanggil aplikasi ASGI (berguna sebagai klien untuk pengujian). </li></ul><br><p>  Proyek-proyek ini dibuat dan didukung oleh Encode, terutama Tom Christie.  Ada diskusi terbuka tentang cara <a href="https://discuss.encode.io/t/setting-up-a-maintainence-team/721/9" rel="nofollow">membuat tim dukungan Encode</a> , jadi jika Anda mencari peluang untuk berpartisipasi dalam pengembangan sumber terbuka, maka Anda memiliki kesempatan seperti itu! </p><br><p>  Bersenang-senang bepergian ke dunia ASGI! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id482936/">https://habr.com/ru/post/id482936/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id482926/index.html">Arc adalah sistem kontrol versi untuk monorepositori. Laporan Yandex</a></li>
<li><a href="../id482928/index.html">Visi Predator: Efek Penglihatan Termal</a></li>
<li><a href="../id482930/index.html">Penelitian silsilah - buku metrik, sensus, arsip, database terbuka</a></li>
<li><a href="../id482932/index.html">IIoT - atau bagaimana membantu karyawan menggunakan otak mereka sebagaimana dimaksud</a></li>
<li><a href="../id482934/index.html">Kegagalan proyek ERP (Liqui Moly, Otto, dan lainnya seperti dia)</a></li>
<li><a href="../id482938/index.html">Penerapan prinsip-prinsip pemrograman fungsional dalam desain ERP</a></li>
<li><a href="../id482940/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 396 (30 Desember 2019 - 5 Januari 2020)</a></li>
<li><a href="../id482942/index.html">Mitos dan legenda Fediverse kuno</a></li>
<li><a href="../id482944/index.html">Dispenser Konveyor Multi Komponen</a></li>
<li><a href="../id482946/index.html">1Ğ¡ DSS dan estimasi syarat dan biaya proyek dengan metode COCOMO II</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>