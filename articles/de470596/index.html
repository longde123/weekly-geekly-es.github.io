<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüëß‚Äçüëß üï∏Ô∏è üèáüèΩ Funktionen von Q und KDB + am Beispiel eines Echtzeitdienstes üåª üî™ ü§∂üèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Was KDB + ist, die Q-Programmiersprache, welche St√§rken und Schw√§chen sie haben, finden Sie in meinem vorherigen Artikel und kurz in der Einleitung. I...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funktionen von Q und KDB + am Beispiel eines Echtzeitdienstes</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dbtc/blog/470596/">  Was KDB + ist, die Q-Programmiersprache, welche St√§rken und Schw√§chen sie haben, finden Sie in meinem vorherigen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel</a> und kurz in der Einleitung.  In diesem Artikel implementieren wir einen Dienst f√ºr Q, der den eingehenden Datenstrom verarbeitet und verschiedene Aggregationsfunktionen pro Minute im Echtzeitmodus berechnet (dh es bleibt Zeit, alles bis zum n√§chsten Datenelement zu berechnen).  Das Hauptmerkmal von Q ist, dass es sich um eine Vektorsprache handelt, mit der Sie nicht mit einzelnen Objekten arbeiten k√∂nnen, sondern mit ihren Arrays, Arrays von Arrays und anderen komplexen Objekten.  Sprachen wie Q und die damit verbundenen Sprachen K, J, APL sind bekannt f√ºr ihre K√ºrze.  Oft kann ein Programm, das mehrere Codebildschirme in einer vertrauten Sprache wie Java umfasst, in mehreren Zeilen darauf geschrieben werden.  Genau das m√∂chte ich in diesem Artikel demonstrieren. <br><br><img src="https://habrastorage.org/webt/wb/ej/zy/wbejzyzkg_-aypnh92it6kecrtq.jpeg"><br><a name="habracut"></a><br><h3>  Einf√ºhrung </h3><br>  KDB + ist eine Spaltendatenbank, die sich auf sehr gro√üe Datenmengen konzentriert und auf bestimmte Weise (haupts√§chlich nach Zeit) sortiert ist.  Es wird vor allem in Finanzorganisationen eingesetzt - Banken, Investmentfonds, Versicherungsunternehmen.  Q-Sprache ist eine interne Sprache von KDB +, mit der Sie effektiv mit diesen Daten arbeiten k√∂nnen.  Die Ideologie von Q ist K√ºrze und Effizienz, w√§hrend Klarheit geopfert wird.  Dies wird durch die Tatsache gerechtfertigt, dass die Vektorsprache in jedem Fall schwer wahrzunehmen ist und die K√ºrze und der Reichtum der Aufnahme es Ihnen erm√∂glichen, einen viel gr√∂√üeren Teil des Programms auf einem Bildschirm zu sehen, was letztendlich das Verst√§ndnis erleichtert. <br><br>  In diesem Artikel implementieren wir ein vollwertiges Q-Programm, das Sie vielleicht ausprobieren m√∂chten.  Dazu ben√∂tigen Sie das aktuelle Q. Sie k√∂nnen die kostenlose 32-Bit-Version von der Website des kx-Unternehmens herunterladen - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.kx.com</a> .  Wenn Sie interessiert sind, finden Sie an derselben Stelle Referenzinformationen zu Q, dem Buch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Q For Mortals</a> und verschiedenen Artikeln zu diesem Thema. <br><br><h3>  Erkl√§rung des Problems </h3><br>  Es gibt eine Quelle, die alle 25 Millisekunden eine Datentabelle sendet.  Da KDB + haupts√§chlich im Finanzbereich verwendet wird, gehen wir davon aus, dass es sich um eine <b>Handelstabelle handelt</b> , in der die folgenden Spalten enthalten sind: Zeit (Zeit in Millisekunden), sym (Firmenname an der B√∂rse - <b>IBM</b> , <b>AAPL</b> , ...), Preis (Preis) durch welche Aktien gekauft wurden), Gr√∂√üe (Transaktionsgr√∂√üe).  Ein Intervall von 25 Millisekunden wird willk√ºrlich gew√§hlt, es ist nicht zu klein und nicht zu gro√ü.  Seine Anwesenheit bedeutet, dass die beim Dienst eintreffenden Daten bereits gepuffert sind.  Es w√§re einfach, die Pufferung auf der Serviceseite zu implementieren, einschlie√ülich der dynamischen Pufferung, abh√§ngig von der aktuellen Last, aber der Einfachheit halber bleiben wir bei einem festen Intervall. <br><br>  Der Dienst sollte jede Minute f√ºr jedes eingehende Zeichen aus der Sym-Spalte eine Reihe von Aggregationsfunktionen z√§hlen - Maximalpreis, Durchschnittspreis, Summengr√∂√üe usw.  n√ºtzliche Informationen.  Der Einfachheit halber nehmen wir an, dass alle Funktionen inkrementell berechnet werden k√∂nnen, d.h.  Um einen neuen Wert zu erhalten, reicht es aus, zwei Zahlen zu kennen - die alte und die eingehende.  Beispielsweise haben die Funktionen max, durchschnitt, sum diese Eigenschaft, die Medianfunktion jedoch nicht. <br><br>  Wir gehen auch davon aus, dass der eingehende Datenstrom nach Zeit geordnet ist.  Dies gibt uns die M√∂glichkeit, nur in letzter Minute zu arbeiten.  In der Praxis reicht es aus, mit den aktuellen und vorherigen Minuten arbeiten zu k√∂nnen, falls Aktualisierungen versp√§tet sind.  Der Einfachheit halber werden wir diesen Fall nicht betrachten. <br><br><h3>  Aggregierte Funktionen </h3><br>  Nachfolgend sind die erforderlichen Aggregatfunktionen aufgef√ºhrt.  Ich habe sie so weit wie m√∂glich genommen, um die Belastung des Dienstes zu erh√∂hen: <br><br><ul><li>  hoch - maximaler Preis - maximaler Preis pro Minute. </li><li>  Niedrigpreis - Der Mindestpreis pro Minute. </li><li>  firstPrice - erster Preis - der erste Preis pro Minute. </li><li>  lastPrice - letzter Preis - der letzte Preis pro Minute. </li><li>  firstSize - erste Gr√∂√üe - die erste Deal-Gr√∂√üe in einer Minute. </li><li>  lastSize - letzte Gr√∂√üe - die letzte Deal-Gr√∂√üe in einer Minute. </li><li>  numTrades - count i - die Anzahl der Transaktionen pro Minute. </li><li>  Volumen - Summengr√∂√üe - Die Summe der Transaktionsgr√∂√üen pro Minute. </li><li>  pvolume - sum price - die Summe der Preise pro Minute, die f√ºr avgPrice erforderlich sind. </li><li>  Umsatz - Summenpreis * Gr√∂√üe - Gesamtvolumen der Transaktionen pro Minute. </li><li>  avgPrice - pvolume% numTrades - Durchschnittspreis pro Minute. </li><li>  avgSize - Volumen% numTrades - durchschnittliche Gesch√§ftsgr√∂√üe pro Minute. </li><li>  vwap - Umsatz% Volumen - der durchschnittliche Preis pro Minute, gewichtet nach der Gr√∂√üe der Transaktion. </li><li>  cumVolume - Summenvolumen - akkumulierte Transaktionsgr√∂√üe f√ºr die gesamte Zeit. </li></ul><br>  Besprechen Sie sofort einen nicht offensichtlichen Punkt - wie diese Spalten zum ersten Mal und f√ºr jede n√§chste Minute initialisiert werden.  Einige Spalten des Typs firstPrice m√ºssen jedes Mal mit null initialisiert werden, ihr Wert ist nicht definiert.  Andere Datentr√§gertypen m√ºssen immer auf 0 gesetzt werden. Es gibt immer noch Spalten, die einen kombinierten Ansatz erfordern. Beispielsweise muss cumVolume aus der vorherigen Minute und f√ºr den ersten auf 0 kopiert werden. Alle diese Parameter werden mithilfe des Datentypw√∂rterbuchs (analog zum Datensatz) festgelegt: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// list ! list ‚Äì  , 0n ‚Äì float null, 0N ‚Äì long null, `sym ‚Äì  , `sym1`sym2 ‚Äì   initWith:`sym`time`high`low`firstPrice`lastPrice`firstSize`lastSize`numTrades`volume`pvolume`turnover`avgPrice`avgSize`vwap`cumVolume!(`;00:00;0n;0n;0n;0n;0N;0N;0;0;0.0;0.0;0n;0n;0n;0); aggCols:reverse key[initWith] except `sym`time; //    , reverse  </span></span></code> </pre> <br>  Ich habe dem W√∂rterbuch zur Vereinfachung sym und time hinzugef√ºgt. Jetzt ist initWith eine fertige Zeile aus der endg√ºltigen aggregierten Tabelle, in der das richtige sym und die richtige Zeit festgelegt werden m√ºssen.  Sie k√∂nnen es verwenden, um der Tabelle neue Zeilen hinzuzuf√ºgen. <br><br>  aggCols ben√∂tigen wir beim Erstellen einer Aggregatfunktion.  Die Liste muss aufgrund der Besonderheiten der Reihenfolge, in der Ausdr√ºcke in Q berechnet werden (von rechts nach links), invertiert werden.  Das Ziel besteht darin, eine Berechnung in Richtung von hoch nach cumVolume bereitzustellen, da einige Spalten von den vorherigen Spalten abh√§ngig sind. <br><br>  Spalten, die von der vorherigen in eine neue Minute kopiert werden sollen, sym-Spalte zur Vereinfachung hinzugef√ºgt: <br><br><pre> <code class="cpp hljs">rollColumns:`sym`cumVolume;</code> </pre><br>  Jetzt teilen wir die Spalten in Gruppen ein, je nachdem, wie sie aktualisiert werden sollen.  Drei Typen k√∂nnen unterschieden werden: <br><br><ol><li>  Batterien (Volumen, Umsatz, ..) - Wir m√ºssen den Eingabewert zum vorherigen hinzuf√ºgen. </li><li>  Mit einem speziellen Punkt (hoch, niedrig, ..) - der erste Wert in einer Minute wird aus den Eingabedaten entnommen, der Rest wird mit der Funktion gez√§hlt. </li><li>  Der Rest.  Immer mit einer Funktion gez√§hlt. </li></ol><br>  Definieren Sie Variablen f√ºr diese Klassen: <br><br><pre> <code class="cpp hljs">accumulatorCols:`numTrades`volume`pvolume`turnover; specialCols:`high`low`firstPrice`firstSize;</code> </pre><br><h3>  Berechnungsreihenfolge </h3><br>  Wir werden die aggregierte Tabelle in zwei Schritten aktualisieren.  Aus Effizienzgr√ºnden verkleinern wir zuerst die eingehende Tabelle, sodass f√ºr jedes Zeichen und jede Minute eine Zeile √ºbrig bleibt.  Die Tatsache, dass alle unsere Funktionen inkrementell und assoziativ sind, garantiert uns, dass sich das Ergebnis dieses zus√§tzlichen Schritts nicht √§ndert.  Sie k√∂nnen die Tabelle mit der Auswahl dr√ºcken: <br><br><pre> <code class="cpp hljs">select high:max price, low:min price ‚Ä¶ by sym,time.minute from table</code> </pre><br>  Diese Methode hat ein Minus - die Menge der berechneten Spalten ist vordefiniert.  Gl√ºcklicherweise wird die Auswahl in Q auch als eine Funktion implementiert, mit der Sie dynamisch erstellte Argumente ersetzen k√∂nnen: <br><br><pre> <code class="cpp hljs">?[table;whereClause;byClause;selectClause]</code> </pre><br>  Ich werde das Format der Argumente nicht im Detail beschreiben, in unserem Fall sind nur durch und ausgew√§hlte Ausdr√ºcke nicht trivial und sie sollten W√∂rterb√ºcher der Formularspalten sein! Ausdr√ºcke.  Somit kann die Einschn√ºrungsfunktion wie folgt definiert werden: <br><br><pre> <code class="cpp hljs">selExpression:`high`low`firstPrice`lastPrice`firstSize`lastSize`numTrades`volume`pvolume`turnover!<span class="hljs-function"><span class="hljs-function">parse </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">each</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"max price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"min price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"first price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"last price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"first size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"last size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"count i"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"sum size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"sum price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"sum price*size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// each   map  Q    preprocess:?[;();`sym`time!`sym`time.minute;selExpression];</span></span></code> </pre><br>  Aus Gr√ºnden der √úbersichtlichkeit habe ich die Analysefunktion verwendet, die einen String mit einem Q-Ausdruck in einen Wert umwandelt, der an die eval-Funktion √ºbergeben werden kann und der in der Funktionsauswahl erforderlich ist.  Beachten Sie auch, dass der Vorprozess als Projektion (d. H. Als Funktion mit teilweise definierten Argumenten) der Auswahlfunktion definiert ist und ein Argument (Tabelle) fehlt.  Wenn wir einen Vorprozess auf eine Tabelle anwenden, erhalten wir eine geschrumpfte Tabelle. <br><br>  In der zweiten Phase wird die aggregierte Tabelle aktualisiert.  Zuerst schreiben wir den Algorithmus im Pseudocode: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> each sym in inputTable idx: row index in agg table <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> sym+currentTime; aggTable[idx;`high]: aggTable[idx;`high] | inputTable[sym;`high]; aggTable[idx;`volume]: aggTable[idx;`volume] + inputTable[sym;`volume]; ‚Ä¶</code> </pre><br>  In Q ist es √ºblich, anstelle von Schleifen Map / Reduce-Funktionen zu verwenden.  Da Q jedoch eine Vektorsprache ist und alle Operationen sicher auf alle Symbole gleichzeitig angewendet werden k√∂nnen, k√∂nnen wir in erster N√§herung √ºberhaupt auf einen Zyklus verzichten und Operationen mit allen Symbolen gleichzeitig ausf√ºhren: <br><br><pre> <code class="cpp hljs">idx:calcIdx inputTable; row:aggTable idx; aggTable[idx;`high]: row[`high] | inputTable`high; aggTable[idx;`volume]: row[`volume] + inputTable`volume; ‚Ä¶</code> </pre><br>  Aber wir k√∂nnen noch weiter gehen, in Q gibt es einen einzigartigen und √§u√üerst leistungsf√§higen Operator - den generalisierten Zuweisungsoperator.  Sie k√∂nnen den Wertesatz in einer komplexen Datenstruktur mithilfe einer Liste von Indizes, Funktionen und Argumenten √§ndern.  In unserem Fall sieht es so aus: <br><br><pre> <code class="cpp hljs">idx:calcIdx inputTable; rows:aggTable idx; <span class="hljs-comment"><span class="hljs-comment">// .[target;(idx0;idx1;..);function;argument] ~ target[idx 0;idx 1;‚Ä¶]: function[target[idx 0;idx 1;‚Ä¶];argument],     ‚Äì   .[aggTable;(idx;aggCols);:;flip (row[`high] | inputTable`high;row[`volume] + inputTable`volume;‚Ä¶)];</span></span></code> </pre><br>  Um einer Tabelle zuzuweisen, ben√∂tigen Sie leider eine Liste von Zeilen, keine Spalten, und Sie m√ºssen die Matrix (Liste der Spalten in eine Liste von Zeilen) mithilfe der Flip-Funktion transponieren.  F√ºr eine gro√üe Tabelle ist dies nicht erforderlich. Stattdessen wenden wir die verallgemeinerte Zuordnung mithilfe der Kartenfunktion (die wie ein Apostroph aussieht) separat auf jede Spalte an: <br><br><pre> <code class="sql hljs">.[aggTable;;:;]'[(idx;)each aggCols; (row[`high] | inputTable`high;row[`volume] + inputTable`volume;‚Ä¶)];</code> </pre><br>  Wir verwenden wieder die Projektionsfunktion.  Beachten Sie auch, dass das Erstellen einer Liste in Q auch eine Funktion ist und wir sie mit der Funktion each (map) aufrufen k√∂nnen, um eine Liste von Listen zu erhalten. <br><br>  Damit die Menge der berechneten Spalten nicht festgelegt wird, erstellen Sie den obigen Ausdruck dynamisch.  Zun√§chst definieren wir die Funktionen zur Berechnung jeder Spalte, wobei wir die Variablen row und inp verwenden, um auf aggregierte Daten und Eingabedaten zu verweisen: <br><br><pre> <code class="cpp hljs">aggExpression:`high`low`firstPrice`lastPrice`firstSize`lastSize`avgPrice`avgSize`vwap`cumVolume! (<span class="hljs-string"><span class="hljs-string">"row[`high]|inp`high"</span></span>;<span class="hljs-string"><span class="hljs-string">"row[`low]&amp;inp`low"</span></span>;<span class="hljs-string"><span class="hljs-string">"row`firstPrice"</span></span>;<span class="hljs-string"><span class="hljs-string">"inp`lastPrice"</span></span>;<span class="hljs-string"><span class="hljs-string">"row`firstSize"</span></span>;<span class="hljs-string"><span class="hljs-string">"inp`lastSize"</span></span>;<span class="hljs-string"><span class="hljs-string">"pvolume%numTrades"</span></span>;<span class="hljs-string"><span class="hljs-string">"volume%numTrades"</span></span>;<span class="hljs-string"><span class="hljs-string">"turnover%volume"</span></span>;<span class="hljs-string"><span class="hljs-string">"row[`cumVolume]+inp`volume"</span></span>);</code> </pre><br>  Einige Spalten sind speziell, ihr erster Wert sollte nicht von einer Funktion berechnet werden.  Wir k√∂nnen feststellen, dass es das erste in der Spaltenzeile [`numTrades] ist - wenn es 0 hat, ist der Wert zuerst.  Q hat eine Auswahlfunktion -? [Boolesche Liste; Liste1; Liste2] - die einen Wert aus Liste 1 oder 2 ausw√§hlt, abh√§ngig von der Bedingung im ersten Argument: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// high -&gt; ?[isFirst;inp`high;row[`high]|inp`high] // @ -         @[`aggExpression;specialCols;{[x;y]"?[isFirst;inp`",y,";",x,"]"};string specialCols];</span></span></code> </pre><br>  Hier habe ich mit meiner Funktion eine generische Zuordnung aufgerufen (Ausdruck in geschweiften Klammern).  Der aktuelle Wert (das erste Argument) und ein zus√§tzliches Argument, das ich im 4. Parameter √ºbergebe, werden an ihn √ºbergeben. <br><br>  Separat f√ºgen wir Batterielautsprecher hinzu, da f√ºr sie die gleiche Funktion gilt: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// volume -&gt; row[`volume]+inp`volume aggExpression[accumulatorCols]:{"row[`",x,"]+inp`",x } each string accumulatorCols;</span></span></code> </pre><br>  Dies ist eine √ºbliche Zuordnung nach den Standards von Q, ich weise nur eine Liste von Werten gleichzeitig zu.  Erstellen Sie schlie√ülich die Hauptfunktion: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ":",/:aggExprs ~ map[{":",x};aggExpr] =&gt; ":row[`high]|inp`high"    ,          // string[cols],'exprs ~ map[,;string[cols];exprs] =&gt; "high:row[`high]|inp`high"   . ,'   map[concat] // ";" sv exprs ‚Äì String from Vector (sv),     ‚Äú;‚Äù  updateAgg:value "{[aggTable;idx;inp] row:aggTable idx; isFirst:0=row`numTrades; .[aggTable;;:;]'[(idx;)each aggCols;(",(";"sv string[aggCols],'":",/:aggExpression aggCols),")]}";</span></span></code> </pre><br>  Mit diesem Ausdruck erstelle ich dynamisch eine Funktion aus einer Zeichenfolge, die den oben zitierten Ausdruck enth√§lt.  Das Ergebnis sieht folgenderma√üen aus: <br><br><pre> <code class="sql hljs">{[aggTable;idx;inp] rows:aggTable idx; isFirst:0=row`numTrades; .[aggTable;;:;]'[(idx;)each aggCols ;(cumVolume:row[`cumVolume]+inp`cumVolume;‚Ä¶ ; high:?[isFirst;inp`high;row[`high]|inp`high])]}</code> </pre><br>  Die Berechnungsreihenfolge der Spalten ist invertiert, da in Q die Berechnungsreihenfolge von rechts nach links ist. <br><br>  Jetzt haben wir zwei Hauptfunktionen, die f√ºr Berechnungen erforderlich sind. Es bleibt noch ein wenig Infrastruktur hinzuzuf√ºgen, und der Dienst ist bereit. <br><br><h3>  Letzte Schritte </h3><br>  Wir haben Preprocess- und UpdateAgg-Funktionen, die die ganze Arbeit erledigen.  Es ist jedoch weiterhin erforderlich, den korrekten √úbergang in Minuten sicherzustellen und die Indizes f√ºr die Aggregation zu berechnen.  Zuerst definieren wir die Init-Funktion: <br><br><pre> <code class="cpp hljs">init:{ tradeAgg:: <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-meta"><span class="hljs-meta">#enlist[initWith]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//    , enlist    ,  0#   0    currTime::00:00; //   0, :: ,      currSyms::`u#`symbol$(); // `u# -    ,     offset::0; //   tradeAgg,     rollCache:: `sym xkey update `u#sym from rollColumns#tradeAgg; //     roll ,    sym }</span></span></span></span></code> </pre><br>  Wir definieren auch die Rollfunktion, die die aktuelle Minute √§ndert: <br><br><pre> <code class="cpp hljs">roll:{[tm] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>[currTime&gt;tm; :init[]]; <span class="hljs-comment"><span class="hljs-comment">//    ,    init rollCache,::offset _ rollColumns#tradeAgg; //   ‚Äì  roll   aggTable, ,   rollCache offset::count tradeAgg; currSyms::`u#`$(); }</span></span></code> </pre><br>  Wir brauchen eine Funktion, um neue Zeichen hinzuzuf√ºgen: <br><br><pre> <code class="java hljs">addSyms:{[syms] currSyms,::syms; <span class="hljs-comment"><span class="hljs-comment">//     //    sym, time  rollColumns   . //  ^      roll ,     . value flip table     . `tradeAgg upsert @[count[syms]#enlist initWith;`sym`time,cols rc;:;(syms;currTime), (initWith cols rc)^value flip rc:rollCache ([] sym: syms)]; }</span></span></code> </pre><br>  Und schlie√ülich die Upd-Funktion (der traditionelle Name dieser Funktion f√ºr Q-Services), die vom Client aufgerufen wird, um Daten hinzuzuf√ºgen: <br><br><pre> <code class="cpp hljs">upd:{[tblName;data] <span class="hljs-comment"><span class="hljs-comment">// tblName   ,       tm:exec distinct time from data:() xkey preprocess data; // preprocess &amp; calc time updMinute[data] each tm; //      }; updMinute:{[data;tm] if[tm&lt;&gt;currTime; roll tm; currTime::tm]; //  ,   data:select from data where time=tm; //  if[count msyms:syms where not (syms:data`sym)in currSyms; addSyms msyms]; //   updateAgg[`tradeAgg;offset+currSyms?syms;data]; //   .  ?        . };</span></span></code> </pre><br>  Das ist alles.  Hier ist der vollst√§ndige Code unseres Service, wie versprochen, nur ein paar Zeilen: <br><br><pre> <code class="cpp hljs">initWith:`sym`time`high`low`firstPrice`lastPrice`firstSize`lastSize`numTrades`volume`pvolume`turnover`avgPrice`avgSize`vwap`cumVolume!(`;<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>;<span class="hljs-number"><span class="hljs-number">0</span></span>n;<span class="hljs-number"><span class="hljs-number">0</span></span>n;<span class="hljs-number"><span class="hljs-number">0</span></span>n;<span class="hljs-number"><span class="hljs-number">0</span></span>n;<span class="hljs-number"><span class="hljs-number">0</span></span>N;<span class="hljs-number"><span class="hljs-number">0</span></span>N;<span class="hljs-number"><span class="hljs-number">0</span></span>;<span class="hljs-number"><span class="hljs-number">0</span></span>;<span class="hljs-number"><span class="hljs-number">0.0</span></span>;<span class="hljs-number"><span class="hljs-number">0.0</span></span>;<span class="hljs-number"><span class="hljs-number">0</span></span>n;<span class="hljs-number"><span class="hljs-number">0</span></span>n;<span class="hljs-number"><span class="hljs-number">0</span></span>n;<span class="hljs-number"><span class="hljs-number">0</span></span>); aggCols:reverse key[initWith] except `sym`time; rollColumns:`sym`cumVolume; accumulatorCols:`numTrades`volume`pvolume`turnover; specialCols:`high`low`firstPrice`firstSize; selExpression:`high`low`firstPrice`lastPrice`firstSize`lastSize`numTrades`volume`pvolume`turnover!<span class="hljs-function"><span class="hljs-function">parse </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">each</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"max price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"min price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"first price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"last price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"first size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"last size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"count i"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"sum size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"sum price"</span></span></span></span><span class="hljs-function"><span class="hljs-params">;</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"sum price*size"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; preprocess:?[;();`sym`time!`sym`time.minute;selExpression]; aggExpression:`high`low`firstPrice`lastPrice`firstSize`lastSize`avgPrice`avgSize`vwap`cumVolume!(<span class="hljs-string"><span class="hljs-string">"row[`high]|inp`high"</span></span>;<span class="hljs-string"><span class="hljs-string">"row[`low]&amp;inp`low"</span></span>;<span class="hljs-string"><span class="hljs-string">"row`firstPrice"</span></span>;<span class="hljs-string"><span class="hljs-string">"inp`lastPrice"</span></span>;<span class="hljs-string"><span class="hljs-string">"row`firstSize"</span></span>;<span class="hljs-string"><span class="hljs-string">"inp`lastSize"</span></span>;<span class="hljs-string"><span class="hljs-string">"pvolume%numTrades"</span></span>;<span class="hljs-string"><span class="hljs-string">"volume%numTrades"</span></span>;<span class="hljs-string"><span class="hljs-string">"turnover%volume"</span></span>;<span class="hljs-string"><span class="hljs-string">"row[`cumVolume]+inp`volume"</span></span>); @[`aggExpression;specialCols;{<span class="hljs-string"><span class="hljs-string">"?[isFirst;inp`"</span></span>,y,<span class="hljs-string"><span class="hljs-string">";"</span></span>,x,<span class="hljs-string"><span class="hljs-string">"]"</span></span>};<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> specialCols]; aggExpression[accumulatorCols]:{<span class="hljs-string"><span class="hljs-string">"row[`"</span></span>,x,<span class="hljs-string"><span class="hljs-string">"]+inp`"</span></span>,x } each <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> accumulatorCols; updateAgg:value <span class="hljs-string"><span class="hljs-string">"{[aggTable;idx;inp] row:aggTable idx; isFirst:0=row`numTrades; .[aggTable;;:;]'[(idx;)each aggCols;("</span></span>,(<span class="hljs-string"><span class="hljs-string">";"</span></span>sv <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[aggCols],<span class="hljs-string"><span class="hljs-string">'":",/:aggExpression aggCols),")]}"; / '</span></span> init:{ tradeAgg::<span class="hljs-number"><span class="hljs-number">0</span></span>#enlist[initWith]; currTime::<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>; currSyms::`u#`symbol$(); offset::<span class="hljs-number"><span class="hljs-number">0</span></span>; rollCache:: `sym xkey update `u#sym from rollColumns#tradeAgg; }; roll:{[tm] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>[currTime&gt;tm; :init[]]; rollCache,::offset _ rollColumns#tradeAgg; offset::count tradeAgg; currSyms::`u#`$(); }; addSyms:{[syms] currSyms,::syms; `tradeAgg upsert @[count[syms]#enlist initWith;`sym`time,cols rc;:;(syms;currTime),(initWith cols rc)^value flip rc:rollCache ([] sym: syms)]; }; upd:{[tblName;data] updMinute[data] each exec distinct time from data:() xkey preprocess data}; updMinute:{[data;tm] <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>[tm&lt;&gt;currTime; roll tm; currTime::tm]; data:select from data where time=tm; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>[count msyms:syms where <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> (syms:data`sym)in currSyms; addSyms msyms]; updateAgg[`tradeAgg;offset+currSyms?syms;data]; };</code> </pre><br><h3>  Testen </h3><br>  √úberpr√ºfen Sie die Leistung des Dienstes.  F√ºhren Sie dazu einen separaten Prozess aus (f√ºgen Sie den Code in die Datei service.q ein) und rufen Sie die Init-Funktion auf: <br><br><pre> <code class="plaintext hljs">q service.q ‚Äìp 5566 q)init[]</code> </pre><br>  Starten Sie in einer anderen Konsole den zweiten Q-Prozess und stellen Sie eine Verbindung zum ersten her: <br><br><pre> <code class="cpp hljs">h:hopen `:host:<span class="hljs-number"><span class="hljs-number">5566</span></span> h:hopen <span class="hljs-number"><span class="hljs-number">5566</span></span> <span class="hljs-comment"><span class="hljs-comment">//     </span></span></code> </pre><br>  Erstellen Sie zun√§chst eine Liste mit 10.000 Zeichen und f√ºgen Sie eine Funktion zum Erstellen einer zuf√§lligen Tabelle hinzu.  In der zweiten Konsole: <br><br><pre> <code class="cpp hljs">syms:`IBM`AAPL`GOOG,<span class="hljs-number"><span class="hljs-number">-9997</span></span>?`<span class="hljs-number"><span class="hljs-number">8</span></span> rnd:{[n;t] ([] sym:n?syms; time:t+asc n#til <span class="hljs-number"><span class="hljs-number">25</span></span>; price:n?<span class="hljs-number"><span class="hljs-number">10f</span></span>; size:n?<span class="hljs-number"><span class="hljs-number">10</span></span>)}</code> </pre><br>  Ich habe der Liste der Zeichen drei echte Zeichen hinzugef√ºgt, um die Suche in der Tabelle zu vereinfachen.  Die Funktion rnd erstellt eine zuf√§llige Tabelle mit n Zeilen, wobei die Zeit von t bis t + 25 Millisekunden variiert. <br><br>  Jetzt k√∂nnen Sie versuchen, Daten an den Dienst zu senden (f√ºgen Sie die ersten zehn Stunden hinzu): <br><br><pre> <code class="cpp hljs">{h (`upd;`trade;rnd[<span class="hljs-number"><span class="hljs-number">10000</span></span>;x])} each `time$<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span> + til <span class="hljs-number"><span class="hljs-number">60</span></span>*<span class="hljs-number"><span class="hljs-number">10</span></span></code> </pre><br>  Sie k√∂nnen im Dienst √ºberpr√ºfen, ob die Tabelle aktualisiert wurde: <br><br><pre> <code class="cpp hljs">\c <span class="hljs-number"><span class="hljs-number">25</span></span> <span class="hljs-number"><span class="hljs-number">200</span></span> select from tradeAgg where sym=`AAPL <span class="hljs-number"><span class="hljs-number">-20</span></span>#select from tradeAgg where sym=`AAPL</code> </pre><br>  Ergebnis: <br><br><pre> <code class="1c hljs">sym<span class="hljs-string"><span class="hljs-string">|time|high|low|firstPrice|lastPrice|firstSize|lastSize|numTrades|volume|pvolume|turnover|avgPrice|avgSize|vwap|cumVolume --|--|--|--|--|-------------------------------- AAPL|09:27|9.258904|9.258904|9.258904|9.258904|8|8|1|8|9.258904|74.07123|9.258904|8|9.258904|2888 AAPL|09:28|9.068162|9.068162|9.068162|9.068162|7|7|1|7|9.068162|63.47713|9.068162|7|9.068162|2895 AAPL|09:31|4.680449|0.2011121|1.620827|0.2011121|1|5|4|14|9.569556|36.84342|2.392389|3.5|2.631673|2909 AAPL|09:33|2.812535|2.812535|2.812535|2.812535|6|6|1|6|2.812535|16.87521|2.812535|6|2.812535|2915 AAPL|09:34|5.099025|5.099025|5.099025|5.099025|4|4|1|4|5.099025|20.3961|5.099025|4|5.099025|2919</span></span></code> </pre> <br>  Wir werden nun Lasttests durchf√ºhren, um herauszufinden, wie viele Daten der Dienst pro Minute verarbeiten kann.  Ich m√∂chte Sie daran erinnern, dass wir das Intervall f√ºr Aktualisierungen auf 25 Millisekunden festgelegt haben.  Dementsprechend sollte ein Dienst (im Durchschnitt) in mindestens 20 Millisekunden pro Aktualisierung passen, damit Benutzer Zeit haben, Daten anzufordern.  Geben Sie im zweiten Vorgang Folgendes ein: <br><br><pre> <code class="cpp hljs">tm:<span class="hljs-number"><span class="hljs-number">10</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.000</span></span> stressTest:{[n] <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>[tm],<span class="hljs-string"><span class="hljs-string">" "</span></span>; times,::h ({st:.zT; upd[`trade;x]; .zT-st};rnd[n;tm]); tm+:<span class="hljs-number"><span class="hljs-number">25</span></span>} start:{[n] times::(); <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>[<span class="hljs-number"><span class="hljs-number">4800</span></span>;stressTest[n]]; <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-string"><span class="hljs-string">" "</span></span>; `min`avg`med`max!(min times;avg times;med times;max times)}</code> </pre><br>  4800 ist zwei Minuten.  Sie k√∂nnen versuchen, zuerst alle 25 Millisekunden 1000 Zeilen zu starten: <br><br><pre> <code class="cpp hljs">start <span class="hljs-number"><span class="hljs-number">1000</span></span></code> </pre><br>  In meinem Fall liegt das Ergebnis bei einigen Millisekunden pro Update.  Daher werde ich die Anzahl der Zeilen sofort auf 10.000 erh√∂hen: <br><br><pre> <code class="cpp hljs">start <span class="hljs-number"><span class="hljs-number">10000</span></span></code> </pre><br>  Ergebnis: <br><br><pre> <code class="cpp hljs">min| <span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.004</span></span> avg| <span class="hljs-number"><span class="hljs-number">9.191458</span></span> med| <span class="hljs-number"><span class="hljs-number">9f</span></span> max| <span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.030</span></span></code> </pre><br>  Wieder nichts Besonderes, aber das sind 24 Millionen Zeilen pro Minute, 400 Tausend pro Sekunde.  F√ºr mehr als 25 Millisekunden wurde das Update nur f√ºnfmal verlangsamt, anscheinend beim √Ñndern der Minute.  Erh√∂hung auf 100.000: <br><br><pre> <code class="cpp hljs">start <span class="hljs-number"><span class="hljs-number">100000</span></span></code> </pre><br>  Ergebnis: <br><br><pre> <code class="cpp hljs">min| <span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.013</span></span> avg| <span class="hljs-number"><span class="hljs-number">25.11083</span></span> med| <span class="hljs-number"><span class="hljs-number">24f</span></span> max| <span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">00.108</span></span> q)sum times <span class="hljs-number"><span class="hljs-number">00</span></span>:<span class="hljs-number"><span class="hljs-number">02</span></span>:<span class="hljs-number"><span class="hljs-number">00.532</span></span></code> </pre><br>  Wie Sie sehen k√∂nnen, kommt der Dienst kaum zurecht, schafft es aber dennoch, √ºber Wasser zu bleiben.  Diese Datenmenge (240 Millionen Zeilen pro Minute) ist extrem gro√ü. In solchen F√§llen ist es √ºblich, mehrere Klone (oder sogar Dutzende von Klonen) des Dienstes auszuf√ºhren, von denen jeder nur einen Teil der Zeichen verarbeitet.  Trotzdem ist das Ergebnis beeindruckend f√ºr die interpretierte Sprache, die sich haupts√§chlich auf die Datenspeicherung konzentriert. <br><br>  Es kann sich die Frage stellen, warum die Zeit nicht linear mit der Gr√∂√üe jedes Updates w√§chst.  Der Grund ist, dass die Quetschfunktion tats√§chlich eine C-Funktion ist, die viel effizienter arbeitet als updateAgg.  Beginnend mit einer Update-Gr√∂√üe (ca. 10.000) erreicht updateAgg seine Obergrenze und die Ausf√ºhrungszeit h√§ngt nicht von der Gr√∂√üe des Updates ab.  Aufgrund des vorl√§ufigen Schritts Q ist der Dienst in der Lage, solche Datenmengen zu verarbeiten.  Dies unterstreicht, wie wichtig es ist, bei der Arbeit mit Big Data den richtigen Algorithmus auszuw√§hlen.  Ein weiterer Punkt ist die korrekte Speicherung von Daten im Speicher.  Wenn die Daten nicht in Spalten gespeichert oder nicht nach Zeit geordnet w√§ren, w√ºrden wir so etwas wie einen TLB-Cache-Fehler kennenlernen - das Fehlen einer Speicherseitenadresse im Prozessoradresscache.  Das Auffinden der Adresse dauert im Fehlerfall etwa 30-mal l√§nger und kann bei verstreuten Daten den Dienst mehrmals verlangsamen. <br><br><h3>  Fazit </h3><br>  In diesem Artikel habe ich gezeigt, dass die KDB + - und Q-Datenbank nicht nur zum Speichern von Big Data und zum einfachen Zugriff √ºber Select geeignet ist, sondern auch zum Erstellen von Datenverarbeitungsdiensten, die Hunderte Millionen Zeilen / Gigabyte Daten selbst in einem einzigen Q-Prozess verarbeiten k√∂nnen .  Die Q-Sprache selbst erm√∂glicht aufgrund ihrer Vektornatur, des eingebauten Interpreters des SQL-Dialekts und einer sehr erfolgreichen Reihe von Bibliotheksfunktionen eine √§u√üerst kurze und effiziente Implementierung von Algorithmen im Zusammenhang mit der Datenverarbeitung. <br><br>  Ich werde feststellen, dass das oben Genannte nur ein Teil der F√§higkeiten von Q ist, es hat andere einzigartige Eigenschaften.  Zum Beispiel ein extrem einfaches IPC-Protokoll, das die Grenze zwischen einzelnen Q-Prozessen aufhebt und es Ihnen erm√∂glicht, Hunderte dieser Prozesse in einem einzigen Netzwerk zu kombinieren, das sich auf Dutzenden von Servern in verschiedenen Teilen der Welt befinden kann. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de470596/">https://habr.com/ru/post/de470596/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de470576/index.html">Banks of America wird in den kommenden Jahren 200.000 Arbeitspl√§tze abbauen</a></li>
<li><a href="../de470578/index.html">Wie wir die Buchhaltung in einer mobilen Bank ‚Äûhumanisiert‚Äú haben</a></li>
<li><a href="../de470582/index.html">√úberpr√ºfen der Telerik-Benutzeroberfl√§che auf UWP als Einstieg in PVS-Studio</a></li>
<li><a href="../de470584/index.html">√úberpr√ºfen Sie die Telerik-Benutzeroberfl√§che auf UWP, um sich mit PVS-Studio vertraut zu machen</a></li>
<li><a href="../de470594/index.html">Bericht von der Lichtshow ‚ÄûCircle of Light‚Äú 2019 in Moskau</a></li>
<li><a href="../de470598/index.html">Das Buch "Modernes Java. Lambda-Ausdr√ºcke, Streams und funktionale Programmierung ‚Äú</a></li>
<li><a href="../de470600/index.html">√úber sichere noVNC-Konsolen, automatische Skalierung in Kubernetes, Haproxy in Ostrovka und die Arbeit von Administratoren mit Programmierern</a></li>
<li><a href="../de470604/index.html">Geschwindigkeit beim Laden von Websites im E-Commerce: Analyse von 48 Top-Online-Shops in Russland</a></li>
<li><a href="../de470608/index.html">Unity UI-Optimierung</a></li>
<li><a href="../de470610/index.html">Ein Tag im Leben eines Entwicklers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>