<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèø‚Äçüåæ üêÖ üèí La ligne de commande la plus simple sur NASM et QEMU üóº ‚úâÔ∏è üåÅ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Donc, droit au but. Nous √©crirons sous Linux, sur NASM et en utilisant QEMU. C'est facile √† installer, alors sautez cette √©tape. 


 Il est entendu qu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>La ligne de commande la plus simple sur NASM et QEMU</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442428/"><p><img src="https://habrastorage.org/webt/-m/3u/a3/-m3ua33_7vl-xeb4pg1o8qacclg.png" alt="image"></p><br><p>  Donc, droit au but.  Nous √©crirons sous Linux, sur NASM et en utilisant QEMU.  C'est facile √† installer, alors sautez cette √©tape. </p><br><p>  Il est entendu que le lecteur conna√Æt la syntaxe de NASM au moins au niveau de base (cependant, il n'y aura rien de particuli√®rement compliqu√© ici) et comprend ce que sont les registres. </p><a name="habracut"></a><br><h2 id="bazovaya-teoriya">  Th√©orie de base </h2><br><p>  La premi√®re chose qui d√©marre le processeur lorsque l'ordinateur est allum√© est le code BIOS (ou UEFI, mais ici je ne parlerai que du BIOS), qui est "c√¢bl√©" dans la m√©moire de la carte m√®re (en particulier - √† 0xFFFFFFF0). </p><br><p>  Imm√©diatement apr√®s avoir allum√© le BIOS, l'autotest √† la mise sous tension (POST) d√©marre - l'autotest apr√®s la mise sous tension.  Le BIOS v√©rifie l'int√©grit√© de la m√©moire, d√©tecte et initialise les p√©riph√©riques connect√©s, v√©rifie les registres, d√©termine la taille de la m√©moire, etc. </p><br><p>  L'√©tape suivante consiste √† identifier le disque de d√©marrage √† partir duquel vous pouvez d√©marrer le syst√®me d'exploitation.  Un disque de d√©marrage est un disque (ou tout autre lecteur) qui a les 2 derniers octets du premier secteur (le premier secteur signifie les 512 premiers octets du lecteur, car 1 secteur = 512 octets) est 55 et AA (au format hexad√©cimal).  D√®s qu'un disque de d√©marrage est trouv√©, le BIOS charge ses 512 premiers octets dans la RAM √† l'adresse 0x7c00 et transf√®re le contr√¥le au processeur √† cette adresse. </p><br><p>  Bien s√ªr, dans ces 512 octets, cela ne fonctionnera pas pour s'adapter √† un syst√®me d'exploitation √† part enti√®re.  Par cons√©quent, g√©n√©ralement dans ce secteur, placez le chargeur principal, qui charge le code principal du syst√®me d'exploitation dans la RAM et lui transf√®re le contr√¥le. </p><br><p>  Depuis le tout d√©but, le processeur fonctionne en mode r√©el (= mode 16 bits).  Cela signifie qu'il ne peut fonctionner qu'avec des donn√©es 16 bits et utilise un adressage de m√©moire segment√©, et ne peut √©galement adresser que 1 Mo de m√©moire.  Mais nous n'utiliserons pas le second ici.  L'image ci-dessous montre l'√©tat de la RAM lors du transfert du contr√¥le vers notre code (l'image est prise √† <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partir d'ici</a> ). </p><br><p><img src="https://habrastorage.org/webt/qs/xb/jr/qsxbjr6em-78cr7d6xj7_nh86bg.png" alt="image"></p><br><p>  La derni√®re chose √† dire avant la partie pratique, ce sont les interruptions.  Une interruption est un signal sp√©cial (par exemple, provenant d'un p√©riph√©rique d'entr√©e, tel qu'un clavier ou une souris) √† un processeur qui dit qu'il est n√©cessaire d'interrompre imm√©diatement l'ex√©cution du code actuel et d'ex√©cuter le code du gestionnaire d'interruption.  Toutes les adresses des gestionnaires d'interruptions se trouvent dans la table des descripteurs d'interruption (IDT) dans la m√©moire principale.  Chaque interruption a son propre gestionnaire d'interruption.  Par exemple, lorsqu'une touche du clavier est enfonc√©e, une interruption est appel√©e, le processeur s'arr√™te, se souvient de l'adresse de l'instruction interrompue, enregistre toutes les valeurs de ses registres (sur la pile) et proc√®de √† l'ex√©cution du gestionnaire d'interruption.  D√®s la fin de son ex√©cution, le processeur restaure les valeurs des registres et revient √† l'instruction interrompue et poursuit l'ex√©cution. </p><br><p>  Par exemple, pour afficher quelque chose √† l'√©cran, le BIOS utilise l'interruption 0x10 (format hexad√©cimal) et l'interruption 0x16 est utilis√©e pour attendre qu'une touche soit press√©e.  En fait, ce sont toutes des interruptions dont nous aurons besoin ici. </p><br><p>  De plus, chaque interruption a sa propre sous-fonction qui d√©termine la particularit√© de son comportement.  Pour afficher quelque chose au format texte (!), Vous devez entrer la valeur 0x0e dans le registre AH.  De plus, les interruptions ont leurs propres param√®tres.  0x10 prend des valeurs de ah (d√©finit une sous-fonction sp√©cifique) et al (le caract√®re √† imprimer).  De cette fa√ßon </p><br><pre><code class="plaintext hljs">mov ah, 0x0e mov al, 'x' int 0x10</code> </pre> <br><p>  affiche le caract√®re ¬´x¬ª.  0x16 prend la valeur de ah (sous-fonction sp√©cifique) et charge la valeur de la cl√© entr√©e dans le registre al.  Nous utiliserons la fonction 0x0. </p><br><h2 id="prakticheskaya-chast">  Partie pratique </h2><br><p>  Commen√ßons par le code d'assistance.  Nous avons besoin des fonctions de comparaison de deux lignes et de la fonction d'affichage d'une ligne √† l'√©cran.  J'ai essay√© de d√©crire le fonctionnement de ces fonctions dans les commentaires aussi clairement que possible. </p><br><p>  str_compare.asm: </p><br><pre> <code class="plaintext hljs">compare_strs_si_bx: push si ;         push bx push ax comp: mov ah, [bx] ;     , cmp [si], ah ;      ah jne not_equal ;    ,     cmp byte [si], 0 ;    ,    je first_zero ;    inc si ;     bx  si inc bx jmp comp ;   first_zero: cmp byte [bx], 0 ;    bx != 0,  ,   jne not_equal ;  ,    not_equal mov cx, 1 ;     ,  cx = 1 pop si ;     pop bx pop ax ret ;     not_equal: mov cx, 0 ;  ,  cx = 0 pop si ;    pop bx pop ax ret ;    </code> </pre> <br><p>  La fonction accepte les registres SI et BX comme param√®tres.  Si les lignes sont √©gales, CX est mis √† 1, sinon 0. </p><br><p>  Il convient √©galement de noter que les registres AX, BX, CX et DX sont divis√©s en deux parties √† un octet: AH, BH, CH et DH pour l'octet haut et AL, BL, CL et DL pour l'octet bas. </p><br><p>  Initialement, il est entendu que dans bx et si il y a des pointeurs (!) (C'est-√†-dire stocke l'adresse en m√©moire) vers une adresse en m√©moire dans laquelle se trouve le d√©but de la ligne.  L'op√©ration [bx] prendra un pointeur de bx, il ira √† cette adresse et en prendra une valeur.  inc bx signifie que maintenant le pointeur fera r√©f√©rence √† l'adresse imm√©diatement apr√®s l'adresse d'origine. </p><br><p>  print_string.asm: </p><br><pre> <code class="plaintext hljs">print_string_si: push ax ;  ax   mov ah, 0x0e ;  ah  0x0e,    call print_next_char ;  pop ax ;  ax ret ;   print_next_char: mov al, [si] ;    cmp al, 0 ;  si  jz if_zero ;     int 0x10 ;     al inc si ;    jmp print_next_char ;   ... if_zero: ret</code> </pre> <br><p>  En param√®tre, la fonction prend le registre SI et octet par octet imprime une cha√Æne. </p><br><p>  Passons maintenant au code principal.  D√©finissons d'abord toutes les variables (ce code sera √† la toute fin du fichier): </p><br><pre> <code class="plaintext hljs">; 0x0d -   , 0xa -    wrong_command: db "Wrong command!", 0x0d, 0xa, 0 greetings: db "The OS is on. Type 'help' for commands", 0x0d, 0xa, 0xa, 0 help_desc: db "Here's nothing to show yet. But soon...", 0x0d, 0xa, 0 goodbye: db 0x0d, 0xa, "Goodbye!", 0x0d, 0xa, 0 prompt: db "&gt;", 0 new_line: db 0x0d, 0xa, 0 help_command: db "help", 0 input: times 64 db 0 ;   - 64  times 510 - ($-$$) db 0 dw 0xaa55</code> </pre> <br><p>  Le caract√®re de retour chariot d√©place le chariot vers le bord gauche de l'√©cran, c'est-√†-dire jusqu'au d√©but de la ligne. </p><br><pre> <code class="plaintext hljs">input: times 64 db 0</code> </pre> <br><p>  signifie que nous allouons 64 octets sous le tampon pour l'entr√©e et les remplissons de z√©ros. </p><br><p>  Les autres variables sont n√©cessaires pour afficher certaines informations, plus bas dans le code, vous comprendrez pourquoi elles sont toutes n√©cessaires. </p><br><pre> <code class="plaintext hljs">times 510 - ($-$$) db 0 dw 0xaa55</code> </pre> <br><p>  signifie que nous d√©finissons explicitement la taille du fichier de sortie (avec l'extension .bin) √† 512 octets, remplissons les 510 premiers octets avec des z√©ros (bien s√ªr, ils sont remplis avant l'ex√©cution de tout le code), et les deux derniers octets avec les m√™mes octets "magiques" 55 et AA .  $ signifie l'adresse de l'instruction en cours, et $$ est l'adresse de la toute premi√®re instruction de notre code. </p><br><p>  Passons au code r√©el: </p><br><pre> <code class="plaintext hljs">org 0x7c00 ; (1) bits 16 ; (2) jmp start ;    start %include "print_string.asm" ;     %include "str_compare.asm" ; ==================================================== start: mov ah, 0x00 ;   (3) mov al, 0x03 int 0x10 mov sp, 0x7c00 ;   (4) mov si, greetings ;    call print_string_si ;      mainloop</code> </pre> <br><p>  (1).  Cette commande indique clairement √† NASM que nous ex√©cutons du code √† partir de 0x7c00.  Cela lui permet de biaiser automatiquement toutes les adresses par rapport √† cette adresse afin que nous ne le fassions pas explicitement. <br>  (2).  Cette commande indique √† NASM que nous fonctionnons en mode 16 bits. <br>  (3).  Une fois lanc√©, QEMU imprime beaucoup d'informations dont nous n'avons pas besoin.  Pour ce faire, r√©glez sur ah 0x00, sur al 0x03 et appelez 0x10 pour effacer l'√©cran de tout. <br>  (4).  Pour enregistrer les registres sur la pile, vous devez sp√©cifier √† quelle adresse son sommet sera situ√© √† l'aide du pointeur de pile SP.  SP indiquera la zone en m√©moire dans laquelle la prochaine valeur sera √©crite.  Ajoutez la valeur √† la pile - SP descend la m√©moire de 2 octets (puisque nous sommes en mode r√©el, o√π tous les op√©randes de registre sont des valeurs de 16 bits, c'est-√†-dire √† deux octets).  Nous avons sp√©cifi√© 0x7c00, donc les valeurs sur la pile seront stock√©es juste √† c√¥t√© de notre code en m√©moire.  Encore une fois - la pile se d√©veloppe (!).  Cela signifie que plus il y a de valeurs sur la pile, moins le pointeur de la pile SP indiquera de m√©moire. </p><br><pre> <code class="plaintext hljs">mainloop: mov si, prompt ;   call print_string_si call get_input ;     jmp mainloop ;  mainloop...</code> </pre> <br><p>  Boucle principale.  Ici, √† chaque it√©ration, nous imprimons le caract√®re "&gt;", apr√®s quoi nous appelons la fonction get_input, qui impl√©mente le travail avec interruption du clavier. </p><br><pre> <code class="plaintext hljs">get_input: mov bx, 0 ;  bx      input_processing: mov ah, 0x0 ;    0x16 int 0x16 ;  ASCII  cmp al, 0x0d ;   enter je check_the_input ;   ,   ,  ;    cmp al, 0x8 ;   backspace je backspace_pressed cmp al, 0x3 ;   ctrl+c je stop_cpu mov ah, 0x0e ;     -   ;     int 0x10 mov [input+bx], al ;       inc bx ;   cmp bx, 64 ;  input  je check_the_input ;    ,    enter jmp input_processing ;   </code> </pre> <br><p>  (1) [entr√©e + bx] signifie que nous prenons l'adresse du d√©but de l'entr√©e du tampon d'entr√©e et y ajoutons bx, c'est-√†-dire que nous arrivons √† bx + le 1er √©l√©ment du tampon. </p><br><pre> <code class="plaintext hljs">stop_cpu: mov si, goodbye ;   call print_string_si jmp $ ;    ; $    </code> </pre> <br><p>  Tout est simple ici - si vous appuyez sur Ctrl + C, l'ordinateur ex√©cute la fonction jmp $ √† l'infini. </p><br><pre> <code class="plaintext hljs">backspace_pressed: cmp bx, 0 ;  backspace ,  input ,  je input_processing ;    mov ah, 0x0e ;  backspace.  ,   int 0x10 ;   ,      mov al, ' ' ;      ,  int 0x10 ;   mov al, 0x8 ;       int 0x10 ;     backspace dec bx mov byte [input+bx], 0 ;    input   jmp input_processing ;   </code> </pre> <br><p>  Afin de ne pas effacer le caract√®re '&gt;' lorsque vous appuyez sur la touche de retour arri√®re, nous v√©rifions si l'entr√©e est vide.  Sinon, ne faites rien. </p><br><pre> <code class="plaintext hljs">check_the_input: inc bx mov byte [input+bx], 0 ;     ,   ;  (  '\0'  ) mov si, new_line ;     call print_string_si mov si, help_command ;  si     help mov bx, input ;   bx -   call compare_strs_si_bx ;  si  bx (  help) cmp cx, 1 ; compare_strs_si_bx   cx 1,  ;     je equal_help ;  =&gt;    ;  help jmp equal_to_nothing ;   ,   "Wrong command!"</code> </pre> <br><p>  Ici, je pense que tout ressort clairement des commentaires. </p><br><pre> <code class="plaintext hljs">equal_help: mov si, help_desc call print_string_si jmp done equal_to_nothing: mov si, wrong_command call print_string_si jmp done</code> </pre> <br><p>  Selon ce qui a √©t√© entr√©, nous affichons soit le texte de la variable help_desc, soit le texte de la variable false_command. </p><br><pre> <code class="plaintext hljs">; done    input done: cmp bx, 0 ;     input   je exit ;   ,    mainloop dec bx ;  ,      mov byte [input+bx], 0 jmp done ;       exit: ret</code> </pre> <br><p>  En fait, tout le code est: </p><br><p>  prompt.asm: </p><br><pre> <code class="plaintext hljs">org 0x7c00 bits 16 jmp start ;    start %include "print_string.asm" %include "str_compare.asm" ; ==================================================== start: cli ;  ,    ;     mov ah, 0x00 ;   mov al, 0x03 int 0x10 mov sp, 0x7c00 ;   mov si, greetings ;    call print_string_si ;      mainloop mainloop: mov si, prompt ;   call print_string_si call get_input ;     jmp mainloop ;  mainloop... get_input: mov bx, 0 ;  bx      input_processing: mov ah, 0x0 ;    0x16 int 0x16 ;  ASCII  cmp al, 0x0d ;   enter je check_the_input ;   ,   ,  ;    cmp al, 0x8 ;   backspace je backspace_pressed cmp al, 0x3 ;   ctrl+c je stop_cpu mov ah, 0x0e ;     -   ;     int 0x10 mov [input+bx], al ;       inc bx ;   cmp bx, 64 ;  input  je check_the_input ;    ,    enter jmp input_processing ;    stop_cpu: mov si, goodbye ;   call print_string_si jmp $ ;    ; $     backspace_pressed: cmp bx, 0 ;  backspace ,  input ,  je input_processing ;    mov ah, 0x0e ;  backspace.  ,   int 0x10 ;   ,      mov al, ' ' ;      ,  int 0x10 ;   mov al, 0x8 ;       int 0x10 ;     backspace dec bx mov byte [input+bx], 0 ;    input   jmp input_processing ;    check_the_input: inc bx mov byte [input+bx], 0 ;     ,   ;  (  '\0'  ) mov si, new_line ;     call print_string_si mov si, help_command ;  si     help mov bx, input ;   bx -   call compare_strs_si_bx ;  si  bx (  help) cmp cx, 1 ; compare_strs_si_bx   cx 1,  ;     je equal_help ;  =&gt;    ;  help jmp equal_to_nothing ;   ,   "Wrong command!" equal_help: mov si, help_desc call print_string_si jmp done equal_to_nothing: mov si, wrong_command call print_string_si jmp done ; done    input done: cmp bx, 0 ;     input   je exit ;   ,    mainloop dec bx ;  ,      mov byte [input+bx], 0 jmp done ;       exit: ret ; 0x0d -   , 0xa -    wrong_command: db "Wrong command!", 0x0d, 0xa, 0 greetings: db "The OS is on. Type 'help' for commands", 0x0d, 0xa, 0xa, 0 help_desc: db "Here's nothing to show yet. But soon...", 0x0d, 0xa, 0 goodbye: db 0x0d, 0xa, "Goodbye!", 0x0d, 0xa, 0 prompt: db "&gt;", 0 new_line: db 0x0d, 0xa, 0 help_command: db "help", 0 input: times 64 db 0 ;   - 64  times 510 - ($-$$) db 0 dw 0xaa55</code> </pre><br><p>  Pour compiler tout cela, entrez la commande: </p><br><pre> <code class="plaintext hljs">nasm -f bin prompt.asm -o bootloader.bin</code> </pre> <br><p>  Et nous obtenons le binaire avec notre code √† la sortie.  Ex√©cutez maintenant l'√©mulateur QEMU avec ce fichier (-monitor stdio vous permet d'afficher la valeur du registre √† tout moment en utilisant la commande print $ reg): </p><br><pre> <code class="plaintext hljs">qemu-system-i386 bootloader.bin -monitor stdio</code> </pre> <br><p>  Et nous obtenons la sortie: </p><br><p><img src="https://habrastorage.org/webt/fq/h2/_7/fqh2_7m_r8mnne4pfo7x4sqvc4k.png" alt="image"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr442428/">https://habr.com/ru/post/fr442428/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr442406/index.html">Fintech digest: transferts gratuits dans le syst√®me SBP, vuln√©rabilit√© des banques aux attaques et autres actualit√©s</a></li>
<li><a href="../fr442408/index.html">La machine universelle pour effectuer des tests de bricolage, partie 1</a></li>
<li><a href="../fr442414/index.html">√âtudier dans une universit√© √©trang√®re √† la premi√®re personne</a></li>
<li><a href="../fr442416/index.html">ITMO University Research and Development Digest: discussion sur les tendances et les nouvelles r√©alisations des scientifiques</a></li>
<li><a href="../fr442422/index.html">Enthousiaste a recr√©√© la carte son Sound Blaster 1.0 - dites-nous √† quel point le projet est remarquable</a></li>
<li><a href="../fr442430/index.html">Le condens√© de mat√©riaux int√©ressants pour le d√©veloppeur mobile # 288 (24 f√©vrier - 3 mars)</a></li>
<li><a href="../fr442432/index.html">[Par les quais] Flutter. Partie 1. Pour les d√©veloppeurs Android</a></li>
<li><a href="../fr442434/index.html">7 recommandations pour analyser les 70 principaux param√®tres de croissance des sites en 2019 chez Yandex</a></li>
<li><a href="../fr442438/index.html">Un premier regard sur JavaScript √† travers les yeux d'un d√©veloppeur Java</a></li>
<li><a href="../fr442440/index.html">Cr√©ation d'une application Android √† l'aide des mises en page Anko et des coroutines Anko</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>