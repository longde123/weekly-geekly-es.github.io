<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🎨 🗃️ ✊ 5 cara untuk menggunakan kode PHP dalam kondisi beban tinggi 🏵️ ☃️ 👩🏾‍🔬</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jika jalan raya diajarkan di sekolah, buku pelajaran tentang hal ini akan memiliki tugas seperti itu. “Jaringan sosial N memiliki 2.000 server, di man...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>5 cara untuk menggunakan kode PHP dalam kondisi beban tinggi</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/449916/">  Jika jalan raya diajarkan di sekolah, buku pelajaran tentang hal ini akan memiliki tugas seperti itu.  “Jaringan sosial N memiliki 2.000 server, di mana 150.000 file 900 MB setiap kode PHP dan staging cluster untuk 50 mesin.  Kode ini digunakan 2 kali sehari ke server, kode diperbarui setiap beberapa menit pada cluster pementasan, dan ada "hotfix" tambahan - set kecil file yang diletakkan di luar giliran semua atau pada bagian yang dipilih dari server, tanpa menunggu perhitungan penuh.  Pertanyaan: apakah kondisi seperti itu dianggap beban tinggi dan bagaimana cara menggunakannya?  Tulis setidaknya 5 opsi penempatan. "  Kita hanya bisa bermimpi tentang buku masalah hyload, tetapi sekarang kita sudah tahu bahwa <strong>Yuri Nasretdinov</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">youROCK</a> ) pasti akan menyelesaikan masalah ini dan mendapatkan "lima". <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/qMu4YHJV1Z8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Yuri tidak berhenti pada solusi yang sederhana, tetapi juga membuat laporan di mana ia mengungkapkan konsep konsep "menyebarkan kode", berbicara tentang solusi klasik dan alternatif untuk penyebaran PHP skala besar, menganalisis kinerja mereka dan mempresentasikan sistem penyebaran MDK. <br><a name="habracut"></a><br><h2>  Konsep "menyebarkan kode" </h2><br>  Dalam bahasa Inggris, istilah "mengerahkan" berarti menyiagakan pasukan, dan dalam bahasa Rusia kita kadang-kadang mengatakan "mengisi kode ke dalam pertempuran," yang berarti hal yang sama.  Anda mengambil kode di yang sudah dikompilasi atau yang asli, jika itu PHP, unduh ke server yang melayani lalu lintas pengguna, dan kemudian, secara ajaib, entah bagaimana mengalihkan beban dari satu versi kode ke yang lain.  Semua ini termasuk dalam konsep "penyebaran kode". <br><br>  Proses penyebaran biasanya terdiri dari beberapa tahap. <br><br><ul><li>  <strong>Mendapatkan kode dari repositori</strong> dengan cara apa pun yang Anda suka: clone, fetch, checkout. </li><li> <strong>Majelis - bangun</strong> .  Untuk kode PHP, fase pembuatan mungkin tidak ada.  Dalam kasus kami, ini adalah, biasanya, pembuatan file terjemahan otomatis, mengunggah file statis ke CDN dan beberapa operasi lainnya. </li><li>  <strong>Pengiriman ke server akhir</strong> - penyebaran. </li></ul><br>  Setelah semuanya terpasang, fase penyebaran segera dimulai - <strong>kode dituangkan ke server produksi</strong> .  Tentang fase inilah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Badoo</a> akan dibahas. <br><br><h2>  Sistem penempatan lama di Badoo </h2><br>  Jika Anda memiliki file dengan gambar sistem file, lalu bagaimana cara memasangnya?  Di Linux, Anda perlu membuat <strong>perangkat Loop perantara</strong> , melampirkan file ke dalamnya, dan setelah itu Anda sudah bisa memasang perangkat blok ini. <br><br>  Perangkat loop adalah penopang yang dibutuhkan Linux untuk me-mount gambar sistem file.  Ada OS di mana kruk ini tidak diperlukan. <br><br><img src="https://habrastorage.org/webt/gd/ch/h6/gdchh68qpl5ikkpddsvxzwcwvlm.png"><br><br>  Bagaimana proses penyebaran menggunakan file, yang juga kami sebut "loop" untuk kesederhanaan?  Ada direktori tempat kode sumber dan konten yang dibuat secara otomatis berada.  Kami mengambil gambar kosong dari sistem file - sekarang EXT2, dan sebelumnya kami menggunakan ReiserFS.  Kami memasang gambar kosong dari sistem file dalam direktori sementara, menyalin semua konten di sana.  Jika kami tidak perlu melakukan sesuatu untuk produksi, maka kami tidak menyalin semuanya.  Setelah itu, unmount perangkat, dan dapatkan gambar dari sistem file di mana file yang diperlukan berada.  Selanjutnya, kami <strong>mengarsipkan gambar dan mengunggah ke semua server</strong> , di sana kami unzip dan memasangnya. <br><br><h2>  Solusi lain yang ada </h2><br>  Pertama, mari kita berterima kasih kepada <strong>Richard Stallman</strong> - tanpa lisensi, sebagian besar utilitas yang kita gunakan tidak akan ada. <br><br><img src="https://habrastorage.org/webt/8h/oa/yh/8hoayhyyicam7izl-q7egj8bitq.png"><br><br>  Saya secara konvensional membagi metode penempatan kode PHP ke dalam 4 kategori. <br><br><ul><li>  <strong>Berdasarkan sistem kontrol versi</strong> : svn up, git pull, hg up. </li><li>  <strong>Berdasarkan utilitas rsync</strong> - ke direktori baru atau "di atas". </li><li>  <strong>Sebarkan satu file</strong> - apa pun yang terjadi: phar, hhbc, loop. </li><li>  Cara khusus yang disarankan <strong>Rasmus Lerdorf</strong> adalah <strong>rsync, 2 direktori dan realpath_root</strong> . </li></ul><br>  Setiap metode memiliki pro dan kontra, karena itu kami mengabaikannya.  Pertimbangkan 4 metode ini secara lebih rinci. <br><br><h3>  Penyebaran berdasarkan sistem kontrol versi svn up </h3><br>  Saya memilih SVN bukan karena kebetulan - menurut pengamatan saya, dalam bentuk ini penyebaran justru ada dalam kasus SVN.  Sistem ini cukup <strong>ringan</strong> , memungkinkan Anda <strong>untuk</strong> menggunakan <strong>dengan cepat dan mudah</strong> - jalankan saja svn dan Anda selesai. <br><br>  Tetapi metode ini memiliki satu minus besar: jika Anda melakukan svn, dan dalam proses memperbarui kode sumber, ketika permintaan baru datang dari repositori, mereka akan melihat status sistem file yang tidak ada di repositori.  Anda akan memiliki sebagian file baru, dan sebagian yang lama - ini adalah <strong>metode penyebaran non-atom</strong> yang tidak cocok untuk beban tinggi, tetapi hanya untuk proyek kecil.  Meskipun demikian, saya tahu proyek yang masih dikerahkan dengan cara ini, dan sejauh ini semuanya bekerja untuk mereka. <br><br><h3>  Penerapan berdasarkan utilitas rsync </h3><br>  Ada dua opsi untuk melakukan hal ini: unggah file menggunakan utilitas langsung ke server dan unggah "di atas" - perbarui. <br><br><h4>  rsync ke direktori baru </h4><br>  Karena Anda pertama kali sepenuhnya menuangkan semua kode ke direktori yang belum ada di server, dan baru kemudian beralih lalu lintas, metode ini bersifat <strong>atomik</strong> - tidak ada yang melihat status perantara.  Dalam kasus kami, membuat 150.000 file dan menghapus direktori lama, yang juga memiliki 150.000 file, menciptakan <strong>beban besar pada subsistem disk</strong> .  Kami menggunakan hard disk sangat aktif, dan server di suatu tempat selama satu menit tidak terasa baik setelah operasi seperti itu.  Karena kami memiliki 2000 server, maka diperlukan untuk mengisi 900 MB 2000 kali. <br><br>  Skema ini dapat ditingkatkan jika Anda pertama kali mengunggah ke sejumlah server perantara, misalnya, 50, dan kemudian menambahkannya ke yang lain.  Ini memecahkan kemungkinan masalah dengan jaringan, tetapi masalah membuat dan menghapus sejumlah besar file tidak hilang di mana pun. <br><br><img src="https://habrastorage.org/webt/wj/c9/pt/wjc9ptyfin79_dn6jmnornudzt8.png"><br><br><h4>  rsync di atas </h4><br>  Jika Anda menggunakan rsync, maka Anda tahu bahwa utilitas ini tidak hanya dapat mengisi seluruh direktori, tetapi juga memperbarui yang sudah ada.  Mengirim hanya perubahan adalah nilai tambah, tetapi karena kami mengunggah perubahan ke direktori yang sama tempat kami menyajikan kode pertempuran, juga akan ada semacam status perantara - ini adalah minus. <br><br>  Mengirimkan perubahan berfungsi seperti ini.  Rsync membuat daftar file di sisi server dari mana penyebaran dilakukan, dan di sisi penerima.  Setelah itu, ia menghitung stat dari semua file dan mengirim seluruh daftar ke sisi penerima.  Pada server dari mana penyebaran sedang berlangsung, perbedaan antara nilai-nilai ini dipertimbangkan, dan ditentukan file mana yang harus dikirim. <br><br>  Dalam kondisi kami, proses ini membutuhkan sekitar <strong>3 MB lalu lintas dan 1 detik waktu prosesor</strong> .  Tampaknya ini tidak banyak, tetapi kami memiliki 2.000 server, dan semuanya ternyata setidaknya satu menit dari waktu prosesor.  Ini bukan metode yang cepat, tetapi jelas lebih baik daripada mengirim semuanya melalui rsync.  Tetap entah bagaimana menyelesaikan masalah atomicity dan akan menjadi hampir sempurna. <br><br><h3>  Menyebarkan satu file </h3><br>  Apa pun file tunggal yang Anda unggah, relatif mudah dilakukan menggunakan BitTorrent atau utilitas UFTP.  Satu file lebih mudah di-unzip, dapat diganti secara atom pada Unix, dan mudah untuk memeriksa integritas file yang dihasilkan pada build server dan dikirim ke mesin target dengan menghitung jumlah MD5 atau SHA-1 dari file (dalam kasus rsync, Anda tidak tahu apa yang ada di server tujuan) ) <br><br>  Untuk hard drive, perekaman berurutan merupakan nilai tambah besar - file 900 MB akan ditulis ke hard drive yang tidak digunakan dalam waktu sekitar 10 detik.  Tetapi Anda masih perlu merekam 900 MB yang sama ini dan mentransfernya melalui jaringan. <br><br><h4>  Penyimpangan liris tentang UFTP </h4><br>  Utilitas Open Source ini pada awalnya dibuat untuk mentransfer file melalui jaringan dengan penundaan yang lama, misalnya, melalui jaringan berbasis satelit.  Tetapi UFTP ternyata cocok untuk mengunggah file ke sejumlah besar mesin, karena berfungsi menggunakan protokol UDP berdasarkan Multicast.  Satu alamat Multicast dibuat, semua mesin yang ingin menerima file berlangganan padanya, dan sakelar menyediakan pengiriman salinan paket ke setiap mesin.  Jadi kami mengalihkan beban pengiriman data ke jaringan.  Jika jaringan Anda dapat menangani ini, maka metode ini bekerja lebih baik daripada BitTorrent. <br><br>  Anda dapat mencoba utilitas Open Source ini di cluster Anda.  Terlepas dari kenyataan bahwa ia bekerja di atas UDP, ia memiliki mekanisme NACK - pengakuan negatif, yang memaksa meneruskan kembali paket yang hilang pada saat pengiriman.  <strong>Ini adalah cara yang andal untuk digunakan</strong> . <br><br><h4>  Opsi penyebaran file tunggal </h4><br>  <strong>tar.gz</strong> <br><br>  Opsi yang menggabungkan kelemahan dari kedua pendekatan.  Anda tidak hanya harus menulis 900 MB ke disk secara berurutan, setelah itu Anda harus menulis 900 MB yang sama lagi secara acak baca-tulis dan membuat 150.000 file.  Metode ini bahkan lebih buruk dalam kinerja daripada rsync. <br><br>  <strong>Phar</strong> <br><br>  PHP mendukung arsip dalam format phar (PHP Archive), tahu bagaimana memberikan kontennya dan memasukkan file.  Tetapi tidak semua proyek mudah dimasukkan ke dalam satu phar - Anda memerlukan adaptasi kode.  Hanya karena kode dari arsip ini tidak berfungsi.  Selain itu, Anda tidak dapat mengubah satu file di arsip ( <em>Yuri dari masa depan: secara teori, Anda masih bisa</em> ), Anda perlu memuat ulang seluruh arsip.  Selain itu, terlepas dari kenyataan bahwa arsip phar bekerja dengan OPCache, ketika menggunakan, cache harus dibuang, karena jika tidak akan ada sampah di OPCache dari file phar lama. <br><br>  <strong>hhbc</strong> <br><br>  Metode ini asli untuk HHVM - HipHop Virtual Machine dan digunakan oleh Facebook.  Ini adalah sesuatu seperti arsip phar, tetapi tidak berisi kode sumber, tetapi kode byte yang dikompilasi dari mesin virtual HHVM - penerjemah PHP dari Facebook.  Dilarang mengubah apa pun dalam file ini: Anda tidak dapat membuat kelas, fungsi, dan beberapa fitur dinamis lainnya dalam mode ini dinonaktifkan.  Karena keterbatasan ini, mesin virtual dapat menggunakan optimasi tambahan.  Menurut Facebook, ini dapat membawa hingga 30% ke kecepatan eksekusi kode.  Ini mungkin pilihan yang bagus untuk mereka.  Juga tidak mungkin untuk mengubah satu file di sini ( <em>Yuri dari masa depan: sebenarnya itu mungkin, karena ini adalah basis sqlite</em> ).  Jika Anda ingin mengubah satu baris, Anda harus mengulang kembali seluruh arsip. <br><br>  Untuk metode ini <strong>dilarang menggunakan eval dan dynamic include.</strong>  Ini memang begitu, tetapi tidak cukup.  Eval dapat digunakan, tetapi jika tidak membuat kelas atau fungsi baru, dan menyertakan tidak dapat dibuat dari direktori yang berada di luar arsip ini. <br><br>  <strong>lingkaran</strong> <br><br>  Ini adalah versi lama kami, dan ini memiliki dua keuntungan besar.  Pertama, sepertinya direktori biasa <strong>.</strong>  Anda memasang loop, dan untuk kode itu tidak masalah - itu bekerja dengan file, baik di lingkungan pengembangan dan lingkungan produksi.  Loop kedua dapat dipasang dalam mode baca dan tulis, dan ubah satu file, jika Anda masih perlu mengubah sesuatu untuk segera diproduksi. <br><br>  Tetapi loop memiliki kontra.  Pertama, ini bekerja aneh dengan buruh pelabuhan.  Saya akan membicarakannya nanti. <br><br>  Kedua, jika Anda menggunakan symlink pada loop terakhir sebagai document_root, maka Anda akan memiliki masalah dengan OPCache.  Ini tidak terlalu bagus untuk memiliki symlink di jalur, dan mulai membingungkan versi file yang akan digunakan.  Karena itu, OPCache harus diatur ulang saat menggunakan. <br><br>  Masalah lain adalah bahwa <strong>hak pengguna super diperlukan</strong> untuk me-mount sistem file.  Dan Anda tidak boleh lupa me-mount mereka pada awal / restart mesin, karena kalau tidak akan ada direktori kosong bukan kode. <br><br><h4>  Masalah dengan buruh pelabuhan </h4><br>  Jika Anda membuat wadah buruh pelabuhan dan membuang di dalamnya sebuah folder di mana "loop" atau perangkat blok lainnya dipasang, maka ada dua masalah sekaligus: titik mount baru tidak jatuh ke dalam wadah buruh pelabuhan, dan "loop" yang ada pada saat penciptaan Wadah buruh pelabuhan <strong>tidak dapat dilepas</strong> karena diduduki oleh wadah buruh pelabuhan. <br><br>  Biasanya, ini umumnya tidak sesuai dengan penyebaran, karena jumlah perangkat loop terbatas, dan tidak jelas bagaimana kode baru harus jatuh ke dalam wadah. <br><br>  Kami mencoba melakukan hal-hal aneh, misalnya, meningkatkan <strong>server NFS</strong> lokal atau memasang direktori menggunakan SSHFS, tetapi karena berbagai alasan ini tidak berakar pada kami.  Akibatnya, di cron, kami mendaftarkan rsync dari "loop" terakhir ke direktori saat ini, dan menjalankan perintah sekali setiap menit: <br><pre><code class="php hljs">rsync /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/loop/&lt;N&gt;/ /<span class="hljs-keyword"><span class="hljs-keyword">var</span></span>/www/</code> </pre> <br>  Di sini <code>/var/www/</code> adalah direktori yang dipromosikan ke wadah.  Tetapi pada mesin yang memiliki wadah buruh pelabuhan, kami tidak perlu sering menjalankan skrip PHP, jadi rsync bukan atom, yang cocok untuk kami.  Tapi tetap saja, metode ini sangat buruk, tentu saja.  Saya ingin membuat sistem penempatan yang berfungsi baik dengan buruh pelabuhan. <br><br><h3>  rsync, 2 direktori dan realpath_root </h3><br>  Metode ini diusulkan oleh Rasmus Lerdorf, penulis PHP, dan ia tahu cara menggunakan. <br><br>  Bagaimana cara membuat penyebaran atom, dan dengan cara apa pun yang saya bicarakan?  Ambil symlink dan daftarkan sebagai document_root.  Pada setiap titik waktu, symlink menunjuk ke salah satu dari dua direktori, dan Anda membuat rsync ke direktori tetangga, yaitu ke direktori yang tidak ditunjuk oleh kode. <br><br><img src="https://habrastorage.org/webt/x7/qh/49/x7qh49aslgwu3loufk6wixt8fcg.png"><br><br>  Tetapi masalah muncul: kode PHP tidak tahu direktori tempat dia menjalankan.  Oleh karena itu, Anda perlu menggunakan, misalnya, variabel yang akan Anda tulis di suatu tempat di awal dalam konfigurasi - ini akan memperbaiki direktori tempat kode dijalankan dan dari mana file baru harus dimasukkan.  Pada salindia, ini disebut <code>ROOT_DIR</code> . <br><br>  Gunakan konstanta ini ketika mengakses semua file di dalam kode yang Anda gunakan saat produksi.  Jadi Anda mendapatkan properti atomicity: permintaan yang tiba sebelum Anda beralih symlink terus menyertakan file dari direktori lama di mana Anda tidak mengubah apa pun, dan permintaan baru yang datang setelah beralih symlink mulai bekerja dari direktori baru dan dilayani kode baru. <br><br><img src="https://habrastorage.org/webt/ny/o3/hh/nyo3hhqqs2iwthucxiquyf-org4.png"><br><br>  Tetapi ini perlu ditulis dalam kode.  Tidak semua proyek siap untuk ini. <br><br><h3>  Gaya Rasmus </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Rasmus menyarankan</a> daripada memodifikasi kode secara manual dan membuat konstanta untuk sedikit memodifikasi Apache atau menggunakan nginx. <br><br><img src="https://habrastorage.org/webt/8f/c3/xy/8fc3xyhs8rgmrtp45qeguvtzufi.png"><br><br>  Untuk document_root, tentukan symlink ke versi terbaru.  Jika Anda memiliki nginx, maka Anda dapat mendaftarkan <code>root $realpath_root</code> , untuk Apache Anda akan memerlukan modul terpisah dengan pengaturan yang dapat dilihat pada slide.  Ini berfungsi seperti ini - ketika sebuah permintaan tiba, nginx atau Apache sesekali mempertimbangkan realpath () dari path, menyimpannya dari symlinks, dan meneruskan path ini sebagai document_root.  Dalam hal ini, document_root akan selalu menunjuk ke direktori reguler tanpa symlink, dan kode PHP Anda mungkin tidak harus memikirkan direktori tempat itu berasal. <br><br>  Metode ini memiliki kelebihan yang menarik - jalur nyata datang ke OPCache PHP, mereka tidak mengandung symlink.  Bahkan file pertama yang diminta sudah penuh, dan tidak akan ada masalah dengan OPCache.  Karena document_root digunakan, ini berfungsi dengan proyek PHP apa pun.  Anda tidak perlu menyesuaikan apa pun. <br><br>  Ini tidak memerlukan pemuatan fpm, tidak perlu mengatur ulang OPCache selama penyebaran, itulah sebabnya server prosesor sangat sibuk, karena harus mengurai semua file lagi.  Dalam percobaan saya, mengatur ulang OPCache sekitar setengah menit meningkatkan konsumsi prosesor dengan faktor 2–3.  Akan menyenangkan untuk menggunakannya kembali dan metode ini memungkinkan Anda untuk melakukannya. <br><br>  Sekarang kontra.  Karena Anda tidak menggunakan kembali OPCache, dan Anda memiliki 2 direktori, Anda perlu menyimpan salinan file dalam memori untuk setiap direktori - di bawah OPCache, diperlukan 2 kali lebih banyak memori. <br><br>  Ada batasan lain yang mungkin tampak aneh - <strong>Anda tidak dapat menggunakan lebih dari sekali setiap max_execution_time</strong> .  Kalau tidak, masalah yang sama akan terjadi, karena ketika rsync pergi ke salah satu direktori, permintaan darinya masih dapat diproses. <br><br>  Jika Anda menggunakan Apache karena suatu alasan, maka Anda memerlukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">modul pihak ketiga</a> yang juga ditulis oleh Rasmus. <br><br>  Rasmus mengatakan sistemnya baik dan saya merekomendasikannya untuk Anda juga.  Untuk 99% proyek, sangat cocok, baik untuk proyek baru maupun yang sudah ada.  Tetapi, tentu saja, kita tidak seperti itu dan memutuskan untuk menulis keputusan kita sendiri. <br><br><h2>  Sistem baru - MDK </h2><br>  Pada dasarnya, persyaratan kami tidak berbeda dengan persyaratan untuk sebagian besar proyek web.  Kami hanya ingin <strong>penyebaran cepat</strong> pada pementasan dan produksi, <strong>konsumsi sumber daya yang rendah</strong> , penggunaan kembali OPCache dan rollback cepat. <br><br>  Tetapi ada dua persyaratan lagi yang mungkin berbeda dari yang lain.  Pertama-tama, itu adalah kemampuan untuk <strong>menerapkan tambalan secara atom</strong> .  Kami merujuk ke tambalan sebagai perubahan dalam satu atau beberapa file yang mengatur sesuatu pada produksi.  Kami ingin melakukannya dengan cepat.  Pada prinsipnya, sistem yang ditawarkan Rasmus mengatasi tugas tambalan. <br><br>  Kami juga memiliki <strong>skrip CLI</strong> <strong>yang dapat berjalan selama beberapa jam</strong> , dan <strong>skrip tersebut</strong> harus tetap bekerja dengan versi kode yang konsisten.  Dalam hal ini, solusi di atas, sayangnya, tidak cocok untuk kita, atau kita harus memiliki banyak direktori. <br><br>  Kemungkinan solusi: <br><br><ul><li>  loop xN (-staging, -docker, -opcache); </li><li>  rsync xN (-produksi, -opcache xN); </li><li>  SVN xN (-produksi, -opcache xN). </li></ul><br>  Di sini N adalah jumlah perhitungan yang terjadi dalam beberapa jam.  Kita dapat memiliki lusinan di antaranya, yang berarti kebutuhan untuk menghabiskan ruang yang sangat besar untuk salinan kode tambahan. <br><br>  Karena itu, kami membuat sistem baru dan menyebutnya <strong>MDK.</strong>  Itu adalah singkatan dari <strong>Multiversion Deployment Kit</strong> , alat penyebaran multi-versi.  Kami melakukannya berdasarkan asumsi berikut. <br><br>  <strong>Kami mengambil arsitektur penyimpanan pohon dari Git.</strong>  Kita perlu memiliki versi kode yang konsisten di mana skrip bekerja, yaitu, kita memerlukan snapshot.  Snapshots didukung oleh LVM, tetapi di sana mereka diimplementasikan secara tidak efisien oleh sistem file eksperimental seperti Btrfs dan Git.  Kami mengambil implementasi snapshots dari Git. <br><br>  <strong>Mengganti nama semua file dari file.php ke file.php. &lt;version&gt;.</strong>  Karena semua file yang kita miliki hanya disimpan di disk, maka jika kita ingin menyimpan beberapa versi file yang sama, kita harus menambahkan akhiran dengan versi tersebut. <br><br>  <strong>Saya suka Go, jadi untuk kecepatan saya menulis sebuah sistem di Go.</strong> <br><br><h3>  Bagaimana Kit Penerapan Multiversion Bekerja </h3><br>  Kami mengambil ide snapshot dari Git.  Saya sedikit menyederhanakannya dan memberi tahu Anda cara penerapannya di MDK. <br><br>  Ada dua jenis file di MDK.  Yang pertama adalah <strong>kartu.</strong>  Gambar-gambar di bawah ini ditandai dengan warna hijau dan sesuai dengan direktori di repositori.  Tipe kedua adalah <strong>file secara langsung,</strong> yang terletak di tempat yang sama seperti biasanya, tetapi dengan akhiran dalam bentuk versi file.  File dan peta diversi berdasarkan isinya, dalam kasus kami hanya MD5. <br><br><img src="https://habrastorage.org/webt/-n/wz/1s/-nwz1str78y7hua15pfwxrrl14o.png"><br><br>  Misalkan kita memiliki beberapa hierarki file di mana <strong>peta root merujuk ke versi file tertentu dari peta lain</strong> , dan mereka, pada gilirannya, merujuk ke file dan peta lain, dan memperbaiki versi tertentu.  Kami ingin mengubah beberapa jenis file. <br><br><img src="https://habrastorage.org/webt/7d/up/_b/7dup_biyh7msgtsp7kejinaulwc.png"><br><br>  Mungkin Anda telah melihat gambar yang sama: kami mengubah file di tingkat bersarang kedua, dan di peta yang sesuai - peta *, versi dari tiga file * diperbarui, isinya dimodifikasi, versinya diubah - dan versinya juga berubah di root map.  Jika kami mengubah sesuatu, kami selalu mendapatkan peta root baru, tetapi semua file yang tidak kami ubah digunakan kembali. <br><br>  Tautan tetap ke file yang sama seperti sebelumnya.  Ini adalah ide utama untuk membuat snapshot dengan cara apa pun, misalnya, di <strong>ZFS</strong> diterapkan dengan cara yang hampir sama. <br><br><h3>  Bagaimana MDK terletak pada disk </h3><br><img src="https://habrastorage.org/webt/2r/vb/k4/2rvbk4ucmbe8upitkgczvy1dbns.png"><br><br>  Kami memiliki pada disk: <strong>symlink ke peta root terbaru</strong> - kode yang akan dilayani dari web, beberapa versi peta root, beberapa file, mungkin dengan versi yang berbeda, dan di subdirektori ada peta untuk direktori yang sesuai. <br><br>  Saya memperkirakan pertanyaan: " <em>Dan bagaimana ini memproses permintaan web? File apa yang akan digunakan oleh kode pengguna?</em> " <br><br>  Ya, saya menipu Anda - ada juga file tanpa versi, karena jika Anda menerima permintaan untuk index.php, dan Anda tidak memilikinya di direktori, situs tidak akan berfungsi. <br><br><img src="https://habrastorage.org/webt/-e/fl/9k/-efl9kqt3-go-tvg0qpu0lnvauo.png"><br><br>  Semua file PHP memiliki file, yang kami sebut <strong>bertopik</strong> , karena mengandung dua baris: wajibkan dari file di mana fungsi yang tahu cara bekerja dengan kartu-kartu ini dideklarasikan, dan diperlukan dari versi file yang diinginkan. <br><br><pre> <code class="php hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?php</span></span> <span class="hljs-keyword"><span class="hljs-keyword">require_once</span></span> <span class="hljs-string"><span class="hljs-string">"mdk.inc"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">require</span></span> mdk_resolve_path(<span class="hljs-string"><span class="hljs-string">"a.php"</span></span>);</code> </pre><br>  Hal ini dilakukan, dan tidak dikaitkan dengan versi terbaru, karena jika Anda mengecualikan <strong>b.php</strong> dari file <strong>a.php</strong> tanpa versi, maka sejak require_once ditulis, sistem akan mengingat kartu root yang memulai, akan menggunakannya, dan Dapatkan versi file yang konsisten. <br><br>  Untuk sisa file, kami hanya memiliki symlink ke versi terbaru. <br><br><h3>  Cara menggunakan MDK </h3><br>  Modelnya sangat mirip dengan git push. <br><br><ul><li>  Kirim isi peta root. </li><li>  Di sisi penerima, kami melihat file apa yang hilang.  Karena versi file ditentukan oleh konten, kita tidak perlu mengunduhnya untuk kedua kalinya ( <em>Yuri dari masa depan: kecuali untuk kasus ketika MD5 yang diperpendek bertabrakan, yang masih terjadi satu kali dalam produksi</em> ). </li><li>  Minta file yang hilang. </li><li>  Kami melewati titik kedua dan selanjutnya dalam lingkaran. </li></ul><br><h4>  Contoh </h4><br>  Misalkan ada file bernama "satu" di server.  Kirim peta root ke sana. <br><br><img src="https://habrastorage.org/webt/_h/sz/h_/_hszh_rruyekpqegz6-blz5xkeq.png"><br><br>  Di root map, panah putus-putus menunjukkan tautan ke file yang tidak kita miliki.  Kami tahu nama dan versinya karena mereka ada di peta.  Kami meminta mereka dari server.  Server mengirim, dan ternyata salah satu file juga kartu. <br><br><img src="https://habrastorage.org/webt/zp/--/ec/zp--ecfpdqqkgjq4zciljreqkk0.png"><br><br>  Kami melihat - kami tidak memiliki satu file sama sekali.  Sekali lagi kami meminta file yang hilang.  Server mengirimkannya.  Tidak ada lagi kartu yang tersisa - proses penyebaran selesai. <br><br><img src="https://habrastorage.org/webt/mp/jk/tc/mpjktcmgb80dpamvqjkwp_ya1lg.png"><br><br>  Anda dapat dengan mudah menebak apa yang akan terjadi jika file 150.000, tetapi satu telah berubah.  Kita akan melihat di peta dasar bahwa ada satu peta yang hilang, mari kita lanjutkan dengan tingkat sarang dan dapatkan file.  Dalam hal kompleksitas komputasi, prosesnya hampir tidak berbeda dengan menyalin file secara langsung, tetapi pada saat yang sama, konsistensi dan snapshot dari kode tersebut dipertahankan. <br><br>  MDK tidak memiliki kekurangan :) Ini memungkinkan Anda untuk secara <strong>cepat dan atomis melakukan perubahan kecil</strong> , dan <strong>skrip bekerja selama berhari-hari</strong> , karena kami dapat meninggalkan semua file yang digunakan dalam waktu seminggu.  Mereka akan menempati ruang yang cukup memadai.  Anda juga dapat menggunakan kembali OPCache, dan CPU hampir tidak makan apa-apa. <br><br>  <strong>Pemantauan cukup sulit, tetapi memungkinkan</strong> .  Semua file diversi versi oleh konten, dan Anda dapat menulis cron, yang akan melewati semua file dan memverifikasi nama dan konten.  Anda juga dapat memeriksa bahwa peta root merujuk ke semua file, bahwa tidak ada tautan yang rusak di dalamnya.  Selain itu, selama integritas penyebaran diperiksa. <br><br>  Anda dapat <strong>dengan mudah mengembalikan perubahan</strong> , karena semua kartu lama ada di tempatnya.  Kita bisa melempar kartunya, semuanya akan segera ada di sana. <br><br>  Bagi saya, ditambah fakta bahwa <strong>MDK ditulis dalam Go</strong> berarti bekerja dengan cepat. <br><br>  Saya menipu Anda lagi, masih ada kontra.  Agar proyek dapat bekerja dengan sistem, <strong>diperlukan modifikasi kode yang signifikan,</strong> tetapi lebih sederhana daripada yang terlihat pada pandangan pertama.  <strong>Sistem ini sangat kompleks</strong> , saya tidak akan merekomendasikan menerapkannya jika Anda tidak memiliki persyaratan seperti Badoo.  Lagipula, cepat atau lambat tempat itu berakhir, jadi <strong>Pengumpul Sampah diperlukan</strong> . <br><br>  Kami menulis utilitas khusus untuk mengedit file - yang asli, bukan bertopik, misalnya, mdk-vim.  Anda menentukan file, menemukan versi yang diinginkan dan mengeditnya. <br><br><h3>  MDK dalam angka </h3><br>  Kami memiliki 50 server untuk pementasan, yang kami gunakan selama 3-5 detik <strong>.</strong>  Dibandingkan dengan semuanya kecuali rsync, ini sangat cepat.  Pada <strong>produksi</strong> kami menyebarkan sekitar <strong>2 menit</strong> , tambalan kecil - <strong>5-10 s</strong> . <br><br>  Jika karena alasan tertentu Anda telah kehilangan seluruh folder dengan kode pada semua server (yang seharusnya tidak pernah terjadi :)), maka <strong>proses pengunggahan penuh membutuhkan waktu sekitar 40 menit</strong> .  Itu pernah terjadi pada kami, meskipun pada malam hari dengan lalu lintas minimum.  Karena itu, tidak ada yang terluka.  File kedua adalah sepasang server selama 5 menit, jadi ini tidak layak disebutkan. <br><br>  Sistem ini tidak di Open Source, tetapi jika Anda tertarik, tulis di komentar - itu mungkin ditata ( <em>Yuri dari masa depan: sistem masih belum di Open Source pada saat penulisan ini</em> ). <br><br><h2>  Kesimpulan </h2><br>  <strong>Dengarkan Rasmus, dia tidak berbohong</strong> .  Menurut pendapat saya, metode rsync-nya bersama dengan realpath_root adalah yang terbaik, meskipun loop juga bekerja dengan baik. <br><br>  <strong>Pikirkan dengan kepala Anda</strong> : lihat apa yang dibutuhkan proyek Anda, dan jangan mencoba membuat pesawat ruang angkasa di mana ada cukup "jagung".  Tetapi jika Anda masih memiliki persyaratan yang serupa, maka sistem yang mirip dengan MDK akan cocok untuk Anda. <br><br><blockquote>  Kami memutuskan untuk kembali ke topik ini, yang dibahas pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HighLoad ++</a> dan, mungkin, tidak mendapat perhatian, karena itu hanya satu dari banyak batu bata untuk mencapai kinerja tinggi.  Tetapi sekarang kami memiliki konferensi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PHP Rusia</a> profesional terpisah yang didedikasikan sepenuhnya untuk PHP.  Dan di sini kita benar-benar datang sepenuhnya.  Kami akan berbicara secara menyeluruh tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kinerja</a> , dan tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">standar</a> , dan tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alat</a> - banyak tentang itu, termasuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">refactoring</a> . <br><br>  Berlangganan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">saluran Telegram</a> dengan pembaruan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">program</a> konferensi dan sampai jumpa pada 17 Mei. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id449916/">https://habr.com/ru/post/id449916/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id449902/index.html">Jaringan TV kabel untuk yang terkecil. Bagian 2: Komposisi dan bentuk gelombang</a></li>
<li><a href="../id449904/index.html">Membuat dll proxy untuk membajak operasi dll memeriksa</a></li>
<li><a href="../id449906/index.html">Mendokumentasikan server REST (Node.JS, TypeScript, Koa, Joi, Swagger)</a></li>
<li><a href="../id449908/index.html">DDR3 atau DDR4? Mengapa kami menawarkan Dell R420 2x E5-2430 2.2Ghz 6C 128GB DDR3 2x960GB SSD 1Gbps seharga $ 99 di Belanda?</a></li>
<li><a href="../id449910/index.html">GitLab Shell Runner. Peluncuran kompetitif layanan pengujian menggunakan Docker Compose</a></li>
<li><a href="../id449918/index.html">Termometer inframerah dengan sensor MLX90614</a></li>
<li><a href="../id449920/index.html">10 cara non-standar untuk melukai SEO saat mengubah CMS (+1 bonus)</a></li>
<li><a href="../id449922/index.html">Test drive nanoCAD SPDS Metalwork 1.2. Bagian 3</a></li>
<li><a href="../id449926/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 362 (22 - 28 April 2019)</a></li>
<li><a href="../id449928/index.html">Tidak hanya memproses: Bagaimana kami membuat database terdistribusi dari Kafka Streams, dan apa yang terjadi</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>