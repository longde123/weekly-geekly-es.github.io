<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✝️ 👎 🚨 Kami sedang membangun templat C ++ lantai empat di RESTinio. Kenapa dan bagaimana? 🧗🏿 🙇🏻 🧑🏿‍🤝‍🧑🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="RESTinio adalah proyek yang relatif kecil, yang merupakan server HTTP asinkron yang dibangun ke dalam aplikasi C ++. Fitur karakteristiknya adalah pen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami sedang membangun templat C ++ lantai empat di RESTinio. Kenapa dan bagaimana?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456632/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">RESTinio</a> adalah proyek yang relatif kecil, yang merupakan server HTTP asinkron yang dibangun ke dalam aplikasi C ++.  Fitur karakteristiknya adalah penggunaan C ++ template yang tersebar luas, bisa dikatakan luas.  Baik dalam implementasi maupun dalam API publik. </p><br><p>  Templat C ++ di RESTinio digunakan dengan sangat aktif sehingga artikel pertama yang berbicara tentang RESTinio di Habr disebut " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Templat C ++ tiga lantai dalam implementasi server HTTP asinkron tertanam dengan wajah manusia</a> ." </p><br><p>  Templat tiga lantai.  Dan ini, secara umum, bukan kiasan. </p><br><p>  Dan baru-baru ini, kami sekali lagi memperbarui RESTinio, dan untuk menambahkan fungsionalitas baru ke versi 0.5.1, kami harus membuat "jumlah lantai" dari templat lebih tinggi.  Jadi di tempat-tempat template C ++ di RESTinio sudah empat lantai. </p><br><p><img src="https://habrastorage.org/webt/vz/t3/vw/vzt3vwbp8snyu3y7hhrcr6crela.jpeg"></p><br><p>  Dan jika seseorang bertanya-tanya mengapa kami membutuhkan ini dan bagaimana kami menggunakan templat, lalu tetap bersama kami, akan ada beberapa detail di bawah potongan.  Guru C ++ yang lazim tidak mungkin menemukan sesuatu yang baru untuk diri mereka sendiri, tetapi nama panggilan C ++ yang kurang canggih akan dapat melihat bagaimana templat digunakan untuk menyisipkan / menghapus bagian-bagian fungsionalitas.  Hampir di alam liar. </p><a name="habracut"></a><br><h1 id="slushatel-sostoyaniya-podklyucheniy">  Pendengar Status Koneksi </h1><br><p>  Fitur utama untuk versi 0.5.1 dibuat adalah kemampuan untuk memberi tahu pengguna bahwa status koneksi ke server HTTP telah berubah.  Misalnya, klien "jatuh" dan ini membuatnya tidak perlu memproses permintaan dari klien ini yang masih mengantri. </p><br><p>  Kami kadang ditanya tentang fitur ini dan sekarang tangan kami mencapai implementasinya.  Tapi sejak itu  tidak semua orang bertanya tentang fitur ini, ia berpikir bahwa itu harus opsional: jika beberapa pengguna membutuhkannya, maka biarkan ia secara eksplisit memasukkannya, dan semua yang lain tidak membayar apa pun untuk keberadaannya di RESTinio. </p><br><p>  Dan karena karakteristik utama dari server HTTP di RESTinio diatur melalui "properties" (ciri-ciri), diputuskan untuk mengaktifkan / menonaktifkan mendengarkan status koneksi melalui properti server. </p><br><h2 id="kak-polzovatel-zadaet-sobstvennogo-slushatelya-sostoyaniya-podklyucheniy">  Bagaimana cara pengguna mengatur pendengar mereka sendiri untuk status koneksi? </h2><br><p>  Untuk mengatur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pendengar</a> Anda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk status koneksi,</a> pengguna harus melakukan tiga langkah. </p><br><p>  Langkah # 1: tentukan kelas Anda sendiri, yang seharusnya memiliki metode state_changed non-statis dari formulir berikut: </p><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">state_changed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> restinio::connection_state::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">notice_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; notice)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span></span>;</code> </pre> <br><p>  Misalnya, bisa jadi seperti: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_state_listener</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex lock_; ... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">state_changed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> restinio::connection_state::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">notice_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; notice)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::lock_guard&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex&gt; l{lock_}; .... } ... };</code> </pre> <br><p>  Langkah # 2: di dalam properti server, Anda perlu mendefinisikan typedef yang disebut <code>connection_state_listener_t</code> , yang harus merujuk pada nama jenis yang dibuat pada langkah # 1: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_traits</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">default_traits_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> = my_state_listener; };</code> </pre> <br><p>  Dengan demikian, properti ini harus digunakan ketika memulai server HTTP: </p><br><pre> <code class="cpp hljs">restinio::run(restinio::on_thread_pool&lt;my_traits&gt;(<span class="hljs-number"><span class="hljs-number">8</span></span>)...);</code> </pre> <br><p>  Langkah # 3: pengguna harus membuat instance pendengarnya dan meneruskan pointer ini melalui shared_ptr di parameter server: </p><br><pre> <code class="cpp hljs">restinio::run( restinio::on_thread_pool&lt;my_traits&gt;(<span class="hljs-number"><span class="hljs-number">8</span></span>) .port(<span class="hljs-number"><span class="hljs-number">8080</span></span>) .address(<span class="hljs-string"><span class="hljs-string">"localhost"</span></span>) .request_handler(...) .connection_state_listener(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;my_state_listener&gt;(...)) ) );</code> </pre> <br><p>  Jika pengguna tidak melakukan panggilan ke metode <code>connection_state_listener</code> , pengecualian akan dilemparkan ketika memulai server HTTP: utara tidak dapat bekerja jika pengguna ingin menggunakan negara pendengar, tetapi tidak menentukan pendengar ini. </p><br><h3 id="a-esli-ne-zadavat-connection_state_listener_t">  Dan jika Anda tidak mengatur connection_state_listener_t? </h3><br><p>  Jika pengguna menetapkan nama <code>connection_state_listener_t</code> di properti server, maka ia harus memanggil metode <code>connection_state_listener</code> untuk mengatur parameter server.  Tetapi jika pengguna tidak menentukan <code>connection_state_listener_t</code> ? </p><br><p>  Dalam hal ini, nama <code>connection_state_listener_t</code> akan tetap ada di properti server, tetapi nama ini akan menunjuk ke tipe khusus <code>restinio::connection_state::noop_listener_t</code> . </p><br><p>  Bahkan, yang berikut ini terjadi: di RESTinio, ketika mendefinisikan sifat-sifat reguler, nilai <code>connection_state_listener_t</code> diatur.  Sesuatu seperti: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> restinio { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">default_traits_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">time_manager_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">asio_time_manager_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">logger_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">null_logger_t</span></span>; ... <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> = connection_state::<span class="hljs-keyword"><span class="hljs-keyword">noop_listener_t</span></span>; }; } <span class="hljs-comment"><span class="hljs-comment">/* namespace restinio */</span></span></code> </pre> <br><p>  Dan ketika pengguna mewarisi dari <code>restinio::default_traits_t</code> , definisi standar dari <code>connection_state_listener_t</code> juga diwarisi.  Tetapi jika nama baru <code>connection_state_listener_t</code> didefinisikan dalam kelas penerus: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_traits</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">default_traits_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> = my_state_listener; ... };</code> </pre> <br><p>  kemudian nama baru menyembunyikan definisi yang diwarisi untuk <code>connection_state_listener_t</code> .  Dan jika tidak ada definisi baru, maka definisi lama tetap terlihat. </p><br><p>  Jadi jika pengguna tidak menentukan nilainya sendiri untuk <code>connection_state_listener_t</code> , maka RESTinio akan menggunakan nilai default, <code>noop_listener_t</code> , yang diproses oleh RESTinio dengan cara khusus.  Sebagai contoh: </p><br><ul><li>  RESTinio sama sekali tidak menyimpan shared_ptr dalam hal ini untuk <code>connection_state_listener_t</code> .  Dan, karenanya, panggilan ke metode <code>connection_state_listener</code> dilarang (panggilan seperti itu akan menyebabkan kesalahan waktu kompilasi); </li><li>  RESTinio tidak melakukan panggilan tambahan terkait perubahan status koneksi. </li></ul><br><p>  Dan hanya tentang bagaimana semua ini tercapai dan akan dibahas di bawah ini. </p><br><h2 id="kak-eto-realizovano-v-restinio">  Bagaimana ini diterapkan di RESTinio? </h2><br><p>  Jadi, dalam kode RESTinio, Anda perlu memeriksa nilai apa yang dimiliki definisi <code>connection_state_listener_t</code> di properti server dan, tergantung pada nilai ini: </p><br><ul><li>  untuk menyimpan atau tidak menyimpan instance shared_ptr untuk objek bertipe <code>connecton_state_listener_t</code> ; </li><li>  mengizinkan atau melarang panggilan ke metode <code>connection_state_listener</code> untuk mengatur parameter server HTTP; </li><li>  memeriksa atau tidak memeriksa keberadaan pointer saat ini ke objek bertipe <code>connection_state_listener_t</code> sebelum memulai operasi server HTTP; </li><li>  melakukan atau tidak melakukan panggilan ke metode <code>state_changed</code> ketika kondisi koneksi ke klien berubah. </li></ul><br><p>  Juga ditambahkan ke kondisi batas yang masih dikembangkan RESTinio sebagai pustaka untuk C ++ 14, oleh karena itu, Anda tidak dapat menggunakan kemampuan C ++ 17 dalam implementasi (sama jika constexpr). </p><br><p>  Semua ini diimplementasikan melalui trik sederhana: kelas templat dan spesialisasi mereka untuk jenis <code>restinio::connection_state::noop_listener_t</code> .  Sebagai contoh, berikut adalah bagaimana penyimpanan shared_ptr dilakukan untuk objek bertipe <code>connection_state_listener_t</code> dalam parameter server.  Bagian satu: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Listener &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">connection_state_listener_holder_t</span></span></span><span class="hljs-class"> {</span></span> ... <span class="hljs-comment"><span class="hljs-comment">//  compile-time . std::shared_ptr&lt; Listener &gt; m_connection_state_listener; static constexpr bool has_actual_connection_state_listener = true; void check_valid_connection_state_listener_pointer() const { if( !m_connection_state_listener ) throw exception_t{ "connection state listener is not specified" }; } }; template&lt;&gt; struct connection_state_listener_holder_t&lt; connection_state::noop_listener_t &gt; { static constexpr bool has_actual_connection_state_listener = false; void check_valid_connection_state_listener_pointer() const { // Nothing to do. } };</span></span></code> </pre> <br><p>  Struktur template didefinisikan di sini yang memiliki konten yang bermanfaat atau tidak.  Hanya untuk tipe <code>noop_listener_t</code> , ia tidak memiliki konten yang berguna. </p><br><p>  Dan bagian dua: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Derived, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">basic_server_settings_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">socket_type_dependent_settings_t</span></span>&lt; Derived, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">stream_socket_t</span></span> &gt; , <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_holder_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> &gt; , <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ip_blocker_holder_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">ip_blocker_t</span></span> &gt; { ... };</code> </pre> <br><p>  Kelas yang berisi parameter untuk server HTTP diwarisi dari <code>connection_state_listener_holder_t</code> .  Dengan demikian, parameter server menunjukkan shared_ptr untuk objek bertipe <code>connection_state_listener_t</code> , atau tidak. </p><br><p>  Saya harus mengatakan bahwa menyimpan atau tidak menyimpan shared_ptr dalam parameter adalah bunga.  Tapi beri pergi ketika mencoba untuk membuat metode yang dimaksudkan untuk bekerja dengan pendengar negara di <code>basic_server_settings_t</code> tersedia hanya jika <code>connection_state_listener_t</code> berbeda dari <code>noop_listener_t</code> . </p><br><p>  Idealnya, saya ingin membuat kompiler “tidak melihat mereka” sama sekali.  Tapi saya disiksa untuk menulis kondisi untuk <code>std::enable_if</code> untuk menyembunyikan metode ini.  Oleh karena itu, itu hanya sebatas menambahkan static_asser: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Derived &amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connection_state_listener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Traits::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">connection_state_listener_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &gt; listener )</span></span></span><span class="hljs-function"> &amp; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( has_actual_connection_state_listener, <span class="hljs-string"><span class="hljs-string">"connection_state_listener(listener) can't be used "</span></span> <span class="hljs-string"><span class="hljs-string">"for the default connection_state::noop_listener_t"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;m_connection_state_listener = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(listener); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> reference_to_derived(); } <span class="hljs-function"><span class="hljs-function">Derived &amp;&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">connection_state_listener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">shared_ptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Traits::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">connection_state_listener_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &gt; listener )</span></span></span><span class="hljs-function"> &amp;&amp; </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;connection_state_listener(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(listener))); } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> &gt; &amp; connection_state_listener() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( has_actual_connection_state_listener, <span class="hljs-string"><span class="hljs-string">"connection_state_listener() can't be used "</span></span> <span class="hljs-string"><span class="hljs-string">"for the default connection_state::noop_listener_t"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;m_connection_state_listener; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ensure_valid_connection_state_listener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;check_valid_connection_state_listener_pointer(); }</code> </pre> <br><p>  Hanya ada saat lain ketika saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menyesal bahwa dalam C + + jika constexpr tidak sama dengan statis jika dalam D.</a>  Dan secara umum di C ++ 14 tidak ada yang serupa :( </p><br><p>  Di sini Anda juga dapat melihat ketersediaan metode <code>ensure_valid_connection_state_listener</code> .  Metode ini dipanggil dalam konstruktor <code>http_server_t</code> untuk memverifikasi bahwa parameter server berisi semua nilai yang diperlukan: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> D&gt; <span class="hljs-keyword"><span class="hljs-keyword">http_server_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">io_context_holder_t</span></span> io_context, <span class="hljs-keyword"><span class="hljs-keyword">basic_server_settings_t</span></span>&lt; D, Traits &gt; &amp;&amp; settings ) : m_io_context{ io_context.giveaway_context() } , m_cleanup_functor{ settings.giveaway_cleanup_func() } { <span class="hljs-comment"><span class="hljs-comment">// Since v.0.5.1 the presence of custom connection state // listener should be checked before the start of HTTP server. settings.ensure_valid_connection_state_listener(); ...</span></span></code> </pre> <br><p>  Pada saat yang sama, di dalam metode <code>ensure_valid_connection_state_listener</code> metode <code>ensure_valid_connection_state_listener</code> diwarisi dari <code>connection_state_listener_holder_t</code> <code>check_valid_connection_state_listener_pointer</code> , yang, karena spesialisasi <code>connection_state_listener_holder_t</code> , baik melakukan pemeriksaan aktual atau tidak melakukan apa-apa. </p><br><p>  Trik serupa digunakan baik untuk memanggil <code>state_changed</code> saat ini jika pengguna ingin menggunakan negara pendengar, atau tidak memanggil apa pun sebaliknya. </p><br><p>  Pertama, kita membutuhkan opsi <code>state_listener_holder_t</code> lain: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> connection_settings_details { <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Listener &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">state_listener_holder_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt; Listener &gt; m_connection_state_listener; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Settings &gt; <span class="hljs-keyword"><span class="hljs-keyword">state_listener_holder_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Settings &amp; settings ) : m_connection_state_listener{ settings.connection_state_listener() } {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Lambda &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call_state_listener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Lambda &amp;&amp; lambda )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ m_connection_state_listener-&gt;state_changed( lambda() ); } }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">state_listener_holder_t</span></span></span><span class="hljs-class">&lt; connection_state::noop_listener_t &gt; {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Settings &gt; <span class="hljs-keyword"><span class="hljs-keyword">state_listener_holder_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Settings &amp; ) { <span class="hljs-comment"><span class="hljs-comment">/* nothing to do */</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Lambda &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">call_state_listener</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Lambda &amp;&amp; </span></span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-params"><span class="hljs-comment">/*lambda*/</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* nothing to do */</span></span> } }; } <span class="hljs-comment"><span class="hljs-comment">/* namespace connection_settings_details */</span></span></code> </pre> <br><p>  Tidak seperti <code>connection_state_listener_holder_t</code> , yang diperlihatkan sebelumnya dan yang digunakan untuk menyimpan pendengar status koneksi dalam parameter seluruh server (mis., Pada objek tipe <code>basic_server_settings_t</code> ), <code>state_listener_holder_t</code> ini akan digunakan untuk tujuan yang sama, tetapi tidak dalam parameter seluruh server, tetapi dari parameter terpisah dari seluruh server koneksi: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">connection_settings_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::enable_shared_from_this&lt; <span class="hljs-keyword"><span class="hljs-keyword">connection_settings_t</span></span>&lt; Traits &gt; &gt; , <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> connection_settings_details::<span class="hljs-keyword"><span class="hljs-keyword">state_listener_holder_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> &gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_holder_t</span></span> = connection_settings_details::<span class="hljs-keyword"><span class="hljs-keyword">state_listener_holder_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Traits::<span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_t</span></span> &gt;; ...</code> </pre> <br><p>  Ada dua fitur di sini. </p><br><p>  Pertama, menginisialisasi <code>state_listener_holder_t</code> .  Itu diperlukan atau tidak.  Tetapi hanya <code>state_listener_holder_t</code> tahu tentang itu.  Oleh karena itu, <code>connection_settings_t</code> constructor cukup "menarik" konstruktor <code>state_listener_holder_t</code> , seperti kata mereka, untuk berjaga-jaga: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Settings &gt; <span class="hljs-keyword"><span class="hljs-keyword">connection_settings_t</span></span>( Settings &amp;&amp; settings, http_parser_settings parser_settings, <span class="hljs-keyword"><span class="hljs-keyword">timer_manager_handle_t</span></span> timer_manager ) : <span class="hljs-keyword"><span class="hljs-keyword">connection_state_listener_holder_t</span></span>{ settings } , m_request_handler{ settings.request_handler() }</code> </pre> <br><p>  Dan konstruktor <code>state_listener_holder_t</code> melakukan tindakan yang diperlukan atau tidak melakukan apa-apa sama sekali (dalam kasus terakhir, kompiler yang kurang lebih masuk akal tidak akan menghasilkan kode apa pun untuk menginisialisasi <code>state_listener_holder_t</code> ). </p><br><p>  Kedua, itu adalah metode <code>state_listner_holder_t::call_state_listener</code> , yang membuat panggilan <code>state_changed</code> menjadi pendengar status.  Atau tidak, jika tidak ada pendengar negara.  <code>call_state_listener</code> di tempat-tempat RESTinio mendiagnosis perubahan dalam kondisi koneksi.  Misalnya, ketika terdeteksi bahwa koneksi telah ditutup: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">close</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_logger.trace( [&amp;]{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt::format( <span class="hljs-string"><span class="hljs-string">"[connection:{}] close"</span></span>, connection_id() ); } ); ... <span class="hljs-comment"><span class="hljs-comment">// Inform state listener if it used. m_settings-&gt;call_state_listener( [this]() noexcept { return connection_state::notice_t{ this-&gt;connection_id(), this-&gt;m_remote_endpoint, connection_state::cause_t::closed }; } ); }</span></span></code> </pre> <br><p>  <code>call_state_listener</code> diteruskan ke <code>call_state_listener</code> , dari mana objek <code>notice_t</code> dengan informasi status koneksi dikembalikan.  Jika ada pendengar yang sebenarnya, maka lambda ini memang akan dipanggil, dan nilai yang dikembalikan olehnya akan diteruskan ke <code>state_changed</code> . </p><br><p>  Namun, jika tidak ada pendengar, maka <code>call_state_listener</code> akan kosong dan, karenanya, lambda tidak akan dipanggil.  Bahkan, kompiler normal hanya membuang semua panggilan ke <code>call_state_listener</code> kosong.  Dan dalam hal ini, dalam kode yang dihasilkan tidak akan ada yang terkait dengan status koneksi yang sedang diakses oleh pendengar. </p><br><h1 id="esche-i-ip-blocker">  Juga pemblokir IP </h1><br><p>  Dalam RESTinio-0.5.1, selain pendengar status koneksi, hal seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">IP-blocker</a> ditambahkan.  Yaitu  pengguna dapat menentukan objek yang RESTinio akan "tarik" untuk setiap koneksi masuk yang baru.  Jika pemblokir IP mengatakan bahwa Anda dapat bekerja dengan koneksi, maka RESTinio memulai pemeliharaan koneksi baru yang biasa (pembacaan dan parsing permintaan, memanggil penangan permintaan, mengontrol timeout, dll).  Tetapi jika IP-blocker melarang bekerja dengan koneksi, maka RESTinio dengan bodohnya menutup koneksi ini dan tidak melakukan apa-apa lagi dengannya. </p><br><p>  Seperti pendengar negara, IP-blocker adalah fitur opsional.  Untuk menggunakan pemblokir IP, Anda harus mengaktifkannya secara eksplisit.  Melalui properti dari server HTTP.  Sama seperti dengan pendengar status koneksi.  Dan implementasi dukungan pemblokir IP di RESTinio menggunakan teknik yang sama yang telah dijelaskan di atas.  Karenanya, kami tidak akan membahas bagaimana IP-blocker digunakan di dalam RESTinio.  Sebagai gantinya, pertimbangkan sebuah contoh di mana pemblokir IP dan pendengar status adalah objek yang sama. </p><br><h2 id="razbor-shtatnogo-primera-ip_blocker">  Analisis contoh standar ip_blocker </h2><br><p>  Dalam versi 0.5.1, contoh lain termasuk dalam contoh RESTinio standar: <a href="">ip_blocker</a> .  Contoh ini menunjukkan bagaimana Anda dapat membatasi jumlah koneksi bersamaan ke server dari satu alamat IP. </p><br><p>  Ini tidak hanya akan memerlukan pemblokir IP, yang akan mengizinkan atau melarang penerimaan koneksi.  Tetapi juga pendengar untuk status koneksi.  Seorang pendengar diperlukan untuk melacak saat-saat membuat dan menutup koneksi. </p><br><p>  Pada saat yang sama, pemblokir IP dan pendengar akan membutuhkan kumpulan data yang sama.  Oleh karena itu, solusi paling sederhana adalah membuat pemblokir dan pendengar IP objek yang sama. </p><br><p>  Tidak masalah, kami dapat dengan mudah melakukan ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">blocker_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::mutex m_lock; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">connections_t</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">map</span></span>&lt; restinio::asio_ns::ip::address, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; restinio::<span class="hljs-keyword"><span class="hljs-keyword">connection_id_t</span></span> &gt; &gt;; <span class="hljs-keyword"><span class="hljs-keyword">connections_t</span></span> m_connections; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">//   IP-blocker-. restinio::ip_blocker::inspection_result_t inspect( const restinio::ip_blocker::incoming_info_t &amp; info ) noexcept {...} //     . void state_changed( const restinio::connection_state::notice_t &amp; notice ) noexcept {...} };</span></span></code> </pre> <br><p>  Di sini kita tidak memiliki warisan dari antarmuka apa pun atau penggantian metode virtual bawaan.  Satu-satunya persyaratan bagi pendengar adalah keberadaan metode <code>state_changed</code> .  Persyaratan ini terpenuhi. </p><br><p>  Demikian juga, dengan satu-satunya persyaratan untuk pemblokir IP: apakah ada metode <code>inspect</code> dengan tanda tangan yang diperlukan?  Ada!  Jadi semuanya baik-baik saja. </p><br><p>  Maka tetap untuk menentukan properti yang benar untuk server HTTP: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">my_traits_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">default_traits_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">logger_t</span></span> = restinio::<span class="hljs-keyword"><span class="hljs-keyword">shared_ostream_logger_t</span></span>; <span class="hljs-comment"><span class="hljs-comment">//      . using connection_state_listener_t = blocker_t; using ip_blocker_t = blocker_t; };</span></span></code> </pre> <br><p>  Kemudian tinggal membuat instance dari <code>blocker_t</code> dan meneruskannya ke parameter ke server HTTP: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> blocker = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;<span class="hljs-keyword"><span class="hljs-keyword">blocker_t</span></span>&gt;(); restinio::run( ioctx, restinio::on_thread_pool&lt;<span class="hljs-keyword"><span class="hljs-keyword">my_traits_t</span></span>&gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread::hardware_concurrency() ) .port( <span class="hljs-number"><span class="hljs-number">8080</span></span> ) .address( <span class="hljs-string"><span class="hljs-string">"localhost"</span></span> ) .connection_state_listener( blocker ) .ip_blocker( blocker ) .max_pipelined_requests( <span class="hljs-number"><span class="hljs-number">4</span></span> ) .handle_request_timeout( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::seconds{<span class="hljs-number"><span class="hljs-number">20</span></span>} ) .request_handler( [&amp;ioctx](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> handler( ioctx, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(req) ); } ) );</code> </pre> <br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><h2 id="o-cnyh-shablonah">  Tentang C ++ Templates </h2><br><p>  Menurut pendapat saya, template C ++ adalah apa yang disebut senjata terlalu besar.  Yaitu  fitur yang sangat kuat sehingga Anda tanpa sadar harus berpikir tentang bagaimana dan bagaimana penggunaannya dibenarkan.  Oleh karena itu, komunitas C ++ modern seolah-olah dibagi menjadi beberapa kubu yang bertikai. </p><br><p>  Perwakilan salah satu dari mereka lebih memilih untuk menjauh dari template.  Karena templatnya kompleks, mereka menghasilkan panjang lembar pesan kesalahan yang tidak terbaca, yang secara signifikan meningkatkan waktu kompilasi.  Belum lagi legenda urban tentang kembung kode dan mengurangi kinerja. </p><br><p>  Perwakilan dari kamp lain (seperti saya) percaya bahwa template adalah salah satu aspek paling kuat dari C ++.  Bahkan mungkin bahwa templat adalah salah satu dari sedikit keunggulan kompetitif paling serius dari C ++ di dunia modern.  Oleh karena itu, menurut saya, masa depan C ++ justru merupakan templat.  Dan beberapa ketidaknyamanan saat ini yang terkait dengan penggunaan template yang luas (seperti kompilasi yang panjang dan padat sumber daya atau pesan kesalahan yang tidak informatif) akan dihilangkan dengan satu atau lain cara dari waktu ke waktu. </p><br><p>  Oleh karena itu, menurut saya pribadi bahwa pendekatan yang dipilih selama implementasi RESTinio, yaitu meluasnya penggunaan templat dan menentukan karakteristik server HTTP melalui properti, masih terbayar.  Berkat ini, kami mendapatkan kustomisasi yang baik untuk kebutuhan spesifik.  Dan pada saat yang sama, dalam arti harfiah, kita tidak membayar apa yang tidak kita gunakan. </p><br><p>  Namun, di sisi lain, tampaknya pemrograman dalam template C ++ masih terlalu rumit.  Anda terutama merasakannya ketika Anda harus memprogram tidak terus-menerus, tetapi ketika beralih di antara berbagai aktivitas.  Anda akan terganggu selama beberapa minggu dari pengkodean, maka Anda akan kembali dan mulai dengan jujur ​​dan khususnya bodoh jika perlu, menyembunyikan beberapa metode menggunakan SFINAE atau memeriksa apakah ada metode dengan tanda tangan tertentu pada objek. </p><br><p>  Jadi bagus ada template di C ++.  Akan lebih baik jika mereka dibawa ke keadaan seperti itu sehingga bahkan pemula seperti saya dapat dengan mudah menggunakan C ++ templates tanpa harus mempelajari cppreference dan stackoverflow setiap 10-15 menit. </p><br><h2 id="o-tekuschem-sostoyanii-restinio-i-buduschey-funkcionalnosti-restinio-i-ne-tolko-restinio">  Tentang keadaan RESTinio saat ini dan fungsionalitas RESTinio di masa mendatang.  Dan bukan hanya RESTinio </h2><br><p>  Saat ini, RESTinio sedang mengembangkan prinsip "ketika ada waktu dan ada keinginan".  Misalnya, pada musim gugur 2018 dan pada musim dingin 2019, kami tidak punya banyak waktu untuk pengembangan RESTinio.  Mereka menjawab pertanyaan pengguna, membuat perubahan kecil, tetapi untuk sesuatu yang lebih, sumber daya kami tidak cukup. </p><br><p>  Tetapi pada akhir musim semi 2019, ada waktu untuk RESTinio, dan kami pertama kali membuat RESTinio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">0.5.0</a> , dan kemudian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">0.5.1</a> .  Pada saat yang sama, persediaan Daftar Keinginan kami dan orang lain habis.  Yaitu  apa yang ingin kami lihat di RESTinio dan apa yang diberitahukan pengguna tentang kami, sudah ada di RESTinio. </p><br><p>  Jelas, RESTinio dapat diisi dengan lebih banyak lagi.  Tapi apa sebenarnya? </p><br><p>  Dan di sini jawabannya sangat sederhana: hanya apa yang diminta untuk masuk ke RESTinio.  Karenanya, jika Anda ingin melihat sesuatu yang Anda butuhkan di RESTinio, maka luangkan waktu untuk memberi tahu kami tentang hal itu (misalnya, melalui masalah pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GitHub</a> atau <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BitBucket</a> , baik melalui <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">grup Google</a> , atau langsung di komentar di sini di Habré) .  Anda tidak akan mengatakan apa pun - Anda tidak akan menerima apa-apa;) </p><br><p>  Sebenarnya, situasi yang sama adalah dengan proyek kami yang lain, khususnya dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SObjectizer</a> .  Versi baru mereka akan dirilis setelah menerima Daftar Keinginan dimengerti. </p><br><p>  Yah, dan akhirnya, saya ingin menawarkan kepada semua orang yang belum mencoba RESTinio: coba <del>  gratis </del>  tidak sakit.  Tiba-tiba menyukainya.  Dan jika Anda tidak menyukainya, maka bagikan apa tepatnya.  Ini akan membantu kami untuk membuat RESTinio lebih nyaman dan fungsional. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id456632/">https://habr.com/ru/post/id456632/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id456616/index.html">3 juta rubel untuk mereka yang bisa kode</a></li>
<li><a href="../id456618/index.html">Larabeer Moscow - 21 Juni</a></li>
<li><a href="../id456622/index.html">Cara membuat OS bersertifikat berdasarkan perlindungan kelas I</a></li>
<li><a href="../id456624/index.html">Alat Python yang Berguna</a></li>
<li><a href="../id456630/index.html">Memperkenalkan Aliran Udara untuk mengelola Spark Jobs di ivi: harapan dan tongkat penyangga</a></li>
<li><a href="../id456634/index.html">Resep Nginx: CAS (Layanan Otorisasi Pusat)</a></li>
<li><a href="../id456638/index.html">Membandingkan proyek yang sama di Rust, Haskell, C ++, Python, Scala, dan OCaml</a></li>
<li><a href="../id456640/index.html">Analisis kontes intelijen kompetitif di PHDays 9</a></li>
<li><a href="../id456642/index.html">Kelulusan pertama program Master Perusahaan JetBrains dan Universitas ITMO</a></li>
<li><a href="../id456644/index.html">Printer polimer foto 3D yang lebih murah muncul di Kickstarter</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>