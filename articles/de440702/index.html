<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😰 👨‍👨‍👧‍👧 🥇 Achtung - GAS! oder wie wir intelligente Verträge ohne Kohlensäure abgeschlossen haben 👩🏼‍🎨 💇 📰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Blockchain- und Smart-Verträge sind nach wie vor ein heißes Thema bei Entwicklern und Technikern. Es gibt viel Forschung und Diskussion über ihre Zuku...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Achtung - GAS! oder wie wir intelligente Verträge ohne Kohlensäure abgeschlossen haben</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/waves/blog/440702/"><p><img src="https://habrastorage.org/webt/ps/lh/d4/pslhd4hgoxgjskexszwtn40mivo.png"></p><br><p>  Blockchain- und Smart-Verträge sind nach wie vor ein heißes Thema bei Entwicklern und Technikern.  Es gibt viel Forschung und Diskussion über ihre Zukunft und wohin sich alles bewegt und wohin es führen wird.  Wir von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Waves Platform haben</a> unsere eigene Meinung dazu, was intelligente Verträge sein sollten, und in diesem Artikel werde ich Ihnen erklären, wie wir sie abgeschlossen haben, auf welche Probleme wir gestoßen sind und warum sie nicht wie intelligente Verträge anderer Blockchain-Projekte sind (vor allem) Ethereum). </p><br><p>  Dieser Artikel ist auch ein Leitfaden für diejenigen, die verstehen möchten, wie intelligente Verträge im Waves-Netzwerk funktionieren, versuchen, einen eigenen Vertrag zu schreiben und sich mit den Tools vertraut zu machen, über die Entwickler bereits verfügen. </p><a name="habracut"></a><br><h2 id="kak-my-doshli-do-zhizni-takoy">  Wie sind wir zu einem solchen Leben gekommen? </h2><br><p>  Wir wurden oft gefragt, wann wir intelligente Verträge erhalten haben, weil die Entwickler die einfache Arbeit mit dem Netzwerk, die Netzwerkgeschwindigkeit (dank <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Waves NG</a> ) und die geringen Provisionen mochten.  Intelligente Verträge bieten jedoch viel mehr Raum für Fantasie. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intelligente Verträge</a> sind in den letzten Jahren aufgrund der Verbreitung der Blockchain sehr beliebt geworden.  Diejenigen, die bei ihrer Arbeit auf Blockchain-Technologie gestoßen sind, denken bei der Erwähnung intelligenter Verträge normalerweise an Ethereum und Solidity.  Es gibt jedoch viele Blockchain-Plattformen mit intelligenten Verträgen, und die meisten von ihnen haben einfach wiederholt, was Ethereum getan hat (virtuelle Maschine + ihre eigene Vertragssprache).  Eine interessante Liste mit verschiedenen Sprachen und Ansätzen befindet sich in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Repository</a> . </p><br><h2 id="chto-takoe-smart-kontrakt">  Was ist ein intelligenter Vertrag? </h2><br><p>  Im weitesten Sinne ist ein intelligenter Vertrag ein Protokoll zur Unterstützung, Überprüfung und Durchsetzung der Bedingungen einer Transaktion oder der Ausführung von Verträgen zwischen Parteien.  Die Idee wurde erstmals 1996 von Nick Szabo vorgeschlagen, aber intelligente Verträge sind erst in den letzten Jahren populär geworden. </p><br><p>  Aus technischer Sicht (was uns mehr interessiert) ist ein intelligenter Vertrag ein Algorithmus (Code), der nicht auf einem Server oder Computer ausgeführt wird, sondern auf vielen (oder allen) Knoten im Blockchain-Netzwerk, d. H.  dezentralisiert. </p><br><h2 id="kak-eto-rabotaet">  Wie funktioniert es </h2><br><p>  Der erste Prototyp eines intelligenten Vertrags in der Blockchain wird korrekt als Bitcoin-Skript betrachtet - unvollständig von Turing, einer stapelbasierten Sprache im Bitcoin-Netzwerk.  In Bitcoin gibt es kein Kontokonzept, stattdessen gibt es Ein- und Ausgänge.  In Bitcoin muss beim Erstellen einer Transaktion (Erstellen einer Ausgabe) auf die empfangene Transaktion (Eingabe) verwiesen werden.  Wenn Sie an den technischen Details des Bitcoin-Geräts interessiert sind, empfehle ich Ihnen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese Artikelserie zu</a> lesen.  Da Bitcoin keine Konten enthält, bestimmt Bitcoin Script, in welchem ​​Fall der eine oder andere Exit ausgegeben werden kann. </p><br><p> Ethereum bietet viel mehr Funktionen als  Bietet Solidity, eine Turing-vollständige Sprache, die in einer virtuellen Maschine in jedem Knoten ausgeführt wird.  Mit großer Kraft geht große Verantwortung und eine Vielzahl von Möglichkeiten einher - eine ziemlich große Anzahl von Einschränkungen, über die wir später sprechen werden. </p><br><h1 id="smart-kontrakty-waves">  Intelligente Verträge Wellen </h1><br><p>  Wie ich oben schrieb, wurden wir oft nach intelligenten Verträgen gefragt, aber wir wollten nicht "like on air" oder "like in anyblockchainname" machen, und es gibt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">viele Gründe dafür</a> .  Daher haben wir die bestehenden Fälle für Verträge analysiert und wie wir mit ihrer Hilfe helfen können, echte Probleme zu lösen. </p><br><p>  Nach der Analyse der Nutzungsszenarien haben wir festgestellt, dass es zwei große Kategorien von Aufgaben gibt, die normalerweise mit intelligenten Verträgen gelöst werden: </p><br><ol><li>  Einfache und unkomplizierte Aufgaben wie Multisig, Atomic Swaps oder Escrow. </li><li>  dApps, vollwertige dezentrale Anwendungen mit Benutzerlogik.  Genauer gesagt ist dies ein Backend für dezentrale Anwendungen.  Die auffälligsten Beispiele sind Cryptokitties oder Bancor. </li></ol><br><p>  Es gibt auch eine dritte, beliebteste Art von Verträgen - Token.  Im Ethereum-Netzwerk beispielsweise sind die meisten Arbeitsverträge ERC20-Standard-Token.  In Waves müssen zum Erstellen von Token keine intelligenten Verträge abgeschlossen werden  Sie sind Teil der Blockchain selbst. Um ein Token auszugeben (mit der Möglichkeit, es sofort an einer dezentralen Börse (DEX) zu handeln), reicht es aus, eine Transaktion des Ausgabetyps (Ausgabetransaktion) zu senden. </p><br><p>  Für die beiden oben genannten Arten von Aufgaben (der Einfachheit halber werden wir einfache und komplexe Fälle nennen) sind die Anforderungen an Sprache, Verträge und Konzepte sehr unterschiedlich.  Ja, wir können sagen, dass eine Turing-vollständige Sprache sowohl einfache als auch komplexe Probleme lösen kann, aber es gibt eine wichtige Bedingung: Die Sprache sollte helfen, Fehler zu vermeiden.  Diese Anforderung ist auch für gewöhnliche Sprachen wichtig, und für intelligente Vertragssprachen ist sie besonders wichtig, weil  Operationen sind finanziell miteinander verbunden, und Verträge sind oft unveränderlich, und es gibt keine Möglichkeit, einen Fehler schnell und einfach zu beheben. </p><br><p>  Angesichts der oben beschriebenen Aufgabentypen haben wir uns entschlossen, schrittweise voranzukommen und als ersten Schritt ein Werkzeug zur Lösung einfacher Probleme bereitzustellen und als nächsten Schritt eine Sprache anzugeben, mit der jede Benutzerlogik problemlos implementiert werden kann.  Infolgedessen erwies sich das System als viel leistungsfähiger, als wir es uns zu Beginn der Reise vorgestellt hatten. </p><br><h2 id="sdelaem-akkaunty-umnymi">  Lassen Sie uns Konten intelligent machen </h2><br><p>  Allmählich kamen wir zum Konzept der Smart Accounts, mit denen vor allem einfache Aufgaben gelöst werden sollen.  Ihre Idee ist Bitcoin Script sehr ähnlich: Dem Konto können zusätzliche Regeln hinzugefügt werden, die die Gültigkeit der ausgehenden Transaktion bestimmen.  Die Hauptanforderungen für Smart Accounts waren: </p><br><ol><li>  Maximale Sicherheit.  Fast jeden Monat finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Neuigkeiten,</a> dass in Ethereum-Modellverträgen eine weitere Sicherheitslücke gefunden wurde.  Das wollten wir vermeiden. </li><li>  Kein Gasbedarf, so dass die Provision feststeht.  Dazu muss das Skript in einer vorhersehbaren Zeit ausgeführt werden und recht strenge Größenbeschränkungen aufweisen. </li></ol><br><p>  Bevor wir mit den technischen Details der Implementierung und des Schreibens von Verträgen fortfahren, skizzieren wir einige Merkmale der Waves-Blockchain, die für das weitere Verständnis wichtig sind: </p><br><ol><li>  Die Waves-Blockchain verfügt derzeit über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">13 verschiedene Arten von Transaktionen.</a> </li></ol><br><p><img src="https://habrastorage.org/webt/dx/to/mz/dxtomzcjjyp7jgwa9wcsmfana1u.png"></p><br><ol><li>  In der Waves-Blockchain keine Ein- und Ausgänge (wie in Bitcoin), sondern Konten (wie zum Beispiel in Nxt).  Eine Transaktion wird für ein bestimmtes Konto ausgeführt. </li><li>  Standardmäßig wird die Richtigkeit einer Transaktion durch den aktuellen Status der Blockchain und die Gültigkeit der Signatur bestimmt, für die die Transaktion gesendet wird.  Die JSON-Darstellung der Transaktion sieht einfach aus: </li></ol><br><p><img src="https://habrastorage.org/webt/gl/0a/m-/gl0am-s8dyjwnsgnksk0tf1fzyu.png"></p><br><p> Da wir bereits verschiedene Arten von Transaktionen in der Blockchain haben, haben wir beschlossen, keine separate Entität als Smart-Konto zu erstellen, sondern eine neue Transaktion hinzuzufügen, die aus einem regulären Konto ein Smart-Konto macht.  Jedes Konto kann zu einem Smart-Konto mit geänderten Transaktionsüberprüfungsregeln werden. Dazu sollte das Konto einfach eine Transaktion vom Typ <code>SetScriptTransaction</code> , die den kompilierten Vertrag enthält. </p><br><p>  Bei einem Smart Account ist der Vertrag eine Validierungsregel für jede ausgehende Transaktion. </p><br><h2 id="a-chto-tam-s-gazom">  Und was ist mit dem Gas? </h2><br><p>  Eine der Hauptaufgaben, die wir uns stellen, ist es, Gas für einfache Operationen loszuwerden.  Dies bedeutet nicht, dass keine Provision anfällt.  Es wird benötigt, damit Bergleute ein Interesse daran haben, Skripte auszuführen.  Wir näherten uns dem Problem von der praktischen Seite und beschlossen, Leistungstests durchzuführen und die Geschwindigkeit verschiedener Vorgänge zu berechnen.  Hierzu wurden Benchmarks mit JMH entwickelt.  Ergebnisse können hier gesehen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> .  Die daraus resultierenden Einschränkungen sind: </p><br><ol><li>  Das Skript sollte schneller als 20 Signaturüberprüfungsvorgänge ausgeführt werden. Dies bedeutet, dass die Überprüfung für ein Smart-Konto nicht mehr als 20-mal langsamer ist als für ein reguläres Konto.  Die Größe des Skripts sollte 8 KB nicht überschreiten. </li><li>  Damit Bergleute intelligente Verträge erfüllen können, legen wir eine zusätzliche Mindestprovision für intelligente Konten in Höhe von 0,004 WAVES fest.  Die Mindestprovision im Waves-Netzwerk für eine Transaktion beträgt 0,001 WAVES, bei einem Smart Account 0,005 WAVES. </li></ol><br><h1 id="yazyk-dlya-smart-kontraktov">  Sprache für intelligente Verträge </h1><br><p>  Eine der schwierigsten Aufgaben war die Schaffung einer eigenen Sprache für intelligente Verträge.  Es scheint, als würde man mit einer Kanone auf Spatzen schießen, wenn man eine vorhandene Turing-vollständige Sprache verwendet und sich an unsere Aufgaben anpasst (trimmt). Außerdem ist es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">äußerst riskant</a> , abhängig von der Codebasis eines anderen in einem Blockchain-Projekt. </p><br><p>  Versuchen wir uns vorzustellen, was die ideale Sprache für intelligente Verträge sein sollte.  Meiner Meinung nach sollte jede Programmiersprache das Schreiben von "korrektem" und sicherem Code erzwingen, d. H.  Idealerweise sollte es einen richtigen Weg geben.  Ja, wenn Sie möchten, können Sie vollständig unlesbaren und nicht unterstützten Code in jeder Sprache schreiben. Dies sollte jedoch schwieriger sein als das korrekte Schreiben (Hallo PHP und JavaScript).  Gleichzeitig sollte die Sprache für die Entwicklung geeignet sein.  Da die Sprache auf allen Knoten des Netzwerks ausgeführt wird, muss sie so effizient wie möglich sein. Eine verzögerte Ausführung kann eine Menge Ressourcen sparen.  Ich hätte auch gerne ein leistungsfähiges Typensystem in der Sprache, vorzugsweise algebraisch, weil es hilft, den Vertrag so klar wie möglich zu beschreiben und dem Traum von "Code is law" näher zu kommen.  Wenn wir unsere Anforderungen etwas weiter formalisieren, erhalten wir die folgenden Sprachparameter: </p><br><ol><li>  Seien Sie streng und statisch typisiert.  Durch starkes Tippen werden viele potenzielle Programmiererfehler automatisch beseitigt. </li><li>  Haben Sie ein leistungsstarkes Typsystem, das es schwieriger macht, sich in den Fuß zu schießen. </li><li>  Seien Sie faul, damit Sie keine wertvollen Prozessorzyklen verschwenden. </li><li>  Verfügen Sie in der Standardbibliothek über bestimmte Funktionen für die Arbeit mit Blockchain, z. B. Hashes.  Gleichzeitig sollte die Standard-Sprachbibliothek nicht überlastet werden, da es immer einen richtigen Weg geben sollte. </li><li>  Haben Sie keine Ausnahmen in der Laufzeit. </li></ol><br><p>  In unserer RIDE-Sprache haben wir versucht, diese wichtigen Funktionen zu berücksichtigen. Da wir viel auf Scala entwickeln und die funktionale Programmierung mögen, ähnelt die Sprache in mancher Hinsicht Scala und F #. </p><br><p>  Die größten Probleme bei der Implementierung in der Praxis traten bei der letzten Anforderung auf, denn wenn Sie keine Ausnahmen in der Sprache haben, muss der Additionsvorgang beispielsweise eine <em>Option zurückgeben</em> , die auf Überlauf überprüft werden muss, was für Entwickler definitiv unpraktisch ist.  Ausnahmen waren ein Kompromiss, aber ohne die Fähigkeit, sie abzufangen - wenn es eine Ausnahme gab, war die Transaktion ungültig.  Ein weiteres Problem bestand darin, alle Datenmodelle, die wir in der Blockchain haben, in die Sprache zu übertragen.  Ich habe bereits beschrieben, dass es in Waves 13 verschiedene Arten von Transaktionen gibt, die in der Sprache unterstützt werden müssen und Zugriff auf alle ihre Felder erhalten müssen. </p><br><p>  Ausführliche Informationen zu verfügbaren Vorgängen und Datentypen in RIDE finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Sprachbeschreibungsseite</a> .  Unter den interessanten Merkmalen der Sprache können wir auch die Tatsache hervorheben, dass die Sprache ausdrucksbasiert ist, dh alles ist Ausdruck, sowie das Vorhandensein eines Mustervergleichs, mit dem Sie die Bedingungen für verschiedene Arten von Transaktionen bequem beschreiben können: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t:<span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; t.recepient <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t:<span class="hljs-type"><span class="hljs-type">MassTransferTransaction</span></span> =&gt; t.transfers <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> }</code> </pre> <br><p>  Wenn Sie wissen möchten, wie die Arbeit mit RIDE-Code funktioniert, lesen Sie das Whitepaper, in dem alle Phasen der Vertragsarbeit beschrieben sind: Parsen, Kompilieren, Deserialisieren, Berechnen der Skriptkomplexität und -ausführung.  Die ersten beiden Phasen - Parsen und Kompilieren - werden außerhalb der Kette ausgeführt. Nur der in base64 kompilierte Vertrag wird in die Blockchain aufgenommen.  Deserialisierung, Komplexitätsberechnung und Ausführung werden in der Kette und mehrmals in verschiedenen Phasen durchgeführt: </p><br><ol><li>  Wenn Sie eine Transaktion empfangen und zu UTX hinzufügen, kann es vorkommen, dass die Transaktion vom Blockchain-Knoten akzeptiert wird, z. B. über die REST-API, aber niemals in den Block gelangt. </li><li>  Wenn ein Block gebildet wird, überprüft der Mining-Knoten Transaktionen und das Skript ist erforderlich. </li><li>  Nach Empfang eines Blocks bei Nicht-Mining-Knoten und Validierung der darin enthaltenen Transaktionen. </li></ol><br><p>  Jede Optimierung bei der Arbeit mit Verträgen wird wertvoll, da sie auf vielen Netzwerkknoten mehrmals durchgeführt wird.  Jetzt laufen Waves-Knoten bei DigitalOcean für 15 US-Dollar leise auf virtuellen Maschinen, obwohl die Arbeitslast nach der Veröffentlichung von Smart Accounts gestiegen ist. </p><br><h2 id="a-chto-v-itoge">  Was ist das Ergebnis? </h2><br><p>  Nun wollen wir sehen, was wir bei Waves bekommen haben.  Wir werden unseren ersten eigenen Vertrag schreiben, es sei ein Standard-Multisig-2-aus-3-Vertrag.  Um einen Vertrag zu schreiben, können Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Online-IDE verwenden</a> (Abstimmung auf die Sprache - ein Thema für einen separaten Artikel).  Erstellen Sie einen neuen leeren Vertrag (Neu → Leerer Vertrag). </p><br><p>  Zunächst werden wir die öffentlichen Schlüssel von Alice, Bob und Cooper bekannt geben, die das Konto kontrollieren werden.  Sie benötigen 2 ihrer 3 Unterschriften: </p><br><pre> <code class="scala hljs">let alicePubKey = base58<span class="hljs-symbol"><span class="hljs-symbol">'B1Yz7fH1bJ2gVDjyJnuyKNTdMFARkKEp</span></span>V' let bobPubKey = base58<span class="hljs-symbol"><span class="hljs-symbol">'7hghYeWtiekfebgAcuCg9ai2NXbRreNz</span></span>c' let cooperPubKey = base58<span class="hljs-symbol"><span class="hljs-symbol">'BVqYXrapgJP9atQccdBPAgJPwHDKkh6A</span></span>8'</code> </pre> <br><p>  In der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation wird</a> die Funktion <code>sigVerify</code> beschrieben, mit der Sie die Transaktionssignatur überprüfen können: </p><br><p><img src="https://habrastorage.org/webt/fw/am/py/fwampygopgdhgrmb9v4z67mkszq.png"></p><br><p>  Die Argumente für die Funktion sind der Hauptteil der Transaktion, die verifizierte Signatur und der öffentliche Schlüssel.  Im globalen Bereich ist ein <code>tx</code> Objekt im Vertrag verfügbar, in dem Transaktionsinformationen gespeichert sind.  Dieses Objekt verfügt über ein Feld <code>tx.bodyBytes</code> , das die Bytes der gesendeten Transaktion enthält.  Es gibt auch eine Reihe von <code>tx.proofs</code> , in denen Signaturen <code>tx.proofs</code> , die bis zu 8 <code>tx.proofs</code> können. Es ist erwähnenswert, dass Sie nicht nur Signaturen an <code>tx.proofs</code> senden <code>tx.proofs</code> , sondern auch alle anderen Informationen, die vom Vertrag verwendet werden können. </p><br><p>  Mit 3 einfachen Zeilen können wir sicherstellen, dass alle Signaturen in der richtigen Reihenfolge angezeigt werden: </p><br><pre> <code class="scala hljs">let aliceSigned = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], alicePubKey )) then <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> let bobSigned = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>], bobPubKey )) then <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> let cooperSigned = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">2</span></span>], cooperPubKey )) then <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br><p>  Nun, der letzte Schritt besteht darin, zu überprüfen, ob mindestens 2 Unterschriften eingereicht wurden. </p><br><pre> <code class="scala hljs">aliceSigned + bobSigned + cooperSigned &gt;= <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br><p>  Der gesamte 2-aus-3-Vertrag mit mehreren Unterschriften sieht folgendermaßen aus: </p><br><pre> <code class="scala hljs">#    let alicePubKey = base58<span class="hljs-symbol"><span class="hljs-symbol">'B1Yz7fH1bJ2gVDjyJnuyKNTdMFARkKEp</span></span>V' let bobPubKey = base58<span class="hljs-symbol"><span class="hljs-symbol">'7hghYeWtiekfebgAcuCg9ai2NXbRreNz</span></span>c' let cooperPubKey = base58<span class="hljs-symbol"><span class="hljs-symbol">'BVqYXrapgJP9atQccdBPAgJPwHDKkh6A</span></span>8' #       let aliceSigned = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], alicePubKey )) then <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> let bobSigned = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>], bobPubKey )) then <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> let cooperSigned = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">2</span></span>], cooperPubKey )) then <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> # ,      <span class="hljs-number"><span class="hljs-number">2</span></span>   aliceSigned + bobSigned + cooperSigned &gt;= <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br><p>  Bitte beachten Sie: Der Code enthält keine Schlüsselwörter wie <code>return</code> , da die zuletzt ausgeführte Zeile als Ergebnis des Skripts betrachtet wird und daher immer <code>true</code> oder <code>false</code> </p><br><p>  Im Vergleich dazu <a href="">sieht</a> der gemeinsame Vertrag mit mehreren Unterschriften von Ethereum <a href="">viel komplizierter aus</a> .  Selbst relativ einfache Variationen sehen so aus: </p><br><pre> <code class="plaintext hljs"> pragma solidity ^0.4.22; contract SimpleMultiSig { uint public nonce; // (only) mutable state uint public threshold; // immutable state mapping (address =&gt; bool) isOwner; // immutable state address[] public ownersArr; // immutable state // Note that owners_ must be strictly increasing, in order to prevent duplicates constructor(uint threshold_, address[] owners_) public { require(owners_.length &lt;= 10 &amp;&amp; threshold_ &lt;= owners_.length &amp;&amp; threshold_ &gt;= 0); address lastAdd = address(0); for (uint i = 0; i &lt; owners_.length; i++) { require(owners_[i] &gt; lastAdd); isOwner[owners_[i]] = true; lastAdd = owners_[i]; } ownersArr = owners_; threshold = threshold_; } // Note that address recovered from signatures must be strictly increasing, in order to prevent duplicates function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) public { require(sigR.length == threshold); require(sigR.length == sigS.length &amp;&amp; sigR.length == sigV.length); // Follows ERC191 signature scheme: https://github.com/ethereum/EIPs/issues/191 bytes32 txHash = keccak256(byte(0x19), byte(0), this, destination, value, data, nonce); address lastAdd = address(0); // cannot have address(0) as an owner for (uint i = 0; i &lt; threshold; i++) { address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]); require(recovered &gt; lastAdd &amp;&amp; isOwner[recovered]); lastAdd = recovered; } // If we make it here all signatures are accounted for. // The address.call() syntax is no longer recommended, see: // https://github.com/ethereum/solidity/issues/2884 nonce = nonce + 1; bool success = false; assembly { success := call(gas, destination, value, add(data, 0x20), mload(data), 0, 0) } require(success); } function () payable public {} }</code> </pre> <br><p>  Die IDE verfügt über eine integrierte Konsole, mit der Sie einen Vertrag sofort kompilieren, bereitstellen, Transaktionen erstellen und das Ergebnis der Ausführung anzeigen können.  Wenn Sie ernsthaft mit Verträgen arbeiten möchten, empfehlen wir Ihnen, sich die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bibliotheken für verschiedene Sprachen</a> und das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Plugin für Visual Studio Code anzusehen</a> . </p><br><p>  Wenn Ihre Hände jucken, finden Sie am Ende des Artikels die wichtigsten Links, mit denen Sie den Tauchgang beginnen können. </p><br><h2 id="sistema-moschnee-chem-yazyk">  Das System ist leistungsfähiger als die Sprache </h2><br><p>  Die Waves-Blockchain verfügt über spezielle Datentypen zum Speichern von Daten - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datentransaktionen</a> .  Sie arbeiten als Schlüsselwertspeicher, der einem Konto zugeordnet ist, dh in gewissem Sinne ist dies der Status des Kontos. </p><br><p><img src="https://habrastorage.org/webt/3o/oh/4h/3ooh4hitfov4sdfhobfhglpec98.png"></p><br><p>  Das Transaktionsdatum kann Zeichenfolgen, Zahlen, Boolesche Werte und Bytearrays mit bis zu 32 KB pro Schlüssel enthalten.  Ein Beispiel für die Arbeit mit Datentransaktionen, mit dem Sie eine Transaktion nur senden können, wenn der Schlüsselwertspeicher des Kontos bereits die Nummer 42 auf dem Schlüsselschlüssel enthält: </p><br><pre> <code class="scala hljs">let keyName = <span class="hljs-string"><span class="hljs-string">"key"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> (tx) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> tx:<span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; let x = extract(getInteger(tx.sender, keyName)) x == <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre> <br><blockquote>  Dank der Datentransaktion werden intelligente Konten zu einem äußerst leistungsstarken Tool, mit dem Sie mit Orakeln arbeiten, den Status verwalten und das Verhalten bequem beschreiben können. </blockquote><p><img src="https://habrastorage.org/webt/ew/ce/gf/ewcegfy0nsj4s8t34c6sn2v7hew.png"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dieser Artikel</a> beschreibt, wie Sie NFT (Non-fungible Token) mithilfe von Datentransaktionen und einem intelligenten Vertrag implementieren können, der den Status kontrolliert.  Infolgedessen enthält der Kontostil Einträge des Formulars: </p><br><pre> <code class="plaintext hljs">+------------+-----------------------------------------------+ | Token Name | Owner Publc Key | +------------+-----------------------------------------------+ | "Token #1" | "6iQaHazE9NVAJfAjMpHifDXMfr1euWcy8fmW6rNcdhr" | | "Token #2" | "3tNLxyJnyxLzDkMkqiZmUjRqXe1UuwFeSyQ14GRYnGL" | | "Token #3" | "3wH7rENpbS78uohErXHq77yKzQwRyKBYhzCR9nKU17q" | | "Token #4" | "6iQaHazE9NVAJfAjMpHifDXMfr1euWcy8fmW6rNcdhr" | | "Token #5" | "6iQaHazE9NVAJfAjMpHifDXMfr1euWcy8fmW6rNcdhr" | +------------+-----------------------------------------------+</code> </pre> <br><p>  Der NFT-Vertrag selbst sieht sehr einfach aus: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> dt: <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; let oldOwner = extract(getString(dt.sender, dt.data[<span class="hljs-number"><span class="hljs-number">0</span></span>].key)) let newOwner = getBinary(dt.data, <span class="hljs-number"><span class="hljs-number">0</span></span>) size(dt.data) == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; sigVerify(dt.bodyBytes, dt.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], fromBase58String(oldOwner)) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre> <br><h1 id="a-chto-dalshe">  Was kommt als nächstes? </h1><br><p>  Die Weiterentwicklung der intelligenten Waves-Verträge sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ride4DApps</a> , mit denen Verträge für andere Konten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aufgerufen</a> werden können, und eine Turing-vollständige Sprache (oder ein System), mit der Sie alle Arten von Aufgaben lösen, andere Aufgaben auslösen usw. können. </p><br><p>  Eine weitere interessante Richtung für die Entwicklung intelligenter Verträge im Waves-Ökosystem sind intelligente Vermögenswerte, die nach einem ähnlichen Prinzip arbeiten - unvollständige Turing-Verträge, die sich auf das Token beziehen.  Der Vertrag regelt die Bedingungen, unter denen Token-Transaktionen abgeschlossen werden können.  Mit ihrer Hilfe wird es beispielsweise möglich sein, Token auf eine bestimmte Blockchain-Höhe einzufrieren oder den Handel mit P2P-Token zu verbieten.  Weitere Informationen zu Smart Assets finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Blog</a> . </p><br><p>  Nun, am Ende werde ich noch einmal eine Liste geben, was notwendig ist, um mit intelligenten Verträgen im Waves-Netzwerk zu arbeiten. </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Dokumentation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IDE mit Konsole</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Weißbuch für die Neugierigsten</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de440702/">https://habr.com/ru/post/de440702/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de440682/index.html">- Und Sie machen dort in der petrochemischen Industrie Gas, oder?</a></li>
<li><a href="../de440688/index.html">PR in der IT: Wie leben, wohin?</a></li>
<li><a href="../de440690/index.html">Funktionen zum Arbeiten mit Mesh in Unity</a></li>
<li><a href="../de440696/index.html">Datenbank-Refactoring-Toolkit: Flyway vs. Liquibase</a></li>
<li><a href="../de440700/index.html">Data Science "Spezialeinheiten" im eigenen Haus</a></li>
<li><a href="../de440706/index.html">InoThings ++ Professional IoT-Konferenz - Was war und was wird</a></li>
<li><a href="../de440708/index.html">Offenes Webinar "Arbeit: das eigene und das eines anderen"</a></li>
<li><a href="../de440710/index.html">Zwei Aspekte von WebView: über den schnellen Start von Projekten und den Diebstahl personenbezogener Daten</a></li>
<li><a href="../de440712/index.html">Die Cloud ist nur jemandes Computer</a></li>
<li><a href="../de440714/index.html">Wie wirkt sich eine Senkung der Erwerbsquote auf uns (Karteninhaber) aus?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>