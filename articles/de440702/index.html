<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò∞ üë®‚Äçüë®‚Äçüëß‚Äçüëß ü•á Achtung - GAS! oder wie wir intelligente Vertr√§ge ohne Kohlens√§ure abgeschlossen haben üë©üèº‚Äçüé® üíá üì∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Blockchain- und Smart-Vertr√§ge sind nach wie vor ein hei√ües Thema bei Entwicklern und Technikern. Es gibt viel Forschung und Diskussion √ºber ihre Zuku...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Achtung - GAS! oder wie wir intelligente Vertr√§ge ohne Kohlens√§ure abgeschlossen haben</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/waves/blog/440702/"><p><img src="https://habrastorage.org/webt/ps/lh/d4/pslhd4hgoxgjskexszwtn40mivo.png"></p><br><p>  Blockchain- und Smart-Vertr√§ge sind nach wie vor ein hei√ües Thema bei Entwicklern und Technikern.  Es gibt viel Forschung und Diskussion √ºber ihre Zukunft und wohin sich alles bewegt und wohin es f√ºhren wird.  Wir von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Waves Platform haben</a> unsere eigene Meinung dazu, was intelligente Vertr√§ge sein sollten, und in diesem Artikel werde ich Ihnen erkl√§ren, wie wir sie abgeschlossen haben, auf welche Probleme wir gesto√üen sind und warum sie nicht wie intelligente Vertr√§ge anderer Blockchain-Projekte sind (vor allem) Ethereum). </p><br><p>  Dieser Artikel ist auch ein Leitfaden f√ºr diejenigen, die verstehen m√∂chten, wie intelligente Vertr√§ge im Waves-Netzwerk funktionieren, versuchen, einen eigenen Vertrag zu schreiben und sich mit den Tools vertraut zu machen, √ºber die Entwickler bereits verf√ºgen. </p><a name="habracut"></a><br><h2 id="kak-my-doshli-do-zhizni-takoy">  Wie sind wir zu einem solchen Leben gekommen? </h2><br><p>  Wir wurden oft gefragt, wann wir intelligente Vertr√§ge erhalten haben, weil die Entwickler die einfache Arbeit mit dem Netzwerk, die Netzwerkgeschwindigkeit (dank <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Waves NG</a> ) und die geringen Provisionen mochten.  Intelligente Vertr√§ge bieten jedoch viel mehr Raum f√ºr Fantasie. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Intelligente Vertr√§ge</a> sind in den letzten Jahren aufgrund der Verbreitung der Blockchain sehr beliebt geworden.  Diejenigen, die bei ihrer Arbeit auf Blockchain-Technologie gesto√üen sind, denken bei der Erw√§hnung intelligenter Vertr√§ge normalerweise an Ethereum und Solidity.  Es gibt jedoch viele Blockchain-Plattformen mit intelligenten Vertr√§gen, und die meisten von ihnen haben einfach wiederholt, was Ethereum getan hat (virtuelle Maschine + ihre eigene Vertragssprache).  Eine interessante Liste mit verschiedenen Sprachen und Ans√§tzen befindet sich in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diesem Repository</a> . </p><br><h2 id="chto-takoe-smart-kontrakt">  Was ist ein intelligenter Vertrag? </h2><br><p>  Im weitesten Sinne ist ein intelligenter Vertrag ein Protokoll zur Unterst√ºtzung, √úberpr√ºfung und Durchsetzung der Bedingungen einer Transaktion oder der Ausf√ºhrung von Vertr√§gen zwischen Parteien.  Die Idee wurde erstmals 1996 von Nick Szabo vorgeschlagen, aber intelligente Vertr√§ge sind erst in den letzten Jahren popul√§r geworden. </p><br><p>  Aus technischer Sicht (was uns mehr interessiert) ist ein intelligenter Vertrag ein Algorithmus (Code), der nicht auf einem Server oder Computer ausgef√ºhrt wird, sondern auf vielen (oder allen) Knoten im Blockchain-Netzwerk, d. H.  dezentralisiert. </p><br><h2 id="kak-eto-rabotaet">  Wie funktioniert es </h2><br><p>  Der erste Prototyp eines intelligenten Vertrags in der Blockchain wird korrekt als Bitcoin-Skript betrachtet - unvollst√§ndig von Turing, einer stapelbasierten Sprache im Bitcoin-Netzwerk.  In Bitcoin gibt es kein Kontokonzept, stattdessen gibt es Ein- und Ausg√§nge.  In Bitcoin muss beim Erstellen einer Transaktion (Erstellen einer Ausgabe) auf die empfangene Transaktion (Eingabe) verwiesen werden.  Wenn Sie an den technischen Details des Bitcoin-Ger√§ts interessiert sind, empfehle ich Ihnen, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese Artikelserie zu</a> lesen.  Da Bitcoin keine Konten enth√§lt, bestimmt Bitcoin Script, in welchem ‚Äã‚ÄãFall der eine oder andere Exit ausgegeben werden kann. </p><br><p> Ethereum bietet viel mehr Funktionen als  Bietet Solidity, eine Turing-vollst√§ndige Sprache, die in einer virtuellen Maschine in jedem Knoten ausgef√ºhrt wird.  Mit gro√üer Kraft geht gro√üe Verantwortung und eine Vielzahl von M√∂glichkeiten einher - eine ziemlich gro√üe Anzahl von Einschr√§nkungen, √ºber die wir sp√§ter sprechen werden. </p><br><h1 id="smart-kontrakty-waves">  Intelligente Vertr√§ge Wellen </h1><br><p>  Wie ich oben schrieb, wurden wir oft nach intelligenten Vertr√§gen gefragt, aber wir wollten nicht "like on air" oder "like in anyblockchainname" machen, und es gibt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">viele Gr√ºnde daf√ºr</a> .  Daher haben wir die bestehenden F√§lle f√ºr Vertr√§ge analysiert und wie wir mit ihrer Hilfe helfen k√∂nnen, echte Probleme zu l√∂sen. </p><br><p>  Nach der Analyse der Nutzungsszenarien haben wir festgestellt, dass es zwei gro√üe Kategorien von Aufgaben gibt, die normalerweise mit intelligenten Vertr√§gen gel√∂st werden: </p><br><ol><li>  Einfache und unkomplizierte Aufgaben wie Multisig, Atomic Swaps oder Escrow. </li><li>  dApps, vollwertige dezentrale Anwendungen mit Benutzerlogik.  Genauer gesagt ist dies ein Backend f√ºr dezentrale Anwendungen.  Die auff√§lligsten Beispiele sind Cryptokitties oder Bancor. </li></ol><br><p>  Es gibt auch eine dritte, beliebteste Art von Vertr√§gen - Token.  Im Ethereum-Netzwerk beispielsweise sind die meisten Arbeitsvertr√§ge ERC20-Standard-Token.  In Waves m√ºssen zum Erstellen von Token keine intelligenten Vertr√§ge abgeschlossen werden  Sie sind Teil der Blockchain selbst. Um ein Token auszugeben (mit der M√∂glichkeit, es sofort an einer dezentralen B√∂rse (DEX) zu handeln), reicht es aus, eine Transaktion des Ausgabetyps (Ausgabetransaktion) zu senden. </p><br><p>  F√ºr die beiden oben genannten Arten von Aufgaben (der Einfachheit halber werden wir einfache und komplexe F√§lle nennen) sind die Anforderungen an Sprache, Vertr√§ge und Konzepte sehr unterschiedlich.  Ja, wir k√∂nnen sagen, dass eine Turing-vollst√§ndige Sprache sowohl einfache als auch komplexe Probleme l√∂sen kann, aber es gibt eine wichtige Bedingung: Die Sprache sollte helfen, Fehler zu vermeiden.  Diese Anforderung ist auch f√ºr gew√∂hnliche Sprachen wichtig, und f√ºr intelligente Vertragssprachen ist sie besonders wichtig, weil  Operationen sind finanziell miteinander verbunden, und Vertr√§ge sind oft unver√§nderlich, und es gibt keine M√∂glichkeit, einen Fehler schnell und einfach zu beheben. </p><br><p>  Angesichts der oben beschriebenen Aufgabentypen haben wir uns entschlossen, schrittweise voranzukommen und als ersten Schritt ein Werkzeug zur L√∂sung einfacher Probleme bereitzustellen und als n√§chsten Schritt eine Sprache anzugeben, mit der jede Benutzerlogik problemlos implementiert werden kann.  Infolgedessen erwies sich das System als viel leistungsf√§higer, als wir es uns zu Beginn der Reise vorgestellt hatten. </p><br><h2 id="sdelaem-akkaunty-umnymi">  Lassen Sie uns Konten intelligent machen </h2><br><p>  Allm√§hlich kamen wir zum Konzept der Smart Accounts, mit denen vor allem einfache Aufgaben gel√∂st werden sollen.  Ihre Idee ist Bitcoin Script sehr √§hnlich: Dem Konto k√∂nnen zus√§tzliche Regeln hinzugef√ºgt werden, die die G√ºltigkeit der ausgehenden Transaktion bestimmen.  Die Hauptanforderungen f√ºr Smart Accounts waren: </p><br><ol><li>  Maximale Sicherheit.  Fast jeden Monat finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Neuigkeiten,</a> dass in Ethereum-Modellvertr√§gen eine weitere Sicherheitsl√ºcke gefunden wurde.  Das wollten wir vermeiden. </li><li>  Kein Gasbedarf, so dass die Provision feststeht.  Dazu muss das Skript in einer vorhersehbaren Zeit ausgef√ºhrt werden und recht strenge Gr√∂√üenbeschr√§nkungen aufweisen. </li></ol><br><p>  Bevor wir mit den technischen Details der Implementierung und des Schreibens von Vertr√§gen fortfahren, skizzieren wir einige Merkmale der Waves-Blockchain, die f√ºr das weitere Verst√§ndnis wichtig sind: </p><br><ol><li>  Die Waves-Blockchain verf√ºgt derzeit √ºber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">13 verschiedene Arten von Transaktionen.</a> </li></ol><br><p><img src="https://habrastorage.org/webt/dx/to/mz/dxtomzcjjyp7jgwa9wcsmfana1u.png"></p><br><ol><li>  In der Waves-Blockchain keine Ein- und Ausg√§nge (wie in Bitcoin), sondern Konten (wie zum Beispiel in Nxt).  Eine Transaktion wird f√ºr ein bestimmtes Konto ausgef√ºhrt. </li><li>  Standardm√§√üig wird die Richtigkeit einer Transaktion durch den aktuellen Status der Blockchain und die G√ºltigkeit der Signatur bestimmt, f√ºr die die Transaktion gesendet wird.  Die JSON-Darstellung der Transaktion sieht einfach aus: </li></ol><br><p><img src="https://habrastorage.org/webt/gl/0a/m-/gl0am-s8dyjwnsgnksk0tf1fzyu.png"></p><br><p> Da wir bereits verschiedene Arten von Transaktionen in der Blockchain haben, haben wir beschlossen, keine separate Entit√§t als Smart-Konto zu erstellen, sondern eine neue Transaktion hinzuzuf√ºgen, die aus einem regul√§ren Konto ein Smart-Konto macht.  Jedes Konto kann zu einem Smart-Konto mit ge√§nderten Transaktions√ºberpr√ºfungsregeln werden. Dazu sollte das Konto einfach eine Transaktion vom Typ <code>SetScriptTransaction</code> , die den kompilierten Vertrag enth√§lt. </p><br><p>  Bei einem Smart Account ist der Vertrag eine Validierungsregel f√ºr jede ausgehende Transaktion. </p><br><h2 id="a-chto-tam-s-gazom">  Und was ist mit dem Gas? </h2><br><p>  Eine der Hauptaufgaben, die wir uns stellen, ist es, Gas f√ºr einfache Operationen loszuwerden.  Dies bedeutet nicht, dass keine Provision anf√§llt.  Es wird ben√∂tigt, damit Bergleute ein Interesse daran haben, Skripte auszuf√ºhren.  Wir n√§herten uns dem Problem von der praktischen Seite und beschlossen, Leistungstests durchzuf√ºhren und die Geschwindigkeit verschiedener Vorg√§nge zu berechnen.  Hierzu wurden Benchmarks mit JMH entwickelt.  Ergebnisse k√∂nnen hier gesehen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> .  Die daraus resultierenden Einschr√§nkungen sind: </p><br><ol><li>  Das Skript sollte schneller als 20 Signatur√ºberpr√ºfungsvorg√§nge ausgef√ºhrt werden. Dies bedeutet, dass die √úberpr√ºfung f√ºr ein Smart-Konto nicht mehr als 20-mal langsamer ist als f√ºr ein regul√§res Konto.  Die Gr√∂√üe des Skripts sollte 8 KB nicht √ºberschreiten. </li><li>  Damit Bergleute intelligente Vertr√§ge erf√ºllen k√∂nnen, legen wir eine zus√§tzliche Mindestprovision f√ºr intelligente Konten in H√∂he von 0,004 WAVES fest.  Die Mindestprovision im Waves-Netzwerk f√ºr eine Transaktion betr√§gt 0,001 WAVES, bei einem Smart Account 0,005 WAVES. </li></ol><br><h1 id="yazyk-dlya-smart-kontraktov">  Sprache f√ºr intelligente Vertr√§ge </h1><br><p>  Eine der schwierigsten Aufgaben war die Schaffung einer eigenen Sprache f√ºr intelligente Vertr√§ge.  Es scheint, als w√ºrde man mit einer Kanone auf Spatzen schie√üen, wenn man eine vorhandene Turing-vollst√§ndige Sprache verwendet und sich an unsere Aufgaben anpasst (trimmt). Au√üerdem ist es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√§u√üerst riskant</a> , abh√§ngig von der Codebasis eines anderen in einem Blockchain-Projekt. </p><br><p>  Versuchen wir uns vorzustellen, was die ideale Sprache f√ºr intelligente Vertr√§ge sein sollte.  Meiner Meinung nach sollte jede Programmiersprache das Schreiben von "korrektem" und sicherem Code erzwingen, d. H.  Idealerweise sollte es einen richtigen Weg geben.  Ja, wenn Sie m√∂chten, k√∂nnen Sie vollst√§ndig unlesbaren und nicht unterst√ºtzten Code in jeder Sprache schreiben. Dies sollte jedoch schwieriger sein als das korrekte Schreiben (Hallo PHP und JavaScript).  Gleichzeitig sollte die Sprache f√ºr die Entwicklung geeignet sein.  Da die Sprache auf allen Knoten des Netzwerks ausgef√ºhrt wird, muss sie so effizient wie m√∂glich sein. Eine verz√∂gerte Ausf√ºhrung kann eine Menge Ressourcen sparen.  Ich h√§tte auch gerne ein leistungsf√§higes Typensystem in der Sprache, vorzugsweise algebraisch, weil es hilft, den Vertrag so klar wie m√∂glich zu beschreiben und dem Traum von "Code is law" n√§her zu kommen.  Wenn wir unsere Anforderungen etwas weiter formalisieren, erhalten wir die folgenden Sprachparameter: </p><br><ol><li>  Seien Sie streng und statisch typisiert.  Durch starkes Tippen werden viele potenzielle Programmiererfehler automatisch beseitigt. </li><li>  Haben Sie ein leistungsstarkes Typsystem, das es schwieriger macht, sich in den Fu√ü zu schie√üen. </li><li>  Seien Sie faul, damit Sie keine wertvollen Prozessorzyklen verschwenden. </li><li>  Verf√ºgen Sie in der Standardbibliothek √ºber bestimmte Funktionen f√ºr die Arbeit mit Blockchain, z. B. Hashes.  Gleichzeitig sollte die Standard-Sprachbibliothek nicht √ºberlastet werden, da es immer einen richtigen Weg geben sollte. </li><li>  Haben Sie keine Ausnahmen in der Laufzeit. </li></ol><br><p>  In unserer RIDE-Sprache haben wir versucht, diese wichtigen Funktionen zu ber√ºcksichtigen. Da wir viel auf Scala entwickeln und die funktionale Programmierung m√∂gen, √§hnelt die Sprache in mancher Hinsicht Scala und F #. </p><br><p>  Die gr√∂√üten Probleme bei der Implementierung in der Praxis traten bei der letzten Anforderung auf, denn wenn Sie keine Ausnahmen in der Sprache haben, muss der Additionsvorgang beispielsweise eine <em>Option zur√ºckgeben</em> , die auf √úberlauf √ºberpr√ºft werden muss, was f√ºr Entwickler definitiv unpraktisch ist.  Ausnahmen waren ein Kompromiss, aber ohne die F√§higkeit, sie abzufangen - wenn es eine Ausnahme gab, war die Transaktion ung√ºltig.  Ein weiteres Problem bestand darin, alle Datenmodelle, die wir in der Blockchain haben, in die Sprache zu √ºbertragen.  Ich habe bereits beschrieben, dass es in Waves 13 verschiedene Arten von Transaktionen gibt, die in der Sprache unterst√ºtzt werden m√ºssen und Zugriff auf alle ihre Felder erhalten m√ºssen. </p><br><p>  Ausf√ºhrliche Informationen zu verf√ºgbaren Vorg√§ngen und Datentypen in RIDE finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Sprachbeschreibungsseite</a> .  Unter den interessanten Merkmalen der Sprache k√∂nnen wir auch die Tatsache hervorheben, dass die Sprache ausdrucksbasiert ist, dh alles ist Ausdruck, sowie das Vorhandensein eines Mustervergleichs, mit dem Sie die Bedingungen f√ºr verschiedene Arten von Transaktionen bequem beschreiben k√∂nnen: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t:<span class="hljs-type"><span class="hljs-type">TransferTransaction</span></span> =&gt; t.recepient <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> t:<span class="hljs-type"><span class="hljs-type">MassTransferTransaction</span></span> =&gt; t.transfers <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> }</code> </pre> <br><p>  Wenn Sie wissen m√∂chten, wie die Arbeit mit RIDE-Code funktioniert, lesen Sie das Whitepaper, in dem alle Phasen der Vertragsarbeit beschrieben sind: Parsen, Kompilieren, Deserialisieren, Berechnen der Skriptkomplexit√§t und -ausf√ºhrung.  Die ersten beiden Phasen - Parsen und Kompilieren - werden au√üerhalb der Kette ausgef√ºhrt. Nur der in base64 kompilierte Vertrag wird in die Blockchain aufgenommen.  Deserialisierung, Komplexit√§tsberechnung und Ausf√ºhrung werden in der Kette und mehrmals in verschiedenen Phasen durchgef√ºhrt: </p><br><ol><li>  Wenn Sie eine Transaktion empfangen und zu UTX hinzuf√ºgen, kann es vorkommen, dass die Transaktion vom Blockchain-Knoten akzeptiert wird, z. B. √ºber die REST-API, aber niemals in den Block gelangt. </li><li>  Wenn ein Block gebildet wird, √ºberpr√ºft der Mining-Knoten Transaktionen und das Skript ist erforderlich. </li><li>  Nach Empfang eines Blocks bei Nicht-Mining-Knoten und Validierung der darin enthaltenen Transaktionen. </li></ol><br><p>  Jede Optimierung bei der Arbeit mit Vertr√§gen wird wertvoll, da sie auf vielen Netzwerkknoten mehrmals durchgef√ºhrt wird.  Jetzt laufen Waves-Knoten bei DigitalOcean f√ºr 15 US-Dollar leise auf virtuellen Maschinen, obwohl die Arbeitslast nach der Ver√∂ffentlichung von Smart Accounts gestiegen ist. </p><br><h2 id="a-chto-v-itoge">  Was ist das Ergebnis? </h2><br><p>  Nun wollen wir sehen, was wir bei Waves bekommen haben.  Wir werden unseren ersten eigenen Vertrag schreiben, es sei ein Standard-Multisig-2-aus-3-Vertrag.  Um einen Vertrag zu schreiben, k√∂nnen Sie die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Online-IDE verwenden</a> (Abstimmung auf die Sprache - ein Thema f√ºr einen separaten Artikel).  Erstellen Sie einen neuen leeren Vertrag (Neu ‚Üí Leerer Vertrag). </p><br><p>  Zun√§chst werden wir die √∂ffentlichen Schl√ºssel von Alice, Bob und Cooper bekannt geben, die das Konto kontrollieren werden.  Sie ben√∂tigen 2 ihrer 3 Unterschriften: </p><br><pre> <code class="scala hljs">let alicePubKey = base58<span class="hljs-symbol"><span class="hljs-symbol">'B1Yz7fH1bJ2gVDjyJnuyKNTdMFARkKEp</span></span>V' let bobPubKey = base58<span class="hljs-symbol"><span class="hljs-symbol">'7hghYeWtiekfebgAcuCg9ai2NXbRreNz</span></span>c' let cooperPubKey = base58<span class="hljs-symbol"><span class="hljs-symbol">'BVqYXrapgJP9atQccdBPAgJPwHDKkh6A</span></span>8'</code> </pre> <br><p>  In der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation wird</a> die Funktion <code>sigVerify</code> beschrieben, mit der Sie die Transaktionssignatur √ºberpr√ºfen k√∂nnen: </p><br><p><img src="https://habrastorage.org/webt/fw/am/py/fwampygopgdhgrmb9v4z67mkszq.png"></p><br><p>  Die Argumente f√ºr die Funktion sind der Hauptteil der Transaktion, die verifizierte Signatur und der √∂ffentliche Schl√ºssel.  Im globalen Bereich ist ein <code>tx</code> Objekt im Vertrag verf√ºgbar, in dem Transaktionsinformationen gespeichert sind.  Dieses Objekt verf√ºgt √ºber ein Feld <code>tx.bodyBytes</code> , das die Bytes der gesendeten Transaktion enth√§lt.  Es gibt auch eine Reihe von <code>tx.proofs</code> , in denen Signaturen <code>tx.proofs</code> , die bis zu 8 <code>tx.proofs</code> k√∂nnen. Es ist erw√§hnenswert, dass Sie nicht nur Signaturen an <code>tx.proofs</code> senden <code>tx.proofs</code> , sondern auch alle anderen Informationen, die vom Vertrag verwendet werden k√∂nnen. </p><br><p>  Mit 3 einfachen Zeilen k√∂nnen wir sicherstellen, dass alle Signaturen in der richtigen Reihenfolge angezeigt werden: </p><br><pre> <code class="scala hljs">let aliceSigned = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], alicePubKey )) then <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> let bobSigned = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>], bobPubKey )) then <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> let cooperSigned = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">2</span></span>], cooperPubKey )) then <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br><p>  Nun, der letzte Schritt besteht darin, zu √ºberpr√ºfen, ob mindestens 2 Unterschriften eingereicht wurden. </p><br><pre> <code class="scala hljs">aliceSigned + bobSigned + cooperSigned &gt;= <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br><p>  Der gesamte 2-aus-3-Vertrag mit mehreren Unterschriften sieht folgenderma√üen aus: </p><br><pre> <code class="scala hljs">#    let alicePubKey = base58<span class="hljs-symbol"><span class="hljs-symbol">'B1Yz7fH1bJ2gVDjyJnuyKNTdMFARkKEp</span></span>V' let bobPubKey = base58<span class="hljs-symbol"><span class="hljs-symbol">'7hghYeWtiekfebgAcuCg9ai2NXbRreNz</span></span>c' let cooperPubKey = base58<span class="hljs-symbol"><span class="hljs-symbol">'BVqYXrapgJP9atQccdBPAgJPwHDKkh6A</span></span>8' #       let aliceSigned = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], alicePubKey )) then <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> let bobSigned = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">1</span></span>], bobPubKey )) then <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> let cooperSigned = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sigVerify(tx.bodyBytes, tx.proofs[<span class="hljs-number"><span class="hljs-number">2</span></span>], cooperPubKey )) then <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> # ,      <span class="hljs-number"><span class="hljs-number">2</span></span>   aliceSigned + bobSigned + cooperSigned &gt;= <span class="hljs-number"><span class="hljs-number">2</span></span></code> </pre> <br><p>  Bitte beachten Sie: Der Code enth√§lt keine Schl√ºsselw√∂rter wie <code>return</code> , da die zuletzt ausgef√ºhrte Zeile als Ergebnis des Skripts betrachtet wird und daher immer <code>true</code> oder <code>false</code> </p><br><p>  Im Vergleich dazu <a href="">sieht</a> der gemeinsame Vertrag mit mehreren Unterschriften von Ethereum <a href="">viel komplizierter aus</a> .  Selbst relativ einfache Variationen sehen so aus: </p><br><pre> <code class="plaintext hljs"> pragma solidity ^0.4.22; contract SimpleMultiSig { uint public nonce; // (only) mutable state uint public threshold; // immutable state mapping (address =&gt; bool) isOwner; // immutable state address[] public ownersArr; // immutable state // Note that owners_ must be strictly increasing, in order to prevent duplicates constructor(uint threshold_, address[] owners_) public { require(owners_.length &lt;= 10 &amp;&amp; threshold_ &lt;= owners_.length &amp;&amp; threshold_ &gt;= 0); address lastAdd = address(0); for (uint i = 0; i &lt; owners_.length; i++) { require(owners_[i] &gt; lastAdd); isOwner[owners_[i]] = true; lastAdd = owners_[i]; } ownersArr = owners_; threshold = threshold_; } // Note that address recovered from signatures must be strictly increasing, in order to prevent duplicates function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) public { require(sigR.length == threshold); require(sigR.length == sigS.length &amp;&amp; sigR.length == sigV.length); // Follows ERC191 signature scheme: https://github.com/ethereum/EIPs/issues/191 bytes32 txHash = keccak256(byte(0x19), byte(0), this, destination, value, data, nonce); address lastAdd = address(0); // cannot have address(0) as an owner for (uint i = 0; i &lt; threshold; i++) { address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]); require(recovered &gt; lastAdd &amp;&amp; isOwner[recovered]); lastAdd = recovered; } // If we make it here all signatures are accounted for. // The address.call() syntax is no longer recommended, see: // https://github.com/ethereum/solidity/issues/2884 nonce = nonce + 1; bool success = false; assembly { success := call(gas, destination, value, add(data, 0x20), mload(data), 0, 0) } require(success); } function () payable public {} }</code> </pre> <br><p>  Die IDE verf√ºgt √ºber eine integrierte Konsole, mit der Sie einen Vertrag sofort kompilieren, bereitstellen, Transaktionen erstellen und das Ergebnis der Ausf√ºhrung anzeigen k√∂nnen.  Wenn Sie ernsthaft mit Vertr√§gen arbeiten m√∂chten, empfehlen wir Ihnen, sich die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Bibliotheken f√ºr verschiedene Sprachen</a> und das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Plugin f√ºr Visual Studio Code anzusehen</a> . </p><br><p>  Wenn Ihre H√§nde jucken, finden Sie am Ende des Artikels die wichtigsten Links, mit denen Sie den Tauchgang beginnen k√∂nnen. </p><br><h2 id="sistema-moschnee-chem-yazyk">  Das System ist leistungsf√§higer als die Sprache </h2><br><p>  Die Waves-Blockchain verf√ºgt √ºber spezielle Datentypen zum Speichern von Daten - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Datentransaktionen</a> .  Sie arbeiten als Schl√ºsselwertspeicher, der einem Konto zugeordnet ist, dh in gewissem Sinne ist dies der Status des Kontos. </p><br><p><img src="https://habrastorage.org/webt/3o/oh/4h/3ooh4hitfov4sdfhobfhglpec98.png"></p><br><p>  Das Transaktionsdatum kann Zeichenfolgen, Zahlen, Boolesche Werte und Bytearrays mit bis zu 32 KB pro Schl√ºssel enthalten.  Ein Beispiel f√ºr die Arbeit mit Datentransaktionen, mit dem Sie eine Transaktion nur senden k√∂nnen, wenn der Schl√ºsselwertspeicher des Kontos bereits die Nummer 42 auf dem Schl√ºsselschl√ºssel enth√§lt: </p><br><pre> <code class="scala hljs">let keyName = <span class="hljs-string"><span class="hljs-string">"key"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> (tx) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> tx:<span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; let x = extract(getInteger(tx.sender, keyName)) x == <span class="hljs-number"><span class="hljs-number">42</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre> <br><blockquote>  Dank der Datentransaktion werden intelligente Konten zu einem √§u√üerst leistungsstarken Tool, mit dem Sie mit Orakeln arbeiten, den Status verwalten und das Verhalten bequem beschreiben k√∂nnen. </blockquote><p><img src="https://habrastorage.org/webt/ew/ce/gf/ewcegfy0nsj4s8t34c6sn2v7hew.png"></p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dieser Artikel</a> beschreibt, wie Sie NFT (Non-fungible Token) mithilfe von Datentransaktionen und einem intelligenten Vertrag implementieren k√∂nnen, der den Status kontrolliert.  Infolgedessen enth√§lt der Kontostil Eintr√§ge des Formulars: </p><br><pre> <code class="plaintext hljs">+------------+-----------------------------------------------+ | Token Name | Owner Publc Key | +------------+-----------------------------------------------+ | "Token #1" | "6iQaHazE9NVAJfAjMpHifDXMfr1euWcy8fmW6rNcdhr" | | "Token #2" | "3tNLxyJnyxLzDkMkqiZmUjRqXe1UuwFeSyQ14GRYnGL" | | "Token #3" | "3wH7rENpbS78uohErXHq77yKzQwRyKBYhzCR9nKU17q" | | "Token #4" | "6iQaHazE9NVAJfAjMpHifDXMfr1euWcy8fmW6rNcdhr" | | "Token #5" | "6iQaHazE9NVAJfAjMpHifDXMfr1euWcy8fmW6rNcdhr" | +------------+-----------------------------------------------+</code> </pre> <br><p>  Der NFT-Vertrag selbst sieht sehr einfach aus: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">match</span></span> tx { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> dt: <span class="hljs-type"><span class="hljs-type">DataTransaction</span></span> =&gt; let oldOwner = extract(getString(dt.sender, dt.data[<span class="hljs-number"><span class="hljs-number">0</span></span>].key)) let newOwner = getBinary(dt.data, <span class="hljs-number"><span class="hljs-number">0</span></span>) size(dt.data) == <span class="hljs-number"><span class="hljs-number">1</span></span> &amp;&amp; sigVerify(dt.bodyBytes, dt.proofs[<span class="hljs-number"><span class="hljs-number">0</span></span>], fromBase58String(oldOwner)) <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> _ =&gt; <span class="hljs-literal"><span class="hljs-literal">false</span></span> }</code> </pre> <br><h1 id="a-chto-dalshe">  Was kommt als n√§chstes? </h1><br><p>  Die Weiterentwicklung der intelligenten Waves-Vertr√§ge sind <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ride4DApps</a> , mit denen Vertr√§ge f√ºr andere Konten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aufgerufen</a> werden k√∂nnen, und eine Turing-vollst√§ndige Sprache (oder ein System), mit der Sie alle Arten von Aufgaben l√∂sen, andere Aufgaben ausl√∂sen usw. k√∂nnen. </p><br><p>  Eine weitere interessante Richtung f√ºr die Entwicklung intelligenter Vertr√§ge im Waves-√ñkosystem sind intelligente Verm√∂genswerte, die nach einem √§hnlichen Prinzip arbeiten - unvollst√§ndige Turing-Vertr√§ge, die sich auf das Token beziehen.  Der Vertrag regelt die Bedingungen, unter denen Token-Transaktionen abgeschlossen werden k√∂nnen.  Mit ihrer Hilfe wird es beispielsweise m√∂glich sein, Token auf eine bestimmte Blockchain-H√∂he einzufrieren oder den Handel mit P2P-Token zu verbieten.  Weitere Informationen zu Smart Assets finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Blog</a> . </p><br><p>  Nun, am Ende werde ich noch einmal eine Liste geben, was notwendig ist, um mit intelligenten Vertr√§gen im Waves-Netzwerk zu arbeiten. </p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Dokumentation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IDE mit Konsole</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wei√übuch f√ºr die Neugierigsten</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de440702/">https://habr.com/ru/post/de440702/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de440682/index.html">- Und Sie machen dort in der petrochemischen Industrie Gas, oder?</a></li>
<li><a href="../de440688/index.html">PR in der IT: Wie leben, wohin?</a></li>
<li><a href="../de440690/index.html">Funktionen zum Arbeiten mit Mesh in Unity</a></li>
<li><a href="../de440696/index.html">Datenbank-Refactoring-Toolkit: Flyway vs. Liquibase</a></li>
<li><a href="../de440700/index.html">Data Science "Spezialeinheiten" im eigenen Haus</a></li>
<li><a href="../de440706/index.html">InoThings ++ Professional IoT-Konferenz - Was war und was wird</a></li>
<li><a href="../de440708/index.html">Offenes Webinar "Arbeit: das eigene und das eines anderen"</a></li>
<li><a href="../de440710/index.html">Zwei Aspekte von WebView: √ºber den schnellen Start von Projekten und den Diebstahl personenbezogener Daten</a></li>
<li><a href="../de440712/index.html">Die Cloud ist nur jemandes Computer</a></li>
<li><a href="../de440714/index.html">Wie wirkt sich eine Senkung der Erwerbsquote auf uns (Karteninhaber) aus?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>