<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîÆ üôÅ üè§ In Python geschriebene Typen f√ºr HTTP-APIs: Instagram-Erfahrung üë®‚Äçüë©‚Äçüëß‚Äçüëß üëÉüèΩ üé∏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute ver√∂ffentlichen wir das zweite Material aus der Reihe, das sich mit der Verwendung von Python in Instagram befasst. Beim letzten Mal wurden die ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>In Python geschriebene Typen f√ºr HTTP-APIs: Instagram-Erfahrung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/474308/">  Heute ver√∂ffentlichen wir das zweite Material aus der Reihe, das sich mit der Verwendung von Python in Instagram befasst.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beim letzten</a> Mal wurden die Arten von Instagram-Servercode √ºberpr√ºft.  Der Server ist ein in Python geschriebener Monolith.  Es besteht aus mehreren Millionen Codezeilen und hat mehrere tausend Django-Endpunkte. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/nn/gh/jg/nnghjgmcauejll98mv34awk3cok.jpeg"></a> <br><br>  In diesem Artikel geht es darum, wie Instagram Typen verwendet, um HTTP-APIs zu dokumentieren und Vertr√§ge bei der Arbeit mit ihnen durchzusetzen. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Situations√ºbersicht</font> </h2><br>  Wenn Sie den mobilen Instagram-Client √∂ffnen, greift er √ºber HTTP auf die JSON-API unseres Python-Servers (Django) zu. <br><br>  Hier finden Sie einige Informationen zu unserem System, mit denen Sie sich ein Bild von der Komplexit√§t der API machen k√∂nnen, mit der wir die Arbeit des mobilen Clients organisieren.  Also hier ist was wir haben: <br><br><ul><li>  √úber 2000 Endpunkte auf dem Server. </li><li>  √úber 200 Felder der obersten Ebene in einem Client-Datenobjekt, das ein Bild, ein Video oder eine Story in einer Anwendung darstellt. </li><li>  Hunderte von Programmierern, die Servercode schreiben (und noch mehr, die sich mit dem Client befassen). </li><li>  T√§glich werden Hunderte von Commits f√ºr Servercode vorgenommen und die API ge√§ndert.  Dies ist erforderlich, um neue Systemfunktionen zu unterst√ºtzen. </li></ul><br>  Wir verwenden Typen, um unsere komplexen, sich st√§ndig weiterentwickelnden HTTP-APIs zu dokumentieren und Vertr√§ge bei der Arbeit mit ihnen durchzusetzen. <br><br><h2>  <font color="#3AC1EF">Typen</font> </h2><br>  Beginnen wir von vorne.  Die Beschreibung der Syntax f√ºr Typanmerkungen in Python-Code wurde in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEP 484 ver√∂ffentlicht</a> .  Warum dem Code Typanmerkungen hinzuf√ºgen? <br><br>  Betrachten Sie die Funktion, mit der Informationen √ºber den Helden von Star Wars heruntergeladen werden: <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_character</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id, calendar)</span></span></span><span class="hljs-function">:</span></span>     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> id == <span class="hljs-number"><span class="hljs-number">1000</span></span>:         <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Character(             id=<span class="hljs-number"><span class="hljs-number">1000</span></span>,             name=<span class="hljs-string"><span class="hljs-string">"Luke Skywalker"</span></span>,             birth_year=<span class="hljs-string"><span class="hljs-string">"19BBY"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> calendar == Calendar.BBY <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ...         )     ...</code> </pre> <br>  Um diese Funktion zu verstehen, m√ºssen Sie den Code lesen.  Nachdem Sie dies getan haben, k√∂nnen Sie Folgendes herausfinden: <br><br><ul><li>  Es wird die Ganzzahlkennung ( <code>id</code> ) des Zeichens verwendet. </li><li>  Es √ºbernimmt den Wert aus der entsprechenden Aufz√§hlung ( <code>calendar</code> ).  Zum Beispiel steht <code>Calendar.BBY</code> f√ºr "Vor der Schlacht von Yavin", dh "Vor der Schlacht von Yavin". </li><li>  Es gibt Informationen √ºber das Zeichen in Form einer Entit√§t zur√ºck, die Felder enth√§lt, die die Kennung dieses Zeichens, seinen Namen und sein Geburtsjahr darstellen. </li></ul><br>  Die Funktion hat einen impliziten Vertrag, dessen Bedeutung der Programmierer jedes Mal wiederherstellen muss, wenn er den Funktionscode liest.  Der Funktionscode wird jedoch nur einmal geschrieben, und Sie m√ºssen ihn viele Male lesen, sodass dieser Ansatz f√ºr die Arbeit mit diesem Code nicht besonders gut ist. <br><br>  Dar√ºber hinaus ist es schwierig zu √ºberpr√ºfen, ob der Mechanismus, der die Funktion aufruft, dem oben beschriebenen impliziten Vertrag entspricht.  Ebenso ist es schwierig zu √ºberpr√ºfen, ob dieser Vertrag im Hauptteil der Funktion eingehalten wird.  In einer gro√üen Codebasis k√∂nnen solche Situationen zu Fehlern f√ºhren. <br><br>  Betrachten Sie nun dieselbe Funktion, die Typanmerkungen deklariert: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_character</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: int, calendar: Calendar)</span></span></span><span class="hljs-function"> -&gt; Character:</span></span>    ...</code> </pre> <br>  Mit Typanmerkungen k√∂nnen Sie den Vertrag dieser Funktion explizit ausdr√ºcken.  Um zu verstehen, was in eine Funktion eingegeben werden muss und was diese Funktion zur√ºckgibt, lesen Sie einfach ihre Signatur.  Ein Typpr√ºfsystem kann die Funktion statisch analysieren und die Einhaltung des Vertrags im Code √ºberpr√ºfen.  Auf diese Weise k√∂nnen Sie eine ganze Klasse von Fehlern beseitigen! <br><br><h2>  <font color="#3AC1EF">Typen f√ºr verschiedene HTTP-APIs</font> </h2><br>  Wir werden eine HTTP-API entwickeln, mit der Sie Informationen √ºber die Helden von Star Wars erhalten.  Um den expliziten Vertrag zu beschreiben, der bei der Arbeit mit dieser API verwendet wird, verwenden wir Typanmerkungen. <br><br>  Unsere API sollte die Zeichenkennung ( <code>id</code> ) als URL-Parameter und den Wert der <code>calendar</code> als Anforderungsparameter akzeptieren.  Die API sollte eine JSON-Antwort mit Zeicheninformationen zur√ºckgeben. <br><br>  So sieht die API-Anforderung aus und welche Antwort wird zur√ºckgegeben: <br><br><pre> <code class="plaintext hljs">curl -X GET https://api.starwars.com/characters/1000?calendar=BBY {    "id": 1000,    "name": "Luke Skywalker",    "birth_year": "19BBY" }</code> </pre> <br>  Um diese API in Django zu implementieren, m√ºssen Sie zuerst den URL-Pfad und die Ansichtsfunktion registrieren, die f√ºr den Empfang der √ºber diesen Pfad gestellten HTTP-Anforderung und die R√ºckgabe der Antwort verantwortlich sind. <br><br><pre> <code class="python hljs">urlpatterns = [    url(<span class="hljs-string"><span class="hljs-string">"characters/&lt;id&gt;/"</span></span>, get_character) ]</code> </pre> <br>  Die Funktion akzeptiert als Eingabe die Anforderungs- und URL-Parameter (in unserem Fall <code>id</code> ).  Es analysiert und wandelt den <code>calendar</code> , der der Wert aus der entsprechenden Aufz√§hlung ist, in den erforderlichen Typ um.  Es l√§dt Zeichendaten aus dem Speicher und gibt ein in JSON serialisiertes und in eine HTTP-Antwort eingeschlossenes W√∂rterbuch zur√ºck. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_character</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request: IGWSGIRequest, id: str)</span></span></span><span class="hljs-function"> -&gt; JsonResponse:</span></span>    calendar = Calendar(request.GET.get(<span class="hljs-string"><span class="hljs-string">"calendar"</span></span>, <span class="hljs-string"><span class="hljs-string">"BBY"</span></span>))    character = Store.get_character(id, calendar)    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> JsonResponse(asdict(character))</code> </pre> <br>  Obwohl die Funktion mit Typanmerkungen versehen ist, wird der feste Vertrag f√ºr die HTTP-API nicht explizit beschrieben.  Aus der Signatur dieser Funktion k√∂nnen wir die Namen oder Typen von Anforderungsparametern oder Antwortfeldern und deren Typen nicht herausfinden. <br><br>  Ist es m√∂glich, dass die Signatur der Funktionsdarstellung genau so aussagekr√§ftig ist wie die Signatur der zuvor betrachteten Funktion mit Typanmerkungen? <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_character</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: int, calendar: Calendar)</span></span></span><span class="hljs-function"> -&gt; Character:</span></span>    ...</code> </pre> <br>  Funktionsparameter k√∂nnen Abfrageparameter sein (URL-, Abfrage- oder Abfragek√∂rperparameter).  Der von der Funktion zur√ºckgegebene Werttyp kann den Inhalt der Antwort darstellen.  Mit diesem Ansatz h√§tten wir einen expliziten und verst√§ndlichen Vertrag f√ºr die HTTP-API zur Verf√ºgung, dessen Einhaltung durch ein Typpr√ºfungssystem sichergestellt werden k√∂nnte. <br><br><h2>  <font color="#3AC1EF">Implementierung</font> </h2><br>  Wie kann man diese Idee umsetzen? <br><br>  Wir verwenden einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dekorateur</a> , um eine stark typisierte Darstellungsfunktion in eine Django-Darstellungsfunktion umzuwandeln.  Dieser Schritt erfordert keine √Ñnderungen in Bezug auf die Arbeit mit dem Django-Framework.  Wir k√∂nnen dieselbe Middleware, dieselben Routen und andere Komponenten verwenden, die wir gewohnt sind. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@api_view def get_character(id: int, calendar: Calendar) -&gt; Character:    ...</span></span></code> </pre> <br>  Betrachten Sie die Details der <code>api_view</code> von <code>api_view</code> decorator: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">api_view</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view)</span></span></span><span class="hljs-function">:</span></span>    @functools.wraps(view)    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">django_view</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span>        params = {            param_name: param.annotation(extract(request, param))            <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> param_name, param <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> inspect.signature(view).parameters.items()        }        data = view(**params)        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> JsonResponse(asdict(data))       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> django_view</code> </pre> <br>  Dies ist ein schwer zu verstehender Code.  Lassen Sie uns seine Funktionen analysieren. <br>  Als Eingabewert nehmen wir eine stark typisierte Darstellungsfunktion und verpacken sie in eine regul√§re Django-Darstellungsfunktion, die wir zur√ºckgeben: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">api_view</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view)</span></span></span><span class="hljs-function">:</span></span>    @functools.wraps(view)    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">django_view</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span>        ...    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> django_view</code> </pre> <br>  Schauen Sie sich nun die Implementierung der Django-Ansichtsfunktion an.  Zuerst m√ºssen wir Argumente f√ºr eine stark typisierte Pr√§sentationsfunktion konstruieren.  Wir verwenden Introspection und das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inspect-</a> Modul, um die Signatur dieser Funktion zu erhalten und ihre Parameter zu durchlaufen: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> param_name, param <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> inspect.signature(view).parameters.items()</code> </pre> <br>  F√ºr jeden Parameter rufen wir die <code>extract</code> , die den Parameterwert aus der Anforderung extrahiert. <br><br>  Dann wandeln wir den Parameter in den erwarteten Typ um, der in der Signatur angegeben ist (z. B. wandeln wir den Zeichenfolgenkalender in einen Wert um, der ein Element der <code>Calendar</code> ). <br><br><pre> <code class="python hljs">param.annotation(extract(request, param))</code> </pre> <br>  Wir rufen eine stark typisierte Ansichtsfunktion mit den von uns konstruierten Argumenten auf: <br><br><pre> <code class="python hljs">data = view(**params)</code> </pre> <br>  Die Funktion gibt einen stark typisierten Wert der <code>Character</code> .  Wir nehmen diesen Wert, wandeln ihn in ein W√∂rterbuch um und verpacken ihn in eine HTTP-Antwort im JSON-Format: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> JsonResponse(asdict(data))</code> </pre> <br>  Gro√üartig!  Wir haben jetzt eine Django-Ansichtsfunktion, die eine stark typisierte Ansichtsfunktion umschlie√üt.  Schauen Sie sich zum Schluss die <code>extract</code> : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extract</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request: HttpRequest, param: Parameter)</span></span></span><span class="hljs-function"> -&gt; Any:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> request.resolver_match.route.contains(<span class="hljs-string"><span class="hljs-string">f"&lt;</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{param}</span></span></span><span class="hljs-string">&gt;"</span></span>):        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.resolver_match.kwargs.get(param.name)    <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>:        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.GET.get(param.name)</code> </pre> <br>  Jeder Parameter kann ein URL-Parameter oder ein Anforderungsparameter sein.  Der Anforderungs-URL-Pfad (der Pfad, den wir zu Beginn registriert haben) ist im Routenobjekt des Django-URL-Locator-Systems verf√ºgbar.  Wir √ºberpr√ºfen den Parameternamen im Pfad.  Wenn es einen Namen gibt, haben wir einen URL-Parameter.  Dies bedeutet, dass wir es irgendwie aus der Anfrage extrahieren k√∂nnen.  Andernfalls ist dies ein Abfrageparameter, den wir auch extrahieren k√∂nnen, jedoch auf andere Weise. <br><br>  Das ist alles.  Dies ist eine vereinfachte Implementierung, die jedoch die Grundidee der Eingabe einer API veranschaulicht. <br><br><h2>  <font color="#3AC1EF">Datentypen</font> </h2><br>  Der Typ, der zur Darstellung des Inhalts der HTTP-Antwort verwendet wird (d. H. <code>Character</code> ), kann entweder durch eine Datenklasse oder ein typisiertes W√∂rterbuch dargestellt werden. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eine</a> Datenklasse ist ein kompaktes Klassenbeschreibungsformat, das Daten darstellt. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dataclasses <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> dataclass @dataclass(frozen=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Character</span></span></span><span class="hljs-class">:</span></span>    id: int    name: str    birth_year: str luke = Character(    id=<span class="hljs-number"><span class="hljs-number">1000</span></span>,    name=<span class="hljs-string"><span class="hljs-string">"Luke Skywalker"</span></span>,    birth_year=<span class="hljs-string"><span class="hljs-string">"19BBY"</span></span> )</code> </pre> <br>  Instagram verwendet normalerweise Datenklassen, um HTTP-Antwortobjekte zu modellieren.  Hier sind ihre Hauptmerkmale: <br><br><ul><li>  Sie generieren automatisch Vorlagenkonstruktionen und verschiedene Hilfsmethoden. </li><li>  Sie sind f√ºr Typpr√ºfungssysteme verst√§ndlich, dh Werte k√∂nnen einer Typpr√ºfung unterzogen werden. </li><li>  Sie behalten ihre Immunit√§t dank des Konstrukts <code>frozen=True</code> . </li><li>  Sie sind in der Python-Standardbibliothek 3.7 oder als Backport im Python-Paketindex verf√ºgbar. </li></ul><br>  Leider verf√ºgt Instagram √ºber eine veraltete Codebasis, die gro√üe, nicht typisierte W√∂rterb√ºcher verwendet, die zwischen Funktionen und Modulen ausgetauscht werden.  Es w√§re nicht einfach, all diesen Code von W√∂rterb√ºchern in Datenklassen zu √ºbersetzen.  Infolgedessen verwenden wir Datenklassen f√ºr den neuen Code und in veraltetem Code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">typisierte W√∂rterb√ºcher</a> . <br><br>  Durch die Verwendung typisierter W√∂rterb√ºcher k√∂nnen wir Client-W√∂rterbuchobjekten Typanmerkungen hinzuf√ºgen und, ohne das Verhalten eines funktionierenden Systems zu √§ndern, die Funktionen zur Typpr√ºfung verwenden. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mypy_extensions <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TypedDict <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Character</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(TypedDict)</span></span></span><span class="hljs-class">:</span></span>    id: int    name: str    birth_year: str luke: Character = {<span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">1000</span></span>} luke[<span class="hljs-string"><span class="hljs-string">"name"</span></span>] = <span class="hljs-string"><span class="hljs-string">"Luke Skywalker"</span></span> luke[<span class="hljs-string"><span class="hljs-string">"birth_year"</span></span>] = <span class="hljs-number"><span class="hljs-number">19</span></span> <span class="hljs-comment"><span class="hljs-comment"># type error, birth_year expects a str luke["invalid_key"] # type error, invalid_key does not exist</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Fehlerbehandlung</font> </h2><br>  Es wird erwartet, dass die Ansichtsfunktion Zeicheninformationen in Form einer Zeichenentit√§t zur√ºckgibt.  Was sollen wir tun, wenn wir einen Fehler an den Client zur√ºckgeben m√ºssen? <br><br>  Sie k√∂nnen eine Ausnahme ausl√∂sen, die vom Framework abgefangen und in eine HTTP-Antwort mit Fehlerinformationen konvertiert wird. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@api_view("GET") def get_character(id: str, calendar: Calendar) -&gt; Character:    try:        return Store.get_character(id)    except CharacterNotFound:        raise Http404Exception()</span></span></code> </pre> <br>  Dieses Beispiel zeigt auch die HTTP-Methode im Decorator, mit der die f√ºr diese API zul√§ssigen HTTP-Methoden festgelegt werden. <br><br><h2>  <font color="#3AC1EF">Die Werkzeuge</font> </h2><br>  Die HTTP-API wird stark mithilfe der HTTP-Methode, der Anforderungstypen und der Antworttypen typisiert.  Wir k√∂nnen diese API √ºberpr√ºfen und festlegen, dass eine GET-Anforderung mit der <code>id</code> Zeichenfolge im URL-Pfad und dem <code>calendar</code> f√ºr die entsprechende Aufz√§hlung in der Abfragezeichenfolge akzeptiert werden soll.  Wir k√∂nnen auch lernen, dass als Antwort auf eine solche Anfrage eine JSON-Antwort mit Informationen √ºber die Art des <code>Character</code> . <br><br>  Was kann mit all diesen Informationen gemacht werden? <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenAPI</a> ist ein API-Beschreibungsformat, auf dessen Grundlage eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vielzahl von Hilfstools</a> erstellt wird.  Dies ist ein ganzes √ñkosystem.  Wenn wir Code schreiben, um eine Endpunkt-Introspektion durchzuf√ºhren und OpenAPI-Spezifikationen basierend auf den empfangenen Daten zu generieren, bedeutet dies, dass wir √ºber die Funktionen dieser Tools verf√ºgen. <br><br><pre> <code class="python hljs">paths:  /characters/{id}:    get:      parameters:        - <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: path          name: id          schema:            type: integer          required: true        - <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: query          name: calendar          schema:            type: string            enum: [<span class="hljs-string"><span class="hljs-string">"BBY"</span></span>]      responses:        <span class="hljs-string"><span class="hljs-string">'200'</span></span>:          content:            application/json:              schema:                type: object                ...</code> </pre> <br>  Wir k√∂nnen eine HTTP-API-Dokumentation f√ºr die <code>get_character</code> API <code>get_character</code> , die Namen, Typen, Anforderungs- und <code>get_character</code> enth√§lt.  Dies ist eine geeignete Abstraktionsebene f√ºr Cliententwickler, die Anforderungen an den entsprechenden Endpunkt erf√ºllen m√ºssen.  Sie m√ºssen den Python-Implementierungscode f√ºr diesen Endpunkt nicht lesen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/673/e79/28e/673e7928eb5c55d4d6ec83c506eaf450.png"><br>  <i><font color="#999999">API-Dokumentation</font></i> <br><br>  Auf dieser Basis k√∂nnen Sie zus√§tzliche Werkzeuge erstellen.  Zum Beispiel ein Mittel zum Ausf√ºhren einer Anfrage von einem Browser.  Auf diese Weise k√∂nnen Entwickler auf die f√ºr sie interessanten HTTP-APIs zugreifen, ohne Code schreiben zu m√ºssen.  Wir k√∂nnen sogar typsicheren Clientcode generieren, um sicherzustellen, dass Typen sowohl auf dem Client als auch auf dem Server ordnungsgem√§√ü funktionieren.  Aus diesem Grund verf√ºgen wir m√∂glicherweise √ºber eine streng typisierte API auf dem Server, deren Aufrufe mit streng typisiertem Clientcode ausgef√ºhrt werden. <br><br>  Dar√ºber hinaus k√∂nnen wir ein Abw√§rtskompatibilit√§tspr√ºfungssystem erstellen.  Was passiert, wenn wir eine neue Version des <code>birth_year</code> , in der wir f√ºr den Zugriff auf die betreffende API <code>id</code> , <code>name</code> und <code>birth_year</code> , und dann verstehen wir, dass wir nicht die Geburtstage aller Zeichen kennen?  In diesem Fall muss der Parameterirth_year optional gemacht werden, aber alte Versionen von Clients, die einen √§hnlichen Parameter erwarten, funktionieren m√∂glicherweise einfach nicht mehr.  Obwohl sich unsere APIs in der expliziten Typisierung unterscheiden, k√∂nnen sich die entsprechenden Typen √§ndern (z. B. √§ndert sich die API, wenn die Verwendung des Geburtsjahres des Charakters zuerst obligatorisch war und dann optional wurde).  Wir k√∂nnen API-√Ñnderungen verfolgen und API-Entwickler warnen, indem wir sie zum richtigen Zeitpunkt auffordern, dass sie durch einige √Ñnderungen die Leistung von Clients beeintr√§chtigen k√∂nnen. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Es gibt eine ganze Reihe von Anwendungsprotokollen, mit denen Computer miteinander kommunizieren k√∂nnen. <br><br>  Eine Seite dieses Spektrums wird durch RPC-Frameworks wie Thrift und gRPC dargestellt.  Sie unterscheiden sich darin, dass sie normalerweise strenge Typen f√ºr Anforderungen und Antworten festlegen und Client- und Servercode f√ºr die Organisation des Betriebs von Anforderungen generieren.  Sie k√∂nnen ohne HTTP und sogar ohne JSON auskommen. <br><br>  Andererseits gibt es in Python geschriebene unstrukturierte Webframeworks, die keine expliziten Vertr√§ge f√ºr Anforderungen und Antworten haben.  Unser Ansatz bietet die Funktionen, die f√ºr klar strukturierte Frameworks charakteristisch sind, erm√∂glicht Ihnen jedoch gleichzeitig die weitere Verwendung des HTTP + JSON-Bundles und tr√§gt dazu bei, dass Sie nur minimale √Ñnderungen am Anwendungscode vornehmen m√ºssen. <br><br>  Es ist wichtig zu beachten, dass diese Idee nicht neu ist.  Es gibt viele Frameworks, die in stark typisierten Sprachen geschrieben sind und Entwicklern die von uns beschriebenen Funktionen bieten.  Wenn wir √ºber Python sprechen, ist dies beispielsweise das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">APIStar-</a> Framework. <br><br>  Wir haben die Verwendung von Typen f√ºr die HTTP-API erfolgreich in Auftrag gegeben.  Wir konnten den beschriebenen Ansatz auf die Typisierung der API in unserer gesamten Codebasis anwenden, da sie gut auf vorhandene Pr√§sentationsfunktionen anwendbar ist.  Der Wert dessen, was wir getan haben, ist f√ºr alle unsere Programmierer offensichtlich.  Wir sprechen n√§mlich von der Tatsache, dass die automatisch generierte Dokumentation zu einem effektiven Kommunikationsmittel f√ºr diejenigen geworden ist, die an der Entwicklung des Servers mit denen beteiligt sind, die den Instagram-Client schreiben. <br><br>  <b>Liebe Leser!</b>  Wie gehen Sie beim Entwurf von HTTP-APIs in Ihren Python-Projekten vor? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de474308/">https://habr.com/ru/post/de474308/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de474294/index.html">Bin√§rkompatibilit√§t: jetzt oder nie</a></li>
<li><a href="../de474298/index.html">Implementieren eines P2P-Gateways von Karte zu Karte</a></li>
<li><a href="../de474300/index.html">Zuverl√§ssiges, sicheres und vielseitiges Backup f√ºr U2F</a></li>
<li><a href="../de474302/index.html">So schreiben Sie ein effektives Anwendungsbenutzbarkeitstestskript</a></li>
<li><a href="../de474306/index.html">√Ñndern Sie die Stile f√ºr Zeigen, Fokussieren und aktiven Status.</a></li>
<li><a href="../de474310/index.html">Gibt es Zufallszahlen in CSS?</a></li>
<li><a href="../de474312/index.html">Installieren der GUI unter Windows Server Core</a></li>
<li><a href="../de474316/index.html">Selbstgemachtes Elektroauto Teil 1. Wie alles begann und wie ich 1.000.000 Aufrufe auf Youtube erzielte</a></li>
<li><a href="../de474318/index.html">Was ist eine virtuelle Tischtabelle?</a></li>
<li><a href="../de474320/index.html">DDD-Gemeinschaftskrise</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>