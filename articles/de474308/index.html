<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔮 🙁 🏤 In Python geschriebene Typen für HTTP-APIs: Instagram-Erfahrung 👨‍👩‍👧‍👧 👃🏽 🎸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Heute veröffentlichen wir das zweite Material aus der Reihe, das sich mit der Verwendung von Python in Instagram befasst. Beim letzten Mal wurden die ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>In Python geschriebene Typen für HTTP-APIs: Instagram-Erfahrung</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/474308/">  Heute veröffentlichen wir das zweite Material aus der Reihe, das sich mit der Verwendung von Python in Instagram befasst.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beim letzten</a> Mal wurden die Arten von Instagram-Servercode überprüft.  Der Server ist ein in Python geschriebener Monolith.  Es besteht aus mehreren Millionen Codezeilen und hat mehrere tausend Django-Endpunkte. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/nn/gh/jg/nnghjgmcauejll98mv34awk3cok.jpeg"></a> <br><br>  In diesem Artikel geht es darum, wie Instagram Typen verwendet, um HTTP-APIs zu dokumentieren und Verträge bei der Arbeit mit ihnen durchzusetzen. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Situationsübersicht</font> </h2><br>  Wenn Sie den mobilen Instagram-Client öffnen, greift er über HTTP auf die JSON-API unseres Python-Servers (Django) zu. <br><br>  Hier finden Sie einige Informationen zu unserem System, mit denen Sie sich ein Bild von der Komplexität der API machen können, mit der wir die Arbeit des mobilen Clients organisieren.  Also hier ist was wir haben: <br><br><ul><li>  Über 2000 Endpunkte auf dem Server. </li><li>  Über 200 Felder der obersten Ebene in einem Client-Datenobjekt, das ein Bild, ein Video oder eine Story in einer Anwendung darstellt. </li><li>  Hunderte von Programmierern, die Servercode schreiben (und noch mehr, die sich mit dem Client befassen). </li><li>  Täglich werden Hunderte von Commits für Servercode vorgenommen und die API geändert.  Dies ist erforderlich, um neue Systemfunktionen zu unterstützen. </li></ul><br>  Wir verwenden Typen, um unsere komplexen, sich ständig weiterentwickelnden HTTP-APIs zu dokumentieren und Verträge bei der Arbeit mit ihnen durchzusetzen. <br><br><h2>  <font color="#3AC1EF">Typen</font> </h2><br>  Beginnen wir von vorne.  Die Beschreibung der Syntax für Typanmerkungen in Python-Code wurde in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PEP 484 veröffentlicht</a> .  Warum dem Code Typanmerkungen hinzufügen? <br><br>  Betrachten Sie die Funktion, mit der Informationen über den Helden von Star Wars heruntergeladen werden: <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_character</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id, calendar)</span></span></span><span class="hljs-function">:</span></span>     <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> id == <span class="hljs-number"><span class="hljs-number">1000</span></span>:         <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Character(             id=<span class="hljs-number"><span class="hljs-number">1000</span></span>,             name=<span class="hljs-string"><span class="hljs-string">"Luke Skywalker"</span></span>,             birth_year=<span class="hljs-string"><span class="hljs-string">"19BBY"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> calendar == Calendar.BBY <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> ...         )     ...</code> </pre> <br>  Um diese Funktion zu verstehen, müssen Sie den Code lesen.  Nachdem Sie dies getan haben, können Sie Folgendes herausfinden: <br><br><ul><li>  Es wird die Ganzzahlkennung ( <code>id</code> ) des Zeichens verwendet. </li><li>  Es übernimmt den Wert aus der entsprechenden Aufzählung ( <code>calendar</code> ).  Zum Beispiel steht <code>Calendar.BBY</code> für "Vor der Schlacht von Yavin", dh "Vor der Schlacht von Yavin". </li><li>  Es gibt Informationen über das Zeichen in Form einer Entität zurück, die Felder enthält, die die Kennung dieses Zeichens, seinen Namen und sein Geburtsjahr darstellen. </li></ul><br>  Die Funktion hat einen impliziten Vertrag, dessen Bedeutung der Programmierer jedes Mal wiederherstellen muss, wenn er den Funktionscode liest.  Der Funktionscode wird jedoch nur einmal geschrieben, und Sie müssen ihn viele Male lesen, sodass dieser Ansatz für die Arbeit mit diesem Code nicht besonders gut ist. <br><br>  Darüber hinaus ist es schwierig zu überprüfen, ob der Mechanismus, der die Funktion aufruft, dem oben beschriebenen impliziten Vertrag entspricht.  Ebenso ist es schwierig zu überprüfen, ob dieser Vertrag im Hauptteil der Funktion eingehalten wird.  In einer großen Codebasis können solche Situationen zu Fehlern führen. <br><br>  Betrachten Sie nun dieselbe Funktion, die Typanmerkungen deklariert: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_character</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: int, calendar: Calendar)</span></span></span><span class="hljs-function"> -&gt; Character:</span></span>    ...</code> </pre> <br>  Mit Typanmerkungen können Sie den Vertrag dieser Funktion explizit ausdrücken.  Um zu verstehen, was in eine Funktion eingegeben werden muss und was diese Funktion zurückgibt, lesen Sie einfach ihre Signatur.  Ein Typprüfsystem kann die Funktion statisch analysieren und die Einhaltung des Vertrags im Code überprüfen.  Auf diese Weise können Sie eine ganze Klasse von Fehlern beseitigen! <br><br><h2>  <font color="#3AC1EF">Typen für verschiedene HTTP-APIs</font> </h2><br>  Wir werden eine HTTP-API entwickeln, mit der Sie Informationen über die Helden von Star Wars erhalten.  Um den expliziten Vertrag zu beschreiben, der bei der Arbeit mit dieser API verwendet wird, verwenden wir Typanmerkungen. <br><br>  Unsere API sollte die Zeichenkennung ( <code>id</code> ) als URL-Parameter und den Wert der <code>calendar</code> als Anforderungsparameter akzeptieren.  Die API sollte eine JSON-Antwort mit Zeicheninformationen zurückgeben. <br><br>  So sieht die API-Anforderung aus und welche Antwort wird zurückgegeben: <br><br><pre> <code class="plaintext hljs">curl -X GET https://api.starwars.com/characters/1000?calendar=BBY {    "id": 1000,    "name": "Luke Skywalker",    "birth_year": "19BBY" }</code> </pre> <br>  Um diese API in Django zu implementieren, müssen Sie zuerst den URL-Pfad und die Ansichtsfunktion registrieren, die für den Empfang der über diesen Pfad gestellten HTTP-Anforderung und die Rückgabe der Antwort verantwortlich sind. <br><br><pre> <code class="python hljs">urlpatterns = [    url(<span class="hljs-string"><span class="hljs-string">"characters/&lt;id&gt;/"</span></span>, get_character) ]</code> </pre> <br>  Die Funktion akzeptiert als Eingabe die Anforderungs- und URL-Parameter (in unserem Fall <code>id</code> ).  Es analysiert und wandelt den <code>calendar</code> , der der Wert aus der entsprechenden Aufzählung ist, in den erforderlichen Typ um.  Es lädt Zeichendaten aus dem Speicher und gibt ein in JSON serialisiertes und in eine HTTP-Antwort eingeschlossenes Wörterbuch zurück. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_character</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request: IGWSGIRequest, id: str)</span></span></span><span class="hljs-function"> -&gt; JsonResponse:</span></span>    calendar = Calendar(request.GET.get(<span class="hljs-string"><span class="hljs-string">"calendar"</span></span>, <span class="hljs-string"><span class="hljs-string">"BBY"</span></span>))    character = Store.get_character(id, calendar)    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> JsonResponse(asdict(character))</code> </pre> <br>  Obwohl die Funktion mit Typanmerkungen versehen ist, wird der feste Vertrag für die HTTP-API nicht explizit beschrieben.  Aus der Signatur dieser Funktion können wir die Namen oder Typen von Anforderungsparametern oder Antwortfeldern und deren Typen nicht herausfinden. <br><br>  Ist es möglich, dass die Signatur der Funktionsdarstellung genau so aussagekräftig ist wie die Signatur der zuvor betrachteten Funktion mit Typanmerkungen? <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_character</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(id: int, calendar: Calendar)</span></span></span><span class="hljs-function"> -&gt; Character:</span></span>    ...</code> </pre> <br>  Funktionsparameter können Abfrageparameter sein (URL-, Abfrage- oder Abfragekörperparameter).  Der von der Funktion zurückgegebene Werttyp kann den Inhalt der Antwort darstellen.  Mit diesem Ansatz hätten wir einen expliziten und verständlichen Vertrag für die HTTP-API zur Verfügung, dessen Einhaltung durch ein Typprüfungssystem sichergestellt werden könnte. <br><br><h2>  <font color="#3AC1EF">Implementierung</font> </h2><br>  Wie kann man diese Idee umsetzen? <br><br>  Wir verwenden einen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dekorateur</a> , um eine stark typisierte Darstellungsfunktion in eine Django-Darstellungsfunktion umzuwandeln.  Dieser Schritt erfordert keine Änderungen in Bezug auf die Arbeit mit dem Django-Framework.  Wir können dieselbe Middleware, dieselben Routen und andere Komponenten verwenden, die wir gewohnt sind. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@api_view def get_character(id: int, calendar: Calendar) -&gt; Character:    ...</span></span></code> </pre> <br>  Betrachten Sie die Details der <code>api_view</code> von <code>api_view</code> decorator: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">api_view</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view)</span></span></span><span class="hljs-function">:</span></span>    @functools.wraps(view)    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">django_view</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span>        params = {            param_name: param.annotation(extract(request, param))            <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> param_name, param <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> inspect.signature(view).parameters.items()        }        data = view(**params)        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> JsonResponse(asdict(data))       <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> django_view</code> </pre> <br>  Dies ist ein schwer zu verstehender Code.  Lassen Sie uns seine Funktionen analysieren. <br>  Als Eingabewert nehmen wir eine stark typisierte Darstellungsfunktion und verpacken sie in eine reguläre Django-Darstellungsfunktion, die wir zurückgeben: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">api_view</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view)</span></span></span><span class="hljs-function">:</span></span>    @functools.wraps(view)    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">django_view</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span>        ...    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> django_view</code> </pre> <br>  Schauen Sie sich nun die Implementierung der Django-Ansichtsfunktion an.  Zuerst müssen wir Argumente für eine stark typisierte Präsentationsfunktion konstruieren.  Wir verwenden Introspection und das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inspect-</a> Modul, um die Signatur dieser Funktion zu erhalten und ihre Parameter zu durchlaufen: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> param_name, param <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> inspect.signature(view).parameters.items()</code> </pre> <br>  Für jeden Parameter rufen wir die <code>extract</code> , die den Parameterwert aus der Anforderung extrahiert. <br><br>  Dann wandeln wir den Parameter in den erwarteten Typ um, der in der Signatur angegeben ist (z. B. wandeln wir den Zeichenfolgenkalender in einen Wert um, der ein Element der <code>Calendar</code> ). <br><br><pre> <code class="python hljs">param.annotation(extract(request, param))</code> </pre> <br>  Wir rufen eine stark typisierte Ansichtsfunktion mit den von uns konstruierten Argumenten auf: <br><br><pre> <code class="python hljs">data = view(**params)</code> </pre> <br>  Die Funktion gibt einen stark typisierten Wert der <code>Character</code> .  Wir nehmen diesen Wert, wandeln ihn in ein Wörterbuch um und verpacken ihn in eine HTTP-Antwort im JSON-Format: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> JsonResponse(asdict(data))</code> </pre> <br>  Großartig!  Wir haben jetzt eine Django-Ansichtsfunktion, die eine stark typisierte Ansichtsfunktion umschließt.  Schauen Sie sich zum Schluss die <code>extract</code> : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extract</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request: HttpRequest, param: Parameter)</span></span></span><span class="hljs-function"> -&gt; Any:</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> request.resolver_match.route.contains(<span class="hljs-string"><span class="hljs-string">f"&lt;</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{param}</span></span></span><span class="hljs-string">&gt;"</span></span>):        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.resolver_match.kwargs.get(param.name)    <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>:        <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> request.GET.get(param.name)</code> </pre> <br>  Jeder Parameter kann ein URL-Parameter oder ein Anforderungsparameter sein.  Der Anforderungs-URL-Pfad (der Pfad, den wir zu Beginn registriert haben) ist im Routenobjekt des Django-URL-Locator-Systems verfügbar.  Wir überprüfen den Parameternamen im Pfad.  Wenn es einen Namen gibt, haben wir einen URL-Parameter.  Dies bedeutet, dass wir es irgendwie aus der Anfrage extrahieren können.  Andernfalls ist dies ein Abfrageparameter, den wir auch extrahieren können, jedoch auf andere Weise. <br><br>  Das ist alles.  Dies ist eine vereinfachte Implementierung, die jedoch die Grundidee der Eingabe einer API veranschaulicht. <br><br><h2>  <font color="#3AC1EF">Datentypen</font> </h2><br>  Der Typ, der zur Darstellung des Inhalts der HTTP-Antwort verwendet wird (d. H. <code>Character</code> ), kann entweder durch eine Datenklasse oder ein typisiertes Wörterbuch dargestellt werden. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eine</a> Datenklasse ist ein kompaktes Klassenbeschreibungsformat, das Daten darstellt. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> dataclasses <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> dataclass @dataclass(frozen=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Character</span></span></span><span class="hljs-class">:</span></span>    id: int    name: str    birth_year: str luke = Character(    id=<span class="hljs-number"><span class="hljs-number">1000</span></span>,    name=<span class="hljs-string"><span class="hljs-string">"Luke Skywalker"</span></span>,    birth_year=<span class="hljs-string"><span class="hljs-string">"19BBY"</span></span> )</code> </pre> <br>  Instagram verwendet normalerweise Datenklassen, um HTTP-Antwortobjekte zu modellieren.  Hier sind ihre Hauptmerkmale: <br><br><ul><li>  Sie generieren automatisch Vorlagenkonstruktionen und verschiedene Hilfsmethoden. </li><li>  Sie sind für Typprüfungssysteme verständlich, dh Werte können einer Typprüfung unterzogen werden. </li><li>  Sie behalten ihre Immunität dank des Konstrukts <code>frozen=True</code> . </li><li>  Sie sind in der Python-Standardbibliothek 3.7 oder als Backport im Python-Paketindex verfügbar. </li></ul><br>  Leider verfügt Instagram über eine veraltete Codebasis, die große, nicht typisierte Wörterbücher verwendet, die zwischen Funktionen und Modulen ausgetauscht werden.  Es wäre nicht einfach, all diesen Code von Wörterbüchern in Datenklassen zu übersetzen.  Infolgedessen verwenden wir Datenklassen für den neuen Code und in veraltetem Code <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">typisierte Wörterbücher</a> . <br><br>  Durch die Verwendung typisierter Wörterbücher können wir Client-Wörterbuchobjekten Typanmerkungen hinzufügen und, ohne das Verhalten eines funktionierenden Systems zu ändern, die Funktionen zur Typprüfung verwenden. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> mypy_extensions <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TypedDict <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Character</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(TypedDict)</span></span></span><span class="hljs-class">:</span></span>    id: int    name: str    birth_year: str luke: Character = {<span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-number"><span class="hljs-number">1000</span></span>} luke[<span class="hljs-string"><span class="hljs-string">"name"</span></span>] = <span class="hljs-string"><span class="hljs-string">"Luke Skywalker"</span></span> luke[<span class="hljs-string"><span class="hljs-string">"birth_year"</span></span>] = <span class="hljs-number"><span class="hljs-number">19</span></span> <span class="hljs-comment"><span class="hljs-comment"># type error, birth_year expects a str luke["invalid_key"] # type error, invalid_key does not exist</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Fehlerbehandlung</font> </h2><br>  Es wird erwartet, dass die Ansichtsfunktion Zeicheninformationen in Form einer Zeichenentität zurückgibt.  Was sollen wir tun, wenn wir einen Fehler an den Client zurückgeben müssen? <br><br>  Sie können eine Ausnahme auslösen, die vom Framework abgefangen und in eine HTTP-Antwort mit Fehlerinformationen konvertiert wird. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@api_view("GET") def get_character(id: str, calendar: Calendar) -&gt; Character:    try:        return Store.get_character(id)    except CharacterNotFound:        raise Http404Exception()</span></span></code> </pre> <br>  Dieses Beispiel zeigt auch die HTTP-Methode im Decorator, mit der die für diese API zulässigen HTTP-Methoden festgelegt werden. <br><br><h2>  <font color="#3AC1EF">Die Werkzeuge</font> </h2><br>  Die HTTP-API wird stark mithilfe der HTTP-Methode, der Anforderungstypen und der Antworttypen typisiert.  Wir können diese API überprüfen und festlegen, dass eine GET-Anforderung mit der <code>id</code> Zeichenfolge im URL-Pfad und dem <code>calendar</code> für die entsprechende Aufzählung in der Abfragezeichenfolge akzeptiert werden soll.  Wir können auch lernen, dass als Antwort auf eine solche Anfrage eine JSON-Antwort mit Informationen über die Art des <code>Character</code> . <br><br>  Was kann mit all diesen Informationen gemacht werden? <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenAPI</a> ist ein API-Beschreibungsformat, auf dessen Grundlage eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vielzahl von Hilfstools</a> erstellt wird.  Dies ist ein ganzes Ökosystem.  Wenn wir Code schreiben, um eine Endpunkt-Introspektion durchzuführen und OpenAPI-Spezifikationen basierend auf den empfangenen Daten zu generieren, bedeutet dies, dass wir über die Funktionen dieser Tools verfügen. <br><br><pre> <code class="python hljs">paths:  /characters/{id}:    get:      parameters:        - <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: path          name: id          schema:            type: integer          required: true        - <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: query          name: calendar          schema:            type: string            enum: [<span class="hljs-string"><span class="hljs-string">"BBY"</span></span>]      responses:        <span class="hljs-string"><span class="hljs-string">'200'</span></span>:          content:            application/json:              schema:                type: object                ...</code> </pre> <br>  Wir können eine HTTP-API-Dokumentation für die <code>get_character</code> API <code>get_character</code> , die Namen, Typen, Anforderungs- und <code>get_character</code> enthält.  Dies ist eine geeignete Abstraktionsebene für Cliententwickler, die Anforderungen an den entsprechenden Endpunkt erfüllen müssen.  Sie müssen den Python-Implementierungscode für diesen Endpunkt nicht lesen. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/673/e79/28e/673e7928eb5c55d4d6ec83c506eaf450.png"><br>  <i><font color="#999999">API-Dokumentation</font></i> <br><br>  Auf dieser Basis können Sie zusätzliche Werkzeuge erstellen.  Zum Beispiel ein Mittel zum Ausführen einer Anfrage von einem Browser.  Auf diese Weise können Entwickler auf die für sie interessanten HTTP-APIs zugreifen, ohne Code schreiben zu müssen.  Wir können sogar typsicheren Clientcode generieren, um sicherzustellen, dass Typen sowohl auf dem Client als auch auf dem Server ordnungsgemäß funktionieren.  Aus diesem Grund verfügen wir möglicherweise über eine streng typisierte API auf dem Server, deren Aufrufe mit streng typisiertem Clientcode ausgeführt werden. <br><br>  Darüber hinaus können wir ein Abwärtskompatibilitätsprüfungssystem erstellen.  Was passiert, wenn wir eine neue Version des <code>birth_year</code> , in der wir für den Zugriff auf die betreffende API <code>id</code> , <code>name</code> und <code>birth_year</code> , und dann verstehen wir, dass wir nicht die Geburtstage aller Zeichen kennen?  In diesem Fall muss der Parameterirth_year optional gemacht werden, aber alte Versionen von Clients, die einen ähnlichen Parameter erwarten, funktionieren möglicherweise einfach nicht mehr.  Obwohl sich unsere APIs in der expliziten Typisierung unterscheiden, können sich die entsprechenden Typen ändern (z. B. ändert sich die API, wenn die Verwendung des Geburtsjahres des Charakters zuerst obligatorisch war und dann optional wurde).  Wir können API-Änderungen verfolgen und API-Entwickler warnen, indem wir sie zum richtigen Zeitpunkt auffordern, dass sie durch einige Änderungen die Leistung von Clients beeinträchtigen können. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Es gibt eine ganze Reihe von Anwendungsprotokollen, mit denen Computer miteinander kommunizieren können. <br><br>  Eine Seite dieses Spektrums wird durch RPC-Frameworks wie Thrift und gRPC dargestellt.  Sie unterscheiden sich darin, dass sie normalerweise strenge Typen für Anforderungen und Antworten festlegen und Client- und Servercode für die Organisation des Betriebs von Anforderungen generieren.  Sie können ohne HTTP und sogar ohne JSON auskommen. <br><br>  Andererseits gibt es in Python geschriebene unstrukturierte Webframeworks, die keine expliziten Verträge für Anforderungen und Antworten haben.  Unser Ansatz bietet die Funktionen, die für klar strukturierte Frameworks charakteristisch sind, ermöglicht Ihnen jedoch gleichzeitig die weitere Verwendung des HTTP + JSON-Bundles und trägt dazu bei, dass Sie nur minimale Änderungen am Anwendungscode vornehmen müssen. <br><br>  Es ist wichtig zu beachten, dass diese Idee nicht neu ist.  Es gibt viele Frameworks, die in stark typisierten Sprachen geschrieben sind und Entwicklern die von uns beschriebenen Funktionen bieten.  Wenn wir über Python sprechen, ist dies beispielsweise das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">APIStar-</a> Framework. <br><br>  Wir haben die Verwendung von Typen für die HTTP-API erfolgreich in Auftrag gegeben.  Wir konnten den beschriebenen Ansatz auf die Typisierung der API in unserer gesamten Codebasis anwenden, da sie gut auf vorhandene Präsentationsfunktionen anwendbar ist.  Der Wert dessen, was wir getan haben, ist für alle unsere Programmierer offensichtlich.  Wir sprechen nämlich von der Tatsache, dass die automatisch generierte Dokumentation zu einem effektiven Kommunikationsmittel für diejenigen geworden ist, die an der Entwicklung des Servers mit denen beteiligt sind, die den Instagram-Client schreiben. <br><br>  <b>Liebe Leser!</b>  Wie gehen Sie beim Entwurf von HTTP-APIs in Ihren Python-Projekten vor? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de474308/">https://habr.com/ru/post/de474308/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de474294/index.html">Binärkompatibilität: jetzt oder nie</a></li>
<li><a href="../de474298/index.html">Implementieren eines P2P-Gateways von Karte zu Karte</a></li>
<li><a href="../de474300/index.html">Zuverlässiges, sicheres und vielseitiges Backup für U2F</a></li>
<li><a href="../de474302/index.html">So schreiben Sie ein effektives Anwendungsbenutzbarkeitstestskript</a></li>
<li><a href="../de474306/index.html">Ändern Sie die Stile für Zeigen, Fokussieren und aktiven Status.</a></li>
<li><a href="../de474310/index.html">Gibt es Zufallszahlen in CSS?</a></li>
<li><a href="../de474312/index.html">Installieren der GUI unter Windows Server Core</a></li>
<li><a href="../de474316/index.html">Selbstgemachtes Elektroauto Teil 1. Wie alles begann und wie ich 1.000.000 Aufrufe auf Youtube erzielte</a></li>
<li><a href="../de474318/index.html">Was ist eine virtuelle Tischtabelle?</a></li>
<li><a href="../de474320/index.html">DDD-Gemeinschaftskrise</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>