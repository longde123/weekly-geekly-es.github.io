<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚õîÔ∏è ‚ûø üçì Una explicaci√≥n simple de algoritmos de b√∫squeda de ruta y A * ‚òÑÔ∏è üìÜ üë®üèø‚ÄçüöÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parte 1. Algoritmo de b√∫squeda general 
 Introduccion 
 Encontrar un camino es uno de esos temas que generalmente son los m√°s dif√≠ciles para los desar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Una explicaci√≥n simple de algoritmos de b√∫squeda de ruta y A *</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444828/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/pb/iz/nb/pbiznbkynw8pju8unbz6xyqnqqq.gif" alt="imagen"></div><br><h2>  Parte 1. Algoritmo de b√∫squeda general </h2><br><h2>  Introduccion </h2><br>  Encontrar un camino es uno de esos temas que generalmente son los m√°s dif√≠ciles para los desarrolladores de juegos.  Especialmente la gente pobre comprende el algoritmo <strong>A *</strong> , y muchos piensan que se trata de alg√∫n tipo de magia incomprensible. <br><br>  El prop√≥sito de este art√≠culo es explicar la b√∫squeda de la ruta en general y <strong>A *</strong> en particular de una manera muy comprensible y accesible, poniendo fin a la idea err√≥nea generalizada de que este tema es complejo.  Con la explicaci√≥n correcta, todo es bastante simple. <br><br>  Tenga en cuenta que en el art√≠culo consideraremos la b√∫squeda de una forma <em>de juegos</em> ;  A diferencia de otros art√≠culos acad√©micos, omitiremos algoritmos de b√∫squeda como Profundidad-Primero o Anchura-Primero.  En su lugar, intentaremos pasar de cero a <strong>A * lo</strong> m√°s r√°pido posible. <br><a name="habracut"></a><br>  En la primera parte explicaremos los conceptos m√°s simples para encontrar un camino.  Al comprender estos conceptos b√°sicos, se dar√° cuenta de que <strong>A *</strong> es sorprendentemente obvio. <br><br><h2>  Circuito simple </h2><br>  Aunque puede aplicar estos conceptos a entornos 3D complejos arbitrarios, comencemos con un esquema extremadamente simple: una cuadr√≠cula cuadrada de 5 x 5. Para mayor comodidad, marqu√© cada celda con una letra may√∫scula. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e2d/66c/ed8/e2d66ced82a4c1d4ed739583bd782245.png"></div><br>  <i>Malla simple</i> <br><br>  Lo primero que haremos es imaginar este entorno como un gr√°fico.  No explicar√© en detalle qu√© es un gr√°fico;  En pocas palabras, este es un conjunto de c√≠rculos conectados por flechas.  Los c√≠rculos se llaman <em>"nudos",</em> y las flechas se <em>llaman "bordes"</em> . <br><br>  Cada nodo representa un <em>"estado"</em> en el que puede estar el personaje.  En nuestro caso, el estado del personaje es su posici√≥n, por lo que creamos un nodo para cada celda de la cuadr√≠cula: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/68a/d4b/4db/68ad4b4db470c1ce34434e6489a5a986.png"></div><br>  <i>Nodos que representan celdas de cuadr√≠cula.</i> <br><br>  Ahora agregue las costillas.  Indican los estados que se pueden <em>"alcanzar"</em> desde cada estado dado;  En nuestro caso, podemos pasar de cualquier celda a la siguiente, con la excepci√≥n de las bloqueadas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f73/56c/9be/f7356c9be0171d61c31e3e4c21bf9385.png"></div><br>  <i>Los arcos denotan movimientos permitidos entre celdas de la cuadr√≠cula.</i> <br><br>  Si podemos pasar de <strong>A</strong> a <strong>B</strong> , entonces decimos que <strong>B</strong> es un <em>"vecino"</em> para el nodo <strong>A.</strong> <br><br>  Vale la pena se√±alar que las costillas tienen una <em>direcci√≥n</em> ;  necesitamos aristas de <strong>A</strong> a <strong>B</strong> , y de <strong>B</strong> a <strong>A.</strong>  Esto puede parecer superfluo, pero no cuando surgen "condiciones" m√°s complejas.  Por ejemplo, un personaje puede caer del techo al piso, pero no puede saltar del piso al techo.  Puede pasar del estado de "vivo" al estado de "muerto", pero no al rev√©s.  Y as√≠ sucesivamente. <br><br><h2>  Ejemplo </h2><br>  Supongamos que queremos pasar de <strong>A</strong> a <strong>T.</strong>  Comenzamos con <strong>A.</strong>  Puede hacer exactamente dos acciones: ir a <strong>B</strong> o ir a <strong>F.</strong> <br><br>  Digamos que nos mudamos a <strong>B.</strong>  Ahora podemos hacer dos cosas: volver a <strong>A</strong> o ir a <strong>C.</strong>  Recordamos que ya est√°bamos en <strong>A</strong> y consideramos las opciones all√≠, por lo que no tiene sentido volver a hacerlo (de lo contrario, podemos pasar todo el d√≠a moviendo <strong>A</strong> ‚Üí <strong>B</strong> ‚Üí <strong>A</strong> ‚Üí <strong>B</strong> ...).  Por lo tanto iremos a <strong>C.</strong> <br><br>  Al estar en <strong>C</strong> , no tenemos a d√≥nde movernos.  Volver a <strong>B no tiene</strong> sentido, es decir, es un callej√≥n sin salida.  Elegir la transici√≥n a <strong>B</strong> cuando est√°bamos en <strong>A</strong> fue una mala idea;  tal vez deber√≠as probar <strong>F en su</strong> lugar? <br><br>  Seguimos repitiendo este proceso hasta que terminamos en <strong>T.</strong>  En este momento, simplemente recreamos el camino desde <strong>A</strong> , volviendo en nuestros pasos.  Estamos en <strong>T</strong> ;  ¬øC√≥mo llegamos all√≠?  De <strong>o</strong> ?  Es decir, el final del camino tiene la forma <strong>O</strong> ‚Üí <strong>T.</strong>  ¬øC√≥mo llegamos a <strong>O</strong> ?  Y as√≠ sucesivamente. <br><br>  Tenga en cuenta que no nos estamos <em>moviendo</em> realmente;  todo esto fue solo un proceso de pensamiento.  Continuamos parados en <strong>A</strong> , y no nos moveremos fuera de √©l hasta que encontremos todo el camino.  Cuando digo "movido a <strong>B</strong> ", quiero decir "imagina que nos mudamos a <strong>B</strong> ". <br><br><h2>  Algoritmo general </h2><br>  <strong>Esta secci√≥n es la parte m√°s importante de todo el art√≠culo</strong> .  Absolutamente <em>debe</em> comprenderlo para poder realizar la b√∫squeda del camino;  el resto (incluido <strong>A *</strong> ) son solo detalles.  En esta secci√≥n, comprender√° hasta que <em>comprenda el significado</em> . <br><br>  Adem√°s, esta secci√≥n es incre√≠blemente simple. <br><br>  Intentemos formalizar nuestro ejemplo, convirti√©ndolo en un pseudoc√≥digo. <br><br>  Necesitamos rastrear los nodos que sabemos c√≥mo llegar desde el nodo inicial.  Al principio, este es solo el nodo inicial, pero en el proceso de "explorar" la cuadr√≠cula, aprenderemos c√≥mo llegar a otros nodos.  Llamemos a esta lista de nodos <code>reachable</code> : <br><br><pre> <code class="python hljs">reachable = [start_node]</code> </pre> <br>  Tambi√©n necesitamos rastrear los nodos ya revisados ‚Äã‚Äãpara no volver a considerarlos.  <code>explored</code> : <br><br><pre> <code class="python hljs">explored = []</code> </pre> <br>  <strong>A continuaci√≥n, describir√© el n√∫cleo del algoritmo</strong> : en cada paso de la b√∫squeda, seleccionamos uno de los nodos que sabemos alcanzar y observamos qu√© nuevos nodos podemos obtener de √©l.  Si determinamos c√≥mo llegar al nodo final (objetivo), ¬°entonces el problema est√° resuelto!  De lo contrario, continuamos la b√∫squeda. <br><br>  Tan simple, ¬øqu√© incluso decepciona?  Y esto es verdad.  Pero este es todo el algoritmo.  Vamos a escribirlo paso a paso con pseudoc√≥digo. <br><br>  Continuamos buscando hasta que lleguemos al nodo final (en este caso, encontramos la ruta desde el nodo inicial al final), o hasta que nos quedemos sin nodos en los que puede buscar (en este caso, no hay forma entre los nodos iniciales y finales) . <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> reachable <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> empty:</code> </pre> <br>  Elegimos uno de los nodos a los que sabemos c√≥mo llegar y que a√∫n no se ha investigado: <br><br><pre> <code class="python hljs"> node = choose_node(reachable)</code> </pre> <br>  Si acabamos de aprender c√≥mo llegar al nodo final, ¬°entonces la tarea est√° completa!  Solo necesitamos construir la ruta siguiendo los enlaces <code>previous</code> al nodo de inicio: <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> node == goal_node: path = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> node != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: path.add(node) node = node.previous <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path</code> </pre> <br>  No tiene sentido examinar el nodo m√°s de una vez, as√≠ que haremos un seguimiento de esto: <br><br><pre> <code class="python hljs"> reachable.remove(node) explored.add(node)</code> </pre> <br>  Identificamos nodos a los que no podemos llegar desde aqu√≠.  Comenzamos con una lista de nodos adyacentes al actual y eliminamos los que ya hemos examinado: <br><br><pre> <code class="python hljs"> new_reachable = get_adjacent_nodes(node) - explored</code> </pre> <br>  Tomamos cada uno de ellos: <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> new_reachable:</code> </pre> <br>  Si ya sabemos c√≥mo llegar al nodo, ign√≥relo.  De lo contrario, agr√©guelo a la lista <code>reachable</code> , rastreando c√≥mo entr√≥ en √©l: <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: adjacent.previous = node <span class="hljs-comment"><span class="hljs-comment"># Remember how we got there. reachable.add(adjacent)</span></span></code> </pre> <br>  Encontrar el nodo final es una forma de salir del bucle.  La segunda es cuando lo <code>reachable</code> se vac√≠a: nos hemos quedado sin nodos que se pueden explorar, y no hemos llegado al nodo final, es decir, no hay forma desde el nodo inicial al final: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span></code> </pre> <br>  Y ... eso es todo.  Este es el algoritmo completo, y el c√≥digo de construcci√≥n de ruta se asigna en un m√©todo separado: <br><br><pre> <code class="python hljs">function find_path (start_node, end_node): reachable = [start_node] explored = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> reachable <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> empty: <span class="hljs-comment"><span class="hljs-comment"># Choose some node we know how to reach. node = choose_node(reachable) # If we just got to the goal node, build and return the path. if node == goal_node: return build_path(goal_node) # Don't repeat ourselves. reachable.remove(node) explored.add(node) # Where can we get from here? new_reachable = get_adjacent_nodes(node) - explored for adjacent in new_reachable: if adjacent not in reachable adjacent.previous = node # Remember how we got there. reachable.add(adjacent) # If we get here, no path was found :( return None</span></span></code> </pre> <br>  Aqu√≠ est√° la funci√≥n que construye la ruta, siguiendo los enlaces <code>previous</code> al nodo de inicio: <br><br><pre> <code class="python hljs">function build_path (to_node): path = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_node != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: path.add(to_node) to_node = to_node.previous <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path</code> </pre> <br>  Eso es todo  <em>Este es el</em> pseudoc√≥digo de <em>cada</em> algoritmo de b√∫squeda de ruta, incluido <strong>A *</strong> . <br><br>  Vuelva a leer esta secci√≥n hasta que comprenda c√≥mo funciona todo y, lo que es m√°s importante, <em>por qu√©</em> funciona todo.  Ser√≠a ideal dibujar un ejemplo a mano en papel, pero tambi√©n puede ver una demostraci√≥n interactiva: <br><br><h2>  Demo interactiva </h2><br>  Aqu√≠ hay una demostraci√≥n y un ejemplo de la implementaci√≥n del algoritmo anterior (puede ejecutarlo en la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">p√°gina del art√≠culo original</a> ).  <code>choose_node</code> solo selecciona un nodo aleatorio.  Puede iniciar el algoritmo paso a paso y ver la lista de <code>explored</code> <code>reachable</code> y <code>explored</code> , as√≠ como a d√≥nde apuntan los enlaces <code>previous</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vt/jk/cb/vtjkcb4tflduq7zu5p-oph2i73s.gif"></div><br>  Observe que la b√∫squeda termina tan pronto como se detecta una ruta;  Puede suceder que algunos nodos ni siquiera sean considerados. <br><br><h2>  Conclusi√≥n </h2><br>  El algoritmo presentado aqu√≠ es un algoritmo general para <em>cualquier</em> algoritmo de b√∫squeda de ruta. <br><br>  Pero, ¬øqu√© distingue cada algoritmo de otro, por qu√© <strong>A *</strong> es <strong>A *</strong> ? <br><br>  Aqu√≠ hay un consejo: si ejecuta la b√∫squeda en la demostraci√≥n varias veces, ver√° que el algoritmo no siempre encuentra la misma ruta.  Encuentra <em>un</em> camino, y este camino no es necesariamente el <em>m√°s corto</em> .  Por qu√© <br><br><h2>  Parte 2. Estrategias de b√∫squeda </h2><br>  Si no comprende completamente el algoritmo descrito en la secci√≥n anterior, vuelva a √©l y l√©alo nuevamente, porque es necesario para comprender m√°s informaci√≥n.  Cuando lo descubras, <strong>A *</strong> te parecer√° completamente natural y l√≥gico. <br><br><h2>  Ingrediente secreto </h2><br>  Al final de la parte anterior, dej√© dos preguntas abiertas: si cada algoritmo de b√∫squeda usa el mismo c√≥digo, ¬øpor qu√© <strong>A * se</strong> comporta como <strong>A *</strong> ?  ¬øY por qu√© la demostraci√≥n a veces encuentra diferentes caminos? <br><br>  Las respuestas a ambas preguntas est√°n relacionadas entre s√≠.  Aunque el algoritmo est√° bien definido, dej√© un aspecto sin resolver, y resulta que es la clave para explicar el comportamiento de los algoritmos de b√∫squeda: <br><br><pre> <code class="python hljs">node = choose_node(reachable)</code> </pre> <br>  Es esta cadena de aspecto inocente que distingue todos los algoritmos de b√∫squeda entre s√≠.  <code>choose_node</code> depende del m√©todo de implementaci√≥n de <code>choose_node</code> . <br><br>  Entonces, ¬øpor qu√© la demostraci√≥n encuentra diferentes caminos?  Porque su m√©todo <code>choose_node</code> selecciona un nodo al azar. <br><br><h2>  La longitud importa </h2><br>  Antes de sumergirnos en las diferencias en el comportamiento de la funci√≥n <code>choose_node</code> , necesitamos corregir un peque√±o descuido en el algoritmo descrito anteriormente. <br><br>  Cuando consideramos los nodos adyacentes a los actuales, ignoramos los que ya saben c√≥mo lograr: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: adjacent.previous = node <span class="hljs-comment"><span class="hljs-comment"># Remember how we got there. reachable.add(adjacent)</span></span></code> </pre> <br>  Esto es un error: ¬øqu√© pasa si descubrimos la <em>mejor</em> manera de llegar a √©l?  En este caso, es necesario cambiar el enlace del nodo <code>previous</code> para reflejar esta ruta m√°s corta. <br><br>  Para hacer esto, necesitamos saber la longitud de la ruta desde el nodo inicial hasta cualquier nodo accesible.  Llamaremos a esto el costo del camino.  Por ahora, suponemos que pasar de un nodo a uno de los nodos vecinos tiene un costo constante de <code>1</code> . <br><br>  Antes de comenzar la b√∫squeda, asignamos el valor de <code>cost</code> de cada nodo al <code>infinity</code> ;  Gracias a esto, <em>cualquier</em> camino ser√° m√°s corto que este.  Tambi√©n estableceremos el <code>cost</code> nodo <code>start_node</code> en <code>0</code> . <br><br>  Entonces as√≠ es como se ver√° el c√≥digo: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> adjacent <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: reachable.add(adjacent) <span class="hljs-comment"><span class="hljs-comment"># If this is a new path, or a shorter path than what we have, keep it. if node.cost + 1 &lt; adjacent.cost: adjacent.previous = node adjacent.cost = node.cost + 1</span></span></code> </pre> <br><h2>  Mismo costo de b√∫squeda </h2><br>  Veamos ahora el m√©todo <code>choose_node</code> .  Si nos esforzamos por encontrar la ruta m√°s corta posible, elegir un nodo al azar no es una buena idea. <br><br>  Es mejor elegir un nodo que podamos alcanzar desde el nodo inicial a lo largo del camino m√°s corto;  Gracias a esto, generalmente preferimos caminos m√°s cortos a los m√°s largos.  Esto no significa que las rutas m√°s largas no se considerar√°n en absoluto, s√≠ significa que las rutas m√°s cortas se considerar√°n primero.  Dado que el algoritmo termina inmediatamente despu√©s de encontrar una ruta adecuada, esto deber√≠a permitirnos encontrar rutas cortas. <br><br>  Aqu√≠ hay un posible ejemplo de la funci√≥n <code>choose_node</code> : <br><br><pre> <code class="python hljs">function choose_node (reachable): best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> best_node == <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> best_node.cost &gt; node.cost: best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br>  Intuitivamente, la b√∫squeda de este algoritmo se expande "radialmente" desde el nodo inicial hasta que llega al nodo final.  Aqu√≠ hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">una demostraci√≥n interactiva de</a> este comportamiento: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nh/fn/jd/nhfnjd_ztdx3fbuqy5v5_am5hxw.gif"></div><br><h2>  Conclusi√≥n </h2><br>  Un simple cambio en el m√©todo de elecci√≥n del nodo considerado por el siguiente nos permiti√≥ obtener un algoritmo bastante bueno: encuentra la ruta m√°s corta desde el nodo inicial hasta el final. <br><br>  Pero este algoritmo, hasta cierto punto, sigue siendo "est√∫pido".  Contin√∫a buscando en todas partes hasta que se topa con un nodo terminal.  Por ejemplo, ¬øcu√°l es el punto en el ejemplo que se muestra arriba para buscar en la direcci√≥n <strong>A</strong> , si es obvio que nos estamos alejando del nodo final? <br><br>  ¬øEs posible hacer <code>choose_node</code> m√°s inteligente?  ¬øPodemos hacer que <em>dirija la b√∫squeda hacia el nodo final</em> , sin siquiera saber de antemano la ruta correcta? <br><br>  Resulta que podemos: en la siguiente parte, finalmente llegamos a <code>choose_node</code> , lo que nos permite convertir el algoritmo de b√∫squeda de ruta general en <strong>A *</strong> . <br><br><h2>  Parte 3. Retire el velo de secreto de A * </h2><br>  El algoritmo obtenido en la parte anterior es bastante bueno: encuentra la ruta m√°s corta desde el nodo inicial hasta el final.  Sin embargo, desperdicia su energ√≠a: considera las formas que una persona obviamente llama err√≥neas: generalmente <em>se alejan</em> de la meta.  ¬øC√≥mo se puede evitar esto? <br><br><h2>  Algoritmo m√°gico </h2><br>  Imagine que ejecutamos un algoritmo de b√∫squeda en una computadora especial con un chip que puede hacer <em>magia</em> .  Gracias a este incre√≠ble chip, podemos expresar <code>choose_node</code> muy simple, que garantiza la creaci√≥n del camino m√°s corto sin perder tiempo explorando caminos parciales que no llevan a ninguna parte: <br><br><pre> <code class="python hljs">function choose_node (reachable): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> magic(reachable, <span class="hljs-string"><span class="hljs-string">" ,     "</span></span>)</code> </pre> <br>  Suena tentador, pero las fichas m√°gicas a√∫n necesitan alg√∫n tipo de c√≥digo de bajo nivel.  Aqu√≠ hay una buena aproximaci√≥n: <br><br><pre> <code class="python hljs">function choose_node (reachable): min_cost = infinity best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: cost_start_to_node = node.cost cost_node_to_goal = magic(node, <span class="hljs-string"><span class="hljs-string">"   "</span></span>) total_cost = cost_start_to_node + cost_node_to_goal <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> min_cost &gt; total_cost: min_cost = total_cost best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br>  Esta es una excelente manera de seleccionar el siguiente nodo: selecciona un nodo que nos da la ruta m√°s corta desde el nodo inicial hasta el final, que es lo que necesitamos. <br><br>  Tambi√©n minimizamos la cantidad de magia utilizada: sabemos exactamente cu√°l es el costo de moverse desde el nodo inicial a cada nodo (esto es <code>node.cost</code> ), y usamos magia solo para predecir el costo de mover del nodo al nodo final. <br><br><h2>  No es m√°gico, pero es bastante impresionante A * </h2><br>  Desafortunadamente, las fichas m√°gicas son nuevas y necesitamos soporte de equipos obsoletos.  La mayor parte del c√≥digo nos conviene, con la excepci√≥n de esta l√≠nea: <br><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># Throws MuggleProcessorException cost_node_to_goal = magic(node, "   ")</span></span></code> </pre> <br>  Es decir, no podemos usar magia para averiguar el costo de un camino inexplorado.  Pues bien, hagamos una predicci√≥n.  Seremos optimistas y supondremos que no hay nada entre los nodos actuales y finales, y simplemente podemos movernos directamente: <br><br><pre> <code class="python hljs">cost_node_to_goal = distance(node, goal_node)</code> </pre> <br>  Tenga en cuenta que la <em>ruta m√°s corta</em> y la <em>distancia m√≠nima son</em> diferentes: la distancia m√≠nima implica que no hay absolutamente ning√∫n obst√°culo entre los nodos actuales y finales. <br><br>  Esta estimaci√≥n es bastante simple de obtener.  En nuestros ejemplos de cuadr√≠cula, esta es la <em>distancia de bloques de ciudades</em> entre dos nodos (es decir, <code>abs(Ax - Bx) + abs(Ay - By)</code> ).  Si pudi√©ramos movernos en diagonal, entonces el valor ser√≠a igual a <code>sqrt( (Ax - Bx)^2 + (Ay - By)^2 )</code> , y as√≠ sucesivamente.  Lo m√°s importante, nunca obtenemos una estimaci√≥n de valor <em>demasiado</em> alta. <br><br>  As√≠ que aqu√≠ hay una versi√≥n no <code>choose_node</code> de <code>choose_node</code> : <br><br><pre> <code class="python hljs">function choose_node (reachable): min_cost = infinity best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: cost_start_to_node = node.cost cost_node_to_goal = estimate_distance(node, goal_node) total_cost = cost_start_to_node + cost_node_to_goal <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> min_cost &gt; total_cost: min_cost = total_cost best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br>  Una funci√≥n que estima la distancia desde el nodo actual hasta el final se llama <em>heur√≠stica</em> , y este algoritmo de b√∫squeda, damas y caballeros, se llama ... <strong>A *</strong> . <br><br><h2>  Demo interactiva </h2><br>  Mientras se recupera de la conmoci√≥n causada por la comprensi√≥n de que el misterioso <strong>A *</strong> es realmente <em>tan simple</em> , puede ver la demostraci√≥n (o ejecutarla en el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culo original</a> ).  Notar√° que, a diferencia del ejemplo anterior, la b√∫squeda pasa muy poco tiempo movi√©ndose en la direcci√≥n incorrecta. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pb/iz/nb/pbiznbkynw8pju8unbz6xyqnqqq.gif"></div><br><h2>  Conclusi√≥n </h2><br>  Finalmente, llegamos al algoritmo <strong>A *</strong> , que no es m√°s que el algoritmo de b√∫squeda general descrito en la primera parte del art√≠culo con algunas mejoras descritas en la segunda parte y usando la funci√≥n <code>choose_node</code> , que selecciona el nodo que, en nuestra estimaci√≥n, nos acerca m√°s a nodo final  Eso es todo <br><br>  Aqu√≠ hay un pseudoc√≥digo completo del m√©todo principal para su referencia: <br><br><pre> <code class="python hljs">function find_path (start_node, end_node): reachable = [start_node] explored = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> reachable <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> empty: <span class="hljs-comment"><span class="hljs-comment"># Choose some node we know how to reach. node = choose_node(reachable) # If we just got to the goal node, build and return the path. if node == goal_node: return build_path(goal_node) # Don't repeat ourselves. reachable.remove(node) explored.add(node) # Where can we get from here that we haven't explored before? new_reachable = get_adjacent_nodes(node) - explored for adjacent in new_reachable: # First time we see this node? if adjacent not in reachable: reachable.add(adjacent) # If this is a new path, or a shorter path than what we have, keep it. if node.cost + 1 &lt; adjacent.cost: adjacent.previous = node adjacent.cost = node.cost + 1 # If we get here, no path was found :( return None</span></span></code> </pre> <br>  M√©todo <code>build_path</code> : <br><br><pre> <code class="python hljs">function build_path (to_node): path = [] <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> to_node != <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: path.add(to_node) to_node = to_node.previous <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> path</code> </pre> <br>  Y aqu√≠ est√° el m√©todo <code>choose_node</code> , que lo convierte en <strong>A *</strong> : <br><br><pre> <code class="python hljs">function choose_node (reachable): min_cost = infinity best_node = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> node <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> reachable: cost_start_to_node = node.cost cost_node_to_goal = estimate_distance(node, goal_node) total_cost = cost_start_to_node + cost_node_to_goal <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> min_cost &gt; total_cost: min_cost = total_cost best_node = node <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> best_node</code> </pre> <br>  Eso es todo <br><br>  Pero, ¬øpor qu√© necesitamos la <strong>parte 4</strong> ? <br><br>  Ahora que comprende c√≥mo funciona <strong>A *</strong> , quiero hablar sobre algunas √°reas sorprendentes de su aplicaci√≥n, que est√°n lejos de limitarse a encontrar rutas en una cuadr√≠cula de celdas. <br><br><h2>  Parte 4. A * en la pr√°ctica </h2><br>  Las primeras tres partes del art√≠culo comienzan con los fundamentos mismos de los algoritmos de b√∫squeda de ruta y terminan con una descripci√≥n clara del algoritmo <strong>A *</strong> .  Todo esto es genial en teor√≠a, pero entender c√≥mo esto es aplicable en la pr√°ctica es un tema completamente diferente. <br><br>  Por ejemplo, ¬øqu√© sucede si nuestro mundo no es una red? <br><br>  ¬øQu√© pasa si un personaje no puede rotar instant√°neamente 90 grados? <br><br>  ¬øC√≥mo construir un gr√°fico si el mundo es infinito? <br><br>  ¬øQu√© pasa si no nos importa la longitud del camino, pero dependemos de la energ√≠a solar y necesitamos estar lo m√°s bajo posible de la luz solar? <br><br>  ¬øC√≥mo encontrar la ruta m√°s corta a cualquiera de los dos nodos finales? <br><br><h2>  Funci√≥n de costo </h2><br>  En los primeros ejemplos, buscamos la ruta m√°s corta entre los nodos de inicio y fin.  Sin embargo, en lugar de almacenar longitudes de ruta parciales en la <code>length</code> variable, lo llamamos <code>cost</code> .  Por qu√© <br><br>  Podemos hacer que <strong>A *</strong> busque no solo el <em>m√°s corto</em> , sino tambi√©n el <em>mejor</em> camino, y la definici√≥n de "mejor" se puede elegir en funci√≥n de nuestros objetivos.  Cuando necesitamos el camino m√°s corto, el costo es la longitud del camino, pero si queremos minimizar, por ejemplo, el consumo de combustible, entonces debemos usarlo como costo.  Si queremos maximizar el "tiempo que pasa bajo el sol", entonces el costo es el tiempo que pasa sin el sol.  Y as√≠ sucesivamente. <br><br>  En el caso general, esto significa que los costos correspondientes est√°n asociados con cada borde del gr√°fico.  En los ejemplos mostrados anteriormente, el valor se estableci√≥ impl√≠citamente y siempre se consider√≥ igual a <code>1</code> , porque contamos los pasos en el camino.  Pero podemos cambiar el costo de la costilla de acuerdo con lo que queremos minimizar. <br><br><h2>  Funci√≥n de criterio </h2><br>  Digamos que nuestro objeto es un autom√≥vil, y √©l necesita llegar a la estaci√≥n de servicio.  Cualquier reabastecimiento de combustible nos vendr√° bien.  Toma la ruta m√°s corta hasta la estaci√≥n de servicio m√°s cercana. <br><br>  El enfoque ingenuo ser√° calcular el camino m√°s corto para cada reabastecimiento de combustible y seleccionar el m√°s corto.  Esto funcionar√°, pero ser√° un proceso bastante costoso. <br><br>  ¬øQu√© pasar√≠a si pudi√©ramos reemplazar un <code>goal_node</code> con un m√©todo que, en un nodo dado, puede decir si es finito o no?  Gracias a esto, podemos buscar varios objetivos al mismo tiempo.  Tambi√©n necesitamos modificar la heur√≠stica para que devuelva el costo m√≠nimo estimado de todos los nodos finales posibles. <br><br>  Dependiendo de los detalles de la situaci√≥n, es posible que no podamos lograr el objetivo a la <em>perfecci√≥n</em> , o costar√° demasiado (si enviamos al personaje a trav√©s de medio mapa enorme, ¬øes importante la diferencia de una pulgada?), Por lo tanto, el m√©todo <code>is_goal_node</code> puede volver <code>true</code> cuando Estamos "lo suficientemente cerca". <br><br><h2>  No se requiere certeza total. </h2><br>  Representar al mundo como una grilla discreta puede no ser suficiente para muchos juegos.  Tomemos, por ejemplo, un juego de disparos o de carreras en primera persona.  El mundo es discreto, pero no se puede representar como una cuadr√≠cula. <br><br>  Pero hay un problema m√°s serio: ¬øqu√© pasa si el mundo es interminable?  En este caso, incluso si podemos presentarlo en forma de cuadr√≠cula, simplemente no podremos construir un gr√°fico correspondiente a la cuadr√≠cula, porque debe ser infinito. <br><br>  Sin embargo, no todo est√° perdido.  Por supuesto, para el algoritmo de b√∫squeda de gr√°ficos, definitivamente necesitamos un gr√°fico.  ¬°Pero nadie dijo que el gr√°fico deber√≠a ser <em>completo</em> ! <br><br>  Si observa detenidamente el algoritmo, notar√° que no estamos haciendo nada con el gr√°fico en su conjunto;  Examinamos el gr√°fico localmente, obteniendo nodos a los que podemos llegar desde el nodo en cuesti√≥n.  Como se puede ver en la demostraci√≥n <strong>A *</strong> , algunos nodos del gr√°fico no se investigan en absoluto. <br><br>  Entonces, ¬øpor qu√© no construimos el gr√°fico en el proceso de investigaci√≥n? <br><br>  Hacemos que la posici√≥n actual del personaje sea el nodo inicial.  Al llamar a <code>get_adjacent_nodes</code> puede determinar las posibles formas en que el personaje puede moverse desde un nodo dado y crear nodos vecinos sobre la marcha. <br><br><h2>  M√°s all√° de las tres dimensiones </h2><br>  Incluso si su mundo es <i>realmente</i> una malla 2D, hay otros aspectos a considerar.  Por ejemplo, ¬øqu√© pasa si un personaje no puede rotar instant√°neamente 90 o 180 grados, como suele ser el caso? <br><br>  <em>El estado</em> representado por cada nodo de b√∫squeda no tiene que ser solo una <em>posici√≥n</em> ;  por el contrario, puede incluir un conjunto de valores arbitrariamente complejo.  Por ejemplo, si los giros de 90 grados toman tanto tiempo como la transici√≥n de una celda a otra, entonces el estado del personaje se puede establecer como <code>[position, heading]</code> .  Cada nodo puede representar no solo la posici√≥n del personaje, sino tambi√©n la direcci√≥n de su mirada;  y los nuevos bordes del gr√°fico (expl√≠cito o indirecto) reflejan esto. <br><br>  Si vuelve a la cuadr√≠cula original de 5x5, la posici√≥n de b√∫squeda inicial ahora puede ser <code>[A, East]</code> .  Los nodos vecinos ahora son <code>[B, East]</code> y <code>[A, South]</code> : si queremos llegar a <strong>F</strong> , primero debemos ajustar la direcci√≥n para que la ruta tome la forma <code>[A, East]</code> , <code>[A, South]</code> , <code>[F, South]</code> . <br><br>  Tirador en primera persona?  Al menos cuatro dimensiones: <code>[X, Y, Z, Heading]</code> .  Quiz√°s incluso <code>[X, Y, Z, Heading, Health, Ammo]</code> . <br><br>  Tenga en cuenta que cuanto m√°s complejo es el estado, m√°s compleja debe ser la funci√≥n heur√≠stica.  <strong>A * en s√≠ mismo</strong> es simple;  El arte a menudo surge de una buena heur√≠stica. <br><br><h2>  Conclusi√≥n </h2><br>  El prop√≥sito de este art√≠culo es disipar el mito de una vez por todas que <strong>A *</strong> es un algoritmo m√≠stico que no se puede descifrar.  Por el contrario, demostr√© que no hay nada misterioso en √©l y, de hecho, puede deducirse simplemente comenzando desde cero. <br><br><h3>  Lectura adicional </h3><br>  Amit Patel tiene una excelente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Introducci√≥n al algoritmo A *"</a> [ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">traducci√≥n</a> en Habr√©] (¬°y sus otros art√≠culos sobre diversos temas tambi√©n son excelentes!). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/444828/">https://habr.com/ru/post/444828/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444816/index.html">Carpinter√≠a de bricolaje: expectativas y realidad</a></li>
<li><a href="../444818/index.html">Citymobil: una gu√≠a para nuevas empresas para aumentar la estabilidad en medio del crecimiento. Parte 1</a></li>
<li><a href="../444820/index.html">Mockdown: la forma m√°s r√°pida de crear wireframes</a></li>
<li><a href="../444822/index.html">JDK 9 / JEP 280: la concatenaci√≥n de cadenas nunca volver√° a ser la misma</a></li>
<li><a href="../444824/index.html">Lo que los robots de mensajer√≠a Amazon y FedEx miran primero</a></li>
<li><a href="../444830/index.html">Firma electr√≥nica en la nube en Rusia y el mundo</a></li>
<li><a href="../444832/index.html">"Sin implementaciones el viernes" y tres reglas de desarrollo m√°s t√°citas</a></li>
<li><a href="../444836/index.html">No hay necesidad de pensar en la memoria, dijeron ... Taller CLRium # 5: Recolector de basura</a></li>
<li><a href="../444838/index.html">Meetup de OWASP Rusia</a></li>
<li><a href="../444840/index.html">3. Punto de verificaci√≥n Comenzando R80.20. Preparaci√≥n del dise√±o</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>