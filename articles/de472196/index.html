<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï§ üì® ü§µüèæ Selbst gemachter "Zucker" f√ºr ein Android-Projekt oder "Wie man es nicht macht" üë©‚Äçüë©‚Äçüë¶‚Äçüë¶ ü¶ê ü§πüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel ist ein Satz kleiner W√ºrfelzucker f√ºr ein Android-Projekt, zu dem ich zu gegebener Zeit gekommen bin und das sich als n√ºtzlich erwiesen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Selbst gemachter "Zucker" f√ºr ein Android-Projekt oder "Wie man es nicht macht"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472196/">  Dieser Artikel ist ein Satz kleiner W√ºrfelzucker f√ºr ein Android-Projekt, zu dem ich zu gegebener Zeit gekommen bin und das sich als n√ºtzlich erwiesen hat.  Einige Dinge sind m√∂glicherweise keine idealen L√∂sungen, aber sie k√∂nnen f√ºr Sie genauso n√ºtzlich sein, wie sie mir einmal n√ºtzlich waren. <br><a name="habracut"></a><br><h3>  Anwendung und Toast </h3><br>  Das erste, was immer n√ºtzlich sein kann und manchmal zu jedem Zeitpunkt im Programm ben√∂tigt wird, ist ein Link zur Anwendung.  Dies wird durch eine einfache Klasse gel√∂st, deren Link in AndroidManifest registriert ist. <br><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { APP = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> APP: App } }</code> </pre> <br>  Dank dessen haben Sie immer Zugriff auf den Kontext der gesamten Anwendung und k√∂nnen von √ºberall aus Leitungen / Ressourcen abrufen.  Und das ist zumindest f√ºr folgendes Zuckerkorn notwendig: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toast</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(messageId: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { Toast.makeText(App.APP, messageId, Toast.LENGTH_LONG).show() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toast</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { Toast.makeText(App.APP, message, Toast.LENGTH_LONG).show() }</code> </pre> <br>  Eine Kleinigkeit, aber dank Kotlin und der Tatsache, dass wir Zugriff auf den Kontext haben, k√∂nnen Sie Toast jetzt von √ºberall in der Anwendung kurz und pr√§zise aufrufen.  Damit die Methode √ºberall verf√ºgbar ist, kann sie in einer Datei markiert werden, ohne die Stammklasse anzugeben. <br><br><h3>  Wer ist auf dem Bildschirm? </h3><br>  Programme mit einer Aktivit√§t werden immer beliebter.  F√ºr unsere Architektur wurde jedoch beschlossen, mehrere Aktivit√§ten zu verwenden.  Zumindest um die Berechtigungslogik und den Hauptteil der Anwendung zu trennen.  Im Laufe der Zeit musste verstanden werden, ob der Bildschirm sichtbar ist und um welchen Teil der Anwendung es sich handelt.  In Zukunft war es auch erforderlich, Zeichenfolgen im Anwendungsgebietsschema abzurufen.  Aber das Wichtigste zuerst.  Damit sich unser APP-Wert nicht alleine langweilt, wird das Unternehmen ihn dazu bringen: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> screenActivity: AppCompatActivity? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> onScreen: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> = <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br>  Und dann erstellen wir unsere Basisklasse, die von AppCompatActivity geerbt wurde: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppCompatActivity</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onStart() App.onScreen = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onStop() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (App.screenActivity == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { App.onScreen = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isFinishing()) App.screenActivity = <span class="hljs-literal"><span class="hljs-literal">null</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onDestroy() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (App.screenActivity == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) App.screenActivity = <span class="hljs-literal"><span class="hljs-literal">null</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { App.screenActivity = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onRestart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onRestart() App.screenActivity = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> } }</code> </pre> <br>  Ja, f√ºr neue Anleitungen k√∂nnen Sie Lifecycle with Activity an den erforderlichen Stellen abonnieren.  Aber wir haben was wir haben. <br><br><h3>  Lokalisierte Zeichenfolgen </h3><br>  Es gibt Funktionen von zweifelhaftem Nutzen, aber TK ist TK.  Dieser Funktionalit√§t w√ºrde ich die Wahl der Sprache in der Anwendung anstelle der Systemsprache zuschreiben.  Lange Zeit gibt es einen Code, mit dem Sie die Sprache programmgesteuert ersetzen k√∂nnen.  Aber wir waren mit einem Fehler konfrontiert, der sich wahrscheinlich nur bei uns wiederholt.  Der Kern des Fehlers besteht darin, dass, wenn Sie die Zeile durch den Anwendungskontext und nicht durch den Aktivit√§tskontext f√ºhren, die Zeile an die Systemgebietsschemata zur√ºckgegeben wird.  Und es ist nicht immer bequem, den Kontext einer Aktivit√§t zu werfen.  Die folgenden Methoden kamen zur Rettung: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Resources = screenActivity?.resources ?: APP.resources <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocalizedString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stringId: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: String = getRes().getString(stringId) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocalizedString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stringId: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">vararg</span></span></span></span><span class="hljs-function"><span class="hljs-params"> formatArgs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>: String = getRes().getString(stringId, *formatArgs)</code> </pre> <br>  Und jetzt k√∂nnen wir von √ºberall in der Anwendung die Zeichenfolge im richtigen Gebietsschema abrufen. <br><br><h3>  SharedPreferences </h3><br>  Wie bei allen Anwendungen m√ºssen unsere einige Einstellungen in SharedPreferences speichern.  Und um das Leben zu vereinfachen, wurde eine Klasse erfunden, die ein bisschen Logik in sich verbirgt.  Zu Beginn wurde ein neuer Freund f√ºr die APP-Variable hinzugef√ºgt: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> settings: SharedPreferences</code> </pre><br>  Es wird beim Start der Anwendung initialisiert und steht uns immer zur Verf√ºgung. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PreferenceString</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> key: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> def: String = <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> store: SharedPreferences = App.settings, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> listener: ModifyListener? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value: String <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() { listener?.customGet() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> store.getString(key, def) ?: def } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(value) { store.edit().putString(key, value).apply() listener?.customSet() } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModifyListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">customGet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">customSet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {} }</code> </pre><br>  Nat√ºrlich m√ºssen Sie f√ºr jeden Variablentyp eine solche Klasse generieren, aber Sie k√∂nnen Singleton durch alle erforderlichen Einstellungen ersetzen, zum Beispiel: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> PREF_LANGUAGE = PreferenceString(<span class="hljs-string"><span class="hljs-string">"pref_language"</span></span>, <span class="hljs-string"><span class="hljs-string">"ru"</span></span>)</code> </pre> <br>  Und jetzt k√∂nnen Sie die Einstellungen immer als Feld bezeichnen, und das Laden / Speichern und die Kommunikation √ºber den Listener werden ausgeblendet. <br><br><h3>  Orientierung und Tablette </h3><br>  Mussten Sie beide Orientierungen unterst√ºtzen?  Und wie haben Sie festgestellt, in welcher Ausrichtung Sie sich jetzt befinden?  Wir haben daf√ºr eine bequeme Methode, die wiederum von √ºberall aufgerufen werden kann und sich nicht um den Kontext k√ºmmert: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isLandscape</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getRes().configuration.orientation == Configuration.ORIENTATION_LANDSCAPE }</code> </pre> <br>  Wenn Sie values ‚Äã‚Äã/ dimen.xml eingeben: <br><br><pre> <code class="kotlin hljs">&lt;bool name=<span class="hljs-string"><span class="hljs-string">"isTablet"</span></span>&gt;<span class="hljs-literal"><span class="hljs-literal">false</span></span>&lt;/bool&gt;</code> </pre> <br>  Und in values-large / dimen.xml: <br><br><pre> <code class="kotlin hljs">&lt;bool name=<span class="hljs-string"><span class="hljs-string">"isTablet"</span></span>&gt;<span class="hljs-literal"><span class="hljs-literal">true</span></span>&lt;/bool&gt;</code> </pre> <br>  Dann k√∂nnen Sie auch eine Methode erstellen: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isTablet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getRes().getBoolean(R.bool.isTablet) }</code> </pre><br><h3>  Datumsformat </h3><br>  Multithreading.  Manchmal ist es ein gruseliges Wort.  Einmal haben wir einen sehr seltsamen Fehler entdeckt, als wir im Hintergrund Datumszeilen gebildet haben.  Es stellte sich heraus, dass SimpleDateFormat nicht threadsicher ist.  Daher wurde folgendes geboren: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThreadSafeDateFormat</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pattern: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isUTC: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> = <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> locale: Locale = DEFAULT_LOCALE){ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dateFormatThreadLocal = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : ThreadLocal&lt;SimpleDateFormat&gt;(){ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: SimpleDateFormat? { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SimpleDateFormat(pattern, locale) } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> formatter: SimpleDateFormat <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dateFormat = dateFormatThreadLocal.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() ?: SimpleDateFormat(pattern, locale) dateFormat.timeZone = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isUTC) TimeZone.getTimeZone(<span class="hljs-string"><span class="hljs-string">"UTC"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> timeZone <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dateFormat } }</code> </pre><br>  Und ein Anwendungsbeispiel (ja, dies wird wieder im Singleton verwendet): <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> utcDateSendSafeFormat = ThreadSafeDateFormat(<span class="hljs-string"><span class="hljs-string">"yyyy-MM-dd"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> utcDateSendFormat: SimpleDateFormat <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = utcDateSendSafeFormat.formatter</code> </pre><br>  F√ºr die gesamte Anwendung hat sich nichts ge√§ndert, und das Problem mit den Threads wurde behoben. <br><br><h3>  Textwatcher </h3><br>  Und Sie haben sich nie darum gek√ºmmert, dass Sie TextWatcher verwenden und 3 (!) Methoden implementieren m√ºssen, wenn Sie den in EditText eingegebenen Text erfassen m√∂chten.  Nicht kritisch, aber nicht bequem.  Und alles wird von der Klasse entschieden: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TextWatcherObject</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TextWatcher{ override fun afterTextChanged</span></span></span></span>(p0: Editable?) {} <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">beforeTextChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p0: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CharSequence</span></span></span></span><span class="hljs-function"><span class="hljs-params">?, p1: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p2: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p3: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onTextChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p0: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CharSequence</span></span></span></span><span class="hljs-function"><span class="hljs-params">?, p1: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p2: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p3: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> {} }</code> </pre><br><h3>  Tastatur </h3><br>  Was immer gebraucht wird.  Sie m√ºssen die Tastatur sofort anzeigen und dann irgendwann ausblenden.  Und dann werden die folgenden zwei Methoden ben√∂tigt.  Im zweiten Fall m√ºssen Sie die Stammansicht √ºbergeben. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showKeyboard</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EditText</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ view.requestFocus(); (App.APP.getSystemService(Context.INPUT_METHOD_SERVICE) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> InputMethodManager?) ?.toggleSoftInput(InputMethodManager.SHOW_FORCED, InputMethodManager.HIDE_IMPLICIT_ONLY) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hideKeyboardFrom</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { (App.APP.getSystemService(Activity.INPUT_METHOD_SERVICE) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> InputMethodManager?) ?.hideSoftInputFromWindow(view.windowToken, <span class="hljs-number"><span class="hljs-number">0</span></span>) }</code> </pre> <br>  Und vielleicht ist jemand n√ºtzlich, eine Funktion zum Kopieren einer beliebigen Zeile in eine Zwischenablage mit Toast: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> String.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toClipboard</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(toast: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> clip = ClipData.newPlainText(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) (App.APP.getSystemService(Context.CLIPBOARD_SERVICE) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ClipboardManager?)?.setPrimaryClip(clip) Toast(toast) }</code> </pre> <br><h3>  RecyclerView und TableLayout </h3><br>  Und am Ende dieses kleinen Artikels m√∂chte ich mitteilen, was ich k√ºrzlich l√∂sen musste.  Vielleicht wird jemand n√ºtzlich sein. <br><br>  Die Anfangsdaten sind wie folgt: <br><br><ol><li>  1k + anzuzeigende Daten. </li><li>  Jede "Zelle" besteht aus ungef√§hr 10 Feldern. </li><li>  Es ist notwendig, Swipe, Click, DoubleClick, LongClick zu fangen. </li><li>  und ...  Die Daten werden alle 300 bis 500 Millisekunden aktualisiert. </li></ol><br>  Wenn Sie den ersten Punkt vergessen.  Dann ist TableLayout die am besten funktionierende L√∂sung.  Warum nicht RecyclerView?  Und wegen 3 und 4 Punkten.  Das Blatt enth√§lt Optimierungen, die die Ansicht wiederverwenden, jedoch nicht immer.  Zum Zeitpunkt der Erstellung einer neuen Ansicht gibt es keine Touch-Handler.  Und okay, wenn es nur den Wisch betrifft, aber von Zeit zu Zeit wird das Problem mit dem √ºblichen Tippen reproduziert.  Selbst das Aktualisieren der Daten direkt in der Ansicht hilft nicht und nicht durch Benachrichtigen.  Daher wurde beschlossen, TableLayout zu verwenden.  Und alles war in Ordnung, bis die Daten nicht mehr als 100 waren. Und dann - willkommen in der Welt der Einfrierungen. <br><br>  Ich habe zwei M√∂glichkeiten gesehen, um zu l√∂sen - oder TableLayout beizubringen, Zellen wiederzuverwenden und beim Scrollen zu zaubern.  Oder versuchen Sie, Freunde RecyclerView und h√§ufige Updates zu finden.  Und ich ging den zweiten Weg.  Da Ber√ºhrungen und Wischvorg√§nge (haupts√§chlich aufgrund von Wischbewegungen) von einer selbstgeschriebenen Klasse basierend auf View.OnTouchListener verarbeitet wurden, erwies es sich als effektive L√∂sung, die Ber√ºhrungsverarbeitung durch √úberschreiben der dispatchTouchEvent-Methode auf die RecyclerView-Ebene zu verschieben. <br><br>  Der Algorithmus ist einfach: <br><br><ul><li>  Ber√ºhrung </li><li>  Bestimmen Sie mit findChildViewUnder (x, y), welches Kind die Ber√ºhrung fliegt. </li><li>  Rufen Sie die Position des Elements im LayoutManager ab </li><li>  Wenn es sich um MotionEvent.ACTION_MOVE handelt, √ºberpr√ºfen wir mit derselben Position, an der wir arbeiten wie zuvor oder nicht </li><li>  F√ºhren Sie die eingebettete Logik zum Ber√ºhren aus </li></ul><br>  Vielleicht wird es in Zukunft noch Probleme mit dieser Methode geben, aber im Moment funktioniert alles und das ist gut so. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472196/">https://habr.com/ru/post/de472196/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472182/index.html">Ank√ºndigung von .NET Core 3.1 Vorschau 1</a></li>
<li><a href="../de472184/index.html">Remote SSH: Tipps und Tricks</a></li>
<li><a href="../de472186/index.html">Open-Closed-Prinzip</a></li>
<li><a href="../de472188/index.html">Was Sie √ºber die √úberpr√ºfung des App Store-Checks wissen m√ºssen (App Store-Quittung)</a></li>
<li><a href="../de472190/index.html">F√ºhren Sie PHP-Skripte √ºber php-fpm ohne Webserver aus. Oder Ihr FastCGI-Client (unter der Haube)</a></li>
<li><a href="../de472198/index.html">Lokalisierung von Push-Nachrichten in mobilen Anwendungen</a></li>
<li><a href="../de472200/index.html">Modernisierung des Informatikunterrichts an einer russischen Schule auf einer Himbeere: billig und fr√∂hlich</a></li>
<li><a href="../de472202/index.html">Windows 10 + Python = VS Code + WSL</a></li>
<li><a href="../de472204/index.html">Einfache Experimente mit dem Mikrocontroller STM32F103 (Blue Tablet)</a></li>
<li><a href="../de472208/index.html">OLED-Bildschirme von Android-Smartphones und wie man damit umgeht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>