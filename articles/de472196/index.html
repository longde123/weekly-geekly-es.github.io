<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕤 📨 🤵🏾 Selbst gemachter "Zucker" für ein Android-Projekt oder "Wie man es nicht macht" 👩‍👩‍👦‍👦 🦐 🤹🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel ist ein Satz kleiner Würfelzucker für ein Android-Projekt, zu dem ich zu gegebener Zeit gekommen bin und das sich als nützlich erwiesen...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Selbst gemachter "Zucker" für ein Android-Projekt oder "Wie man es nicht macht"</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472196/">  Dieser Artikel ist ein Satz kleiner Würfelzucker für ein Android-Projekt, zu dem ich zu gegebener Zeit gekommen bin und das sich als nützlich erwiesen hat.  Einige Dinge sind möglicherweise keine idealen Lösungen, aber sie können für Sie genauso nützlich sein, wie sie mir einmal nützlich waren. <br><a name="habracut"></a><br><h3>  Anwendung und Toast </h3><br>  Das erste, was immer nützlich sein kann und manchmal zu jedem Zeitpunkt im Programm benötigt wird, ist ein Link zur Anwendung.  Dies wird durch eine einfache Klasse gelöst, deren Link in AndroidManifest registriert ist. <br><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Application</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">init</span></span> { APP = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> APP: App } }</code> </pre> <br>  Dank dessen haben Sie immer Zugriff auf den Kontext der gesamten Anwendung und können von überall aus Leitungen / Ressourcen abrufen.  Und das ist zumindest für folgendes Zuckerkorn notwendig: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toast</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(messageId: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { Toast.makeText(App.APP, messageId, Toast.LENGTH_LONG).show() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Toast</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(message: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { Toast.makeText(App.APP, message, Toast.LENGTH_LONG).show() }</code> </pre> <br>  Eine Kleinigkeit, aber dank Kotlin und der Tatsache, dass wir Zugriff auf den Kontext haben, können Sie Toast jetzt von überall in der Anwendung kurz und präzise aufrufen.  Damit die Methode überall verfügbar ist, kann sie in einer Datei markiert werden, ohne die Stammklasse anzugeben. <br><br><h3>  Wer ist auf dem Bildschirm? </h3><br>  Programme mit einer Aktivität werden immer beliebter.  Für unsere Architektur wurde jedoch beschlossen, mehrere Aktivitäten zu verwenden.  Zumindest um die Berechtigungslogik und den Hauptteil der Anwendung zu trennen.  Im Laufe der Zeit musste verstanden werden, ob der Bildschirm sichtbar ist und um welchen Teil der Anwendung es sich handelt.  In Zukunft war es auch erforderlich, Zeichenfolgen im Anwendungsgebietsschema abzurufen.  Aber das Wichtigste zuerst.  Damit sich unser APP-Wert nicht alleine langweilt, wird das Unternehmen ihn dazu bringen: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> screenActivity: AppCompatActivity? = <span class="hljs-literal"><span class="hljs-literal">null</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> onScreen: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> = <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br>  Und dann erstellen wir unsere Basisklasse, die von AppCompatActivity geerbt wurde: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">AppCompatActivity</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onStart() App.onScreen = <span class="hljs-literal"><span class="hljs-literal">true</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onStop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onStop() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (App.screenActivity == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) { App.onScreen = <span class="hljs-literal"><span class="hljs-literal">false</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isFinishing()) App.screenActivity = <span class="hljs-literal"><span class="hljs-literal">null</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onDestroy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onDestroy() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (App.screenActivity == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) App.screenActivity = <span class="hljs-literal"><span class="hljs-literal">null</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { App.screenActivity = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onRestart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onRestart() App.screenActivity = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> } }</code> </pre> <br>  Ja, für neue Anleitungen können Sie Lifecycle with Activity an den erforderlichen Stellen abonnieren.  Aber wir haben was wir haben. <br><br><h3>  Lokalisierte Zeichenfolgen </h3><br>  Es gibt Funktionen von zweifelhaftem Nutzen, aber TK ist TK.  Dieser Funktionalität würde ich die Wahl der Sprache in der Anwendung anstelle der Systemsprache zuschreiben.  Lange Zeit gibt es einen Code, mit dem Sie die Sprache programmgesteuert ersetzen können.  Aber wir waren mit einem Fehler konfrontiert, der sich wahrscheinlich nur bei uns wiederholt.  Der Kern des Fehlers besteht darin, dass, wenn Sie die Zeile durch den Anwendungskontext und nicht durch den Aktivitätskontext führen, die Zeile an die Systemgebietsschemata zurückgegeben wird.  Und es ist nicht immer bequem, den Kontext einer Aktivität zu werfen.  Die folgenden Methoden kamen zur Rettung: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getRes</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: Resources = screenActivity?.resources ?: APP.resources <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocalizedString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stringId: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: String = getRes().getString(stringId) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getLocalizedString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(stringId: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">vararg</span></span></span></span><span class="hljs-function"><span class="hljs-params"> formatArgs: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span>: String = getRes().getString(stringId, *formatArgs)</code> </pre> <br>  Und jetzt können wir von überall in der Anwendung die Zeichenfolge im richtigen Gebietsschema abrufen. <br><br><h3>  SharedPreferences </h3><br>  Wie bei allen Anwendungen müssen unsere einige Einstellungen in SharedPreferences speichern.  Und um das Leben zu vereinfachen, wurde eine Klasse erfunden, die ein bisschen Logik in sich verbirgt.  Zu Beginn wurde ein neuer Freund für die APP-Variable hinzugefügt: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">lateinit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> settings: SharedPreferences</code> </pre><br>  Es wird beim Start der Anwendung initialisiert und steht uns immer zur Verfügung. <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PreferenceString</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> key: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> def: String = <span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> store: SharedPreferences = App.settings, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> listener: ModifyListener? = <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> value: String <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() { listener?.customGet() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> store.getString(key, def) ?: def } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>(value) { store.edit().putString(key, value).apply() listener?.customSet() } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModifyListener</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">customGet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">customSet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> {} }</code> </pre><br>  Natürlich müssen Sie für jeden Variablentyp eine solche Klasse generieren, aber Sie können Singleton durch alle erforderlichen Einstellungen ersetzen, zum Beispiel: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> PREF_LANGUAGE = PreferenceString(<span class="hljs-string"><span class="hljs-string">"pref_language"</span></span>, <span class="hljs-string"><span class="hljs-string">"ru"</span></span>)</code> </pre> <br>  Und jetzt können Sie die Einstellungen immer als Feld bezeichnen, und das Laden / Speichern und die Kommunikation über den Listener werden ausgeblendet. <br><br><h3>  Orientierung und Tablette </h3><br>  Mussten Sie beide Orientierungen unterstützen?  Und wie haben Sie festgestellt, in welcher Ausrichtung Sie sich jetzt befinden?  Wir haben dafür eine bequeme Methode, die wiederum von überall aufgerufen werden kann und sich nicht um den Kontext kümmert: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isLandscape</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getRes().configuration.orientation == Configuration.ORIENTATION_LANDSCAPE }</code> </pre> <br>  Wenn Sie values ​​/ dimen.xml eingeben: <br><br><pre> <code class="kotlin hljs">&lt;bool name=<span class="hljs-string"><span class="hljs-string">"isTablet"</span></span>&gt;<span class="hljs-literal"><span class="hljs-literal">false</span></span>&lt;/bool&gt;</code> </pre> <br>  Und in values-large / dimen.xml: <br><br><pre> <code class="kotlin hljs">&lt;bool name=<span class="hljs-string"><span class="hljs-string">"isTablet"</span></span>&gt;<span class="hljs-literal"><span class="hljs-literal">true</span></span>&lt;/bool&gt;</code> </pre> <br>  Dann können Sie auch eine Methode erstellen: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isTablet</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> getRes().getBoolean(R.bool.isTablet) }</code> </pre><br><h3>  Datumsformat </h3><br>  Multithreading.  Manchmal ist es ein gruseliges Wort.  Einmal haben wir einen sehr seltsamen Fehler entdeckt, als wir im Hintergrund Datumszeilen gebildet haben.  Es stellte sich heraus, dass SimpleDateFormat nicht threadsicher ist.  Daher wurde folgendes geboren: <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThreadSafeDateFormat</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pattern: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isUTC: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span> = <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> locale: Locale = DEFAULT_LOCALE){ <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dateFormatThreadLocal = <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> : ThreadLocal&lt;SimpleDateFormat&gt;(){ <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initialValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>: SimpleDateFormat? { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> SimpleDateFormat(pattern, locale) } } <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> formatter: SimpleDateFormat <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dateFormat = dateFormatThreadLocal.<span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() ?: SimpleDateFormat(pattern, locale) dateFormat.timeZone = <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isUTC) TimeZone.getTimeZone(<span class="hljs-string"><span class="hljs-string">"UTC"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> timeZone <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dateFormat } }</code> </pre><br>  Und ein Anwendungsbeispiel (ja, dies wird wieder im Singleton verwendet): <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> utcDateSendSafeFormat = ThreadSafeDateFormat(<span class="hljs-string"><span class="hljs-string">"yyyy-MM-dd"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> utcDateSendFormat: SimpleDateFormat <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>() = utcDateSendSafeFormat.formatter</code> </pre><br>  Für die gesamte Anwendung hat sich nichts geändert, und das Problem mit den Threads wurde behoben. <br><br><h3>  Textwatcher </h3><br>  Und Sie haben sich nie darum gekümmert, dass Sie TextWatcher verwenden und 3 (!) Methoden implementieren müssen, wenn Sie den in EditText eingegebenen Text erfassen möchten.  Nicht kritisch, aber nicht bequem.  Und alles wird von der Klasse entschieden: <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">open</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TextWatcherObject</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TextWatcher{ override fun afterTextChanged</span></span></span></span>(p0: Editable?) {} <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">beforeTextChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p0: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CharSequence</span></span></span></span><span class="hljs-function"><span class="hljs-params">?, p1: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p2: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p3: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> {} <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onTextChanged</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p0: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CharSequence</span></span></span></span><span class="hljs-function"><span class="hljs-params">?, p1: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p2: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p3: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> {} }</code> </pre><br><h3>  Tastatur </h3><br>  Was immer gebraucht wird.  Sie müssen die Tastatur sofort anzeigen und dann irgendwann ausblenden.  Und dann werden die folgenden zwei Methoden benötigt.  Im zweiten Fall müssen Sie die Stammansicht übergeben. <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showKeyboard</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">EditText</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>{ view.requestFocus(); (App.APP.getSystemService(Context.INPUT_METHOD_SERVICE) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> InputMethodManager?) ?.toggleSoftInput(InputMethodManager.SHOW_FORCED, InputMethodManager.HIDE_IMPLICIT_ONLY) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hideKeyboardFrom</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(view: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">View</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { (App.APP.getSystemService(Activity.INPUT_METHOD_SERVICE) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> InputMethodManager?) ?.hideSoftInputFromWindow(view.windowToken, <span class="hljs-number"><span class="hljs-number">0</span></span>) }</code> </pre> <br>  Und vielleicht ist jemand nützlich, eine Funktion zum Kopieren einer beliebigen Zeile in eine Zwischenablage mit Toast: <br><br><pre> <code class="kotlin hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> String.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toClipboard</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(toast: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> clip = ClipData.newPlainText(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>) (App.APP.getSystemService(Context.CLIPBOARD_SERVICE) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ClipboardManager?)?.setPrimaryClip(clip) Toast(toast) }</code> </pre> <br><h3>  RecyclerView und TableLayout </h3><br>  Und am Ende dieses kleinen Artikels möchte ich mitteilen, was ich kürzlich lösen musste.  Vielleicht wird jemand nützlich sein. <br><br>  Die Anfangsdaten sind wie folgt: <br><br><ol><li>  1k + anzuzeigende Daten. </li><li>  Jede "Zelle" besteht aus ungefähr 10 Feldern. </li><li>  Es ist notwendig, Swipe, Click, DoubleClick, LongClick zu fangen. </li><li>  und ...  Die Daten werden alle 300 bis 500 Millisekunden aktualisiert. </li></ol><br>  Wenn Sie den ersten Punkt vergessen.  Dann ist TableLayout die am besten funktionierende Lösung.  Warum nicht RecyclerView?  Und wegen 3 und 4 Punkten.  Das Blatt enthält Optimierungen, die die Ansicht wiederverwenden, jedoch nicht immer.  Zum Zeitpunkt der Erstellung einer neuen Ansicht gibt es keine Touch-Handler.  Und okay, wenn es nur den Wisch betrifft, aber von Zeit zu Zeit wird das Problem mit dem üblichen Tippen reproduziert.  Selbst das Aktualisieren der Daten direkt in der Ansicht hilft nicht und nicht durch Benachrichtigen.  Daher wurde beschlossen, TableLayout zu verwenden.  Und alles war in Ordnung, bis die Daten nicht mehr als 100 waren. Und dann - willkommen in der Welt der Einfrierungen. <br><br>  Ich habe zwei Möglichkeiten gesehen, um zu lösen - oder TableLayout beizubringen, Zellen wiederzuverwenden und beim Scrollen zu zaubern.  Oder versuchen Sie, Freunde RecyclerView und häufige Updates zu finden.  Und ich ging den zweiten Weg.  Da Berührungen und Wischvorgänge (hauptsächlich aufgrund von Wischbewegungen) von einer selbstgeschriebenen Klasse basierend auf View.OnTouchListener verarbeitet wurden, erwies es sich als effektive Lösung, die Berührungsverarbeitung durch Überschreiben der dispatchTouchEvent-Methode auf die RecyclerView-Ebene zu verschieben. <br><br>  Der Algorithmus ist einfach: <br><br><ul><li>  Berührung </li><li>  Bestimmen Sie mit findChildViewUnder (x, y), welches Kind die Berührung fliegt. </li><li>  Rufen Sie die Position des Elements im LayoutManager ab </li><li>  Wenn es sich um MotionEvent.ACTION_MOVE handelt, überprüfen wir mit derselben Position, an der wir arbeiten wie zuvor oder nicht </li><li>  Führen Sie die eingebettete Logik zum Berühren aus </li></ul><br>  Vielleicht wird es in Zukunft noch Probleme mit dieser Methode geben, aber im Moment funktioniert alles und das ist gut so. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de472196/">https://habr.com/ru/post/de472196/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de472182/index.html">Ankündigung von .NET Core 3.1 Vorschau 1</a></li>
<li><a href="../de472184/index.html">Remote SSH: Tipps und Tricks</a></li>
<li><a href="../de472186/index.html">Open-Closed-Prinzip</a></li>
<li><a href="../de472188/index.html">Was Sie über die Überprüfung des App Store-Checks wissen müssen (App Store-Quittung)</a></li>
<li><a href="../de472190/index.html">Führen Sie PHP-Skripte über php-fpm ohne Webserver aus. Oder Ihr FastCGI-Client (unter der Haube)</a></li>
<li><a href="../de472198/index.html">Lokalisierung von Push-Nachrichten in mobilen Anwendungen</a></li>
<li><a href="../de472200/index.html">Modernisierung des Informatikunterrichts an einer russischen Schule auf einer Himbeere: billig und fröhlich</a></li>
<li><a href="../de472202/index.html">Windows 10 + Python = VS Code + WSL</a></li>
<li><a href="../de472204/index.html">Einfache Experimente mit dem Mikrocontroller STM32F103 (Blue Tablet)</a></li>
<li><a href="../de472208/index.html">OLED-Bildschirme von Android-Smartphones und wie man damit umgeht</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>