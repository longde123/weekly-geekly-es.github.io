<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üò™ üë©üèº‚Äçü§ù‚Äçüë®üèΩ ü§¶üèº Aprendemos promesas basadas en la especificaci√≥n Ecmascript. Conocido ü§úüèø ‚ôíÔ∏è üë®üèΩ‚Äçüíº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola Al estudiar JavaScript (y, en principio, cualquier otra tecnolog√≠a), siempre surgen varias preguntas, la principal de las cuales es: "¬øPor qu√© fu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aprendemos promesas basadas en la especificaci√≥n Ecmascript. Conocido</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/478938/"><img src="https://habrastorage.org/webt/zo/be/at/zobeat0bkvnvgpgaxgkufwtm3li.png" alt="promesa de introducci√≥n"><br><br><p>  Hola  Al estudiar JavaScript (y, en principio, cualquier otra tecnolog√≠a), siempre surgen varias preguntas, la principal de las cuales es: "¬øPor qu√© funciona de esta manera y no de otra manera?" Y es muy importante en este momento no solo encontrar la respuesta a la pregunta, sino tambi√©n la explicaci√≥n recibida incrustar en un solo sistema de conocimiento ya adquirido.  De lo contrario, la informaci√≥n hu√©rfana tendr√° que ser memorizada u olvidada. <br></p><br><p>  Aprender algo juntos ayuda mucho a encontrar respuestas.  Cuando un estudiante / compa√±ero hace una pregunta sobre c√≥mo entender la frase: "... el resultado del anterior" falla "en la pr√≥xima promesa en la cadena ..." involuntariamente piensa ... Esto es algo extra√±o.  Pero ya no se puede decir mejor, ¬ørealmente no est√° claro?  Miras a los ojos limpios, un poco ingenuos, de los compa√±eros y entiendes: necesitas decir algo m√°s.  Es deseable para que ni siquiera tenga que memorizar.  Solo para obtener informaci√≥n nueva que se ajuste org√°nicamente a los pensamientos humanos existentes. <br></p><br><p>  No describir√© lo que probamos, le√≠mos, vimos.  Como resultado, nos interesamos en la especificaci√≥n ECMAScript.  C√≥mo leerlo y entenderlo es una conversaci√≥n separada (tal vez incluso una publicaci√≥n separada).  Pero la forma en que se describen las promesas y su comportamiento all√≠, por primera vez nos dio una comprensi√≥n hol√≠stica y l√≥gicamente coherente de este tema.  Lo que quiero compartir contigo. <br></p><a name="habracut"></a><br><p>  Este art√≠culo es para principiantes.  Las promesas en t√©rminos de la especificaci√≥n ECMAScript se discutir√°n aqu√≠.  S√© que suena extra√±o, pero como es. <br></p><br><h2>  El objeto de la promesa: su filosof√≠a, presentaci√≥n t√©cnica, posibles estados. <br></h2><br><p>  Ya he notado m√°s de una vez que la capacitaci√≥n en programaci√≥n de alta calidad debe constar de 2 partes.  Esta es una comprensi√≥n filos√≥fica de la idea, y solo entonces su implementaci√≥n t√©cnica.  Es decir, la l√≥gica humana habitual, por la cual el alumno se gu√≠a al tomar cualquier decisi√≥n, facilita enormemente la comprensi√≥n de la implementaci√≥n t√©cnica de esta decisi√≥n.  Por lo tanto, comenzamos con lo que es una promesa en la vida y c√≥mo nos relacionamos con ella.  Y luego veremos: c√≥mo se implementar√°n los ejemplos de promesas en el c√≥digo.  Considere las siguientes figuras (Fig. 1, 2, 3). <br></p><br><img src="https://habrastorage.org/webt/np/8l/ux/np8luxrdlenwq4o2lzikaludrlw.png" alt="Estado de promesa"><br>  <i>Figura 1. ([[PromiseState]] - como resultado de una promesa)</i> <br><br><img src="https://habrastorage.org/webt/sj/xi/bq/sjxibq_vroug72q8bkdprh4rxik.png" alt="Resultado de la promesa"><br>  <i>fig 2. ([[PromiseResult]] - como informaci√≥n relacionada con el resultado de una promesa cumplida o incumplida)</i> <br><br><img src="https://habrastorage.org/webt/2e/zj/l_/2ezjl_fhehmml3yhfqjijcnerbw.png" alt="Reacciones prometedoras"><br>  <i>Figura 3. ([[[PromiseFulfillReactions]], [[PromiseRejectReactions]] - como consecuencias que ocurren despu√©s del cumplimiento o incumplimiento de la promesa)</i> <br><br><p>  Vemos que el concepto mismo de promesa se basa en 3 pilares.  1) ¬øSe cumpli√≥ la promesa?  2) ¬øQu√© informaci√≥n adicional podemos extraer despu√©s de cumplir o rechazar una promesa?  3) ¬øCu√°les son las consecuencias si nuestra promesa es positiva o negativa? <br></p><br><p>  T√©cnicamente, una promesa es una entidad ordinaria expresada a trav√©s de un tipo de datos como un objeto.  Esta entidad tiene un nombre / clase Promesa.  Los objetos nacidos de esta clase tienen Promise.prototype en su cadena de prototipos.  Y esta entidad debe estar conectada de alguna manera con toda la "informaci√≥n de la vida" que examinamos anteriormente.  La especificaci√≥n ECMAScript establece esta informaci√≥n en una promesa incluso a un nivel que es m√°s bajo en abstracci√≥n que el propio JavaScript.  Por ejemplo, a nivel de C ++.  En consecuencia, en el objeto de la promesa hay un lugar tanto bajo el estado, como bajo el resultado, y bajo las consecuencias de la promesa.  Eche un vistazo a en qu√© consiste <a href="https://www.ecma-international.org/ecma-262/7.0/">la</a> promesa <a href="https://www.ecma-international.org/ecma-262/7.0/">de ECMAScript</a> (Figura 4). <br></p><br><img src="https://habrastorage.org/webt/bj/m5/lh/bjm5lhtxstjywkkfe6jnjqaqaes.png" alt="Campos de promesa"><br>  <i>Figura 4. (Campos internos del objeto de promesa de acuerdo con la especificaci√≥n ECMAScript)</i> <br><br><p>  ¬øQu√© colores nuevos jug√≥ la frase "promesa no significa casarse" en t√©rminos de un programador?  1) [[PromiseState]].  Alguien no se ha casado.  2) [[PromiseResult]].  Porque no ten√≠a suficiente dinero para la boda.  3) [[PromiseRejectReactions]].  Como resultado, ten√≠a mucho tiempo libre que dedicaba al autodesarrollo 4) [[PromiseFulfillReactions]].  ¬øPor qu√© una persona necesita el plan B cuando ya ha elegido el plan A? <br></p><br><p>  S√≠, hay un quinto campo [[PromiseIsHandled]].  No es muy importante para nosotros las personas, y ya no lo operaremos en el futuro.  En resumen: se almacena una se√±al para el int√©rprete sobre si la promesa fue rechazada por el programador o no.  De lo contrario, el motor JS interpreta el rechazo de promesa en bruto como un error.  Para los impacientes: si el programador no colg√≥ la funci√≥n Promise.prototype.then () como el segundo controlador de funci√≥n de llamada del estado rechazado de la promesa, entonces el estado de promesa "rechazado" del objeto le mostrar√° un error rojo en la consola del desarrollador. <br></p><br><p>  ¬øHa notado que los campos del objeto de promesa est√°n encerrados en "[[" y "]]"?  Esto enfatiza que el programador JS no tiene acceso directo a esta informaci√≥n.  Solo a trav√©s de herramientas / comandos / API especiales, como el comando Promise.prototype.then ().  Si tiene un deseo irresistible de controlar "esta cocina" directamente, bienvenido al club de est√°ndares de especificaci√≥n EcmaScript. <br></p><br><p>  Una breve observaci√≥n al final de este subcap√≠tulo.  Si en la vida en nuestro pa√≠s las promesas pueden cumplirse parcialmente, entonces en EcmaScript, no.  Es decir, si una persona prometi√≥ dar un mill√≥n y dio 950 mil, entonces en la vida, tal vez sea un socio confiable, pero para JavaScript, dicho deudor ser√° incluido en la lista negra a trav√©s de [[PromiseState]] === ‚Äúrechazado‚Äù.  Un objeto Promise cambia su estado sin ambig√ºedades y solo una vez.  C√≥mo se implementa t√©cnicamente esto es un poco m√°s tarde. <br></p><br><h2>  Promesa del dise√±ador, su filosof√≠a.  El ejecutor de la funci√≥n de devoluci√≥n de llamada es como el "ejecutor" de una promesa.  Esquema de interacci√≥n: promesa (constructor) - ejecutor (devoluci√≥n de llamada) - promesa (objeto) </h2><br><p>  Entonces, descubrimos que la promesa es una entidad que t√©cnicamente es un objeto JS con campos internos ocultos especiales, que a su vez proporcionan un relleno filos√≥fico con el significado de la palabra "promesa". <br></p><br><p>  Cuando un principiante crea un objeto de promesa por primera vez, la siguiente imagen lo espera (Fig. 5). <br></p><br><img src="https://habrastorage.org/webt/m1/xg/3u/m1xg3uoxgytd1nd2x7pc_z9i93m.png" alt="incorrecto creando objeto de promesa"><br>  <i>Figura 5. (La primera vez que creamos intuitivamente un objeto de promesa)</i> <br><br><p>  Qu√© sali√≥ mal y por qu√© el error es una pregunta est√°ndar.  Al responderlo, es mejor traer de nuevo algo de analog√≠a a la vida.  Por ejemplo, a pocas personas les gustan las "campanadas vac√≠as" a nuestro alrededor: quienes solo prometen, pero no hacen nada para cumplir sus declaraciones (la pol√≠tica no cuenta).  Somos mucho mejores para aquellas personas que, despu√©s de su promesa, tienen un plan e inmediatamente toman alguna medida para lograr el resultado prometido. <br></p><br><p>  Por lo tanto, la filosof√≠a ECMAScript implica que si crea una promesa, indique inmediatamente c√≥mo la cumplir√°.  El programador necesita elaborar su plan de acci√≥n en forma de un par√°metro de funci√≥n, que usted pasa al constructor Promise.  El siguiente experimento se ve as√≠ (Fig. 6). <br></p><br><img src="https://habrastorage.org/webt/xh/sk/h7/xhskh7cuzrn1jxavomenlnfzwu0.png" alt="Promise constructor utiliza ejecutor"><br>  <i>Figura 6. (Cree un objeto de promesa, pasando la funci√≥n ejecutor al constructor de Promesa)</i> <br><br><p>  Desde el t√≠tulo hasta la figura, vemos que la funci√≥n (par√°metro del constructor Promise) tiene su propio nombre: ejecutor.  Su tarea es comenzar a cumplir la promesa y, preferiblemente, llevarla a alg√∫n tipo de conclusi√≥n l√≥gica.  Y si el programador puede escribir cualquier c√≥digo en el ejecutor, entonces ¬øc√≥mo puede el programador indicarle a JS que todo, el trabajo est√° hecho, puede ir y ver los resultados de la promesa? <br></p><br><p>  Los marcadores o se√±ales que ayudan al programador a informar que la promesa se ha completado se pasan autom√°ticamente al ejecutor, par√°metros en forma de argumentos especialmente formados por JavaScript.  Estos par√°metros se pueden invocar como desee, pero la mayor√≠a de las veces los encontrar√° con nombres como res y rej.  En la especificaci√≥n ECMAScript, su nombre completo es funci√≥n de resoluci√≥n y funci√≥n de rechazo.  Estos marcadores de funci√≥n tienen sus propias caracter√≠sticas, que consideraremos un poco m√°s adelante. <br></p><br><p>  Para comprender la nueva informaci√≥n, se invita al reci√©n llegado a codificar de forma independiente la siguiente declaraci√≥n: "Prometo que puedo dividir un n√∫mero en otro y dar una respuesta, si solo el divisor no es cero".  As√≠ es como se ver√≠a el c√≥digo (fig. 7). <br></p><br><img src="https://habrastorage.org/webt/uu/to/gj/uutogjuluy9r5xxvwo2hrrwnaaq.png" alt="tarea de promesa: divisi√≥n por cero"><br>  <i>Figura 7. (Soluci√≥n del problema de dividir 2 n√∫meros a trav√©s de promesas)</i> <br><br><p>  Ahora puedes analizar el resultado.  Vemos que por segunda vez la consola del navegador muestra el objeto Promis de una manera interesante.  A saber: 2 campos adicionales se indican entre corchetes dobles.  Puede dibujar con seguridad una analog√≠a entre [[PromiseState]] y [[PromiseStatus]], cumplida y resuelta, [[PromiseValue]] y [[PromiseResult]].  S√≠, el navegador en s√≠ intenta decirle al programador sobre la presencia y el valor de los campos internos del objeto de promesa.  Tambi√©n vemos el sistema conectado del objeto de promesa, la funci√≥n ejecutora, la funci√≥n especial callback-tokens res y rej. <br></p><br><p>  Para que el alumno / compa√±ero se relaje m√°s en este material, se le ofrece el siguiente c√≥digo (Fig. 8).  Es necesario analizarlo y responder las siguientes preguntas. <br></p><br><img src="https://habrastorage.org/webt/zs/md/vv/zsmdvv05gwmpi-vyq5a-d5sorjq.png" alt="tarea de promesa: divisi√≥n por cero. Versi√≥n alternativa"><br>  <i>Figura 8. (Variaci√≥n de la soluci√≥n al problema de dividir 2 n√∫meros a trav√©s de promesas)</i> <br><br><p>  ¬øFuncionar√° el c√≥digo?  ¬øD√≥nde est√° la funci√≥n ejecutor aqu√≠ y cu√°l es su nombre?  ¬øEs apropiado el nombre "wantToDivide" en este c√≥digo?  ¬øQu√© devuelve la funci√≥n de enlace despu√©s de s√≠ misma?  ¬øPor qu√© los argumentos se pasan a la funci√≥n de vinculaci√≥n solo en segundo y tercer lugar?  ¬øD√≥nde desaparecieron las funciones especiales funci√≥n de resoluci√≥n y funci√≥n de rechazo?  ¬øC√≥mo entraron los n√∫meros de entrada necesarios n√∫mero 1 y n√∫mero 2 en el "plan de cumplimiento de la promesa"?  ¬øCu√°ntos elementos hay en los argumentos pseudo-array?  ¬øEs posible recuperar de la memoria c√≥mo se ver√° la respuesta en la consola del navegador? <br></p><br><p>  Se invita al lector a pensar en las respuestas a las preguntas por s√≠ mismo.  Tambi√©n <br>  Experimentar en el c√≥digo.  Afortunadamente, el c√≥digo es peque√±o y la idea de la tarea es simple.  S√≠, hay preguntas sobre las promesas y el conocimiento general de JavaScript.  Qu√© hacer, en todas partes estamos esperando sorpresas que nos impiden relajarnos.  Tan pronto como todo te quede claro, puedes seguir adelante. <br></p><br><div class="spoiler">  <b class="spoiler_title">Ver / copiar c√≥digo</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> number1 = <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(prompt(<span class="hljs-string"><span class="hljs-string">"input number 1"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> number2 = <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(prompt(<span class="hljs-string"><span class="hljs-string">"input number 2"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> wantToDivide = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>] === <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[<span class="hljs-number"><span class="hljs-number">3</span></span>](<span class="hljs-string"><span class="hljs-string">"it is forbidden to divide by zero"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] / <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>](result); }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(wantToDivide.bind(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, number1, number2)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myPromise);</code> </pre> <br></div></div><br><h2>  Considere los argumentos de ejecutor-a: resolver y rechazar funciones <br></h2><br><p>  Entonces, tomamos un caf√©, seguimos adelante.  Consideremos con m√°s detalle las funciones especiales resolver funci√≥n y rechazar, que JavaScript genera autom√°ticamente para traducir la promesa del objeto al estado cumplido o rechazado, que simboliza el final de la promesa. <br></p><br><p>  Para empezar, tratemos de verlos simplemente en la consola del desarrollador (Fig. 9). <br></p><br><img src="https://habrastorage.org/webt/rz/ox/vj/rzoxvjvsvmt3962toiukmqtf9ye.png" alt="funci√≥n de resoluci√≥n de investigaci√≥n"><br>  <i>Figura 9. (Investigaci√≥n de la funci√≥n resolver funci√≥n - res)</i> <br><br><p>  Vemos que la funci√≥n de resoluci√≥n es una funci√≥n que toma un argumento (longitud de propiedad === 1).  Y su prototipo es Function.prototype. <br></p><br><p>  Ok, continuemos los experimentos.  ¬øY qu√© suceder√° si eliminamos el enlace a la funci√≥n resolver / rechazar del ejecutor al √°mbito externo?  ¬øSe romper√° algo (fig. 10)? <br></p><br><img src="https://habrastorage.org/webt/9z/2i/cf/9z2icfrmkwiwfeeerdphezhtjay.png" alt="Contol externo de objeto de promesa"><br>  <i>Figura 10. (Traducimos la promesa myPromise al estado cumplido fuera de la promesa)</i> <br><br><p>  Nada fuera de lo com√∫n.  Las funciones como una subespecie de un objeto en JavaScript se pasan por referencia.  Todo sali√≥ como esper√°bamos.  La variable del cierre exteriorRes obtuvo una referencia a nuestra funci√≥n de resoluci√≥n res.  Y utilizamos su funcionalidad para poner la promesa en el estado cumplido fuera del propio ejecutor.  El siguiente ejemplo ligeramente modificado muestra la misma idea, as√≠ que mire el c√≥digo y piense en qu√© estado y con qu√© valor estar√°n myPromise1 y myPromise2 (Fig. 11).  Luego puede verificar sus suposiciones bajo el spoiler. </p><br><img src="https://habrastorage.org/webt/re/gf/ov/regfovwn9xc5-jwlkftz0ed8vgc.png" alt="promesa de tarea. Pregunta">  <i>Figura 11. (La tarea de reflexi√≥n. ¬øEn qu√© estado y con qu√© valor estar√°n las promesas myPromise1 y myPromise2 en la consola del desarrollador?)</i> <br><br><div class="spoiler">  <b class="spoiler_title">La respuesta al problema en la Figura 11 (Figura 12).</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/iy/3x/k-/iy3xk-yuomgcgev4ddftqcffnvm.png" alt="promesa de tarea. Respuesta"><br>  <i>Figura 12. (La respuesta al problema en la Figura 11)</i> <br></div></div><br><p>  Y ahora puedes pensar en una pregunta interesante.  Pero, ¬øc√≥mo la funci√≥n resolver / rechazar siempre sabe exactamente qu√© promesa traducir al estado requerido?  Pasamos al <a href="https://www.ecma-international.org/ecma-262/7.0/">algoritmo en la especificaci√≥n</a> , que describe c√≥mo se crean estas funciones (Fig. 13). <br></p><br><img src="https://habrastorage.org/webt/4n/gq/k-/4ngqk-fikg8ddjo6uhe00_rhkci.png" alt="crear funciones de resoluci√≥n"><br>  <i>Figura 13. (Caracter√≠sticas de la creaci√≥n de funciones de resoluci√≥n para un objeto de promesa espec√≠fico)</i> <br><br><p>  Puntos importantes a los que prestar atenci√≥n: <br></p><br><ul><li>  en el momento de la creaci√≥n de las funciones de resoluci√≥n / rechazo, est√°n unidas r√≠gidamente al √∫nico objeto de promesa que le corresponde <br></li><li>  las funciones de resoluci√≥n / rechazo como un tipo de datos de objeto tienen sus propios campos ocultos [[Promesa]] y [[Ya Resuelto]], que proporcionan a todos la l√≥gica intuitiva familiar que a) - las funciones de resoluci√≥n mismas traducen el objeto de promesa al estado necesario;  y el hecho de que b) una promesa no puede transferirse a otro estado si al menos una vez se invoc√≥ una funci√≥n de resoluci√≥n o rechazo.  Este algoritmo puede ser representado por la siguiente figura (Fig. 14). <br><br><img src="https://habrastorage.org/webt/0p/wt/1d/0pwt1dmqxhzhq0uuat_zljihrhc.png" alt="resolviendo funciones y prometiendo objeto"><br>  <i>Figura 14. (Campos de funciones ocultas de funci√≥n de resoluci√≥n y funci√≥n de rechazo)</i> <br><br><p>  Los algoritmos que usan esta informaci√≥n de campos ocultos no se considerar√°n ahora, ya que son detallados y m√°s complejos.  Todav√≠a tenemos que prepararnos para ellos tanto te√≥rica como moralmente.  Por ahora, solo puedo confirmar su pensamiento: ‚ÄúWow, qu√© simple resulta.  Probablemente, en cada resoluci√≥n / resoluci√≥n de la promesa del objeto, se marcar√° el indicador de "objeto" {[[Valor]]: falso}.  Y si se establece en verdadero, detenemos el proceso de traducir la promesa a otro estado con un simple retorno ".  S√≠, eso es exactamente lo que sucede.  Parece que puede responder correctamente la siguiente pregunta sin problemas.  ¬øCu√°l ser√° el resultado en la consola del desarrollador (Fig. 15)? <br></p><br><img src="https://habrastorage.org/webt/p6/1l/co/p61lcoillhsvjme0-hotfyacsoi.png" alt="experiencia con funciones de resoluci√≥n de enlaces y objetos de promesa"><br>  <i>Figura 15. (Un experimento que muestra la relaci√≥n entre resolver y rechazar funciones con un objeto de promesa espec√≠fico)</i> <br><br><h2>  Algoritmo para crear un objeto de promesa de acuerdo con la especificaci√≥n ECMAScript </h2><br><p>  Considere el momento fascinante cuando nace en el mundo: un <a href="https://www.ecma-international.org/ecma-262/7.0/">objeto de promesa de</a> pleno derecho (Fig. 16). <br></p><br><img src="https://habrastorage.org/webt/xm/yu/09/xmyu0944vrpk4ykurzgunwst0ji.png" alt="promesa de creaci√≥n en ecmascript"><br>  <i>Figura 16. (Algoritmo para crear un objeto de promesa a partir de la especificaci√≥n EcmaScript)</i> <br><br><p>  No deben surgir preguntas complicadas al verlo: </p><p></p><ul><li>  Promise constructor debe ser llamado en modo constructor, y no solo una llamada a funci√≥n <br></li><li>  Promise constructor requiere una funci√≥n ejecutora <br></li><li>  crear un objeto JavaScript con campos ocultos espec√≠ficos <br></li><li>  inicializar campos ocultos con algunos valores iniciales <br></li><li>  crear las funciones de resoluci√≥n y rechazo asociadas con el objeto de promesa <br></li><li>  llamamos a la funci√≥n ejecutora para su ejecuci√≥n, pasando los tokens ya generados resuelven la funci√≥n y rechazan la funci√≥n como argumentos <br></li><li>  si durante la ejecuci√≥n del ejecutor, algo sali√≥ mal, coloca nuestro objeto de promesa en el estado rechazado <br></li><li>  regrese a la variable el objeto de promesa de promesa nacida. <br></li></ul><br><p>  No s√© si fue un descubrimiento para usted que el algoritmo ejecutor de la funci√≥n se ejecuta aqu√≠ y ahora, en modo sincr√≥nico normal, incluso antes de que se escriba algo en la variable a la izquierda del constructor Promise.  Pero a su debido tiempo para m√≠ se convirti√≥ en una revelaci√≥n. <br></p><br><p>  Dado que tocamos el tema del sincronismo y la asincron√≠a, aqu√≠ est√° el siguiente c√≥digo para que usted "piense" o experimente.  Pregunta: Despu√©s de ver alguna creaci√≥n del programador Dima, ¬øpuedes responder cu√°l es el significado del juego codificado a continuaci√≥n? <br></p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randomInteger</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">min, max</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(min + <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() * (max + <span class="hljs-number"><span class="hljs-number">1</span></span> - min)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">game</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> guessCubeNumber = <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(prompt(<span class="hljs-string"><span class="hljs-string">"Throw dice? Guess number?"</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"throwing dice ... wait until it stop"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gameState = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res, rej</span></span></span><span class="hljs-function">) </span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gottenNumberDice = randomInteger(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); gottenNumberDice === guessCubeNumber ? res(<span class="hljs-string"><span class="hljs-string">"you win!"</span></span>) : rej(<span class="hljs-string"><span class="hljs-string">`you loose. </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${gottenNumberDice}</span></span></span><span class="hljs-string"> points dropped on dice`</span></span>); }, <span class="hljs-number"><span class="hljs-number">3000</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gameState; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(game());</code> </pre><br><p>  Por supuesto, esta es una emulaci√≥n de una tirada de dado.  ¬øPuede el usuario adivinar el n√∫mero que se cay√≥ o no?  Vea c√≥mo se integra setTimeout org√°nicamente as√≠ncrono en el ejecutor s√≠ncrono: en nuestro plan, tire un dado y descubra el n√∫mero que se cay√≥.  ¬øC√≥mo se pueden interpretar los resultados en la consola del desarrollador de una manera especial (Fig. 17)? <br></p><br><p>  Si tratamos de ver la promesa hasta que el cubo se detenga (3000 ms se indica en el c√≥digo), veremos que la promesa todav√≠a est√° en estado de espera: el juego no ha terminado, el cubo a√∫n no se ha detenido, no se ha eliminado ning√∫n n√∫mero.  Si tratamos de mirar el objeto prometido despu√©s de que el cubo se detiene, veremos informaci√≥n muy espec√≠fica: si el usuario gan√≥ (adivinando el n√∫mero) o perdi√≥ y por qu√© (qu√© n√∫mero realmente se cay√≥). <br></p><br><img src="https://habrastorage.org/webt/g4/oi/ba/g4oibarzyfjcrnzbvdqs9nqddqm.png" alt="juego de promesa - tirar dados"><br>  <i>Figura 17. (El estado de promesa de un objeto cuando hay una operaci√≥n asincr√≥nica en la funci√≥n ejecutora)</i> <br><br><p>  Si est√° interesado en este ejemplo, o si desea adivinar la cantidad de cubos invertidos, puede copiar el c√≥digo y realizar sus experimentos.  ¬°Atr√©vete! <br></p><br><h2>  Reacci√≥n de promesa como consecuencia de una promesa cumplida </h2><br><p>  Como puede ver en la Figura 14, las consecuencias de resolver / resolver una promesa de un objeto se firman como "+ reacci√≥n" y "-reacci√≥n".  El t√©rmino oficial para estas palabras de la especificaci√≥n ECMAScript es una reacci√≥n prometedora.  Se supone que en los siguientes art√≠culos este tema se considerar√° en detalle.  Por ahora, nos limitamos a la idea general de qu√© es la reacci√≥n de promesa, de modo que este t√©rmino pueda asociarse correctamente con el significado filos√≥fico de esta palabra y su ejecuci√≥n t√©cnica. <br></p><br><p>  Como recordamos, una promesa puede tener consecuencias, pero puede que no.  ¬øCu√°l es la consecuencia?  Esta es una acci√≥n que suceder√° alg√∫n tiempo despu√©s: una vez que se cumpla la promesa.  Y como esta es una acci√≥n, la consecuencia puede expresarse mediante una funci√≥n JavaScript normal.  Algunas funciones se ejecutar√°n en caso de una resoluci√≥n exitosa de la promesa (+ reacci√≥n);  otras funciones: en el caso de que la promesa pase al estado rechazado (reacci√≥n).  T√©cnicamente, estas funciones (consecuencias) se pasan en argumentos cuando se llama al m√©todo Promise.prototype.then (). <br></p><br><p>  Por lo tanto, una parte importante de una reacci√≥n prometedora es una acci√≥n asincr√≥nica que se realiza en alg√∫n momento en el futuro.  Hay un segundo componente importante de la reacci√≥n de promesa: esta es la promesa reci√©n creada que se devuelve despu√©s de ejecutar el comando Promise.prototype.then ().  Esto se debe a que las consecuencias afectan otras promesas.  Por ejemplo, existe la promesa de comprar un autom√≥vil, pero solo despu√©s de que se cumpla la promesa de ganar una cierta cantidad de dinero.  Se cumpli√≥ una promesa, la consecuencia funcion√≥, ahora se puede cumplir la segunda. <br></p><br><p>  De hecho, una reacci√≥n de promesa une las promesas entre s√≠ en un cierto intervalo de tiempo.  Es importante recordar que la reacci√≥n se procesa autom√°ticamente.  Las llamadas a funciones, las consecuencias de resolver una promesa, son hechas por el motor JS, no por el programador (Fig. 18).  Y, dado que las reacciones est√°n estrechamente relacionadas con los objetos de promesa (promesas) en s√≠, es l√≥gico suponer que los algoritmos de reacci√≥n de promesa usan sus campos internos en su l√≥gica.  Y es mejor saber acerca de todos estos matices para poder controlar conscientemente la l√≥gica asincr√≥nica basada en promesas. <br></p><br><img src="https://habrastorage.org/webt/zc/tk/ja/zctkjapwx_daq-shustmj4yc5fo.png" alt="promesa de reacci√≥n en el m√©todo then ()"><br>  <i>Figura 18. (Las consecuencias de resolver una promesa se registran mediante las funciones de devoluci√≥n de llamada en el m√©todo then (). La devoluci√≥n de llamada ser√° llamada as√≠ncronamente autom√°ticamente por el motor JS)</i> <br><br><h2>  Para resumir </h2><br><p>  1) Conocimos las promesas en JavaScript, su filosof√≠a y ejecuci√≥n t√©cnica.  Todo esto se implementa utilizando campos de promesa internos especiales del objeto: [[PromiseState]], [[PromiseValue]], [[PromiseFulFillReactions]], [[PromiseRejectReactions]]. <br></p><br><p>  2) El programador tiene la oportunidad de cumplir su promesa a trav√©s de la funci√≥n ejecutora, transmitida como argumento al constructor de Promise. <br></p><br><p>  3) Los l√≠mites de una promesa cumplida o incumplida est√°n determinados por funciones especiales de marcador, funci√≥n de resoluci√≥n y funci√≥n de rechazo, a menudo en el c√≥digo llamado res y rej.  Estas funciones son creadas autom√°ticamente por JavaScript y pasadas en argumentos al ejecutor. <br></p><br><p>  4) la funci√≥n de resoluci√≥n y la funci√≥n de rechazo siempre tienen un objeto de promesa asociado con ellas, as√≠ como un campo especial com√∫n {[[Valor]]: falso}, que garantiza que la promesa se resuelva solo una vez. <br></p><br><p>  5) [[PromiseFulFillReactions]] y [[PromiseRejectReactions]] son ‚Äã‚Äãcampos internos del objeto de promesa que almacenan las consecuencias de resolver la promesa, una parte importante de las cuales son funciones asincr√≥nicas personalizadas definidas a trav√©s del m√©todo de promesa Promise.prototype.then () del objeto. <br></p><br><h2>  PS </h2><br><p>  Este art√≠culo fue preparado como un resumen de la sesi√≥n de video del grupo InSimpleWords.  Hay suficientes "lecciones en video" y todav√≠a hay material para tomar notas.  Otra pregunta es si ser√° interesante para los miembros de la comunidad leer qu√© art√≠culo sobre promesas seguidas.  Esperando sus comentarios. <br></p><p></p><p></p></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/478938/">https://habr.com/ru/post/478938/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../478926/index.html">.NET Core 3.1 lanzado</a></li>
<li><a href="../478928/index.html">Python o no Python</a></li>
<li><a href="../478930/index.html">C√≥mo usar MySQL sin contrase√±a (y riesgos de seguridad)</a></li>
<li><a href="../478932/index.html">Docker para el front-end. Parte 1. ¬øPor qu√©?</a></li>
<li><a href="../478934/index.html">El m√≥dulo de biblioteca est√°ndar de Python m√°s √∫til que todo el mundo olvida constantemente</a></li>
<li><a href="../478942/index.html">Gran experimento porno: la historia de Internet para adultos</a></li>
<li><a href="../478948/index.html">Busque vulnerabilidades en Samsung TrustZone o AFL fuzz all</a></li>
<li><a href="../478950/index.html">Los resultados de la semana: Huawei se adapta a las sanciones, Putin firma leyes sensacionales y ShutterStock est√° bloqueado en Rusia</a></li>
<li><a href="../478952/index.html">Un mes con Onyx Boox Note Pro</a></li>
<li><a href="../478954/index.html">RE: Miedo y asco en TI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>