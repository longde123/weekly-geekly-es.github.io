<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçüé§ ‚öóÔ∏è üì† Gera√ß√£o efetiva de n√∫meros em um determinado intervalo üìò üî∂ üè∑Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="A grande maioria dos meus posts sobre gera√ß√£o de n√∫meros aleat√≥rios lidava principalmente com as propriedades de v√°rios esquemas de gera√ß√£o. Isso pode...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gera√ß√£o efetiva de n√∫meros em um determinado intervalo</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455702/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21b/913/a41/21b913a412f4fcae1d02afabc90b236c.svg" alt="imagem"></div><br>  A grande maioria dos meus posts sobre gera√ß√£o de n√∫meros aleat√≥rios lidava principalmente com as propriedades de v√°rios esquemas de gera√ß√£o.  Isso pode ser inesperado, mas o desempenho do algoritmo de randomiza√ß√£o pode depender n√£o do esquema de gera√ß√£o escolhido, mas de outros fatores.  Neste post (inspirado em um excelente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo de Daniel Lemyr</a> ), examinaremos as principais raz√µes para o decl√≠nio no desempenho da gera√ß√£o de n√∫meros aleat√≥rios, que geralmente superam o desempenho do mecanismo PRN. <br><br>  Imagine esta situa√ß√£o: <br><br>  Como li√ß√£o de casa, Juan e Sasha implementam o mesmo algoritmo aleat√≥rio em C ++, que ser√° executado no mesmo computador da universidade e com um conjunto de dados.  Seu c√≥digo √© quase id√™ntico e difere apenas na gera√ß√£o de n√∫meros aleat√≥rios.  Juan est√° com pressa para suas aulas de m√∫sica, ent√£o ele simplesmente escolheu o turbilh√£o de Mersenne.  Sasha, por outro lado, passou algumas horas extras pesquisando.  Sasha conduziu benchmarks de v√°rios dos PRNGs mais r√°pidos, que ele aprendeu recentemente nas redes sociais, e escolheu o mais r√°pido.  Na reuni√£o, Sasha estava impaciente em se gabar e perguntou a Juan: "Que sistema PRNG voc√™ usou?" <br><br>  "Pessoalmente, peguei o v√≥rtice de Mersenne - ele est√° embutido na linguagem e parece funcionar muito bem." <br><br>  "Ha!" Respondeu Sasha.  ‚ÄúEu usei o <code>jsf32</code> .  √â muito mais r√°pido que o velho e lento turbilh√£o de Mersenne!  Meu programa √© executado em 3 minutos e 15 segundos! ‚Äù <br><br>  "Hmm, nada mal, mas o meu pode fazer isso em menos de um minuto", diz Juan e encolhe os ombros.  ‚ÄúBem, ent√£o eu tenho que ir ao show.  Voc√™ vem comigo? <br><br>  "N√£o", responde Sasha.  "Eu ... uh ... preciso olhar meu c√≥digo novamente." <br><br>  Essa situa√ß√£o ficcional embara√ßosa <em>n√£o</em> √© particularmente ficcional;  √© baseado em resultados reais.  Se o seu algoritmo aleat√≥rio n√£o est√° funcionando t√£o r√°pido quanto gostar√≠amos, e o gargalo parece ser a gera√ß√£o de n√∫meros aleat√≥rios, por incr√≠vel que pare√ßa, o problema pode n√£o estar no gerador de n√∫meros aleat√≥rios! <br><a name="habracut"></a><br><h3>  Introdu√ß√£o: N√∫meros Aleat√≥rios na Pr√°tica </h3><br>  A maioria dos geradores de n√∫meros aleat√≥rios de alta qualidade modernos cria palavras de m√°quina preenchidas com bits aleat√≥rios, ou seja, geralmente geram n√∫meros no intervalo [0..2 <sup>32</sup> ) ou [0..2 <sup>64</sup> ).  Mas em muitos casos de uso, os usu√°rios precisam de n√∫meros em um determinado intervalo - por exemplo, para rolar um dado ou escolher uma carta aleat√≥ria, n√∫meros s√£o necess√°rios em pequenos intervalos constantes.  No entanto, muitos algoritmos, desde a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mistura</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">amostragem de reservat√≥rios</a> at√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">as √°rvores de busca bin√°ria aleat√≥ria,</a> exigem n√∫meros extra√≠dos de outros intervalos. <br><br><h3>  M√©todos </h3><br>  Veremos muitos m√©todos diferentes.  Para simplificar a discuss√£o, em vez de gerar n√∫meros no intervalo [ <em>i</em> .. <em>j</em> ) ou [ <em>i</em> .. <em>j</em> ], geraremos n√∫meros no intervalo [0 .. <em>k</em> ).  Tendo esse esquema, podemos, por exemplo, gerar n√∫meros no intervalo [ <em>i</em> .. <em>j</em> ) configurando <em>k</em> = <em>j</em> - <em>i</em> , gerando um n√∫mero no intervalo [0 .. <em>k</em> ) e adicionando <em>i</em> a ele. <br><br><h4>  Ferramentas C ++ incorporadas </h4><br>  Muitos idiomas possuem ferramentas internas para obter um n√∫mero aleat√≥rio em um intervalo especificado.  Por exemplo, para remover um cart√£o de um baralho com 52 cart√µes em linguagens de script como Perl e Python, podemos escrever <code>int(rand(52))</code> e <code>random.randint(0,52)</code> .  [Nota  Usu√°rio do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=" class="user_link">CryptoPirate</a> : <i>Parece-me um erro aqui, no Python, o randint (a, b) gera n√∫meros de a para b, incluindo b.</i>  <i>E como existem 52 cartas no baralho e a primeira √© ‚Äú0‚Äù, deve haver random.randint (0,51)</i> .] No C ++, podemos usar <code>uniform_int_distribution</code> mesma <code>uniform_int_distribution</code> . <br><br>  O c√≥digo C ++ para implementar essa abordagem √© simples: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::uniform_int_distribution&lt;<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>&gt; dist(<span class="hljs-number"><span class="hljs-number">0</span></span>, range<span class="hljs-number"><span class="hljs-number">-1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> dist(rng); }</code> </pre> <br>  Geralmente, uma das t√©cnicas descritas abaixo √© usada nas ferramentas internas, mas a maioria dos usu√°rios simplesmente as utiliza, sem pensar no que est√° acontecendo "oculto", acreditando que essas ferramentas foram projetadas corretamente e s√£o bastante eficazes.  No C ++, as ferramentas internas s√£o mais complexas porque devem poder funcionar com mecanismos de gera√ß√£o bastante arbitr√°rios - um gerador que produz valores no intervalo de -3 a 17 pode ser bastante v√°lido e pode ser usado com <code>std::uniform_int_distribution</code> para criar n√∫meros em qualquer intervalo, por exemplo [0..1000).  Ou seja, as ferramentas C ++ internas s√£o muito complicadas para a maioria dos casos em que s√£o usadas. <br><br><h4>  O restante cl√°ssico da divis√£o (distorcido) </h4><br>  Vamos passar de uma abordagem simplificada para uma simplista demais. <br><br>  Quando estudei programa√ß√£o, geramos n√∫meros no intervalo (por exemplo, para selecionar uma carta em um baralho de 52 cartas) usando o operador restante.  Para obter o n√∫mero no intervalo [0..52), escrevemos <code>rand() % 52</code> . <br><br>  No C ++, essa abordagem pode ser implementada da seguinte maneira: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rng() % range; }</code> </pre> <br>  Apesar da simplicidade dessa abordagem, ela demonstra o motivo pelo qual obter n√∫meros no intervalo certo geralmente √© uma tarefa lenta - requer divis√£o (para calcular o restante obtido pelo operador <code>%</code> ).  A divis√£o √© geralmente pelo menos uma ordem de magnitude mais lenta que outras opera√ß√µes aritm√©ticas; portanto, uma √∫nica opera√ß√£o aritm√©tica leva mais tempo do que todo o trabalho realizado por um PRNG r√°pido. <br><br>  Mas, al√©m da baixa velocidade, tamb√©m √© <em>distorcida</em> .  Para entender por que <code>rand() % 52</code> retorna n√∫meros assim√©tricos, suponha que <code>rand()</code> crie n√∫meros no intervalo [0..2 <sup>32</sup> ) e observe que 52 n√£o divide 2 <sup>32</sup> completamente, divide-o 82 595 524 vezes com o restante 48. Ou seja, se usarmos <code>rand() % 52</code> , teremos 82 595 525 maneiras de selecionar as primeiras 48 cartas do baralho e apenas 82 595 524 maneiras de selecionar as √∫ltimas quatro cartas.  Em outras palavras, h√° uma inclina√ß√£o de 0,00000121% contra essas √∫ltimas quatro cartas (talvez sejam reis!).  Quando eu era estudante e escrevia a li√ß√£o de casa sobre jogar dados ou desenhar cartas, ningu√©m costumava se incomodar com distor√ß√µes t√£o pequenas, mas com um aumento no intervalo, a distor√ß√£o aumenta linearmente.  Para um PRNG de 32 bits, um intervalo limitado de menos de <sup>24</sup> tem uma inclina√ß√£o inferior a 0,5%, mas acima de 2 <sup>31 uma</sup> inclina√ß√£o de 50% - alguns n√∫meros retornam duas vezes mais que outros. <br><br>  Neste artigo, consideraremos principalmente t√©cnicas que usam estrat√©gias para eliminar um erro sistem√°tico, mas provavelmente vale a pena dizer que, para um PRNG de 64 bits, o valor de inclina√ß√£o em aplicativos normais provavelmente ser√° desprez√≠vel. <br><br>  Outro problema pode ser que alguns geradores tenham bits baixos fracos.  Por exemplo, as fam√≠lias GPRS Xoroshiro + e Xoshiro + t√™m bits baixos que n√£o passam nos testes estat√≠sticos.  Quando executamos <code>% 52</code> (porque 52 √© par), passamos o bit de ordem baixa diretamente para a sa√≠da. <br><br><h4>  Multiplicar n√∫meros de ponto flutuante (inclinado) </h4><br>  Outra t√©cnica comum √© o uso de um PRNG que gera n√∫meros de ponto flutuante no intervalo [0..1) com a convers√£o subsequente desses n√∫meros no intervalo desejado.  Essa abordagem √© usada no Perl; √© <a href="">recomend√°vel</a> usar <code>int(rand(10))</code> para gerar um n√∫mero inteiro no intervalo [0..10), gerando um n√∫mero de ponto flutuante seguido de arredondamento para baixo. <br><br>  Em C ++, essa abordagem √© escrita assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bounded_rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">rng_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; rng, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint32_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> range)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> zeroone = <span class="hljs-number"><span class="hljs-number">0x1</span></span><span class="hljs-number"><span class="hljs-number">.0</span></span>p<span class="hljs-number"><span class="hljs-number">-32</span></span> * rng(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> range * zeroone; }</code> </pre> <br>  (Observe que <code>0x1.0p-32</code> √© uma constante de ponto flutuante bin√°rio para 2 <sup>-32</sup> , que usamos para converter um n√∫mero inteiro aleat√≥rio no intervalo [0..2 <sup>32</sup> ) para dobrar no intervalo da unidade;  em vez disso, podemos realizar essa convers√£o usando <code>ldexp(rng(), -32)</code> , mas quando <code>ldexp(rng(), -32)</code> essa abordagem, ela ficou muito mais lenta.) <br><br>  Essa abordagem √© t√£o distorcida quanto o restante cl√°ssico da divis√£o, mas a distor√ß√£o aparece de maneira diferente.  Por exemplo, se selecion√°ssemos n√∫meros no intervalo [0..52), os n√∫meros 0, 13, 26 e 39 ocorreriam uma vez menos que os outros. <br><br>  Essa vers√£o, ao generalizar para 64 bits, √© ainda mais desagrad√°vel, pois requer um tipo de ponto flutuante cuja mantissa √© de pelo menos 64 bits.  Em m√°quinas x86 com Linux e macOS, podemos usar <code>long double</code> para aproveitar os n√∫meros de ponto flutuante x86 de precis√£o aumentada que possuem uma mantissa de 64 bits, mas <code>long double</code> n√£o <code>long double</code> universalmente portado para todos os sistemas - em alguns sistemas, <code>long double</code> equivalente a <code>double</code> . <br><br>  Existe um lado bom - essa abordagem √© mais r√°pida que as solu√ß√µes residuais para PRNGs com bits baixos fracos. <br><br><h4>  Multiplica√ß√£o de n√∫meros inteiros (enviesada) </h4><br>  O m√©todo de multiplica√ß√£o pode ser adaptado √† aritm√©tica de ponto fixo, e n√£o de ponto flutuante.  De fato, apenas multiplicamos constantemente por 2 <sup>32</sup> , <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x = rng(); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>; }</code> </pre> <br>  Pode parecer que esta vers√£o requer aritm√©tica de 64 bits. Nos processadores x86, um bom compilador compila esse c√≥digo em uma instru√ß√£o <code>mult</code> 32 bits (que nos fornece dois valores de sa√≠da de 32 bits, um dos quais √© o valor de retorno).  Pode-se esperar que esta vers√£o seja r√°pida, mas √© distorcida exatamente como o m√©todo de multiplica√ß√£o de n√∫meros de ponto flutuante. <br><br><h4>  Divis√£o de queda (sem inclina√ß√£o) </h4><br>  Podemos modificar o esquema de multiplica√ß√£o de ponto flutuante em um esquema baseado em divis√£o.  Em vez de multiplicar <code>x * range / 2**32</code> calculamos <code>x / (2**32 / range)</code> .  Como trabalhamos com aritm√©tica inteira, o arredondamento nesta vers√£o ser√° realizado de maneira diferente e, √†s vezes, gera valores fora do intervalo desejado.  Se descartamos esses valores (por exemplo, nos livramos deles e geramos novos valores), como resultado, obtemos uma t√©cnica sem distor√ß√µes. <br><br>  Por exemplo, no caso de retirar um cart√£o usando um PRNG de 32 bits, podemos gerar um n√∫mero de 32 bits e dividi-lo por 2 32/52 = 82 595 524 para selecionar um cart√£o.  Essa t√©cnica funciona se o valor aleat√≥rio do PRNG de 32 bits for menor que 52 √ó 82595524 = 2 32/32 - 48. Se o valor aleat√≥rio do PRNR for um dos √∫ltimos 48 valores da parte superior do intervalo do gerador, ser√° necess√°rio descart√°-lo e procurar outro. <br><br>  Nosso c√≥digo para esta vers√£o usa um truque para dividir 2 <sup>32</sup> por <code>range</code> sem usar matem√°tica de 64 bits.  Para o c√°lculo direto de <code>2**32 / range</code> precisamos representar o n√∫mero 2 <sup>32</sup> , que √© muito grande (por um!) Para representar como um n√∫mero inteiro de 32 bits.  Em vez disso, levamos em considera√ß√£o que, para n√∫meros inteiros n√£o assinados, o <code>range</code> opera√ß√£o de nega√ß√£o un√°ria calcula um valor positivo de 2 <sup>32</sup> - <code>range</code> ;  Ao dividir esse valor por <code>range</code> , obtemos uma resposta menor que <code>2**32 / range</code> . <br><br>  Portanto, o c√≥digo C ++ para gerar n√∫meros usando divis√£o e soltar se parece com o seguinte: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-comment"><span class="hljs-comment">// calculates divisor = 2**32 / range uint32_t divisor = ((-range) / range) + 1; if (divisor == 0) // overflow, it's really 2**32 return 0; for (;;) { uint32_t val = rng() / divisor; if (val &lt; range) return val; } }</span></span></code> </pre> <br>  Obviamente, essa abordagem requer duas opera√ß√µes lentas baseadas na divis√£o, que geralmente s√£o mais lentas que outras opera√ß√µes aritm√©ticas, portanto, voc√™ n√£o deve esperar que seja r√°pida. <br><br><h4>  O restante da divis√£o (dupla) sem distor√ß√µes - t√©cnica OpenBSD </h4><br>  Tamb√©m podemos adotar a abordagem de queda para eliminar a inclina√ß√£o no m√©todo restante da divis√£o cl√°ssica.  No exemplo com cartas de baralho, precisamos novamente soltar 48 valores.  Nesta vers√£o, em vez de descartar os <em>√∫ltimos</em> 48 valores, (equivalente) descartamos os <em>primeiros</em> 48 valores. <br><br>  Aqui est√° a implementa√ß√£o dessa abordagem em C ++: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-comment"><span class="hljs-comment">// calculates 2**32 % range uint32_t t = (-range) % range; for (;;) { uint32_t r = rng(); if (r &gt;= t) return r % range; } }</span></span></code> </pre> <br>  Essa t√©cnica remove a inclina√ß√£o, mas requer duas opera√ß√µes de divis√£o demoradas com o restante de cada valor de sa√≠da (e voc√™ pode precisar de um gerador interno para criar v√°rios n√∫meros).  Portanto, deve-se esperar que o m√©todo seja aproximadamente duas vezes mais lento que a abordagem de inclina√ß√£o cl√°ssica. <br><br>  <a href=""><code> arc4random_uniform</code> OpenBSD</a> (que tamb√©m √© usado no OS X e iOS) usa essa estrat√©gia. <br><br><h4>  Restante de divis√£o (√∫nica) sem inclina√ß√£o - metodologia Java </h4><br>  Java usa uma abordagem diferente para gerar um n√∫mero em um intervalo que usa apenas uma opera√ß√£o de divis√£o restante, com exce√ß√£o de casos bastante raros de descartar o resultado.  C√≥digo: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> uint32_t </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bounded_rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rng_t&amp; rng, uint32_t range)</span></span></span><span class="hljs-function"> </span></span>{ uint32_t x, r; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { x = rng(); r = x % range; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (x - r &gt; (-range)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r; }</code> </pre> <br>  Para entender por que essa op√ß√£o funciona, voc√™ precisa pensar um pouco.  Diferentemente da vers√£o anterior baseada em res√≠duos, que elimina o vi√©s ao remover parte dos valores mais baixos do mecanismo de gera√ß√£o interno, esta vers√£o filtra os valores da parte superior do intervalo do mecanismo. <br><br><h4>  Multiplica√ß√£o de n√∫meros inteiros inclinados - m√©todo Lemira </h4><br>  Da mesma maneira que removemos o vi√©s do m√©todo restante da divis√£o, podemos eliminar o vi√©s da t√©cnica de multiplica√ß√£o de n√∫meros inteiros.  Esta t√©cnica foi inventada por Lemyr. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> t = (-range) % range; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x = rng(); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> l = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(m); } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (l &lt; t); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>; }</code> </pre> <br><h4>  Drop bitmask (no skew) - t√©cnica da Apple </h4><br>  Em nossa √∫ltima abordagem, as opera√ß√µes de divis√£o e restante s√£o completamente eliminadas.  Em vez disso, utiliza uma opera√ß√£o de mascaramento simples para obter um n√∫mero aleat√≥rio no intervalo [0..2 <sup><em>k</em></sup> ), onde <em>k</em> √© o menor valor, de modo que 2 <sup><em>k √©</em></sup> maior que o intervalo.  Se o valor for muito grande para o nosso intervalo, n√≥s o descartamos e tentamos obter outro.  O c√≥digo √© mostrado abaixo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> mask = ~<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>); --range; mask &gt;&gt;= __builtin_clz(range|<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x; <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { x = rng() &amp; mask; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (x &gt; range); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x; }</code> </pre> <br>  Essa abordagem foi adotada pela Apple quando (na vers√£o macOS Sierra) executou <a href="">sua pr√≥pria revis√£o</a> do c√≥digo <code>arc4random_uniform</code> . <br><br><h3>  T√©cnicas b√°sicas de benchmarking </h3><br>  Agora, temos v√°rias abordagens que podem ser avaliadas.  Infelizmente, quando estamos preocupados com os custos de uma opera√ß√£o de divis√£o √∫nica, o benchmarking se torna algo n√£o trivial.  Nenhuma refer√™ncia pode levar em considera√ß√£o todos os fatores que afetam o campo de aplica√ß√£o, e n√£o h√° garantia de que a melhor op√ß√£o para sua aplica√ß√£o seja certamente a melhor para a minha. <br><br>  Usamos tr√™s par√¢metros de refer√™ncia e testamos as t√©cnicas com muitos PRNGs diferentes. <br><br><h4>  Aleat√≥rio grande de refer√™ncia </h4><br>  Provavelmente a refer√™ncia mais √≥bvia √© a mistura.  Nesta refer√™ncia, simulamos a execu√ß√£o de mixagem em larga escala.  Para classificar uma matriz de tamanho <em>N,</em> devemos gerar n√∫meros nos intervalos [0 .. <em>N</em> ), [0 .. ( <em>N</em> -1)), ..., [0..1).  Nesta refer√™ncia, assumiremos que <em>N</em> √© o n√∫mero m√°ximo poss√≠vel (para <code>uint32_t</code> √© 2 <sup>32</sup> -1).  C√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0xffffffff</span></span>; i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; --i) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bval = bounded_rand(rng, i); assert(bval &lt; i); sum += bval; }</code> </pre> <br>  Observe que ‚Äúusamos‚Äù cada n√∫mero adicionando-o √† <code>sum</code> (para que n√£o seja descartado pela otimiza√ß√£o), mas n√£o realizamos nenhuma mistura para focar na gera√ß√£o de n√∫meros. <br><br>  Para testar a gera√ß√£o de 64 bits, temos um teste semelhante, mas ser√° impratic√°vel executar um teste correspondente √† mistura de uma matriz de tamanho 2 <sup>64</sup> - 1 (porque levar√° muitos milhares de anos para concluir essa refer√™ncia maior).  Em vez disso, cruzamos o intervalo inteiro de 64 bits, mas geramos o mesmo n√∫mero de valores de sa√≠da que no teste de 32 bits.  C√≥digo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0xffffffff</span></span>; i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; --i) { <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> bound = (<span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(i)&lt;&lt;<span class="hljs-number"><span class="hljs-number">32</span></span>) | i; <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> bval = bounded_rand(rng, bound ); assert(bval &lt; bound); sum += bval; }</code> </pre> <br><h5>  Resultados Mersenne vortex </h5><br>  Os resultados mostrados abaixo demonstram o desempenho desse par√¢metro de refer√™ncia para cada um dos m√©todos que examinamos ao usar o v√≥rtice Mersenne e test√°-lo em 32 bits (usando <code>std::mt19937</code> da <code>libstdc++</code> ) e c√≥digo semelhante de 64 bits (usando <code>std:mt19937_64</code> da <code>libstdc++</code> )  Os resultados s√£o a m√©dia geom√©trica de 15 execu√ß√µes com diferentes valores de sementes, que s√£o normalizadas para que o m√©todo restante da divis√£o cl√°ssica tenha um √∫nico tempo de execu√ß√£o. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b9f/3eb/53f/b9f3eb53f894a14ac2698f44090b23a6.svg"></div><br>  Pode parecer que temos respostas claras sobre desempenho - parece que voc√™ pode criar t√©cnicas para a perfei√ß√£o deles e se perguntar o que os desenvolvedores do <code>libstdc++</code> estavam pensando quando escreveram uma implementa√ß√£o t√£o terr√≠vel para n√∫meros de 32 bits.  Mas, como costuma ser o caso do benchmarking, a situa√ß√£o √© mais complicada do que parece com esses resultados.  Em primeiro lugar, existe o risco de os resultados serem espec√≠ficos do v√≥rtice de Mersenne; portanto, expandiremos os muitos PRNGs testados.  Em segundo lugar, pode haver um problema sutil com o pr√≥prio benchmark.  Vamos primeiro lidar com a primeira pergunta. <br><br><h5>  Resultados de diferentes PRNGs </h5><br>  <code>chacha8r</code> <code>gjrand32</code> 32 bits com <code>arc4_rand32</code> , <code>chacha8r</code> , <code>gjrand32</code> , <code>jsf32</code> , <code>mt19937</code> , <code>pcg32</code> , <code>pcg32_fast</code> , <code>sfc32</code> , <code>splitmix32</code> , <code>xoroshiro64+</code> , <code>xorshift*64/32</code> <code>xoshiro128+</code> , <code>xoshiro128+</code> e <code>xoshiro128**</code> e <code>gjrand64</code> 64 bits <code>jsf64</code> , <code>mcg128</code> , <code>mcg128_fast</code> , <code>mt19937_64</code> , <code>pcg64</code> , <code>pcg64_fast</code> , <code>sfc64</code> , <code>splitmix64</code> , <code>xoroshiro128+</code> , <code>xorshift*128/64</code> <code>xoshiro256+</code> , <code>xoshiro256+</code> e <code>xoshiro256*</code> .  Esses kits nos fornecer√£o alguns PRNs lentos e muitos muito r√°pidos. <br><br>  Aqui est√£o os resultados: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2dc/8c8/f1a/2dc8c8f1af9aa517a92260e7cbd3a73e.svg"></div><br>  Podemos ver as principais diferen√ßas dos resultados com o v√≥rtice de Mersenne.  PRNGs mais r√°pidos deslocam o equil√≠brio em dire√ß√£o ao c√≥digo delimitador e, portanto, a diferen√ßa entre as diferentes abordagens se torna mais acentuada, especialmente no caso de PRNRs de 64 bits.  Com um conjunto mais amplo de <code>libstc++</code> implementa√ß√£o <code>libstc++</code> deixa de parecer t√£o terr√≠vel. <br><br><h5>  Conclus√µes </h5><br>  Nesse benchmark por uma margem significativa, a abordagem baseada na multiplica√ß√£o com vi√©s ganha em velocidade.  Existem muitas situa√ß√µes em que os limites ser√£o pequenos em rela√ß√£o ao tamanho do PRNG, e o desempenho √© absolutamente cr√≠tico.  Nessas situa√ß√µes, √© improv√°vel que um leve vi√©s tenha um efeito percept√≠vel, mas a velocidade do PRNG ter√°.  Um exemplo √© o Quicksort com um ponto de refer√™ncia aleat√≥rio.  Dos m√©todos distorcidos, a t√©cnica de m√°scara de bit parece promissora. <br><br>  Mas antes de tirar conclus√µes s√©rias, precisamos apontar o enorme problema desse benchmark - a maior parte do tempo √© gasta em limites muito altos, o que provavelmente d√° import√¢ncia excessiva a grandes intervalos.  Portanto, precisamos ir para o segundo benchmark. <br><br><h4>  Aleat√≥rio pequeno de refer√™ncia </h4><br>     ,     ¬´ ¬ª (). : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> j = <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; <span class="hljs-number"><span class="hljs-number">0xffff</span></span>; ++j) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0xffff</span></span>; i &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; --i) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bval = bounded_rand(rng, i); assert(bval &lt; i); sum += bval; } }</code> </pre> <br><h5>    </h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c5/d3b/4bd/6c5d3b4bdb5f2e45cd805a051d79ab9a.svg"></div><br><h5>    </h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/45a/9ae/8c0/45a9ae8c040cb4d297fe82f00fa06e3c.svg"></div><br><h5>  Conclus√µes </h5><br>                ,      . <br><br><h4>     </h4><br>     ,     ;        ,    ,     . <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bit = <span class="hljs-number"><span class="hljs-number">1</span></span>; bit != <span class="hljs-number"><span class="hljs-number">0</span></span>; bit &lt;&lt;= <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">0x1000000</span></span>; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bound = bit | (i &amp; (bit - <span class="hljs-number"><span class="hljs-number">1</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bval = bounded_rand(rng, bound); assert(bval &lt; bound); sum += bval; } }</code> </pre> <br><h5>    </h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f34/65c/447/f3465c447f9b19b430bb43533a655c2f.svg"></div><br><h5>    </h5><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/64b/c58/2a2/64bc582a2fde24fd0faedbeaabb9f64c.svg"></div><br><h5>  Conclus√µes </h5><br>      .     ,      ,     , ,    . <br><br>      ,      ,          . <br><br><h3>   </h3><br>             , -     ,    .   ,       . <br><br><h4>       </h4><br>          , : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-comment"><span class="hljs-comment">// calculates 2**32 % range uint32_t t = (-range) % range; for (;;) { uint32_t r = rng(); if (r &gt;= t) return r % range; } }</span></span></code> </pre> <br>  <code>range</code>       ,     <em> </em> .         ,     ,        . <br><br>      : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> r = rng(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (r &lt; range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> t = (-range) % range; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (r &lt; t) r = rng(); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> r % range; }</code> </pre> <br>       ¬´ Mod  ¬ª (. ),   ¬´   ¬ª.   ,       (   ). <br><br><h5>   Large-Shuffle </h5><br>        64-  (  mod  ),         32- .   ,       . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bb4/61d/b52/bb461db52be4a7d983dd7f97844179c0.svg"></div><br><h5>   Small-Shuffle </h5><br>   ,      small-shuffle      ,       .            .     (OpenBSD)        (Java). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f07/2bd/fe2/f072bdfe2660cf0f8789b124a8f02646.svg"></div><br><h5>      </h5><br>          . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/219/b1d/add/219b1daddfa6a55a2cb485b3ae774016.svg"></div><br> ,       :        . <br><br><h4>     </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Normalmente, um c√°lculo </font></font><code>a % b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">requer divis√£o, mas em situa√ß√µes em que o </font></font><code>a &lt; b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">resultado √© simples </font></font><code>a</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e a divis√£o n√£o √© necess√°ria. </font><font style="vertical-align: inherit;">E quando </font></font><code>a/2 &lt; b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, o resultado √© simples </font></font><code>a - b</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Portanto, em vez de computar</font></font><br><br><pre> <code class="cpp hljs">a %= b;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√≥s podemos cumprir </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt;= b) { a -= b; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt;= b) a %= b; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O custo da divis√£o √© t√£o significativo que o aumento do custo desse c√≥digo mais complexo pode justificar-se economizando tempo devido √† falta de divis√£o. </font></font><br><br><h5><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Resultados de refer√™ncia de reprodu√ß√£o aleat√≥ria grande </font></font></h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A adi√ß√£o dessa otimiza√ß√£o aprimora muito os resultados do benchmark de shuffle grande. </font><font style="vertical-align: inherit;">Isso √© mais percept√≠vel no c√≥digo de 64 bits, onde a opera√ß√£o de tirar o restante √© mais cara. </font><font style="vertical-align: inherit;">O m√©todo de duplo restante (estilo OpenBSD) mostra vers√µes com otimiza√ß√µes para apenas uma opera√ß√£o restante e para ambas.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c56/e1a/669/c56e1a669836477e46f870bd1bc7a6c9.svg"></div><br>      -  ,         . <br><br><h5>   Small-Shuffle </h5><br>        small-shuffle,      ,     .    ,     . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6fa/4db/b65/6fa4dbb65b9a3f6c6f9e8ba4f7b455db.svg"></div><br><h5>      </h5><br>        . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0e/ae7/758/e0eae77583cc457a9e923540ad954257.svg"></div><br><h4> :    </h4><br>              ,           .               . <br><br><h5>    32-  </h5><br>      32-  ,       ,    32-  : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/21b/913/a41/21b913a412f4fcae1d02afabc90b236c.svg"></div><br>   ,   ,  <code>pcg32_fast</code>      ‚Äî      Xoroshiro (    ).     ,     -       ‚Äî      .  ,           5%,   ,     ¬´¬ª. <br><br><h5>    64-  </h5><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">O gr√°fico mostra o desempenho de v√°rios esquemas de gera√ß√£o de 64 bits, em m√©dia, entre todas as t√©cnicas e quinze execu√ß√µes normalizadas para o desempenho do v√≥rtice Mersenne de 32 bits. Pode parecer estranho que a normaliza√ß√£o seja realizada usando o v√≥rtice Mersenne de 32 bits, mas isso nos permite ver os custos adicionais do uso da gera√ß√£o de 64 bits nos casos em que a gera√ß√£o de 32 bits √© suficiente.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/928/16c/b24/92816cb249e7f76c4ed4e11c65f67475.svg"></div><br>   ,  <code>mcg128_fast</code>  ,          5%,       . <code>pcg64</code>  <code>pcg64_fast</code>    <code>mcg128_fast</code> ,       128-    (, LCG)  128-    (, MCG).   ,          , <code>pcg64</code>    20%  64-  . <br><br>     ,     ,      64- ,  64-   ,  32-. <br><br><h3>  Conclus√µes </h3><br>      ,       (, 32-  )          45%.                     66%;  ,      . <br><br>    ( ) ‚Äî    (   ).  : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> bounded_rand(<span class="hljs-keyword"><span class="hljs-keyword">rng_t</span></span>&amp; rng, <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> x = rng(); <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> l = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(m); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (l &lt; range) { <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> t = -range; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &gt;= range) { t -= range; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (t &gt;= range) t %= range; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (l &lt; t) { x = rng(); m = <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(x) * <span class="hljs-keyword"><span class="hljs-keyword">uint64_t</span></span>(range); l = <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span>(m); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m &gt;&gt; <span class="hljs-number"><span class="hljs-number">32</span></span>; }</code> </pre> <br>         ,          . <br><br><h3> :    </h3><br>      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">GitHub</a> .     23   <code>bounded_rand</code>   26   (13 32-   13 64-),    (GCC 8  LLVM 6),    26 * 23 * 2 = 1196  ,       15 seed,   1196 * 15 = 17 940   ,       .       48-     Xeon E7-4830v3   2,1 .          . <br><br>        . ,    <code>jsf32.STD-libc++</code> ,   ‚Äî <code>mt19937.BIASED_FP_MULT_SCALE</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">No benchmark 3, este √∫ltimo leva 69,6% menos tempo. </font><font style="vertical-align: inherit;">Ou seja, o tempo dessa situa√ß√£o ficcional √© baseado em dados da realidade.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt455702/">https://habr.com/ru/post/pt455702/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt455692/index.html">ASZP: restyling ou teatro come√ßa com um cabide</a></li>
<li><a href="../pt455694/index.html">Arquitetura de cobran√ßa de pr√≥xima gera√ß√£o: transi√ß√£o para Tarantool</a></li>
<li><a href="../pt455696/index.html">O estado eletr√¥nico do futuro. Parte 2</a></li>
<li><a href="../pt455698/index.html">O livro "Como funciona o JavaScript"</a></li>
<li><a href="../pt455700/index.html">4 truques que nos ajudaram a otimizar o frontend</a></li>
<li><a href="../pt455710/index.html">Por que n√≥s da Leroy Merlin precisamos de nosso pr√≥prio departamento de desenvolvimento russo para 200 pessoas</a></li>
<li><a href="../pt455714/index.html">Exporte automaticamente o Google Forms para o Notion usando IFTTT e Django</a></li>
<li><a href="../pt455716/index.html">15 pr√°ticas recomendadas para implantar o software de Business Intelligence</a></li>
<li><a href="../pt455720/index.html">Como criamos interface do usu√°rio para sistemas de an√∫ncios</a></li>
<li><a href="../pt455722/index.html">Python consome muita mem√≥ria ou como reduzir o tamanho dos objetos?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>