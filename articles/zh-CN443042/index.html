<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙎🏿 🎉 ↩️ 在GLSL上发布了61.9万个俄罗斯方块，它们的渲染和一个简单的机器人 👨‍❤️‍👨 🌞 🌒</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我有一个“想法”，可以使一个着色器（一个帧缓冲纹理）同时运行俄罗斯方块的最大数量。 


 以下是对所得代码如何工作的简短描述。 
 这是什么 


每个俄罗斯方块都以三个像素工作，对于1920x1080分辨率，您一次可以运行619200份。 还制作了一个用于自动播放的简单机器人。 
 在帖子末尾，...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在GLSL上发布了61.9万个俄罗斯方块，它们的渲染和一个简单的机器人</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443042/"><p> 我有一个“想法”，可以使一个着色器（一个帧缓冲纹理）同时运行俄罗斯方块的最大数量。 </p><br><p> 以下是对所得代码如何工作的简短描述。 </p><a name="habracut"></a><br><h4 id="chto-eto"> 这是什么 </h4><br><p>每个俄罗斯方块都以三个像素工作，对于<code>1920x1080</code>分辨率，您一次可以运行<code>619200</code>份。 还制作了一个用于自动播放的简单机器人。 <br>  <strong>在帖子末尾，可以链接到运行和源。</strong> <br>  <strong>视频已更新，显示剩余字段数，最多为零。</strong> </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/rcgpwVLydLw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3 id="hranenie-dannyh"> 资料储存 </h3><br><p> 尺寸为<code>[10, 22]</code> （10宽，22高度）的俄罗斯方块表。 <br> 每个单元格可以为空或不为空。 <br> 存储整个表总共需要<code>22 * 10 = 220</code>位。 <br> 一个“像素”是四个24位浮点数，每个像素96位。 </p><br><p> 在视觉上（调试框架的一部分），三个像素用红色突出显示，这是一个保存的字段： </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f6b/9e7/973/f6b9e7973210477303e269254223e645.png" alt="图片"></p><br><p> <code>2 * 96 + 24 + 4</code> <br> 两个像素，第三像素的一个浮点数，第三像素的第二个浮点数的4位 <br> 第三个像素<em>pixel3.zw中</em>有两个未使用的浮点数，它们存储<em>了逻辑状态</em> ，更精确地讲 </p><br><ul><li>  <strong>z</strong>存储三个八位数字<code>[a,b,c]</code> <br>  -当前块的位置，作为数组中该位置的ID（大小为220位的数组，最大位置为220，小于0xff） <br>  <em>-b</em>时间，直到每帧<code>-1</code>自动下降（定时器）到该数字为止，当它变为0时它就落在块上 <br>  -当前块的<em>c</em> ID </li><li>  <strong>w</strong>也是<code>[a,b,c]</code> ，而且整个浮动的符号（正号或负号） <em>也是当前表中游戏结束</em>的标志（以免浪费该字段，避免浪费资源） <br>  - <em>一个</em>动作，无动作（0），向左（1），向右（2），依此类推，完整代码在<em>Common中</em> ，动作具有两种状态， <em>检查左</em>并<em>检查</em>是否可以向左移动，然后将动作设置为<em>left_ move</em> 。 <br>  -当前表的<code>[b,c]</code> <em>0xffff</em> （16位）点，已刻录的行数 </li></ul><br><p> 在第三像素的第二浮点数中还有<code>20 </code>未使用。 </p><br><p>  <strong>调试</strong>框架显示<em>保存逻辑正常工作</em> <br> 左侧有一个大小为3个像素的白场，专门设置为显示间隙已正确处理（如果分辨率不是3的倍数，则条带将成一定角度） <br>  <em>75行的条件缓冲区A</em> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/00f/770/c98/00f770c9850ac3900303ba7503040268.png" alt="图片"></p><br><h4 id="zachem-nuzhny-id-deystviy"> 为什么需要动作ID： </h4><br><ul><li> 数据存储在三个像素中，不可能同时<em>检查逻辑并</em>在一帧中<em>更改数据</em> （如果不执行所有逻辑并在每个像素中加载整个地图，则负载将增加数十倍）。 </li><li> 因此， <em>数据存储</em>逻辑在每个像素中工作，并执行接收到的命令<em>left_mov</em> ，验证<em>命令left_check</em>仅在一个像素（第三个像素） <em>中</em>执行。 </li></ul><br><h4 id="medlennoe-mesto"> 慢的地方 </h4><br><ul><li> 每三个像素（逻辑像素）解压缩整个地图（读取所有三个像素）。 </li><li> 其余两个像素仅解压缩“自身”（一个像素）以执行保存的动作。 </li><li> 在操作过程中， <em>线烧了，</em>另一个像素被加载，因为桌子掉下来了，桌子的下部应该知道上面是什么。 </li></ul><br><h4 id="proizvoditelnost-algoritma-hraneniya-dannyh"> 存储算法性能 </h4><br><p> 对于测试，也将<em>#define debug</em>设置为Common和<em>AI 0</em> 。 <br>  <strong>我得到了这样的结果</strong> -渲染和处理所有619200字段时为<em>10FPS</em> ， <br> 在12万场（25fps） </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c6f/f08/74f/c6ff0874f2aa639402b7247546e718c2.jpg" alt="图片"></p><br><h3 id="logika-bota"> 机器人逻辑 </h3><br><p>  <strong>逻辑非常糟糕</strong> ，该僵尸程序在一分钟内就会耗尽，最高可升至60分。 </p><br><p> 考虑到基于所有可能的跌落的最佳位置，我无法通过许多周期来检查孔洞，壁架和可燃区域来开始一个<em>良好的逻辑</em> ... <br> 好的逻辑对我来说最多可以工作100份，并且在绕过所有循环时会产生很大的延迟。 </p><br><p>  <strong>我的机器人逻辑是这样的</strong> <br> 所有逻辑都在缓冲区A的<em>AI_pos_gen</em>函数中，共有十行。 </p><br><p> 伪代码： <br> 检查模块安装的高度是否等于当前列中字段的最大值（检查一行的高度） </p><br><pre> <code class="plaintext hljs">(4   ){ (  (10)){ (     ){  (    ,  )   best ID()  best POS } } }  (     )   (  )      0     1</code> </pre> <br><p> 事实证明，三个循环很常见-他们将块放置在使得高度最小的位置。 </p><br><p> 当出现新块时<em>会</em>调用<em>AI_pos_gen</em>函数，并返回<em>从上方下落</em>的位置，获取块ID并使其旋转，该函数在第三个像素（逻辑）中工作，即，它具有一个已满载的地图（地图数组）。 <br>  <em>如果愿意，您可以轻松尝试编写您的机器人。</em> </p><br><p>  <strong>最慢的地方</strong> <br> 仅增加一个循环即可<em>测试漏洞</em> ，当机器人数量超过1万时，我的视频卡驱动程序崩溃了……我编写的机器人是我能做到的最“简约”的机器人版本，不幸的是它非常糟糕。 </p><br><h3 id="interfeysrendering-ui">  UI界面/渲染 </h3><br><p> 所有呈现在<em>Image中</em> ，UI逻辑在<em>缓冲区B中。</em> </p><br><p>  <strong>渲染：</strong> <br> 将屏幕拆分为<em>小块，</em>并在每个小块中绘制一张桌子，以最小的负荷。 </p><br><p> 加载地图的逻辑-未解压缩每个像素，未解压缩每个像素，仅解压缩了“必需位”（字面意思），功能代码为： </p><br><pre> <code class="plaintext hljs">int maptmp(int id, int midg) { int nBits = 8; ivec4 pixeldata = loadat(id, midg); int itt = (id / 24) / 4; //data pixel id 0-2 int jtt = (id - itt * 24 * 4) / 24; //component in data pizel id 0-3 int ott = (id - itt * 24 * 4 - jtt * 24) / 8; //component in unpacked value 0-2 int ttt = (id - itt * 24 * 4 - jtt * 24 - ott * 8); //bit after int2bit 0-7 ivec3 val = decodeval16(pixeldata[jtt]); int n = val[ott]; for (int i = 0; i &lt; nBits; ++i, n /= 2) { if (i == ttt) { if ((n % 2) == 0)return 0; else return 1; //switch + return does not work on windows(Angle) /*switch (n % 2) { case 0:return 0;break; case 1:return 1;break; }*/ } } return 0; }</code> </pre> <br><p>  <strong>为了避免</strong>滚动时的<strong>像素化</strong> ，从43000开始，浮点数的小数部分会丢失，并且无法计算出将619千添加到UV进行滚动（会有像素而不是表格）。 <br> 所有滚动都分为一个大<em>图块，</em>并旋转一圈，最多向UV添加32。  （ <em>图片中的</em> 207行）。 </p><br><p> 确定字段ID的方法相同。  （ <em>图片中的</em>第215行） </p><br><h4 id="ui"> 用户界面 </h4><br><p> 号码： <br> 黄色是俄罗斯方块字段的数量。 <br> 左大-当前字段的编号。 <br> 在右下方-当前字段的点。 </p><br><h3 id="ishodnik-i-zapusk"> 源和启动 </h3><br><p>  <em>Bufer A</em>逻辑， <em>Bufer B</em>是UI控件， <em>图像</em>渲染 <br> 来源<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://www.shadertoy.com/view/3dlSzs</a> （通过Angle编译的时间为16秒） <br> 该机器人在此处被禁用（您可以启用它），并且所有字段都<em>可以</em>通过键盘进行<em>播放</em> 。 </p><br><p> 控制左/右/上/下箭头。 </p><br><p>  UI红色矩形重置，移动（单击LMB拖动鼠标），然后单击字段以滚动或选择要显示的字段。 </p><br><p> 从网络浏览器启动： </p><br><ul><li> 使用<i>chrome.exe</i>运行chrome <i>--use-angle = gl</i> </li><li> 跟随<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">链接到shadertoy</a> </li><li> 在网站上的编辑器中，选择“通用”并删除<i>#define no_AI</i> </li><li>  （也是常见的）将#define AI 199设置为0，即<i>#define AI 0</i> </li><li> 单击编译按钮（在着色器上的编辑器窗口下），然后单击全屏 </li></ul><br><p>  <b>第二个选项</b>是在任何“着色器启动器”中运行着色器，这里是<a href="">指向</a>带有该着色器的* .exe文件<a href="">的存档（ <b>下载</b> ）</a>的<a href="">链接</a> 。 </p><br><p>  OpenGL的编译时间约为10秒。 </p><br><p>  <strong>更新</strong> ：添加了带有<em>孔检查</em>的着色器<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://www.shadertoy.com/view/wsXXzH</a> <br> 而不是在相同高度下获得更好位置的条件。  <code>check_block_at_wh</code>功能<code>check_block_at_wh</code> （第380 BufA行），同时检查位置的有效性，计算孔数，未添加新的循环以及条件行442至459 BufA。 <br> 它也可以在一分钟之内迅速燃烧30-60点（显然，您需要检查较大的区域是否有孔，但这会产生强大的制动作用） </p><br><p> 还有两张图片解释了这项工作： <br> 位置选择<a href="">https://i.imgur.com/e0uENgV.png</a> <br> 该条件的块位置为<a href="">https://i.imgur.com/ORECXUW.png</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN443042/">https://habr.com/ru/post/zh-CN443042/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN443028/index.html">3月11日至17日在莫斯科举行的数字活动</a></li>
<li><a href="../zh-CN443030/index.html">STM32和其他微控制器上最简单的内存配置</a></li>
<li><a href="../zh-CN443034/index.html">新的Tesla充电站：在5分钟内为120公里的电池充电</a></li>
<li><a href="../zh-CN443038/index.html">如果强力胶进入眼睛</a></li>
<li><a href="../zh-CN443040/index.html">在Google Play和AppStore上阻止应用程序的7个主要原因</a></li>
<li><a href="../zh-CN443046/index.html">安全研究人员如何访问iOS代码的受保护站点</a></li>
<li><a href="../zh-CN443050/index.html">当今对称加密算法工作原理的最简单解释</a></li>
<li><a href="../zh-CN443052/index.html">来自旧智能手机的精美精准手表</a></li>
<li><a href="../zh-CN443054/index.html">Linux下程序员的实用程序选择</a></li>
<li><a href="../zh-CN443056/index.html">第二名艾滋病患者达到缓解</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>