<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙋🏻 🎖️ 🛵 Fort Byte Car (dan banyak lagi) Penduduk Asli Amerika 🔟 🕺🏾 🖋️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ya, ya, itu adalah "byte" dan itu dalam bahasa India (bukan India). Saya akan mulai dalam rangka. Baru-baru ini di sini, di Habré, artikel tentang byt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fort Byte Car (dan banyak lagi) Penduduk Asli Amerika</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431932/"><img src="https://habrastorage.org/getpro/habr/post_images/dbb/a59/e93/dbba59e932ecdb4b0c28896a7e6fc3e3.jpg" alt="gambar"><br><br>  Ya, ya, itu adalah "byte" dan itu dalam bahasa India (bukan India).  Saya akan mulai dalam rangka.  Baru-baru ini di sini, di Habré, artikel tentang bytecode mulai muncul.  Dan suatu ketika, saya senang menulis sistem Fort.  Tentu saja, di assembler.  Mereka 16-bit.  Saya tidak pernah memprogram pada x86-64.  Bahkan dengan 32 tidak bisa bermain.  Jadi pikiran itu datang - mengapa tidak?  Mengapa tidak mengaduk benteng 64-bit, dan bahkan dengan bytecode?  Ya, dan di Linux, di mana saya juga tidak menulis sistem apa pun. <br><br>  Saya memiliki server rumah dengan Linux.  Secara umum, saya sedikit Google dan menemukan bahwa assembler di Linux disebut GAS, dan perintah sebagai.  Saya terhubung melalui SSH ke server, mengetik - ya!  Saya sudah menginstalnya.  Masih butuh tautan, ketik ld - ya!  Jadi, dan cobalah untuk menulis sesuatu yang menarik di assembler.  Tanpa peradaban, hanya hutan, seperti orang India asli :) Tanpa lingkungan pengembangan, hanya baris perintah dan Komandan Tengah Malam.  Editornya adalah Nano, yang tergantung pada F4 saya di mc.  Bagaimana nyanyian kelompok "Nol"?  Orang India sejati hanya membutuhkan satu hal ... Apa lagi yang dibutuhkan orang India sejati?  Tentu saja, seorang debugger.  Kami mengetik gdb - is!  Nah, tekan Shift + F4, dan pergi! <br><a name="habracut"></a><br><h2>  Arsitektur </h2><br>  Sebagai permulaan, mari kita putuskan arsitektur.  Dengan kedalaman bit sudah ditentukan, 64 bit.  Dalam implementasi Fort klasik, segmen data dan kode adalah sama.  Tapi, kami akan mencoba melakukannya dengan benar.  Kami hanya akan memiliki kode di segmen kode, data di segmen data.  Sebagai hasilnya, kami mendapatkan kernel untuk platform dan kode byte sepenuhnya platform-independen. <br><br>  Mari kita coba untuk membuat mesin byte stack tercepat (tetapi tanpa JIT).  Jadi, kita akan memiliki tabel yang berisi 256 alamat - satu untuk setiap perintah byte.  Kurang dari apa pun - pemeriksaan tambahan, ini adalah 1-2 instruksi prosesor.  Dan kita perlu cepat, tanpa kompromi. <br><br><h4>  Tumpukan </h4><br>  Biasanya, dalam implementasi Fort, tumpukan kembali prosesor (* SP) digunakan sebagai tumpukan data, dan sistem pengembalian tumpukan diterapkan dengan menggunakan cara lain.  Memang, mesin kami akan ditumpuk, dan pekerjaan utamanya adalah pada tumpukan data.  Karena itu, mari kita lakukan hal yang sama - RSP akan menjadi tumpukan data.  Nah, biarkan stack kembali menjadi RBP, yang juga, secara default, berfungsi dengan segmen stack.  Dengan demikian, kita akan memiliki tiga segmen memori: segmen kode, segmen data dan segmen tumpukan (akan memiliki tumpukan data dan tumpukan kembali). <br><br><h4>  Daftar </h4><br>  Saya masuk ke deskripsi register x86-64, dan oops!  Ada sebanyak 8 register tujuan umum tambahan (R8 - R16), dibandingkan dengan mode 32 atau 16 bit ... <br><br>  Sudah memutuskan bahwa mereka akan membutuhkan RSP dan RBP.  Masih membutuhkan pointer (counter) dari perintah bytecode.  Dari operasi register ini, hanya pembacaan memori yang diperlukan.  Register utama (RAX, RBX, RCX, RDX, RSI, RDI) lebih fleksibel, universal, dengan mereka ada banyak perintah khusus.  Mereka akan berguna bagi kita untuk berbagai tugas, dan untuk konter instruksi bytecode kita mengambil salah satu register baru untukku, biarlah R8. <br><br><h2>  Mari kita mulai </h2><br>  Saya tidak punya pengalaman pemrograman di Linux dalam bahasa assembly.  Karena itu, sebagai permulaan, kami akan menemukan "Halo, dunia" yang telah selesai untuk memahami bagaimana program memulai dan menampilkan teks.  Tanpa diduga bagi saya, saya menemukan opsi dengan sintaks aneh di mana bahkan sumber dan penerima diatur ulang.  Ternyata, ini adalah sintaks AT&amp;T, dan sebagian besar ditulis di bawah GAS.  Tetapi opsi sintaks lain didukung, itu disebut sintaks Intel.  Berpikir, saya memutuskan untuk menggunakannya sama saja.  Nah, tulis di awal noprefix .intel_syntax. <br><br>  Kompilasi dan jalankan "Halo, dunia" untuk memastikan semuanya berfungsi.  Dengan membaca bantuan dan percobaan, saya mulai menggunakan perintah berikut untuk mengkompilasi: <br> <code>$ as fort.asm -o fort.o -g -ahlsm &gt;list.txt</code> <br>  Di sini, sakelar -o menunjukkan file hasil, sakelar -g menginstruksikan untuk menghasilkan informasi debug, dan sakelar -ahlsm menetapkan format daftar.  Dan saya menyimpan hasilnya dalam daftar, di dalamnya Anda dapat melihat banyak hal berguna.  Saya akui, pada awal pekerjaan saya tidak melakukan listing, dan bahkan tidak menentukan saklar -g.  Saya mulai menggunakan saklar -g setelah penggunaan pertama debugger, dan mulai melakukan daftar setelah makro muncul dalam kode :) <br><br>  Setelah itu, kami menggunakan tautan, tetapi tidak ada tempat yang lebih sederhana: <br><br> <code>$ ld forth.o -o forth</code> <br>  Lari! <br> <code>$ ./forth <br> Hello, world!</code> <br>  Itu bekerja. <br><br><div class="spoiler">  <b class="spoiler_title">Ini adalah pertama sebagainya.asme (sebenarnya itu adalah 'Hellow, dunia!', Tentu saja)</b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix .section .data msg: .ascii <span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span> len = . - msg #  len    .section .text .global _start #     _start: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   № <span class="hljs-number"><span class="hljs-number">4</span></span> — sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  № <span class="hljs-number"><span class="hljs-number">1</span></span> — <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, OFFSET FLAT:msg #     mov edx, len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   № <span class="hljs-number"><span class="hljs-number">1</span></span> — sys_exit xor ebx, ebx #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #  </code> </pre> <br>  By the way, saya kemudian menemukan bahwa di x86-64 lebih tepat menggunakan syscall untuk panggilan sistem, daripada int 0x80.  Panggilan 0x80 dianggap usang untuk arsitektur ini, meskipun didukung. <br></div></div><br>  Awal telah dibuat, dan sekarang ... <br><br><h2>  Ayo pergi! </h2><br>  Bahwa akan ada setidaknya beberapa spesifik, kita akan menulis kode perintah satu byte.  Biarkan itu menjadi kata Fort "0", menempatkan 0 di atas tumpukan: <br><br><pre> <code class="cpp hljs">bcmd_num0: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next</code> </pre><br>  Pada saat perintah ini dieksekusi, R8 sudah menunjuk ke perintah byte berikutnya.  Penting untuk membacanya, menambah R8, menentukan alamat yang dapat dieksekusi dengan kode perintah byte, dan mentransfer kontrol ke sana. <br><br>  Tapi ... berapa kedalaman bit dari tabel alamat byte-perintah?  Kemudian saya harus cukup menggali ke dalam sistem perintah x86-64 baru untuk saya.  Sayangnya, saya tidak menemukan perintah yang memungkinkan Anda pergi ke offset dalam memori.  Jadi, baik menghitung alamat, atau alamat akan siap - 64 bit.  Tidak ada waktu bagi kami untuk menghitung, yang berarti - 64 bit.  Dalam hal ini, ukuran tabel akan 256 * 8 = 4096 byte.  Akhirnya, enkode panggilan _next: <br><br><pre> <code class="cpp hljs">_next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>] <span class="hljs-meta"><span class="hljs-meta"># bcmd -   -</span></span></code> </pre><br>  Lumayan, menurut saya ... Hanya ada tiga instruksi prosesor, ketika beralih dari satu perintah byte ke yang lain. <br><br>  Sebenarnya, perintah-perintah ini tidak mudah bagi saya.  Saya harus mempelajari sistem perintah 0x86-64 lagi dan menemukan perintah MOVZX baru untuk saya.  Bahkan, perintah ini mengubah nilai 8, 16, atau 32 bit menjadi register 64-bit.  Ada dua varian dari perintah ini: unsigned, di mana digit yang lebih tinggi diisi dengan nol, dan yang ditandatangani adalah MOVSX.  Dalam versi yang ditandatangani, tanda itu mengembang, yaitu, untuk bilangan positif, nol akan menuju ke angka yang lebih tinggi, dan untuk yang negatif, yang.  Opsi ini juga berguna bagi kita untuk perintah byte byte. <br><br>  Omong-omong, apakah opsi ini yang tercepat?  Mungkin seseorang akan menyarankan lebih cepat? <br><br>  Nah, sekarang kita memiliki mesin byte yang dapat dijalankan melalui urutan perintah byte dan menjalankannya.  Penting untuk mengujinya dalam praktik, untuk memaksa mengeksekusi setidaknya satu tim.  Tapi yang mana?  Nol di tumpukan?  Tapi di sini Anda bahkan tidak tahu hasilnya, jika Anda tidak melihat tumpukan di bawah debugger ... Tetapi jika program dimulai, itu dapat diselesaikan :) <br><br>  Kami menulis perintah selamat tinggal yang menyelesaikan program dan menulis tentang hal itu, terutama karena kami memiliki "Hellow, dunia!". <br><br><pre> <code class="cpp hljs">bcmd_bye: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   № <span class="hljs-number"><span class="hljs-number">4</span></span> — sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  № <span class="hljs-number"><span class="hljs-number">1</span></span> — <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bye #     mov edx, msg_bye_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   № <span class="hljs-number"><span class="hljs-number">1</span></span> — sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #  </code> </pre><br>  Satu-satunya yang tersisa adalah membuat tabel alamat byte-perintah, menginisialisasi register, dan memulai mesin byte.  Jadi ... ada 256 nilai dalam tabel, dan ada dua perintah.  Apa yang ada di sel lain? <br>  Sisanya akan memiliki kode operasi yang tidak valid.  Tetapi, Anda tidak dapat melakukan pemeriksaan padanya, ini adalah tim tambahan, kami memiliki tiga tim sekarang, dan dengan cek itu akan menjadi lima.  Jadi, kita akan membuat perintah rintisan seperti itu - tim yang buruk.  Pertama, kita mengisi seluruh tabel untuk itu, dan kemudian kita mulai menempati sel dengan perintah yang berguna.  Biarkan tim yang buruk memiliki kode 0x00, tim selamat tinggal akan memiliki 0x01, dan '0' akan memiliki kode 0x02, begitu kode itu sudah ditulis.  Tim yang buruk sejauh ini akan melakukan hal yang sama dengan selamat tinggal, hanya dengan kode dan teks penyelesaian yang berbeda (saya akan meletakkannya di spoiler, hampir sama dengan selamat tinggal): <br><br><div class="spoiler">  <b class="spoiler_title">bcmd_bad</b> <div class="spoiler_text"><pre> <code class="cpp hljs">bcmd_bad: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   № <span class="hljs-number"><span class="hljs-number">4</span></span> — sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  № <span class="hljs-number"><span class="hljs-number">1</span></span> — <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bad_byte #     mov edx, msg_bad_byte_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   № <span class="hljs-number"><span class="hljs-number">1</span></span> — sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #  </code> </pre> </div></div>  Sekarang gambarkan daftar alamat.  Untuk kenyamanan, kita akan menempatkan delapan di setiap baris, akan ada 16 baris. Tabelnya cukup besar: <br><br><div class="spoiler">  <b class="spoiler_title">Tabel Alamat Perintah Byte</b> <div class="spoiler_text"><pre> <code class="cpp hljs">bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad</code> </pre> </div></div>  Kami menulis isi dari program byte.  Untuk melakukan ini, tetapkan kode perintah ke variabel assembler.  Kami akan memiliki perjanjian berikut: <br><br><ul><li>  Alamat untuk mengeksekusi perintah byte akan dimulai pada bcmd_ </li><li>  Kode perintah itu sendiri akan disimpan dalam variabel yang dimulai dengan b_ </li></ul><br>  Dengan demikian, isi dari program byte akan seperti ini: <br><br><pre> <code class="cpp hljs">start: .byte b_bye</code> </pre><br>  Nyatakan ukuran tumpukan data sebagai stack_size.  Biarkan sejauh ini 1024. Pada inisialisasi, kita akan melakukan RBP = RSP - stack_size. <br><br><div class="spoiler">  <b class="spoiler_title">Sebenarnya, kami mendapatkan kode program seperti itu (sebagainya.asm)</b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix stack_size = <span class="hljs-number"><span class="hljs-number">1024</span></span> .section .data msg_bad_byte: .ascii <span class="hljs-string"><span class="hljs-string">"Bad byte code!\n"</span></span> msg_bad_byte_len = . - msg_bad_byte #  len    msg_bye: .ascii <span class="hljs-string"><span class="hljs-string">"bye!\n"</span></span> msg_bye_len = . - msg_bye msg_hello: .ascii <span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span> msg_hello_len = . - msg_hello bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad start: .byte b_bye .section .text .global _start #     _start: mov rbp, rsp sub rbp, stack_size lea r8, start jmp _next _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>] b_bad = <span class="hljs-number"><span class="hljs-number">0x00</span></span> bcmd_bad: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   № <span class="hljs-number"><span class="hljs-number">4</span></span> — sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  № <span class="hljs-number"><span class="hljs-number">1</span></span> — <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bad_byte #     mov edx, msg_bad_byte_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   № <span class="hljs-number"><span class="hljs-number">1</span></span> — sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_bye = <span class="hljs-number"><span class="hljs-number">0x01</span></span> bcmd_bye: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   № <span class="hljs-number"><span class="hljs-number">4</span></span> — sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  № <span class="hljs-number"><span class="hljs-number">1</span></span> — <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bye #     mov edx, msg_bye_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   № <span class="hljs-number"><span class="hljs-number">1</span></span> — sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_num0 = <span class="hljs-number"><span class="hljs-number">0x02</span></span> bcmd_num0: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next</code> </pre><br></div></div><br>  Kompilasi, jalankan: <br><br> <code>$ as fort.asm -o fort.o -g -ahlsm &gt;list.txt <br> $ ld forth.o -o forth <br> $ ./forth <br> bye! <br></code> <br>  Itu berhasil!  Program bytecode pertama kami dari satu byte diluncurkan :) <br>  Tentu saja, ini akan terjadi jika semuanya dilakukan dengan benar.  Dan jika tidak, hasilnya mungkin seperti ini: <br><br> <code>$ ./forth <br>   <br></code> <br>  Tentu saja, opsi lain dimungkinkan, tetapi saya telah menemukan ini paling sering.  Dan kami membutuhkan debugger. <br><br><div class="spoiler">  <b class="spoiler_title">Lirik Debugger</b> <div class="spoiler_text">  Seperti yang sudah disebutkan, saya menggunakan GDB.  Ini adalah debugger yang sangat kuat, tetapi dengan antarmuka baris perintah.  Menjalankannya sangat sederhana: <br><br><pre> <code class="plaintext hljs">$ gdb ./forth GNU gdb (Ubuntu 7.11.1-0ubuntu1~16.5) 7.11.1 Copyright (C) 2016 Free Software Foundation, Inc. License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt; This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. Type "show copying" and "show warranty" for details. This GDB was configured as "x86_64-linux-gnu". Type "show configuration" for configuration details. For bug reporting instructions, please see: &lt;http://www.gnu.org/software/gdb/bugs/&gt;. Find the GDB manual and other documentation resources online at: &lt;http://www.gnu.org/software/gdb/documentation/&gt;. For help, type "help". Type "apropos word" to search for commands related to "word"... Reading symbols from ./forth...done. (gdb)</code> </pre> <br>  Selanjutnya, dengan memasukkan perintah, kami melakukan debug.  Saya punya cukup waktu untuk menemukan beberapa perintah yang diperlukan dan belajar cara menggunakannya untuk debugging.  Inilah mereka: <br>  b &lt;label&gt; - atur breakpoint <br>  l &lt;label&gt; - lihat kode sumber <br>  r - mulai atau mulai ulang program <br>  ir - lihat status register prosesor <br>  s - step <br><br>  Omong-omong, ingat bahwa Anda perlu mengkompilasi program dengan -g switch?  Jika tidak, tag dan kode sumber tidak akan tersedia.  Dalam hal ini, akan mungkin untuk melakukan debug hanya dengan kode yang dibongkar dan menggunakan alamat dalam memori.  Kami, tentu saja, adalah orang India, tetapi tidak pada tingkat yang sama ... </div></div><br>  Tetapi entah bagaimana programnya tidak banyak.  Kami hanya mengatakan "Halo" padanya, dan dia segera mengatakan "Sampai jumpa!".  Mari kita buat "Halo dunia!"  pada bytecode.  Untuk melakukan ini, letakkan alamat dan panjang string pada stack, kemudian jalankan perintah yang menampilkan string, dan kemudian perintah bye.  Untuk melakukan semua ini, diperlukan perintah baru: ketik untuk menampilkan string, dan menyala untuk meletakkan alamat dan panjang string.  Pertama kita tulis ketik, biarkan kodenya 0x80.  Kami, sekali lagi, membutuhkan kode itu dengan panggilan sys_write: <br><br><pre> <code class="cpp hljs">b_type = <span class="hljs-number"><span class="hljs-number">0x80</span></span> bcmd_type: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   № <span class="hljs-number"><span class="hljs-number">4</span></span> — sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  № <span class="hljs-number"><span class="hljs-number">1</span></span> — <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx pop rcx push r8 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   pop r8 jmp _next</code> </pre><br>  Di sini kita mengambil alamat dan panjang string dari tumpukan data menggunakan perintah POP.  Memanggil int 0x80 dapat mengubah register R8, jadi kami menyimpannya.  Kami tidak melakukan ini sebelumnya karena program ini berakhir.  Isi register ini tidak peduli.  Sekarang ini adalah perintah byte reguler, setelah itu kode byte terus dieksekusi, dan Anda perlu berperilaku sendiri. <br><br>  Sekarang mari kita tuliskan lit.  Ini akan menjadi tim pertama kami dengan parameter.  Setelah byte dengan kode untuk perintah ini, akan ada byte yang berisi nomor yang akan diletakkan di stack.  Pertanyaan segera muncul - kedalaman bit apa yang dibutuhkan di sini?  Untuk memasukkan nomor apa pun, Anda perlu 64 bit.  Tapi, setiap kali perintah akan menempati 9 byte, apa yang akan menempatkan satu angka?  Jadi kita kehilangan kekompakan, salah satu sifat utama bytecode, dan kode benteng juga ... <br><br>  Solusinya sederhana - kami akan membuat beberapa perintah untuk kedalaman bit yang berbeda.  Ini akan menjadi lit8, lit16, lit32 dan lit64.  Untuk angka kecil kita akan menggunakan lit8 dan lit16, untuk angka yang lebih besar - lit32 dan lit64.  Jumlah kecil paling sering digunakan, dan bagi mereka akan ada perintah terpendek, yang membutuhkan dua byte.  Tidak buruk! .. Kami akan membuat kode dari perintah ini 0x08 - 0x0B. <br><br><pre> <code class="cpp hljs">b_lit8 = <span class="hljs-number"><span class="hljs-number">0x08</span></span> bcmd_lit8: movsx rax, byte ptr [r8] inc r8 push rax jmp _next b_lit16 = <span class="hljs-number"><span class="hljs-number">0x09</span></span> bcmd_lit16: movsx rax, word ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> push rax jmp _next b_lit32 = <span class="hljs-number"><span class="hljs-number">0x0A</span></span> bcmd_lit32: movsx rax, dword ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> push rax jmp _next b_lit64 = <span class="hljs-number"><span class="hljs-number">0x0B</span></span> bcmd_lit64: mov rax, [r8] add r8, <span class="hljs-number"><span class="hljs-number">8</span></span> push rax jmp _next</code> </pre> <br>  Di sini kita menggunakan perintah MOVSX - ini adalah versi ikon dari perintah MOVZX yang sudah kita kenal.  R8 kami memiliki penghitung perintah byte.  Kami memuat nilai ukuran yang diinginkan di atasnya, memindahkannya ke perintah berikutnya, dan menempatkan nilai dikonversi ke 64 bit ke tumpukan. <br><br>  <b>Jangan lupa untuk menambahkan alamat tim baru di tabel ke posisi yang diinginkan.</b> <br><br>  Itu semua siap untuk menulis program pertama Anda "Halo, dunia!"  pada bytecode kami.  Mari bekerja dengan kompiler!  :) <br><br><pre> <code class="cpp hljs">start: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_bye</code> </pre> <br>  Kami menggunakan dua perintah lit berbeda: lit64, yang akan meletakkan alamat string pada stack, dan lit8, yang dengannya kami meletakkan panjangnya di stack.  Selanjutnya, kita menjalankan dua perintah byte lagi: ketik dan bye. <br>  Kompilasi, jalankan: <br><br><pre> <code class="plaintext hljs">$ as fort.asm -o fort.o -g -ahlsm &gt;list.txt $ ld forth.o -o forth $ ./forth Hello, world! bye!</code> </pre><br>  Hasilkan bytecode kami!  Ini adalah hasil yang seharusnya jika semuanya normal. <br><br><div class="spoiler">  <b class="spoiler_title">Sumber lengkap</b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix stack_size = <span class="hljs-number"><span class="hljs-number">1024</span></span> .section .data msg_bad_byte: .ascii <span class="hljs-string"><span class="hljs-string">"Bad byte code!\n"</span></span> msg_bad_byte_len = . - msg_bad_byte #  len    msg_bye: .ascii <span class="hljs-string"><span class="hljs-string">"bye!\n"</span></span> msg_bye_len = . - msg_bye msg_hello: .ascii <span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span> msg_hello_len = . - msg_hello bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x00</span></span> .quad bcmd_lit8, bcmd_lit16, bcmd_lit32, bcmd_lit64, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x10</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x20</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x30</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x40</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x60</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_type, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x80</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad start: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_bye .section .text .global _start #     _start: mov rbp, rsp sub rbp, stack_size lea r8, start jmp _next _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>] b_bad = <span class="hljs-number"><span class="hljs-number">0x00</span></span> bcmd_bad: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   № <span class="hljs-number"><span class="hljs-number">4</span></span> — sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  № <span class="hljs-number"><span class="hljs-number">1</span></span> — <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bad_byte #     mov edx, msg_bad_byte_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   № <span class="hljs-number"><span class="hljs-number">1</span></span> — sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_bye = <span class="hljs-number"><span class="hljs-number">0x01</span></span> bcmd_bye: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   № <span class="hljs-number"><span class="hljs-number">4</span></span> — sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  № <span class="hljs-number"><span class="hljs-number">1</span></span> — <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bye #     mov edx, msg_bye_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   № <span class="hljs-number"><span class="hljs-number">1</span></span> — sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_num0 = <span class="hljs-number"><span class="hljs-number">0x02</span></span> bcmd_num0: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next b_lit8 = <span class="hljs-number"><span class="hljs-number">0x08</span></span> bcmd_lit8: movsx rax, byte ptr [r8] inc r8 push rax jmp _next b_lit16 = <span class="hljs-number"><span class="hljs-number">0x09</span></span> bcmd_lit16: movsx rax, word ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> push rax jmp _next b_lit32 = <span class="hljs-number"><span class="hljs-number">0x0A</span></span> bcmd_lit32: movsx rax, dword ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> push rax jmp _next b_lit64 = <span class="hljs-number"><span class="hljs-number">0x0B</span></span> bcmd_lit64: mov rax, [r8] add r8, <span class="hljs-number"><span class="hljs-number">8</span></span> push rax jmp _next b_type = <span class="hljs-number"><span class="hljs-number">0x80</span></span> bcmd_type: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   № <span class="hljs-number"><span class="hljs-number">4</span></span> — sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  № <span class="hljs-number"><span class="hljs-number">1</span></span> — <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx pop rcx push r8 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   pop r8 jmp _next</code> </pre> <br></div></div><br>  Tetapi kemungkinannya masih sangat primitif, Anda tidak dapat membuat suatu kondisi, sebuah siklus. <br><br>  Bagaimana tidak mungkin?  Anda bisa, semuanya ada di tangan kita!  Mari kita lakukan baris ini dalam loop 10 kali.  Ini akan membutuhkan perintah cabang kondisional, serta sedikit aritmatika tumpukan: perintah yang mengurangi nilai pada tumpukan dengan 1 (pada benteng “1-”) dan perintah duplikasi simpul (“dup”). <br><br>  Dengan aritmatika, semuanya sederhana, saya bahkan tidak akan berkomentar: <br><br><pre> <code class="cpp hljs">b_dup = <span class="hljs-number"><span class="hljs-number">0x18</span></span> bcmd_dup: push [rsp] jmp _next b_wm = <span class="hljs-number"><span class="hljs-number">0x20</span></span> bcmd_wm: decq [rsp] jmp _next</code> </pre> <br>  Sekarang lompatan bersyarat.  Sebagai permulaan, mari kita buat tugas lebih sederhana - transisi tanpa syarat.  Jelas bahwa Anda hanya perlu mengubah nilai register R8.  Hal pertama yang terlintas dalam pikiran adalah perintah byte, diikuti oleh parameter - alamat transisi adalah 64 bit.  Sekali lagi sembilan byte.  Apakah kita memerlukan sembilan byte ini?  Transisi biasanya terjadi pada jarak pendek, seringkali dalam beberapa ratus byte.  Jadi, kita akan menggunakan bukan alamatnya, tetapi offsetnya! <br><br>  Agak dalam?  Dalam banyak kasus, 8 bit (127 maju / mundur) sudah cukup, tetapi kadang-kadang ini tidak cukup.  Oleh karena itu, kami akan melakukan hal yang sama dengan perintah yang menyala, kami akan membuat dua opsi - 8 dan 16 digit, kode perintah akan menjadi 0x10 dan 0x11: <br><br><pre> <code class="cpp hljs">b_branch8 = <span class="hljs-number"><span class="hljs-number">0x10</span></span> bcmd_branch8: movsx rax, byte ptr [r8] add r8, rax jmp _next b_branch16 = <span class="hljs-number"><span class="hljs-number">0x11</span></span> bcmd_branch16: movsx rax, word ptr [r8] add r8, rax jmp _next</code> </pre>  Sekarang transisi bersyarat mudah diimplementasikan.  Jika tumpukannya 0, buka _next, dan jika tidak, buka perintah branch! <br><pre> <code class="cpp hljs">b_qbranch8 = <span class="hljs-number"><span class="hljs-number">0x12</span></span> bcmd_qbranch8: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch8 inc r8 jmp _next b_qbranch16 = <span class="hljs-number"><span class="hljs-number">0x13</span></span> bcmd_qbranch16: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch16 add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> jmp _next</code> </pre><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sekarang kita memiliki segalanya untuk membuat lingkaran: </font></font><pre> <code class="cpp hljs">start: .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">10</span></span> #  #  m0: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_wm .byte b_dup .byte b_qbranch8 .byte m0 - . .byte b_bye</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dua perintah pertama - kita meletakkan penghitung loop pada stack. </font><font style="vertical-align: inherit;">Selanjutnya, cetak string Halo. </font><font style="vertical-align: inherit;">Kemudian kita kurangi 1 dari penghitung, duplikat dan lakukan (atau tidak melakukan) transisi. </font><font style="vertical-align: inherit;">Perintah duplikasi diperlukan karena perintah cabang bersyarat mengambil nilai dari atas tumpukan. </font><font style="vertical-align: inherit;">Transisi di sini adalah delapan-bit, karena jaraknya hanya beberapa byte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menempatkan alamat perintah baru dalam sebuah tabel, kompilasi dan eksekusi.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya akan meletakkannya di spoiler, jika tidak program kami menjadi verbose)</font></font></b> <div class="spoiler_text"><pre> <code class="plaintext hljs">$ as fort.asm -o fort.o -g -ahlsm &gt;list.txt $ ld forth.o -o forth $ ./forth Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! bye!</code> </pre><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Yah, kita sudah bisa melakukan kondisi dan siklus! </font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sumber lengkap</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix stack_size = <span class="hljs-number"><span class="hljs-number">1024</span></span> .section .data msg_bad_byte: .ascii <span class="hljs-string"><span class="hljs-string">"Bad byte code!\n"</span></span> msg_bad_byte_len = . - msg_bad_byte #  len    msg_bye: .ascii <span class="hljs-string"><span class="hljs-string">"bye!\n"</span></span> msg_bye_len = . - msg_bye msg_hello: .ascii <span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span> msg_hello_len = . - msg_hello bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x00</span></span> .quad bcmd_lit8, bcmd_lit16, bcmd_lit32, bcmd_lit64, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_branch8, bcmd_branch16, bcmd_qbranch8, bcmd_qbranch16, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x10</span></span> .quad bcmd_dup, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_wm, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x20</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x30</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x40</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x60</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_type, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x80</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad start: .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">10</span></span> #  #  m0: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_wm .byte b_dup .byte b_qbranch8 .byte m0 - . .byte b_bye .section .text .global _start #     _start: mov rbp, rsp sub rbp, stack_size lea r8, start jmp _next _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>] b_bad = <span class="hljs-number"><span class="hljs-number">0x00</span></span> bcmd_bad: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   № <span class="hljs-number"><span class="hljs-number">4</span></span> — sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  № <span class="hljs-number"><span class="hljs-number">1</span></span> — <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bad_byte #     mov edx, msg_bad_byte_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   № <span class="hljs-number"><span class="hljs-number">1</span></span> — sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_bye = <span class="hljs-number"><span class="hljs-number">0x01</span></span> bcmd_bye: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   № <span class="hljs-number"><span class="hljs-number">4</span></span> — sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  № <span class="hljs-number"><span class="hljs-number">1</span></span> — <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bye #     mov edx, msg_bye_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   № <span class="hljs-number"><span class="hljs-number">1</span></span> — sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_num0 = <span class="hljs-number"><span class="hljs-number">0x02</span></span> bcmd_num0: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next b_lit8 = <span class="hljs-number"><span class="hljs-number">0x08</span></span> bcmd_lit8: movsx rax, byte ptr [r8] inc r8 push rax jmp _next b_lit16 = <span class="hljs-number"><span class="hljs-number">0x09</span></span> bcmd_lit16: movsx rax, word ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> push rax jmp _next b_lit32 = <span class="hljs-number"><span class="hljs-number">0x0A</span></span> bcmd_lit32: movsx rax, dword ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> push rax jmp _next b_lit64 = <span class="hljs-number"><span class="hljs-number">0x0B</span></span> bcmd_lit64: mov rax, [r8] add r8, <span class="hljs-number"><span class="hljs-number">8</span></span> push rax jmp _next b_type = <span class="hljs-number"><span class="hljs-number">0x80</span></span> bcmd_type: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   № <span class="hljs-number"><span class="hljs-number">4</span></span> — sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  № <span class="hljs-number"><span class="hljs-number">1</span></span> — <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx pop rcx push r8 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   pop r8 jmp _next b_dup = <span class="hljs-number"><span class="hljs-number">0x18</span></span> bcmd_dup: push [rsp] jmp _next b_wm = <span class="hljs-number"><span class="hljs-number">0x20</span></span> bcmd_wm: decq [rsp] jmp _next b_branch8 = <span class="hljs-number"><span class="hljs-number">0x10</span></span> bcmd_branch8: movsx rax, byte ptr [r8] add r8, rax jmp _next b_branch16 = <span class="hljs-number"><span class="hljs-number">0x11</span></span> bcmd_branch16: movsx rax, word ptr [r8] add r8, rax jmp _next b_qbranch8 = <span class="hljs-number"><span class="hljs-number">0x12</span></span> bcmd_qbranch8: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch8 inc r8 jmp _next b_qbranch16 = <span class="hljs-number"><span class="hljs-number">0x13</span></span> bcmd_qbranch16: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch16 add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> jmp _next</code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi sampai mesin byte yang lengkap hilang fungsi lain yang sangat penting. </font><font style="vertical-align: inherit;">Kami tidak dapat memanggil orang lain dari bytecode. </font><font style="vertical-align: inherit;">Kami tidak memiliki apa yang disebut rutinitas, prosedur, dll. </font><font style="vertical-align: inherit;">Dan di benteng, tanpa ini, kita tidak bisa menggunakan kata-kata selain kata-kata inti dalam beberapa kata. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami membawa pekerjaan sampai akhir. </font><font style="vertical-align: inherit;">Di sini untuk pertama kalinya kami membutuhkan setumpuk pengembalian. </font><font style="vertical-align: inherit;">Diperlukan dua perintah - perintah panggilan dan perintah kembali (panggilan dan keluar).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perintah panggilan, pada prinsipnya, melakukan hal yang sama seperti cabang - mentransfer kontrol ke bytecode lain. </font><font style="vertical-align: inherit;">Tapi, tidak seperti cabang, Anda masih perlu menyimpan alamat pengirim di tumpukan kembali sehingga Anda bisa kembali dan melanjutkan eksekusi. </font><font style="vertical-align: inherit;">Ada perbedaan lain - panggilan tersebut dapat terjadi pada jarak yang jauh lebih besar. </font><font style="vertical-align: inherit;">Oleh karena itu, kami membuat perintah panggilan dalam rupa cabang, tetapi dalam tiga versi - 8, 16 dan 32 bit.</font></font><br><br><pre> <code class="cpp hljs">b_call8 = <span class="hljs-number"><span class="hljs-number">0x0C</span></span> bcmd_call8: movsx rax, byte ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> inc r8 mov [rbp], r8 add r8, rax jmp _next b_call16 = <span class="hljs-number"><span class="hljs-number">0x0D</span></span> bcmd_call16: movsx rax, word ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> mov [rbp], r8 add r8, rax jmp _next b_call32 = <span class="hljs-number"><span class="hljs-number">0x0E</span></span> bcmd_call32: movsx rax, dword ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> mov [rbp], r8 add r8, rax jmp _next</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang Anda lihat, di sini, tidak seperti transisi, 3 tim ditambahkan. Salah satunya mengatur ulang R8 ke perintah byte berikutnya, dan dua sisanya menyimpan nilai yang diterima dalam tumpukan kembali. Ngomong-ngomong, di sini saya mencoba untuk tidak meletakkan instruksi prosesor yang saling bergantung satu sama lain, sehingga conveyor prosesor dapat menjalankan perintah secara paralel. Tapi saya tidak tahu berapa banyak ini memberikan efek. Jika diinginkan, maka Anda dapat memeriksa tes. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Harus diingat bahwa pembentukan argumen untuk perintah panggilan agak berbeda dari untuk cabang. Untuk cabang, offset dihitung sebagai perbedaan antara alamat cabang dan alamat byte mengikuti perintah byte. Dan untuk perintah panggilan, ini adalah perbedaan antara alamat lompat dan alamat perintah berikutnya.</font></font> Mengapa ini dibutuhkan?<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini menghasilkan lebih sedikit instruksi prosesor. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang perintah kembali. </font><font style="vertical-align: inherit;">Sebenarnya, tugasnya hanya mengembalikan R8 dari stack kembali dan mentransfer kontrol ke mesin byte lebih lanjut:</font></font><br><br><pre> <code class="cpp hljs">b_exit = <span class="hljs-number"><span class="hljs-number">0x1F</span></span> bcmd_exit: mov r8, [rbp] add rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> jmp _next</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perintah-perintah ini akan digunakan sangat sering, dan mereka perlu dioptimalkan secara maksimal. </font><font style="vertical-align: inherit;">Perintah byte keluar menempati tiga instruksi mesin. </font><font style="vertical-align: inherit;">Apakah mungkin untuk mengurangi sesuatu di sini? </font><font style="vertical-align: inherit;">Ternyata kamu bisa! </font><font style="vertical-align: inherit;">Anda cukup menghapus perintah transisi :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk melakukan ini, letakkan di atas titik masuk mesin byte _next:</font></font><br><br><pre> <code class="cpp hljs">b_exit = <span class="hljs-number"><span class="hljs-number">0x1F</span></span> bcmd_exit: mov r8, [rbp] add rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">By the way, perintah yang paling penting dan sering digunakan (misalnya, seperti panggilan) perlu ditempatkan lebih dekat ke mesin byte sehingga kompiler dapat membentuk perintah lompatan pendek. </font><font style="vertical-align: inherit;">Ini terlihat jelas dalam daftar. </font><font style="vertical-align: inherit;">Berikut ini sebuah contoh.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-number"><span class="hljs-number">262</span></span> <span class="hljs-number"><span class="hljs-number">0084</span></span> <span class="hljs-number"><span class="hljs-number">490F</span></span>BE00 bcmd_lit8: movsx rax, byte ptr [r8] <span class="hljs-number"><span class="hljs-number">263</span></span> <span class="hljs-number"><span class="hljs-number">0088</span></span> <span class="hljs-number"><span class="hljs-number">49F</span></span>FC0 inc r8 <span class="hljs-number"><span class="hljs-number">264</span></span> <span class="hljs-number"><span class="hljs-number">008b</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span> push rax <span class="hljs-number"><span class="hljs-number">265</span></span> <span class="hljs-number"><span class="hljs-number">008</span></span>c EB90 jmp _next <span class="hljs-number"><span class="hljs-number">266</span></span> <span class="hljs-number"><span class="hljs-number">267</span></span> b_lit16 = <span class="hljs-number"><span class="hljs-number">0x09</span></span> <span class="hljs-number"><span class="hljs-number">268</span></span> <span class="hljs-number"><span class="hljs-number">008</span></span>e <span class="hljs-number"><span class="hljs-number">490F</span></span>BF00 bcmd_lit16: movsx rax, word ptr [r8] <span class="hljs-number"><span class="hljs-number">269</span></span> <span class="hljs-number"><span class="hljs-number">0092</span></span> <span class="hljs-number"><span class="hljs-number">4983</span></span>C002 add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">270</span></span> <span class="hljs-number"><span class="hljs-number">0096</span></span> <span class="hljs-number"><span class="hljs-number">50</span></span> push rax <span class="hljs-number"><span class="hljs-number">271</span></span> <span class="hljs-number"><span class="hljs-number">0097</span></span> EB85 jmp _next <span class="hljs-number"><span class="hljs-number">272</span></span> <span class="hljs-number"><span class="hljs-number">273</span></span> b_lit32 = <span class="hljs-number"><span class="hljs-number">0x0A</span></span> <span class="hljs-number"><span class="hljs-number">274</span></span> <span class="hljs-number"><span class="hljs-number">0099</span></span> <span class="hljs-number"><span class="hljs-number">496300</span></span> bcmd_lit32: movsx rax, dword ptr [r8] <span class="hljs-number"><span class="hljs-number">275</span></span> <span class="hljs-number"><span class="hljs-number">009</span></span>c <span class="hljs-number"><span class="hljs-number">4983</span></span>C004 add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">276</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span>a0 <span class="hljs-number"><span class="hljs-number">50</span></span> push rax <span class="hljs-number"><span class="hljs-number">277</span></span> <span class="hljs-number"><span class="hljs-number">00</span></span>a1 E978FFFF jmp _next <span class="hljs-number"><span class="hljs-number">277</span></span> FF <span class="hljs-number"><span class="hljs-number">278</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sini, pada baris 265 dan 271, perintah jmp masing-masing mengambil 2 byte, dan pada baris 277, perintah yang sama sudah dikompilasi menjadi 5 byte, karena jarak lompatan melebihi panjang perintah pendek. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oleh karena itu, perintah byte seperti bad, bye, type diatur ulang lebih lanjut, dan seperti panggilan, cabang, lit lebih dekat. Sayangnya, tidak banyak yang dapat ditampung dalam transisi 127 byte. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami menambahkan perintah baru ke tabel alamat perintah sesuai dengan kode mereka. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, kami sekarang memiliki tantangan dan pengembalian, kami akan menguji mereka! Untuk melakukan ini, pilih jalur cetak dalam prosedur terpisah, dan kami akan memanggilnya secara berulang dua kali. Dan jumlah pengulangan siklus dikurangi menjadi tiga.</font></font><br><br><pre> <code class="cpp hljs">start: .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">3</span></span> #  #  m0: .byte b_call16 .word sub_hello - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word sub_hello - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_wm .byte b_dup .byte b_qbranch8 .byte m0 - . .byte b_bye sub_hello: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_exit</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Call8 dapat digunakan di sini, tetapi saya memutuskan untuk menggunakan call16 sebagai yang paling mungkin digunakan. </font><font style="vertical-align: inherit;">Nilai 2 dikurangi karena keanehan menghitung alamat untuk perintah byte panggilan yang saya tulis. </font><font style="vertical-align: inherit;">Untuk call8, 1 akan dikurangkan di sini, untuk call32, masing-masing, 4. Kami </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">mengkompilasi dan memanggil:</font></font><br><br><pre> <code class="plaintext hljs">$ as forth.asm -o forth.o -g -ahlsm&gt;list.txt $ ld forth.o -o forth $ ./forth Hello, world! Bad byte code!</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ups ... seperti kata mereka, ada yang salah :) Yah, kami meluncurkan GDB dan melihat apa yang terjadi di sana. </font><font style="vertical-align: inherit;">Saya segera menetapkan breakpoint pada bcmd_exit, karena jelas bahwa panggilan sub_hello sudah lewat, dan badan prosedur sedang mengeksekusi ... diluncurkan ... dan program tidak mencapai breakpoint. </font><font style="vertical-align: inherit;">Segera ada kecurigaan kode perintah byte. </font><font style="vertical-align: inherit;">Dan, memang, alasannya ada di dalam dirinya. </font><font style="vertical-align: inherit;">b_exit Saya menetapkan nilai 0x1f, dan alamat itu sendiri ditempatkan di nomor sel tabel 0x17. </font><font style="vertical-align: inherit;">Baiklah, maka saya akan memperbaiki nilai b_exit ke 0x17 dan coba lagi:</font></font><br><br><pre> <code class="plaintext hljs">$ as forth.asm -o forth.o -g -ahlsm&gt;list.txt $ ld forth.o -o forth $ ./forth Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! Hello, world! bye!</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tepat enam kali sapaan, dan sekali selamat tinggal. </font><font style="vertical-align: inherit;">Seperti yang seharusnya :)</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sumber lengkap</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix stack_size = <span class="hljs-number"><span class="hljs-number">1024</span></span> .section .data msg_bad_byte: .ascii <span class="hljs-string"><span class="hljs-string">"Bad byte code!\n"</span></span> msg_bad_byte_len = . - msg_bad_byte #  len    msg_bye: .ascii <span class="hljs-string"><span class="hljs-string">"bye!\n"</span></span> msg_bye_len = . - msg_bye msg_hello: .ascii <span class="hljs-string"><span class="hljs-string">"Hello, world!\n"</span></span> msg_hello_len = . - msg_hello bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x00</span></span> .quad bcmd_lit8, bcmd_lit16, bcmd_lit32, bcmd_lit64, bcmd_call8, bcmd_call16, bcmd_call32, bcmd_bad .quad bcmd_branch8, bcmd_branch16, bcmd_qbranch8, bcmd_qbranch16, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_exit # <span class="hljs-number"><span class="hljs-number">0x10</span></span> .quad bcmd_dup, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_wm, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x20</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x30</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x40</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x60</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_type, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x80</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad start: .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">3</span></span> #  #  m0: .byte b_call16 .word sub_hello - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word sub_hello - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_wm .byte b_dup .byte b_qbranch8 .byte m0 - . .byte b_bye sub_hello: .byte b_lit64 .quad msg_hello .byte b_lit8 .byte msg_hello_len .byte b_type .byte b_exit .section .text .global _start #     _start: mov rbp, rsp sub rbp, stack_size lea r8, start jmp _next b_exit = <span class="hljs-number"><span class="hljs-number">0x17</span></span> bcmd_exit: mov r8, [rbp] add rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*<span class="hljs-number"><span class="hljs-number">8</span></span>] b_num0 = <span class="hljs-number"><span class="hljs-number">0x02</span></span> bcmd_num0: push <span class="hljs-number"><span class="hljs-number">0</span></span> jmp _next b_lit8 = <span class="hljs-number"><span class="hljs-number">0x08</span></span> bcmd_lit8: movsx rax, byte ptr [r8] inc r8 push rax jmp _next b_lit16 = <span class="hljs-number"><span class="hljs-number">0x09</span></span> bcmd_lit16: movsx rax, word ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> push rax jmp _next b_call8 = <span class="hljs-number"><span class="hljs-number">0x0C</span></span> bcmd_call8: movsx rax, byte ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> inc r8 mov [rbp], r8 add r8, rax jmp _next b_call16 = <span class="hljs-number"><span class="hljs-number">0x0D</span></span> bcmd_call16: movsx rax, word ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> mov [rbp], r8 add r8, rax jmp _next b_call32 = <span class="hljs-number"><span class="hljs-number">0x0E</span></span> bcmd_call32: movsx rax, dword ptr [r8] sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> mov [rbp], r8 add r8, rax jmp _next b_lit32 = <span class="hljs-number"><span class="hljs-number">0x0A</span></span> bcmd_lit32: movsx rax, dword ptr [r8] add r8, <span class="hljs-number"><span class="hljs-number">4</span></span> push rax jmp _next b_lit64 = <span class="hljs-number"><span class="hljs-number">0x0B</span></span> bcmd_lit64: mov rax, [r8] add r8, <span class="hljs-number"><span class="hljs-number">8</span></span> push rax jmp _next b_dup = <span class="hljs-number"><span class="hljs-number">0x18</span></span> bcmd_dup: push [rsp] jmp _next b_wm = <span class="hljs-number"><span class="hljs-number">0x20</span></span> bcmd_wm: decq [rsp] jmp _next b_branch8 = <span class="hljs-number"><span class="hljs-number">0x10</span></span> bcmd_branch8: movsx rax, byte ptr [r8] add r8, rax jmp _next b_branch16 = <span class="hljs-number"><span class="hljs-number">0x11</span></span> bcmd_branch16: movsx rax, word ptr [r8] add r8, rax jmp _next b_qbranch8 = <span class="hljs-number"><span class="hljs-number">0x12</span></span> bcmd_qbranch8: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch8 inc r8 jmp _next b_qbranch16 = <span class="hljs-number"><span class="hljs-number">0x13</span></span> bcmd_qbranch16: pop rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jnz bcmd_branch16 add r8, <span class="hljs-number"><span class="hljs-number">2</span></span> jmp _next b_bad = <span class="hljs-number"><span class="hljs-number">0x00</span></span> bcmd_bad: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   № <span class="hljs-number"><span class="hljs-number">4</span></span> — sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  № <span class="hljs-number"><span class="hljs-number">1</span></span> — <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bad_byte #     mov edx, msg_bad_byte_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   № <span class="hljs-number"><span class="hljs-number">1</span></span> — sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #    <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_bye = <span class="hljs-number"><span class="hljs-number">0x01</span></span> bcmd_bye: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   № <span class="hljs-number"><span class="hljs-number">4</span></span> — sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  № <span class="hljs-number"><span class="hljs-number">1</span></span> — <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov ecx, offset msg_bye #     mov edx, msg_bye_len #   <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   mov eax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   № <span class="hljs-number"><span class="hljs-number">1</span></span> — sys_exit mov ebx, <span class="hljs-number"><span class="hljs-number">0</span></span> #    <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   b_type = <span class="hljs-number"><span class="hljs-number">0x80</span></span> bcmd_type: mov eax, <span class="hljs-number"><span class="hljs-number">4</span></span> #   № <span class="hljs-number"><span class="hljs-number">4</span></span> — sys_write mov ebx, <span class="hljs-number"><span class="hljs-number">1</span></span> #  № <span class="hljs-number"><span class="hljs-number">1</span></span> — <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx pop rcx push r8 <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span> #   pop r8 jmp _next</code> </pre><br></div></div><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apa hasilnya </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami melakukan dan menguji mesin byte byte 64-bit yang lengkap dan cukup cepat. Dalam kecepatan, mungkin mesin byte ini akan menjadi salah satu yang tercepat di kelasnya (mesin stack byte tanpa JIT). Dia tahu bagaimana mengeksekusi perintah secara berurutan, melakukan lompatan bersyarat dan tanpa syarat, prosedur panggilan, dan kembali darinya. Pada saat yang sama, bytecode yang digunakan cukup kompak. Pada dasarnya, perintah byte membutuhkan 1-3 byte, lebih banyak sangat jarang (hanya sejumlah besar, dan panggilan prosedur yang sangat jauh). Satu set kecil perintah byte juga dibuat sketsa, yang mudah diperluas. Misalkan semua perintah dasar untuk bekerja dengan stack (drop, swap, over, root, dll dapat ditulis dalam 20 menit, jumlah yang sama akan masuk ke perintah integer aritmatika).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Poin penting lainnya. Bytecode, tidak seperti kode benteng dijahit langsung klasik, tidak mengandung instruksi mesin, sehingga dapat ditransfer tanpa kompilasi ulang ke platform lain. Cukup dengan menulis ulang kernel sekali ke sistem instruksi prosesor baru, dan ini dapat dilakukan dengan sangat cepat. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Versi mesin byte saat ini tidak spesifik untuk bahasa tertentu. Tetapi saya ingin membuat implementasi bahasa Fort di atasnya karena saya memiliki pengalaman dengannya, dan kompiler untuk itu dapat dilakukan dengan sangat cepat.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika ada minat dalam hal ini, berdasarkan mesin ini, pada artikel selanjutnya, saya akan melakukan input-output dari string dan angka, kamus benteng, dan penerjemah. Anda dapat "menyentuh" ​​tim dengan tangan Anda. Nah, pada artikel ketiga kita akan membuat kompiler, dan kita mendapatkan sistem benteng yang hampir lengkap. Maka dimungkinkan untuk menulis dan menyusun beberapa algoritma standar dan membandingkan kinerjanya dengan bahasa dan sistem lain. Anda dapat menggunakan, misalnya, saringan Eratosthenes, dan sejenisnya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sangat menarik untuk bereksperimen dengan opsi. </font><font style="vertical-align: inherit;">Sebagai contoh, buat tabel perintah 16-bit, dan lihat bagaimana ini akan mempengaruhi kinerja. </font><font style="vertical-align: inherit;">Anda juga dapat mengubah titik entri _next menjadi makro, dalam hal ini kode mesin dari setiap byte perintah akan bertambah ukurannya dengan dua perintah (minus transisi dan ditambah tiga perintah dari _next). </font><font style="vertical-align: inherit;">Artinya, pada akhirnya tidak akan ada transisi ke _next, tetapi isi dari titik _next itu sendiri (ini adalah 14 byte). </font><font style="vertical-align: inherit;">Sangat menarik untuk mengetahui bagaimana ini akan mempengaruhi kinerja. </font><font style="vertical-align: inherit;">Anda juga dapat mencoba melakukan optimasi menggunakan register. </font><font style="vertical-align: inherit;">Misalnya, loop standar dengan penghitung di benteng menyimpan penghitung di tumpukan kembali. </font><font style="vertical-align: inherit;">Anda dapat membuat versi register dan juga mengujinya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Anda juga dapat membuat kompilator ekspresi yang ditulis dalam bentuk klasik (misalnya, A = 5 + (B + C * 4)).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Secara umum, ada ruang untuk eksperimen! </font></font> :) <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lanjutan: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mesin-byte untuk benteng (dan tidak hanya) di Native American (bagian 2)</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id431932/">https://habr.com/ru/post/id431932/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id431920/index.html">Frontend Mix - laporan tentang Node.js, skalabilitas, dan web asli</a></li>
<li><a href="../id431922/index.html">Apa itu Metode Menangani di Jawa</a></li>
<li><a href="../id431924/index.html">Sistem manajemen gudang menggunakan CQRS dan Event Sourcing. Proses Pengembangan</a></li>
<li><a href="../id431928/index.html">Kelelahan karena barang sekali pakai. Atau ode A.S. Makarenko</a></li>
<li><a href="../id431930/index.html">Pertemuan DevOps di St. Petersburg</a></li>
<li><a href="../id431934/index.html">Bagaimana kecerdasan buatan membantu bekerja dengan dokumen hukum? Kuliah oleh Egor Budnikov dari ABBYY</a></li>
<li><a href="../id431936/index.html">Hasil dari kontes TechnoText</a></li>
<li><a href="../id431938/index.html">Integer Cube Root di Verilog</a></li>
<li><a href="../id431940/index.html">Orang-orang terbakar jika mereka tidak merasakan nilai mereka. Apa yang harus dilakukan?</a></li>
<li><a href="../id431942/index.html">Injeksi ketergantungan hirarkis dalam React dan MobX State Tree sebagai model domain</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>