<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ“˜ ğŸ‘¨ğŸ¾â€ğŸ”¬ ğŸ‘¨â€ğŸ’¼ Menggunakan TSDuck untuk Memantau Streaming IP (TS) ğŸš¿ ğŸ¤±ğŸ¼ ğŸ‘¨ğŸ¼â€ğŸŒ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Saat ini, ada solusi siap pakai (proprietary) untuk memantau aliran IP (TS), misalnya, VB dan iQ , mereka memiliki serangkaian fungsi yang cukup kaya ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Menggunakan TSDuck untuk Memantau Streaming IP (TS)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482736/"><p>  Saat ini, ada solusi siap pakai (proprietary) untuk memantau aliran IP (TS), misalnya, <a href="https://bridgetech.tv/all-products/" rel="nofollow">VB</a> dan <a href="https://www.telestream.net/pdfs/iq/productsheets/Surveyor_TS_New.pdf" rel="nofollow">iQ</a> , mereka memiliki serangkaian fungsi yang cukup kaya dan biasanya solusi tersebut tersedia untuk operator besar yang berurusan dengan layanan TV.  Artikel ini menjelaskan solusi yang didasarkan pada proyek open source <a href="https://tsduck.io/" rel="nofollow">TSDuck</a> , yang dirancang untuk meminimalkan kontrol aliran IP (TS) oleh counter CC (kontinuitas konter) dan bit rate.  Aplikasi yang mungkin adalah untuk mengontrol kehilangan paket atau seluruh aliran melalui saluran L2 sewaan (yang tidak dapat dipantau secara normal, misalnya, dengan membaca penghitung kerugian dalam antrian). </p><br><h2 id="ochen-kratko-o-tsduck">  Sangat singkat tentang TSDuck </h2><br><p> TSDuck adalah perangkat lunak sumber terbuka (lisensi 2-Clause BSD) (satu set utilitas konsol dan perpustakaan untuk mengembangkan utilitas atau plug-in) untuk memanipulasi aliran TS.  Sebagai input ia dapat bekerja dengan IP (multicast / unicast), http, hls, dvb tuner, dektec dvb-asi demodulator, ada generator aliran TS internal dan membaca dari file.  Outputnya bisa berupa file, IP (multicast / unicast), hls, dektec dvb-asi dan modulator HiDes, pemain (mplayer, vlc, xine) dan drop.  Antara input dan output, Anda dapat mengaktifkan berbagai prosesor lalu lintas, misalnya, pemetaan ulang PID, pengacakan / penguraian ulang, analisis penghitung CC, perhitungan bitrate, dan operasi lain yang khas untuk TS-stream. </p><a name="habracut"></a><br><p>  Dalam artikel ini, aliran IP (multicast) akan digunakan sebagai input, prosesor bitrate_monitor digunakan (dari namanya jelas apa itu) dan kontinuitas (analisis penghitung CC).  Tanpa masalah, Anda dapat mengganti IP multicast dengan jenis input lain yang didukung oleh TSDuck. </p><br><p>  Ada <a href="https://tsduck.io/download/tsduck/" rel="nofollow">build / paket resmi</a> TSDuck untuk sebagian besar OS saat ini.  Untuk Debian, mereka tidak, tetapi dimungkinkan untuk berkumpul tanpa masalah di bawah debian 8 dan debian 10. </p><br><p>  Selanjutnya, TSDuck versi 3.19-1520 digunakan, Linux digunakan sebagai OS (debian 10 digunakan untuk menyiapkan solusi, CentOS 7 digunakan untuk penggunaan nyata) </p><br><h2 id="podgotovka-tsduck-i-os">  Mempersiapkan TSDuck dan OS </h2><br><p>  Sebelum memantau arus nyata, Anda perlu memastikan bahwa TSDuck berfungsi dengan benar dan tidak ada tetes pada level kartu jaringan atau OS (soket).  Ini diperlukan agar tidak menebak nanti di mana tetes terjadi - di jaringan atau "di dalam server".  Anda dapat memeriksa tetes pada tingkat kartu jaringan dengan perintah ethtool -S ethX, penyetelan dilakukan dengan ethtool yang sama (biasanya, Anda perlu meningkatkan buffer RX (-G) dan terkadang menonaktifkan beberapa pembebanan (-K)).  Sebagai rekomendasi umum, Anda dapat merekomendasikan menggunakan port terpisah untuk menerima lalu lintas yang dianalisis, jika mungkin, ini meminimalkan positif palsu yang terkait dengan fakta bahwa penurunan terjadi secara koheren pada port analyzer karena adanya lalu lintas lainnya.  Jika ini tidak memungkinkan (komputer mini / NUC dengan satu port digunakan), maka sangat diinginkan untuk memprioritaskan lalu lintas yang dianalisis relatif terhadap yang lain pada perangkat di mana penganalisa terhubung.  Mengenai lingkungan virtual, di sini Anda harus berhati-hati dan dapat menemukan paket tetes mulai dari port fisik dan diakhiri dengan aplikasi di dalam mesin virtual. </p><br><h3 id="generaciya-i-priyom-potoka-vnutri-hosta">  Pembuatan dan penerimaan aliran di dalam host </h3><br><p>  Sebagai langkah pertama dalam mempersiapkan TSDuck, kami akan menghasilkan dan menerima lalu lintas di dalam host yang sama menggunakan jaringan. </p><br><p>  Lingkungan memasak: </p><br><pre><code class="bash hljs">ip netns add P <span class="hljs-comment"><span class="hljs-comment"># netns P,       ip link add type veth # veth- - veth0   netns   (     ) ip link set dev veth1 netns P #veth1 -   netns P (     ) ip netns exec P ifconfig veth1 192.0.2.1/30 up # IP  veth1,      ip netns exec P ip ro add default via 192.0.2.2 #     nents P sysctl net.ipv6.conf.veth0.disable_ipv6=1 # IPv6  veth0 -    ,    TX     ifconfig veth0 up #  veth0 ip route add 239.0.0.1 dev veth0 # ,      239.0.0.1   veth0</span></span></code> </pre> <br><p>  Lingkungan sudah siap.  Kami memulai penganalisa lalu lintas: </p><br><pre> <code class="bash hljs">ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> P tsp --realtime -t \ -I ip 239.0.0.1:1234 \ -P continuity \ -P bitrate_monitor -p 1 -t 1 \ -O drop</code> </pre> <br><p>  di mana "-p 1 -t 1" berarti Anda harus menghitung bitrate setiap detik dan menampilkan informasi tentang bitrate setiap detik <br>  Kami memulai generator lalu lintas dengan kecepatan 10 Mbps: </p><br><pre> <code class="bash hljs">tsp -I craft \ -P regulate -b 10000000 \ -O ip -p 7 -e --<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>-port 6000 239.0.0.1:1234</code> </pre> <br><p>  di mana "-p 7 -e" berarti Anda harus mengemas 7 paket TS ke dalam 1 paket IP dan melakukannya dengan keras (-e), yaitu  selalu menunggu 7 paket TS dari prosesor terakhir sebelum mengirim paket IP. </p><br><p>  Penganalisis mulai menampilkan pesan yang diharapkan: </p><br><pre> <code class="plaintext hljs">* 2020/01/03 14:55:44 - bitrate_monitor: 2020/01/03 14:55:44, TS bitrate: 9,970,016 bits/s * 2020/01/03 14:55:45 - bitrate_monitor: 2020/01/03 14:55:45, TS bitrate: 10,022,656 bits/s * 2020/01/03 14:55:46 - bitrate_monitor: 2020/01/03 14:55:46, TS bitrate: 9,980,544 bits/s</code> </pre> <br><p>  Sekarang tambahkan beberapa tetes: </p><br><pre> <code class="bash hljs">ip netns <span class="hljs-built_in"><span class="hljs-built_in">exec</span></span> P iptables -I INPUT -d 239.0.0.1 -m statistic --mode random --probability 0.001 -j DROP</code> </pre> <br><p>  dan pesan seperti ini muncul: </p><br><pre> <code class="plaintext hljs">* 2020/01/03 14:57:11 - continuity: packet index: 80,745, PID: 0x0000, missing 7 packets * 2020/01/03 14:57:11 - continuity: packet index: 83,342, PID: 0x0000, missing 7 packets</code> </pre> <br><p>  apa yang diharapkan.  Nonaktifkan packet loss (ip netns exec P iptables -F) dan coba tingkatkan bitrate generator menjadi 100 Mbps.  Penganalisa melaporkan banyak kesalahan CC dan sekitar 75 Mbit / s, bukan 100. Kami mencoba mencari tahu siapa yang harus disalahkan - generator tidak punya waktu atau masalahnya tidak ada, untuk ini kami mulai menghasilkan jumlah paket yang tetap (700.000 paket TS = 100.000 paket IP): </p><br><pre> <code class="plaintext hljs"># ifconfig veth0 | grep TX TX packets 151825460 bytes 205725459268 (191.5 GiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 # tsp -I craft -c 700000 -P regulate -b 100000000 -P count -O ip -p 7 -e --local-port 6000 239.0.0.1:1234 * count: PID 0 (0x0000): 700,000 packets # ifconfig veth0 | grep TX TX packets 151925460 bytes 205861259268 (191.7 GiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0</code> </pre> <br><p>  Seperti yang Anda lihat, tepat 100.000 paket IP dihasilkan (151925460-151825460).  Jadi kami memahami apa yang terjadi dengan alat analisis, untuk ini kami memeriksa dengan penghitung RX pada veth1, itu benar-benar sama dengan penghitung TX pada veth0, kemudian kita melihat apa yang terjadi pada tingkat soket: </p><br><pre> <code class="plaintext hljs"># ip netns exec P cat /proc/net/udp sl local_address rem_address st tx_queue rx_queue tr tm-&gt;when retrnsmt uid timeout inode ref pointer drops 133: 010000EF:04D2 00000000:0000 07 00000000:00000000 00:00000000 00000000 0 0 72338 2 00000000e0a441df 24355</code> </pre> <br><p>  Di sini Anda dapat melihat jumlah tetes = 24355. Dalam paket TS itu adalah 170485 atau 24,36% dari 700.000, jadi kami melihat bahwa 25% dari bitrate yang hilang adalah tetes dalam soket udp.  Penurunan pada soket UDP biasanya terjadi karena kurangnya buffer, lihat ukuran buffer socket default dan ukuran maksimum buffer socket: </p><br><pre> <code class="plaintext hljs"># sysctl net.core.rmem_default net.core.rmem_default = 212992 # sysctl net.core.rmem_max net.core.rmem_max = 212992</code> </pre> <br><p>  Jadi, jika aplikasi tidak secara eksplisit meminta ukuran buffer, soket dibuat dengan buffer 208 KB, tetapi jika mereka meminta lebih dari itu, mereka masih tidak akan menerima apa yang diminta.  Karena di tsp Anda dapat mengatur ukuran buffer (--buffer-size) untuk input IP, kami tidak akan menyentuh ukuran socket secara default, kami hanya mengatur ukuran maksimum buffer socket dan menentukan ukuran buffer secara eksplisit melalui argumen tsp: </p><br><pre> <code class="plaintext hljs">sysctl net.core.rmem_max=8388608 ip netns exec P tsp --realtime -t -I ip 239.0.0.1:1234 -b 8388608 -P continuity -P bitrate_monitor -p 1 -t 1 -O drop</code> </pre> <br><p>  Dengan penyetelan buffer soket ini, bitrate yang sekarang dilaporkan adalah sekitar 100 Mbit / s, tidak ada kesalahan CC. </p><br><p>  Oleh konsumsi CPU oleh aplikasi tsp itu sendiri.  Sehubungan dengan satu inti dari CPU i5-4260U @ 1.40GHz, analisis aliran 10Mbit / s memerlukan CPU 3-4%, 100Mbit / s - 25%, 200Mbit / s - 46%.  Saat mengatur% packet loss, beban pada CPU secara praktis tidak meningkat (tetapi dapat berkurang). </p><br><p>  Pada perangkat keras yang lebih produktif, dimungkinkan untuk menghasilkan dan menganalisis aliran lebih dari 1 Gb / s tanpa masalah. </p><br><h3 id="testirovanie-na-realnyh-setevyh-kartah">  Menguji kartu jaringan nyata </h3><br><p>  Setelah menguji pada pasangan veth, Anda perlu mengambil dua host atau dua port dari satu host, menghubungkan port satu sama lain, menjalankan generator pada satu, dan analisa pada yang kedua.  Tidak ada kejutan, tetapi pada kenyataannya itu semua tergantung pada besi, semakin lemah semakin menarik. </p><br><h2 id="ispolzovanie-poluchaemyh-dannyh-sistemoy-monitoringa-zabbix">  Penggunaan data yang diterima oleh sistem pemantauan (Zabbix) </h2><br><p>  Tsp tidak memiliki API yang dapat dibaca mesin seperti SNMP atau sejenisnya.  Pesan-pesan CC harus dikumpulkan setidaknya 1 detik (dengan persentase paket yang tinggi, mungkin ada ratusan / ribuan / puluhan ribu per detik, tergantung pada bitrate). </p><br><p>  Jadi, untuk menyimpan informasi dan menggambar grafik kesalahan CC dan bit rate dan membuat semacam kecelakaan, opsi berikut mungkin lebih lanjut: </p><br><ol><li>  Parsing dan agregat (menurut CC) output dari tsp, mis.  mengubahnya menjadi bentuk yang diinginkan. </li><li>  Tambahkan tsp dan / atau plugin prosesor bitrate_monitor dan kontinuitas itu sendiri sehingga hasilnya ditampilkan dalam bentuk yang dapat dibaca mesin yang cocok untuk sistem pemantauan. </li><li>  Tulis aplikasi Anda di atas perpustakaan tsduck. </li></ol><br><p>  Jelas, dari sudut biaya tenaga kerja, opsi 1 adalah yang paling sederhana, terutama mengingat bahwa tsduck sendiri ditulis dalam bahasa tingkat rendah (menurut standar modern) (C ++) </p><br><p>  Prototipe sederhana dari pengurai + pengurai pada bash menunjukkan bahwa pada aliran 10Mbit / s dan paket loss 50% (kasus terburuk), proses bash mengkonsumsi CPU 3-4 kali lebih banyak daripada proses tsp itu sendiri.  Skenario ini tidak dapat diterima.  Sebenarnya sepotong prototipe di bawah ini </p><br><div class="spoiler">  <b class="spoiler_title">Mie di pesta</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/usr/bin/env bash missingPackets=0 ccErrorSeconds=0 regexMissPackets='^\*\ (.+) - continuity:.*missing ([0-9]+) packets$' missingPacketsTime="" ip netns exec P tsp --realtime -t -I ip -b 8388608 "239.0.0.1:1234" -O drop -P bitrate_monitor -p 1 -t 1 -P continuity 2&gt;&amp;1 | \ while read i do #line example:* 2019/12/28 23:41:14 - continuity: packet index: 6,078, PID: 0x0100, missing 5 packets #line example 2: * 2019/12/28 23:55:11 - bitrate_monitor: 2019/12/28 23:55:11, TS bitrate: 4,272,864 bits/s if [[ "$i" == *continuity:* ]] then if [[ "$i" =~ $regexMissPackets ]] then missingPacketsTimeNew="${BASH_REMATCH[1]}" #timestamp (seconds) if [[ "$missingPacketsTime" != "$missingPacketsTimeNew" ]] #new second with CC error then ((ccErrorSeconds += 1)) fi missingPacketsTime=$missingPacketsTimeNew packets=${BASH_REMATCH[2]} #TS missing packets ((missingPackets += packets)) fi elif [[ "$i" == *bitrate_monitor:* ]] then : #... fi done</span></span></code> </pre> </div></div><br><p>  Selain fakta bahwa ia bekerja sangat lambat, tidak ada utas normal dalam bash, pekerjaan bash adalah proses yang independen, dan saya harus mencatat nilai missingPackets pada efek samping satu detik sekali (ketika saya menerima pesan bitrate yang datang setiap detik).  Akibatnya, bash ditinggalkan sendirian dan diputuskan untuk menulis pembungkus (pengurai + pengumpul) di golang.  Konsumsi CPU dari kode golang serupa adalah 4-5 kali lebih sedikit dari proses tsp itu sendiri.  Mempercepat pembungkus dengan mengganti bash dengan golang ternyata sekitar 16 kali dan secara keseluruhan hasilnya dapat diterima (overhead pada CPU sebesar 25% dalam kasus terburuk).  File sumber di golang ada di <a href="https://github.com/inheb/tsduck-stat/tree/master/tsduck-stat" rel="nofollow">sini</a> . </p><br><h3 id="zapusk-obyortki">  Peluncuran wrapper </h3><br><p>  Untuk menjalankan wrapper, templat layanan paling sederhana untuk systemd dibuat (di <a href="https://github.com/inheb/tsduck-stat/tree/master/systemd" rel="nofollow">sini</a> ).  Diasumsikan bahwa pembungkus itu sendiri dikompilasi menjadi file biner (go build tsduck-stat.go), yang terletak di / opt / tsduck-stat /.  Diasumsikan bahwa golang digunakan dengan dukungan untuk jam monoton (&gt; = 1.9). </p><br><p>  Untuk membuat turunan dari layanan, Anda perlu menjalankan perintah systemctl aktifkan tsduck-stat@239.0.0.1: 1234, kemudian mulai gunakan systemctl start tsduck-stat@239.0.0.1: 1234. </p><br><h3 id="discovery-iz-zabbix">  Penemuan Zabbix </h3><br><p>  Agar zabbix dapat melakukan penemuan layanan yang sedang berjalan, <a href="https://github.com/inheb/tsduck-stat/tree/master/tsduck-stat" rel="nofollow">generator daftar grup</a> (discovery.sh) dibuat, dalam format yang diperlukan untuk penemuan Zabbix, diasumsikan bahwa ia terletak di sana - di / opt / tsduck-stat.  Untuk memulai penemuan melalui agen zabbix, Anda perlu menambahkan <a href="" rel="nofollow">file .conf</a> ke direktori dengan konfigurasi agen zabbix untuk menambahkan parameter pengguna. </p><br><h3 id="shablon-zabbix">  Template Zabbix </h3><br><p>  <a href="https://github.com/inheb/tsduck-stat/tree/master/zabbix_templates" rel="nofollow">Template yang dibuat</a> (tsduck_stat_template.xml) berisi aturan autodiscover, prototipe elemen data, grafik, dan pemicu. </p><br><h2 id="kratkiy-cheklist-nu-a-vdrug-kto-to-reshit-vospolzovatsya">  Daftar singkat (bagaimana jika seseorang memutuskan untuk menggunakannya) </h2><br><ol><li>  Pastikan tsp tidak menjatuhkan paket dalam kondisi "ideal" (generator dan penganalisa terhubung langsung), jika ada tetes, lihat bagian 2 atau teks artikel tentang hal ini. </li><li>  Lakukan penyetelan buffer soket maksimum (net.core.rmem_max = 8388608). </li><li>  Kompilasi tsduck-stat.go (buka build tsduck-stat.go). </li><li>  Masukkan templat layanan di / lib / systemd / system. </li><li>  Mulai layanan menggunakan systemctl, periksa bahwa penghitung mulai muncul (grep "" / dev / shm / tsduck-stat / *).  Jumlah layanan dengan jumlah aliran multicast.  Di sini Anda mungkin perlu membuat rute ke grup multicast, mungkin mematikan rp_filter atau membuat rute ke sumber ip. </li><li>  Jalankan discovery.sh, pastikan itu menghasilkan json. </li><li>  Pasang konfigurasi agen zabbix, restart agen zabbix. </li><li>  Unduh template ke zabbix, terapkan pada host di mana agen-zabbix dimonitor dan diinstal, tunggu sekitar 5 menit, lihat bahwa elemen data baru, grafik dan pemicu telah muncul. </li></ol><br><h2 id="rezultat">  Hasil </h2><br><p><img src="https://habrastorage.org/webt/ug/rc/5c/ugrc5c87ctd6rylequ7kdha5lze.png" alt="Bagan dengan bitrate dan kesalahan CC"></p><br><p>  Untuk tugas mendeteksi packet loss hampir cukup, setidaknya lebih baik daripada kurangnya pemantauan. </p><br><p>  Faktanya, â€œkerugianâ€ CC dapat terjadi ketika menempelkan klip video (sejauh yang saya tahu, penyisipan dilakukan di telecenter lokal di Federasi Rusia, yaitu, tanpa menghitung konter CC), ini harus diingat.  Dalam solusi berpemilik, masalah ini sebagian dilewati dengan mendeteksi label tag SCTE-35 (jika ditambahkan oleh generator aliran). <br>  <strong>UPD:</strong> menambahkan dukungan untuk tag SCTE-35 ke bungkus dan template zabbix </p><br><p>  Dari sudut pandang pemantauan kualitas transportasi, tidak ada cukup pemantauan jitter (IAT), karena  Peralatan TV (apakah modulator atau perangkat akhir) memiliki persyaratan untuk parameter ini dan tidak selalu mungkin untuk mengembang jitbuffer hingga tak terbatas.  Dan jitter dapat mengambang ketika peralatan dengan buffer besar digunakan dalam perjalanan dan QoS tidak dikonfigurasi atau tidak dikonfigurasi dengan baik untuk mengirimkan lalu lintas waktu nyata tersebut. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id482736/">https://habr.com/ru/post/id482736/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id482722/index.html">Cerita yang fantastis "Project C. Vanity of vanities" (10 mnt)</a></li>
<li><a href="../id482726/index.html">Intisari materi menarik untuk pengembang seluler # 328 (23-29 Desember)</a></li>
<li><a href="../id482728/index.html">Jpeg. Algoritma kompresi</a></li>
<li><a href="../id482730/index.html">Polling liburan</a></li>
<li><a href="../id482734/index.html">Kompilasi kebingungan waktu menggunakan NAND / NOR</a></li>
<li><a href="../id482740/index.html">Wawancara untuk posisi seorang penyair</a></li>
<li><a href="../id482742/index.html">Memasuki Pasar Barat: Bagaimana Berinteraksi dengan Pelanggan</a></li>
<li><a href="../id482744/index.html">Menemukan Peluru Perak: Amunisi Tidak Biasa</a></li>
<li><a href="../id482748/index.html">Membuat bisnis pemesanan taksi di Dubai: Bagaimana cara meluncurkan aplikasi taksi yang berpusat pada pelanggan seperti Careem & Hala?</a></li>
<li><a href="../id482752/index.html">"Epik Baru". Kami makan gajah di beberapa bagian</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>