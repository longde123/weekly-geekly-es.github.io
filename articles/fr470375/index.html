<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧗🏼 🤮 ▪️ Lorsque des tests et des autotests sont nécessaires, un aperçu du super système ⛰️ 👨‍🏫 😶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ai-je besoin d'un auto-test? Quand est-il nécessaire? Quelle valeur cela apporte-t-il? 

 L'article explique quand et pourquoi le test est nécessaire ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Lorsque des tests et des autotests sont nécessaires, un aperçu du super système</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/470375/">  Ai-je besoin d'un auto-test?  Quand est-il nécessaire?  Quelle valeur cela apporte-t-il? <br><br>  L'article explique quand et pourquoi le test est nécessaire en tant que tel et dans quels cas son automatisation est nécessaire. <br><a name="habracut"></a><br>  Au cours de la discussion sur cette question tenue dans le club pour eux.  Francis Bacon («KifB Web-Meetings» en téléram), des collègues ont échangé leurs expériences et écrit leurs réflexions. <br><br>  L'automatisation des tests est nécessaire si elle apporte de la valeur.  Quand le test lui-même apporte-t-il de la valeur?  Deux cas ont été identifiés. <br><br><h3>  Si le processus détecte des erreurs dans le logiciel avant de partir au combat </h3><br>  Si le test de la nouvelle version a révélé des erreurs qui ont ensuite été corrigées, ce test n'a pas été vain. <br><br>  Mais que faire si la situation s'inverse?  Si les tests n'ont pas trouvé d'erreur, mais qu'ils sont apparus au combat?  Si des erreurs ont été détectées sur le banc d'essai (y compris le banc d'essai configuré le plus près de la bataille). <br><br>  Il est allégué que, dans ce cas, les tests ont été mal effectués. <br><br>  Comment mesurer la qualité des tests?  Dans ce cas, la métrique convient = le nombre d'erreurs sur l'environnement de test / (le nombre d'erreurs sur l'environnement de test + combat).  Dans ce cas, le nombre d'erreurs est pris pondéré par le niveau de criticité. <br><br>  Mais que faire si les tests n'ont pas trouvé d'erreurs et n'ont pas été trouvés sur le serveur de combat? <br>  Il est allégué que dans ce cas, les tests, en tant que tels, n'ont pas apporté de valeur et ces travaux ont été effectués en vain (à l'exception du cas suivant, dont nous parlerons plus loin).  Du point de vue de Lean, c'est une perte. <br><br>  Quand est-ce possible?  Lorsque le module testé n'a pas changé.  Qu'est-ce qui peut changer un module? <br><br><ul><li>  Modification du code du module. </li><li>  Modification de la version des bibliothèques utilisées (y compris OS, base de données, etc.).  Le changement peut être dû aux exigences des régulateurs, c'est pourquoi la bibliothèque doit être mise à jour dans un délai fixe. </li><li>  Modifier les paramètres ou les données qui affectent sérieusement le comportement d'une fonctionnalité universelle, dont les tests complets sont inutilement difficiles à réaliser et, par conséquent, les tests ont été abandonnés.  Exemples: <br><br><ul><li>  La définition de promotions dans des solutions telles que Siebel CRM ou Oracle ATG peut entraîner une dégradation des performances des fonctions de calcul de la promo, et la possibilité d'une vérification complète est impossible dans un délai raisonnable en raison de la flexibilité et de la polyvalence excessives de ces solutions. </li><li>  La description html de la fiche produit peut contenir une structure de document cassée ou des erreurs dans la description du code js écrites à l'intérieur, ce qui brise la page de la fiche produit </li></ul></li><li>  L'utilisation de fonctionnalités n'est pas prévue à cet effet (clous marteaux avec un microscope).  Par exemple, une modification du type de charge qui n'est pas inhérente aux exigences et, par conséquent, n'est pas prise en compte lors des tests.  Par exemple, avant le Black Friday, il vaut la peine d'effectuer un test de charge distinct pour la page de destination, où ira le trafic s'il n'y avait pas de telles exigences de charge pour ce type de page. </li><li>  Modification du comportement de l'API des autres modules utilisés par le module en cours de développement.  Surtout si la fonctionnalité de l'API n'est pas couverte par les tests de régression. </li></ul><br>  Étant donné que les options de changement peuvent être différentes et que la réalisation d'un test de régression complet coûte de l'argent, cela ne vaut pas tous les tests.  Une option de contrôle consiste à baliser les tests avec des balises et avant les tests.  Le gestionnaire de tests détermine quelle suite de tests doit être envoyée pour exécution pour une partie donnée des modifications. <br><br>  Quand dois-je écrire des autotests dans ce cas? <br><br>  Pour commencer, les tests automatisés n'annulent pas les tests de paramétrage, les tests de conception et l'écriture de cas de paramétrage de test!  Et ne les remplace pas.  Si ce n'est pas le cas, l'automatisation ne doit pas être traitée.  Dans le même temps, les autotests doivent être compris non seulement comme le script lui-même, mais aussi comme la préparation de leur exécution et de l'utilisation des résultats. <br><br>  Si vous écrivez des autotests après avoir créé le code, cela entraînera une augmentation de time2market (ce qui entraînera automatiquement une augmentation du capital connecté).  Par conséquent, s'il est décidé de couvrir le code avec des autotests, vous devez alors écrire ces autotests parallèlement au code principal, dans le paradigme de développement de «TestFirst» ou «TDD». <br><br>  La principale valeur créée par l'automatisation des tests est la réduction de time2market en raison du téléchargement plus rapide de la nouvelle version. <br><br><h3>  Des tests sont nécessaires pour garantir la performance des processus critiques. </h3><br>  Malgré le fait que la voiture n'a jamais pris feu, la présence d'un extincteur n'est pas inutile. <br><br>  Une erreur sur un site à fort trafic qui ne permet pas d'ajouter un article au panier peut entraîner des pertes plus importantes que le coût de développement et de test de cette fonctionnalité sur l'année. <br><br>  Par conséquent, il est nécessaire de mettre en évidence les processus critiques qui feront l'objet de contrôles réguliers (qui valent la peine d'être effectués en cas de changement).  Comparez: <br><br><ul><li>  perte de temps d'arrêt de la fonction depuis le moment de la détection jusqu'à sa correction, </li><li>  dépenses tests manuels réguliers ou son automatisation et sa mise en œuvre ultérieure pendant la période de récupération. </li></ul><br>  Mais que se passe-t-il si les tests réguliers ne détectent pas les erreurs pendant une longue période et qu'elles ne se produisent pas au combat?  Ensuite, les tests n'apportent pas de valeur et ne sont donc pas nécessaires.  Quand est-ce possible? <br><br><ul><li>  Le module en cours de développement n'est pas très volumineux. </li><li>  Équipe stable et hautement compétente. </li><li>  Les intégrations sont fermées par des tests ou de l'autre côté il n'y a aucun changement. </li></ul><br>  Est-il possible de ne pas faire de tests du tout? <br><br>  Cela est possible grâce au lancement de plusieurs installations de la solution et au test de nouvelles versions bêta sur les chats, si cela est techniquement possible et si de tels volontaires sont trouvés.  Après la mise en place de la nouvelle version, la télémétrie est surveillée et un rollback est effectué en cas de dégradation des indicateurs.  (Rappelons que la télémétrie au combat doit être indépendante de la disponibilité des tests). <br><br>  Un autre cas de l'utilité de l'auto-test de régression est le test d'API (test de contrat d'API), si cette API est requise pour prendre en charge un processus critique.  Ceci est particulièrement important si les développeurs d'un autre module changent quelque chose et ne font pas de test de qualité des changements de leur côté. <br><br><h3>  Lorsque l'automatisation des tests n'est pas nécessaire </h3><br>  Si vous avez une grande quantité de code hérité de très mauvaise qualité.  Couvrir les autotests avec un tel chaos augmente le chaos. <br><br>  Dans ce cas, il convient de souligner le module logique de cette solution.  Après avoir sélectionné la couche d'interaction de ce module avec le reste du code, vous devez couvrir l'interaction avec les autotests.  Cela fournira des garanties de l'intégrité du comportement et de l'intégrité du module après son recodage. <br><br>  Les autotests ne remplacent pas les tests manuels.  Les tests manuels sont le plus souvent effectués plus rapidement et à moindre coût que l'écriture et, par la suite, les autotests associés.  En particulier, si le test est effectué après le développement du code, à partir de ce test, seule la partie qui entrera dans le test régulier des fonctionnalités critiques devrait être automatisée. <br><br><h4>  Et enfin - une liste de contrôle de la préparation de l'entreprise pour les autotests </h4><br>  Faisons une réservation tout de suite, cette liste de contrôle n'est pas pour tout le monde, elle est écrite pour les testeurs des entreprises pour lesquelles le développement de logiciels est la principale source de revenus. <br><br><h3>  Liste de contrôle </h3><br><ol><li>  L'entreprise dessine le principal processus de livraison et comprend où vous vous trouvez. </li><li>  L'entreprise a élaboré le processus de création de valeur pour les clients. </li><li>  La gestion des tâches a été mise en place, ce qui signifie que toutes les personnes impliquées prennent les tâches à l'état souhaité.  Et les tâches sont caractérisées. </li><li>  L'entreprise a formulé des objectifs de test. </li><li>  Les titres des tâches dans le tracker sont «peignés», en d'autres termes, par le titre, vous pouvez comprendre de quel type de tâche il s'agit. </li><li>  Le registre des tâches est gérable, à tout moment il reflète l'état actuel et la politique du projet / produit. </li><li>  Il existe un registre des exigences et il est gérable. </li><li>  Il existe une traçabilité des exigences des tâches. </li><li>  Il existe une traçabilité des exigences de test.  On sait quelles exigences sont couvertes par quels tests. </li><li>  Il existe une traçabilité des tests de tâches.  On sait qu'il a déjà été testé où et comment. </li><li>  Il existe une matrice de l'influence des composants les uns sur les autres. </li><li>  Les tâches sont attribuées aux composants. </li><li>  Tout est sur le contrôle de version. </li><li>  Il existe une politique versionnée de qui, comment et pourquoi.  On comprend pourquoi git flow est un mauvais modèle. </li><li>  Normes existantes: codage et autres </li><li>  Il y a un ci </li><li>  Il existe une politique de publication, où en particulier des méthodes de versioning sont prescrites, tout ce qui est nécessaire. </li><li>  Il existe un référentiel pour les artefacts à partir duquel vous pouvez retirer uniquement un produit prêt pour l'installation. </li><li>  Il existe une politique de marquage des artefacts selon différents critères.  L'analyse de code statique n'est pas oubliée. </li><li>  Le milieu de balayage du produit monte d'un simple clic.  L'environnement est également sous contrôle de version. </li><li>  L'environnement est entièrement automatisé et son exactitude est vérifiée.  Ports, version Java, ... </li><li>  Le produit se déplie en un clic avec un chèque </li><li>  Le produit est configuré de manière entièrement automatique pour la tâche requise.  Soit dit en passant, cela s'applique également aux configurations d'entreprise.  Et cela est également enregistré automatiquement. </li><li>  Vous avez un moyen de générer de manière répétée et automatique toutes les données de test nécessaires.  Les scripts de génération sont également sous contrôle de version et sont associés à des artefacts de produit. </li><li>  Tout ce qui précède fonctionne pour n'importe quelle version du produit. </li><li>  Vous avez un pipeline de livraison enregistré dans la politique de publication. </li></ol><br>  Enfin, merci aux membres du groupe pour la discussion et l'aide à la préparation de l'article. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr470375/">https://habr.com/ru/post/fr470375/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr470361/index.html">Le condensé de matières fraîches du monde du front-end de la dernière semaine n ° 383 (1 - 6 octobre 2019)</a></li>
<li><a href="../fr470363/index.html">Qui allez-vous appeler: créez un appel dans le concepteur de robots et apprenez à ne pas enrager les gens</a></li>
<li><a href="../fr470365/index.html">Travailler avec USB HID personnalisé sur Android</a></li>
<li><a href="../fr470367/index.html">Food Design Digest, septembre 2019</a></li>
<li><a href="../fr470373/index.html">PHP Digest n ° 165 (23 septembre - 7 octobre 2019)</a></li>
<li><a href="../fr470379/index.html">Le problème des trois montagnes, la théorie insaisissable de l'esprit et le problème de la périodisation du développement de l'enfant</a></li>
<li><a href="../fr470381/index.html">Station météo autonome sur le contrôleur ATMEGA328P et alimentée par batterie avec un capteur à distance sans fil</a></li>
<li><a href="../fr470385/index.html">Le ratio d'or en économie - 2</a></li>
<li><a href="../fr470393/index.html">Lunettes Cleverness - Impressions de Pegasi Dream Glasses</a></li>
<li><a href="../fr470395/index.html">OWASP API Security Top 10 RC</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>