<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑‍🤝‍🧑 🚱 😷 Apprenez OpenGL. Leçon 5.7 - HDR 🖱️ 🍡 ➕</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lors de l'écriture dans le tampon d'image, les valeurs de la luminosité des couleurs sont réduites à l'intervalle de 0,0 à 1,0. Pour cette raison, à p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apprenez OpenGL. Leçon 5.7 - HDR</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420409/"><img src="https://habrastorage.org/getpro/habr/post_images/20f/e6a/5f3/20fe6a5f38cfacad9ea8355ca097e8f4.png" width="200" align="left"><br><p>  Lors de l'écriture dans le tampon d'image, les valeurs de la luminosité des couleurs sont réduites à l'intervalle de 0,0 à 1,0.  Pour cette raison, à première vue inoffensif, nous devons toujours choisir des valeurs d'éclairage et de couleurs qui correspondent à cette restriction.  Cette approche fonctionne et donne des résultats décents, mais que se passe-t-il si nous rencontrons une zone particulièrement lumineuse avec beaucoup de sources de lumière vive et que la luminosité totale dépasse 1,0?  Par conséquent, toutes les valeurs supérieures à 1,0 seront converties en 1,0, ce qui n'est pas très joli: </p><br><p><img src="https://habrastorage.org/webt/cd/0m/ir/cd0mir8t9qcbakfwldnjibj3ay0.png"></p><br><p>  Étant donné que les valeurs de couleur sont réduites à 1,0 pour un grand nombre de fragments, de grandes zones de l'image sont remplies de la même couleur blanche, un nombre important de détails de l'image sont perdus et l'image elle-même commence à paraître anormale. </p><br><p>  La solution à ce problème peut être de réduire la luminosité des sources lumineuses afin qu'il n'y ait pas de fragments plus lumineux que 1.0 sur la scène: ce n'est pas la meilleure solution, ce qui oblige à utiliser des valeurs d'éclairage irréalistes.  La meilleure approche consiste à permettre aux valeurs de luminosité de dépasser temporairement la luminosité de 1,0 et à l'étape finale de changer les couleurs afin que la luminosité revienne dans la plage de 0,0 à 1,0, mais sans perte de détails de l'image. </p><br><p>  L'écran de l'ordinateur est capable d'afficher des couleurs avec une luminosité allant de 0,0 à 1,0, mais nous n'avons pas une telle limitation lors du calcul de l'éclairage.  En permettant aux couleurs du fragment d'être plus lumineuses que l'unité, nous obtenons une plage de luminosité beaucoup plus élevée pour le travail - HDR <em>(plage dynamique élevée)</em> .  Avec hdr, les choses brillantes paraissent brillantes, les choses sombres peuvent être vraiment sombres, et ce faisant, nous verrons les détails. </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Table des matières</b> <div class="spoiler_text"><p>  Partie 1. Pour commencer <br><br></p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Opengl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Création de fenêtres</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bonjour fenêtre</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bonjour triangle</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Shaders</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Textures</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Transformations</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Systèmes de coordonnées</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Appareil photo</a> </li></ol><br><p>  Partie 2. Éclairage de base <br><br></p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les couleurs</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bases d'éclairage</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Matériaux</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cartes de texture</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sources lumineuses</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sources d'éclairage multiples</a> </li></ol><br><p>  Partie 3. Télécharger des modèles 3D <br><br></p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bibliothèque Assimp</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Classe de polygone de maillage</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Classe de modèle 3D</a> </li></ol><br><p>  Partie 4. Fonctionnalités avancées d'OpenGL <br><br></p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Test de profondeur</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Test au pochoir</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mélange de couleurs</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Couper les visages</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tampon de trame</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cartes cubiques</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Traitement avancé des données</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GLSL avancé</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Shader géométrique</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Instanciation</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Lissage</a> </li></ol><br><p>  Partie 5. Éclairage avancé <br><br></p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Éclairage avancé.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Modèle Blinn-Fong.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Correction gamma</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cartes fantômes</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cartes ombrées omnidirectionnelles</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cartographie normale</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mappage de parallaxe</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">HDR</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bloom</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Rendu différé</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SSAO</a> </li></ol><br><p>  Partie 6. PBR <br><br></p><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Théorie</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sources de lumière analytiques</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Irradiation diffuse.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">IBL</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Exposition miroir.</a> </li></ol></div></div><br><p>  Initialement, une plage dynamique élevée était utilisée en photographie: le photographe a pris plusieurs photographies identiques de la scène avec différentes expositions, capturant des couleurs de presque n'importe quelle luminosité.  La combinaison de ces photos forme une image hdr dans laquelle la plupart des détails deviennent visibles en raison de la combinaison d'images avec différentes pertes d'exposition.  Par exemple, ci-dessous sur l'image de gauche, des fragments fortement éclairés de l'image sont clairement visibles (regardez la fenêtre), mais ces détails disparaissent lorsque vous utilisez une exposition élevée.  Cependant, l'exposition élevée rend les détails sur les zones sombres de l'image qui n'étaient pas visibles auparavant. </p><br><p><img src="https://habrastorage.org/webt/hh/-0/0h/hh-00hpoeday-yolbntasroul14.png"></p><br><p>  Ceci est similaire au fonctionnement de l'œil humain.  Avec un manque de lumière, l'œil s'adapte, de sorte que les détails sombres deviennent clairement visibles, et de même pour les zones claires.  On peut dire que l'œil humain dispose d'un contrôle d'exposition automatique, en fonction de la luminosité de la scène. </p><br><p>  Le rendu HDR fonctionne de la même manière.  Nous autorisons lors du rendu à utiliser une large plage de valeurs de luminosité pour collecter des informations sur les détails clairs et sombres de la scène, et à la fin, nous reconvertirons les valeurs de la plage HDR en LDR (faible plage dynamique, plage de 0 à 1).  Cette transformation est appelée <em>cartographie des tons</em> , il existe un grand nombre d'algorithmes visant à conserver la plupart des détails de l'image lors de la conversion en LDR.  Ces algorithmes ont souvent un paramètre d'exposition qui leur permet de mieux montrer les zones claires ou sombres de l'image. </p><br><p>  L'utilisation du HDR lors du rendu nous permet non seulement de dépasser la plage LDR de 0 à 1 et d'enregistrer plus de détails sur l'image, mais permet également d'indiquer la luminosité réelle des sources lumineuses.  Par exemple, le soleil a une luminosité beaucoup plus grande que quelque chose comme une lampe de poche, alors pourquoi ne pas régler le soleil sur cela (par exemple, lui donner une luminosité de 10,0)?  Cela nous permettra de mieux régler l'éclairage de la scène avec des paramètres de luminosité plus réalistes, ce qui serait impossible avec un rendu LDR et une plage de luminosité de 0 à 1. </p><br><p>  Étant donné que l'affichage n'affiche une luminosité que de 0 à 1, nous sommes obligés de reconvertir la plage de valeurs HDR utilisée en plage du moniteur.  Une simple mise à l'échelle de la plage ne sera pas une bonne solution, car les zones claires commenceront à dominer l'image.  Cependant, nous pouvons utiliser diverses équations ou courbes pour convertir les valeurs HDR en LDR, ce qui nous donnera un contrôle total sur la luminosité de la scène.  Cette transformation est appelée <em>mappage des tons</em> et est la dernière étape du rendu HDR. </p><br><h3 id="freymbufery-s-plavayuschey-tochkoy">  Tampons de cadre à virgule flottante </h3><br><p>  Pour implémenter le rendu HDR, nous avons besoin d'un moyen d'empêcher les valeurs d'être portées à une plage de 0 à 1 à partir du shader de fragment.  Si le tampon d'images utilise le format à virgule fixe normalisé (GL_RGB) pour les tampons de couleurs, OpenGL limite automatiquement les valeurs avant de les enregistrer dans le tampon d'images.  Cette restriction s'applique à la plupart des formats de tampon d'image, à l'exception des formats à virgule flottante. </p><br><p> Pour stocker des valeurs qui se trouvent en dehors de la plage [0.0..1.0], nous pouvons utiliser un tampon de couleur avec les formats suivants: <code>GL_RGB16F, GL_RGBA16F, GL_RGB32F or GL_RGBA32F</code> .  C'est génial pour le rendu hdr.  Un tel tampon sera appelé tampon de trame à virgule flottante. </p><br><p>  La création d'un tampon à virgule flottante diffère d'un tampon standard uniquement en ce qu'il utilise un format interne différent: </p><br><pre> <code class="plaintext hljs">glBindTexture(GL_TEXTURE_2D, colorBuffer); glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA16F, SCR_WIDTH, SCR_HEIGHT, 0, GL_RGBA, GL_FLOAT, NULL);</code> </pre> <br><p>  Le framebuffer OpenGL utilise par défaut seulement 8 bits pour stocker chaque couleur.  Dans le tampon d' <code>GL_RGB32F</code> à <code>GL_RGB32F</code> <code>GL_RGBA32F</code> formats <code>GL_RGB32F</code> ou <code>GL_RGBA32F</code> , 32 bits sont utilisés pour stocker chaque couleur - 4 fois plus.  Si une précision très élevée n'est pas requise, le format <code>GL_RGBA16F</code> sera tout à fait suffisant. </p><br><p>  Si un tampon à virgule flottante est attaché au tampon de trame pour la couleur, nous pouvons y rendre la scène en tenant compte du fait que les valeurs de couleur ne seront pas limitées à la plage de 0 à 1. Dans le code de cet article, nous rendons d'abord la scène au tampon de trame à virgule flottante, puis afficher le contenu tampons de couleur sur un rectangle demi-écran.  Cela ressemble à ceci: </p><br><pre> <code class="plaintext hljs">glBindFramebuffer(GL_FRAMEBUFFER, hdrFBO); glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // [...]    hdr glBindFramebuffer(GL_FRAMEBUFFER, 0); //  hdr    2     hdrShader.use(); glActiveTexture(GL_TEXTURE0); glBindTexture(GL_TEXTURE_2D, hdrColorBufferTexture); RenderQuad();</code> </pre> <br><p>  Ici, les valeurs de couleur contenues dans le tampon de couleur peuvent être supérieures à 1. Pour cet article, une scène a été créée avec un grand cube allongé qui ressemble à un tunnel avec quatre sources lumineuses ponctuelles, l'une d'entre elles est située à l'extrémité du tunnel et a une grande luminosité. </p><br><pre> <code class="plaintext hljs">std::vector&lt;glm::vec3&gt; lightColors; lightColors.push_back(glm::vec3(200.0f, 200.0f, 200.0f)); lightColors.push_back(glm::vec3(0.1f, 0.0f, 0.0f)); lightColors.push_back(glm::vec3(0.0f, 0.0f, 0.2f)); lightColors.push_back(glm::vec3(0.0f, 0.1f, 0.0f));</code> </pre> <br><p>  Le rendu dans le tampon à virgule flottante est exactement le même que si nous rendions la scène dans un tampon d'images normal.  La seule nouveauté est le shader hdr fragmenté, qui traite de l'ombrage simple d'un rectangle plein écran avec les valeurs d'une texture, qui est un tampon de couleurs à virgule flottante.  Pour commencer, écrivons un shader simple qui transfère les données d'entrée inchangées: </p><br><pre> <code class="plaintext hljs">#version 330 core out vec4 FragColor; in vec2 TexCoords; uniform sampler2D hdrBuffer; void main() { vec3 hdrColor = texture(hdrBuffer, TexCoords).rgb; FragColor = vec4(hdrColor, 1.0); }</code> </pre> <br><p>  Nous prenons l'entrée de la virgule flottante du tampon de couleur et nous l'utilisons comme valeur de sortie du shader.  Cependant, étant donné que le rectangle 2D est rendu dans le framebuffer par défaut, les valeurs de sortie du shader seront limitées à un intervalle de 0 à 1, malgré le fait qu'à certains endroits, les valeurs sont supérieures à 1. </p><br><p><img src="https://habrastorage.org/webt/rw/mb/ds/rwmbdsi_qc8fjdssulhqwwzk3rg.png"></p><br><p>  Il devient évident que des valeurs de couleur trop grandes à la fin du tunnel sont limitées à l'unité, car une partie importante de l'image est complètement blanche et nous perdons des détails d'image plus brillants que l'unité.  Puisque nous utilisons les valeurs HDR directement en tant que LDR, cela équivaut à ne pas avoir de HDR.  Pour résoudre ce problème, nous devons afficher les différentes valeurs de couleur dans la plage de 0 à 1 sans perdre aucun détail dans l'image.  Pour ce faire, appliquez une compression tonale. </p><br><h3 id="tonalnaya-kompressiya">  Compression de tonalité </h3><br><p>  La compression des tons est la conversion des valeurs de couleur pour les adapter dans la plage de 0 à 1 sans perdre les détails de l'image, souvent en combinaison avec donner à l'image la balance des blancs souhaitée. </p><br><p>  L'algorithme de <em>mappage de tons le</em> plus simple est connu sous le nom d'algorithme de <em>mappage de tons Reinhard</em> .  Il affiche toutes les valeurs HDR dans la plage LDR.  Ajoutez cet algorithme au shader de fragment précédent et appliquez également la correction gamma (et l'utilisation de textures SRGB). </p><br><pre> <code class="plaintext hljs">void main() { const float gamma = 2.2; vec3 hdrColor = texture(hdrBuffer, TexCoords).rgb; //   vec3 mapped = hdrColor / (hdrColor + vec3(1.0)); // - mapped = pow(mapped, vec3(1.0 / gamma)); FragColor = vec4(mapped, 1.0); }</code> </pre> <br><blockquote>  Remarque  trans.  - pour les petites valeurs de x, la fonction x / (1 + x) se comporte approximativement comme x, pour les grands x elle tend vers l'unité.  Graphique de fonction: </blockquote><p><img src="https://habrastorage.org/webt/sz/oq/ao/szoqaojobtfzh5_m5htgu_nh2_y.png"></p><br><p>  Avec la compression de tonalité Reinhardt, nous ne perdons plus de détails dans les zones claires de l'image.  L'algorithme préfère les zones claires, rendant les zones sombres moins distinctes. </p><br><p><img src="https://habrastorage.org/webt/jm/um/3c/jmum3cplqvaaqwhh96nzrrlhuc4.png"></p><br><p>  Ici, vous pouvez à nouveau voir les détails à la fin de l'image, tels que la texture du bois.  Avec cet algorithme relativement simple, nous pouvons voir clairement toutes les couleurs de la gamme HDR et pouvons contrôler l'éclairage de la scène sans perdre les détails de l'image. </p><br><blockquote>  Il convient de noter que nous pouvons utiliser la compression tonale directement à la fin de notre shader pour calculer l'éclairage, et nous n'avons alors pas du tout besoin d'un tampon de trame à virgule flottante.  Cependant, dans les scènes plus complexes, vous rencontrerez souvent la nécessité de stocker des valeurs HDR intermédiaires dans des tampons à virgule flottante, donc cela vous sera utile. </blockquote><p>  Une autre caractéristique intéressante de la compression de tonalité est l'utilisation d'un paramètre d'exposition.  Vous vous souvenez peut-être que dans les images au début de l'article, divers détails étaient visibles à différentes valeurs d'exposition.  Si nous avons une scène dans laquelle le jour et la nuit changent, il est logique d'utiliser une faible exposition pendant la journée et haute la nuit, ce qui est similaire à l'adaptation de l'œil humain.  Avec ce paramètre d'exposition, nous pouvons configurer des paramètres d'éclairage qui fonctionneront jour et nuit dans différentes conditions d'éclairage. </p><br><p>  Un algorithme de compression tonale relativement simple avec exposition ressemble à ceci: </p><br><pre> <code class="plaintext hljs">uniform float exposure; void main() { const float gamma = 2.2; vec3 hdrColor = texture(hdrBuffer, TexCoords).rgb; //     vec3 mapped = vec3(1.0) - exp(-hdrColor * exposure); // - mapped = pow(mapped, vec3(1.0 / gamma)); FragColor = vec4(mapped, 1.0); }</code> </pre> <br><blockquote>  Remarque  par: ajouter un graphique pour cette fonction avec les expositions 1 et 2: </blockquote><p><img src="https://habrastorage.org/webt/3j/fj/zi/3jfjzibpldumgonxyhin6ydi-ao.png"></p><br><p>  Ici, nous avons défini une variable pour l'exposition, qui est 1 par défaut et nous permet de choisir plus précisément l'équilibre entre la qualité d'affichage des zones sombres et lumineuses de l'image.  Par exemple, avec une grande exposition, nous voyons beaucoup plus de détails dans les zones sombres de l'image.  À l'inverse, une faible exposition rend les zones sombres indiscernables, mais vous permet de mieux voir les zones claires de l'image.  Ci-dessous sont des images d'un tunnel avec différents niveaux d'exposition. </p><br><p><img src="https://habrastorage.org/webt/ae/kx/vf/aekxvfxdggv34kzeqcoxy9tjdps.png"></p><br><p>  Ces images montrent clairement les avantages du rendu hdr.  À mesure que le niveau d'exposition change, nous voyons plus de détails de la scène qui seraient perdus dans le rendu normal.  Prenons l'exemple du bout du tunnel - avec une exposition normale, la texture de l'arbre est à peine visible, mais avec une exposition faible, la texture est parfaitement visible.  De même, à forte exposition, les détails dans les zones sombres sont très clairement visibles. </p><br><p>  Le code source de la démo est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici.</a> </p><br><h3 id="bolshe-hdr">  Plus de HDR </h3><br><p>  Ces deux algorithmes de compression de tonalité qui ont été montrés ne sont qu'une petite partie parmi un grand nombre d'algorithmes plus avancés, chacun ayant ses propres forces et faiblesses.  Certains algorithmes mettent mieux en valeur certaines couleurs / luminosités, certains algorithmes montrent des zones sombres et lumineuses en même temps, donnant des images plus colorées et plus détaillées.  Il existe également de nombreuses méthodes connues sous le nom <em>d'ajustement automatique de l'exposition</em> ou d' <em>adaptation oculaire</em> .  Ils déterminent la luminosité de la scène dans l'image précédente et modifient (lentement) le paramètre d'exposition, de sorte que la scène sombre devient lentement plus lumineuse et la lumière - plus sombre: semblable à l'habituation de l'œil humain. </p><br><p>  Les avantages réels du HDR sont mieux visibles sur les scènes grandes et complexes avec des algorithmes d'éclairage sérieux.  À des fins de formation, cet article a utilisé la scène la plus simple possible, car la création d'une grande scène peut être difficile.  Malgré la simplicité de la scène, certains avantages du rendu hdr sont visibles: dans les zones sombres et lumineuses de l'image, les détails ne sont pas perdus, car ils sont enregistrés à l'aide de la compression des tons, l'ajout de plusieurs sources de lumière n'entraîne pas l'apparition de zones blanches et les valeurs n'ont pas à tenir dans LDR gamme. </p><br><p>  De plus, le rendu HDR rend également certains effets intéressants plus crédibles et réalistes.  L'un de ces effets est la floraison, dont nous parlerons dans un prochain <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> . </p><br><h3 id="dopolnitelnye-resursy">  Ressources supplémentaires: </h3><br><ul><li>  Une question d'échange de pile avec une très longue réponse qui décrit certains des avantages du rendu HDR: le rendu HDR a- <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">t-il des avantages si la floraison n'est pas appliquée?</a> </li><li>  Une autre réponse intéressante avec de bonnes images comme exemples de compression tonale.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Qu'est-ce que le mappage de tons?</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Comment est-ce lié au HDR?</a> </li></ul><br><p>  <strong>PS</strong> Nous avons un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">télégramme conf</a> pour la coordination des transferts.  Si vous avez un sérieux désir d'aider à la traduction, alors vous êtes les bienvenus! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr420409/">https://habr.com/ru/post/fr420409/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr420393/index.html">PHP, YII2 et la formation de gros fichiers Excel</a></li>
<li><a href="../fr420395/index.html">Tablettes "gratuites" pour les détenus - pas du tout gratuites</a></li>
<li><a href="../fr420397/index.html">Les scientifiques ont trouvé un moyen d'inverser le processus de vieillissement des cellules</a></li>
<li><a href="../fr420405/index.html">Recherche sur le processus de vente informatique</a></li>
<li><a href="../fr420407/index.html">C n'est pas un langage de bas niveau</a></li>
<li><a href="../fr420413/index.html">SQLite et NW.js - instructions pas à pas pour créer des amitiés solides</a></li>
<li><a href="../fr420415/index.html">Tout ce que vous vouliez savoir sur les tests d'adaptateurs Wi-Fi, mais aviez peur de demander</a></li>
<li><a href="../fr420419/index.html">Coureurs pour ceux qui aiment l'humiliation ou comment nous avons changé et modifié PixJam</a></li>
<li><a href="../fr420423/index.html">Problèmes d'interface avec le passage au sol</a></li>
<li><a href="../fr420425/index.html">Théorie et pratique de l'utilisation de HBase</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>