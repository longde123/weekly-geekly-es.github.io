<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëèüèΩ üè´ üë£ DMA: Mitos e Realidade üïå üë™ üå¨Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Introdu√ß√£o 
 Em um artigo anterior ( ‚ÄúParte 2: Usando blocos Cypress PSoC UDB para reduzir o n√∫mero de interrup√ß√µes em uma impressora 3D‚Äù ), observ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DMA: Mitos e Realidade</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437112/"><img src="https://habrastorage.org/webt/m4/12/q3/m412q3b8zbug620xzvv0the7ix0.jpeg"><br><br><h2>  1. Introdu√ß√£o </h2><br>  Em um artigo anterior ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">‚ÄúParte 2: Usando blocos Cypress PSoC UDB para reduzir o n√∫mero de interrup√ß√µes em uma impressora 3D‚Äù</a> ), observei um fato muito interessante: se uma m√°quina no UDB removeu os dados do FIFO muito rapidamente, conseguiu perceber o estado de que havia novas n√£o h√° dados no FIFO, ap√≥s o qual entra em um estado falso <b>ocioso</b> .  Claro, eu estava interessado nesse fato.  Mostrei os resultados abertos a um grupo de conhecidos.  Uma pessoa respondeu que tudo isso era √≥bvio, e at√© citou os motivos.  O resto n√£o ficou menos surpreso do que eu estava no in√≠cio da pesquisa.  Portanto, alguns especialistas n√£o encontrar√£o nada de novo aqui, mas seria bom levar essas informa√ß√µes ao p√∫blico em geral, para que todos os programadores de microcontroladores tenham isso em mente. <br><a name="habracut"></a><br>  N√£o que fosse um colapso de algum tipo de cobertura.  Descobriu-se que tudo isso est√° bem documentado, mas o problema √© que n√£o est√° no principal, mas em documentos adicionais.  E, pessoalmente, fiquei feliz na ignor√¢ncia, acreditando que o DMA √© um subsistema muito √°gil que pode aumentar drasticamente a efici√™ncia dos programas, pois h√° uma transfer√™ncia sistem√°tica de dados sem distrair o incremento do registro e organizar o ciclo com os mesmos comandos.  Quanto √† melhoria da efici√™ncia - tudo √© verdade, mas devido a coisas ligeiramente diferentes. <br><br>  Mas as primeiras coisas primeiro. <br><br><h2>  Experi√™ncias com Cypress PSoC </h2><br>  Vamos fazer uma m√°quina simples.  Ele ter√° dois estados condicionalmente: o estado ocioso e o estado em que cair√° quando houver pelo menos um byte de dados no FIFO.  Ao entrar nesse estado, ele simplesmente pega esses dados e depois cai novamente em um estado de descanso.  A palavra "condicional" n√£o citei acidentalmente.  Como temos dois FIFOs, farei dois desses estados, um para cada FIFO, para garantir que eles tenham comportamento completamente id√™ntico.  O gr√°fico de transi√ß√£o para a m√°quina ficou assim: <br><br><img src="https://habrastorage.org/webt/pv/cu/1q/pvcu1qmbxk9zkbgxk8u51unthpe.png"><br><br>  Os sinalizadores para sair do estado ocioso s√£o definidos da seguinte maneira: <br><br><img src="https://habrastorage.org/webt/h8/re/rp/h8rerphupbsfvawmjiwgwqr_thw.png"><br><br>  N√£o esque√ßa de enviar os bits do n√∫mero de status para as entradas do Datapath: <br><br><img src="https://habrastorage.org/webt/ze/dz/ab/zedzab8iuaoxnu0esg32xwwga3g.png"><br><br>  Para o exterior, emitimos dois grupos de sinais: um par de sinais de que o FIFO possui espa√ßo livre (para que o DMA possa come√ßar a enviar dados para eles) e alguns sinais de que o FIFO est√° vazio (para exibir esse fato em um oscilosc√≥pio). <br><br><img src="https://habrastorage.org/webt/ts/bm/dn/tsbmdn-puyugsmixnsipf81pboa.png"><br><br>  A ALU simplesmente obter√° ficcionalmente os dados do FIFO: <br><br><img src="https://habrastorage.org/webt/px/5s/_w/px5s_wj1zqwjedrk0h7ty7tbu_4.png"><br><br>  Deixe-me mostrar os detalhes do estado "0001": <br><br><img src="https://habrastorage.org/webt/mb/-s/j0/mb-sj05-chkdijmqn3mue8hmjnk.png"><br><br>  Tamb√©m defini a largura do barramento, que estava no projeto no qual notei esse efeito, 16 bits: <br><br><img src="https://habrastorage.org/webt/sa/hc/br/sahcbrgearj6wnw5-4lykaew1qy.png"><br><br>  Passamos para o esquema do pr√≥prio projeto.  Externamente, dou n√£o apenas sinais de que o FIFO est√° vazio, mas tamb√©m pulsos de clock.  Isso me permitir√° ficar sem medi√ß√µes do cursor em um oscilosc√≥pio.  Eu posso apenas tomar medidas com o dedo. <br><br><img src="https://habrastorage.org/webt/b-/8v/iq/b-8viqzbm1isamdkiljvmwevwme.png"><br><br>  Aparentemente, fiz 24 clock megahertz.  A frequ√™ncia do n√∫cleo do processador √© exatamente a mesma.  Quanto menor a frequ√™ncia, menor a interfer√™ncia em um oscilosc√≥pio chin√™s (oficialmente tem uma banda de 250 MHz, mas depois megahertz chin√™s) e todas as medi√ß√µes ser√£o realizadas com rela√ß√£o aos pulsos de clock.  Qualquer que seja a frequ√™ncia, o sistema ainda funcionar√° com rela√ß√£o a eles.  Eu definiria um megahertz, mas o ambiente de desenvolvimento me proibiu de inserir um valor de frequ√™ncia de n√∫cleo do processador inferior a 24 MHz. <br><br>  Agora o material de teste.  Para escrever em FIFO0, criei esta fun√ß√£o: <br><br><pre><code class="plaintext hljs">void WriteTo0FromROM() { static const uint16 steps[] = { 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001, 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001 }; //  DMA  ,      uint8 channel = DMA_0_DmaInitialize (sizeof(steps[0]),1,HI16(steps),HI16(JustReadFromFIFO_1_Datapath_1_F0_PTR)); CyDmaChRoundRobin (channel,1); //       ,       uint8 td = CyDmaTdAllocate(); //       .  ,    . CyDmaTdSetConfiguration(td, sizeof(steps), CY_DMA_DISABLE_TD, TD_INC_SRC_ADR / TD_AUTO_EXEC_NEXT); //       CyDmaTdSetAddress(td, LO16((uint32)steps), LO16((uint32)JustReadFromFIFO_1_Datapath_1_F0_PTR)); //      CyDmaChSetInitialTd(channel, td); //         CyDmaChEnable(channel, 1); }</code> </pre> <br>  A palavra ROM no nome da fun√ß√£o deve-se ao fato de que o array a ser enviado √© armazenado na √°rea ROM, e o Cortex M3 possui uma arquitetura Harvard.  A velocidade de acesso ao barramento RAM e ao barramento ROM pode variar, eu queria verific√°-lo, por isso tenho uma fun√ß√£o semelhante para enviar uma matriz da RAM (a matriz de <b>etapas</b> n√£o possui um modificador <b>const est√°tico</b> no corpo).  Bem, h√° o mesmo par de fun√ß√µes para enviar para FIFO1, o registro do receptor √© diferente l√°: n√£o F0, mas F1.  Caso contr√°rio, todas as fun√ß√µes s√£o id√™nticas.  Como n√£o notei muita diferen√ßa nos resultados, considerarei os resultados da chamada exatamente da fun√ß√£o acima.  Um raio-rel√≥gio amarelo pulsa, sa√≠da azul <b>FIFO0 vazia</b> . <br><br><img src="https://habrastorage.org/webt/ko/65/0j/ko650jp1nj58h1nm5dzal4bzdhw.png"><br><br>  Primeiro, verifique a plausibilidade do motivo pelo qual o FIFO √© preenchido em dois ciclos de clock.  Vamos ver este site em mais detalhes: <br><br><img src="https://habrastorage.org/webt/ox/fi/x_/oxfix_l8jpspyxgbiumrlagm9ma.png"><br><br>  Na borda 1, os dados se enquadram no FIFO, o sinalizador <b>FIFO0enmpty</b> cai.  Na borda 2, o aut√¥mato entra no estado <b>GetDataFromFifo1</b> .  Na borda 3, nesse estado, os dados do FIFO s√£o copiados para o registro da ALU, o FIFO √© esvaziado, o sinalizador <b>FIFO0vaz</b> √© <b>levantado</b> novamente.  Ou seja, a forma de onda se comporta de maneira plaus√≠vel, voc√™ pode contar com ela no ciclo do rel√≥gio.  Temos 9 pe√ßas. <br><br><img src="https://habrastorage.org/webt/fc/mq/bj/fcmqbjhfee7mf7u7_xnkgyspq18.png"><br><br>  <b>No total, na √°rea inspecionada, s√£o necess√°rios 9 ciclos de rel√≥gio para copiar uma palavra de dados da RAM para o UDB usando DMA.</b> <br><br>  E agora a mesma coisa, mas com a ajuda do n√∫cleo do processador.  Primeiro, um c√≥digo ideal dificilmente poss√≠vel de ser alcan√ßado na vida real: <br><br><pre> <code class="plaintext hljs"> volatile uint16_t* ptr = (uint16_t*)JustReadFromFIFO_1_Datapath_1_F0_PTR; ptr[0] = 0; ptr[0] = 0;</code> </pre><br>  o que se transformar√° em c√≥digo de montagem: <br><br><pre> <code class="plaintext hljs"> ldr r3, [pc, #8] ; (90 &lt;main+0xc&gt;) movs r2, #0 strh r2, [r3, #0] strh r2, [r3, #0] bn 8e &lt;main+0xa&gt; .word 0x40006898</code> </pre><br>  Sem pausas, sem ciclos extras.  Dois pares de medidas seguidas ... <br><br><img src="https://habrastorage.org/webt/ms/po/gq/mspogqifm21mt0o34s0ltbh1fyu.png"><br><br>  Vamos tornar o c√≥digo um pouco mais real (com a sobrecarga de organizar o ciclo, buscar dados e aumentar os ponteiros): <br><br><pre> <code class="plaintext hljs">void SoftWriteTo0FromROM() { //         . //         static const uint16 steps[] = { 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001, 0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001,0x0001 }; uint16_t* src = steps; volatile uint16_t* dest = (uint16_t*)JustReadFromFIFO_1_Datapath_1_F0_PTR; for (int i=sizeof(steps)/sizeof(steps[0]);i&gt;0;i--) { *dest = *src++; } }</code> </pre><br>  c√≥digo assembler recebido: <br><br><pre> <code class="plaintext hljs"> ldr r3, [pc, #14] ; (9c &lt;CYDEV_CACHE_SIZE&gt;) ldr r0, [pc, #14] ; (a0 &lt;CYDEV_CACHE_SIZE+0x4&gt;) add.w r1, r3, #28 ; 0x28 ldrh.w r2, [r3], #2 cmp r3, r1 strh r2, [r0, #0] bne.n 8e &lt;main+0xa&gt;</code> </pre><br>  No oscilograma, vemos apenas 7 ciclos por ciclo versus nove no caso de DMA: <br><br><img src="https://habrastorage.org/webt/h5/5k/y0/h55ky0f4pfsfaco90dvfgahwwki.png"><br><br><h2>  Um pouco sobre mito </h2><br>  Para ser sincero, para mim foi originalmente um choque.  De alguma forma, estou acostumado a acreditar que o mecanismo DMA permite transferir dados de maneira r√°pida e eficiente.  1/9 da frequ√™ncia do barramento n√£o √© t√£o r√°pido.  Mas aconteceu que ningu√©m estava escondendo isso.  O documento TRM para o PSoC 5LP cont√©m v√°rias considera√ß√µes te√≥ricas, e o documento "T√≥picos avan√ßados de DMA AN84810 - PSoC 3 e PSoC 5LP" descreve em detalhes o processo de acesso ao DMA.  A lat√™ncia √© a culpa.  O ciclo de troca com o √¥nibus leva um certo n√∫mero de ticks.  Na verdade, s√£o essas medidas que desempenham um papel decisivo na ocorr√™ncia de um atraso.  Em geral, ningu√©m esconde nada, mas voc√™ precisa saber disso. <br><br>  <b>Se o famoso GPIF usado no FX2LP (outra arquitetura fabricada pela Cypress) n√£o limita nada, ent√£o aqui o limite de velocidade √© devido √†s lat√™ncias que ocorrem ao acessar o barramento.</b> <br><br><h2>  Verifica√ß√£o de DMA no STM32 </h2><br>  Fiquei t√£o impressionado que decidi realizar um experimento no STM32.  Um STM32F103 com o mesmo n√∫cleo do processador Cortex M3 foi obtido como um coelho experimental.  Ele n√£o possui UDB do qual os sinais de servi√ßo podem ser derivados, mas √© bem poss√≠vel verificar o DMA.  O que √© um GPIO?  Este √© um conjunto de registros em um espa√ßo de endere√ßo comum.  Tudo bem.  Configuramos o DMA no modo de c√≥pia ‚Äúmemory-memory‚Äù, especificando a mem√≥ria real (ROM ou RAM) como fonte e o registro de dados GPIO sem o incremento de endere√ßo como receptor.  Enviaremos para l√° alternadamente 0 ou 1 e corrigiremos o resultado com um oscilosc√≥pio.  Para come√ßar, escolhi a porta B, era mais f√°cil conectar-se a ela na placa de ensaio. <br><br><img src="https://habrastorage.org/webt/od/u2/es/odu2esatrpusmpi8od4ecfaftk8.png"><br><br>  Gostei muito de contar medidas com um dedo, n√£o com cursores.  √â poss√≠vel fazer o mesmo neste controlador?  Bastante!  Pegue a frequ√™ncia do rel√≥gio de refer√™ncia para o oscilosc√≥pio da perna do MCO, que est√° conectada √† porta PA8 no STM32F10C8T6.  A escolha das fontes para este cristal barato n√£o √© √≥tima (o mesmo STM32F103, mas mais impressionante, oferece muito mais op√ß√µes); enviaremos o sinal SYSCLK para essa sa√≠da.  Como a frequ√™ncia no MCO n√£o pode ser superior a 50 MHz, reduziremos a velocidade geral do clock do sistema para 48 MHz.  Multiplicaremos a frequ√™ncia do quartzo 8 MHz, n√£o por 9, mas por 6 (j√° que 6 * 8 = 48): <br><br><img src="https://habrastorage.org/webt/0x/de/1a/0xde1acpu3rpgslyseaw2kcysc4.png"><br><br><div class="spoiler">  <b class="spoiler_title">Mesmo texto:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">void SystemClock_Config(void) { RCC_OscInitTypeDef RCC_OscInitStruct; RCC_ClkInitTypeDef RCC_ClkInitStruct; RCC_PeriphCLKInitTypeDef PeriphClkInit; /**Initializes the CPU, AHB and APB busses clocks */ RCC_OscInitStruct.OscillatorType = RCC_OSCILLATORTYPE_HSE; RCC_OscInitStruct.HSEState = RCC_HSE_ON; RCC_OscInitStruct.HSEPredivValue = RCC_HSE_PREDIV_DIV1; RCC_OscInitStruct.HSIState = RCC_HSI_ON; RCC_OscInitStruct.PLL.PLLState = RCC_PLL_ON; RCC_OscInitStruct.PLL.PLLSource = RCC_PLLSOURCE_HSE; // RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL9; RCC_OscInitStruct.PLL.PLLMUL = RCC_PLL_MUL6; if (HAL_RCC_OscConfig(&amp;RCC_OscInitStruct) != HAL_OK) { _Error_Handler(__FILE__, __LINE__); }</code> </pre><br></div></div><br>  Vamos programar o MCO usando a biblioteca <b>mcucpp</b> de Konstantin Chizhov (a partir de agora, conduzirei todas as chamadas para o equipamento atrav√©s desta maravilhosa biblioteca): <br><br><pre> <code class="plaintext hljs"> //  MCO Mcucpp::Clock::McoBitField::Set (0x4); //   MCO    Mcucpp::IO::Pa8::SetConfiguration (Mcucpp::IO::Pa8::Port::AltFunc); //     Mcucpp::IO::Pa8::SetSpeed (Mcucpp::IO::Pa8::Port::Fastest);</code> </pre><br>  Bem, agora configuramos a sa√≠da da matriz de dados no GPIOB: <br><br><pre> <code class="plaintext hljs">typedef Mcucpp::IO::Pb0 dmaTest0; typedef Mcucpp::IO::Pb1 dmaTest1; ... //  GPIOB      dmaTest0::ConfigPort::Enable(); dmaTest0::SetDirWrite(); dmaTest1::ConfigPort::Enable(); dmaTest1::SetDirWrite(); uint16_t dataForDma[]={0x0000,0x8001,0x0000,0x8001,0x0000, 0x8001,0x0000,0x8001,0x0000,0x8001,0x0000,0x8001,0x0000,0x8001}; typedef Mcucpp::Dma1Channel1 channel; //    dmaTest1::Set(); dmaTest1::Clear(); dmaTest1::Set(); // ,    DMA channel::Init (channel::Mem2Mem|channel::MSize16Bits|channel::PSize16Bits|channel::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); while (1) { } }</code> </pre><br>  A forma de onda resultante √© muito semelhante √† do PSoC. <br><br><img src="https://habrastorage.org/webt/ee/nl/2i/eenl2ix0_9zgzgaaxxeffbjzwjk.png"><br><br>  No meio √© uma grande corcunda azul.  Este √© o processo de inicializa√ß√£o do DMA.  Os pulsos azuis √† esquerda foram recebidos puramente pelo software no PB1.  Amplie-os mais: <br><br><img src="https://habrastorage.org/webt/9l/y8/tp/9ly8tp_8hj1vohrh6jcnyktfa_a.png"><br><br>  2 medidas por pulso.  A opera√ß√£o do sistema √© conforme o esperado.  Mas agora vamos olhar para a √°rea maior marcada na forma de onda principal com um fundo azul escuro.  Neste ponto, o bloco DMA j√° est√° em execu√ß√£o. <br><br><img src="https://habrastorage.org/webt/jw/fu/ds/jwfudsdqtgwfunc3htoczgrw5eg.png"><br><br>  10 ciclos por mudan√ßa de linha GPIO.  Na verdade, o trabalho segue com a RAM e o programa √© repetido em um ciclo constante.  N√£o h√° chamadas para RAM a partir do n√∫cleo do processador.  O barramento est√° completamente √† disposi√ß√£o da unidade DMA, mas 10 ciclos.  Mas, na verdade, os resultados n√£o s√£o muito diferentes daqueles observados no PSoC; portanto, comece a procurar por Notas de aplicativos relacionadas ao DMA no STM32.  Havia v√°rios deles.  H√° AN2548 em F0 / F1, h√° AN3117 em L0 / L1 / L3, h√° AN4031 em F2 / F4 / F77.  Talvez haja mais alguns ... <br><br>  Mas, no entanto, a partir deles, vemos que aqui tamb√©m a culpa √© da lat√™ncia.  Al√©m disso, o acesso em lote do F103 ao barramento com DMA √© imposs√≠vel.  Eles s√£o poss√≠veis para F4, mas n√£o mais do que quatro palavras.  Ent√£o, novamente, o problema de lat√™ncia surgir√°. <br><br>  Vamos tentar executar as mesmas a√ß√µes, mas com a ajuda de um registro do programa.  Acima, vimos que a grava√ß√£o direta nas portas √© instant√¢nea.  Mas havia um registro perfeito.  Linhas: <br><br><pre> <code class="plaintext hljs">//    dmaTest1::Set(); dmaTest1::Clear(); dmaTest1::Set();</code> </pre><br>  sujeito a essas configura√ß√µes de otimiza√ß√£o (voc√™ deve especificar a otimiza√ß√£o por tempo): <br><br><img src="https://habrastorage.org/webt/zz/cs/vt/zzcsvtte2m06u7tzhkfefvfa8wg.png"><br><br>  transformado no seguinte c√≥digo do assembler: <br><br><pre> <code class="plaintext hljs"> STR r6,[r2,#0x00] MOV r0,#0x20000 STR r0,[r2,#0x00] STR r6,[r2,#0x00]</code> </pre><br>  Na c√≥pia real, haver√° uma chamada para a fonte, para o receptor, uma altera√ß√£o na vari√°vel do loop, ramifica√ß√£o ... Em geral, muita sobrecarga (que, como se acredita, elimina apenas o DMA).  Qual ser√° a velocidade das mudan√ßas no porto?  Ent√£o, escrevemos: <br><br><pre> <code class="plaintext hljs">uint16_t* src = dataForDma; uint16_t* dest = (uint16_t*)&amp;GPIOB-&gt;ODR; for (int i=sizeof(dataForDma)/sizeof(dataForDma[0]);i&gt;0;i--) { *dest = *src++; }</code> </pre><br>  Esse c√≥digo C ++ se transforma em um c√≥digo de montagem: <br><br><pre> <code class="plaintext hljs"> MOVS r1,#0x0E LDRH r3,[r0],#0x02 STRH r3,[r2,#0x00] LDRH r3,[r0],#0x02 SUBS r1,r1,#2 STRH r3,[r2,#0x00] CMP r1,#0x00 BGT 0x080032A8</code> </pre><br>  E temos: <br><br><img src="https://habrastorage.org/webt/oj/m5/1d/ojm51d2qjhkz_rii2zfb4zvzdos.png"><br><br>  8 medidas no meio-ciclo superior e 6 na metade inferior (verifiquei, o resultado √© repetido para todos os semestres).  A diferen√ßa surgiu porque o otimizador fez 2 c√≥pias por itera√ß√£o.  Portanto, duas medidas em um dos per√≠odos semestrais s√£o adicionadas √† opera√ß√£o da filial. <br><br>  <b>Grosso modo, com a c√≥pia de software, 14 medidas s√£o gastas na c√≥pia de duas palavras contra 20 medidas na mesma, mas pelo DMA.</b>  <b>O resultado √© bastante documentado, mas muito inesperado para quem ainda n√£o leu a literatura extensa.</b> <br><br>  Bom  Mas o que acontece se voc√™ come√ßar a gravar dados em dois fluxos de DMA ao mesmo tempo?  Quanta velocidade cair√°?  Conecte o blue ray ao PA0 e reescreva o programa da seguinte maneira: <br><br><pre> <code class="plaintext hljs">typedef Mcucpp::Dma1Channel1 channel1; typedef Mcucpp::Dma1Channel2 channel2; // ,    DMA channel1::Init (channel1::Mem2Mem|channel1::MSize16Bits|channel1::PSize16Bits|channel1::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2);</code> </pre><br>  Primeiro, vamos examinar a natureza dos pulsos: <br><br><img src="https://habrastorage.org/webt/vu/ki/pg/vukipghxkaqqtxdnvz4a2qjp1wu.png"><br><br>  Enquanto o segundo canal est√° sendo sintonizado, a velocidade de c√≥pia do primeiro √© mais alta.  Ent√£o, ao copiar em pares, a velocidade diminui.  Quando o primeiro canal termina, o segundo come√ßa a funcionar mais rapidamente.  Tudo √© l√≥gico, resta apenas descobrir exatamente quanto a velocidade cai. <br><br>  Enquanto houver apenas um canal, a grava√ß√£o leva de 10 a 12 compassos (os d√≠gitos est√£o flutuando). <br><br><img src="https://habrastorage.org/webt/iw/1l/lk/iw1llkwh0nki1yczmva7gzxgrgk.png"><br><br>  Durante a colabora√ß√£o, obtemos 16 ciclos por registro em cada porta: <br><br><img src="https://habrastorage.org/webt/f6/vf/o3/f6vfo3mgv4mpos2kdrrwmo9dzsm.png"><br><br>  Ou seja, a velocidade n√£o √© reduzida pela metade.  Mas e se voc√™ come√ßar a escrever em tr√™s t√≥picos ao mesmo tempo?  Adicionamos trabalho ao PC15, pois PC0 n√£o √© emitido (√© por isso que 0, 1, 0, 1 ..., mas 0x0000,0x8001, 0x0000, 0x8001 ... s√£o emitidos na matriz). <br><br><pre> <code class="plaintext hljs">typedef Mcucpp::Dma1Channel1 channel1; typedef Mcucpp::Dma1Channel2 channel2; typedef Mcucpp::Dma1Channel3 channel3; // ,    DMA channel1::Init (channel1::Mem2Mem|channel1::MSize16Bits|channel1::PSize16Bits|channel1::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel3::Init (channel3::Mem2Mem|channel3::MSize16Bits|channel3::PSize16Bits|channel3::PeriphIncriment,(void*)&amp;GPIOC-&gt;ODR,dataForDma,sizeof(dataForDma)/2);</code> </pre><br>  Aqui o resultado √© t√£o inesperado que desligo o feixe que exibe a frequ√™ncia do rel√≥gio.  N√£o temos tempo para medi√ß√µes.  N√≥s olhamos para a l√≥gica do trabalho. <br><br><img src="https://habrastorage.org/webt/zo/u3/5s/zou35sqtetrlryln8lxe04tdkwy.png"><br><br>  At√© o primeiro canal terminar o trabalho, o terceiro n√£o come√ßou.  Tr√™s canais ao mesmo tempo n√£o funcionam!  Alguma coisa sobre esse t√≥pico pode ser deduzida do AppNote para o DMA, que diz que o F103 possui apenas dois mecanismos em um bloco (e copiamos usando um bloco de DMA, o segundo est√° ocioso agora e o volume do artigo j√° √© tal que eu posso us√°-lo Eu n√£o vou).  Reescrevemos o programa de amostra para que o terceiro canal inicie mais cedo do que todos os outros: <br><br><img src="https://habrastorage.org/webt/bs/ld/kc/bsldkce9ztqrbk15x7e1omcharg.png"><br><br><div class="spoiler">  <b class="spoiler_title">Mesmo texto:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">// ,    DMA channel3::Init (channel3::Mem2Mem|channel3::MSize16Bits|channel3::PSize16Bits|channel3::PeriphIncriment,(void*)&amp;GPIOC-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel1::Init (channel1::Mem2Mem|channel1::MSize16Bits|channel1::PSize16Bits|channel1::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2);</code> </pre><br></div></div><br>  A imagem mudar√° da seguinte forma: <br><br><img src="https://habrastorage.org/webt/jg/wr/_2/jgwr_2kidbaoxg_-17muiyvo3n4.png"><br><br>  O terceiro canal foi lan√ßado, at√© trabalhou em conjunto com o primeiro, mas quando o segundo entrou no neg√≥cio, o terceiro foi suplantado at√© a conclus√£o do primeiro canal. <br><br><h2>  Um pouco sobre prioridades </h2><br>  Na verdade, a imagem anterior est√° relacionada √†s prioridades da DMA, existem algumas.  Se todos os canais em funcionamento tiverem a mesma prioridade, seus n√∫meros entrar√£o em jogo.  Dentro de uma determinada prioridade, quem tem um n√∫mero menor √© aquele que tem prioridade.  Vamos tentar o terceiro canal para indicar uma prioridade global diferente, elevando-a acima de todos os outros (ao longo do caminho, tamb√©m aumentaremos a prioridade do segundo canal): <br><br><img src="https://habrastorage.org/webt/40/qo/c5/40qoc5ngwnq2tenzpmcc2ornd4w.png"><br><br><div class="spoiler">  <b class="spoiler_title">Mesmo texto:</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">channel3::Init (channel3::PriorityVeryHigh|channel3::Mem2Mem|channel3::MSize16Bits|channel3::PSize16Bits|channel3::PeriphIncriment,(void*)&amp;GPIOC-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel1::Init (channel1::Mem2Mem|channel1::MSize16Bits|channel1::PSize16Bits|channel1::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel1::PriorityVeryHigh|channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2);</code> </pre><br></div></div><br>  Agora, o primeiro que costumava ser o mais legal ficar√° em desvantagem. <br><br><img src="https://habrastorage.org/webt/te/mq/_7/temq_7wguw109a0t-oi_rsi3jju.png"><br><br>  No total, vemos que, mesmo reproduzindo prioridades, o STM32F103 n√£o pode iniciar mais de dois threads em um bloco DMA.  Em princ√≠pio, o terceiro segmento pode ser executado no n√∫cleo do processador.  Isso nos permitir√° comparar o desempenho. <br><br><pre> <code class="plaintext hljs">// ,    DMA channel3::Init (channel3::Mem2Mem|channel3::MSize16Bits|channel3::PSize16Bits|channel3::PeriphIncriment,(void*)&amp;GPIOC-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2); uint16_t* src = dataForDma; uint16_t* dest = (uint16_t*)&amp;GPIOB-&gt;ODR; for (int i=sizeof(dataForDma)/sizeof(dataForDma[0]);i&gt;0;i--) { *dest = *src++; }</code> </pre><br>  Primeiro, a imagem geral, que mostra que tudo funciona em paralelo e o n√∫cleo do processador tem a maior velocidade de c√≥pia: <br><br><img src="https://habrastorage.org/webt/yq/bc/ah/yqbcahagnawdxrr70dh7zvbetmo.png"><br><br>  E agora darei a todos a oportunidade de contar as medidas no momento em que todos os fluxos de c√≥pias estiverem ativos: <br><br> <a href=""><img src="https://habrastorage.org/webt/_m/m9/2b/_mm92b5yfgjltz6cizilmdtg4d4.png"></a> <br><br><h2>  O n√∫cleo do processador prioriza todos </h2><br>  Agora, voltemos ao fato de que, durante a opera√ß√£o de dois segmentos, enquanto o segundo canal foi sintonizado, o primeiro forneceu dados para um n√∫mero diferente de ciclos de clock.  Esse fato tamb√©m est√° bem documentado no AppNote no DMA.  O fato √© que, durante a instala√ß√£o do segundo canal, as solicita√ß√µes √† RAM eram enviadas periodicamente e o n√∫cleo do processador tem maior prioridade ao acessar a RAM do que o n√∫cleo do DMA.  Quando o processador solicitou alguns dados, o DMA retirou os ciclos do rel√≥gio, recebeu os dados com um atraso e, portanto, copiou mais lentamente.  Vamos fazer o √∫ltimo experimento de hoje.  Vamos trazer o trabalho para um mais real.  Ap√≥s iniciar o DMA, n√£o entraremos em um ciclo vazio (quando definitivamente n√£o houver acesso √† RAM), mas executaremos uma opera√ß√£o de c√≥pia da RAM para a RAM, mas essa opera√ß√£o n√£o estar√° relacionada √† opera√ß√£o dos n√∫cleos do DMA: <br><br><pre> <code class="plaintext hljs">channel1::Init (channel1::Mem2Mem|channel1::MSize16Bits|channel1::PSize16Bits|channel1::PeriphIncriment,(void*)&amp;GPIOB-&gt;ODR,dataForDma,sizeof(dataForDma)/2); channel2::Init (channel2::Mem2Mem|channel2::MSize16Bits|channel2::PSize16Bits|channel2::PeriphIncriment,(void*)&amp;GPIOA-&gt;ODR,dataForDma,sizeof(dataForDma)/2); uint32_t src1[0x200]; uint32_t dest1 [0x200]; while (1) { uint32_t* src = src1; uint32_t* dest = dest1; for (int i=sizeof(src1)/sizeof(src1[0]);i&gt;0;i--) { *dest++ = *src++; } }</code> </pre><br> <a href=""><img src="https://habrastorage.org/webt/ks/k-/c6/ksk-c6feobygy2krzseq0nlka78.png"></a> <br><br>  Em alguns lugares, o ciclo aumentou de 16 para 17 medidas.  Eu tinha medo que fosse pior. <br><br><h2>  Comece a tirar conclus√µes </h2><br>  Na verdade, nos voltamos para o que eu queria dizer. <br><br>  Vou come√ßar de longe.  Alguns anos atr√°s, quando comecei a estudar o STM32, estudei as vers√µes do MiddleWare para USB existentes naquele momento e me perguntei por que os desenvolvedores removeram a transfer√™ncia de dados por meio do DMA.  Era evidente que inicialmente essa op√ß√£o estava √† vista, depois foi removida para os quintais e, no final, havia apenas rudimentos.  Agora estou come√ßando a suspeitar que entendo os desenvolvedores. <br><br>  No <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeiro artigo sobre o UDB,</a> eu disse que, embora o UDB possa trabalhar com dados paralelos, √© improv√°vel que ele possa substituir o GPIF por si mesmo, j√° que o barramento USB do PSoC roda em velocidade m√°xima versus alta velocidade para FX2LP.  Acontece que h√° um fator limitante mais s√©rio.  O DMA simplesmente n√£o tem tempo para fornecer dados na mesma velocidade que o GPIF, mesmo dentro do controlador, sem levar em considera√ß√£o o barramento USB. <br><br>  Como voc√™ pode ver, n√£o h√° DMA de entidade √∫nica.  Em primeiro lugar, cada fabricante faz o seu pr√≥prio caminho.  N√£o apenas isso, mesmo um fabricante para fam√≠lias diferentes pode variar a abordagem de cria√ß√£o de DMA.  Se voc√™ planeja carregar seriamente esta unidade, considere cuidadosamente se as necessidades ser√£o atendidas. <br><br>  Provavelmente, √© necess√°rio diluir o fluxo pessimista com uma observa√ß√£o otimista.  Vou at√© destac√°-la. <br><br>  <b>O DMA dos controladores Cortex M permite aumentar o desempenho do sistema com base no princ√≠pio dos famosos Javelins: "Iniciar e esquecer".</b>  <b>Sim, a c√≥pia de dados de software √© um pouco mais r√°pida.</b>  <b>Por√©m, se voc√™ precisar copiar v√°rios encadeamentos, nenhum otimizador poder√° fazer com que o processador os conduza sem a sobrecarga de recarregar e girar loops de registro.</b>  <b>Al√©m disso, para portas lentas, o processador ainda deve aguardar disponibilidade e o DMA faz isso no n√≠vel do hardware.</b> <br><br>  Mas mesmo aqui v√°rias nuances s√£o poss√≠veis.  Se a porta for relativamente lenta ... Bem, digamos, um SPI operando na frequ√™ncia mais alta poss√≠vel, existem teoricamente poss√≠veis situa√ß√µes em que o DMA n√£o tem tempo para coletar dados do buffer e ocorre um estouro.  Ou vice-versa - coloque os dados no registro do buffer.  Quando o fluxo de dados √© √∫nico, √© improv√°vel que isso aconte√ßa, mas quando existem muitos deles, vimos que sobreposi√ß√µes incr√≠veis podem ocorrer.  Para lidar com isso, voc√™ deve desenvolver tarefas n√£o separadamente, mas em combina√ß√£o.  E os testadores tentam provocar esses problemas (um trabalho destrutivo para os testadores). <br><br>  Mais uma vez, ningu√©m oculta esses dados.  Mas, por alguma raz√£o, tudo isso geralmente n√£o est√° contido no documento principal, mas nas Notas sobre o Aplicativo.  Portanto, minha tarefa era chamar a aten√ß√£o dos programadores para o fato de que o DMA n√£o √© uma panac√©ia, mas apenas uma ferramenta conveniente. <br><br>  Mas, √© claro, n√£o apenas programadores, mas tamb√©m desenvolvedores de hardware.  Digamos, em nossa organiza√ß√£o, um grande complexo de software e hardware esteja sendo desenvolvido para depura√ß√£o remota de sistemas embarcados.  A id√©ia √© que algu√©m esteja desenvolvendo um dispositivo, mas queira solicitar o "firmware" ao lado.  E por algum motivo, n√£o pode fornecer equipamentos para o lado.  Pode ser volumoso, pode ser caro, pode ser √∫nico e "precisar de voc√™", diferentes grupos podem trabalhar com ele em fusos hor√°rios diferentes, fornecendo uma esp√©cie de trabalho em v√°rios turnos, que pode ser constantemente lembrado ... Em geral, voc√™ pode apresentar raz√µes muito, nosso grupo simplesmente deixou essa tarefa como garantida. <br><br>  Dessa forma, o complexo de depura√ß√£o deve ser capaz de simular o maior n√∫mero poss√≠vel de dispositivos externos, da simula√ß√£o trivial de pressionamento de bot√£o a v√°rios protocolos SPI, I2C, CAN, 4-20 mA e outras outras coisas, para que atrav√©s deles os emuladores possam recriar um comportamento diferente blocos conectados ao equipamento que est√° sendo desenvolvido (eu pessoalmente fiz v√°rios simuladores para depura√ß√£o em terra de acess√≥rios para helic√≥pteros, em nosso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">site os casos correspondentes s√£o pesquisados ‚Äã‚Äãpela palavra Cassel Aero</a> ). <br><br>  E assim, nos requisitos t√©cnicos para o desenvolvimento de certos requisitos.  Tanto SPI, tanto I2C, tanto GPIO.  Eles devem operar em tais e tais frequ√™ncias extremas.  Tudo parece estar claro.  Colocamos STM32F4 e ULPI para trabalhar com USB no modo HS.  A tecnologia √© comprovada.  Mas aqui chega um longo fim de semana com as f√©rias de novembro, que eu descobri com o UDB.  Vendo que algo estava errado, √† noite eu obtive os resultados pr√°ticos que s√£o dados no come√ßo deste artigo.  E percebi que tudo, √© claro, √© √≥timo, mas n√£o para este projeto.  Como j√° observei, quando o poss√≠vel desempenho m√°ximo do sistema se aproxima do limite superior, tudo deve ser projetado n√£o separadamente, mas em um complexo. <br><br>  Mas aqui o design integrado de tarefas n√£o pode ser em princ√≠pio.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hoje estamos trabalhando com um equipamento de terceiros, amanh√£ - com completamente diferente. Os √¥nibus ser√£o usados ‚Äã‚Äãpelos programadores para cada caso de emula√ß√£o, a seu crit√©rio. Portanto, a op√ß√£o foi rejeitada, v√°rias pontes FTDI diferentes foram adicionadas ao circuito. Dentro da ponte, uma, duas ou quatro fun√ß√µes ser√£o resolvidas de acordo com um esquema r√≠gido e, entre as pontes, o host USB resolver√° tudo.</font></font> Infelizmente.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nesta tarefa, n√£o posso confiar no DMA. </font><font style="vertical-align: inherit;">√â claro que voc√™ pode dizer que os programadores sair√£o, mas as horas para o processo de truque s√£o custos de m√£o-de-obra que devem ser evitados. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas isso √© um extremo. </font><font style="vertical-align: inherit;">Na maioria das vezes, voc√™ s√≥ precisa ter em mente as limita√ß√µes do subsistema DMA (por exemplo, introduza um fator de corre√ß√£o 10: se precisar de um fluxo de 1 milh√£o de transa√ß√µes por segundo, considere que n√£o s√£o 1 milh√£o, mas 10 milh√µes de ciclos) e considere o desempenho em conjunto.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt437112/">https://habr.com/ru/post/pt437112/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt437102/index.html">Novo encontro de campe√µes de Lego: Lego Boost</a></li>
<li><a href="../pt437104/index.html">Introsc√≥pio: bem, teste de unidade muito pregui√ßoso</a></li>
<li><a href="../pt437106/index.html">TI na zona .it</a></li>
<li><a href="../pt437108/index.html">A maioria dos textos na Internet √© escrita por loucos.</a></li>
<li><a href="../pt437110/index.html">Os nanomateriais est√£o mudando nosso mundo e ainda n√£o temos procedimentos para verificar sua seguran√ßa</a></li>
<li><a href="../pt437114/index.html">Semin√°rio on-line aberto: ‚ÄúSSH / NC / Socat: dicas e truques‚Äù</a></li>
<li><a href="../pt437116/index.html">AWS, MongoDB e as realidades econ√¥micas do c√≥digo aberto</a></li>
<li><a href="../pt437118/index.html">AI e 2048. Parte 1: M√©todo Monte Carlo</a></li>
<li><a href="../pt437120/index.html">Cadeira de escrit√≥rio coreana: sensa√ß√µes Harachair Miracle</a></li>
<li><a href="../pt437122/index.html">Nomeando coisas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>