<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛬 🧔🏻 🆓 OOP in der R-Sprache (Teil 1): S3-Klassen 🍮 💪🏾 🎡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="R ist eine objektorientierte Sprache. Darin ist absolut alles ein Objekt, beginnend mit Funktionen und endend mit Tabellen. 


 Jedes Objekt in R gehö...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OOP in der R-Sprache (Teil 1): S3-Klassen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453964/"><p>  R ist eine objektorientierte Sprache.  Darin ist absolut alles ein Objekt, beginnend mit Funktionen und endend mit Tabellen. </p><br><p>  Jedes Objekt in R gehört wiederum zu einer Klasse.  In der Welt um uns herum ist die Situation ungefähr gleich.  Wir sind von Objekten umgeben und jedes Objekt kann einer Klasse zugeordnet werden.  Eine Klasse bestimmt die Eigenschaften und Aktionen, die mit diesem Objekt ausgeführt werden können. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6c5/79c/992/6c579c992140a44ceb85c0359165ec15.jpg" alt="Bild"></p><a name="habracut"></a><br><p> Zum Beispiel gibt es in jeder Küche einen Tisch und einen Herd.  Und der Küchentisch und der Herd können als Küchengeräte bezeichnet werden.  Die Eigenschaften des Tisches sind in der Regel durch Abmessungen, Farbe und Material begrenzt, aus dem er besteht.  Der Ofen hat ein breiteres Spektrum an Eigenschaften, zumindest die Leistung, die Anzahl der Brenner und die Art des Ofens (elektrisch oder gasförmig) sind obligatorisch. </p><br><p>  Aktionen, die für Objekte ausgeführt werden können, werden als ihre Methoden bezeichnet.  Für die Tabelle bzw. die Platte sind die Methoden ebenfalls unterschiedlich.  Sie können am Tisch zu Abend essen, Sie können darauf kochen, aber es ist unmöglich, Lebensmittel, für die normalerweise ein Herd verwendet wird, wärmebehandelt zu werden. <br><img src="https://habrastorage.org/getpro/habr/post_images/8f8/8a9/06d/8f88a906d52701c8a5059106b2148fca.jpg" alt="Bild"></p><br><h2 id="soderzhanie">  Inhalt </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klasseneigenschaften</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verallgemeinerte Funktionen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist eine S3-Klasse und wie erstelle ich eine eigene Klasse?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zuweisungsfunktionen für benutzerdefinierte S3-Klassen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklung benutzerdefinierter Methoden für die generische Druckfunktion</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erstellen einer verallgemeinerten Funktion und Methoden dafür</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vererbung</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Wenn Sie Ihre eigenen Klassen verwenden können</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fazit</a> </li></ul><br><h2 id="svoystva-klassov">  Klasseneigenschaften </h2><br><p>  In R gehört jedes Objekt auch zu einer Klasse.  Abhängig von der Klasse verfügt es über bestimmte Eigenschaften und Methoden.  In Bezug auf die objektorientierte Programmierung (OOP) wird die Möglichkeit, ähnliche Eigenschaften und Methoden von Objekten in Gruppen (Klassen) zu kombinieren, als <strong>Kapselung bezeichnet</strong> . </p><br><p>  Ein Vektor ist die einfachste Klasse von Objekten in R und hat die Eigenschaft der Länge.  Als Beispiel nehmen wir die eingebauten <em>Vektorbuchstaben</em> . </p><br><pre><code class="plaintext hljs">length(letters)</code> </pre> <br><pre> <code class="plaintext hljs">[1] 26</code> </pre> <br><p>  Mit der <code>length</code> haben wir die Länge des <em>Buchstabenvektors erhalten</em> .  Versuchen wir nun, dieselbe Funktion auf den in die <em>Iris</em> integrierten Datumsrahmen anzuwenden. </p><br><pre> <code class="plaintext hljs">length(iris)</code> </pre> <br><pre> <code class="plaintext hljs">[1] 5</code> </pre> <br><p>  Die für Tabellen geltende Längenfunktion gibt die Anzahl der Spalten zurück. </p><br><p>  Tabellen haben auch eine andere Eigenschaft, Dimension. </p><br><pre> <code class="plaintext hljs">dim(iris)</code> </pre> <br><pre> <code class="plaintext hljs">[1] 150 5</code> </pre> <br><p>  Die <code>dim</code> Funktion im obigen Beispiel zeigt Informationen an, dass die <em>Iris-</em> Tabelle 150 Zeilen und 5 Spalten enthält. </p><br><p>  Der Vektor hat wiederum keine Dimension. </p><br><pre> <code class="plaintext hljs">dim(letters)</code> </pre><br><pre> <code class="plaintext hljs">NULL</code> </pre> <br><p>  Daher haben wir sichergestellt, dass Objekte verschiedener Klassen unterschiedliche Eigenschaften haben. </p><br><h2 id="obobschyonnye-funkcii">  Verallgemeinerte Funktionen </h2><br><p>  R hat viele allgemeine Funktionen: <code>print</code> , <code>plot</code> , <code>summary</code> usw.  Diese Funktionen funktionieren unterschiedlich mit Objekten verschiedener Klassen. </p><br><p>  Nehmen Sie zum Beispiel die <code>plot</code> .  Lassen Sie es uns ausführen, indem Sie die <em>Iris-</em> Tabelle als Hauptargument übergeben. </p><br><p> <code>plot(iris)</code> </p> <br><p>  <strong>Ergebnis:</strong> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0ae/432/7ba/0ae4327babecab1c6f76a19b311450d3.png" alt="Das Ergebnis der Plotfunktion"></p><br><p>  Versuchen wir nun, einen Vektor von 100 Zufallszahlen mit normaler Verteilung an die Plotfunktion zu übergeben. </p><br><p> <code>plot(rnorm(100, 50, 30))</code> </p> <br><p>  <strong>Ergebnis:</strong> </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/4f7/c3e/85d/4f7c3e85d80cbcdf4484d201bd17ec99.png" alt="Das Ergebnis der Plotfunktion"></p><br><p>  Wir haben verschiedene Graphen erhalten, im ersten Fall die Korrelationsmatrix, im zweiten das Streudiagramm, auf dem der Beobachtungsindex entlang der x-Achse angezeigt wird, und seinen Wert entlang der y-Achse. </p><br><p>  Somit kann sich die Plotfunktion an die Arbeit mit verschiedenen Klassen anpassen.  Wenn wir zur OOP-Terminologie zurückkehren, wird die Fähigkeit, die Klasse eines eingehenden Objekts zu bestimmen und verschiedene Aktionen mit Objekten verschiedener Klassen auszuführen, als <strong>Polymorphismus bezeichnet</strong> .  Dies liegt an der Tatsache, dass diese Funktion nur ein Wrapper für eine Vielzahl von Methoden ist, die für die Arbeit mit verschiedenen Klassen geschrieben wurden.  Sie können dies mit dem folgenden Befehl überprüfen: </p><br><pre> <code class="plaintext hljs">body(plot)</code> </pre> <br><pre> <code class="plaintext hljs">UseMethod("plot")</code> </pre> <br><p>  Der Befehl <code>body</code> druckt den Funktionskörper auf die R-Konsole.  Wie Sie sehen können, besteht der Hauptteil der Körperfunktion aus nur einem <code>UseMethod("plot")</code> . </p><br><p>  Das heißt,  Die <code>plot</code> startet nur eine der vielen Methoden, die in sie geschrieben wurden, abhängig von der Klasse des Objekts, das an sie übergeben wurde.  Zeigen Sie eine Liste aller Methoden wie folgt an. </p><br><pre> <code class="plaintext hljs">methods(plot)</code> </pre> <br><pre> <code class="plaintext hljs"> [1] plot.acf* plot.data.frame* plot.decomposed.ts* [4] plot.default plot.dendrogram* plot.density* [7] plot.ecdf plot.factor* plot.formula* [10] plot.function plot.hclust* plot.histogram* [13] plot.HoltWinters* plot.isoreg* plot.lm* [16] plot.medpolish* plot.mlm* plot.ppr* [19] plot.prcomp* plot.princomp* plot.profile.nls* [22] plot.raster* plot.spec* plot.stepfun [25] plot.stl* plot.table* plot.ts [28] plot.tskernel* plot.TukeyHSD*</code> </pre> <br><p>  Das Ergebnis zeigt an, dass die <em>Plotfunktion</em> über 29 Methoden verfügt, darunter die <em>Datei plot.default</em> , die standardmäßig funktioniert, wenn die Funktion ein Objekt einer unbekannten Klasse für die Eingabe empfängt. </p><br><p>  Mit der <code>methods</code> können Sie auch eine Reihe aller verallgemeinerten Funktionen abrufen, für die eine Methode für eine beliebige Klasse geschrieben wurde. </p><br><pre> <code class="plaintext hljs">methods(, "data.frame")</code> </pre> <br><pre> <code class="plaintext hljs"> [1] $&lt;- [ [[ [[&lt;- [5] [&lt;- aggregate anyDuplicated as.data.frame [9] as.list as.matrix by cbind [13] coerce dim dimnames dimnames&lt;- [17] droplevels duplicated edit format [21] formula head initialize is.na [25] Math merge na.exclude na.omit [29] Ops plot print prompt [33] rbind row.names row.names&lt;- rowsum [37] show slotsFromS3 split split&lt;- [41] stack str subset summary [45] Summary t tail transform [49] type.convert unique unstack within</code> </pre> <br><h2 id="chto-takoe-s3-klass-i-kak-sozdat-sobstvennyy-klass">  Was ist eine S3-Klasse und wie erstelle ich eine eigene Klasse? </h2><br><p>  Es gibt eine Reihe von Klassen in R, die Sie selbst erstellen können.  Eines der beliebtesten ist S3. </p><br><p>  Diese Klasse ist eine Liste, in der verschiedene Eigenschaften der von Ihnen erstellten Klasse gespeichert sind.  Um eine eigene Klasse zu erstellen, erstellen Sie einfach eine <em>Liste</em> und geben Sie ihr einen Klassennamen. </p><br><p>  Das Buch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Die Kunst des Programmierens in R"</a> gibt ein Beispiel für die <em>Mitarbeiterklasse</em> , in der Informationen über den Mitarbeiter gespeichert sind.  Als Beispiel für diesen Artikel habe ich mich auch für ein Objekt zum Speichern von Informationen über Mitarbeiter entschieden.  Aber machte es komplexer und funktionaler. </p><br><pre> <code class="plaintext hljs">#    employee1 &lt;- list(name = "Oleg", surname = "Petrov", salary = 1500, salary_datetime = Sys.Date(), previous_sallary = NULL, update = Sys.time()) #    class(employee1) &lt;- "emp"</code> </pre> <br><p>  Daher haben wir unsere eigene Klasse erstellt, die die folgenden Daten in ihrer Struktur speichert: </p><br><ul><li>  Name des Mitarbeiters </li><li>  Familienname des Mitarbeiters </li><li>  Gehalt </li><li>  Der Zeitpunkt, zu dem das Gehalt festgelegt wurde </li><li>  Vorheriges Gehalt </li><li>  Datum und Uhrzeit der letzten Aktualisierung der Informationen </li></ul><br><p>  Danach weisen wir mit dem Befehl <code>class(employee1) &lt;- "emp"</code> dem Objekt die Klasse <em>emp</em> zu. </p><br><p>  Zum bequemen Erstellen von Objekten der Klasse <em>emp können</em> Sie eine Funktion schreiben. </p><br><div class="spoiler">  <b class="spoiler_title">Funktionscode zum Erstellen von emp-Klassenobjekten</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#     create_employee &lt;- function(name, surname, salary, salary_datetime = Sys.Date(), update = Sys.time()) { out &lt;- list(name = name, surname = surname, salary = salary, salary_datetime = salary_datetime, previous_sallary = NULL, update = update) class(out) &lt;- "emp" return(out) } #    emp    create_employee employee1 &lt;- create_employee("Oleg", "Petrov", 1500) #     class(employee1)</code> </pre> <br><pre> <code class="plaintext hljs">[1] "emp"</code> </pre> </div></div><br><h2 id="funkcii-prisvaivaniya-znacheniy-polzovatelskim-s3-klassam">  Zuweisungsfunktionen für benutzerdefinierte S3-Klassen </h2><br><p>  Also haben wir unser eigenes Klassen- <em>Emp geschaffen</em> , aber bisher hat uns das nichts gegeben.  Mal sehen, warum wir unsere eigene Klasse erstellt haben und was wir damit machen können. </p><br><p>  Zunächst können Sie Zuweisungsfunktionen für die erstellte Klasse schreiben. </p><br><div class="spoiler">  <b class="spoiler_title">Zuweisungsfunktion für [</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">"[&lt;-.emp" &lt;- function(x, i, value) { if ( i == "salary" || i == 3 ) { cat(x$name, x$surname, "has changed salary from", x$salary, "to", value) x$previous_sallary &lt;- x$salary x$salary &lt;- value x$salary_datetime &lt;- Sys.Date() x$update &lt;- Sys.time() } else { cat( "You can`t change anything except salary" ) } return(x) }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Zuweisungsfunktion für [[</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">"[[&lt;-.emp" &lt;- function(x, i, value) { if ( i == "salary" || i == 3 ) { cat(x$name, x$surname, "has changed salary from", x$salary, "to", value) x$previous_sallary &lt;- x$salary x$salary &lt;- value x$salary_datetime &lt;- Sys.Date() x$update &lt;- Sys.time() } else { cat( "You can`t change anything except salary" ) } return(x) }</code> </pre> </div></div><br><p>  Zuweisungsfunktionen bei der Erstellung werden immer in Anführungszeichen gesetzt und sehen folgendermaßen aus: <code>"[&lt;-. " / "[[&lt;-. "</code> .  Und sie haben 3 erforderliche Argumente. </p><br><ul><li>  <strong>x</strong> - Das Objekt, dem der Wert zugewiesen wird; </li><li>  <strong>i</strong> - Name / Index des Elements des Objekts (Name, Nachname, Gehalt, Gehaltsdatenzeit, vorherige_Zahlung, Aktualisierung); </li><li>  <strong>value</strong> - Der zugewiesene Wert. </li></ul><br><p>  Weiter im Hauptteil der Funktion schreiben Sie, wie sich die Elemente Ihrer Klasse ändern sollen.  In meinem Fall möchte ich, dass der Benutzer nur das Gehalt ändern kann <em>(</em> Gehaltselement <em>, dessen Index 3 ist)</em> .  Daher schreibe ich innerhalb der Funktion einen <code>if ( i == "salary" || i == 3 )</code> Check <code>if ( i == "salary" || i == 3 )</code> .  Wenn der Benutzer versucht, andere Eigenschaften zu bearbeiten, erhält er die Meldung <code>"You can't change anything except salary"</code> . </p><br><p>  Wenn das <em>Gehaltselement geändert wird, wird eine</em> Meldung angezeigt, die den Vor- und Nachnamen des Mitarbeiters sowie seine aktuelle und neue Gehaltsstufe enthält.  Das aktuelle Gehalt wird an die Eigenschaft <em>previous_sallary übergeben</em> , und dem <em>Gehalt wird</em> ein neuer Wert zugewiesen.  Die Werte der Eigenschaften <em>Salary_Datetime</em> und <em>Update</em> werden ebenfalls aktualisiert. </p><br><p>  Jetzt können Sie versuchen, das Gehalt zu ändern. </p><br><pre> <code class="plaintext hljs">employee1["salary"] &lt;- 1750</code> </pre> <br><pre> <code class="plaintext hljs">Oleg Petrov has changed salary from 1500 to 1750</code> </pre> <br><h2 id="razrabotka-sobstvennyh-metodov-dlya-obobschyonnyh-funkciy">  Entwicklung benutzerdefinierter Methoden für generische Funktionen </h2><br><p>  Sie haben bereits zuvor erfahren, dass es in R verallgemeinerte Funktionen gibt, die ihr Verhalten abhängig von der Klasse ändern, die an der Eingabe des Objekts empfangen wird. </p><br><p>  Sie können Ihre Methoden zu vorhandenen verallgemeinerten Funktionen hinzufügen und sogar Ihre eigenen verallgemeinerten Funktionen erstellen. </p><br><p>  Eine der am häufigsten verwendeten generischen Funktionen ist das <code>print</code> .  Diese Funktion wird jedes Mal ausgelöst, wenn Sie ein Objekt beim Namen nennen.  Die Druckausgabe des von uns erstellten <em>emp-</em> Klassenobjekts sieht nun folgendermaßen aus: </p><br><pre> <code class="plaintext hljs">$name [1] "Oleg" $surname [1] "Petrov" $salary [1] 1750 $salary_datetime [1] "2019-05-29" $previous_sallary [1] 1500 $update [1] "2019-05-29 11:13:25 EEST"</code> </pre><br><p>  Schreiben wir unsere Methode für die Druckfunktion. </p><br><pre> <code class="plaintext hljs">print.emp &lt;- function(x) { cat("Name:", x$name, x$surname, "\n", "Current salary:", x$salary, "\n", "Days from last udpate:", Sys.Date() - x$salary_datetime, "\n", "Previous salary:", x$previous_sallary) }</code> </pre> <br><p>  Jetzt kann die Druckfunktion Objekte unserer <em>emp-</em> Klasse <em>drucken</em> .  Geben Sie einfach den Namen des Objekts in die Konsole ein und erhalten Sie die folgende Ausgabe. </p><br><pre> <code class="plaintext hljs">employee1</code> </pre> <br><pre> <code class="plaintext hljs">Name: Oleg Petrov Current salary: 1750 Days from last udpate: 0 Previous salary: 1500</code> </pre> <br><h2 id="sozdanie-obobschyonnoy-funkcii-i-metodov">  Generische Funktionen und Methoden erstellen </h2><br><p>  Die meisten der darin enthaltenen generischen Funktionen sehen gleich aus und verwenden nur die <code>UseMethod</code> Funktion. </p><br><pre> <code class="plaintext hljs">#   get_salary &lt;- function(x, ...) { UseMethod("get_salary") }</code> </pre> <br><p>  Jetzt werden wir zwei Methoden dafür schreiben, eine für die Arbeit mit Objekten der <em>emp-</em> Klasse, die zweite Methode wird standardmäßig für Objekte aller anderen Klassen gestartet, für die unsere verallgemeinerte Funktion keine separat geschriebene Methode hat. </p><br><pre> <code class="plaintext hljs">#      emp get_salary.emp &lt;- function(x) x$salary #      get_salary.default &lt;- function(x) cat("Work only with emp class objects")</code> </pre> <br><p>  Der Name der Methode besteht aus dem Namen der Funktion und der Objektklasse, die diese Methode verarbeitet.  Die <em>Standardmethode</em> wird jedes Mal ausgeführt, wenn Sie ein Klassenobjekt übergeben, in das die Methode nicht geschrieben wurde. </p><br><pre> <code class="plaintext hljs">get_salary(employee1)</code> </pre> <br><pre> <code class="plaintext hljs">[1] 1750</code> </pre> <br><pre> <code class="plaintext hljs">get_salary(iris)</code> </pre> <br><pre> <code class="plaintext hljs">Work only with emp class objects</code> </pre> <br><h2 id="nasledovanie">  Vererbung </h2><br><p>  Ein weiterer Begriff, auf den Sie beim Erlernen der objektorientierten Programmierung stoßen werden. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/816/718/892/8167188925cafe5b3224398c7d78b51d.png" alt="Bild"></p><br><p>  Alles, was auf dem Bild gezeigt wird, kann als <em>Transportklasse</em> klassifiziert werden.  In der Tat haben alle diese Objekte eine gemeinsame Methode - Bewegung und gemeinsame Eigenschaften, zum Beispiel Geschwindigkeit.  Trotzdem können alle 6 Objekte in drei Unterklassen unterteilt werden: Land, Wasser und Luft.  In diesem Fall erbt die Unterklasse die Eigenschaften der übergeordneten Klasse, verfügt jedoch auch über zusätzliche Eigenschaften und Methoden.  Eine ähnliche Eigenschaft im Rahmen der objektorientierten Programmierung heißt <strong>Vererbung</strong> . </p><br><p>  In unserem Beispiel können wir Remote-Mitarbeiter einer separaten Unterklasse von <em>remote_emp zuordnen</em> .  Diese Mitarbeiter haben ein zusätzliches Eigentum: Wohnort. </p><br><pre> <code class="plaintext hljs">#    employee2 &lt;- list(name = "Ivan", surname = "Ivanov", salary = 500, salary_datetime = Sys.Date(), previous_sallary = NULL, update = Sys.time(), city = "Moscow") #    remote_emp class(employee2) &lt;- c("remote_emp", "emp") #    class(employee2)</code> </pre> <br><pre> <code class="plaintext hljs">[1] "remote_emp" "emp"</code> </pre> <br><p>  Beim Zuweisen einer Klasse und Erstellen einer Unterklasse verwenden wir einen Vektor, in dem das erste Element der Name der Unterklasse ist, gefolgt vom Namen der übergeordneten Klasse. </p><br><p>  Im Falle der <strong>Vererbung</strong> funktionieren alle verallgemeinerten Funktionen und Methoden, die für die Arbeit mit der übergeordneten Klasse geschrieben wurden, ordnungsgemäß mit ihren Unterklassen. </p><br><pre> <code class="plaintext hljs">#    remote_emp   employee2</code> </pre> <br><pre> <code class="plaintext hljs">Name: Ivan Ivanov Current salary: 500 Days from last udpate: 0 Previous salary:</code> </pre> <br><pre> <code class="plaintext hljs">#   salary   remote_emp get_salary(employee2)</code> </pre> <br><pre> <code class="plaintext hljs">[1] 500</code> </pre> <br><p>  Sie können Methoden jedoch für jede Unterklasse separat entwickeln. </p><br><pre> <code class="plaintext hljs">#     salary   remote_emp get_salary.remote_emp &lt;- function(x) { cat(x$surname, "remote from", x$city, "\n") return(x$salary) }</code> </pre> <br><pre> <code class="plaintext hljs">#   salary   remote_emp get_salary(employee2)</code> </pre> <br><pre> <code class="plaintext hljs">Ivanov remote from Moscow [1] 500</code> </pre> <br><p>  Es funktioniert wie folgt.  Zunächst sucht die verallgemeinerte Funktion nach einer Methode, die für die Unterklasse <em>remote_emp geschrieben</em> wurde. Wenn sie diese nicht findet, geht sie weiter und sucht nach einer Methode, die für die übergeordnete Klasse <em>emp geschrieben wurde</em> . </p><br><h2 id="kogda-vam-mogut-prigoditsya-sobstvennye-klassy">  Wenn Sie Ihre eigenen Klassen verwenden können </h2><br><p>  Es ist unwahrscheinlich, dass die Funktionalität zum Erstellen eigener S3-Klassen für diejenigen nützlich ist, die gerade erst ihre Reise in die Beherrschung der R-Sprache beginnen. </p><br><p>  Persönlich haben sie sich bei der Entwicklung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">rfacebookstat-</a> Pakets als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nützlich erwiesen</a> .  Tatsache ist, dass in der Facebook-API der Parameter <em>action_breakdowns</em> vorhanden ist, um Ereignisse zu laden und auf Werbeveröffentlichungen in verschiedenen Gruppen zu reagieren. </p><br><p>  Wenn Sie solche Gruppierungen verwenden, erhalten Sie eine Antwort in Form einer JSON-Struktur im folgenden Format: </p><br><pre> <code class="plaintext hljs">{ "action_name": "like", "action_type": "post_reaction", "value": 6 } { "action_type": "comment", "value": 4 }</code> </pre> <br><p>  Die Anzahl und der Name der Elemente für verschiedene <em>action_breakdowns sind</em> unterschiedlich, daher müssen Sie für jedes <em>Element</em> einen eigenen Parser schreiben.  Um dieses Problem zu lösen, habe ich die Funktionalität zum Erstellen benutzerdefinierter S3-Klassen und einer verallgemeinerten Funktion mit einer Reihe von Methoden verwendet. </p><br><p>  Beim Anfordern von Statistiken zu Ereignissen mit Gruppierungen wurde abhängig von den Werten der Argumente eine Klasse definiert, die der von der API empfangenen Antwort zugewiesen wurde.  Die Antwort wurde an eine generische Funktion übergeben, und abhängig von der zuvor angegebenen Klasse wurde eine Methode ermittelt, die das Ergebnis analysierte.  Wer möchte sich mit den Implementierungsdetails befassen? <a href="">Hier</a> finden Sie den Code zum Erstellen einer verallgemeinerten Funktion und Methoden. <a href="">Hier finden Sie</a> deren Verwendung. </p><br><p>  In meinem Fall habe ich Klassen und Methoden verwendet, um sie ausschließlich innerhalb des Pakets zu verarbeiten.  Wenn Sie dem Benutzer des Pakets im Allgemeinen eine Schnittstelle für die Arbeit mit den von Ihnen erstellten Klassen zur Verfügung stellen müssen, müssen alle Methoden wie folgt als <code>S3method</code> Direktive in die <code>S3method</code> Datei aufgenommen werden. </p><br><pre> <code class="plaintext hljs">S3method(_,) S3method("[&lt;-",emp) S3method("[[&lt;-",emp) S3method("print",emp)</code> </pre> <br><h2 id="zaklyuchenie">  Fazit </h2><br><p>  Wie aus dem Titel des Artikels hervorgeht, ist dies nur der erste Teil, weil  In R gibt es neben den <em>S3-</em> Klassen noch andere: <em>S4</em> , <em>R5</em> ( <em>RC</em> ), <em>R6</em> .  In Zukunft werde ich versuchen, über jede dieser OOP-Implementierungen zu schreiben.  Trotzdem erlaubt jeder mit Englischkenntnissen, Bücher frei zu lesen, dann ist Headley Wickham ziemlich prägnant und mit Beispielen behandelte er dieses Thema in seinem Buch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Advanced R"</a> . </p><br><p>  Wenn ich in einem Artikel plötzlich einige wichtige Informationen zu S3-Klassen verpasst habe, wäre ich Ihnen dankbar, wenn Sie dies in den Kommentaren schreiben. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de453964/">https://habr.com/ru/post/de453964/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de453952/index.html">"Die Anfrage ist gereift": Alexei Fedorov über eine neue Konferenz über verteilte Systeme</a></li>
<li><a href="../de453956/index.html">Museum DataArt. Videoterminal ADM-3A. Das Auto ist schwer, zuverlässig, geschlachtet</a></li>
<li><a href="../de453958/index.html">Monorepositories: bitte</a></li>
<li><a href="../de453960/index.html">Globales DevOps Bootcamp 2019 in Moskau</a></li>
<li><a href="../de453962/index.html">RxSwift und Coroutines bei Kotlin - optionale mobile Entwicklung von AGIMA und GeekBrains</a></li>
<li><a href="../de453968/index.html">Verlernen Sie die Überprüfungspraktiken für toxischen Code</a></li>
<li><a href="../de453970/index.html">Wir schreiben Reverse socks5 Proxy auf Powershell. Teil 2</a></li>
<li><a href="../de453972/index.html">Archäologen erstellen mithilfe von 3D-Druck und -Scanning einen zweitausend Jahre alten Stift nach</a></li>
<li><a href="../de453974/index.html">Wettbewerb von ML-Systemen um Sprachmaterial. Wie haben wir gelernt, die Lücken zu füllen?</a></li>
<li><a href="../de453976/index.html">Wirtschaftliches Bildungsprogramm für IT-Spezialisten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>