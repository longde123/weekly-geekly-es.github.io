<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚙️ 👨🏼‍🔧 👨🏼‍✈️ Das Buch „Perfekter Algorithmus. Graph-Algorithmen und Datenstrukturen " 🚣 👧🏾 😍</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habrozhiteli! Algorithmen sind das Herz und die Seele der Informatik. Sie können nicht ohne sie auskommen, sie sind überall - von Netzwerkroutin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das Buch „Perfekter Algorithmus. Graph-Algorithmen und Datenstrukturen "</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/461039/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/e5/2z/76/e52z769bpr1nib4vz_bij_xvkgo.jpeg" align="left" alt="Bild"></a>  Hallo habrozhiteli!  Algorithmen sind das Herz und die Seele der Informatik.  Sie können nicht ohne sie auskommen, sie sind überall - von Netzwerkrouting und Genomikberechnungen bis hin zu Kryptographie und maschinellem Lernen.  Der „perfekte Algorithmus“ macht Sie zu einem echten Profi, der Aufgaben festlegt und diese sowohl im Leben als auch bei einem Vorstellungsgespräch meisterhaft löst, wenn Sie ein IT-Unternehmen einstellen. <br><br>  Im zweiten Buch spricht Tim Rafgarden, der Guru der Algorithmen, über die Graphensuche und ihre Anwendung, den Suchalgorithmus für kürzeste Wege sowie die Verwendung und Implementierung einiger Datenstrukturen: Heaps, Suchbäume, Hash-Tabellen und den Bloom-Filter. <br><br>  Dieser Beitrag enthält einen Auszug aus Bloom Filters: The Basics. <br><a name="habracut"></a><br><h3>  Worum geht es in diesem Buch? </h3><br>  Der zweite Teil des Buches „Perfekter Algorithmus“ ist ein Einführungskurs in die Grundlagen der Alphabetisierung zu den folgenden drei Themen. <br><br>  <b>Diagrammsuche und Anwendungen</b> .  Diagramme modellieren eine Reihe verschiedener Arten von Netzwerken, einschließlich Straße, Kommunikation, soziale Netzwerke und Netzwerke von Abhängigkeiten zwischen Aufgaben.  Diagramme können komplex sein, aber es gibt einige unglaublich schnelle Grundelemente, um über die Diagrammstruktur zu sprechen.  Wir werden mit linearen Zeitgraphen-Suchalgorithmen beginnen, von Anwendungen, die von der Netzwerkanalyse bis zum Erstellen einer Abfolge von Operationen reichen. <br><br>  <b>Die kürzesten Wege</b> .  Bei dem Problem mit dem kürzesten Pfad besteht das Ziel darin, die beste Route im Netzwerk von Punkt A nach Punkt B zu berechnen. Diese Aufgabe hat offensichtliche Anwendungen, wie beispielsweise die Berechnung von Verkehrsrouten, und tritt auch in getarnter Form bei vielen anderen universellen Aufgaben auf.  Wir werden einen unserer Graphensuchalgorithmen verallgemeinern und zum berühmten Dijkstra-Suchalgorithmus für kürzeste Wege kommen. <br><br>  <b>Datenstrukturen</b> .  Dieses Buch macht Sie zu einem hochqualifizierten Benutzer verschiedener Datenstrukturen, die eine sich entwickelnde Gruppe von Objekten mit den zugehörigen Schlüsseln unterstützen sollen.  Das Hauptziel ist es, eine Vorstellung davon zu entwickeln, welche Datenstruktur für Ihre Anwendung geeignet ist.  Zusätzliche Abschnitte enthalten Richtlinien für die Implementierung dieser Datenstrukturen von Grund auf neu. <br><br>  Zunächst diskutieren wir Heaps, die das gespeicherte Objekt mit dem kleinsten Schlüssel schnell identifizieren können und auch zum Sortieren, Implementieren einer Prioritätswarteschlange und Implementieren des nahezu linear-zeitlichen Algorithmus von Dijkstra nützlich sind.  Suchbäume behalten die vollständige Reihenfolge der Schlüssel für gespeicherte Objekte bei und unterstützen ein noch breiteres Spektrum von Vorgängen.  Hash-Tabellen sind für ultraschnelle Suchvorgänge optimiert und in modernen Programmen weit verbreitet.  Wir betrachten auch den Bloom-Filter, einen nahen Verwandten der Hash-Tabelle, der aufgrund zufälliger Fehler weniger Speicherplatz benötigt. <br><br>  Sie können sich in den Abschnitten „Schlussfolgerungen“, die jedes Kapitel vervollständigen und die wichtigsten Punkte identifizieren, ausführlicher mit dem Inhalt des Buches vertraut machen.  Die mit einem Sternchen gekennzeichneten Abschnitte des Buches sind in Bezug auf den Informationsstand am weitesten fortgeschritten.  Wenn das Buch für eine oberflächliche Einarbeitung in das Thema konzipiert ist, kann der Leser sie überspringen, ohne die Integrität des Geschriebenen zu verlieren. <br><br>  <b>Themen in drei weiteren Teilen behandelt</b> .  Der erste Teil des Buches „Perfekter Algorithmus.  Fundamentals “umfasst die asymptotische Notation (die O-Large-Notation und ihre nahen Verwandten), die Algorithmen zum Teilen und Erobern und den Hauptsatz der Wiederholungsrelation - die Hauptmethode, die randomisierte schnelle Sortierung und ihre Analyse sowie linear-zeitliche Auswahlalgorithmen.  Der dritte Teil befasst sich mit gierigen Algorithmen (Planung, minimale Spannbäume, Clustering, Huffman-Codes) und dynamischer Programmierung (Rucksackproblem, Sequenzausrichtung, kürzeste Wege, optimale Suchbäume).  Der vierte Teil befasst sich mit der NP-Vollständigkeit, was dies für einen Algorithmusdesigner bedeutet, und Strategien zur Lösung rechnerisch unlösbarer Probleme, einschließlich heuristischer Analyse und lokaler Suche. <br><br><h3>  12.5.  Bloom-Filter: Die Grundlagen </h3><br>  Bloom-Filter sind nahe Verwandte von Hash-Tabellen.  Sie sind sehr kompakt, machen aber regelmäßig Fehler.  In diesem Abschnitt wird beschrieben, wie gut Bloom-Filter sind und wie sie implementiert werden. In Abschnitt 12.6 wird eine Kompromisskurve zwischen dem vom Filter verwendeten Speicherplatz und seiner Fehlerrate dargestellt. <br><br><h3>  12.5.1.  Unterstützte Operationen </h3><br>  Der Grund für die Existenz von Bloom-Filtern ist im Wesentlichen der gleiche wie bei einer Hash-Tabelle: superschnelle Einfüge- und Ansichtsvorgänge, mit denen Sie sich schnell daran erinnern können, was Sie gesehen haben und was nicht.  Warum sollte uns eine andere Datenstruktur mit denselben Operationen stören?  Weil Bloom-Filter Hash-Tabellen in Anwendungen vorzuziehen sind, in denen Speicherplatz Gold wert ist und ein zufälliger Fehler kein Hindernis für die Transaktion darstellt. <br><br>  Wie Hash-Tabellen mit offener Adressierung sind Bloom-Filter viel einfacher zu implementieren und vorzustellen, wenn sie nur Einfüge- und Ansichtsvorgänge (und ohne den Löschvorgang) unterstützen.  Wir werden uns auf diesen Fall konzentrieren. <br><br><blockquote>  BLÜTENFILTER: UNTERSTÜTZTE FUNKTIONEN <br><br>  Ansicht: Geben Sie mit der Taste k "Ja" zurück, wenn k zuvor in den Bloom-Filter eingefügt wurde, andernfalls "Nein". <br>  Einfügen: Fügen Sie dem Bloom-Filter einen neuen Schlüssel k hinzu. </blockquote><br>  Bloom-Filter sind räumlich sehr effizient;  Typischerweise benötigen sie möglicherweise nur 8 Bits pro Einfügung.  Das ist unglaublich, da 8 Bit nicht ausreichen, um sich auch nur einen 32-Bit-Schlüssel oder Zeiger auf ein Objekt zu merken!  Aus diesem Grund gibt die Ansichtsoperation im Bloom-Filter nur die Antwort "Ja" / "Nein" zurück, während diese Operation in der Hash-Tabelle einen Zeiger auf das gewünschte Objekt zurückgibt (falls es gefunden wird).  Aus diesem Grund akzeptiert die Einfügeoperation jetzt nur den Schlüssel und nicht den (Zeiger auf) das Objekt. <br><br>  Im Gegensatz zu allen anderen von uns untersuchten Datenstrukturen können Bloom-Filter falsch sein.  Es gibt zwei Arten von Fehlern: falsch negative Ergebnisse, wenn die View-Operation "false" zurückgibt, auch wenn der angeforderte Schlüssel bereits früher eingefügt wurde, und falsche Anweisungen (oder positive), wenn die View-Operation "true" zurückgibt, obwohl der angeforderte Schlüssel in der Vergangenheit noch nicht eingefügt wurde .  In Abschnitt 12.5.3 werden wir sehen, dass die grundlegenden Bloom-Filter niemals unter falsch negativen Ergebnissen leiden, sondern „Phantomelemente“ in Form falscher Aussagen enthalten können.  Abschnitt 12.6 zeigt, dass die Häufigkeit falscher Behauptungen durch entsprechende Anpassung der Raumnutzung kontrolliert werden kann.  Eine typische Implementierung eines Bloom-Filters kann eine Fehlerrate von etwa 1% oder 0,1% aufweisen. <br><br>  Die Ausführungszeiten für die Einfüge- und Ansichtsvorgänge sind so schnell wie in der Hash-Tabelle.  Und noch besser ist, dass diese Vorgänge unabhängig von der Implementierung des Bloom-Filters und des Datensatzes1 garantiert in konstanter Zeit ausgeführt werden.  Die Implementierung und der Datensatz wirken sich jedoch auf die Filterfehlerrate aus. <br><br>  Um die Vor- und Nachteile von Bloom-Filtern gegenüber Hash-Tabellen zusammenzufassen: <br><br><blockquote>  BLÜTENFILTER GEGEN HASH TABLES <br><br>  1. Vorteile: räumlich effektiver. <br><br>  2. Vorteile: Garantierte Dauerbetriebe für jeden Datensatz. <br><br>  3. Nachteile: Zeiger auf Objekte können nicht gespeichert werden. <br><br>  4. Nachteile: komplexere Löschungen im Vergleich zu einer Hash-Tabelle mit Kupplung. <br><br>  5. Nachteile: Nicht-Null-Wahrscheinlichkeit einer falschen Aussage. </blockquote><br>  Die Liste der Indikatoren für die grundlegenden Bloom-Filter lautet wie folgt. <br><br>  Tabelle 12.4.  Grundlegende Bloom-Filter: Unterstützte Vorgänge und deren Ausführungszeit.  Das Dolchzeichen (†) zeigt an, dass die Ansichtsoperation eine steuerbare Wahrscheinlichkeit für falsche Behauptungen aufweist, die jedoch nicht Null ist <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/j2/s0/bc/j2s0bcwhevqsy2-scnfyznyywpi.png" alt="Bild"></div><br>  Bloom-Filter sollten anstelle von Hash-Tabellen in Anwendungen verwendet werden, in denen ihre Vor- und Nachteile keine Rolle für die Transaktion spielen. <br><br><blockquote>  WANN MAN DEN BLÜTENFILTER VERWENDET <br><br>  Wenn eine Anwendung eine schnelle Suche mit einem sich dynamisch entwickelnden Satz von Objekten erfordert, der Platz Gold wert ist und eine akzeptable geringe Anzahl falscher Behauptungen vorliegt, ist der Bloom-Filter normalerweise die bevorzugte Datenstruktur. </blockquote><br><h3>  12.5.2.  Anwendungen </h3><br>  Als nächstes gibt es drei Verwendungszwecke bei wiederholten Scans, bei denen Platzersparnis wichtig sein kann und falsche Aussagen kein Hindernis für die Transaktion darstellen. <br><br>  Rechtschreibprüfung.  In den 1970er Jahren wurden Bloom-Filter verwendet, um Rechtschreibprüfungen zu implementieren.  In der Vorverarbeitungsphase wird jedes Wort im Wörterbuch in den Bloom-Filter eingefügt.  Die Schreibweise eines Dokuments hängt von einer Operation ab. Sehen Sie sich ein Wort in einem Dokument an und markieren Sie alle Wörter, für die diese Operation "Nein" zurückgibt. <br><br>  In diesem Anhang entspricht eine falsche Aussage einem ungültigen Wort, das die Rechtschreibprüfung versehentlich akzeptiert.  Solche Fehler machten die Rechtschreibprüfung nicht ideal.  In den frühen 1970er Jahren war der Weltraum Gold wert, daher war die Verwendung von Bloom-Filtern zu dieser Zeit eine Win-Win-Strategie. <br><br>  <b>Verbotene Passwörter</b> .  Eine alte Anwendung, die bis heute gültig ist, verfolgt verbotene Passwörter - Passwörter, die zu häufig oder zu leicht zu erraten sind.  Zunächst werden alle verbotenen Passwörter in den Bloom-Filter eingefügt.  Zusätzliche verbotene Passwörter können später nach Bedarf eingefügt werden.  Wenn ein Benutzer versucht, sein Kennwort festzulegen oder zurückzusetzen, sucht das System im Bloom-Filter nach dem vorgeschlagenen Kennwort.  Wenn die Suche "Ja" zurückgibt, wird der Benutzer aufgefordert, es erneut mit einem anderen Kennwort zu versuchen.  Hier wird eine falsche Aussage in ein sicheres Passwort übersetzt, das das System ablehnt. <br><br>  Vorausgesetzt, die Fehlerrate ist nicht zu hoch, beispielsweise nicht mehr als 1% oder 0,1%, spielt dies keine große Rolle.  Von Zeit zu Zeit benötigen einige Benutzer einen zusätzlichen Versuch, ein für das System akzeptables Kennwort zu finden. <br><br>  <b>Internet-Router</b> .  Eine Reihe der heutigen atemberaubenden Anwendungen von Bloom-Filtern findet tief im Internet statt, wo Datenpakete Router mit Streaming-Geschwindigkeit passieren.  Es gibt viele Gründe, warum ein Router sich schnell daran erinnern möchte, was er in der Vergangenheit gesehen hat.  Beispielsweise möchte ein Router möglicherweise die Quell-IP-Adresse eines Pakets in der Liste der blockierten IP-Adressen finden, den Inhalt des Caches verfolgen, um falsche Cache-Ansichten zu vermeiden, oder Statistiken führen, mit denen ein Denial-of-Service-Netzwerkangriff identifiziert werden kann.  Die Paketankunftsrate erfordert superschnelle Ansichten, und der begrenzte Speicher des Routers macht Speicherplatz Gold wert.  Diese Anwendungen werden direkt vom Bloom-Filter verwaltet. <br><br><h3>  12.5.3.  Implementierung </h3><br>  Wenn Sie in den Bloom-Filter schauen, sehen Sie eine elegante Implementierung.  Die Datenstruktur unterstützt eine n-Bit-Zeichenfolge oder ebenfalls ein Array A der Länge n, in dem jedes Element 0 oder 1 ist. (Alle Elemente werden auf Null initialisiert.) Diese Struktur verwendet auch m Hash-Funktionen h1, h2, ..., hm , während jeder das Universum U aller möglichen Schlüssel auf die Menge {0, 1, 2, ..., n - 1} von Positionen im Array abbildet.  Der Parameter m ist proportional zur Anzahl der Bits, die vom Bloom-Filter zum Einfügen verwendet werden, und ist in der Regel eine kleine Konstante (z. B. 5). <br><br>  Immer wenn ein Schlüssel in einen Bloom-Filter eingefügt wird, setzt jede der m Hash-Funktionen ein Flag und setzt das entsprechende Bit von Array A auf 1. <br><br><blockquote>  BLÜTENFILTER: EINFÜGEN (AUF SCHLÜSSEL) <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span> to m <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> A[hi(k)] := <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </blockquote><br>  Wenn beispielsweise m = 3 und h1 (k) = 23, h2 (k) = 17 und h3 (k) = 5 sind, bewirkt das Einfügen von k, dass das 5., 17. und 23. Bit des Arrays gleich gesetzt werden 1 (Abb. 12.5). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ma/-d/zf/ma-dzftjbgtmytk1uoelbb0q17o.png" alt="Bild"></div><br>  In der Ansichtsoperation sucht der Bloom-Filter nach dem Fingerabdruck, der möglicherweise beim Einfügen k verblieben ist. <br><br><blockquote>  BLÜTENFILTER: ANSICHT (SCHLÜSSELSCHLÜSSEL) <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span> to m <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> A [hi (k)] = <span class="hljs-number"><span class="hljs-number">0</span></span> then <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> «» <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> «»</code> </pre> </blockquote><br>  Jetzt können wir sehen, warum Bloom-Filter nicht unter falsch negativen Ergebnissen leiden können.  Wenn der Schlüssel k eingefügt wird, werden die entsprechenden m Bits auf 1 gesetzt. Während der Lebensdauer des Bloom-Filters können die Bits ihren Wert von 0 auf 1 ändern, jedoch nicht umgekehrt.  Somit bleiben diese m Bits für immer 1.  Bei jeder nachfolgenden View k-Operation wird garantiert die richtige Ja-Antwort zurückgegeben. <br><br>  Wir können auch sehen, wie falsche Aussagen entstehen.  Angenommen, m = 3 und die vier Schlüssel k1, k2, k3, k4 haben die folgenden Hashwerte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m0/uo/7r/m0uo7rbq7ewvpqhhmpvdmx8pfs4.png" alt="Bild"></div><br>  Angenommen, wir fügen k1, k2, k3 und k4 in einen Bloom-Filter ein (Abbildung 12.6).  Diese drei Einfügungen führen dazu, dass insgesamt neun Bits gleich 1 gesetzt werden, einschließlich drei Bits im Fingerabdruck des Schlüssels k1 (5, 17 und 23).  Zu diesem Zeitpunkt kann der Bloom-Filter nicht mehr unterscheiden, ob der Schlüssel k1 eingefügt wurde oder nicht.  Selbst wenn k1 nicht in den Filter eingefügt wurde, gibt die Suche "Ja" zurück, was eine falsche Aussage ist. <br><br>  Intuitiv können wir davon ausgehen, dass mit zunehmender Größe n des Bloom-Filters die Anzahl der Überlagerungen zwischen den Fingerabdrücken verschiedener Tasten abnehmen sollte, was wiederum zu einer geringeren Anzahl falscher Aussagen führt.  Das Hauptziel des Bloom-Filters ist jedoch die Platzersparnis.  Gibt es einen Mittelweg, auf dem sowohl n als auch die Häufigkeit falscher Aussagen gleichzeitig gering sind?  Die Antwort ist nicht offensichtlich und erfordert eine mathematische Analyse im nächsten Abschnitt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gz/ib/_o/gzib_oomyz17bbrtney0kyxiru4.png" alt="Bild"></div><br><br>  »Weitere Informationen zum Buch finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Website des Herausgebers</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auszug</a> <br><br>  Für Khabrozhiteley 20% Rabatt auf den Gutschein - <b>Algorithmen</b> <br>  Nach Bezahlung der Papierversion des Buches wird ein elektronisches Buch per E-Mail verschickt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461039/">https://habr.com/ru/post/de461039/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461029/index.html">Ein See voller Marketingdaten - von monströsen Tabellen bis hin zu Berichten und Visualisierungen</a></li>
<li><a href="../de461031/index.html">Wir verbinden Online-Karten mit dem Navigator auf dem Smartphone. Teil 1 - Standard-Rasterkarten</a></li>
<li><a href="../de461033/index.html">Woher kommt diese Konfiguration? [Debian / Ubuntu]</a></li>
<li><a href="../de461035/index.html">Lehrreiche Episoden aus der Serie Silicon Valley (Staffel 1)</a></li>
<li><a href="../de461037/index.html">Und hier bin ich "echt"</a></li>
<li><a href="../de461041/index.html">Abgerundet oder spitzwinklig?</a></li>
<li><a href="../de461043/index.html">Konfliktmanagement im Team - Balanceakt oder lebenswichtige Notwendigkeit?</a></li>
<li><a href="../de461045/index.html">Holen Sie sich einen Auszug aus Rosreestr über FSIS USRN und Python. Teil 1</a></li>
<li><a href="../de461047/index.html">Schreiben oder nicht schreiben. Briefe an Behörden bei Veranstaltungen</a></li>
<li><a href="../de461049/index.html">ONYX BOOX Faust - Wer sucht, ist nicht gezwungen zu wandern</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>