<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚öôÔ∏è üë®üèº‚Äçüîß üë®üèº‚Äç‚úàÔ∏è Das Buch ‚ÄûPerfekter Algorithmus. Graph-Algorithmen und Datenstrukturen " üö£ üëßüèæ üòç</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habrozhiteli! Algorithmen sind das Herz und die Seele der Informatik. Sie k√∂nnen nicht ohne sie auskommen, sie sind √ºberall - von Netzwerkroutin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Das Buch ‚ÄûPerfekter Algorithmus. Graph-Algorithmen und Datenstrukturen "</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/461039/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/e5/2z/76/e52z769bpr1nib4vz_bij_xvkgo.jpeg" align="left" alt="Bild"></a>  Hallo habrozhiteli!  Algorithmen sind das Herz und die Seele der Informatik.  Sie k√∂nnen nicht ohne sie auskommen, sie sind √ºberall - von Netzwerkrouting und Genomikberechnungen bis hin zu Kryptographie und maschinellem Lernen.  Der ‚Äûperfekte Algorithmus‚Äú macht Sie zu einem echten Profi, der Aufgaben festlegt und diese sowohl im Leben als auch bei einem Vorstellungsgespr√§ch meisterhaft l√∂st, wenn Sie ein IT-Unternehmen einstellen. <br><br>  Im zweiten Buch spricht Tim Rafgarden, der Guru der Algorithmen, √ºber die Graphensuche und ihre Anwendung, den Suchalgorithmus f√ºr k√ºrzeste Wege sowie die Verwendung und Implementierung einiger Datenstrukturen: Heaps, Suchb√§ume, Hash-Tabellen und den Bloom-Filter. <br><br>  Dieser Beitrag enth√§lt einen Auszug aus Bloom Filters: The Basics. <br><a name="habracut"></a><br><h3>  Worum geht es in diesem Buch? </h3><br>  Der zweite Teil des Buches ‚ÄûPerfekter Algorithmus‚Äú ist ein Einf√ºhrungskurs in die Grundlagen der Alphabetisierung zu den folgenden drei Themen. <br><br>  <b>Diagrammsuche und Anwendungen</b> .  Diagramme modellieren eine Reihe verschiedener Arten von Netzwerken, einschlie√ülich Stra√üe, Kommunikation, soziale Netzwerke und Netzwerke von Abh√§ngigkeiten zwischen Aufgaben.  Diagramme k√∂nnen komplex sein, aber es gibt einige unglaublich schnelle Grundelemente, um √ºber die Diagrammstruktur zu sprechen.  Wir werden mit linearen Zeitgraphen-Suchalgorithmen beginnen, von Anwendungen, die von der Netzwerkanalyse bis zum Erstellen einer Abfolge von Operationen reichen. <br><br>  <b>Die k√ºrzesten Wege</b> .  Bei dem Problem mit dem k√ºrzesten Pfad besteht das Ziel darin, die beste Route im Netzwerk von Punkt A nach Punkt B zu berechnen. Diese Aufgabe hat offensichtliche Anwendungen, wie beispielsweise die Berechnung von Verkehrsrouten, und tritt auch in getarnter Form bei vielen anderen universellen Aufgaben auf.  Wir werden einen unserer Graphensuchalgorithmen verallgemeinern und zum ber√ºhmten Dijkstra-Suchalgorithmus f√ºr k√ºrzeste Wege kommen. <br><br>  <b>Datenstrukturen</b> .  Dieses Buch macht Sie zu einem hochqualifizierten Benutzer verschiedener Datenstrukturen, die eine sich entwickelnde Gruppe von Objekten mit den zugeh√∂rigen Schl√ºsseln unterst√ºtzen sollen.  Das Hauptziel ist es, eine Vorstellung davon zu entwickeln, welche Datenstruktur f√ºr Ihre Anwendung geeignet ist.  Zus√§tzliche Abschnitte enthalten Richtlinien f√ºr die Implementierung dieser Datenstrukturen von Grund auf neu. <br><br>  Zun√§chst diskutieren wir Heaps, die das gespeicherte Objekt mit dem kleinsten Schl√ºssel schnell identifizieren k√∂nnen und auch zum Sortieren, Implementieren einer Priorit√§tswarteschlange und Implementieren des nahezu linear-zeitlichen Algorithmus von Dijkstra n√ºtzlich sind.  Suchb√§ume behalten die vollst√§ndige Reihenfolge der Schl√ºssel f√ºr gespeicherte Objekte bei und unterst√ºtzen ein noch breiteres Spektrum von Vorg√§ngen.  Hash-Tabellen sind f√ºr ultraschnelle Suchvorg√§nge optimiert und in modernen Programmen weit verbreitet.  Wir betrachten auch den Bloom-Filter, einen nahen Verwandten der Hash-Tabelle, der aufgrund zuf√§lliger Fehler weniger Speicherplatz ben√∂tigt. <br><br>  Sie k√∂nnen sich in den Abschnitten ‚ÄûSchlussfolgerungen‚Äú, die jedes Kapitel vervollst√§ndigen und die wichtigsten Punkte identifizieren, ausf√ºhrlicher mit dem Inhalt des Buches vertraut machen.  Die mit einem Sternchen gekennzeichneten Abschnitte des Buches sind in Bezug auf den Informationsstand am weitesten fortgeschritten.  Wenn das Buch f√ºr eine oberfl√§chliche Einarbeitung in das Thema konzipiert ist, kann der Leser sie √ºberspringen, ohne die Integrit√§t des Geschriebenen zu verlieren. <br><br>  <b>Themen in drei weiteren Teilen behandelt</b> .  Der erste Teil des Buches ‚ÄûPerfekter Algorithmus.  Fundamentals ‚Äúumfasst die asymptotische Notation (die O-Large-Notation und ihre nahen Verwandten), die Algorithmen zum Teilen und Erobern und den Hauptsatz der Wiederholungsrelation - die Hauptmethode, die randomisierte schnelle Sortierung und ihre Analyse sowie linear-zeitliche Auswahlalgorithmen.  Der dritte Teil befasst sich mit gierigen Algorithmen (Planung, minimale Spannb√§ume, Clustering, Huffman-Codes) und dynamischer Programmierung (Rucksackproblem, Sequenzausrichtung, k√ºrzeste Wege, optimale Suchb√§ume).  Der vierte Teil befasst sich mit der NP-Vollst√§ndigkeit, was dies f√ºr einen Algorithmusdesigner bedeutet, und Strategien zur L√∂sung rechnerisch unl√∂sbarer Probleme, einschlie√ülich heuristischer Analyse und lokaler Suche. <br><br><h3>  12.5.  Bloom-Filter: Die Grundlagen </h3><br>  Bloom-Filter sind nahe Verwandte von Hash-Tabellen.  Sie sind sehr kompakt, machen aber regelm√§√üig Fehler.  In diesem Abschnitt wird beschrieben, wie gut Bloom-Filter sind und wie sie implementiert werden. In Abschnitt 12.6 wird eine Kompromisskurve zwischen dem vom Filter verwendeten Speicherplatz und seiner Fehlerrate dargestellt. <br><br><h3>  12.5.1.  Unterst√ºtzte Operationen </h3><br>  Der Grund f√ºr die Existenz von Bloom-Filtern ist im Wesentlichen der gleiche wie bei einer Hash-Tabelle: superschnelle Einf√ºge- und Ansichtsvorg√§nge, mit denen Sie sich schnell daran erinnern k√∂nnen, was Sie gesehen haben und was nicht.  Warum sollte uns eine andere Datenstruktur mit denselben Operationen st√∂ren?  Weil Bloom-Filter Hash-Tabellen in Anwendungen vorzuziehen sind, in denen Speicherplatz Gold wert ist und ein zuf√§lliger Fehler kein Hindernis f√ºr die Transaktion darstellt. <br><br>  Wie Hash-Tabellen mit offener Adressierung sind Bloom-Filter viel einfacher zu implementieren und vorzustellen, wenn sie nur Einf√ºge- und Ansichtsvorg√§nge (und ohne den L√∂schvorgang) unterst√ºtzen.  Wir werden uns auf diesen Fall konzentrieren. <br><br><blockquote>  BL√úTENFILTER: UNTERST√úTZTE FUNKTIONEN <br><br>  Ansicht: Geben Sie mit der Taste k "Ja" zur√ºck, wenn k zuvor in den Bloom-Filter eingef√ºgt wurde, andernfalls "Nein". <br>  Einf√ºgen: F√ºgen Sie dem Bloom-Filter einen neuen Schl√ºssel k hinzu. </blockquote><br>  Bloom-Filter sind r√§umlich sehr effizient;  Typischerweise ben√∂tigen sie m√∂glicherweise nur 8 Bits pro Einf√ºgung.  Das ist unglaublich, da 8 Bit nicht ausreichen, um sich auch nur einen 32-Bit-Schl√ºssel oder Zeiger auf ein Objekt zu merken!  Aus diesem Grund gibt die Ansichtsoperation im Bloom-Filter nur die Antwort "Ja" / "Nein" zur√ºck, w√§hrend diese Operation in der Hash-Tabelle einen Zeiger auf das gew√ºnschte Objekt zur√ºckgibt (falls es gefunden wird).  Aus diesem Grund akzeptiert die Einf√ºgeoperation jetzt nur den Schl√ºssel und nicht den (Zeiger auf) das Objekt. <br><br>  Im Gegensatz zu allen anderen von uns untersuchten Datenstrukturen k√∂nnen Bloom-Filter falsch sein.  Es gibt zwei Arten von Fehlern: falsch negative Ergebnisse, wenn die View-Operation "false" zur√ºckgibt, auch wenn der angeforderte Schl√ºssel bereits fr√ºher eingef√ºgt wurde, und falsche Anweisungen (oder positive), wenn die View-Operation "true" zur√ºckgibt, obwohl der angeforderte Schl√ºssel in der Vergangenheit noch nicht eingef√ºgt wurde .  In Abschnitt 12.5.3 werden wir sehen, dass die grundlegenden Bloom-Filter niemals unter falsch negativen Ergebnissen leiden, sondern ‚ÄûPhantomelemente‚Äú in Form falscher Aussagen enthalten k√∂nnen.  Abschnitt 12.6 zeigt, dass die H√§ufigkeit falscher Behauptungen durch entsprechende Anpassung der Raumnutzung kontrolliert werden kann.  Eine typische Implementierung eines Bloom-Filters kann eine Fehlerrate von etwa 1% oder 0,1% aufweisen. <br><br>  Die Ausf√ºhrungszeiten f√ºr die Einf√ºge- und Ansichtsvorg√§nge sind so schnell wie in der Hash-Tabelle.  Und noch besser ist, dass diese Vorg√§nge unabh√§ngig von der Implementierung des Bloom-Filters und des Datensatzes1 garantiert in konstanter Zeit ausgef√ºhrt werden.  Die Implementierung und der Datensatz wirken sich jedoch auf die Filterfehlerrate aus. <br><br>  Um die Vor- und Nachteile von Bloom-Filtern gegen√ºber Hash-Tabellen zusammenzufassen: <br><br><blockquote>  BL√úTENFILTER GEGEN HASH TABLES <br><br>  1. Vorteile: r√§umlich effektiver. <br><br>  2. Vorteile: Garantierte Dauerbetriebe f√ºr jeden Datensatz. <br><br>  3. Nachteile: Zeiger auf Objekte k√∂nnen nicht gespeichert werden. <br><br>  4. Nachteile: komplexere L√∂schungen im Vergleich zu einer Hash-Tabelle mit Kupplung. <br><br>  5. Nachteile: Nicht-Null-Wahrscheinlichkeit einer falschen Aussage. </blockquote><br>  Die Liste der Indikatoren f√ºr die grundlegenden Bloom-Filter lautet wie folgt. <br><br>  Tabelle 12.4.  Grundlegende Bloom-Filter: Unterst√ºtzte Vorg√§nge und deren Ausf√ºhrungszeit.  Das Dolchzeichen (‚Ä†) zeigt an, dass die Ansichtsoperation eine steuerbare Wahrscheinlichkeit f√ºr falsche Behauptungen aufweist, die jedoch nicht Null ist <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/j2/s0/bc/j2s0bcwhevqsy2-scnfyznyywpi.png" alt="Bild"></div><br>  Bloom-Filter sollten anstelle von Hash-Tabellen in Anwendungen verwendet werden, in denen ihre Vor- und Nachteile keine Rolle f√ºr die Transaktion spielen. <br><br><blockquote>  WANN MAN DEN BL√úTENFILTER VERWENDET <br><br>  Wenn eine Anwendung eine schnelle Suche mit einem sich dynamisch entwickelnden Satz von Objekten erfordert, der Platz Gold wert ist und eine akzeptable geringe Anzahl falscher Behauptungen vorliegt, ist der Bloom-Filter normalerweise die bevorzugte Datenstruktur. </blockquote><br><h3>  12.5.2.  Anwendungen </h3><br>  Als n√§chstes gibt es drei Verwendungszwecke bei wiederholten Scans, bei denen Platzersparnis wichtig sein kann und falsche Aussagen kein Hindernis f√ºr die Transaktion darstellen. <br><br>  Rechtschreibpr√ºfung.  In den 1970er Jahren wurden Bloom-Filter verwendet, um Rechtschreibpr√ºfungen zu implementieren.  In der Vorverarbeitungsphase wird jedes Wort im W√∂rterbuch in den Bloom-Filter eingef√ºgt.  Die Schreibweise eines Dokuments h√§ngt von einer Operation ab. Sehen Sie sich ein Wort in einem Dokument an und markieren Sie alle W√∂rter, f√ºr die diese Operation "Nein" zur√ºckgibt. <br><br>  In diesem Anhang entspricht eine falsche Aussage einem ung√ºltigen Wort, das die Rechtschreibpr√ºfung versehentlich akzeptiert.  Solche Fehler machten die Rechtschreibpr√ºfung nicht ideal.  In den fr√ºhen 1970er Jahren war der Weltraum Gold wert, daher war die Verwendung von Bloom-Filtern zu dieser Zeit eine Win-Win-Strategie. <br><br>  <b>Verbotene Passw√∂rter</b> .  Eine alte Anwendung, die bis heute g√ºltig ist, verfolgt verbotene Passw√∂rter - Passw√∂rter, die zu h√§ufig oder zu leicht zu erraten sind.  Zun√§chst werden alle verbotenen Passw√∂rter in den Bloom-Filter eingef√ºgt.  Zus√§tzliche verbotene Passw√∂rter k√∂nnen sp√§ter nach Bedarf eingef√ºgt werden.  Wenn ein Benutzer versucht, sein Kennwort festzulegen oder zur√ºckzusetzen, sucht das System im Bloom-Filter nach dem vorgeschlagenen Kennwort.  Wenn die Suche "Ja" zur√ºckgibt, wird der Benutzer aufgefordert, es erneut mit einem anderen Kennwort zu versuchen.  Hier wird eine falsche Aussage in ein sicheres Passwort √ºbersetzt, das das System ablehnt. <br><br>  Vorausgesetzt, die Fehlerrate ist nicht zu hoch, beispielsweise nicht mehr als 1% oder 0,1%, spielt dies keine gro√üe Rolle.  Von Zeit zu Zeit ben√∂tigen einige Benutzer einen zus√§tzlichen Versuch, ein f√ºr das System akzeptables Kennwort zu finden. <br><br>  <b>Internet-Router</b> .  Eine Reihe der heutigen atemberaubenden Anwendungen von Bloom-Filtern findet tief im Internet statt, wo Datenpakete Router mit Streaming-Geschwindigkeit passieren.  Es gibt viele Gr√ºnde, warum ein Router sich schnell daran erinnern m√∂chte, was er in der Vergangenheit gesehen hat.  Beispielsweise m√∂chte ein Router m√∂glicherweise die Quell-IP-Adresse eines Pakets in der Liste der blockierten IP-Adressen finden, den Inhalt des Caches verfolgen, um falsche Cache-Ansichten zu vermeiden, oder Statistiken f√ºhren, mit denen ein Denial-of-Service-Netzwerkangriff identifiziert werden kann.  Die Paketankunftsrate erfordert superschnelle Ansichten, und der begrenzte Speicher des Routers macht Speicherplatz Gold wert.  Diese Anwendungen werden direkt vom Bloom-Filter verwaltet. <br><br><h3>  12.5.3.  Implementierung </h3><br>  Wenn Sie in den Bloom-Filter schauen, sehen Sie eine elegante Implementierung.  Die Datenstruktur unterst√ºtzt eine n-Bit-Zeichenfolge oder ebenfalls ein Array A der L√§nge n, in dem jedes Element 0 oder 1 ist. (Alle Elemente werden auf Null initialisiert.) Diese Struktur verwendet auch m Hash-Funktionen h1, h2, ..., hm , w√§hrend jeder das Universum U aller m√∂glichen Schl√ºssel auf die Menge {0, 1, 2, ..., n - 1} von Positionen im Array abbildet.  Der Parameter m ist proportional zur Anzahl der Bits, die vom Bloom-Filter zum Einf√ºgen verwendet werden, und ist in der Regel eine kleine Konstante (z. B. 5). <br><br>  Immer wenn ein Schl√ºssel in einen Bloom-Filter eingef√ºgt wird, setzt jede der m Hash-Funktionen ein Flag und setzt das entsprechende Bit von Array A auf 1. <br><br><blockquote>  BL√úTENFILTER: EINF√úGEN (AUF SCHL√úSSEL) <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span> to m <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> A[hi(k)] := <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </blockquote><br>  Wenn beispielsweise m = 3 und h1 (k) = 23, h2 (k) = 17 und h3 (k) = 5 sind, bewirkt das Einf√ºgen von k, dass das 5., 17. und 23. Bit des Arrays gleich gesetzt werden 1 (Abb. 12.5). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ma/-d/zf/ma-dzftjbgtmytk1uoelbb0q17o.png" alt="Bild"></div><br>  In der Ansichtsoperation sucht der Bloom-Filter nach dem Fingerabdruck, der m√∂glicherweise beim Einf√ºgen k verblieben ist. <br><br><blockquote>  BL√úTENFILTER: ANSICHT (SCHL√úSSELSCHL√úSSEL) <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span> to m <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> A [hi (k)] = <span class="hljs-number"><span class="hljs-number">0</span></span> then <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ¬´¬ª <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ¬´¬ª</code> </pre> </blockquote><br>  Jetzt k√∂nnen wir sehen, warum Bloom-Filter nicht unter falsch negativen Ergebnissen leiden k√∂nnen.  Wenn der Schl√ºssel k eingef√ºgt wird, werden die entsprechenden m Bits auf 1 gesetzt. W√§hrend der Lebensdauer des Bloom-Filters k√∂nnen die Bits ihren Wert von 0 auf 1 √§ndern, jedoch nicht umgekehrt.  Somit bleiben diese m Bits f√ºr immer 1.  Bei jeder nachfolgenden View k-Operation wird garantiert die richtige Ja-Antwort zur√ºckgegeben. <br><br>  Wir k√∂nnen auch sehen, wie falsche Aussagen entstehen.  Angenommen, m = 3 und die vier Schl√ºssel k1, k2, k3, k4 haben die folgenden Hashwerte: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/m0/uo/7r/m0uo7rbq7ewvpqhhmpvdmx8pfs4.png" alt="Bild"></div><br>  Angenommen, wir f√ºgen k1, k2, k3 und k4 in einen Bloom-Filter ein (Abbildung 12.6).  Diese drei Einf√ºgungen f√ºhren dazu, dass insgesamt neun Bits gleich 1 gesetzt werden, einschlie√ülich drei Bits im Fingerabdruck des Schl√ºssels k1 (5, 17 und 23).  Zu diesem Zeitpunkt kann der Bloom-Filter nicht mehr unterscheiden, ob der Schl√ºssel k1 eingef√ºgt wurde oder nicht.  Selbst wenn k1 nicht in den Filter eingef√ºgt wurde, gibt die Suche "Ja" zur√ºck, was eine falsche Aussage ist. <br><br>  Intuitiv k√∂nnen wir davon ausgehen, dass mit zunehmender Gr√∂√üe n des Bloom-Filters die Anzahl der √úberlagerungen zwischen den Fingerabdr√ºcken verschiedener Tasten abnehmen sollte, was wiederum zu einer geringeren Anzahl falscher Aussagen f√ºhrt.  Das Hauptziel des Bloom-Filters ist jedoch die Platzersparnis.  Gibt es einen Mittelweg, auf dem sowohl n als auch die H√§ufigkeit falscher Aussagen gleichzeitig gering sind?  Die Antwort ist nicht offensichtlich und erfordert eine mathematische Analyse im n√§chsten Abschnitt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gz/ib/_o/gzib_oomyz17bbrtney0kyxiru4.png" alt="Bild"></div><br><br>  ¬ªWeitere Informationen zum Buch finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Website des Herausgebers</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Inhalt</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Auszug</a> <br><br>  F√ºr Khabrozhiteley 20% Rabatt auf den Gutschein - <b>Algorithmen</b> <br>  Nach Bezahlung der Papierversion des Buches wird ein elektronisches Buch per E-Mail verschickt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de461039/">https://habr.com/ru/post/de461039/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de461029/index.html">Ein See voller Marketingdaten - von monstr√∂sen Tabellen bis hin zu Berichten und Visualisierungen</a></li>
<li><a href="../de461031/index.html">Wir verbinden Online-Karten mit dem Navigator auf dem Smartphone. Teil 1 - Standard-Rasterkarten</a></li>
<li><a href="../de461033/index.html">Woher kommt diese Konfiguration? [Debian / Ubuntu]</a></li>
<li><a href="../de461035/index.html">Lehrreiche Episoden aus der Serie Silicon Valley (Staffel 1)</a></li>
<li><a href="../de461037/index.html">Und hier bin ich "echt"</a></li>
<li><a href="../de461041/index.html">Abgerundet oder spitzwinklig?</a></li>
<li><a href="../de461043/index.html">Konfliktmanagement im Team - Balanceakt oder lebenswichtige Notwendigkeit?</a></li>
<li><a href="../de461045/index.html">Holen Sie sich einen Auszug aus Rosreestr √ºber FSIS USRN und Python. Teil 1</a></li>
<li><a href="../de461047/index.html">Schreiben oder nicht schreiben. Briefe an Beh√∂rden bei Veranstaltungen</a></li>
<li><a href="../de461049/index.html">ONYX BOOX Faust - Wer sucht, ist nicht gezwungen zu wandern</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>