<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ–¥ï¸ ğŸ–¥ï¸ ğŸ‘©â€ğŸ« Pemulihan Foto Berbasis AI ğŸ¦ ğŸ•¶ï¸ ğŸ––ğŸ¼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hai semuanya! Saya seorang insinyur penelitian di tim visi komputer Grup Mail.ru. Dalam artikel ini, saya akan menceritakan tentang bagaimana kami tel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pemulihan Foto Berbasis AI</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/459696/"><img src="https://habrastorage.org/webt/ya/mt/mm/yamtmmcino7skf3gyqzpsrgqla4.jpeg"><br><br>  Hai semuanya!  Saya seorang insinyur penelitian di tim visi komputer Grup Mail.ru.  Dalam artikel ini, saya akan menceritakan tentang bagaimana kami telah menciptakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek pemulihan foto berbasis AI untuk foto-foto</a> militer lama.  Apa itu "restorasi foto"?  Ini terdiri dari tiga langkah: <br><br><ul><li>  kami menemukan semua cacat gambar: fraktur, pertengkaran, lubang; <br></li><li>  kami mengecat cacat yang ditemukan, berdasarkan nilai piksel di sekitarnya; <br></li><li>  kami mewarnai gambar. <br></li></ul><br>  Lebih lanjut, saya akan menjelaskan setiap langkah pemulihan foto dan memberi tahu Anda bagaimana kami mendapatkan data kami, jaring apa yang kami latih, apa yang kami capai, dan kesalahan apa yang kami buat. <br><a name="habracut"></a><br><h1>  Mencari cacat </h1><br>  Kami ingin menemukan semua piksel yang terkait dengan cacat pada foto yang diunggah.  Pertama, kita perlu mencari tahu gambar seperti apa yang akan diunggah orang.  Kami berbicara dengan para pendiri proyek "Immortal Regiment", sebuah organisasi non-komersial yang menyimpan foto-foto warisan WW2, yang membagikan data mereka kepada kami.  Setelah menganalisisnya, kami perhatikan bahwa orang-orang mengunggah sebagian besar potret individu atau kelompok dengan cacat tingkat sedang hingga besar. <br><br>  Kemudian kami harus mengumpulkan satu set pelatihan.  Set pelatihan untuk tugas segmentasi adalah gambar dan topeng tempat semua cacat ditandai.  Cara termudah untuk melakukannya adalah membiarkan penilai membuat topeng segmentasi.  Tentu saja, orang tahu betul cara menemukan cacat, tetapi itu akan memakan waktu terlalu lama. <br><br><img src="https://habrastorage.org/webt/yg/6y/iu/yg6yiue75v7msnxyffapttyugs8.jpeg"><br><br>  Butuh satu jam atau seluruh hari kerja untuk menandai piksel cacat dalam satu foto.  Karena itu, tidak mudah untuk mengumpulkan satu set pelatihan lebih dari 100 gambar dalam beberapa minggu.  Itu sebabnya kami mencoba menambah data kami dan membuat cacat kami sendiri: kami akan mengambil foto yang bagus, menambahkan cacat menggunakan jalan acak pada gambar, dan berakhir dengan topeng yang menunjukkan bagian gambar dengan cacat.  Tanpa augmentasi, kami memiliki 68 foto berlabel secara manual di set latihan dan 11 foto di set validasi. <br><br>  Pendekatan segmentasi yang paling populer: ambil Unet dengan encoder pra-terlatih dan minimalkan jumlah BCE ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">binary cross-entropy</a> ) dan DICE ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SÃ¸rensen - Dice koefisien</a> ). <br><br>  Masalah apa yang muncul ketika kita menggunakan pendekatan segmentasi ini untuk tugas kita? <br><br><ul><li>  Bahkan jika terlihat ada banyak cacat dalam foto, bahwa itu sangat tua dan lusuh, area dengan cacat masih jauh lebih kecil daripada yang tidak rusak.  Untuk mengatasi masalah ini, kita dapat meningkatkan bobot kelas positif dalam BCE;  bobot yang optimal adalah rasio piksel bersih dengan yang rusak. <br></li><li>  Masalah kedua adalah bahwa jika kita menggunakan Unet out-of-box dengan pra-terlatih encoder (Albunet-18, misalnya), kita kehilangan banyak data posisi.  Lapisan pertama Albunet-18 terdiri dari konvolusi dengan kernel 5 dan langkah yang sama dengan dua.  Ini memungkinkan internet bekerja cepat.  Kami menukar waktu operasi bersih untuk memiliki lokalisasi cacat yang lebih baik: kami menghapus kumpulan maksimum setelah lapisan pertama, mengurangi langkah ke 1 dan mengurangi konvolusi kernel menjadi 3. <br></li><li>  Jika kita bekerja dengan gambar kecil dengan mengompresnya, misalnya menjadi 256 x 256 atau 512 x 512 piksel, maka cacat kecil akan hilang karena interpolasi.  Karena itu, kita perlu bekerja dengan gambar yang lebih besar.  Kami saat ini mengelompokkan cacat dalam ukuran foto 1024 x 1024 dalam produksi.  Itu sebabnya kami harus melatih jaring pada tanaman gambar besar.  Namun, ini menyebabkan masalah dengan ukuran batch kecil pada satu GPU. <br></li><li>  Selama pelatihan, kami dapat memuat sekitar 20 gambar pada satu GPU.  Karena itu, kita berakhir dengan nilai mean dan standar deviasi yang tidak akurat di lapisan BatchNorm.  Kita dapat mengatasi masalah ini menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BatchNorm Di Tempat</a> , yang, di satu sisi, menghemat ruang memori, dan di sisi lain, memiliki versi BatchNorm yang Disinkronkan, yang menyinkronkan statistik di semua GPU.  Sekarang kita menghitung nilai rata-rata dan standar deviasi bukan untuk 20 gambar pada satu GPU, tetapi untuk 80 gambar dari 4 GPU.  Ini meningkatkan konvergensi bersih. <br></li></ul><br>  Akhirnya, setelah menambah bobot BCE, mengubah arsitektur, dan menggunakan BatchNorm di tempat, kami membuat segmentasi lebih baik.  Namun, tidak perlu terlalu banyak biaya untuk melakukan sesuatu yang lebih baik dengan menambahkan Augmentasi Waktu Tes.  Kita dapat menjalankan net sekali pada gambar input, lalu mirror itu dan jalankan kembali net untuk menemukan semua cacat kecil. <br><br><img src="https://habrastorage.org/webt/3c/vj/g0/3cvjg04qc_nqsl8lop44jvtjfym.jpeg"><br><br>  Jaring bertemu dalam 18 jam pada empat GeForce 1080Ti.  Inferensi membutuhkan waktu 290 ms.  Ini cukup panjang, tapi itulah harga kinerja kami yang lebih baik daripada standar.  Validasi DICE sama dengan 0,35, dan ROCAUC - 0,93. <br><br><h1>  Pengecatan gambar </h1><br>  Sama dengan tugas segmentasi kami menggunakan Unet.  Untuk melakukan pewarnaan, kami akan mengunggah gambar asli dan topeng di mana kami menandai semua area bersih dengan yang, dan dengan nol - semua piksel yang ingin kami cat.  Ini adalah cara kami mengumpulkan data: untuk foto apa pun dari dataset gambar sumber terbuka, misalnya, OpenImagesV4, kami menambahkan cacat yang mirip dengan yang kita lihat dalam kehidupan nyata.  Kemudian kami melatih jaring untuk mengembalikan bagian yang hilang. <br><br>  Bagaimana kita bisa memodifikasi Unet untuk tugas ini? <br><br>  Kita dapat menggunakan konvolusi parsial alih-alih yang asli.  Idenya adalah bahwa ketika kita menggabungkan area dengan beberapa kernel, kita tidak memperhitungkan nilai piksel cacat.  Ini membuat pewarnaan lebih tepat.  Kami menunjukkan kepada Anda sebuah contoh dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">makalah NVIDIA</a> terbaru.  Mereka menggunakan Unet dengan konvolusi 2 dimensi default di gambar tengah dan konvolusi parsial - dalam gambar di sebelah kanan. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec1/5ba/bdb/ec15babdbf1cd219be4a5e3ffa4ae50f.jpg"><br><br>  Kami melatih jaring selama lima hari.  Pada hari terakhir, kami membekukan BatchNorms untuk membuat batas bagian yang dicat tidak terlihat. <br><br>  Dibutuhkan net 50 ms untuk memproses satu gambar 512 x 512.  Validasi PSNR sama dengan 26,4.  Namun, Anda tidak dapat sepenuhnya mengandalkan metrik dalam tugas ini.  Untuk memilih model terbaik, kami menjalankan beberapa model bagus pada gambar penilaian, menganonimkan hasilnya, dan memilih yang paling kami sukai.  Itulah cara kami memilih model akhir kami. <br><br>  Saya telah menyebutkan sebelumnya bahwa kami secara artifisial menambahkan beberapa cacat pada gambar bersih.  Anda harus selalu melacak ukuran maksimum cacat tambahan selama pelatihan;  dalam kasus ketika Anda memberi makan gambar dengan cacat sangat besar ke jaring yang tidak pernah ditangani pada tahap pelatihan, jaring akan menjadi liar dan menghasilkan hasil yang tidak dapat diterapkan.  Karena itu, jika Anda perlu memperbaiki cacat yang besar, tambah set latihan Anda dengan mereka. <br><br>  Berikut adalah contoh cara kerja algoritma kami: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c48/2cd/253/c482cd253865ee12a834475a2e30d619.jpg"><br><br><h1>  Pewarnaan </h1><br>  Kami mengelompokkan cacat dan mencatnya;  langkah ketiga - rekonstruksi warna.  Seperti yang saya katakan sebelumnya, ada banyak potret individu dan kelompok di antara foto-foto Resimen Abadi.  Kami ingin jaring kami bekerja dengan baik bersama mereka.  Kami memutuskan untuk membuat pewarnaan sendiri karena tidak ada layanan yang ada yang dapat mewarnai potret dengan cepat dan efisien.  Kami ingin foto berwarna kami menjadi lebih dapat dipercaya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cec/b9a/b6c/cecb9ab6c8e1b76b567f49eac1261957.jpg"><br><br>  GitHub memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">repositori</a> populer untuk pewarnaan foto.  Itu pekerjaan yang baik tetapi masih memiliki beberapa masalah.  Misalnya, ia cenderung mengecat pakaian biru.  Itu sebabnya kami menolaknya juga. <br><br>  Jadi, kami memutuskan untuk membuat algoritma untuk pewarnaan gambar.  Ide paling jelas: ambil gambar hitam-putih dan prediksi tiga saluran: merah, hijau, dan biru.  Namun, kita dapat membuat pekerjaan kita lebih mudah: bekerja bukan dengan representasi warna RGB, tetapi dengan representasi warna YCbCr.  Komponen Y adalah kecerahan (luma).  Gambar hitam-putih yang diunggah adalah saluran Y, dan kami akan menggunakannya kembali.  Sekarang kita perlu memprediksi Cb dan Cr: Cb adalah perbedaan warna biru dan kecerahan dan Cr - perbedaan warna merah dan kecerahan. <br><br><img src="https://habrastorage.org/webt/yo/au/zi/yoauzi06k3bd0uyod2rjnpxgvms.jpeg"><br><br>  Mengapa kami memilih representasi YCbCr?  Mata manusia lebih sensitif terhadap perubahan kecerahan daripada perubahan warna.  Itu sebabnya kami menggunakan kembali komponen Y (kecerahan) yang mata manusia paling peka terhadap dan memprediksi Cb dan Cr yang mungkin kita buat salah karena kita tidak bisa melihat kepalsuan warna dengan sangat baik.  Karakteristik khusus ini banyak digunakan pada awal televisi berwarna ketika kapasitas saluran tidak cukup untuk mengirimkan semua warna.  Gambar ditransmisikan dalam YCbCr, tidak berubah ke komponen Y, dan Cb dan Cr berkurang setengahnya. <br><br><h1>  Cara membuat garis dasar </h1><br>  Kita dapat mengambil Unet dengan encoder pretrained dan meminimalkan Kehilangan L1 antara nilai CbCr yang ada dan yang diprediksi.  Kami ingin mewarnai potret dan, oleh karena itu, selain foto OpenImages, kami membutuhkan lebih banyak foto spesifik tugas. <br><br>  Di mana kita bisa mendapatkan foto berwarna orang yang mengenakan seragam militer?  Ada orang di internet yang mewarnai foto-foto lama sebagai hobi atau untuk harga.  Mereka melakukannya dengan sangat hati-hati, berusaha menjadi sangat tepat.  Ketika mereka mewarnai seragam, papan bahu, dan medali, mereka merujuk pada bahan arsip, sehingga hasil pekerjaan mereka dapat dipercaya.  Secara keseluruhan, kami menggunakan 200 gambar berwarna secara manual dengan orang-orang berseragam militer. <br><br>  Sumber data lain yang bermanfaat adalah situs web <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tentara Merah Pekerja dan Petani</a> .  Salah satu pendirinya berfoto di hampir setiap seragam Soviet Perang Dunia 2 yang tersedia. <br><br><img src="https://habrastorage.org/webt/yh/b7/u7/yhb7u74fa3feihqo0k-jpqcyxgk.jpeg"><br><br>  Dalam beberapa gambar, ia meniru pose orang-orang dari foto arsip terkenal.  Ini adalah hal yang baik bahwa gambar-gambarnya memiliki latar belakang putih: itu memungkinkan kami untuk menambah data dengan sangat baik dengan menambahkan berbagai objek alami di latar belakang.  Kami juga menggunakan beberapa potret reguler, melengkapi mereka dengan lencana dan atribut perang lainnya. <br><br>  Kami melatih AlbuNet-50 - ini adalah Unet yang menggunakan ResNet-50 yang dipra-pretr sebagai encoder.  Jaring mulai memberikan hasil yang memadai: kulit berwarna merah muda, mata - abu-abu-biru, papan bahu - kekuningan.  Namun, masalahnya adalah bahwa beberapa area pada foto tidak tersentuh.  Hal ini disebabkan oleh fakta bahwa menurut kesalahan L1 menemukan yang optimal di mana lebih baik untuk tidak melakukan apa-apa daripada mencoba memprediksi beberapa warna. <br><br><img src="https://habrastorage.org/webt/ov/zh/bn/ovzhbnv-6ch0nnoa4fdbh3nygym.jpeg"><br>  <i>Kami membandingkan hasil kami dengan foto Ground Truth - pewarnaan manual yang dilakukan oleh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Klimbim</a></i> <br><br>  Bagaimana kita bisa menyelesaikan masalah ini?  Kita membutuhkan pembeda: jaringan saraf yang akan menerima gambar dan memberi tahu kita apakah itu terlihat realistis atau tidak.  Salah satu gambar di bawah ini diwarnai secara manual dan yang lainnya - oleh generator kami, AlbuNet-50.  Bagaimana manusia membedakan foto yang diwarnai secara manual dan otomatis?  Dengan melihat detail.  Bisakah Anda tahu di mana foto yang diwarnai secara otomatis dengan solusi dasar kami? <br><br><img src="https://habrastorage.org/webt/fk/er/n_/fkern_az5kgkgr2kwamcoxr_gtg.jpeg"><br><br><div class="spoiler">  <b class="spoiler_title">Jawab</b> <div class="spoiler_text">  gambar di sebelah kiri diwarnai secara manual, di sebelah kanan - secara otomatis. </div></div><br>  Kami menggunakan diskriminator dari kertas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Self-Attention GAN</a> .  Ini adalah jaring konvolusi kecil dengan apa yang disebut Self-Attention yang dibangun di lapisan atas.  Ini memungkinkan kita untuk "lebih memperhatikan" detail gambar.  Kami juga menggunakan normalisasi spektral.  Anda dapat menemukan informasi lebih lanjut di makalah yang disebutkan di atas.  Kami telah melatih internet dengan kombinasi kehilangan L1 dan kehilangan dari diskriminator.  Sekarang jaring mewarnai detail gambar dengan lebih baik, dan latar belakang terlihat lebih konsisten.  Satu contoh lagi: di sebelah kiri adalah pekerjaan yang dilatih hanya dengan kehilangan L1;  di sebelah kanan - dengan kombinasi kerugian diskriminator L1. <br><br><img src="https://habrastorage.org/webt/nd/3p/91/nd3p91aw1mzzoidhra1egef3zki.jpeg"><br><br>  Proses pelatihan memakan waktu dua hari pada empat GeForce 1080Ti.  Dibutuhkan 30 ms bersih untuk memproses gambar 512 x 512.  Validasi MSE - 34,4.  Sama seperti dengan pewarnaan, metrik yang tidak ingin Anda andalkan pada metrik.  Itu sebabnya kami memilih enam model dengan metrik validasi terbaik dan memilih secara buta untuk model terbaik. <br><br>  Ketika kami telah membuat sistem produksi dan meluncurkan situs web, kami terus bereksperimen dan menyimpulkan bahwa lebih baik kami meminimalkan bukan kerugian L1 per-piksel, tetapi kerugian persepsi.  Untuk menghitungnya, kami mengumpankan prediksi netto dan foto ground-truthl ke jaring VGG-16, mengambil peta fitur di lapisan bawah dan membandingkannya dengan MSE.  Pendekatan ini melukis lebih banyak area dan memberikan hasil yang lebih berwarna. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/676/9c8/b64/6769c8b64fdf00cb66dcd73edcd39e81.jpg"><br><br><h1>  Rekap </h1><br>  Unet adalah model yang sangat keren.  Pada tugas segmentasi pertama, kami menghadapi masalah selama pelatihan, dan bekerja dengan gambar resolusi tinggi dan itulah sebabnya kami menggunakan BatchNorm In-Place.  Pada tugas kedua kami (Inpainting), kami menggunakan Konvolusi Parsial alih-alih yang default, dan memungkinkan kami untuk mendapatkan hasil yang lebih baik.  Saat mengerjakan pewarnaan, kami menambahkan jaring pembeda kecil yang menghukum generator untuk gambar yang tidak realistis.  Kami juga menggunakan kerugian persepsi. <br><br>  Kesimpulan kedua - penilai sangat penting.  Dan tidak hanya selama tahap pembuatan mask segmentasi tetapi juga untuk validasi hasil akhir.  Pada akhirnya, kami memberikan pengguna tiga foto: gambar asli dengan cacat inpainted, foto berwarna dengan cacat inpainted dan yang hanya berwarna jika algoritma untuk pencarian cacat dan inpainting salah. <br><br>  Kami mengambil beberapa gambar dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">proyek Album Perang</a> dan memprosesnya melalui neuronet ini.  Inilah hasil yang kami dapatkan: <br><br><img src="https://habrastorage.org/webt/rm/4z/sb/rm4zsbvc0j_h_r2nobp4xj2p4ei.jpeg"><br><br>  Selain itu, di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> Anda dapat melihat lebih dekat pada gambar asli dan semua tahapan pemrosesan. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id459696/">https://habr.com/ru/post/id459696/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id459682/index.html">Kualitas data dalam penyimpanan</a></li>
<li><a href="../id459684/index.html">Peta Moskow Metro dan seluruh dunia untuk Android</a></li>
<li><a href="../id459688/index.html">Urbanisme di Tiongkok: Kurang Hipsters, Lebih Banyak Sains dan IT</a></li>
<li><a href="../id459692/index.html">Bagaimana kami menemukan modifikasi material yang bertentangan dengan prinsip kimia yang berlaku</a></li>
<li><a href="../id459694/index.html">Museum DataArt. Buka paket dan luncurkan Radio 86RK</a></li>
<li><a href="../id459698/index.html">Bagaimana cara memaksa Oracle BI 12c untuk membuat variabel sesi sebanyak yang dibutuhkan programmer?</a></li>
<li><a href="../id459704/index.html">LLVM IR dan Go</a></li>
<li><a href="../id459706/index.html">5 alasan mengapa Anda harus melupakan Redux dalam Bereaksi aplikasi</a></li>
<li><a href="../id459708/index.html">Desain Antarmuka Game. Brent Fox Tentang apa buku itu?</a></li>
<li><a href="../id459710/index.html">Selamat dari tabrakan langsung dan mengapa amnesia bukan seperti yang Anda pikirkan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>