<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì¶ ü§£ üèáüèº Manejo de errores en Go 1.13 ü•Ç üë®üèø‚ÄçüöÄ ü§õüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Durante la √∫ltima d√©cada, hemos explotado con √©xito el hecho de que Go maneja los errores como valores . Aunque la biblioteca est√°ndar ten√≠a un soport...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Manejo de errores en Go 1.13</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/473658/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/9f/wo/zl/9fwozl-z2zhf7bg5l_i8lfvdxdw.jpeg"></div><br>  Durante la √∫ltima d√©cada, hemos explotado con √©xito el hecho de que Go maneja los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">errores como valores</a> .  Aunque la biblioteca est√°ndar ten√≠a un soporte m√≠nimo para los errores: solo los errores. <code>errors.New</code> y <code>fmt.Errorf</code> que generan un error que contiene solo un mensaje: la interfaz integrada permite a los programadores de Go agregar cualquier informaci√≥n.  Todo lo que necesitas es un tipo que implemente el m√©todo de <code>Error</code> : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> QueryError <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Err error } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *QueryError)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.Query + <span class="hljs-string"><span class="hljs-string">": "</span></span> + e.Err.Error() }</code> </pre> <a name="habracut"></a><br>  Estos tipos de errores se encuentran en todos los idiomas y almacenan una amplia variedad de informaci√≥n, desde marcas de tiempo hasta nombres de archivos y direcciones de servidores.  A menudo se mencionan errores de bajo nivel que proporcionan un contexto adicional. <br><br>  El patr√≥n, cuando un error contiene otro, se encuentra con tanta frecuencia en Go que despu√©s de una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">discusi√≥n acalorada</a> en Go 1.13 se agreg√≥ su apoyo expl√≠cito.  En este art√≠culo, veremos las adiciones a la biblioteca est√°ndar que proporcionan el soporte mencionado: tres nuevas funciones en el paquete de errores y un nuevo comando de formato para <code>fmt.Errorf</code> . <br><br>  Antes de discutir los cambios en detalle, hablemos sobre c√≥mo se investigaron y construyeron los errores en versiones anteriores del lenguaje. <br><br><h1>  Errores antes de ir 1.13 </h1><br><h4>  Investigaci√≥n de errores </h4><br>  Los errores en Go son significados.  Los programas toman decisiones basadas en estos valores de diferentes maneras.  Muy a menudo, el error se compara con cero para ver si la operaci√≥n fall√≥. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">// something went wrong }</span></span></code> </pre><br>  A veces comparamos el error para encontrar el valor de <i>control</i> y ver si ha ocurrido un error espec√≠fico. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ErrNotFound = errors.New(<span class="hljs-string"><span class="hljs-string">"not found"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == ErrNotFound { <span class="hljs-comment"><span class="hljs-comment">// something wasn't found }</span></span></code> </pre> <br>  El valor de error puede ser de cualquier tipo que satisfaga la interfaz de error definida en el idioma.  Un programa puede usar una declaraci√≥n de tipo o un interruptor de tipo para ver el valor de error de un tipo m√°s espec√≠fico. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> NotFoundError <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *NotFoundError)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.Name + <span class="hljs-string"><span class="hljs-string">": not found"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e, ok := err.(*NotFoundError); ok { <span class="hljs-comment"><span class="hljs-comment">// e.Name wasn't found }</span></span></code> </pre><br><h4>  Agregar informaci√≥n </h4><br>  A menudo, una funci√≥n pasa un error a la pila de llamadas, agregando informaci√≥n, por ejemplo, una breve descripci√≥n de lo que sucedi√≥ cuando ocurri√≥ el error.  Esto es f√°cil de hacer, solo construya un nuevo error que incluya el texto del error anterior: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"decompress %v: %v"</span></span>, name, err) }</code> </pre> <br>  Al crear un nuevo error usando <code>fmt.Errorf</code> descartamos todo excepto el texto del error original.  Como vimos en el ejemplo de <code>QueryError</code> , a veces es necesario definir un nuevo tipo de error que contenga el error original para guardarlo para el an√°lisis usando el c√≥digo: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> QueryError <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Err error }</code> </pre> <br>  Los programas pueden mirar dentro del <code>*QueryError</code> y tomar una decisi√≥n basada en el error original.  Esto a veces se llama desenvolver un error. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e, ok := err.(*QueryError); ok &amp;&amp; e.Err == ErrPermission { <span class="hljs-comment"><span class="hljs-comment">// query failed because of a permission problem }</span></span></code> </pre> <br>  El tipo <code>os.PathError</code> de la biblioteca est√°ndar es otro ejemplo de c√≥mo un error contiene otro. <br><br><h1>  Errores en Go 1.13 </h1><br><h4>  M√©todo de desenvoltura </h4><br>  En Go 1.13, los paquetes de biblioteca est√°ndar de <code>errors</code> y <code>fmt</code> simplificaron el <code>fmt</code> errores que contienen otros errores.  Lo m√°s importante es la convenci√≥n, no el cambio: un error que contiene otro error puede implementar el m√©todo <code>Unwrap</code> , que devuelve el error original.  Si <code>e1.Unwrap()</code> devuelve <code>e2</code> , entonces decimos que <code>e1</code> <i>empaqueta</i> <code>e2</code> y puede <i>desempaquetar</i> <code>e1</code> para obtener <code>e2</code> . <br><br>  De acuerdo con esta convenci√≥n, puede <code>QueryError</code> tipo <code>QueryError</code> descrito anteriormente al m√©todo <code>QueryError</code> , que devuelve el error que contiene: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *QueryError)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Unwrap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.Err }</code> </pre> <br>  El resultado de desempaquetar el error tambi√©n puede contener el m√©todo <code>Unwrap</code> .  La secuencia de errores obtenidos a trav√©s del desempaquetado repetido, la llamamos <i>cadena de errores</i> . <br><br><h4>  Investigaci√≥n de error con Is y As </h4><br>  En Go 1.13, el paquete de <code>errors</code> contiene dos nuevas funciones para investigar errores: <code>Is</code> y <code>As</code> . <br><br>  Los <code>errors.Is</code> . <code>errors.Is</code> funci√≥n compara un error con un valor. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Similar to: // if err == ErrNotFound { ‚Ä¶ } if errors.Is(err, ErrNotFound) { // something wasn't found }</span></span></code> </pre> <br>  La funci√≥n <code>As</code> comprueba si el error es de un tipo particular. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Similar to: // if e, ok := err.(*QueryError); ok { ‚Ä¶ } var e *QueryError if errors.As(err, &amp;e) { // err is a *QueryError, and e is set to the error's value }</span></span></code> </pre> <br>  En el caso m√°s simple, los <code>errors.Is</code> . <code>errors.Is</code> funci√≥n se comporta como una comparaci√≥n con un error de control, y los <code>errors.As</code> . <code>errors.As</code> funci√≥n se comporta como una declaraci√≥n de tipo.  Sin embargo, cuando se trabaja con errores empaquetados, estas funciones eval√∫an todos los errores en la cadena.  Veamos el ejemplo de <code>QueryError</code> anterior para examinar el error original: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e, ok := err.(*QueryError); ok &amp;&amp; e.Err == ErrPermission { <span class="hljs-comment"><span class="hljs-comment">// query failed because of a permission problem }</span></span></code> </pre> <br>  Usando los <code>errors.Is</code> funci√≥n, puede escribir esto: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.Is(err, ErrPermission) { <span class="hljs-comment"><span class="hljs-comment">// err, or some error that it wraps, is a permission problem }</span></span></code> </pre> <br>  El paquete de <code>errors</code> tambi√©n contiene una nueva funci√≥n <code>Unwrap</code> que devuelve el resultado de llamar al m√©todo <code>Unwrap</code> del error, o devuelve nil si el error no tiene el m√©todo <code>Unwrap</code> .  Por lo general, es mejor usar <code>errors.Is</code> , es <code>errors.As</code> , <code>errors.As</code> , ya que le permiten examinar toda la cadena con una sola llamada. <br><br><h4>  Error al empaquetar con% w </h4><br>  Como mencion√©, es una pr√°ctica normal usar la funci√≥n <code>fmt.Errorf</code> para agregar informaci√≥n adicional al error. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"decompress %v: %v"</span></span>, name, err) }</code> </pre> <br>  En Go 1.13, la funci√≥n <code>fmt.Errorf</code> admite el nuevo comando <code>%w</code> .  Si es as√≠, entonces el error devuelto por <code>fmt.Errorf</code> contendr√° el m√©todo <code>Unwrap</code> que devuelve el argumento <code>%w</code> , que deber√≠a ser un error.  En todos los dem√°s casos, <code>%w</code> id√©ntico a <code>%v</code> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Return an error which unwraps to err. return fmt.Errorf("decompress %v: %w", name, err) }</span></span></code> </pre> <br>  Empaquetar el error con <code>%w</code> hace disponible para <code>errors.Is</code> y <code>errors.As</code> . <code>errors.As</code> : <br><br><pre> <code class="go hljs">err := fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"access denied: %w"</span></span>, ErrPermission) ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.Is(err, ErrPermission) ...</code> </pre><br><h4>  ¬øCu√°ndo empacar? </h4><br>  Cuando agrega un contexto adicional al error utilizando <code>fmt.Errorf</code> o una implementaci√≥n de tipo personalizado, debe decidir si el nuevo error contendr√° el original.  No hay una respuesta √∫nica para esto, todo depende del contexto en el que se crea el nuevo error.  Empaca para mostrarle a la persona que llama.  No empaquete el error si esto lleva a la divulgaci√≥n de los detalles de implementaci√≥n. <br><br>  Por ejemplo, imagine una funci√≥n <code>Parse</code> que lee una estructura de datos compleja de <code>io.Reader</code> .  Si ocurre un error, querremos averiguar el n√∫mero de la fila y la columna donde ocurri√≥.  Si se produjo un error al leer <code>io.Reader</code> , tendremos que empacarlo para averiguar el motivo.  Dado que el llamante recibi√≥ la funci√≥n <code>io.Reader</code> , tiene sentido mostrar el error que gener√≥. <br><br>  Otro caso: una funci√≥n que realiza varias llamadas a la base de datos probablemente no deber√≠a devolver un error en el que se empaqueta el resultado de una de estas llamadas.  Si la base de datos utilizada por esta funci√≥n es parte de la implementaci√≥n, la divulgaci√≥n de estos errores violar√° la abstracci√≥n.  Por ejemplo, si la funci√≥n <code>LookupUser</code> del paquete <code>pkg</code> usa la <code>database/sql</code> Go <code>database/sql</code> paquete <code>database/sql</code> , entonces puede encontrar el error <code>sql.ErrNoRows</code> .  Si devuelve un error usando <code>fmt.Errorf("accessing DB: %v", err)</code> , la persona que llama no puede mirar adentro y encontrar <code>sql.ErrNoRows</code> .  Pero si la funci√≥n devuelve <code>fmt.Errorf("accessing DB: %w", err)</code> , la persona que llama podr√≠a escribir: <br><br><pre> <code class="go hljs">err := pkg.LookupUser(...) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.Is(err, sql.ErrNoRows) ‚Ä¶</code> </pre> <br>  En este caso, la funci√≥n siempre debe devolver <code>sql.ErrNoRows</code> si no desea dividir clientes, incluso al cambiar a un paquete con una base de datos diferente.  En otras palabras, el empaquetado hace que un error forme parte de su API.  Si no desea confirmar la compatibilidad con este error en el futuro como parte de la API, no lo empaque. <br><br>  Es importante recordar que independientemente de si lo empaca o no, el error permanecer√° sin cambios.  <i>Una persona</i> que lo entienda tendr√° la misma informaci√≥n.  Tomar decisiones sobre el empaque depende de si se necesita informaci√≥n adicional para los <i>programas</i> para que puedan tomar decisiones m√°s informadas;  o si desea ocultar esta informaci√≥n para mantener el nivel de abstracci√≥n. <br><br><h4>  Configuraci√≥n de pruebas de error utilizando m√©todos Is y As </h4><br>  La funci√≥n <code>errors.Is</code> verifica cada error en la cadena contra el valor objetivo.  Por defecto, un error coincide con este valor si son equivalentes.  Adem√°s, un error en la cadena puede declarar su conformidad con el valor objetivo utilizando la implementaci√≥n del <i>m√©todo</i> <code>Is</code> . <br><br>  Considere el error causado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">por el paquete Upspin</a> , que compara el error con la plantilla y eval√∫a solo los campos distintos de cero: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Error <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Path <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> User <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *Error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Is</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { t, ok := target.(*Error) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (e.Path == t.Path || t.Path == <span class="hljs-string"><span class="hljs-string">""</span></span>) &amp;&amp; (e.User == t.User || t.User == <span class="hljs-string"><span class="hljs-string">""</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.Is(err, &amp;Error{User: <span class="hljs-string"><span class="hljs-string">"someuser"</span></span>}) { <span class="hljs-comment"><span class="hljs-comment">// err's User field is "someuser". }</span></span></code> </pre> <br>  Los <code>errors.As</code> La funci√≥n <code>errors.As</code> tambi√©n aconseja el m√©todo <code>As</code> , si lo hay. <br><br><h4>  Errores y API de paquetes </h4><br>  Un paquete que devuelve errores (y la mayor√≠a de los paquetes hacen esto) debe describir las propiedades de estos errores en los que un programador puede confiar.  Un paquete bien dise√±ado tambi√©n evitar√° la devoluci√≥n de errores con propiedades en las que no se puede confiar. <br><br>  Lo m√°s simple es decir si la operaci√≥n fue exitosa, devolviendo, respectivamente, el valor nil o non-nil.  En muchos casos, no se requiere otra informaci√≥n. <br><br>  Si necesita que la funci√≥n devuelva un estado de error identificable, por ejemplo, "elemento no encontrado", puede devolver un error en el que se empaqueta el valor de la se√±al. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ErrNotFound = errors.New(<span class="hljs-string"><span class="hljs-string">"not found"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// FetchItem returns the named item. // // If no item with the name exists, FetchItem returns an error // wrapping ErrNotFound. func FetchItem(name string) (*Item, error) { if itemNotFound(name) { return nil, fmt.Errorf("%q: %w", name, ErrNotFound) } // ... }</span></span></code> </pre> <br>  Existen otros patrones para proporcionar errores que la persona que llama puede examinar sem√°nticamente.  Por ejemplo, devuelve directamente un valor de control, un tipo espec√≠fico o un valor que puede analizarse mediante una funci√≥n predicativa. <br><br>  En cualquier caso, no revele los detalles internos al usuario.  Como se mencion√≥ en el cap√≠tulo "¬øCu√°ndo vale la pena empaquetarlo?", Si devuelve un error de otro paquete, convi√©rtalo para no revelar el error original, a menos que tenga la intenci√≥n de comprometerse a devolver este error espec√≠fico en el futuro. <br><br><pre> <code class="go hljs">f, err := os.Open(filename) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">// The *os.PathError returned by os.Open is an internal detail. // To avoid exposing it to the caller, repackage it as a new // error with the same text. We use the %v formatting verb, since // %w would permit the caller to unwrap the original *os.PathError. return fmt.Errorf("%v", err) }</span></span></code> </pre> <br>  Si una funci√≥n devuelve un error con un valor o tipo de se√±al empaquetada, no devuelva directamente el error original. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ErrPermission = errors.New(<span class="hljs-string"><span class="hljs-string">"permission denied"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// DoSomething returns an error wrapping ErrPermission if the user // does not have permission to do something. func DoSomething() { if !userHasPermission() { // If we return ErrPermission directly, callers might come // to depend on the exact error value, writing code like this: // // if err := pkg.DoSomething(); err == pkg.ErrPermission { ‚Ä¶ } // // This will cause problems if we want to add additional // context to the error in the future. To avoid this, we // return an error wrapping the sentinel so that users must // always unwrap it: // // if err := pkg.DoSomething(); errors.Is(err, pkg.ErrPermission) { ... } return fmt.Errorf("%w", ErrPermission) } // ... }</span></span></code> </pre><br><h4>  Conclusi√≥n </h4><br>  Aunque discutimos solo tres funciones y un comando de formateo, esperamos que ayuden a mejorar en gran medida el manejo de errores en los programas Go.  Esperamos que el empaquetado en aras de proporcionar un contexto adicional se convierta en una pr√°ctica normal, ayudando a los programadores a tomar mejores decisiones y encontrar errores m√°s r√°pido. <br><br>  Como dijo Russ Cox en su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">discurso en la GopherCon 2019</a> , en el camino hacia Go 2 experimentamos, simplificamos y enviamos.  Y ahora, despu√©s de haber enviado estos cambios, iniciamos nuevos experimentos. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/473658/">https://habr.com/ru/post/473658/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../473646/index.html">Hackathon en una peque√±a empresa: c√≥mo organizar sin tirar un tren de recursos</a></li>
<li><a href="../473648/index.html">El caballo est√° muerto - llora: transici√≥n de tslint a eslint</a></li>
<li><a href="../473652/index.html">Crear una API REST con Node.js y una Base de datos Oracle. Parte 5</a></li>
<li><a href="../473654/index.html">PHP Composer: arregla las dependencias sin dolor</a></li>
<li><a href="../473656/index.html">Experiencia de generador de sitio est√°tico de Hugo</a></li>
<li><a href="../473660/index.html">Ingenier√≠a inversa de arcade: grabar Michael Jordan en NBA Jam</a></li>
<li><a href="../473664/index.html">Experiencia de aprendizaje de primera mano. Yandex.Practicum - Analista de datos</a></li>
<li><a href="../473666/index.html">Como escritor de ciencia ficci√≥n, Arthur Clark casi cierra la revista Tech - Youth</a></li>
<li><a href="../473668/index.html">Por qu√© Bitrix - Bitrix</a></li>
<li><a href="../473670/index.html">Stoloto: como presentar un m√≥vil a la loter√≠a</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>