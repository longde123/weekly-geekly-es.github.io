<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📦 🤣 🏇🏼 Manejo de errores en Go 1.13 🥂 👨🏿‍🚀 🤛🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Durante la última década, hemos explotado con éxito el hecho de que Go maneja los errores como valores . Aunque la biblioteca estándar tenía un soport...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Manejo de errores en Go 1.13</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/473658/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/9f/wo/zl/9fwozl-z2zhf7bg5l_i8lfvdxdw.jpeg"></div><br>  Durante la última década, hemos explotado con éxito el hecho de que Go maneja los <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">errores como valores</a> .  Aunque la biblioteca estándar tenía un soporte mínimo para los errores: solo los errores. <code>errors.New</code> y <code>fmt.Errorf</code> que generan un error que contiene solo un mensaje: la interfaz integrada permite a los programadores de Go agregar cualquier información.  Todo lo que necesitas es un tipo que implemente el método de <code>Error</code> : <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> QueryError <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Err error } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *QueryError)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.Query + <span class="hljs-string"><span class="hljs-string">": "</span></span> + e.Err.Error() }</code> </pre> <a name="habracut"></a><br>  Estos tipos de errores se encuentran en todos los idiomas y almacenan una amplia variedad de información, desde marcas de tiempo hasta nombres de archivos y direcciones de servidores.  A menudo se mencionan errores de bajo nivel que proporcionan un contexto adicional. <br><br>  El patrón, cuando un error contiene otro, se encuentra con tanta frecuencia en Go que después de una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">discusión acalorada</a> en Go 1.13 se agregó su apoyo explícito.  En este artículo, veremos las adiciones a la biblioteca estándar que proporcionan el soporte mencionado: tres nuevas funciones en el paquete de errores y un nuevo comando de formato para <code>fmt.Errorf</code> . <br><br>  Antes de discutir los cambios en detalle, hablemos sobre cómo se investigaron y construyeron los errores en versiones anteriores del lenguaje. <br><br><h1>  Errores antes de ir 1.13 </h1><br><h4>  Investigación de errores </h4><br>  Los errores en Go son significados.  Los programas toman decisiones basadas en estos valores de diferentes maneras.  Muy a menudo, el error se compara con cero para ver si la operación falló. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">// something went wrong }</span></span></code> </pre><br>  A veces comparamos el error para encontrar el valor de <i>control</i> y ver si ha ocurrido un error específico. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ErrNotFound = errors.New(<span class="hljs-string"><span class="hljs-string">"not found"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == ErrNotFound { <span class="hljs-comment"><span class="hljs-comment">// something wasn't found }</span></span></code> </pre> <br>  El valor de error puede ser de cualquier tipo que satisfaga la interfaz de error definida en el idioma.  Un programa puede usar una declaración de tipo o un interruptor de tipo para ver el valor de error de un tipo más específico. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> NotFoundError <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *NotFoundError)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.Name + <span class="hljs-string"><span class="hljs-string">": not found"</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e, ok := err.(*NotFoundError); ok { <span class="hljs-comment"><span class="hljs-comment">// e.Name wasn't found }</span></span></code> </pre><br><h4>  Agregar información </h4><br>  A menudo, una función pasa un error a la pila de llamadas, agregando información, por ejemplo, una breve descripción de lo que sucedió cuando ocurrió el error.  Esto es fácil de hacer, solo construya un nuevo error que incluya el texto del error anterior: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"decompress %v: %v"</span></span>, name, err) }</code> </pre> <br>  Al crear un nuevo error usando <code>fmt.Errorf</code> descartamos todo excepto el texto del error original.  Como vimos en el ejemplo de <code>QueryError</code> , a veces es necesario definir un nuevo tipo de error que contenga el error original para guardarlo para el análisis usando el código: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> QueryError <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Query <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Err error }</code> </pre> <br>  Los programas pueden mirar dentro del <code>*QueryError</code> y tomar una decisión basada en el error original.  Esto a veces se llama desenvolver un error. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e, ok := err.(*QueryError); ok &amp;&amp; e.Err == ErrPermission { <span class="hljs-comment"><span class="hljs-comment">// query failed because of a permission problem }</span></span></code> </pre> <br>  El tipo <code>os.PathError</code> de la biblioteca estándar es otro ejemplo de cómo un error contiene otro. <br><br><h1>  Errores en Go 1.13 </h1><br><h4>  Método de desenvoltura </h4><br>  En Go 1.13, los paquetes de biblioteca estándar de <code>errors</code> y <code>fmt</code> simplificaron el <code>fmt</code> errores que contienen otros errores.  Lo más importante es la convención, no el cambio: un error que contiene otro error puede implementar el método <code>Unwrap</code> , que devuelve el error original.  Si <code>e1.Unwrap()</code> devuelve <code>e2</code> , entonces decimos que <code>e1</code> <i>empaqueta</i> <code>e2</code> y puede <i>desempaquetar</i> <code>e1</code> para obtener <code>e2</code> . <br><br>  De acuerdo con esta convención, puede <code>QueryError</code> tipo <code>QueryError</code> descrito anteriormente al método <code>QueryError</code> , que devuelve el error que contiene: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *QueryError)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Unwrap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.Err }</code> </pre> <br>  El resultado de desempaquetar el error también puede contener el método <code>Unwrap</code> .  La secuencia de errores obtenidos a través del desempaquetado repetido, la llamamos <i>cadena de errores</i> . <br><br><h4>  Investigación de error con Is y As </h4><br>  En Go 1.13, el paquete de <code>errors</code> contiene dos nuevas funciones para investigar errores: <code>Is</code> y <code>As</code> . <br><br>  Los <code>errors.Is</code> . <code>errors.Is</code> función compara un error con un valor. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Similar to: // if err == ErrNotFound { … } if errors.Is(err, ErrNotFound) { // something wasn't found }</span></span></code> </pre> <br>  La función <code>As</code> comprueba si el error es de un tipo particular. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Similar to: // if e, ok := err.(*QueryError); ok { … } var e *QueryError if errors.As(err, &amp;e) { // err is a *QueryError, and e is set to the error's value }</span></span></code> </pre> <br>  En el caso más simple, los <code>errors.Is</code> . <code>errors.Is</code> función se comporta como una comparación con un error de control, y los <code>errors.As</code> . <code>errors.As</code> función se comporta como una declaración de tipo.  Sin embargo, cuando se trabaja con errores empaquetados, estas funciones evalúan todos los errores en la cadena.  Veamos el ejemplo de <code>QueryError</code> anterior para examinar el error original: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> e, ok := err.(*QueryError); ok &amp;&amp; e.Err == ErrPermission { <span class="hljs-comment"><span class="hljs-comment">// query failed because of a permission problem }</span></span></code> </pre> <br>  Usando los <code>errors.Is</code> función, puede escribir esto: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.Is(err, ErrPermission) { <span class="hljs-comment"><span class="hljs-comment">// err, or some error that it wraps, is a permission problem }</span></span></code> </pre> <br>  El paquete de <code>errors</code> también contiene una nueva función <code>Unwrap</code> que devuelve el resultado de llamar al método <code>Unwrap</code> del error, o devuelve nil si el error no tiene el método <code>Unwrap</code> .  Por lo general, es mejor usar <code>errors.Is</code> , es <code>errors.As</code> , <code>errors.As</code> , ya que le permiten examinar toda la cadena con una sola llamada. <br><br><h4>  Error al empaquetar con% w </h4><br>  Como mencioné, es una práctica normal usar la función <code>fmt.Errorf</code> para agregar información adicional al error. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"decompress %v: %v"</span></span>, name, err) }</code> </pre> <br>  En Go 1.13, la función <code>fmt.Errorf</code> admite el nuevo comando <code>%w</code> .  Si es así, entonces el error devuelto por <code>fmt.Errorf</code> contendrá el método <code>Unwrap</code> que devuelve el argumento <code>%w</code> , que debería ser un error.  En todos los demás casos, <code>%w</code> idéntico a <code>%v</code> . <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Return an error which unwraps to err. return fmt.Errorf("decompress %v: %w", name, err) }</span></span></code> </pre> <br>  Empaquetar el error con <code>%w</code> hace disponible para <code>errors.Is</code> y <code>errors.As</code> . <code>errors.As</code> : <br><br><pre> <code class="go hljs">err := fmt.Errorf(<span class="hljs-string"><span class="hljs-string">"access denied: %w"</span></span>, ErrPermission) ... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.Is(err, ErrPermission) ...</code> </pre><br><h4>  ¿Cuándo empacar? </h4><br>  Cuando agrega un contexto adicional al error utilizando <code>fmt.Errorf</code> o una implementación de tipo personalizado, debe decidir si el nuevo error contendrá el original.  No hay una respuesta única para esto, todo depende del contexto en el que se crea el nuevo error.  Empaca para mostrarle a la persona que llama.  No empaquete el error si esto lleva a la divulgación de los detalles de implementación. <br><br>  Por ejemplo, imagine una función <code>Parse</code> que lee una estructura de datos compleja de <code>io.Reader</code> .  Si ocurre un error, querremos averiguar el número de la fila y la columna donde ocurrió.  Si se produjo un error al leer <code>io.Reader</code> , tendremos que empacarlo para averiguar el motivo.  Dado que el llamante recibió la función <code>io.Reader</code> , tiene sentido mostrar el error que generó. <br><br>  Otro caso: una función que realiza varias llamadas a la base de datos probablemente no debería devolver un error en el que se empaqueta el resultado de una de estas llamadas.  Si la base de datos utilizada por esta función es parte de la implementación, la divulgación de estos errores violará la abstracción.  Por ejemplo, si la función <code>LookupUser</code> del paquete <code>pkg</code> usa la <code>database/sql</code> Go <code>database/sql</code> paquete <code>database/sql</code> , entonces puede encontrar el error <code>sql.ErrNoRows</code> .  Si devuelve un error usando <code>fmt.Errorf("accessing DB: %v", err)</code> , la persona que llama no puede mirar adentro y encontrar <code>sql.ErrNoRows</code> .  Pero si la función devuelve <code>fmt.Errorf("accessing DB: %w", err)</code> , la persona que llama podría escribir: <br><br><pre> <code class="go hljs">err := pkg.LookupUser(...) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.Is(err, sql.ErrNoRows) …</code> </pre> <br>  En este caso, la función siempre debe devolver <code>sql.ErrNoRows</code> si no desea dividir clientes, incluso al cambiar a un paquete con una base de datos diferente.  En otras palabras, el empaquetado hace que un error forme parte de su API.  Si no desea confirmar la compatibilidad con este error en el futuro como parte de la API, no lo empaque. <br><br>  Es importante recordar que independientemente de si lo empaca o no, el error permanecerá sin cambios.  <i>Una persona</i> que lo entienda tendrá la misma información.  Tomar decisiones sobre el empaque depende de si se necesita información adicional para los <i>programas</i> para que puedan tomar decisiones más informadas;  o si desea ocultar esta información para mantener el nivel de abstracción. <br><br><h4>  Configuración de pruebas de error utilizando métodos Is y As </h4><br>  La función <code>errors.Is</code> verifica cada error en la cadena contra el valor objetivo.  Por defecto, un error coincide con este valor si son equivalentes.  Además, un error en la cadena puede declarar su conformidad con el valor objetivo utilizando la implementación del <i>método</i> <code>Is</code> . <br><br>  Considere el error causado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">por el paquete Upspin</a> , que compara el error con la plantilla y evalúa solo los campos distintos de cero: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Error <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Path <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> User <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(e *Error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Is</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(target error)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { t, ok := target.(*Error) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (e.Path == t.Path || t.Path == <span class="hljs-string"><span class="hljs-string">""</span></span>) &amp;&amp; (e.User == t.User || t.User == <span class="hljs-string"><span class="hljs-string">""</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> errors.Is(err, &amp;Error{User: <span class="hljs-string"><span class="hljs-string">"someuser"</span></span>}) { <span class="hljs-comment"><span class="hljs-comment">// err's User field is "someuser". }</span></span></code> </pre> <br>  Los <code>errors.As</code> La función <code>errors.As</code> también aconseja el método <code>As</code> , si lo hay. <br><br><h4>  Errores y API de paquetes </h4><br>  Un paquete que devuelve errores (y la mayoría de los paquetes hacen esto) debe describir las propiedades de estos errores en los que un programador puede confiar.  Un paquete bien diseñado también evitará la devolución de errores con propiedades en las que no se puede confiar. <br><br>  Lo más simple es decir si la operación fue exitosa, devolviendo, respectivamente, el valor nil o non-nil.  En muchos casos, no se requiere otra información. <br><br>  Si necesita que la función devuelva un estado de error identificable, por ejemplo, "elemento no encontrado", puede devolver un error en el que se empaqueta el valor de la señal. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ErrNotFound = errors.New(<span class="hljs-string"><span class="hljs-string">"not found"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// FetchItem returns the named item. // // If no item with the name exists, FetchItem returns an error // wrapping ErrNotFound. func FetchItem(name string) (*Item, error) { if itemNotFound(name) { return nil, fmt.Errorf("%q: %w", name, ErrNotFound) } // ... }</span></span></code> </pre> <br>  Existen otros patrones para proporcionar errores que la persona que llama puede examinar semánticamente.  Por ejemplo, devuelve directamente un valor de control, un tipo específico o un valor que puede analizarse mediante una función predicativa. <br><br>  En cualquier caso, no revele los detalles internos al usuario.  Como se mencionó en el capítulo "¿Cuándo vale la pena empaquetarlo?", Si devuelve un error de otro paquete, conviértalo para no revelar el error original, a menos que tenga la intención de comprometerse a devolver este error específico en el futuro. <br><br><pre> <code class="go hljs">f, err := os.Open(filename) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-comment"><span class="hljs-comment">// The *os.PathError returned by os.Open is an internal detail. // To avoid exposing it to the caller, repackage it as a new // error with the same text. We use the %v formatting verb, since // %w would permit the caller to unwrap the original *os.PathError. return fmt.Errorf("%v", err) }</span></span></code> </pre> <br>  Si una función devuelve un error con un valor o tipo de señal empaquetada, no devuelva directamente el error original. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ErrPermission = errors.New(<span class="hljs-string"><span class="hljs-string">"permission denied"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// DoSomething returns an error wrapping ErrPermission if the user // does not have permission to do something. func DoSomething() { if !userHasPermission() { // If we return ErrPermission directly, callers might come // to depend on the exact error value, writing code like this: // // if err := pkg.DoSomething(); err == pkg.ErrPermission { … } // // This will cause problems if we want to add additional // context to the error in the future. To avoid this, we // return an error wrapping the sentinel so that users must // always unwrap it: // // if err := pkg.DoSomething(); errors.Is(err, pkg.ErrPermission) { ... } return fmt.Errorf("%w", ErrPermission) } // ... }</span></span></code> </pre><br><h4>  Conclusión </h4><br>  Aunque discutimos solo tres funciones y un comando de formateo, esperamos que ayuden a mejorar en gran medida el manejo de errores en los programas Go.  Esperamos que el empaquetado en aras de proporcionar un contexto adicional se convierta en una práctica normal, ayudando a los programadores a tomar mejores decisiones y encontrar errores más rápido. <br><br>  Como dijo Russ Cox en su <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">discurso en la GopherCon 2019</a> , en el camino hacia Go 2 experimentamos, simplificamos y enviamos.  Y ahora, después de haber enviado estos cambios, iniciamos nuevos experimentos. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/473658/">https://habr.com/ru/post/473658/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../473646/index.html">Hackathon en una pequeña empresa: cómo organizar sin tirar un tren de recursos</a></li>
<li><a href="../473648/index.html">El caballo está muerto - llora: transición de tslint a eslint</a></li>
<li><a href="../473652/index.html">Crear una API REST con Node.js y una Base de datos Oracle. Parte 5</a></li>
<li><a href="../473654/index.html">PHP Composer: arregla las dependencias sin dolor</a></li>
<li><a href="../473656/index.html">Experiencia de generador de sitio estático de Hugo</a></li>
<li><a href="../473660/index.html">Ingeniería inversa de arcade: grabar Michael Jordan en NBA Jam</a></li>
<li><a href="../473664/index.html">Experiencia de aprendizaje de primera mano. Yandex.Practicum - Analista de datos</a></li>
<li><a href="../473666/index.html">Como escritor de ciencia ficción, Arthur Clark casi cierra la revista Tech - Youth</a></li>
<li><a href="../473668/index.html">Por qué Bitrix - Bitrix</a></li>
<li><a href="../473670/index.html">Stoloto: como presentar un móvil a la lotería</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>