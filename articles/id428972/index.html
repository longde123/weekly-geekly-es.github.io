<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍👦 🍏 🏉 Integrasi berkelanjutan di Yandex 👨🏻‍✈️ 🚟 🔧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mempertahankan basis kode yang besar sambil memastikan produktivitas tinggi untuk sejumlah besar pengembang adalah tantangan serius. Selama 5 tahun te...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Integrasi berkelanjutan di Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/428972/"><p>  Mempertahankan basis kode yang besar sambil memastikan produktivitas tinggi untuk sejumlah besar pengembang adalah tantangan serius.  Selama 5 tahun terakhir, Yandex telah mengembangkan sistem khusus untuk integrasi berkelanjutan.  Pada artikel ini, kita akan berbicara tentang skala basis kode Yandex, tentang mentransfer pengembangan ke repositori tunggal dengan pendekatan berbasis trunk untuk pengembangan, tentang tugas-tugas apa yang harus dipecahkan oleh sistem integrasi berkelanjutan untuk bekerja secara efektif dalam kondisi seperti itu. </p><br><img src="https://habrastorage.org/webt/wb/mt/xc/wbmtxcvurtd6cdv1aomjrtcyfw8.png"><br><p>  Bertahun-tahun yang lalu, Yandex tidak memiliki aturan khusus dalam pengembangan layanan: setiap departemen dapat menggunakan bahasa apa pun, teknologi apa pun, sistem penyebaran apa pun.  Dan seperti yang telah ditunjukkan oleh praktik, kebebasan seperti itu tidak selalu membantu untuk bergerak maju lebih cepat.  Pada saat itu, untuk menyelesaikan masalah yang sama, sering kali ada beberapa pengembangan kepemilikan atau sumber terbuka.  Ketika perusahaan tumbuh, ekosistem seperti itu bekerja lebih buruk.  Pada saat yang sama, kami ingin tetap menjadi Yandex yang besar, dan tidak terpecah menjadi banyak perusahaan independen, karena memberikan banyak keuntungan: banyak orang melakukan tugas yang sama, hasil pekerjaan mereka dapat digunakan kembali.  Mulai dari berbagai struktur data, seperti tabel hash yang didistribusikan dan antrian bebas kunci, dan diakhiri dengan banyak kode khusus berbeda yang telah kami tulis selama 20 tahun. </p><a name="habracut"></a><br><p>  Banyak tugas yang kami selesaikan tidak selesaikan di dunia open-source.  Tidak ada MapReduce yang berfungsi dengan baik pada volume kami (5000+ server) dan tugas kami, tidak ada pelacak tugas yang dapat menangani semua puluhan juta tiket kami.  Ini menarik di Yandex - Anda dapat melakukan hal-hal hebat. </p><br><p>  Tetapi kami benar-benar kehilangan efisiensi ketika kami memecahkan masalah yang sama lagi, mengulang solusi yang sudah jadi, membuat integrasi antar komponen menjadi sulit.  Adalah baik dan nyaman untuk melakukan segalanya hanya untuk diri Anda sendiri di sudut Anda sendiri, Anda tidak dapat memikirkan orang lain untuk saat ini.  Tetapi begitu layanan menjadi cukup nyata, ia akan memiliki dependensi.  Tampaknya hanya berbagai layanan lemah saling bergantung satu sama lain, pada kenyataannya - ada banyak koneksi antara berbagai bagian perusahaan.  Banyak layanan yang tersedia melalui aplikasi Yandex / Browser / dll., Atau saling melekat satu sama lain.  Misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alice</a> muncul di Browser, menggunakan Alice Anda dapat memesan Taksi.  Kita semua menggunakan komponen umum: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">YT</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">YQL</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Nirvana</a> . </p><br><p>  Model pembangunan lama memiliki masalah yang signifikan.  Karena adanya banyak repositori, sulit bagi pengembang biasa, terutama pemula, untuk mencari tahu: </p><br><ul><li>  dimana komponennya? </li><li>  cara kerjanya: tidak ada cara untuk "mengambil dan membaca" </li><li>  Siapa yang mengembangkan dan mendukungnya sekarang? </li><li>  bagaimana cara menggunakannya? </li></ul><br><p> Akibatnya, masalah saling menggunakan komponen muncul.  Komponen hampir tidak dapat menggunakan komponen lain karena mereka mewakili "kotak hitam" satu sama lain.  Ini berdampak negatif bagi perusahaan, karena komponen tidak hanya tidak digunakan kembali, tetapi sering juga tidak membaik.  Banyak komponen digandakan, jumlah kode yang harus didukung tumbuh secara signifikan.  Kami umumnya bergerak lebih lambat dari yang kami bisa. </p><br><h3 id="edinyy-repozitoriy-i-infrastruktura">  Repositori dan infrastruktur tunggal </h3><br><p>  5 tahun yang lalu, kami memulai proyek untuk mentransfer pengembangan ke repositori tunggal, dengan sistem umum untuk perakitan, pengujian, penyebaran, dan pemantauan. </p><br><p>  Tujuan utama yang ingin kami capai adalah untuk menghilangkan hambatan yang mencegah integrasi kode orang lain.  Sistem harus menyediakan akses mudah ke kode kerja yang sudah jadi, skema yang jelas untuk koneksi dan penggunaannya, kolektibilitas: proyek selalu dikumpulkan (dan lulus tes). </p><br><p>  Sebagai hasil dari proyek, setumpuk teknologi infrastruktur untuk perusahaan muncul: penyimpanan kode sumber, sistem peninjauan kode, sistem pembangunan, sistem integrasi berkelanjutan, penyebaran, pemantauan. </p><br><p>  Sekarang sebagian besar kode sumber untuk proyek Yandex disimpan dalam repositori tunggal, atau sedang dalam proses pindah ke sana: </p><br><ul><li>  Lebih dari 2000 pengembang mengerjakan proyek. </li><li>  lebih dari 50.000 proyek dan perpustakaan. </li><li>  Ukuran repositori melebihi 25 GB. </li><li>  Lebih dari 3.000.000 komit telah dikomit ke repositori. </li></ul><br><p>  Plus untuk perusahaan: </p><br><ul><li>  proyek apa pun dari repositori menerima infrastruktur siap pakai: <br><ul><li>  sistem untuk melihat dan menavigasi kode sumber dan sistem tinjauan kode. </li><li>  sistem perakitan dan perakitan terdistribusi.  Ini adalah topik besar yang terpisah, dan kami pasti akan membahasnya dalam artikel berikut. </li><li>  sistem integrasi berkelanjutan. </li><li>  penyebaran, integrasi dengan sistem pemantauan. </li></ul></li><li>  berbagi kode, interaksi tim aktif. </li><li>  semua kode adalah umum, Anda dapat datang ke proyek lain dan membuat perubahan yang Anda butuhkan di sana.  Ini sangat penting dalam sebuah perusahaan besar, karena tim lain tempat Anda membutuhkan sesuatu mungkin tidak memiliki sumber daya.  Dengan kode umum, Anda memiliki kesempatan untuk melakukan bagian dari pekerjaan sendiri dan “membantu terjadi” perubahan yang Anda butuhkan. </li><li>  Ada peluang untuk melakukan refactoring global.  Anda tidak perlu mendukung versi lama API atau pustaka Anda, Anda dapat mengubahnya dan mengubah tempat di mana mereka digunakan dalam proyek lain. </li><li>  kode menjadi kurang "beragam."  Anda memiliki serangkaian cara untuk menyelesaikan masalah, dan tidak perlu menambahkan cara lain untuk melakukan hal yang sama, tetapi dengan sedikit perbedaan. </li><li>  dalam proyek di sebelah Anda, kemungkinan besar, tidak akan ada bahasa dan perpustakaan yang benar-benar eksotis. </li></ul><br><p>  Juga harus dipahami bahwa model pengembangan tersebut memiliki kelemahan yang perlu dipertimbangkan: </p><br><ul><li>  Repositori bersama membutuhkan infrastruktur terpisah dan spesifik. </li><li>  perpustakaan yang Anda butuhkan mungkin tidak ada di repositori, tetapi perpustakaan itu dalam open-source.  Ada biaya untuk menambah dan memperbaruinya.  Sangat tergantung pada bahasa dan perpustakaan, di suatu tempat yang hampir gratis, di suatu tempat yang sangat mahal. </li><li>  Anda harus terus bekerja pada "kesehatan" kode.  Ini termasuk setidaknya perang melawan dependensi yang tidak perlu dan kode mati. </li></ul><br><p>  Pendekatan kami terhadap repositori umum memberlakukan aturan umum yang harus diikuti semua orang.  Dalam hal menggunakan repositori tunggal, pembatasan ditempatkan pada bahasa yang digunakan, perpustakaan, dan metode penyebaran.  Tetapi dalam proyek tetangga semuanya akan sama atau sangat mirip dengan milik Anda, dan Anda bahkan dapat memperbaiki sesuatu di sana. </p><br><p>  Model repositori yang sama berlaku untuk semua perusahaan besar.  Repositori monolitik adalah topik yang besar dan telah dipelajari dan dibahas dengan baik, jadi sekarang kita tidak akan membahasnya terlalu banyak.  Jika Anda ingin tahu lebih banyak, maka di akhir artikel Anda akan menemukan beberapa tautan bermanfaat yang mengungkapkan topik ini secara lebih rinci. </p><br><h3 id="usloviya-v-kotoryh-rabotaet-sistema-nepreryvnoy-integracii">  Kondisi di mana sistem integrasi berkelanjutan beroperasi </h3><br><p>  Pengembangan dilakukan sesuai dengan model pengembangan berbasis batang.  Sebagian besar pengguna bekerja dengan HEAD, atau salinan repositori terbaru, yang diperoleh dari cabang utama yang disebut trunk, di mana pengembangan sedang berlangsung.  Melakukan perubahan pada repositori dilakukan secara berurutan.  Segera setelah komit, kode baru terlihat dan dapat digunakan oleh semua pengembang.  Pengembangan di cabang yang terpisah tidak dianjurkan, meskipun cabang dapat digunakan untuk rilis. </p><br><p>  Proyek tergantung pada kode sumber.  Proyek dan perpustakaan membentuk grafik ketergantungan yang kompleks.  Dan ini berarti bahwa perubahan yang dibuat dalam satu proyek berpotensi mempengaruhi sisa repositori. </p><br><p>  Aliran besar komit masuk ke repositori: </p><br><ul><li>  lebih dari 2000 komit per hari. </li><li>  hingga 10 perubahan per menit selama jam sibuk. </li></ul><br><p>  Basis kode berisi lebih dari 500.000 target dan pengujian build. </p><br><p>  Tanpa sistem khusus integrasi berkelanjutan dalam kondisi seperti itu, akan sangat sulit untuk bergerak maju dengan cepat. </p><br><h3 id="sistema-nepreryvnoy-integracii">  Sistem integrasi berkelanjutan </h3><br><p>  Sistem integrasi berkelanjutan meluncurkan rakitan dan pengujian untuk setiap perubahan: </p><br><ul><li>  Pemeriksaan pendahuluan.  Mereka mengizinkan memeriksa kode sebelum melakukan dan menghindari tes yang melanggar di bagasi.  Sidang dan tes kemudian dijalankan di atas KEPALA.  Saat ini, pemeriksaan pra-audit dimulai secara sukarela.  Untuk proyek-proyek kritis, diperlukan pemeriksaan sebelum audit. </li><li>  Pemeriksaan pasca-komitmen setelah melakukan ke repositori. </li></ul><br><p>  Pembuatan dan pengujian berjalan secara paralel pada kelompok besar ratusan server.  Pembuatan dan pengujian berjalan pada platform yang berbeda.  Di bawah platform utama (linux), semua proyek dirakit dan semua tes dijalankan, di bawah platform lain - sebagian dari yang dapat dikonfigurasi pengguna. </p><br><p>  Setelah menerima dan menganalisis hasil rakitan dan menjalankan tes, pengguna menerima umpan balik, misalnya, jika perubahan melanggar tes apa pun. </p><br><img src="https://habrastorage.org/webt/kr/7s/re/kr7srek9pwwq-88vz8b3orjmtqc.png"><br><br><p>  Jika terjadi kegagalan atau pengujian rakitan baru, kami mengirim pemberitahuan kepada pemilik tes dan pembuat perubahan.  Sistem juga menyimpan dan menampilkan hasil pemeriksaan dalam antarmuka khusus.  Antarmuka web sistem integrasi menampilkan progres dan hasil pengujian, dikelompokkan berdasarkan jenis pengujian.  Layar dengan hasil pemindaian sekarang dapat terlihat seperti ini: </p><br><img src="https://habrastorage.org/webt/c_/p-/p3/c_p-p3pb17bzgmefh0-su2gmrnc.png"><br><br><h3 id="osobennosti-i-vozmozhnosti-sistemy-nepreryvnoy-integracii">  Fitur dan kemampuan sistem integrasi berkelanjutan </h3><br><p>  Memecahkan berbagai masalah yang dihadapi pengembang dan penguji, kami mengembangkan sistem integrasi berkelanjutan kami.  Sistem sudah menyelesaikan banyak masalah, tetapi masih banyak yang harus diperbaiki. </p><br><h4 id="tipy-i-razmery-testov">  Jenis dan ukuran tes </h4><br><p>  Ada beberapa jenis tujuan yang dapat dipicu oleh sistem integrasi berkelanjutan: </p><br><ul><li>  konfigurasikan.  Fase konfigurasi dilakukan oleh sistem build.  Konfigurasi mencakup analisis file konfigurasi sistem perakitan, menentukan dependensi antara proyek dan parameter perakitan dan menjalankan tes. </li><li>  membangun.  Majelis perpustakaan dan proyek. </li><li>  gaya.  Pada tahap ini, gaya kode cocok dengan persyaratan yang ditentukan. </li><li>  tes.  Tes dibagi menjadi beberapa tahap sesuai dengan batas waktu mereka untuk waktu kerja dan persyaratan untuk sumber daya komputasi. <br><ul><li>  kecil.  &lt;1 mnt </li><li>  sedang.  &lt;10 mnt </li><li>  besar  &gt; 10 mnt  Selain itu, mungkin ada persyaratan khusus untuk sumber daya komputasi. </li><li>  ekstra besar.  Ini adalah jenis tes khusus.  Pengujian tersebut dikarakteristikkan dengan serangkaian karakteristik berikut: waktu operasi yang lama, konsumsi sumber daya yang besar, sejumlah besar data input, mereka mungkin memerlukan akses khusus, dan yang paling penting, dukungan untuk skenario uji kompleks yang dijelaskan di bawah ini.  Ada lebih sedikit tes semacam itu daripada jenis tes lainnya, tetapi mereka sangat penting. </li></ul></li></ul><br><h4 id="chastota-zapuska-testov-i-binarnyy-poisk-polomok">  Uji frekuensi peluncuran dan deteksi kesalahan biner </h4><br><p>  Sumber daya besar dialokasikan untuk pengujian di Yandex - ratusan server yang kuat.  Tetapi bahkan dengan sejumlah besar sumber daya, kami tidak dapat menjalankan semua tes untuk setiap perubahan yang memengaruhi mereka.  Tetapi pada saat yang sama, sangat penting bagi kami untuk selalu membantu pengembang untuk melokalkan tempat di mana tes rusak, terutama di repositori besar. </p><br><p>  Apa yang kita lakukan  Untuk setiap perubahan untuk semua proyek yang terkena dampak, rakitan, pemeriksaan gaya, dan pengujian dengan ukuran kecil dan menengah dijalankan.  Sisa tes dijalankan tidak untuk setiap komit yang mempengaruhi, tetapi dengan periodisitas tertentu, jika ada komitmen yang mempengaruhi tes.  Dalam beberapa kasus, pengguna dapat mengontrol frekuensi startup, dalam kasus lain, frekuensi startup diatur oleh sistem.  Ketika kegagalan tes terdeteksi, proses mencari komit pemecahan dimulai.  Semakin jarang tes berjalan, semakin lama kita akan mencari komit melanggar setelah kegagalan terdeteksi. </p><br><img width="700" src="https://habrastorage.org/webt/1b/7r/hg/1b7rhgcpvzuuqnkue2cmn8yytam.png"><br><br><p>  Saat memulai pemeriksaan pra-audit, kami juga menjalankan hanya rakitan dan uji ringan.  Kemudian pengguna dapat secara manual memulai peluncuran tes berat dengan memilih dari daftar tes yang dipengaruhi oleh perubahan yang disediakan oleh sistem. </p><br><h4 id="obnaruzhenie-migayuschih-testov">  Deteksi Tes Berkedip </h4><br><p>  Tes Flash adalah tes yang menjalankan (Lulus / Gagal) hasil pada kode yang sama mungkin tergantung pada berbagai faktor.  Penyebab tes berkedip dapat berbeda: tidur dalam kode uji, kesalahan saat bekerja dengan multithreading, masalah infrastruktur (tidak tersedianya sistem apa pun), dll.  Tes berkedip menghadirkan masalah serius: </p><br><ul><li>  Mereka mengarah pada kenyataan bahwa sistem integrasi terus menerus dari peringatan palsu tentang kegagalan pengujian. </li><li>  Kontaminasi hasil tes.  Semakin sulit untuk memutuskan keberhasilan hasil verifikasi. </li><li>  Tunda rilis produk. </li><li>  Sulit dideteksi.  Tes mungkin berkedip sangat jarang. <br>  Pengembang dapat mengabaikan tes yang berkedip saat menganalisis hasil tes.  Terkadang salah. <br>  Tidak mungkin untuk sepenuhnya menghilangkan tes yang berkedip, ini harus diperhitungkan dalam sistem integrasi berkelanjutan. </li></ul><br><p>  Saat ini, untuk setiap tes, kami menjalankan semua tes dua kali untuk mendeteksi tes flashing.  Kami juga memperhitungkan keluhan akun dari pengguna (penerima notifikasi).  Jika kami mendeteksi kedipan, kami menandai tes dengan bendera khusus (dibisukan) dan memberi tahu pemilik tes.  Setelah ini, hanya pemilik tes yang akan menerima pemberitahuan tentang kegagalan pengujian.  Selanjutnya, kami terus menjalankan tes dalam mode normal, sambil menganalisis riwayat peluncurannya.  Jika tes tidak berkedip di jendela waktu tertentu, otomasi dapat memutuskan bahwa tes telah berhenti berkedip dan Anda dapat menghapus benderanya. </p><br><p>  Algoritma kami saat ini cukup sederhana dan banyak perbaikan yang direncanakan di tempat ini.  Pertama-tama, kami ingin menggunakan sinyal yang jauh lebih bermanfaat. </p><br><h4 id="avtomaticheskoe-obnovlenie-vhodnyh-dannyh-testov">  Pembaruan otomatis input uji </h4><br><p>  Saat menguji sistem Yandex yang paling kompleks, di samping metode pengujian lainnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengujian strategi kotak hitam</a> + <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengujian berbasis data</a> sering digunakan.  Untuk memastikan cakupan yang baik, pengujian semacam itu membutuhkan sejumlah besar data input.  Data dapat dipilih dari kelompok produksi.  Tetapi ada masalah dengan fakta bahwa data dengan cepat menjadi usang.  Dunia tidak tinggal diam, sistem kami terus berkembang.  Data uji yang ketinggalan zaman dari waktu ke waktu tidak akan memberikan cakupan tes yang baik, dan kemudian benar-benar mengarah pada gangguan tes karena fakta bahwa program mulai menggunakan data baru yang tidak tersedia dalam data uji yang ketinggalan zaman. </p><br><p>  Agar data tidak menjadi usang, sistem integrasi berkelanjutan dapat memperbaruinya secara otomatis.  Bagaimana cara kerjanya? </p><br><ol><li>  Data uji disimpan dalam penyimpanan sumber daya khusus. </li><li>  Tes berisi metadata yang menjelaskan input yang diperlukan. </li><li>  Korespondensi antara input tes yang diperlukan dan sumber daya disimpan dalam sistem integrasi berkelanjutan. </li><li>  Pengembang menyediakan pengiriman data segar secara rutin ke toko sumber daya. </li><li>  Sistem integrasi berkelanjutan mencari versi baru data uji dalam repositori sumber daya dan mengalihkan data input. </li></ol><br><p>  Penting untuk memperbarui data sehingga tes palsu tidak terjadi.  Anda tidak bisa hanya mengambil dan, mulai dari komit tertentu, mulai menggunakan data baru, karena  dalam hal terjadi gangguan pengujian, tidak akan jelas siapa yang harus disalahkan - melakukan atau data baru.  Ini juga akan membuat tes diff (dijelaskan di bawah) tidak beroperasi. </p><br><img width="600" src="https://habrastorage.org/webt/yz/xq/ew/yzxqew6kgfu-irgksx-mbgejtz8.png"><br><p>  Oleh karena itu, kami membuatnya sehingga ada beberapa interval kecil komit, di mana tes diluncurkan baik dengan yang lama dan dengan versi baru dari data input. </p><br><img width="700" src="https://habrastorage.org/webt/r1/zr/j8/r1zrj8e-kxo8bmnd0evq6tgzktg.png"><br><br><h4 id="diff-testy">  Tes Diff </h4><br><p>  Diff-tes kami sebut jenis khusus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tes yang digerakkan oleh data</a> , yang berbeda dari pendekatan yang diterima secara umum dalam bahwa tes tidak memiliki hasil referensi, tetapi pada saat yang sama kita perlu menemukan dalam melakukan apa tes melakukan perubahan perilakunya. </p><br><p>  Pendekatan standar dalam pengujian berbasis data adalah sebagai berikut.  Tes memiliki hasil referensi yang diperoleh saat tes pertama kali dijalankan.  Hasil referensi dapat disimpan dalam repositori di sebelah tes.  Pengujian selanjutnya harus menghasilkan hasil yang sama. </p><br><img width="600" src="https://habrastorage.org/webt/gj/bq/gx/gjbqgx1rtrgb1lwxhih01ojki3k.png"><br><p>  Jika hasilnya berbeda dari referensi, pengembang harus memutuskan apakah perubahan ini diharapkan atau kesalahan.  Jika perubahan diharapkan, pengembang harus memperbarui hasil referensi pada saat yang sama dengan melakukan perubahan pada repositori. </p><br><p>  Ada kesulitan saat menggunakan pendekatan ini dalam repositori besar dengan aliran komit besar: </p><br><ol><li>  Mungkin ada banyak tes dan tes bisa sangat sulit.  Pengembang tidak memiliki kemampuan untuk menjalankan semua tes yang terpengaruh dalam lingkungan kerja. </li><li>  Setelah melakukan perubahan, tes dapat rusak jika hasil referensi tidak diperbarui secara bersamaan dengan perubahan pada kode.  Kemudian pengembang lain dapat membuat perubahan pada komponen yang sama dan hasil pengujian akan berubah lagi.  Kami mendapatkan pengenaan satu kesalahan pada kesalahan lainnya.  Sangat sulit untuk menangani masalah seperti itu, butuh waktu dari pengembang. </li></ol><br><p>  Apa yang kita lakukan  Tes diff terdiri dari 2 bagian: </p><br><ul><li>  Periksa komponen. <br><ul><li>  Kami memulai tes dan menyimpan hasilnya dalam penyimpanan sumber daya. </li><li>  Jangan bandingkan hasilnya dengan referensi. </li><li>  Kami dapat menangkap beberapa kesalahan, misalnya, program tidak memulai / tidak berakhir, macet, program tidak merespons.  Validasi hasil juga dapat dilakukan: keberadaan setiap bidang dalam jawaban, dll. </li></ul></li><li>  Komponen diff. <br><ul><li>  Bandingkan hasil yang diperoleh pada peluncuran yang berbeda dan beda build.  Dalam kasus paling sederhana, ini adalah fungsi yang mengambil 2 parameter dan mengembalikan diff. </li><li>  Penampilan diff tergantung pada tes, tetapi itu harus menjadi sesuatu yang dapat dimengerti bagi seseorang yang akan melihat diff.  Biasanya diff adalah file html. </li></ul></li></ul><br><p>  Peluncuran komponen check dan diff dikendalikan oleh sistem integrasi berkelanjutan. </p><br><img width="600" src="https://habrastorage.org/webt/jp/g2/2z/jpg22zjvje4rqvytyy8-qlrf-yo.png"><br><br><p>  Jika sistem integrasi berkelanjutan mendeteksi diff, maka pencarian biner pertama kali dilakukan untuk komit yang menyebabkan perubahan.  Setelah menerima pemberitahuan dari pengembang, dimungkinkan untuk mempelajari perbedaan dan memutuskan apa yang harus dilakukan selanjutnya: mengenali perbedaan seperti yang diharapkan (untuk ini Anda perlu melakukan tindakan khusus) atau memperbaiki / "mengembalikan" perubahan Anda. </p><br><h3 id="prodolzhenie-sleduet">  Untuk dilanjutkan </h3><br><p>  Pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel selanjutnya</a> kita akan berbicara tentang bagaimana sistem integrasi berkelanjutan bekerja. </p><br><h3 id="ssylki">  Referensi </h3><br><p>  Repositori monolitik, pengembangan berbasis trunk </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Monorepo - Wikipedia</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://trunkbaseddevelopment.com</a> </li></ul><br><p>  Pengujian berdasarkan data </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengujian berbasis data - Wikipedia</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id428972/">https://habr.com/ru/post/id428972/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id428954/index.html">Bagaimana kami menembak diri sendiri dan mencoba mencari tahu apa tepatnya</a></li>
<li><a href="../id428956/index.html">Drone di ISS</a></li>
<li><a href="../id428960/index.html">Laporan Club of Rome 2018, Bab 1.5: Tantangan Iklim</a></li>
<li><a href="../id428962/index.html">Relokasi di Luxoft: bagaimana kehidupan tersisa</a></li>
<li><a href="../id428964/index.html">Kerentanan SSD Terenkripsi Perangkat Keras Memungkinkan Penyerang dengan Mudah Memotong Tindakan Pelindung</a></li>
<li><a href="../id428974/index.html">Menarik di Interlight 2018</a></li>
<li><a href="../id428976/index.html">Bukit atau benteng semut? Saya sedang membangun rumah untuk harga sebuah apartemen. Bagian 2: Pemanasan</a></li>
<li><a href="../id428980/index.html">Broker JavaScript Offline</a></li>
<li><a href="../id428982/index.html">Cara menulis D pada ARM</a></li>
<li><a href="../id428984/index.html">Julia dan potret fase sistem dinamis</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>