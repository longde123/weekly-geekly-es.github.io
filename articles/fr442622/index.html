<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👧‍👧 👞 🌑 Comment rendre les coroutines dans Unity un peu plus pratiques 👪 📻 🏗️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Chaque développeur trouve ses avantages et ses inconvénients à utiliser coroutine dans Unity. Et il décide dans quels scénarios les appliquer et dans ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment rendre les coroutines dans Unity un peu plus pratiques</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/442622/"><p>  Chaque développeur trouve ses avantages et ses inconvénients à utiliser coroutine dans Unity.  Et il décide dans quels scénarios les appliquer et dans lesquels privilégier les alternatives. </p><br><p>  Dans la pratique quotidienne, j'utilise souvent des coroutines pour différents types de tâches.  Une fois, j'ai réalisé que c'était moi qui agaçais et rejetais de nombreux nouveaux venus en eux. </p><a name="habracut"></a><br><h2 id="koshmarnyy-interfeys">  Interface cauchemar </h2><br><p>  Le moteur ne fournit que quelques méthodes et plusieurs de leurs surcharges pour travailler avec des coroutines: </p><br><p>  <strong>Lancement</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">docs</a> ) </p><br><ul><li><code>StartCoroutine(string name, object value = null)</code> </li> <li> <code>StartCoroutine(IEnumerator routine)</code> </li> </ul><br><p>  <strong>Arrêter</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">docs</a> ) </p><br><ul><li> <code>StopCoroutine(string methodName)</code> </li> <li> <code>StopCoroutine(IEnumerator routine)</code> </li> <li> <code>StopCoroutine(Coroutine routine)</code> </li> </ul><br><p>  Les surcharges avec des paramètres de chaîne (malgré leur commodité trompeuse) peuvent immédiatement <del>  envoyer à la poubelle </del>  oublier pour au moins trois raisons. </p><br><ul><li>  L'utilisation explicite des noms de méthode de chaîne compliquera l'analyse future du code, le débogage et plus encore. </li><li>  Selon la documentation, les surcharges de chaînes prennent plus de temps et ne permettent de transmettre qu'un seul paramètre supplémentaire. </li><li>  Dans ma pratique, il s'est avéré assez souvent que rien ne s'est produit lorsqu'une surcharge de chaîne <code>StopCoroutine</code> été <code>StopCoroutine</code> .  Corutin a continué d'être exécuté. </li></ul><br><p>  D'une part, les méthodes fournies sont suffisantes pour couvrir les besoins de base.  Mais au fil du temps, j'ai commencé à remarquer qu'avec une utilisation active, je dois écrire une grande quantité de code passe-partout - c'est fatigant et nuit à sa lisibilité. </p><br><h2 id="blizhe-k-suti">  Plus près du but </h2><br><p>  Dans cet article, je veux décrire un petit wrapper que j'utilise depuis longtemps.  Grâce à elle, avec des pensées sur les coroutines, des fragments du code modèle n'apparaissent plus dans ma tête avec lesquels je devais danser autour d'eux.  De plus, toute l'équipe est devenue plus facile à lire et à comprendre les composants où les coroutines sont utilisées. </p><br><p>  Supposons que nous ayons la tâche suivante - écrire un composant qui vous permet de déplacer un objet vers un point donné. </p><br><p>  En ce moment, peu importe la méthode qui sera utilisée pour se déplacer et dans quelles coordonnées.  Seule une des nombreuses options sera sélectionnée par moi - ce sont l'interpolation et les coordonnées globales. </p><br><p>  Veuillez noter qu'il est fortement recommandé de ne pas déplacer un objet en changeant ses coordonnées «front», c'est-à-dire la construction <code>transform.position = newPosition</code> si le composant <code>RigidBody</code> est utilisé avec lui (en particulier dans la méthode <code>Update</code> ) ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">docs</a> ). </p><br><h3 id="standartnaya-realizaciya">  Implémentation standard </h3><br><p>  Je propose la mise en œuvre suivante du composant nécessaire: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> IEnumerator = System.Collections.IEnumerator; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MoveToPoint</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 target; [Space] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> threshold; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Move</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moveRoutine == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) StartCoroutine(MoveRoutine()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MoveRoutine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (Vector3.Distance(transform.position, target) &gt; threshold) { transform.position = Vector3.Lerp(transform.position, target, speed * Time.deltaTime); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Un peu de code</b> <div class="spoiler_text"><p>  Dans la méthode <code>Move</code> , il est très important d'exécuter coroutine uniquement lorsqu'il n'est pas déjà en cours d'exécution.  Sinon, ils peuvent être lancés autant que vous le souhaitez et chacun d'eux déplacera l'objet. </p><br><p>  <code>threshold</code> - tolérance.  En d'autres termes, la distance au point, approchant, nous supposerons que nous avons atteint le but. </p><br><p>  <strong>À quoi ça sert?</strong> </p><br><p>  Étant donné que tous les composants ( <code>x</code> , <code>y</code> , <code>z</code> ) de la structure <code>Vector3</code> sont de type <code>float</code> , utiliser le résultat de la vérification de l'égalité de la distance à la cible et de la tolérance comme condition de boucle est une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mauvaise idée</a> . </p><br><p>  Nous vérifions la distance de la cible pour plus / moins, ce qui nous permet d'éviter ce problème. </p><br><p>  En outre, si vous le souhaitez, vous pouvez utiliser la <code>Mathf.Approximately</code> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">docs</a> ) pour une vérification <em>approximative</em> de l'égalité.  Il convient de noter qu'avec certaines méthodes de déplacement, la vitesse peut s'avérer suffisamment élevée pour que l'objet «saute» la cible dans une image.  Alors le cycle ne finira jamais.  Par exemple, si vous utilisez la méthode <code>Vector3.MoveTowards</code> . </p><br><p>  Pour <code>Vector3</code> que je sache, dans le moteur Unity pour la structure <code>Vector3</code> , l'opérateur <code>Vector3</code> est déjà redéfini de telle sorte que <code>Mathf.Approximately</code> est appelé pour vérifier l'égalité au niveau des composants. </p></div></div><br><p>  C'est tout pour l'instant, notre composant est assez simple.  Et pour le moment il n'y a pas de problèmes.  Mais, quel est ce composant qui vous permet de déplacer un objet vers un point, mais ne fournit pas l'occasion de l'arrêter.  Corrigeons cette injustice. </p><br><p>  Puisque vous et moi avons décidé de ne pas passer du mauvais côté et de ne pas utiliser de surcharge avec des paramètres de chaîne, nous devons maintenant enregistrer quelque part un lien vers la coroutine en cours d'exécution.  Sinon, comment alors l'arrêter? </p><br><p>  Ajoutez un champ: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Coroutine moveRoutine;</code> </pre> <br><p>  Fix <code>Move</code> : </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Move</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moveRoutine == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) moveRoutine = StartCoroutine(MoveRoutine()); }</code> </pre> <br><p>  Ajoutez une méthode de stop motion: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moveRoutine != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) StopCoroutine(moveRoutine); }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Code entier</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> IEnumerator = System.Collections.IEnumerator; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MoveToPoint</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 target; [Space] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> threshold; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Coroutine moveRoutine; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Move</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moveRoutine == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) moveRoutine = StartCoroutine(MoveRoutine()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moveRoutine != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) StopCoroutine(moveRoutine); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MoveRoutine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (Vector3.Distance(transform.position, target) &gt; threshold) { transform.position = Vector3.Lerp(transform.position, target, speed * Time.deltaTime); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } }</code> </pre> </div></div><br><p>  Une toute autre affaire! <del>  Appliquer au moins sur la plaie. </del></p><br><p>  Alors.  Nous avons un petit composant qui effectue la tâche.  Quelle est mon indignation? </p><br><h3 id="problemy-i-ih-reshenie">  Problèmes et leur solution </h3><br><p>  Au fil du temps, le projet se développe, et avec lui le nombre de composants, y compris ceux utilisant des coroutines.  Et à chaque fois, ces choses me hantent de plus en plus: </p><br><ul><li>  Appels sandwich en cours </li></ul><br><pre> <code class="cs hljs">StartCoroutine(MoveRoutine());</code> </pre> <br><pre> <code class="cs hljs">StopCoroutine(moveRoutine);</code> </pre> <br><p>  Le simple fait de les regarder fait trembler mes yeux, et lire un tel code est un plaisir douteux (je suis d'accord, cela peut être pire).  Mais ce serait beaucoup plus agréable et plus visuel d'avoir quelque chose comme ça: </p><br><pre> <code class="cs hljs">moveRoutine.Start();</code> </pre> <br><pre> <code class="cs hljs">moveRoutine.Stop();</code> </pre> <br><ul><li>  Chaque fois que vous appelez <code>StartCoroutine</code> vous devez vous rappeler de sauvegarder la valeur de retour: </li></ul><br><pre> <code class="cs hljs">moveRoutine = StartCoroutine(MoveRoutine());</code> </pre> <br><p>  Sinon, en raison du manque de référence à la coroutine, vous ne pouvez tout simplement pas l'arrêter. </p><br><ul><li>  Contrôles constants: </li></ul><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moveRoutine == <span class="hljs-literal"><span class="hljs-literal">null</span></span>)</code> </pre> <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moveRoutine != <span class="hljs-literal"><span class="hljs-literal">null</span></span>)</code> </pre> <br><ul><li>  Et une autre chose mauvaise dont vous devez toujours vous souvenir (et que je <del>  encore oublié </del>  spécialement raté).  À la toute fin de la coroutine et avant chaque sortie de celle-ci (par exemple, en utilisant la <code>yield break</code> ), il est nécessaire de réinitialiser la valeur du champ. <br><pre> <code class="cs hljs">moveRoutine = <span class="hljs-literal"><span class="hljs-literal">null</span></span>;</code> </pre> </li></ul><br><p>  Si vous oubliez, vous recevrez une coroutine unique.  Après la première exécution dans <code>moveRoutine</code> , le lien vers la coroutine restera et la nouvelle exécution ne fonctionnera pas. </p><br><p>  De la même manière, vous devez faire en cas d'arrêt forcé: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moveRoutine != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { StopCoroutine(moveRoutine); moveRoutine = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Code avec toutes les modifications</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MoveToPoint</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 target; [Space] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> threshold; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> Coroutine moveRoutine; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Move</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { moveRoutine = StartCoroutine(MoveRoutine()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (moveRoutine != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { StopCoroutine(moveRoutine); moveRoutine = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MoveRoutine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (Vector3.Distance(transform.position, target) &gt; threshold) { transform.localPosition = Vector3.Lerp(transform.position, target, speed * Time.deltaTime); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } moveRoutine = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } }</code> </pre> </div></div><br><p>  À un moment donné, je veux vraiment sortir une fois cette mascarade quelque part et ne me laisser que les méthodes nécessaires: <code>Start</code> , <code>Stop</code> et quelques autres événements et propriétés. </p><br><p>  <strong>Faisons-le enfin!</strong> </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CoroutineObject</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MonoBehaviour Owner { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Coroutine Coroutine { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Func&lt;IEnumerator&gt; Routine { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsProcessing =&gt; Coroutine != <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CoroutineObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MonoBehaviour owner, Func&lt;IEnumerator&gt; routine</span></span></span><span class="hljs-function">)</span></span> { Owner = owner; Routine = routine; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Process</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Routine.Invoke(); Coroutine = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Stop(); Coroutine = Owner.StartCoroutine(Process()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (IsProcessing) { Owner.StopCoroutine(Coroutine); Coroutine = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Débriefing</b> <div class="spoiler_text"><p>  <code>Owner</code> - un lien vers l'instance <code>MonoBehaviour</code> à laquelle la coroutine sera attachée.  Comme vous le savez, elle doit être exécutée dans le contexte d'un composant particulier, car c'est à lui qu'appartiennent les méthodes <code>StartCoroutine</code> et <code>StopCoroutine</code> .  En conséquence, nous avons besoin d'un lien vers le composant qui sera le propriétaire de la coroutine. </p><br><p>  <code>Coroutine</code> - un analogue du champ <code>moveRoutine</code> dans le composant <code>MoveToPoint</code> , contient un lien vers la coroutine actuelle. </p><br><p>  <code>Routine</code> - le délégué avec lequel la méthode faisant office de coroutine sera communiquée. </p><br><p>  <code>Process()</code> est un petit wrapper sur la méthode <code>Routine</code> principale.  Il est nécessaire pour pouvoir tracer lorsque l'exécution de la coroutine est terminée, réinitialiser le lien vers celui-ci et exécuter un autre code à ce moment (si nécessaire). </p><br><p>  <code>IsProcessing</code> - vous permet de savoir si la coroutine est en cours d'exécution. </p></div></div><br><p>  Ainsi, nous nous débarrassons d'une grande quantité de maux de tête, et notre composant prend un aspect complètement différent: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> IEnumerator = System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MoveToPoint</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 target; [Space] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> threshold; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CoroutineObject moveRoutine; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { moveRoutine = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CoroutineObject(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, MoveRoutine); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Move</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; moveRoutine.Start(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; moveRoutine.Stop(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MoveRoutine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (Vector3.Distance(transform.position, target) &gt; threshold) { transform.position = Vector3.Lerp(transform.position, target, speed * Time.deltaTime); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } }</code> </pre> <br><p>  Il ne reste que la coroutine elle-même et quelques lignes de code pour travailler avec.  Beaucoup mieux. </p><br><p>  Supposons qu'une nouvelle tâche soit arrivée - vous devez ajouter la possibilité d'exécuter n'importe quel code une fois que l'objet a atteint son objectif. </p><br><p>  Dans la version originale, nous devrions ajouter un paramètre délégué supplémentaire à chaque coroutine qui peut être extraite après son achèvement. </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MoveRoutine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">System.Action callback</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (Vector3.Distance(transform.position, target) &gt; threshold) { transform.position = Vector3.Lerp(transform.position, target, speed * Time.deltaTime); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } moveRoutine = <span class="hljs-literal"><span class="hljs-literal">null</span></span> callback?.Invoke(); }</code> </pre> <br><p>  Et appelez comme suit: </p><br><pre> <code class="cs hljs">moveRoutine = StartCoroutine(moveRoutine(CallbackHandler)); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CallbackHandler</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// do something }</span></span></code> </pre> <br><p>  Et s'il y a du lambda en tant que gestionnaire, cela semble encore pire. </p><br><p>  Avec notre wrapper, il suffit d'y ajouter une seule fois cet événement. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Action Finish;</code> </pre> <br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Process</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Routine.Invoke(); Coroutine = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; Finish?.Invoke(); }</code> </pre> <br><p>  Et puis, si nécessaire, abonnez-vous. </p><br><pre> <code class="cs hljs">moveRoutine.Finished += OnFinish; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnFinish</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-comment"><span class="hljs-comment">// do something }</span></span></code> </pre> <br><p>  Je crois que vous avez déjà remarqué que la version actuelle du wrapper offre la possibilité de travailler uniquement avec des coroutines sans paramètres.  Par conséquent, nous pouvons écrire un wrapper généralisé pour coroutine avec un paramètre.  Le reste se fait par analogie. </p><br><p>  Mais, pour le bien, ce serait bien de mettre d'abord le code, qui sera le même pour tous les wrappers, dans une classe de base, afin de ne pas écrire la même chose.  Nous combattons cela. </p><br><p>  Nous le supprimons: </p><br><ul><li>  Propriétaire des <code>Owner</code> , <code>Coroutine</code> , <code>IsProcessing</code> </li><li>  Événement <code>Finished</code> </li></ul><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Action = System.Action; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CoroutineObjectBase</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> MonoBehaviour Owner { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Coroutine Coroutine { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsProcessing =&gt; Coroutine != <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action Finished; }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Wrapper sans paramètre après refactoring</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CoroutineObject</span></span> : <span class="hljs-title"><span class="hljs-title">CoroutineObjectBase</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Func&lt;IEnumerator&gt; Routine { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action Finished; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CoroutineObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MonoBehaviour owner, Func&lt;IEnumerator&gt; routine</span></span></span><span class="hljs-function">)</span></span> { Owner = owner; Routine = routine; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Process</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Routine.Invoke(); Coroutine = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; Finished?.Invoke(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Stop(); Coroutine = Owner.StartCoroutine(Process()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsProcessing) { Owner.StopCoroutine(Coroutine); Coroutine = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } }</code> </pre> </div></div><br><p>  Et maintenant, en fait, un wrapper pour coroutine avec un paramètre: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">CoroutineObject</span></span>&lt;<span class="hljs-title"><span class="hljs-title">T</span></span>&gt; : <span class="hljs-title"><span class="hljs-title">CoroutineObjectBase</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Func&lt;T, IEnumerator&gt; Routine { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> Action Finished; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CoroutineObject</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">MonoBehaviour owner, Func&lt;T, IEnumerator&gt; routine</span></span></span><span class="hljs-function">)</span></span> { Owner = owner; Routine = routine; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Process</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T arg</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Routine.Invoke(arg); Coroutine = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; Finished?.Invoke(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">T arg</span></span></span><span class="hljs-function">)</span></span> { Stop(); Coroutine = Owner.StartCoroutine(Process(arg)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(IsProcessing) { Owner.StopCoroutine(Coroutine); Coroutine = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } }</code> </pre> <br><p>  Comme vous pouvez le voir, le code est presque le même.  Ce n'est qu'à certains endroits que des fragments ont été ajoutés, selon le nombre d'arguments. </p><br><p>  Supposons que l'on nous ait demandé de mettre à jour le composant MoveToPoint afin que le point puisse être défini non pas via la fenêtre <code>Inspector</code> dans l'éditeur, mais par code lors de l'appel de la méthode <code>Move</code> . </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> IEnumerator = System.Collections.IEnumerator; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MoveToPoint</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> threshold; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> CoroutineObject&lt;Vector3&gt; moveRoutine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> IsMoving =&gt; moveRoutine.IsProcessing; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Awake</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { moveRoutine = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> CoroutineObject&lt;Vector3&gt;(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, MoveRoutine); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Move</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 target</span></span></span><span class="hljs-function">)</span></span> =&gt; moveRoutine.Start(target); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; moveRoutine.Stop(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> IEnumerator </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MoveRoutine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Vector3 target</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (Vector3.Distance(transform.position, target) &gt; threshold) { transform.localPosition = Vector3.Lerp(transform.position, target, speed); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; } } }</code> </pre> <br><p>  Il existe de nombreuses options pour étendre autant que possible les fonctionnalités de ce wrapper: ajouter un lancement retardé, des événements avec des paramètres, un suivi possible de la progression de la coroutine, etc.  Mais je suggère d'arrêter à ce stade. </p><br><p>  Le but de cet article est le désir de partager les problèmes urgents que j'ai rencontrés et de leur proposer une solution, et non de couvrir les besoins éventuels de tous les développeurs. </p><br><p>  J'espère que les camarades débutants et expérimentés bénéficieront de mon expérience.  Peut-être partageront-ils leurs commentaires ou signaleront-ils des erreurs que j'aurais pu commettre. </p><br></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr442622/">https://habr.com/ru/post/fr442622/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr442612/index.html">Moteur en carton pour un jeu de société électrique. Comment nous l'avons rapproché de la réalité</a></li>
<li><a href="../fr442614/index.html">CI / CD utilisant Jenkins sur Kubernetes</a></li>
<li><a href="../fr442616/index.html">Nous accélérons le traitement des événements à 1,6 million par seconde</a></li>
<li><a href="../fr442618/index.html">Pas pour le selfie: test immuno-enzymatique numérique utilisant une nouvelle puce intégrée dans un smartphone</a></li>
<li><a href="../fr442620/index.html">Apprentissage automatique dans la surveillance informatique</a></li>
<li><a href="../fr442624/index.html">Le livre «Algorithme parfait. Les bases</a></li>
<li><a href="../fr442626/index.html">Habraiting: construction d'un nuage de mots russophones sur l'exemple des en-têtes Habra</a></li>
<li><a href="../fr442630/index.html">Durabilité de la lampe LED et rendement lumineux réduit</a></li>
<li><a href="../fr442632/index.html">Énergie géothermique: comment la chaleur de la Terre a été transformée en une ressource énergétique efficace</a></li>
<li><a href="../fr442636/index.html">Apportez-vous de mauvaises nouvelles à la direction?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>