<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍌 👩🏿‍🤝‍👩🏾 🈲 Sandera COBOL dan Matematika. Bagian 1 👱🏿 🤲🏾 🙌🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mari kita hadapi itu: tidak ada yang suka angka pecahan - bahkan komputer. 

 Ketika datang ke bahasa pemrograman COBOL, pertanyaan pertama yang muncu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sandera COBOL dan Matematika. Bagian 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/467251/">  Mari kita hadapi itu: tidak ada yang suka angka pecahan - bahkan komputer. <br><br>  Ketika datang ke bahasa pemrograman COBOL, pertanyaan pertama yang muncul di kepala semua orang selalu terlihat seperti ini: "Mengapa umat manusia masih menggunakan bahasa ini di banyak bidang penting?"  Bank masih menggunakan COBOL.  Sekitar 7% dari PDB AS bergantung pada COBOL dalam memproses pembayaran dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CMS</a> .  Layanan Pendapatan Internal Amerika Serikat (IRS), seperti yang diketahui semua orang, masih menggunakan COBOL.  Bahasa ini juga digunakan dalam penerbangan ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari sini</a> saya belajar satu hal yang menarik tentang topik ini: nomor reservasi pada tiket pesawat digunakan untuk menjadi pointer biasa).  Kita dapat mengatakan bahwa banyak organisasi yang sangat serius, apakah itu sektor swasta atau publik, masih menggunakan COBOL. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/q1/m_/gs/q1m_gsyxbbwdk32ng3w1foeckgc.jpeg"></a> <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian kedua</a> <br><br>  Penulis bahan, bagian pertama dari terjemahan yang kami terbitkan hari ini, akan menemukan jawaban untuk pertanyaan mengapa COBOL, bahasa yang muncul pada tahun 1959, masih begitu luas. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Mengapa COBOL masih hidup?</font> </h2><br>  Jawaban tradisional untuk pertanyaan ini sangat sinis.  Organisasi adalah kemalasan, ketidakmampuan dan kebodohan.  Mereka mengejar murahnya dan tidak cenderung berinvestasi dalam menulis ulang sistem perangkat lunak mereka pada sesuatu yang modern.  Secara umum, dapat diasumsikan bahwa alasan bahwa pekerjaan sejumlah besar organisasi tergantung pada COBOL adalah kombinasi dari kelembaman dan kepicikan.  Dan dalam hal ini, tentu saja, ada beberapa kebenaran.  Menulis ulang sejumlah besar kode membingungkan adalah tugas besar.  Itu mahal.  Ini rumit.  Dan jika perangkat lunak yang ada tampaknya berfungsi dengan baik, organisasi tidak akan memiliki motivasi yang kuat untuk berinvestasi dalam proyek untuk memperbarui perangkat lunak ini. <br><br>  Semua ini begitu.  Tetapi ketika saya bekerja di IRS, para veteran COBOL berbicara tentang bagaimana mereka mencoba menulis ulang kode di Jawa dan ternyata Java tidak dapat melakukan perhitungan dengan benar. <br><br>  Kedengarannya sangat aneh bagi saya.  Sangat aneh sehingga saya langsung berpikir: "Tuhan, itu artinya IRS telah menyelesaikan pembayaran pajak untuk semua orang selama 50 tahun !!!"  Saya tidak percaya COBOL dapat berkeliling Jawa dalam hal perhitungan matematis yang diperlukan oleh IRS.  Pada akhirnya - mereka tidak meluncurkan orang ke luar angkasa. <br><br>  Salah satu efek samping yang menarik dari belajar COBOL di musim panas adalah saya mulai memahami yang berikut.  Intinya bukan bahwa Java tidak dapat melakukan perhitungan matematika dengan benar.  Intinya adalah bagaimana tepatnya Java membuat perhitungan benar.  Dan ketika Anda memahami bagaimana perhitungan dilakukan di Jawa, dan bagaimana hal yang sama dilakukan dalam COBOL, Anda mulai memahami mengapa banyak organisasi merasa sangat sulit untuk menyingkirkan warisan komputer mereka. <br><br><h2>  <font color="#3AC1EF">"Aku" apa yang harus diberi titik?</font> </h2><br>  Saya akan pindah sedikit dari cerita COBOL dan berbicara tentang bagaimana komputer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menyimpan informasi</a> sebelum representasi biner data menjadi standar de facto (tetapi materi tentang cara menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">antarmuka</a> z / OS; ini adalah sesuatu yang istimewa).  Saya pikir dalam mempertimbangkan masalah kita, akan berguna untuk menyimpang dari tema utama ke arah ini.  Dalam materi yang disebutkan di atas, saya berbicara tentang berbagai cara menggunakan saklar biner untuk menyimpan angka dalam sistem biner, ternary, desimal, untuk menyimpan angka negatif - dan seterusnya.  Satu-satunya hal yang saya tidak cukup perhatikan adalah bagaimana angka desimal disimpan. <br><br>  Jika Anda mendesain komputer biner Anda sendiri, maka Anda bisa mulai dengan memutuskan bahwa Anda akan menggunakan sistem angka biner.  Bit di sebelah kiri titik mewakili bilangan bulat - 1, 2, 4, 8. Dan bit di sebelah kanan - angka pecahan - 1/2, 1/4, 1/8 ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c87/2eb/182/c872eb1825dc1d6b456ae11cbcc3325d.png"></div><br>  <i><font color="#999999">2,75 dalam representasi biner</font></i> <br><br>  Masalahnya di sini adalah memahami bagaimana menyimpan titik desimal itu sendiri (sebenarnya - saya harus mengatakan "titik biner" - karena, setelah semua, kita berbicara tentang angka biner).  Ini bukan semacam "alkimia komputer", jadi Anda bisa menebak apa yang saya bicarakan tentang angka titik mengambang dan angka titik tetap.  Dalam angka floating point, titik biner dapat ditempatkan di mana saja (yaitu, itu bisa "mengambang").  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Posisi</a> titik disimpan sebagai eksponen.  Kemampuan untuk memindahkan suatu titik memungkinkan untuk menyimpan rentang angka yang lebih luas daripada yang tersedia tanpa adanya kesempatan seperti itu.  Titik desimal dapat dipindahkan ke bagian paling belakang angka dan pilih semua bit untuk menyimpan nilai integer, mewakili angka yang sangat besar.  Intinya dapat digeser ke depan angka dan menyatakan nilai yang sangat kecil.  Tetapi kebebasan ini datang pada harga keakuratan.  Mari kita lihat lagi representasi biner 2,75 dari contoh sebelumnya.  Transisi dari empat ke delapan jauh lebih dari transisi dari seperempat ke delapan.  Mungkin lebih mudah bagi kita untuk membayangkan ini jika kita menulis ulang contoh seperti yang ditunjukkan di bawah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/894/ec9/8aa/894ec98aa1715609e45d95ede3b865b1.png"></div><br>  <i><font color="#999999">Saya memilih jarak antara angka dengan mata - hanya untuk menunjukkan ide saya</font></i> <br><br>  Perbedaan antara angka-angka itu mudah dihitung sendiri.  Misalnya, jarak antara 1/16 dan 1/32 adalah 0,03125, tetapi jarak antara 1/2 dan 1/4 sudah 0,25. <br><br>  Mengapa ini penting?  Dalam kasus representasi bilangan bulat biner, ini tidak masalah - jarak antara angka-angka yang berdekatan dari catatan biner dapat dengan mudah dikompensasi dengan mengisinya dengan kombinasi bit yang sesuai dan tanpa kehilangan akurasi.  Tetapi dalam kasus representasi bilangan pecahan, itu tidak begitu sederhana.  Jika Anda mencoba "mengisi" "lubang" di antara angka-angka yang berdekatan - sesuatu dapat "jatuh" (dan benar-benar jatuh) ke dalam lubang ini.  Ini mengarah pada fakta bahwa dalam format biner tidak mungkin untuk mendapatkan representasi angka pecahan yang tepat. <br><br>  Ini diilustrasikan oleh contoh klasik angka 0,1 (sepersepuluh).  Bagaimana cara merepresentasikan angka ini dalam format biner?  2 <sup>-1</sup> adalah 1/2, atau 0,5.  Ini terlalu banyak.  1/16 adalah 0,0635.  Ini terlalu sedikit.  1/16 + 1/32 sudah lebih dekat (0,09375), tetapi 1/16 + 1/32 + 1/64 sudah lebih dari yang kita butuhkan (0,109375). <br><br>  Jika Anda yakin bahwa alasan ini dapat dilanjutkan tanpa batas waktu - maka Anda benar - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">apa adanya</a> . <br><br>  Di sini Anda dapat berkata kepada diri sendiri: "Mengapa kita tidak menyimpan 0,1 saja dengan cara yang sama seperti kita menyimpan nomor 1?  Kami dapat menyimpan angka 1 tanpa masalah - jadi mari kita hapus titik desimal dan simpan angka apa pun dengan cara yang sama seperti kita menyimpan bilangan bulat. " <br><br>  Ini adalah solusi yang sangat baik untuk masalah ini, kecuali bahwa itu memerlukan memperbaiki titik biner / desimal di beberapa tempat yang telah ditentukan.  Kalau tidak, angka 10.00001 dan 100000.1 akan terlihat sama persis.  Tetapi jika titik tersebut diperbaiki sehingga, katakanlah, 2 digit dialokasikan ke bagian fraksional dari angka, maka kita dapat membulatkan 10.00001 menjadi 10.00, dan 100000.1 akan berubah menjadi 100000.10. <br><br>  Kami baru saja "menemukan" angka titik tetap. <br><br>  Dengan representasi nilai yang berbeda menggunakan angka titik tetap, kami baru saja menemukannya.  Itu mudah dilakukan.  Apakah mungkin, menggunakan nomor-nomor tetap, untuk memfasilitasi solusi dari beberapa masalah lain?  Mari kita ingat di sini tentang teman baik kita - tentang angka desimal biner (Binary Coded Decimal, BCD).  Ngomong-ngomong, untuk memberi tahu Anda, angka-angka ini digunakan di sebagian besar kalkulator ilmiah dan grafik.  Dari perangkat ini, yang cukup jelas, mereka mengharapkan hasil perhitungan yang benar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/102/020/d31/102020d313c5627bb37fc6dee57954a4.jpg"></div><br>  <i><font color="#999999">TI-84 Plus Calculator</font></i> <br><br><h2>  <font color="#3AC1EF">Rasio pengulangan Muller dan Python</font> </h2><br>  Angka titik tetap dianggap lebih akurat karena fakta bahwa "lubang" di antara angka-angka itu konstan, dan karena pembulatan terjadi hanya ketika Anda perlu membayangkan angka yang tidak ada cukup ruang.  Tetapi ketika menggunakan angka floating point, kita bisa mewakili angka yang sangat besar dan sangat kecil menggunakan jumlah memori yang sama.  Benar, dengan bantuan mereka tidak mungkin untuk mewakili semua angka dalam rentang yang dapat diakses secara akurat dan kami terpaksa menggunakan pembulatan untuk mengisi "lubang". <br><br>  COBOL dibuat sebagai bahasa di mana, secara default, nomor titik tetap digunakan.  Tetapi apakah ini berarti bahwa COBOL lebih baik daripada bahasa modern untuk melakukan perhitungan matematika?  Jika kita menangkap masalah seperti hasil penghitungan nilai 0,1 + 0,2, maka sepertinya pertanyaan sebelumnya harus dijawab "ya".  Tapi itu akan membosankan.  Jadi mari kita lanjutkan. <br><br>  Kita akan bereksperimen dengan COBOL menggunakan apa yang disebut hubungan Perulangan Muller.  Jean-Michel Muller adalah seorang ilmuwan Perancis yang mungkin telah membuat penemuan ilmiah utama di bidang teknologi informasi.  Dia menemukan cara untuk memutus operasi yang benar dari komputer menggunakan matematika.  Saya yakin bahwa ia akan mengatakan bahwa ia mempelajari masalah keandalan dan akurasi, tetapi tidak dan tidak lagi: ia menciptakan masalah matematika yang “menghancurkan” komputer.  Salah satu tugas ini adalah rumus perulangannya.  Ini terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fa/1d8/56c/8fa1d856cfe581c272fc25a8c55e8938.png"></div><br>  <i><font color="#999999">Contoh ini diambil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari sini.</a></font></i> <br><br>  Formula itu sepertinya tidak menakutkan sama sekali.  Benar?  Tugas ini sesuai untuk tujuan kami karena alasan berikut: <br><br><ul><li>  Hanya aturan matematika sederhana yang digunakan di sini - tidak ada rumus rumit atau ide yang mendalam. </li><li>  Kita mulai dengan angka yang memiliki dua digit setelah titik desimal.  Sebagai hasilnya, mudah untuk membayangkan bahwa kita bekerja dengan nilai-nilai yang mewakili jumlah uang tertentu. </li><li>  Kesalahan yang dihasilkan dari perhitungan bukanlah kesalahan pembulatan kecil.  Ini adalah penyimpangan dari hasil yang benar oleh seluruh urutan besarnya. </li></ul><br>  Berikut ini adalah skrip Python kecil yang menghitung hasil relasi pengulangan Mueller menggunakan angka floating-point dan fixed-point: <br><br><pre><code class="plaintext hljs">from decimal import Decimal def rec(y, z):  return 108 - ((815-1500/z)/y)  def floatpt(N):  x = [4, 4.25]  for i in range(2, N+1):   x.append(rec(x[i-1], x[i-2]))  return x  def fixedpt(N):  x = [Decimal(4), Decimal(17)/Decimal(4)]  for i in range(2, N+1):   x.append(rec(x[i-1], x[i-2]))  return x N = 20 flt = floatpt(N) fxd = fixedpt(N) for i in range(N):  print str(i) + ' | '+str(flt[i])+' | '+str(fxd[i])</code> </pre> <br>  Inilah hasil skrip ini: <br><br><pre> <code class="plaintext hljs">i | floating pt  | fixed pt -- | -------------- | --------------------------- 0 | 4       | 4 1 | 4.25      | 4.25 2 | 4.47058823529 | 4.4705882352941176470588235 3 | 4.64473684211 | 4.6447368421052631578947362 4 | 4.77053824363 | 4.7705382436260623229461618 5 | 4.85570071257 | 4.8557007125890736342039857 6 | 4.91084749866 | 4.9108474990827932004342938 7 | 4.94553739553 | 4.9455374041239167246519529 8 | 4.96696240804 | 4.9669625817627005962571288 9 | 4.98004220429 | 4.9800457013556311118526582 10 | 4.9879092328  | 4.9879794484783912679439415 11 | 4.99136264131 | 4.9927702880620482067468253 12 | 4.96745509555 | 4.9956558915062356478184985 13 | 4.42969049831 | 4.9973912683733697540253088 14 | -7.81723657846 | 4.9984339437852482376781601 15 | 168.939167671 | 4.9990600687785413938424188 16 | 102.039963152 | 4.9994358732880376990501184 17 | 100.099947516 | 4.9996602467866575821700634 18 | 100.004992041 | 4.9997713526716167817979714 19 | 100.000249579 | 4.9993671517118171375788238</code> </pre> <br>  Hingga iterasi 12, kesalahan pembulatan terlihat lebih atau kurang signifikan, tetapi kemudian neraka yang sebenarnya dimulai.  Perhitungan floating-point berkumpul untuk angka yang dua puluh kali lebih besar dari apa yang dihasilkan dari perhitungan titik tetap. <br><br>  Mungkin Anda berpikir tidak mungkin ada orang yang melakukan perhitungan rekursif skala besar.  Tetapi justru inilah yang menyebabkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bencana tahun</a> 1991, yang menyebabkan kematian 28 orang, ketika sistem kendali rudal Patriot secara salah menghitung waktu.  Ternyata perhitungan floating point secara tidak sengaja banyak merugikan.  Inilah beberapa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">hal</a> hebat yang mungkin komputasi kinerja tinggi hanyalah cara yang lebih cepat untuk mendapatkan jawaban yang salah.  Baca karya ini jika Anda ingin mendapatkan informasi lebih lanjut tentang masalah yang dibahas di sini dan lihat lebih banyak contoh. <br><br>  Masalahnya adalah jumlah RAM yang dimiliki komputer tidak terbatas.  Oleh karena itu, mustahil untuk menyimpan jumlah desimal (atau biner) yang tak terbatas.  Perhitungan fixed-point bisa lebih akurat daripada perhitungan floating-point jika ada keyakinan bahwa kecil kemungkinan akan lebih banyak angka yang dibutuhkan setelah poin daripada format yang digunakan.  Jika nomor tidak sesuai dengan format ini, itu akan dibulatkan.  Perlu dicatat bahwa baik perhitungan titik tetap maupun perhitungan titik mengambang tidak terlindungi dari masalah yang ditunjukkan oleh hubungan berulang Mueller.  Baik itu dan orang lain sebagai hasilnya memberikan hasil yang salah.  Pertanyaannya adalah kapan ini terjadi.  Jika Anda menambah jumlah iterasi dalam skrip Python, misalnya, dari 20 menjadi 22, maka angka terakhir yang diperoleh dalam perhitungan dengan titik tetap adalah 0,728107.  23 iterasi?  -501.7081261.  24?  105.8598187. <br><br>  Dalam bahasa yang berbeda, masalah ini memanifestasikan dirinya dengan cara yang berbeda.  Beberapa, seperti COBOL, memungkinkan Anda untuk bekerja dengan angka yang parameternya diatur dengan ketat.  Dan dengan Python, misalnya, ada nilai default yang dapat dikonfigurasi jika komputer memiliki cukup memori.  Jika kita menambahkan baris <code>getcontext().prec = 60</code> ke program kami, memberi tahu modul desimal Python bahwa ia akan menggunakan 60 posisi setelah periode, dan bukan 28, seperti yang dilakukan secara default, program akan dapat melakukan 40 iterasi relasi perulangan tanpa kesalahan Mueller. <br><br>  Dilanjutkan ... <br><br>  <b>Pembaca yang budiman!</b>  Sudahkah Anda mengalami masalah serius yang timbul dari sifat perhitungan floating-point? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/it/t5/3p/itt53pns2iucwylb3bwn1fmmtnu.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467251/">https://habr.com/ru/post/id467251/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467239/index.html">Perbedaan antara Data Scientist dan seorang remaja dalam mobil sport</a></li>
<li><a href="../id467241/index.html">Troli truk ROS. Bagian 4. Membuat simulasi robot menggunakan editor rviz dan gazebo</a></li>
<li><a href="../id467245/index.html">Dmitry Matskevich, Dbrain: tentang kewirausahaan sebagai cacat mental, AI, dan keamanan emosional</a></li>
<li><a href="../id467247/index.html">Sebuah kisah tentang V8, React dan penurunan kinerja. Bagian 1</a></li>
<li><a href="../id467249/index.html">Sebuah kisah tentang V8, React dan penurunan kinerja. Bagian 2</a></li>
<li><a href="../id467253/index.html">Sandera COBOL dan Matematika. Bagian 2</a></li>
<li><a href="../id467255/index.html">Tiga Kesalahan Umum tentang Keamanan Yang Harus Diketahui Setiap Pengembang Tentang</a></li>
<li><a href="../id467257/index.html">Jangan menyimpan semua telur Anda dalam satu keranjang sekaligus</a></li>
<li><a href="../id467259/index.html">DPI (inspeksi SSL) bertentangan dengan makna kriptografi, tetapi perusahaan menerapkannya</a></li>
<li><a href="../id467261/index.html">Threading yang tepat dalam Qt</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>