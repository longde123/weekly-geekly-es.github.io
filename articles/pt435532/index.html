<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï¥üèæ üë®üèΩ‚Äçüåæ üëû Tornado vs Aiohttp: uma jornada pela natureza de estruturas ass√≠ncronas ü•å üìµ ü§úüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Oi Eu sou Dima e estou sentado em Python h√° algum tempo. Hoje, quero mostrar as diferen√ßas entre duas estruturas ass√≠ncronas - Tornado e Aiohttp. Vou ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tornado vs Aiohttp: uma jornada pela natureza de estruturas ass√≠ncronas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/avito/blog/435532/">  Oi  Eu sou Dima e estou sentado em Python h√° algum tempo.  Hoje, quero mostrar as diferen√ßas entre duas estruturas ass√≠ncronas - Tornado e Aiohttp.  Vou contar a hist√≥ria da escolha entre as estruturas do nosso projeto, como as corotinas do Tornado e do AsyncIO diferem. Mostrarei benchmarks e darei algumas dicas √∫teis sobre como entrar na natureza das estruturas e sair com √™xito. <br><br><img src="https://habrastorage.org/webt/df/uz/jm/dfuzjmbmzyoqjfd87asllltamtk.png"><br><a name="habracut"></a><br>  Como voc√™ sabe, o Avito √© um servi√ßo de an√∫ncios bastante grande.  Temos muitos dados e carga, 35 milh√µes de usu√°rios todos os meses e 45 milh√µes de an√∫ncios ativos diariamente.  Trabalho como consultor t√©cnico de um grupo de desenvolvimento de recomenda√ß√µes.  Minha equipe escreve microsservi√ßos, agora temos cerca de vinte deles.  Uma carga est√° acumulando tudo isso - como 5k RPS. <br><br><h2>  Escolhendo uma estrutura ass√≠ncrona </h2><br>  Primeiro, vou contar como acabamos onde estamos agora.  Em 2015, precis√°vamos escolher uma estrutura ass√≠ncrona, porque sab√≠amos: <br><br><ul><li>  que voc√™ precisa fazer muitas solicita√ß√µes para outros microsservi√ßos: http, json, rpc; </li><li>  que voc√™ precisar√° coletar dados de diferentes fontes o tempo todo: Redis, Postgres, MongoDB. </li></ul><br>  Assim, temos muitas tarefas de rede e o aplicativo √© ocupado principalmente com entrada / sa√≠da.  A vers√£o atual do python na √©poca era 3.4, ass√≠ncrona e aguardada ainda n√£o apareceu.  Aiohttp tamb√©m estava - na vers√£o 0.x.  O Tornado Ass√≠ncrono do Facebook apareceu em 2010.  Muitos drivers de banco de dados foram escritos para ele que precisamos.  O Tornado apresentou resultados est√°veis ‚Äã‚Äãnos benchmarks.  Ent√£o paramos a nossa escolha nesse quadro. <br><br>  Tr√™s anos depois, entendemos muito. <br><br>  Primeiro, o Python 3.5 foi lan√ßado com mec√¢nica ass√≠ncrona / aguardada.  N√≥s descobrimos qual √© a diferen√ßa entre rendimento e rendimento e como o Tornado √© consistente com aguardar (spoiler: n√£o muito bom). <br>  Em segundo lugar, encontramos problemas estranhos de desempenho com uma grande quantidade de corotina no agendador, mesmo quando a CPU n√£o est√° totalmente ocupada. <br>  Em terceiro lugar, descobrimos que, ao executar um grande n√∫mero de solicita√ß√µes HTTP para outros servi√ßos Tornado, voc√™ precisa ser especialmente amig√°vel com o resolvedor de DNS ass√≠ncrono, ele n√£o respeita os tempos limite para estabelecer uma conex√£o e enviar a solicita√ß√£o que especificamos.  E, em geral, o melhor m√©todo para fazer solicita√ß√µes HTTP no Tornado √© o curl, o que √© bastante estranho por si s√≥. <br><br>  Em sua <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">palestra na PyCon Russia 2018,</a> Andrei Svetlov disse: ‚ÄúSe voc√™ deseja escrever algum tipo de aplicativo Web ass√≠ncrono, basta escrever em ass√≠ncrono, aguarde.  Event loop, provavelmente, voc√™ n√£o precisar√° disso em breve.  N√£o entre na natureza dos frameworks para n√£o ficar confuso.  N√£o use primitivas de baixo n√≠vel, e tudo ficar√° bem com voc√™ ... ".  Nos √∫ltimos tr√™s anos, infelizmente, tivemos que entrar no Tornado com bastante frequ√™ncia, aprender muitas coisas interessantes a partir da√≠ e ver tracebacks gigantes para chamadas de 30 a 40. <br><br><h2>  Rendimento vs rendimento de </h2><br>  Um dos maiores problemas para entender em python ass√≠ncrono √© a diferen√ßa entre rendimento de e rendimento. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Guido Van Rossum escreveu</a> mais sobre isso.  Estou anexando a tradu√ß√£o com pequenas abrevia√ß√µes. <br><blockquote>  J√° me perguntaram v√°rias vezes por que o PEP 3156 insiste em usar yield-from em vez de yield, o que exclui a possibilidade de backport no Python 3.2 ou mesmo 2.7. <br>  (...) <br>  sempre que voc√™ quiser um resultado futuro, use o rendimento. <br>  Isso √© implementado da seguinte maneira.  A fun√ß√£o que cont√©m yield √© (obviamente) um gerador, portanto deve haver algum tipo de c√≥digo iterativo.  Vamos cham√°-lo de planejador.  De fato, o planejador n√£o ‚Äúitera‚Äù no sentido cl√°ssico (com loop for);  em vez disso, ele suporta duas cole√ß√µes futuras. <br><br>  Vou chamar a primeira cole√ß√£o de uma sequ√™ncia "execut√°vel".  Este √© o futuro, cujos resultados est√£o dispon√≠veis.  Enquanto essa lista n√£o estiver vazia, o planejador seleciona um item e executa uma etapa da itera√ß√£o.  Esta etapa chama o m√©todo gerador .send () com o resultado do futuro (que pode ser dados que acabaram de ser lidos do soquete);  no gerador, esse resultado aparece como o valor de retorno da express√£o de rendimento.  Quando send () retorna um resultado ou √© conclu√≠do, o planejador analisa o resultado (que pode ser StopIteration, outra exce√ß√£o ou algum tipo de objeto). <br>  (Se voc√™ est√° confuso, provavelmente deveria ler sobre como os geradores funcionam, em particular o m√©todo .send (). Talvez o PEP 342 seja um bom ponto de partida). <br><br>  (...) <br><br>  a segunda cole√ß√£o futura suportada pelo planejador consiste no futuro, que ainda aguarda E / S.  Eles s√£o de alguma forma passados ‚Äã‚Äãpara o select / poll / shell etc.  que fornece um retorno de chamada quando o descritor de arquivo est√° pronto para E / S.  O retorno de chamada realmente executa a opera√ß√£o de E / S solicitada pelo futuro, define o valor futuro resultante para o resultado da opera√ß√£o de E / S e move o futuro para a fila de execu√ß√£o. <br><br>  (...) <br><br>  Agora chegamos ao mais interessante.  Suponha que voc√™ esteja escrevendo um protocolo complexo.  Dentro do seu protocolo, voc√™ l√™ bytes de um soquete usando o m√©todo recv ().  Esses bytes chegam ao buffer.  O m√©todo recv () √© envolvido em um shell ass√≠ncrono, que define a E / S e retorna o futuro, que √© executado quando a E / S √© conclu√≠da, como expliquei acima.  Agora, suponha que alguma outra parte do seu c√≥digo deseje ler dados do buffer, uma linha por vez.  Suponha que voc√™ tenha usado o m√©todo readline ().  Se o tamanho do buffer for maior que o comprimento m√©dio da linha, seu m√©todo readline () poder√° simplesmente obter a pr√≥xima linha do buffer sem bloquear;  mas √†s vezes o buffer n√£o cont√©m uma linha inteira, e o readline (), por sua vez, chama recv () no soquete. <br><br>  Pergunta: readline () deve retornar futuro ou n√£o?  N√£o seria muito bom se ele √†s vezes retornasse uma sequ√™ncia de bytes e, √†s vezes, futuro, for√ßando o chamador a executar verifica√ß√£o de tipo e rendimento condicional.  Portanto, a resposta √© que readline () deve sempre retornar o futuro.  Quando readline () √© chamado, ele verifica o buffer e, se encontrar pelo menos uma linha inteira, cria um futuro, define o resultado futuro de uma linha retirada do buffer e retorna futuro.  Se o buffer n√£o tiver uma linha inteira, ele iniciar√° a E / S e a esperar√° e, quando a E / S estiver conclu√≠da, ser√° iniciada novamente. <br><br>  (...) <br><br>  Mas agora estamos criando muitos futuros que n√£o exigem bloqueio de E / S, mas ainda for√ßam uma chamada ao agendador, porque readline () retorna o futuro, o rendimento √© necess√°rio ao chamador e isso significa uma chamada ao agendador. <br>  O planejador pode transferir o controle diretamente para a corotina se perceber que o futuro, que j√° foi conclu√≠do, √© exibido ou pode retornar o futuro √† fila de execu√ß√£o.  Este √∫ltimo desacelerar√° bastante o trabalho (desde que exista mais de uma corrotina execut√°vel), j√° que n√£o apenas a espera no final da fila √© necess√°ria, mas a localidade da mem√≥ria (se houver) provavelmente tamb√©m est√° perdida. <br><br>  (...) <br><br>  O efeito final de tudo isso √© que os autores da corotina precisam saber sobre o futuro da produ√ß√£o e, portanto, h√° uma barreira psicol√≥gica maior para reorganizar o c√≥digo complexo em corotinas mais leg√≠veis - muito mais fortes que a resist√™ncia existente, porque as chamadas de fun√ß√£o no Python s√£o muito lentas.  E lembro-me de uma conversa com a Glyph que a velocidade √© importante em uma estrutura de E / S ass√≠ncrona t√≠pica. <br>  Agora vamos comparar isso com yield-from. <br><br>  (...) <br><br>  Voc√™ deve ter ouvido falar que ‚Äúrendimento de S‚Äù √© aproximadamente equivalente a ‚Äúpara i em S: rendimento i‚Äù.  No caso mais simples, isso √© verdade, mas isso n√£o √© suficiente para entender a rotina.  Considere o seguinte (ainda n√£o pense em E / S ass√≠ncrona): <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">driver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(g)</span></span></span><span class="hljs-function">:</span></span> print(next(g)) g.send(<span class="hljs-number"><span class="hljs-number">42</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gen1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> val = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-string"><span class="hljs-string">'okay'</span></span> print(val) driver(gen1())</code> </pre> <br>  Esse c√≥digo imprime duas linhas contendo "okay" e "42" (e produz uma StopIteration sem tratamento, que voc√™ pode suprimir adicionando rendimento no final de gen1).  Voc√™ pode ver esse c√≥digo em a√ß√£o no pythontutor.com no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link</a> . <br><br>  Agora considere o seguinte: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gen2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gen1() driver(gen2())</code> </pre><br>  Funciona <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">exatamente da mesma maneira</a> .  Agora pense.  Como isso funciona?  A extens√£o simples de produ√ß√£o no loop for n√£o pode ser usada aqui, pois nesse caso o c√≥digo retornaria None.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">(Experimente)</a> .  O rendimento de atua como um "canal transparente" entre driver e gen1.  Ou seja, quando gen1 fornece o valor "ok", ele sai do gen2, atrav√©s do yield-from, para o driver, e quando o driver envia 42 de volta ao gen2, esse valor √© retornado novamente atrav√©s do yield-from para o gen1 novamente (onde se torna o resultado do yield ) <br><br>  O mesmo aconteceria se o motorista lan√ßasse um erro no gerador: o erro passa pelo rendimento do gerador interno que o processa.  Por exemplo: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throwing_driver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(g)</span></span></span><span class="hljs-function">:</span></span> print(next(g)) g.throw(RuntimeError(<span class="hljs-string"><span class="hljs-string">'booh'</span></span>)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gen1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: val = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-string"><span class="hljs-string">'okay'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> RuntimeError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> exc: print(exc) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: print(val) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> throwing_driver(gen1())</code> </pre><br>  O c√≥digo fornecer√° "okay" e "bah", al√©m do seguinte c√≥digo: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gen2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gen1() <span class="hljs-comment"><span class="hljs-comment"># unchanged throwing_driver(gen2())</span></span></code> </pre> <br>  (Veja aqui: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">goo.gl/8tnjk</a> ) <br><br>  Agora, eu gostaria de apresentar gr√°ficos simples (ASCII) para poder falar sobre esse tipo de c√≥digo.  Eu uso [f1 -&gt; f2 -&gt; ... -&gt; fN) para representar a pilha com f1 na parte inferior (quadro de chamada mais antiga) e fN na parte superior (quadro de chamada mais recente), onde cada item da lista √© um gerador e -&gt; s√£o rendimentos .  O primeiro exemplo, driver (gen1 ()), n√£o tem rendimento, mas possui um gerador gen1; portanto, √© parecido com isto: <br><br><pre> <code class="python hljs">[ gen1 )</code> </pre> <br>  No segundo exemplo, gen2 chama gen1 usando yield-from, ent√£o fica assim: <br><br><pre> <code class="python hljs">[ gen2 -&gt; gen1 )</code> </pre> <br>  Uso a nota√ß√£o matem√°tica para o intervalo semi-aberto [...] para mostrar que outro quadro pode ser adicionado √† direita quando o gerador mais √† direita usa yield-from para chamar outro gerador, enquanto a extremidade esquerda √© mais ou menos fixa.  O final esquerdo √© o que o motorista v√™ (ou seja, o agendador). <br><br>  Agora estou pronto para retornar ao exemplo readline ().  Podemos reescrever o readline () como um gerador que chama read (), outro gerador usando yield-from;  o √∫ltimo, por sua vez, chama recv (), que faz a entrada / sa√≠da real do soquete.  √Ä nossa esquerda est√° o aplicativo, que tamb√©m consideramos um gerador que chama readline (), novamente usando yield-from.  O esquema √© o seguinte: <br><br><pre> <code class="python hljs">[ app -&gt; readline -&gt; read -&gt; recv )</code> </pre> <br>  Agora, o gerador recv () define E / S, liga-o ao futuro e o passa para o planejador usando * yield * (n√£o yield-from!).  O futuro vai para a esquerda, ao longo das duas setas de retorno do agendador (localizado √† esquerda de "[").  Observe que o planejador n√£o sabe que cont√©m uma pilha de geradores;  tudo o que sabe √© que ele cont√©m o gerador mais √† esquerda e que acaba de lan√ßar um futuro.  Quando a E / S √© conclu√≠da, o planejador define o resultado futuro e o envia de volta ao gerador;  o resultado se move para a direita, ao longo das duas flechas "Yiled-from" para o gerador de recv, que recebe os bytes que deseja ler do soquete como resultado da produ√ß√£o. <br><br>  Em outras palavras, o planejador de estrutura yield-from manipula opera√ß√µes de E / S, exatamente como o planejador de estrutura baseado em rendimento que eu descrevi anteriormente.  * Mas: * ele n√£o precisa se preocupar com otimiza√ß√£o quando o futuro j√° estiver executado, pois o planejador n√£o participa da transfer√™ncia de controle entre readline () e read () ou entre read () e recv () e vice-versa.  Portanto, o planejador n√£o participa quando o aplicativo () chama readline () e readline () pode atender √† solicita√ß√£o do buffer (sem chamar read ()) - a intera√ß√£o entre app () e readline () nesse caso √© completamente processada pelo interpretador de bytecode Python  O planejador pode ser mais simples, e o n√∫mero de futuros criados e gerenciados pelo planejador √© menor, porque n√£o existem futuros criados e destru√≠dos a cada chamada de corotina.  O √∫nico futuro que ainda √© necess√°rio s√£o aqueles que representam a E / S real, por exemplo, criada por recv (). <br><br>  Se voc√™ leu at√© este ponto, merece uma recompensa.  Omiti muitos detalhes da implementa√ß√£o, mas a ilustra√ß√£o acima reflete corretamente a imagem. <br><br>  Outra coisa que eu gostaria de destacar.  * Voc√™ pode * fazer parte do c√≥digo usar yield-from e a outra parte usar yield.  Mas o rendimento exige que todo elo da cadeia tenha um futuro, n√£o apenas uma rotina.  Como existem v√°rias vantagens em usar o yield-from, desejo que o usu√°rio n√£o precise se lembrar de quando usar yield e, quando yield-from, √© mais f√°cil sempre usar o yield-from.  Uma solu√ß√£o simples ainda permite que recv () use yield-from para passar E / S futuras para o planejador: o m√©todo __iter__ √© realmente o gerador que o futuro emite. <br><br>  (...) <br><br>  E mais uma coisa.  Qual valor o retorno de retorno?  Acontece que este √© o valor de retorno do gerador * externo *. <br><br>  (...) <br><br>  Assim, embora as setas vinculem os quadros esquerdo e direito ao destino * produtivo *, eles tamb√©m passam os valores de retorno usuais da maneira usual, um quadro de pilha por vez.  Exce√ß√µes s√£o movidas da mesma maneira;  √© claro que, em cada n√≠vel, √© necess√°rio tentar / exceto para captur√°-los. <br></blockquote>  Acontece que o rendimento √© praticamente o mesmo que aguardar. <br><br><h2>  rendimento de vs ass√≠ncrono </h2><br><table><tbody><tr><td><p>  def coro () ^ </p><p>  y = rendimento de um </p></td><td>  async def async_coro (): <p>  y = aguarde um </p></td></tr><tr><td>  0 load_global </td><td>  0 load_global </td></tr><tr><td>  2 get_yield_from_iter </td><td><p>  2 get_awaitable </p></td></tr><tr><td>  4 load_const </td><td><p>  4 load_const </p></td></tr><tr><td>  6 rendimento_de </td><td>  6 rendimento_de </td></tr><tr><td>  8 store_fast </td><td><p>  8 store_fast </p></td></tr><tr><td>  10 load_const </td><td>  10 load_const <br></td></tr><tr><td>  12 return_value </td><td>  12 return_value </td></tr></tbody></table><br><br>  As duas corotinas das antigas e das novas escolas t√™m apenas uma pequena diferen√ßa: obter rendimento do iter versus esperar. <br><br>  Por que isso √© tudo?  Tornado usa um rendimento simples.  Antes da vers√£o 5, ele conecta toda essa cadeia de chamadas atrav√©s de rendimento, que √© pouco compat√≠vel com o novo rendimento legal do paradigma / aguarda. <br><br><h2>  O benchmark ass√≠ncrono mais simples </h2><br>  √â dif√≠cil encontrar uma estrutura realmente boa, escolhendo-a apenas de acordo com testes sint√©ticos.  Na vida real, muitas coisas podem dar errado. <br><br>  Peguei o Aiohttp vers√£o 3.4.4, Tornado 5.1.1, uvloop 0.11, peguei o processador do servidor Intel Xeon, CPU E5 v4, 3.6 GHz, e nele com o Python 3.6.5 comecei a verificar a competitividade dos servidores web. <br><br>  O problema t√≠pico que resolvemos com a ajuda de microsservi√ßos e que funciona no modo ass√≠ncrono √© semelhante a este.  N√≥s receberemos pedidos.  Para cada um deles, faremos uma solicita√ß√£o para algum microsservi√ßo, obteremos os dados a partir da√≠, acessaremos outros dois ou tr√™s microsservi√ßos, tamb√©m de forma ass√≠ncrona, em seguida, gravaremos os dados em algum lugar no banco de dados e retornaremos o resultado.  Acontece muitos pontos em que vamos esperar. <br><br>  Realizamos uma opera√ß√£o mais simples.  Ligamos o servidor, dormimos 50 ms.  Crie uma rotina e complete-a.  N√£o teremos um RPS muito grande (pode n√£o ser uma ordem de magnitude semelhante √† que √© vista em benchmarks totalmente sint√©ticos) com um atraso aceit√°vel, devido ao fato de que muitas corotinas girar√£o simultaneamente em um servidor competitivo. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@tornado.gen.coroutine def old_school_work(): yield tornado.gen.sleep(SLEEP_TIME) async def work(): await tornado.gen.sleep(SLEEP_TIME)</span></span></code> </pre> <br>  Carregar - GET solicita√ß√µes http.  Dura√ß√£o - 300s, 1s - aquecimento, 5 repeti√ß√µes da carga. <br><br><img src="https://habrastorage.org/webt/ep/mq/fw/epmqfwh6bv_vyfu8tymtelvohos.png"><br><br>  <i>Resultados em percentis de tempo de resposta do servi√ßo.</i> <br><br><div class="spoiler">  <b class="spoiler_title">O que s√£o percentis?</b> <div class="spoiler_text">  Voc√™ tem um grande n√∫mero de n√∫meros.  O 95¬∫ percentil X significa que 95% dos valores nesta amostra s√£o menores que X. Com uma probabilidade de 5%, seu n√∫mero ser√° maior que X. <br></div></div><br>  Vimos que o Aiohttp fez um bom trabalho a 1000 RPS em um teste t√£o simples.  Tudo at√© agora sem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uvloop</a> . <br><br>  Compare Tornado com as corotinas das escolas antigas (rendimento) e novas (ass√≠ncronas).  Os autores recomendam fortemente o uso ass√≠ncrono.  Podemos garantir que eles sejam realmente muito mais r√°pidos. <br><br>  A 1200 RPS, o Tornado, mesmo com as novas corotinas da escola, j√° est√° come√ßando a desistir, e o Tornado com as corotinas da velha escola est√° completamente deslumbrado.  Se dormimos por 50 ms, e o microsservi√ßo √© respons√°vel por 80 ms - isso n√£o entra em nenhuma porta. <br><br>  A nova escola do Tornado, com 1.500 RPS, desistiu completamente, enquanto o Aiohttp ainda est√° longe do limite de 3.000 RPS.  O mais interessante ainda est√° por vir. <br><br><h2>  Pyflame, criando um perfil de microsservi√ßo em funcionamento </h2><br>  Vamos ver o que est√° acontecendo neste momento com o processador. <br><br><img src="https://habrastorage.org/webt/mw/-6/c-/mw-6c-vzw_kk-flygqeig93qohe.png"><br><br>  Quando descobrimos como os microsservi√ßos ass√≠ncronos do Python funcionam na produ√ß√£o, tentamos entender o que isso significava.  Na maioria dos casos, o problema estava na CPU ou nos descritores.  Existe uma excelente ferramenta de cria√ß√£o de perfil criada no Uber, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">criador de</a> perfil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pyflame</a> , que √© baseado na chamada do sistema ptrace. <br><br>  Iniciamos algum servi√ßo no cont√™iner e come√ßamos a lan√ßar uma carga de combate nele.  Freq√ºentemente, essa n√£o √© uma tarefa muito trivial - criar exatamente uma carga que est√° em batalha, porque geralmente acontece que voc√™ executa testes sint√©ticos em testes de carga, olha e tudo funciona bem.  Voc√™ empurra a carga de combate contra ele, e aqui o microsservi√ßo come√ßa a embotar. <br><br>  Durante a opera√ß√£o, esse criador de perfil faz instant√¢neos da pilha de chamadas para n√≥s.  Voc√™ n√£o pode alterar o servi√ßo, basta executar o pyflame nas proximidades.  Ele coletar√° um rastreamento de pilha uma vez em um determinado per√≠odo de tempo e, em seguida, far√° uma visualiza√ß√£o interessante.  Esse criador de perfil fornece muito pouca sobrecarga, especialmente quando comparado ao cProfile.  O Pyflame tamb√©m suporta programas multithread.  Lan√ßamos essa coisa diretamente no produto, e o desempenho n√£o diminuiu muito. <br><br><img src="https://habrastorage.org/webt/pk/2s/lu/pk2slutzgqe-szo4mbefnk_zoqe.png"><br><br>  Aqui, o eixo X √© a quantidade de tempo, o n√∫mero de chamadas, quando o quadro de pilha estava na lista de todos os quadros de pilha Python.  Essa √© a quantidade aproximada de tempo do processador que gastamos nesse quadro espec√≠fico da pilha. <br><br>  Como voc√™ pode ver, aqui a maior parte do tempo no aiohttp fica ocioso.  Tudo bem: √© isso que queremos de um servi√ßo ass√≠ncrono, para que ele lide com chamadas de rede na maioria das vezes.  A profundidade da pilha neste caso √© de cerca de 15 quadros. <br><br>  No Tornado (segunda imagem) com a mesma carga, gasta-se muito menos tempo no modo inativo e a profundidade da pilha nesse caso √© de cerca de 30 quadros. <br><br>  Aqui est√° um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link para svg</a> , voc√™ pode se torcer. <br><br><h2>  Refer√™ncia ass√≠ncrona mais complexa </h2><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#     await asyncio.sleep(SLEEP_TIME) class HardWorkHandler(tornado.web.RequestHandler): timeout_time = datetime.timedelta(seconds=SLEEP_TIME / 2) async def get(self): await work() #     await tornado.gen.multi([work(), work()]) #     try: await tornado.gen.with_timeout(self.timeout_time, work()) except tornado.util.TimeoutError: #     pass</span></span></code> </pre><br>  Espere um tempo de execu√ß√£o de 125 ms. <br><br><img src="https://habrastorage.org/webt/i2/u5/3d/i2u53d-v1qhpmgkqiifa6q8rita.png"><br><br>  Tornado com uvloop aguenta-se melhor.  Mas o Aiohttp uvloop ajuda muito mais.  O Aiohttp come√ßa a se comportar mal em 2300-2400 RPS e, com o uvloop, expande significativamente a faixa de carga.  Uma linha de importa√ß√£o e agora voc√™ tem um servi√ßo muito mais produtivo. <br><br><h2>  Sum√°rio </h2><br>  Resumirei o que queria transmitir a voc√™ hoje. <br><br><ul><li>  Em primeiro lugar, lancei um determinado par√¢metro de refer√™ncia artificial, onde havia uma quantidade decente de longa rotina.  Em nosso teste, o Aiohttp teve um desempenho melhor 2,5 vezes do que o Tornado. </li><li>  O segundo fato.  O Uvloop ajuda muito a melhorar o desempenho do Aiohttp (melhor que o Tornado). </li><li>  Eu falei sobre o Pyflame, com o qual frequentemente perfilamos o aplicativo diretamente na produ√ß√£o. </li><li>  E tamb√©m falamos sobre rendimento de (aguardar) versus rendimento. </li></ul><br>  Como resultado desses benchmarks, nossa equipe de recomenda√ß√µes (e algumas outras) quase mudou completamente para Aiohttp with Tornado para microsservi√ßos em Python em produ√ß√£o. <br><br><ul><li>  Para servi√ßos de combate, o consumo de CPU caiu mais de 2 vezes. </li><li>  Come√ßamos a respeitar o tempo limite para solicita√ß√µes de http. </li><li>  Os servi√ßos de lat√™ncia ca√≠ram 2 a 5 vezes. </li></ul><br>  Aqui est√° um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link para o benchmark</a> .  Se estiver interessado, voc√™ pode repeti-lo.  Obrigado a todos pela aten√ß√£o.  Fa√ßa perguntas, tentarei respond√™-las. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt435532/">https://habr.com/ru/post/pt435532/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt435520/index.html">N√≥s escrevemos nossa linguagem de programa√ß√£o, parte 3: Arquitetura do tradutor. An√°lise de estruturas de linguagem e express√µes matem√°ticas</a></li>
<li><a href="../pt435522/index.html">Instant√¢neos de eventos no Axonframework 3, melhorando o desempenho</a></li>
<li><a href="../pt435526/index.html">Aventuras com um cluster Kubernetes em casa</a></li>
<li><a href="../pt435528/index.html">5 raz√µes para o sucesso: por que a Amazon se tornou a empresa mais cara do mundo</a></li>
<li><a href="../pt435530/index.html">Assinaturas pagas - Depend√™ncia da conex√£o autom√°tica em um dispositivo m√≥vel</a></li>
<li><a href="../pt435534/index.html">Ci√™ncia de dados: livros b√°sicos</a></li>
<li><a href="../pt435536/index.html">Rob√¥s human√≥ides: benef√≠cios e problemas de mecanismos antropom√≥rficos</a></li>
<li><a href="../pt435538/index.html">Em 2018, mais energia "verde" foi recebida na Alemanha do que eletricidade proveniente da combust√£o de carv√£o</a></li>
<li><a href="../pt435540/index.html">Novas palavras-chave em Java</a></li>
<li><a href="../pt435542/index.html">Desenvolvimento de jogos e defesa de um diploma ou "Como matei dois coelhos com uma panqueca de uma cajadada s√≥"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>