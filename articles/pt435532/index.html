<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕴🏾 👨🏽‍🌾 👞 Tornado vs Aiohttp: uma jornada pela natureza de estruturas assíncronas 🥌 📵 🤜🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Oi Eu sou Dima e estou sentado em Python há algum tempo. Hoje, quero mostrar as diferenças entre duas estruturas assíncronas - Tornado e Aiohttp. Vou ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tornado vs Aiohttp: uma jornada pela natureza de estruturas assíncronas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/avito/blog/435532/">  Oi  Eu sou Dima e estou sentado em Python há algum tempo.  Hoje, quero mostrar as diferenças entre duas estruturas assíncronas - Tornado e Aiohttp.  Vou contar a história da escolha entre as estruturas do nosso projeto, como as corotinas do Tornado e do AsyncIO diferem. Mostrarei benchmarks e darei algumas dicas úteis sobre como entrar na natureza das estruturas e sair com êxito. <br><br><img src="https://habrastorage.org/webt/df/uz/jm/dfuzjmbmzyoqjfd87asllltamtk.png"><br><a name="habracut"></a><br>  Como você sabe, o Avito é um serviço de anúncios bastante grande.  Temos muitos dados e carga, 35 milhões de usuários todos os meses e 45 milhões de anúncios ativos diariamente.  Trabalho como consultor técnico de um grupo de desenvolvimento de recomendações.  Minha equipe escreve microsserviços, agora temos cerca de vinte deles.  Uma carga está acumulando tudo isso - como 5k RPS. <br><br><h2>  Escolhendo uma estrutura assíncrona </h2><br>  Primeiro, vou contar como acabamos onde estamos agora.  Em 2015, precisávamos escolher uma estrutura assíncrona, porque sabíamos: <br><br><ul><li>  que você precisa fazer muitas solicitações para outros microsserviços: http, json, rpc; </li><li>  que você precisará coletar dados de diferentes fontes o tempo todo: Redis, Postgres, MongoDB. </li></ul><br>  Assim, temos muitas tarefas de rede e o aplicativo é ocupado principalmente com entrada / saída.  A versão atual do python na época era 3.4, assíncrona e aguardada ainda não apareceu.  Aiohttp também estava - na versão 0.x.  O Tornado Assíncrono do Facebook apareceu em 2010.  Muitos drivers de banco de dados foram escritos para ele que precisamos.  O Tornado apresentou resultados estáveis ​​nos benchmarks.  Então paramos a nossa escolha nesse quadro. <br><br>  Três anos depois, entendemos muito. <br><br>  Primeiro, o Python 3.5 foi lançado com mecânica assíncrona / aguardada.  Nós descobrimos qual é a diferença entre rendimento e rendimento e como o Tornado é consistente com aguardar (spoiler: não muito bom). <br>  Em segundo lugar, encontramos problemas estranhos de desempenho com uma grande quantidade de corotina no agendador, mesmo quando a CPU não está totalmente ocupada. <br>  Em terceiro lugar, descobrimos que, ao executar um grande número de solicitações HTTP para outros serviços Tornado, você precisa ser especialmente amigável com o resolvedor de DNS assíncrono, ele não respeita os tempos limite para estabelecer uma conexão e enviar a solicitação que especificamos.  E, em geral, o melhor método para fazer solicitações HTTP no Tornado é o curl, o que é bastante estranho por si só. <br><br>  Em sua <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">palestra na PyCon Russia 2018,</a> Andrei Svetlov disse: “Se você deseja escrever algum tipo de aplicativo Web assíncrono, basta escrever em assíncrono, aguarde.  Event loop, provavelmente, você não precisará disso em breve.  Não entre na natureza dos frameworks para não ficar confuso.  Não use primitivas de baixo nível, e tudo ficará bem com você ... ".  Nos últimos três anos, infelizmente, tivemos que entrar no Tornado com bastante frequência, aprender muitas coisas interessantes a partir daí e ver tracebacks gigantes para chamadas de 30 a 40. <br><br><h2>  Rendimento vs rendimento de </h2><br>  Um dos maiores problemas para entender em python assíncrono é a diferença entre rendimento de e rendimento. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Guido Van Rossum escreveu</a> mais sobre isso.  Estou anexando a tradução com pequenas abreviações. <br><blockquote>  Já me perguntaram várias vezes por que o PEP 3156 insiste em usar yield-from em vez de yield, o que exclui a possibilidade de backport no Python 3.2 ou mesmo 2.7. <br>  (...) <br>  sempre que você quiser um resultado futuro, use o rendimento. <br>  Isso é implementado da seguinte maneira.  A função que contém yield é (obviamente) um gerador, portanto deve haver algum tipo de código iterativo.  Vamos chamá-lo de planejador.  De fato, o planejador não “itera” no sentido clássico (com loop for);  em vez disso, ele suporta duas coleções futuras. <br><br>  Vou chamar a primeira coleção de uma sequência "executável".  Este é o futuro, cujos resultados estão disponíveis.  Enquanto essa lista não estiver vazia, o planejador seleciona um item e executa uma etapa da iteração.  Esta etapa chama o método gerador .send () com o resultado do futuro (que pode ser dados que acabaram de ser lidos do soquete);  no gerador, esse resultado aparece como o valor de retorno da expressão de rendimento.  Quando send () retorna um resultado ou é concluído, o planejador analisa o resultado (que pode ser StopIteration, outra exceção ou algum tipo de objeto). <br>  (Se você está confuso, provavelmente deveria ler sobre como os geradores funcionam, em particular o método .send (). Talvez o PEP 342 seja um bom ponto de partida). <br><br>  (...) <br><br>  a segunda coleção futura suportada pelo planejador consiste no futuro, que ainda aguarda E / S.  Eles são de alguma forma passados ​​para o select / poll / shell etc.  que fornece um retorno de chamada quando o descritor de arquivo está pronto para E / S.  O retorno de chamada realmente executa a operação de E / S solicitada pelo futuro, define o valor futuro resultante para o resultado da operação de E / S e move o futuro para a fila de execução. <br><br>  (...) <br><br>  Agora chegamos ao mais interessante.  Suponha que você esteja escrevendo um protocolo complexo.  Dentro do seu protocolo, você lê bytes de um soquete usando o método recv ().  Esses bytes chegam ao buffer.  O método recv () é envolvido em um shell assíncrono, que define a E / S e retorna o futuro, que é executado quando a E / S é concluída, como expliquei acima.  Agora, suponha que alguma outra parte do seu código deseje ler dados do buffer, uma linha por vez.  Suponha que você tenha usado o método readline ().  Se o tamanho do buffer for maior que o comprimento médio da linha, seu método readline () poderá simplesmente obter a próxima linha do buffer sem bloquear;  mas às vezes o buffer não contém uma linha inteira, e o readline (), por sua vez, chama recv () no soquete. <br><br>  Pergunta: readline () deve retornar futuro ou não?  Não seria muito bom se ele às vezes retornasse uma sequência de bytes e, às vezes, futuro, forçando o chamador a executar verificação de tipo e rendimento condicional.  Portanto, a resposta é que readline () deve sempre retornar o futuro.  Quando readline () é chamado, ele verifica o buffer e, se encontrar pelo menos uma linha inteira, cria um futuro, define o resultado futuro de uma linha retirada do buffer e retorna futuro.  Se o buffer não tiver uma linha inteira, ele iniciará a E / S e a esperará e, quando a E / S estiver concluída, será iniciada novamente. <br><br>  (...) <br><br>  Mas agora estamos criando muitos futuros que não exigem bloqueio de E / S, mas ainda forçam uma chamada ao agendador, porque readline () retorna o futuro, o rendimento é necessário ao chamador e isso significa uma chamada ao agendador. <br>  O planejador pode transferir o controle diretamente para a corotina se perceber que o futuro, que já foi concluído, é exibido ou pode retornar o futuro à fila de execução.  Este último desacelerará bastante o trabalho (desde que exista mais de uma corrotina executável), já que não apenas a espera no final da fila é necessária, mas a localidade da memória (se houver) provavelmente também está perdida. <br><br>  (...) <br><br>  O efeito final de tudo isso é que os autores da corotina precisam saber sobre o futuro da produção e, portanto, há uma barreira psicológica maior para reorganizar o código complexo em corotinas mais legíveis - muito mais fortes que a resistência existente, porque as chamadas de função no Python são muito lentas.  E lembro-me de uma conversa com a Glyph que a velocidade é importante em uma estrutura de E / S assíncrona típica. <br>  Agora vamos comparar isso com yield-from. <br><br>  (...) <br><br>  Você deve ter ouvido falar que “rendimento de S” é aproximadamente equivalente a “para i em S: rendimento i”.  No caso mais simples, isso é verdade, mas isso não é suficiente para entender a rotina.  Considere o seguinte (ainda não pense em E / S assíncrona): <br><br><pre><code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">driver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(g)</span></span></span><span class="hljs-function">:</span></span> print(next(g)) g.send(<span class="hljs-number"><span class="hljs-number">42</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gen1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> val = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-string"><span class="hljs-string">'okay'</span></span> print(val) driver(gen1())</code> </pre> <br>  Esse código imprime duas linhas contendo "okay" e "42" (e produz uma StopIteration sem tratamento, que você pode suprimir adicionando rendimento no final de gen1).  Você pode ver esse código em ação no pythontutor.com no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link</a> . <br><br>  Agora considere o seguinte: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gen2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gen1() driver(gen2())</code> </pre><br>  Funciona <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">exatamente da mesma maneira</a> .  Agora pense.  Como isso funciona?  A extensão simples de produção no loop for não pode ser usada aqui, pois nesse caso o código retornaria None.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">(Experimente)</a> .  O rendimento de atua como um "canal transparente" entre driver e gen1.  Ou seja, quando gen1 fornece o valor "ok", ele sai do gen2, através do yield-from, para o driver, e quando o driver envia 42 de volta ao gen2, esse valor é retornado novamente através do yield-from para o gen1 novamente (onde se torna o resultado do yield ) <br><br>  O mesmo aconteceria se o motorista lançasse um erro no gerador: o erro passa pelo rendimento do gerador interno que o processa.  Por exemplo: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">throwing_driver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(g)</span></span></span><span class="hljs-function">:</span></span> print(next(g)) g.throw(RuntimeError(<span class="hljs-string"><span class="hljs-string">'booh'</span></span>)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gen1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: val = <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-string"><span class="hljs-string">'okay'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> RuntimeError <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> exc: print(exc) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: print(val) <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> throwing_driver(gen1())</code> </pre><br>  O código fornecerá "okay" e "bah", além do seguinte código: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gen2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> gen1() <span class="hljs-comment"><span class="hljs-comment"># unchanged throwing_driver(gen2())</span></span></code> </pre> <br>  (Veja aqui: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">goo.gl/8tnjk</a> ) <br><br>  Agora, eu gostaria de apresentar gráficos simples (ASCII) para poder falar sobre esse tipo de código.  Eu uso [f1 -&gt; f2 -&gt; ... -&gt; fN) para representar a pilha com f1 na parte inferior (quadro de chamada mais antiga) e fN na parte superior (quadro de chamada mais recente), onde cada item da lista é um gerador e -&gt; são rendimentos .  O primeiro exemplo, driver (gen1 ()), não tem rendimento, mas possui um gerador gen1; portanto, é parecido com isto: <br><br><pre> <code class="python hljs">[ gen1 )</code> </pre> <br>  No segundo exemplo, gen2 chama gen1 usando yield-from, então fica assim: <br><br><pre> <code class="python hljs">[ gen2 -&gt; gen1 )</code> </pre> <br>  Uso a notação matemática para o intervalo semi-aberto [...] para mostrar que outro quadro pode ser adicionado à direita quando o gerador mais à direita usa yield-from para chamar outro gerador, enquanto a extremidade esquerda é mais ou menos fixa.  O final esquerdo é o que o motorista vê (ou seja, o agendador). <br><br>  Agora estou pronto para retornar ao exemplo readline ().  Podemos reescrever o readline () como um gerador que chama read (), outro gerador usando yield-from;  o último, por sua vez, chama recv (), que faz a entrada / saída real do soquete.  À nossa esquerda está o aplicativo, que também consideramos um gerador que chama readline (), novamente usando yield-from.  O esquema é o seguinte: <br><br><pre> <code class="python hljs">[ app -&gt; readline -&gt; read -&gt; recv )</code> </pre> <br>  Agora, o gerador recv () define E / S, liga-o ao futuro e o passa para o planejador usando * yield * (não yield-from!).  O futuro vai para a esquerda, ao longo das duas setas de retorno do agendador (localizado à esquerda de "[").  Observe que o planejador não sabe que contém uma pilha de geradores;  tudo o que sabe é que ele contém o gerador mais à esquerda e que acaba de lançar um futuro.  Quando a E / S é concluída, o planejador define o resultado futuro e o envia de volta ao gerador;  o resultado se move para a direita, ao longo das duas flechas "Yiled-from" para o gerador de recv, que recebe os bytes que deseja ler do soquete como resultado da produção. <br><br>  Em outras palavras, o planejador de estrutura yield-from manipula operações de E / S, exatamente como o planejador de estrutura baseado em rendimento que eu descrevi anteriormente.  * Mas: * ele não precisa se preocupar com otimização quando o futuro já estiver executado, pois o planejador não participa da transferência de controle entre readline () e read () ou entre read () e recv () e vice-versa.  Portanto, o planejador não participa quando o aplicativo () chama readline () e readline () pode atender à solicitação do buffer (sem chamar read ()) - a interação entre app () e readline () nesse caso é completamente processada pelo interpretador de bytecode Python  O planejador pode ser mais simples, e o número de futuros criados e gerenciados pelo planejador é menor, porque não existem futuros criados e destruídos a cada chamada de corotina.  O único futuro que ainda é necessário são aqueles que representam a E / S real, por exemplo, criada por recv (). <br><br>  Se você leu até este ponto, merece uma recompensa.  Omiti muitos detalhes da implementação, mas a ilustração acima reflete corretamente a imagem. <br><br>  Outra coisa que eu gostaria de destacar.  * Você pode * fazer parte do código usar yield-from e a outra parte usar yield.  Mas o rendimento exige que todo elo da cadeia tenha um futuro, não apenas uma rotina.  Como existem várias vantagens em usar o yield-from, desejo que o usuário não precise se lembrar de quando usar yield e, quando yield-from, é mais fácil sempre usar o yield-from.  Uma solução simples ainda permite que recv () use yield-from para passar E / S futuras para o planejador: o método __iter__ é realmente o gerador que o futuro emite. <br><br>  (...) <br><br>  E mais uma coisa.  Qual valor o retorno de retorno?  Acontece que este é o valor de retorno do gerador * externo *. <br><br>  (...) <br><br>  Assim, embora as setas vinculem os quadros esquerdo e direito ao destino * produtivo *, eles também passam os valores de retorno usuais da maneira usual, um quadro de pilha por vez.  Exceções são movidas da mesma maneira;  é claro que, em cada nível, é necessário tentar / exceto para capturá-los. <br></blockquote>  Acontece que o rendimento é praticamente o mesmo que aguardar. <br><br><h2>  rendimento de vs assíncrono </h2><br><table><tbody><tr><td><p>  def coro () ^ </p><p>  y = rendimento de um </p></td><td>  async def async_coro (): <p>  y = aguarde um </p></td></tr><tr><td>  0 load_global </td><td>  0 load_global </td></tr><tr><td>  2 get_yield_from_iter </td><td><p>  2 get_awaitable </p></td></tr><tr><td>  4 load_const </td><td><p>  4 load_const </p></td></tr><tr><td>  6 rendimento_de </td><td>  6 rendimento_de </td></tr><tr><td>  8 store_fast </td><td><p>  8 store_fast </p></td></tr><tr><td>  10 load_const </td><td>  10 load_const <br></td></tr><tr><td>  12 return_value </td><td>  12 return_value </td></tr></tbody></table><br><br>  As duas corotinas das antigas e das novas escolas têm apenas uma pequena diferença: obter rendimento do iter versus esperar. <br><br>  Por que isso é tudo?  Tornado usa um rendimento simples.  Antes da versão 5, ele conecta toda essa cadeia de chamadas através de rendimento, que é pouco compatível com o novo rendimento legal do paradigma / aguarda. <br><br><h2>  O benchmark assíncrono mais simples </h2><br>  É difícil encontrar uma estrutura realmente boa, escolhendo-a apenas de acordo com testes sintéticos.  Na vida real, muitas coisas podem dar errado. <br><br>  Peguei o Aiohttp versão 3.4.4, Tornado 5.1.1, uvloop 0.11, peguei o processador do servidor Intel Xeon, CPU E5 v4, 3.6 GHz, e nele com o Python 3.6.5 comecei a verificar a competitividade dos servidores web. <br><br>  O problema típico que resolvemos com a ajuda de microsserviços e que funciona no modo assíncrono é semelhante a este.  Nós receberemos pedidos.  Para cada um deles, faremos uma solicitação para algum microsserviço, obteremos os dados a partir daí, acessaremos outros dois ou três microsserviços, também de forma assíncrona, em seguida, gravaremos os dados em algum lugar no banco de dados e retornaremos o resultado.  Acontece muitos pontos em que vamos esperar. <br><br>  Realizamos uma operação mais simples.  Ligamos o servidor, dormimos 50 ms.  Crie uma rotina e complete-a.  Não teremos um RPS muito grande (pode não ser uma ordem de magnitude semelhante à que é vista em benchmarks totalmente sintéticos) com um atraso aceitável, devido ao fato de que muitas corotinas girarão simultaneamente em um servidor competitivo. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@tornado.gen.coroutine def old_school_work(): yield tornado.gen.sleep(SLEEP_TIME) async def work(): await tornado.gen.sleep(SLEEP_TIME)</span></span></code> </pre> <br>  Carregar - GET solicitações http.  Duração - 300s, 1s - aquecimento, 5 repetições da carga. <br><br><img src="https://habrastorage.org/webt/ep/mq/fw/epmqfwh6bv_vyfu8tymtelvohos.png"><br><br>  <i>Resultados em percentis de tempo de resposta do serviço.</i> <br><br><div class="spoiler">  <b class="spoiler_title">O que são percentis?</b> <div class="spoiler_text">  Você tem um grande número de números.  O 95º percentil X significa que 95% dos valores nesta amostra são menores que X. Com uma probabilidade de 5%, seu número será maior que X. <br></div></div><br>  Vimos que o Aiohttp fez um bom trabalho a 1000 RPS em um teste tão simples.  Tudo até agora sem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uvloop</a> . <br><br>  Compare Tornado com as corotinas das escolas antigas (rendimento) e novas (assíncronas).  Os autores recomendam fortemente o uso assíncrono.  Podemos garantir que eles sejam realmente muito mais rápidos. <br><br>  A 1200 RPS, o Tornado, mesmo com as novas corotinas da escola, já está começando a desistir, e o Tornado com as corotinas da velha escola está completamente deslumbrado.  Se dormimos por 50 ms, e o microsserviço é responsável por 80 ms - isso não entra em nenhuma porta. <br><br>  A nova escola do Tornado, com 1.500 RPS, desistiu completamente, enquanto o Aiohttp ainda está longe do limite de 3.000 RPS.  O mais interessante ainda está por vir. <br><br><h2>  Pyflame, criando um perfil de microsserviço em funcionamento </h2><br>  Vamos ver o que está acontecendo neste momento com o processador. <br><br><img src="https://habrastorage.org/webt/mw/-6/c-/mw-6c-vzw_kk-flygqeig93qohe.png"><br><br>  Quando descobrimos como os microsserviços assíncronos do Python funcionam na produção, tentamos entender o que isso significava.  Na maioria dos casos, o problema estava na CPU ou nos descritores.  Existe uma excelente ferramenta de criação de perfil criada no Uber, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">criador de</a> perfil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pyflame</a> , que é baseado na chamada do sistema ptrace. <br><br>  Iniciamos algum serviço no contêiner e começamos a lançar uma carga de combate nele.  Freqüentemente, essa não é uma tarefa muito trivial - criar exatamente uma carga que está em batalha, porque geralmente acontece que você executa testes sintéticos em testes de carga, olha e tudo funciona bem.  Você empurra a carga de combate contra ele, e aqui o microsserviço começa a embotar. <br><br>  Durante a operação, esse criador de perfil faz instantâneos da pilha de chamadas para nós.  Você não pode alterar o serviço, basta executar o pyflame nas proximidades.  Ele coletará um rastreamento de pilha uma vez em um determinado período de tempo e, em seguida, fará uma visualização interessante.  Esse criador de perfil fornece muito pouca sobrecarga, especialmente quando comparado ao cProfile.  O Pyflame também suporta programas multithread.  Lançamos essa coisa diretamente no produto, e o desempenho não diminuiu muito. <br><br><img src="https://habrastorage.org/webt/pk/2s/lu/pk2slutzgqe-szo4mbefnk_zoqe.png"><br><br>  Aqui, o eixo X é a quantidade de tempo, o número de chamadas, quando o quadro de pilha estava na lista de todos os quadros de pilha Python.  Essa é a quantidade aproximada de tempo do processador que gastamos nesse quadro específico da pilha. <br><br>  Como você pode ver, aqui a maior parte do tempo no aiohttp fica ocioso.  Tudo bem: é isso que queremos de um serviço assíncrono, para que ele lide com chamadas de rede na maioria das vezes.  A profundidade da pilha neste caso é de cerca de 15 quadros. <br><br>  No Tornado (segunda imagem) com a mesma carga, gasta-se muito menos tempo no modo inativo e a profundidade da pilha nesse caso é de cerca de 30 quadros. <br><br>  Aqui está um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link para svg</a> , você pode se torcer. <br><br><h2>  Referência assíncrona mais complexa </h2><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">work</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#     await asyncio.sleep(SLEEP_TIME) class HardWorkHandler(tornado.web.RequestHandler): timeout_time = datetime.timedelta(seconds=SLEEP_TIME / 2) async def get(self): await work() #     await tornado.gen.multi([work(), work()]) #     try: await tornado.gen.with_timeout(self.timeout_time, work()) except tornado.util.TimeoutError: #     pass</span></span></code> </pre><br>  Espere um tempo de execução de 125 ms. <br><br><img src="https://habrastorage.org/webt/i2/u5/3d/i2u53d-v1qhpmgkqiifa6q8rita.png"><br><br>  Tornado com uvloop aguenta-se melhor.  Mas o Aiohttp uvloop ajuda muito mais.  O Aiohttp começa a se comportar mal em 2300-2400 RPS e, com o uvloop, expande significativamente a faixa de carga.  Uma linha de importação e agora você tem um serviço muito mais produtivo. <br><br><h2>  Sumário </h2><br>  Resumirei o que queria transmitir a você hoje. <br><br><ul><li>  Em primeiro lugar, lancei um determinado parâmetro de referência artificial, onde havia uma quantidade decente de longa rotina.  Em nosso teste, o Aiohttp teve um desempenho melhor 2,5 vezes do que o Tornado. </li><li>  O segundo fato.  O Uvloop ajuda muito a melhorar o desempenho do Aiohttp (melhor que o Tornado). </li><li>  Eu falei sobre o Pyflame, com o qual frequentemente perfilamos o aplicativo diretamente na produção. </li><li>  E também falamos sobre rendimento de (aguardar) versus rendimento. </li></ul><br>  Como resultado desses benchmarks, nossa equipe de recomendações (e algumas outras) quase mudou completamente para Aiohttp with Tornado para microsserviços em Python em produção. <br><br><ul><li>  Para serviços de combate, o consumo de CPU caiu mais de 2 vezes. </li><li>  Começamos a respeitar o tempo limite para solicitações de http. </li><li>  Os serviços de latência caíram 2 a 5 vezes. </li></ul><br>  Aqui está um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">link para o benchmark</a> .  Se estiver interessado, você pode repeti-lo.  Obrigado a todos pela atenção.  Faça perguntas, tentarei respondê-las. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt435532/">https://habr.com/ru/post/pt435532/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt435520/index.html">Nós escrevemos nossa linguagem de programação, parte 3: Arquitetura do tradutor. Análise de estruturas de linguagem e expressões matemáticas</a></li>
<li><a href="../pt435522/index.html">Instantâneos de eventos no Axonframework 3, melhorando o desempenho</a></li>
<li><a href="../pt435526/index.html">Aventuras com um cluster Kubernetes em casa</a></li>
<li><a href="../pt435528/index.html">5 razões para o sucesso: por que a Amazon se tornou a empresa mais cara do mundo</a></li>
<li><a href="../pt435530/index.html">Assinaturas pagas - Dependência da conexão automática em um dispositivo móvel</a></li>
<li><a href="../pt435534/index.html">Ciência de dados: livros básicos</a></li>
<li><a href="../pt435536/index.html">Robôs humanóides: benefícios e problemas de mecanismos antropomórficos</a></li>
<li><a href="../pt435538/index.html">Em 2018, mais energia "verde" foi recebida na Alemanha do que eletricidade proveniente da combustão de carvão</a></li>
<li><a href="../pt435540/index.html">Novas palavras-chave em Java</a></li>
<li><a href="../pt435542/index.html">Desenvolvimento de jogos e defesa de um diploma ou "Como matei dois coelhos com uma panqueca de uma cajadada só"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>