<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🌾 🧚🏾 🧓🏼 功能思维。 第9部分 📴 ⛔️ 👈🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="这已经是有关F＃！函数编程的系列文章的第9部分。 我确信在哈布雷（Habré）上不会有这么长的周期。 但是我们不会停止。 今天，我们将讨论嵌套函数，模块，名称空间以及模块中混合类型和函数。 





- 第一部分 
- 第二部分 
- 第三部分 
- 第四部分 
- 第五部分 
- 第六部分 
-...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>功能思维。 第9部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/433406/"><p> 这已经是有关F＃！函数编程的系列文章的第9部分。 我确信在哈布雷（Habré）上不会有这么长的周期。 但是我们不会停止。 今天，我们将讨论嵌套函数，模块，名称空间以及模块中混合类型和函数。 </p><br><p><img src="https://habrastorage.org/webt/7j/cd/7x/7jcd7xzdvnhpyxuebjvbzb1uiqs.jpeg"></p><br><ul><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一部分</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第二部分</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第三部分</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第四部分</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第五部分</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第六部分</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第七部分</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第八部分</a></strong> <a name="habracut"></a></li></ul><br><hr><br><p> 现在您知道如何定义函数，但是如何组织它们呢？ </p><br><p>  F＃具有三个选项： </p><br><ul><li> 函数可以嵌套在其他函数中。 </li><li> 在应用程序级别，顶级功能被分组为“模块”。 </li><li> 或者您可以遵循面向对象的方法，并将函数作为方法附加到类型上。 </li></ul><br><p> 在本文中，我们将考虑前两种方法，其余的将在下一种方法中使用。 </p><br><h2> 嵌套函数 </h2><br><p> 在F＃中，可以在其他函数中定义函数。 这是封装辅助功能的好方法，这些辅助功能仅是主要功能所需要的，并且不应从外部看到。 </p><br><p>在下面的示例中， <code>add</code>嵌套在<code>addThreeNumbers</code> ： </p><br><pre> <code class="plaintext hljs">let addThreeNumbers xyz = //     let add n = fun x -&gt; x + n //    x |&gt; add y |&gt; add z addThreeNumbers 2 3 4</code> </pre> <br><p> 嵌套函数可以直接访问父参数，因为它们在其范围内。 <br> 因此，在下面的示例中， <code>printError</code>嵌套函数不需要参数，因为 她可以直接访问<code>n</code>和<code>max</code> 。 </p><br><pre> <code class="plaintext hljs">let validateSize max n = //       let printError() = printfn "Oops: '%i' is bigger than max: '%i'" n max //    if n &gt; max then printError() validateSize 10 9 validateSize 10 11</code> </pre> <br><p> 一个非常常见的模式是定义嵌套的递归辅助函数的主要函数，该函数以相应的初始值调用。 <br> 以下是此类代码的示例： </p><br><pre> <code class="plaintext hljs">let sumNumbersUpTo max = //      let rec recursiveSum n sumSoFar = match n with | 0 -&gt; sumSoFar | _ -&gt; recursiveSum (n-1) (n+sumSoFar) //       recursiveSum max 0 sumNumbersUpTo 10</code> </pre> <br><p> 尝试避免深度嵌套，尤其是在直接访问父变量（而不是参数形式）的情况下。 <br> 与许多嵌套的命令分支中最糟糕的嵌套一样，过度嵌套的函数将很难理解。 </p><br><p> 一个<em>不怎么</em>做的例子： </p><br><pre> <code class="plaintext hljs">// wtf,    ? let fx = let f2 y = let f3 z = x * z let f4 z = let f5 z = y * z let f6 () = y * x f6() f4 y x * f2 x</code> </pre> <br><h2> 模组 </h2><br><p> 模块只是将功能组合在一起的一个集合，通常是因为它们使用相同的一种或多种数据类型。 </p><br><p> 模块定义与功能定义非常相似。 它以<code>module</code>关键字开头，然后是<code>=</code>符号，然后是模块的内容。 <br> 模块的内容以及函数定义中的表达式<em>必须</em>设置有偏移量的格式。 </p><br><p> 包含两个功能的模块的定义： </p><br><pre> <code class="plaintext hljs">module MathStuff = let add xy = x + y let subtract xy = x - y</code> </pre> <br><p> 如果在Visual Studio中打开此代码， <code>add</code>鼠标悬停在<code>add</code>您会看到全名<code>add</code> ，实际上等于<code>MathStuff.add</code> ，就像<code>MastStuff</code>是一个类，而<code>add</code>是一个方法一样。 </p><br><p> 实际上，这正是正在发生的事情。 在后台，F＃编译器使用静态方法创建一个静态类。 等效的C＃看起来像这样： </p><br><pre> <code class="plaintext hljs">static class MathStuff { static public int add(int x, int y) { return x + y; } static public int subtract(int x, int y) { return x - y; } }</code> </pre> <br><p> 认识到模块只是静态类而函数是静态方法，可以很好地理解模块在F＃中的工作方式，因为大多数适用于静态类的规则也适用于模块。 </p><br><p> 就像在C＃中一样，每个独立功能都应该是该类的一部分，在F＃中，每个独立功能<em>都应该</em>是该模块的一部分。 </p><br><h3> 访问模块外部的功能 </h3><br><p> 如果需要从另一个模块访问功能，则可以通过其全名来引用它。 </p><br><pre> <code class="plaintext hljs">module MathStuff = let add xy = x + y let subtract xy = x - y module OtherStuff = //     MathStuff let add1 x = MathStuff.add x 1</code> </pre> <br><p> 您也可以使用<code>open</code>指令导入另一个模块的所有功能，然后可以使用短名称代替完整名称。 </p><br><pre> <code class="plaintext hljs">module OtherStuff = open MathStuff //      let add1 x = add x 1</code> </pre> <br><p> 期望使用名称的规则。 您始终可以按功能的全名来访问功能，也可以根据当前作用域使用相对或不完整的名称。 </p><br><h3> 嵌套模块 </h3><br><p> 与静态类一样，模块可以包含嵌套模块： </p><br><pre> <code class="plaintext hljs">module MathStuff = let add xy = x + y let subtract xy = x - y //   module FloatLib = let add xy :float = x + y let subtract xy :float = x - y</code> </pre> <br><p> 其他模块可以根据需要使用全名或相对名来引用嵌套模块中的函数： </p><br><pre> <code class="plaintext hljs">module OtherStuff = open MathStuff let add1 x = add x 1 //   let add1Float x = MathStuff.FloatLib.add x 1.0 //   let sub1Float x = FloatLib.subtract x 1.0</code> </pre> <br><h3> 顶级模块 </h3><br><p> 因此，由于模块可以嵌套，因此在上链之前，您可以到达顶层的某些父模块。 真的是 </p><br><p> 与前面显示的模块不同，顶层模块的定义有所不同。 </p><br><ul><li>  <code>module MyModuleName</code> <em>必须</em>是文件中的第一个声明 </li><li> 标志<code>=</code>缺少 </li><li> 模块内容<em>不得</em>缩进 </li></ul><br><p> 通常，每个源<code>.FS</code>文件中都应存在一个“顶级”声明。 有一些例外，但这仍然是一种好习惯。 模块名称不必与文件名匹配，但是两个文件不能包含名称相同的模块。 </p><br><p> 对于<code>.FSX</code>文件，不需要模块声明，在这种情况下，脚本文件名将自动成为模块名。 </p><br><p> 声明为“顶部模块”模块的<code>MathStuff</code>的示例： </p><br><pre> <code class="plaintext hljs">//    module MathStuff let add xy = x + y let subtract xy = x - y //   module FloatLib = let add xy :float = x + y let subtract xy :float = x - y</code> </pre> <br><p> 请注意，“顶层”代码（ <code>module MathStuff</code> ）中没有缩进，而嵌套<code>FloatLib</code>模块的内容仍然必须缩进。 </p><br><h3> 其他模块内容 </h3><br><p> 除功能外，模块还可以包含其他声明，例如类型声明，简单值和初始化代码（例如，静态构造函数） </p><br><pre> <code class="plaintext hljs">module MathStuff = //  let add xy = x + y let subtract xy = x - y //   type Complex = {r:float; i:float} type IntegerFunction = int -&gt; int -&gt; int type DegreesOrRadians = Deg | Rad // "" let PI = 3.141 // "" let mutable TrigType = Deg //  /   do printfn "module initialized"</code> </pre><br><p> 顺便说一下，如果以交互方式运行这些示例，则可能需要足够频繁地重新启动会话，以使代码保持“新鲜”且不会被先前的计算所感染。 </p><br><h3> 隐藏（重叠，阴影） </h3><br><p> 这也是我们的示例模块。 请注意， <code>MathStuff</code>包含<code>add</code>函数<em>以及</em> <code>FloatLib</code> 。 </p><br><pre> <code class="plaintext hljs">module MathStuff = let add xy = x + y let subtract xy = x - y //   module FloatLib = let add xy :float = x + y let subtract xy :float = x - y</code> </pre> <br><p> 如果在当前作用域中打开<em>两个</em>模块并调用<code>add</code>什么？ </p><br><pre> <code class="plaintext hljs">open MathStuff open MathStuff.FloatLib let result = add 1 2 // Compiler error: This expression was expected to // have type float but here has type int</code> </pre> <br><p> 碰巧， <code>MathStuff.FloatLib</code>模块重新定义了原始<code>MathStuff</code> ，该原始<code>MathStuff</code>被<code>FloatLib</code>模块阻止（隐藏）。 </p><br><p> 结果，我们得到了FS0001编译器错误，因为第一个参数<code>1</code>被期望为浮点数。 要解决此问题，您必须将<code>1</code>更改为<code>1.0</code> 。 </p><br><p> 不幸的是，在实践中这是<em>谨慎</em>而又容易被忽视的。 有时使用这种技术，您可以做一些有趣的技巧，就像子类一样，但是大多数情况下，具有相同名称的函数很烦人（例如，在极为通用的<code>map</code>函数的情况下）。 </p><br><p> 如果要避免此行为，可以使用<code>RequireQualifiedAccess</code>属性来停止它。 在同一示例中，两个模块都使用此属性进行修饰： </p><br><pre> <code class="plaintext hljs">[&lt;RequireQualifiedAccess&gt;] module MathStuff = let add xy = x + y let subtract xy = x - y //   [&lt;RequireQualifiedAccess&gt;] module FloatLib = let add xy :float = x + y let subtract xy :float = x - y</code> </pre> <br><p> 现在， <code>open</code>指令不可用： </p><br><pre> <code class="plaintext hljs">open MathStuff //  open MathStuff.FloatLib // </code> </pre> <br><p> 但是您仍然可以通过函数的全名来访问函数（没有任何歧义）： </p><br><pre> <code class="plaintext hljs">let result = MathStuff.add 1 2 let result = MathStuff.FloatLib.add 1.0 2.0</code> </pre> <br><h3> 门禁控制 </h3><br><p>  F＃支持使用标准.NET访问控制运算符，例如<code>public</code> ， <code>private</code>和<code>internal</code> 。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">MSDN文章</a>包含完整的信息。 </p><br><ul><li> 这些访问说明符可以应用于（“绑定”）顶级功能，值，类型和模块中的其他声明。 也可以为模块本身指定它们（例如，可能需要专用的嵌套模块）。 </li><li> 默认情况下，所有内容都具有公共访问权限（几种情况除外），因此要保护它们，您需要使用<code>private</code>或<code>internal</code> 。 </li></ul><br><p> 这些访问说明符只是控制F＃中可见性的一种方法。 一种完全不同的方法是使用类似于C头文件的签名文件，它们抽象地描述了模块的内容。 签名对于认真的封装非常有用，但是要考虑它们的功能，您将必须等待计划的<em>基于功能的</em>系列封装和<em>安全性</em> 。 </p><br><h2> 命名空间 </h2><br><p>  F＃中的命名空间类似于C＃中的命名空间。 它们可用于组织模块和类型，以避免名称冲突。 </p><br><p> 使用<code>namespace</code>关键字声明的<code>namespace</code> ： </p><br><pre> <code class="plaintext hljs">namespace Utilities module MathStuff = //  let add xy = x + y let subtract xy = x - y</code> </pre> <br><p> 由于<code>MathStuff</code>这个命名空间， <code>MathStuff</code>模块的全名<code>MathStuff</code>成为<code>Utilities.MathStuff</code> ，全名<code>add</code>是<code>Utilities.MathStuff.add</code> 。 </p><br><p> 相同的缩进规则适用于上面显示的模块名称空间中的模块。 </p><br><p> 您还可以通过在模块名称中添加句点来显式声明名称空间。 即 上面的代码可以这样重写： </p><br><pre> <code class="plaintext hljs">module Utilities.MathStuff //  let add xy = x + y let subtract xy = x - y</code> </pre> <br><p>  <code>MathStuff</code>模块的全名仍然是<code>Utilities.MathStuff</code> ，但现在它是一个顶级模块，其内容不需要缩进。 </p><br><p> 使用名称空间的一些其他功能： </p><br><ul><li> 命名空间对于模块是可选的。 与C＃不同，对于F＃项目，没有默认的名称空间，因此没有名称空间的顶级模块将是全局的。 如果计划创建可重用的库，则必须添加几个名称空间，以避免与其他库的代码冲突。 </li><li> 命名空间可以直接包含类型声明，但不能包含函数声明。 如前所述，所有函数和值声明必须是模块的一部分。 </li><li> 最后，请记住，名称空间在脚本中不起作用。 例如，如果您尝试将名称空间声明（例如<code>namespace Utilities</code> ）发送到交互式窗口，则会收到错误。 </li></ul><br><h3> 命名空间层次结构 </h3><br><p> 您可以通过简单地用点将名称分隔来建立名称空间的层次结构： </p><br><pre> <code class="plaintext hljs">namespace Core.Utilities module MathStuff = let add xy = x + y</code> </pre> <br><p> 如果需要，还可以在一个文件中声明<em>两个</em>名称空间。 应该注意的是，所有名称空间都<em>必须</em>以其全名声明-它们不支持嵌套。 </p><br><pre> <code class="plaintext hljs">namespace Core.Utilities module MathStuff = let add xy = x + y namespace Core.Extra module MoreMathStuff = let add xy = x + y</code> </pre> <br><p> 命名空间和模块之间的名称冲突是不可能的。 </p><br><pre> <code class="plaintext hljs">namespace Core.Utilities module MathStuff = let add xy = x + y namespace Core //    - Core.Utilities //     ! module Utilities = let add xy = x + y</code> </pre> <br><h2> 模块中的混合类型和功能 </h2><br><p> 如我们所见，模块通常由许多与特定数据类型交互的相互依赖的函数组成。 </p><br><p> 在OOP中，它们之上的数据结构和功能将在一个类中组合在一起。 在功能性F＃中，其上方的数据结构和功能被组合为一个模块。 </p><br><p> 有两种将类型和功能组合在一起的模式： </p><br><ul><li> 类型与函数分开声明 </li><li> 类型在与函数相同的模块中声明 </li></ul><br><p> 在第一种情况下，在任何模块<em>外部</em> （但在名称空间中）声明该类型，然后将与此类型一起使用的功能放入相同类型的模块中。 </p><br><pre> <code class="plaintext hljs">//    namespace Example //      type PersonType = {First:string; Last:string} //    ,     module Person = //  let create first last = {First=first; Last=last} // ,     let fullName {First=first; Last=last} = first + " " + last let person = Person.create "john" "doe" Person.fullName person |&gt; printfn "Fullname=%s"</code> </pre> <br><p> 或者，类型<em>在</em>模块<em>内部</em>声明<em>，</em>并具有简单的名称，例如“ <code>T</code> ”或模块名称。 对函数的访问大致如下： <code>MyModule.Func</code>和<code>MyModule.Func2</code> ，并访问类型： <code>MyModule.T</code> ： </p><br><pre> <code class="plaintext hljs">module Customer = // Customer.T -      type T = {AccountId:int; Name:string} //  let create id name = {T.AccountId=id; T.Name=name} // ,     let isValid {T.AccountId=id; } = id &gt; 0 let customer = Customer.create 42 "bob" Customer.isValid customer |&gt; printfn "Is valid?=%b"</code> </pre> <br><p> 请注意，在两种情况下，都必须有一个构造函数来创建类型（工厂）的新实例。 然后，在客户端代码中，您几乎不必显式访问类型名称，也不必怀疑类型是否在模块内部。 </p><br><p> 那么选择哪种方式呢？ </p><br><ul><li> 第一种方法更像经典的.NET，如果计划将此库用于F＃之外的代码（应该使用单独存在的类），则应首选该方法。 </li><li> 第二种方法在其他功能语言中更为常见。 模块内部的类型将作为嵌套类进行编译，这对于OOP语言通常不是很方便。 </li></ul><br><p> 您可以自己尝试两种方法。 在团队发展的情况下，必须选择一种风格。 </p><br><h3> 仅包含类型的模块 </h3><br><p> 如果有许多类型需要声明而没有任何函数，请不要使用该模块。 您可以直接在名称空间中声明类型，而无需使用嵌套类。 </p><br><p> 例如，您可能要这样做： </p><br><pre> <code class="plaintext hljs">//    module Example //     type PersonType = {First:string; Last:string} //    ,  ...</code> </pre> <br><p> 这是另一种方法。 单词<code>module</code>仅用单词<code>namespace</code>替换。 </p><br><pre> <code class="plaintext hljs">//    namespace Example //     type PersonType = {First:string; Last:string}</code> </pre> <br><p> 在这两种情况下， <code>PersonType</code>都将具有相同的全名。 </p><br><p> 请注意，此替换仅适用于类型。 必须<strong>始终</strong>在模块内部声明函数。 </p><br><h1> 其他资源 </h1><br><p>  F＃的教程很多，包括那些具有C＃或Java经验的人的材料。 当您深入了解F＃时，以下链接可能会很有用： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">F＃指南</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">F＃娱乐与利润</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">F＃维基</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在Y分钟内学习X：F＃</a> </li></ul><br><p> 还介绍了其他几种<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">开始学习F＃的方法</a> 。 </p><br><p> 最后，F＃社区非常适合初学者。 在Slack上，由F＃Software Foundation支持的聊天非常活跃，您<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">可以自由加入</a>初学者室。 我们强烈建议您这样做！ </p><br><p> 不要忘记访问<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">俄语社区F＃的网站</a> ！ 如果您对学习语言有任何疑问，我们将很乐意在聊天室中讨论这些问题： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">F＃软件基金会Slack聊天</a>室中的<code>#ru_general</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">室</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在电报中聊天</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">聊天聊天</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">F＃软件基金会Slack聊天</a>室中的#en_general <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">室</a> </li></ul><br><h2> 关于翻译作者 </h2><br><p> 由<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>@kleidemos</em></a>翻译 <br><img src="https://habrastorage.org/getpro/habr/post_images/f95/c6d/92c/f95c6d92c5b1126b093792a43955aa43.png" width="56" height="56">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在F＃开发人员</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">俄语社区</a>的努力下进行了翻译和编辑更改。 我们也感谢<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>@schvepsss</em></a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>@shwars</em></a>为本文准备发表。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN433406/">https://habr.com/ru/post/zh-CN433406/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN433396/index.html">前端2018：年度结果</a></li>
<li><a href="../zh-CN433398/index.html">功能思维。 第7部分</a></li>
<li><a href="../zh-CN433400/index.html">React教程第2部分：功能组件</a></li>
<li><a href="../zh-CN433402/index.html">功能思维。 第8部分</a></li>
<li><a href="../zh-CN433404/index.html">React教程第3部分：组件文件，项目结构</a></li>
<li><a href="../zh-CN433408/index.html">Node.js中的高效内存处理</a></li>
<li><a href="../zh-CN433410/index.html">功能思维。 第10部分</a></li>
<li><a href="../zh-CN433412/index.html">功能思维。 第11部分：决赛</a></li>
<li><a href="../zh-CN433414/index.html">测试PRTG网络监视器并与Zabbix进行比较</a></li>
<li><a href="../zh-CN433420/index.html">ZeroNights 2018结果</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>