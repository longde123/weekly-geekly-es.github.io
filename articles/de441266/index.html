<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📇 🤴🏻 👨🏼 Wie das tiOPF-Framework für Delphi / Lazarus funktioniert. Besuchervorlage 🔄 👉🏾 🔪</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vom Übersetzer 
 Es gibt zwei Gründe, warum ich mich verpflichtet habe, mehrere Materialien zu dem vor zwanzig Jahren für die nicht sehr beliebte Prog...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie das tiOPF-Framework für Delphi / Lazarus funktioniert. Besuchervorlage</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441266/"><h3>  Vom Übersetzer </h3><br>  Es gibt zwei Gründe, warum ich mich verpflichtet habe, mehrere Materialien zu dem vor zwanzig Jahren für die nicht sehr beliebte Programmierumgebung entwickelten Framework zu übersetzen: <br><br>  1. Nachdem ich vor einigen Jahren viele der Freuden der Arbeit mit dem Entity Framework als ORM für die .Net-Plattform kennengelernt hatte, suchte ich vergeblich nach Analoga für die Lazarus-Umgebung und im Allgemeinen nach Freepascal. <br>  Überraschenderweise fehlen ihr gute ORMs.  Alles, was damals gefunden wurde, war ein Open-Source-Projekt namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tiOPF</a> , das Ende der 90er Jahre für Delphi entwickelt und später auf Freepascal portiert wurde.  Dieses Framework unterscheidet sich jedoch grundlegend vom üblichen Aussehen großer und dicker ORMs. <br><br>  Es gibt keine visuellen Möglichkeiten, Objekte (in Entity - Modell zuerst) zu entwerfen und Objekte Feldern in relationalen Datenbanktabellen (in Entität - Datenbank zuerst) in tiOPF zuzuordnen.  Der Entwickler selbst positioniert diese Tatsache als einen der Mängel des Projekts. Als Verdienst bietet er jedoch eine vollständige Orientierung speziell auf das Geschäftsmodell des Objekts, es ist nur einen Hardcode wert ... <br><a name="habracut"></a><br>  Auf der Ebene der vorgeschlagenen Hardcodierung hatte ich Probleme.  Zu dieser Zeit war ich nicht sehr gut mit den Paradigmen und Methoden vertraut, die der Framework-Entwickler vollständig verwendete und in der Dokumentation mehrmals pro Absatz erwähnte (Entwurfsmuster des Besuchers, Linkers, Beobachters, verschiedene Abstraktionsebenen für die Unabhängigkeit von DBMS usw.). .).  Mein großes Projekt, das zu dieser Zeit mit der Datenbank arbeitete, konzentrierte sich vollständig auf die visuellen Komponenten von Lazarus und die Art und Weise, mit Datenbanken zu arbeiten, die von der visuellen Umgebung angeboten werden. Das Ergebnis waren Tonnen desselben Codes: drei Tabellen in der Datenbank selbst mit fast derselben Struktur und homogenen Daten, Drei identische Formulare zum Anzeigen, drei identische Formulare zum Bearbeiten, drei identische Formulare für Berichte und alles andere oben in der Überschrift „So entwerfen Sie keine Software“. <br><br>  Nachdem ich genügend Literatur zu den Prinzipien des korrekten Entwurfs von Datenbanken und Informationssystemen, einschließlich des Studiums von Vorlagen, gelesen und das Entity Framework kennengelernt hatte, entschied ich mich für ein vollständiges Refactoring sowohl der Datenbank selbst als auch meiner Anwendung.  Und wenn ich die erste Aufgabe vollständig bewältigt habe, gab es für die Implementierung der zweiten zwei Wege, die in verschiedene Richtungen führten: entweder vollständig .net, C # und das Entity Framework studieren oder ein geeignetes ORM für das vertraute Lazarus-System finden.  Es gab auch einen dritten, ersten, unauffälligen Radweg - ORM zu schreiben, um Ihren Bedürfnissen selbst zu entsprechen, aber das ist jetzt nicht der Punkt. <br><br>  Der Quellcode des Frameworks wird nicht viel kommentiert, aber die Entwickler haben dennoch (anscheinend in der Anfangsphase der Entwicklung) eine bestimmte Menge an Dokumentation vorbereitet.  Natürlich ist alles englischsprachig, und die Erfahrung zeigt, dass trotz der Fülle an Code, Diagrammen und Vorlagenprogrammierphrasen viele russischsprachige Programmierer in der englischsprachigen Dokumentation immer noch schlecht orientiert sind.  Nicht immer und nicht jeder hat den Wunsch, die Fähigkeit zu trainieren, den englischen technischen Text zu verstehen, ohne dass der Verstand ihn ins Russische übersetzen muss. <br><br>  Durch wiederholtes Korrekturlesen des zu übersetzenden Textes können Sie außerdem sehen, was ich beim ersten Treffen mit der Dokumentation verpasst habe. Ich habe es nicht vollständig oder falsch verstanden.  Das heißt, dies ist für ihn eine Gelegenheit, den untersuchten Rahmen besser zu lernen. <br><br>  2. In der Dokumentation überspringt der Autor absichtlich oder nicht einige Codeteile, was seiner Meinung nach wahrscheinlich offensichtlich ist.  Aufgrund der Einschränkungen beim Schreiben werden in der Dokumentation veraltete Mechanismen und Objekte als Beispiele verwendet, die in neuen Versionen des Frameworks gelöscht oder nicht mehr verwendet werden (habe ich nicht gesagt, dass es sich selbst weiterentwickelt?).  Als ich die entwickelten Beispiele selbst wiederholte, fand ich einige Fehler, die behoben werden sollten.  Daher erlaubte ich mir an einigen Stellen, den Text nicht nur zu übersetzen, sondern ihn auch zu ergänzen oder zu überarbeiten, damit er relevant bleibt, und die Beispiele funktionierten. <br><br>  Ich möchte mit der Übersetzung von Materialien aus einem Artikel von Peter Henrikson über den ersten „Wal“ beginnen, auf dem das gesamte Framework steht - die Besuchervorlage.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Originaltext hier gepostet</a> . <br><br><h2>  Besucher- und tiOPF-Vorlage </h2><br>  In diesem Artikel wird die Besuchervorlage vorgestellt, deren Verwendung eines der Hauptkonzepte des tiOPF-Frameworks (TechInsite Object Persistence Framework) ist.  Wir werden das Problem im Detail betrachten, nachdem wir alternative Lösungen analysiert haben, bevor wir den Besucher verwenden.  Bei der Entwicklung unseres eigenen Besucherkonzepts stehen wir vor einer weiteren Herausforderung: der Notwendigkeit, alle Objekte in der Sammlung zu durchlaufen.  Dieses Problem wird ebenfalls untersucht. <br><br>  Die Hauptaufgabe besteht darin, eine allgemeine Methode zu finden, um eine Reihe verwandter Methoden für einige Objekte in der Sammlung auszuführen.  Die durchgeführten Methoden können je nach internem Status der Objekte variieren.  Wir können überhaupt keine Methoden ausführen, aber wir können mehrere Methoden für dieselben Objekte ausführen. <br><br><h3>  Das notwendige Ausbildungsniveau </h3><br>  Der Leser sollte mit dem Objekt Pascal vertraut sein und die Grundprinzipien der objektorientierten Programmierung beherrschen. <br><br><h3>  Beispiel einer Geschäftsaufgabe in diesem Artikel </h3><br>  Als Beispiel entwickeln wir ein Adressbuch, mit dem Sie Aufzeichnungen über Personen und deren Kontaktinformationen erstellen können.  Mit der Zunahme der möglichen Kommunikationswege zwischen Personen sollte die Anwendung es Ihnen ermöglichen, solche Methoden flexibel ohne nennenswerte Codeverarbeitung hinzuzufügen (ich erinnere mich, dass ich den Code zum Hinzufügen einer Telefonnummer sofort erneut verarbeiten musste, um E-Mails hinzuzufügen).  Wir müssen zwei Kategorien von Adressen angeben: echte Adressen wie Privatadresse, Post, Arbeit und Elektronik: Festnetztelefon, Fax, Handy, E-Mail, Website. <br><br>  Auf Präsentationsebene sollte unsere Anwendung wie Explorer / Outlook aussehen, dh sie sollte Standardkomponenten wie TreeView und ListView verwenden.  Die Anwendung sollte schnell funktionieren und nicht den Eindruck einer umfangreichen Client-Server-Software erwecken. <br><br>  Eine Anwendung könnte ungefähr so ​​aussehen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/18a/fa8/773/18afa8773d4df14f7c08b3e4ae5ec204.png"><br><br>  Im Kontextmenü der Baumstruktur können Sie den Kontakt einer Person oder eines Unternehmens hinzufügen / entfernen und mit der rechten Maustaste auf die Kontaktdatenliste klicken, um deren Bearbeitungsdialog aufzurufen, Daten zu löschen oder hinzuzufügen. <br><br>  Daten können in verschiedenen Formen gespeichert werden. In Zukunft werden wir überlegen, wie diese Vorlage zur Implementierung dieser Funktion verwendet werden kann. <br><br><h3>  Bevor Sie anfangen </h3><br>  Wir beginnen mit einer einfachen Sammlung von Objekten - einer Liste von Personen, die wiederum zwei Eigenschaften haben - Name (Name) und Adresse (EmailAdrs).  Zunächst wird die Liste mit Daten im Konstruktor gefüllt und anschließend aus einer Datei oder Datenbank geladen.  Dies ist natürlich ein sehr vereinfachtes Beispiel, aber es reicht aus, um die Besuchervorlage vollständig zu implementieren. <br><br>  Erstellen Sie eine neue Anwendung und fügen Sie zwei Klassen des Schnittstellenabschnitts des Hauptmoduls hinzu: TPersonList (von TObjectList geerbt und erfordert die Verbindung des Contnrs-Moduls in Verwendungen) und TPerson (von TObject geerbt): <br><br><pre><code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TPersonList</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObjectList)  <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;  <span class="hljs-title"><span class="hljs-title">TPerson</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObject)  <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>    FEMailAdrs: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>;    FName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FName <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FName;    <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> EMailAdrs: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FEMailAdrs <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FEMailAdrs;  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Im TPersonList-Konstruktor erstellen wir drei TPerson-Objekte und fügen sie der Liste hinzu: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPersonList</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lData: TPerson; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span>; lData := TPerson.Create; lData.<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> := <span class="hljs-string"><span class="hljs-string">'Malcolm Groves'</span></span>; lData.EMailAdrs := <span class="hljs-string"><span class="hljs-string">'malcolm@dontspamme.com'</span></span>;  <span class="hljs-comment"><span class="hljs-comment">// (ADUG Vice President) Add(lData); lData := TPerson.Create; lData.Name := 'Don MacRae';  // (ADUG President) lData.EMailAdrs := 'don@dontspamme.com'; Add(lData); lData := TPerson.Create; lData.Name := 'Peter Hinrichsen';  // (Yours truly) lData.EMailAdrs := 'peter_hinrichsen@dontspamme.com'; Add(lData); end;</span></span></code> </pre> <br>  Zuerst gehen wir die Liste durch und führen zwei Operationen für jedes Element der Liste aus.  Die Vorgänge sind ähnlich, aber nicht identisch: Ein einfacher ShowMessage-Aufruf, der den Inhalt der Eigenschaften Name und EmailAdrs von TPerson-Objekten anzeigt.  Fügen Sie dem Formular zwei Schaltflächen hinzu und benennen Sie sie wie folgt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/201/819/5ce/2018195cee6acbb2348e3ceb78abeaea.png"><br><br>  Im bevorzugten Bereich Ihres Formulars sollten Sie außerdem eine Eigenschaft (oder nur ein Feld) FPersonList vom Typ TPersonList hinzufügen (wenn der Typ unter dem Formular deklariert ist, ändern Sie entweder die Reihenfolge oder erstellen Sie eine vorläufige Typdeklaration) und rufen Sie den Konstruktor im onCreate-Ereignishandler auf: <br><br><pre> <code class="delphi hljs">FPersonList := TPersonList.Create;</code> </pre> <br>  Um den Speicher im onClose-Ereignishandler des Formulars ordnungsgemäß freizugeben, muss dieses Objekt zerstört werden: <br><br><pre> <code class="delphi hljs">FPersonList.Free.</code> </pre> <br><h3>  Schritt 1. Hardcode-Iteration </h3><br>  Fügen Sie dem onClick-Ereignishandler der ersten Schaltfläche den folgenden Code hinzu, um Namen von TPerson-Objekten anzuzeigen: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button1Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> FPersonList.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>   ShowMessage(TPerson(FPersonList.Items[i]).<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Für die zweite Schaltfläche lautet der Handlercode wie folgt: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button2Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> FPersonList.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>   ShowMessage(TPerson(FPersonList.Items[i]).EMailAdrs); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Hier sind die offensichtlichen Schulen dieses Codes: <br><br><ul><li>  zwei Methoden, die fast dasselbe tun.  Der Unterschied besteht nur im Namen der Eigenschaft des Objekts, das sie anzeigen. <br></li><li>  Die Iteration ist langwierig, insbesondere wenn Sie gezwungen sind, eine ähnliche Schleife an hundert Stellen im Code zu schreiben. <br></li><li>  Eine harte Besetzung für TPerson ist mit Ausnahmesituationen behaftet.  Was ist, wenn die Liste eine Instanz von TAnimal ohne Adresseneigenschaft enthält?  In diesem Code gibt es keinen Mechanismus, um den Fehler zu stoppen und sich dagegen zu verteidigen. <br></li></ul><br>  Lassen Sie uns herausfinden, wie der Code durch Einführung einer Abstraktion verbessert werden kann: Wir übergeben den Iteratorcode an die übergeordnete Klasse. <br><br><h3>  Schritt 2. Iterator abstrahieren </h3><br>  Wir wollen also die Iteratorlogik in die Basisklasse verschieben.  Der Listeniterator selbst ist sehr einfach: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> FList.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment">// -    …</span></span></code> </pre> <br>  Es hört sich so an, als würden wir eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Iterator-</a> Vorlage verwenden.  Aus dem Buch über das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gang-of-Four-Entwurfsmusterbuch</a> ist bekannt, dass der Iterator extern und intern sein kann.  Bei Verwendung eines externen Iterators steuert der Client die Durchquerung explizit durch Aufrufen der Next-Methode (z. B. wird die Aufzählung von TCollection-Elementen durch die Methoden First, Next, Last gesteuert).  Wir werden hier den internen Iterator verwenden, da es einfacher ist, die Baumdurchquerung mit seiner Hilfe zu implementieren, was unser Ziel ist.  Wir werden die Iterate-Methode zu unserer Listenklasse hinzufügen und ihr eine Rückrufmethode übergeben, die für jedes Element der Liste ausgeführt werden muss.  Rückruf in Objekt Pascal wird als prozeduraler Typ deklariert, wir haben zum Beispiel TDoSomethingToAPerson. <br><br>  Daher deklarieren wir einen prozeduralen Typ TDoSomethingToAPerson, der einen Parameter vom Typ TPerson verwendet.  Mit dem Prozedurtyp können Sie die Methode als Parameter einer anderen Methode verwenden, dh einen Rückruf implementieren.  Auf diese Weise erstellen wir zwei Methoden, von denen eine die Name-Eigenschaft des Objekts und die andere die EmailAdrs-Eigenschaft anzeigt und die selbst als Parameter an den allgemeinen Iterator übergeben werden.  Schließlich sollte der Abschnitt zur Typdeklaration folgendermaßen aussehen: <br><br><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{ TPerson }</span></span> <span class="hljs-title"><span class="hljs-title">TPerson</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObject) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>   FEMailAdrs: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>;   FName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FName <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FName;   <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> EMailAdrs: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FEMailAdrs <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FEMailAdrs; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; TDoSomethingToAPerson = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData: TPerson)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">of</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">object</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-comment"><span class="hljs-comment">{ TPersonList }</span></span> <span class="hljs-title"><span class="hljs-title">TPersonList</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObjectList) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function">   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pMethod: TDoSomethingToAPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;   DoSomething: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPersonList</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pMethod: TDoSomethingToAPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>   pMethod(TPerson(Items[i])); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Um nun die erforderlichen Aktionen für die Listenelemente auszuführen, müssen wir zwei Dinge tun.  Definieren Sie zunächst die erforderlichen Operationen mit Methoden, deren Signatur von TDoSomethingToAPerson angegeben wurde, und schreiben Sie zweitens DoSomething-Aufrufe mit den Zeigern auf diese als Parameter übergebenen Methoden.  Fügen Sie im Abschnitt Formularbeschreibung zwei Deklarationen hinzu: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span>   FPersonList: TPersonList;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoShowName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData: TPerson)</span></span></span><span class="hljs-function">;</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoShowEmail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData: TPerson)</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>  Bei der Implementierung dieser Methoden geben wir Folgendes an: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoShowName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData: TPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ShowMessage(pData.<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoShowEmail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData: TPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ShowMessage(pData.EMailAdrs); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Der Code für Schaltflächenhandler wird wie folgt geändert: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button1Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FPersonList.DoSomething(@DoShowName); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button2Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FPersonList.DoSomething(@DoShowEmail); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Schon besser.  Wir haben jetzt drei Abstraktionsebenen in unserem Code.  Ein generischer Iterator ist eine Klassenmethode, die eine Sammlung von Objekten implementiert.  Geschäftslogik (bisher nur endlose Nachrichtenausgabe über ShowMessage) wird separat platziert.  Auf der Ebene der Präsentation (grafische Oberfläche) wird die Geschäftslogik in einer Zeile aufgerufen. <br><br>  Es ist leicht vorstellbar, wie ein Aufruf von ShowMessage durch Code ersetzt werden kann, der unsere Daten von TPerson in einer relationalen Datenbank mithilfe der SQL-Abfrage des TQuery-Objekts speichert.  Zum Beispiel so: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SavePerson</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData: TPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lQuery: TQuery; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> lQuery := TQuery.Create(<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>   lQuery.SQL.Text := <span class="hljs-string"><span class="hljs-string">'insert into people values (:Name, :EMailAdrs)'</span></span>;   lQuery.ParamByName(<span class="hljs-string"><span class="hljs-string">'Name'</span></span>).AsString := pData.<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>;   lQuery.ParamByName(<span class="hljs-string"><span class="hljs-string">'EMailAdrs'</span></span>).AsString := pData.EMailAdrs;   lQuery.Datababase := gAppDatabase;   lQuery.ExecSQL; <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>   lQuery.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Dies führt übrigens zu einem neuen Problem bei der Aufrechterhaltung einer Verbindung zur Datenbank.  In unserer Anfrage wird die Verbindung zur Datenbank über ein globales gAppDatabase-Objekt hergestellt.  Aber wo wird es sich befinden und wie soll man arbeiten?  Darüber hinaus werden wir bei jedem Schritt des Iterators gequält, um TQuery-Objekte zu erstellen, die Verbindung zu konfigurieren, die Abfrage auszuführen und nicht zu vergessen, den Speicher freizugeben.  Es ist besser, diesen Code in eine Klasse zu packen, die die Logik zum Erstellen und Ausführen von SQL-Abfragen sowie zum Einrichten und Aufrechterhalten einer Verbindung zur Datenbank enthält. <br><br><h3>  Schritt 3. Übergeben eines Objekts anstelle eines Zeigers auf einen Rückruf </h3><br>  Durch Übergeben des Objekts an die Iteratormethode der Basisklasse wird das Problem der Statusverwaltung gelöst.  Wir werden eine abstrakte Besucherklasse TPersonVisitor mit einer einzelnen Execute-Methode erstellen und das Objekt als Parameter an diese Methode übergeben.  Die abstrakte Besucheroberfläche ist unten dargestellt: <br><br><pre> <code class="delphi hljs">  <span class="hljs-title"><span class="hljs-title">TPersonVisitor</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObject) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pPerson: TPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Fügen Sie als Nächstes die Iterate-Methode zu unserer TPersonList-Klasse hinzu: <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TPersonList</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObjectList) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Iterate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisitor: TPersonVisitor)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Die Implementierung dieser Methode erfolgt wie folgt: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPersonList</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Iterate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisitor: TPersonVisitor)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>   pVisitor.Execute(TPerson(Items[i])); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Ein Objekt des implementierten Visitors der TPersonVisitor-Klasse wird an die Iterate-Methode übergeben, und beim Durchlaufen der Listenelemente für jedes dieser Elemente wird der angegebene Visitor (seine Ausführungsmethode) mit der TPerson-Instanz als Parameter aufgerufen. <br><br>  Erstellen wir zwei Implementierungen des Visitors - TShowNameVisitor und TShowEmailVistor, die die erforderlichen Arbeiten ausführen.  So füllen Sie den Abschnitt mit den Modulschnittstellen auf: <br><br><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{ TShowNameVisitor }</span></span> <span class="hljs-title"><span class="hljs-title">TShowNameVisitor</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TPersonVisitor) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pPerson: TPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-comment"><span class="hljs-comment">{ TShowEmailVisitor }</span></span> <span class="hljs-title"><span class="hljs-title">TShowEmailVisitor</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TPersonVisitor) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pPerson: TPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Der Einfachheit halber besteht die Implementierung der Ausführungsmethoden für sie weiterhin aus einer einzelnen Zeile - ShowMessage (pPerson.Name) und ShowMessage (pPerson.EMailAdrs). <br><br>  Ändern Sie den Code für die Schaltflächenklick-Handler: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button1Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lVis: TPersonVisitor; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> lVis := TShowNameVisitor.Create; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>   FPersonList.Iterate(lVis); <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>   lVis.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button2Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lVis: TPersonVisitor; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> lVis := TShowEmailVisitor.Create; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>   FPersonList.Iterate(lVis); <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>   lVis.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Nachdem wir ein Problem gelöst haben, haben wir uns ein anderes geschaffen.  Die Iteratorlogik ist in einer separaten Klasse gekapselt.  Die während der Iteration ausgeführten Operationen sind in Objekte eingeschlossen, wodurch wir einige Informationen über den Status speichern können. Die Größe des Codes ist jedoch von einer Zeile (FPersonList.DoSomething (@DoShowName) auf neun Zeilen für jeden Schaltflächenhandler angewachsen. Jetzt wird es uns helfen - dies ist der Besuchermanager, der sich um das Erstellen und Freigeben seiner Kopien kümmert. Möglicherweise können wir mehrere Vorgänge mit Objekten vorsehen, die während der Iteration ausgeführt werden sollen. Dazu speichert der Besuchermanager seine Liste und geht sie bei jedem Schritt durch, Sie  CREATE, DELETE und UPDATE:. Durch drei verschiedene Operatoren SQL werden kann, speichern Olnyaya nur Weiter ausgewählte Operationen werden die Vorteile dieses Ansatzes deutlich zeigen, werden wir die Besucher, um die Daten in einer relationalen Datenbank als eine einfache Datensicherung Betriebes durchgeführt. <br><br><h3>  Schritt 4. Weitere Verkapselung des Besuchers </h3><br>  Bevor wir fortfahren, müssen wir die Logik der Arbeit des Besuchers kapseln und sie von der Geschäftslogik der Anwendung trennen, damit sie nicht zu ihr zurückkehrt.  Dazu benötigen wir drei Schritte: Erstellen Sie die Basisklassen TVisited und TVisitor, dann die Basisklassen für das Geschäftsobjekt und die Sammlung von Geschäftsobjekten, und passen Sie dann unsere spezifischen Klassen TPerson und TPersonList (oder TPeople) geringfügig an, sodass sie Erben der erstellten Basis werden Klassen.  Im Allgemeinen entspricht die Klassenstruktur einem solchen Diagramm: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8bb/f5e/b62/8bbf5eb6201de628050d085c061fe800.png"><br><br>  Das TVisitor-Objekt implementiert zwei Methoden: die AcceptVisitor-Funktion und die Execute-Prozedur, an die das TVisited-Typobjekt übergeben wird.  Das TVisited-Objekt implementiert wiederum die Iterate-Methode mit einem Parameter vom Typ TVisitor.  Das heißt, TVisited.Iterate muss die Execute-Methode für das übertragene TVisitor-Objekt aufrufen und einen Link zu seiner eigenen Instanz als Parameter senden. Wenn die Instanz eine Sammlung ist, wird die Execute-Methode für jedes Element in der Sammlung aufgerufen.  Die AcceptVisitor-Funktion ist erforderlich, da wir ein verallgemeinertes System entwickeln.  Es ist möglich, eine Instanz der TDog-Klasse an den Besucher zu übergeben, der nur mit TPerson-Typen arbeitet, und es muss einen Mechanismus geben, um Ausnahmen und Zugriffsfehler aufgrund von Typinkongruenz zu verhindern.  Die TVisited-Klasse ist der Nachkomme der TPersistent-Klasse, da wir wenig später Funktionen implementieren müssen, die sich auf die Verwendung von RTTI beziehen. <br><br>  Der Schnittstellenteil des Moduls sieht nun folgendermaßen aus: <br><br><pre> <code class="delphi hljs">TVisited = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>; <span class="hljs-comment"><span class="hljs-comment">{ TVisitor }</span></span> <span class="hljs-title"><span class="hljs-title">TVisitor</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObject) <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcceptVisitor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">:</span></span> boolean; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-comment"><span class="hljs-comment">{ TVisited }</span></span> <span class="hljs-title"><span class="hljs-title">TVisited</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TPersistent) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Iterate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisitor: TVisitor)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Die Methoden der TVisitor Abstract-Klasse werden von den Erben implementiert, und die allgemeine Implementierung der Iterate-Methode für TVisited ist unten angegeben: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisited</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Iterate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisitor: TVisitor)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> pVisitor.Execute(self); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Gleichzeitig wird die Methode für die Möglichkeit ihrer Überschreibung bei den Erben als virtuell deklariert. <br><br><h3>  Schritt 5. Erstellen Sie ein freigegebenes Geschäftsobjekt und eine Sammlung </h3><br>  Unser Framework benötigt zwei weitere Basisklassen: das Definieren eines Geschäftsobjekts und eine Sammlung solcher Objekte.  Nennen Sie sie TtiObject und TtiObjectList.  Die Schnittstelle des ersten von ihnen: <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TtiObject</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TVisited) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Später im Entwicklungsprozess werden wir diese Klasse komplizieren, aber für die aktuelle Aufgabe reicht nur ein virtueller Konstruktor mit der Möglichkeit, sie in den Erben zu überschreiben. <br><br>  Wir planen, die TtiObjectList-Klasse aus TVisited zu generieren, um das Verhalten in Methoden zu verwenden, die bereits vom Vorfahren implementiert wurden (es gibt auch andere Gründe für diese Vererbung, die an seiner Stelle erörtert werden).  Darüber hinaus verbietet nichts die Verwendung von <abbr title="Der Autor hat den Teil mit Schnittstellen im Handbuch nicht implementiert, weil Der Artikel wurde in den 90ern geschrieben und der Mod für ihre Verwendung in Freepascal ist noch nicht eingetroffen.">Schnittstellen</abbr> (Interfaces) anstelle von abstrakten Klassen. <br><br>  Der Schnittstellenteil der TtiObjectList-Klasse lautet wie folgt: <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TtiObjectList</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TtiObject) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>   FList: TObjectList; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function">;</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Iterate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisitor: TVisitor)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pData: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Wie Sie sehen, befindet sich der Container selbst mit den Objektelementen im geschützten Bereich und steht Kunden dieser Klasse nicht zur Verfügung.  Der wichtigste Teil der Klasse ist die Implementierung der überschriebenen Iterate-Methode.  Wenn in der Basisklasse die Methode einfach pVisitor.Execute (self) heißt, dann ist hier die Implementierung mit der Aufzählung der Liste verbunden: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TtiObjectList</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Iterate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisitor: TVisitor)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Iterate(pVisitor); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> FList.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>   (FList.Items[i] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> TVisited).Iterate(pVisitor); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Die Implementierung anderer Klassenmethoden erfordert eine Codezeile, ohne automatisch platzierte geerbte Ausdrücke zu berücksichtigen: <br><br><pre> <code class="delphi hljs">Create: FList := TObjectList.Create; Destroy: FList.Free; Clear: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Assigned(FList) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> FList.Clear; Add: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Assigned(FList) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> FList.Add(pData);</code> </pre> <br>  Dies ist ein wichtiger Teil des gesamten Systems.  Wir haben zwei grundlegende Klassen von Geschäftslogik: TtiObject und TtiObjectList.  Beide haben eine Iterate-Methode, an die eine Instanz der TVisited-Klasse übergeben wird.  Der Iterator selbst ruft die Execute-Methode der TVisitor-Klasse auf und übergibt ihr einen Verweis auf das Objekt selbst.  Dieser Aufruf ist im Klassenverhalten auf der obersten Vererbungsebene vordefiniert.  Für eine Containerklasse verfügt jedes in der Liste gespeicherte Objekt auch über eine Iterate-Methode, die mit einem Parameter vom Typ TVisitor aufgerufen wird. Das heißt, es wird garantiert, dass jeder bestimmte Besucher alle in der Liste gespeicherten Objekte sowie die Liste selbst als Containerobjekt umgeht. <br><br><h3>  Schritt 6. Erstellen eines Besuchermanagers </h3><br>  Zurück zu dem Problem, das wir selbst beim dritten Schritt gezogen haben.  Da wir nicht jedes Mal Kopien von Besuchern erstellen und zerstören möchten, ist die Entwicklung des Managers die Lösung.  Es sollte zwei Hauptaufgaben ausführen: Verwalten der Liste der Besucher (die im Initialisierungsabschnitt der einzelnen Module als solche registriert sind) und Ausführen, wenn sie den entsprechenden Befehl vom Client erhalten. <br>  Zur Implementierung des Managers ergänzen wir unser Modul um drei zusätzliche Klassen: TVisClassRef, TVisMapping und TtiVisitorManager. <br><br><pre> <code class="delphi hljs">TVisClassRef = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> TVisitor;</code> </pre> <br>  TVisClassRef ist ein Referenztyp und gibt den Namen einer bestimmten Klasse an - ein Nachkomme von TVisitor.  Die Verwendung eines Referenztyps hat folgende Bedeutung: Wenn die Base Execute-Methode mit einer Signatur aufgerufen wird <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData: TVisited; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pVisClass: TVisClassRef)</span></span></span><span class="hljs-function">,</span></span></code> </pre> <br>  Intern kann diese Methode einen Ausdruck wie lVisitor: = pVisClass.Create verwenden, um eine Instanz eines bestimmten Besuchers zu erstellen, ohne zuvor den Typ zu kennen.  Das heißt, jede Klasse - ein Nachkomme von TVisitor kann dynamisch innerhalb derselben Execute-Methode erstellt werden, wenn der Name seiner Klasse als Parameter übergeben wird. <br><br>  Die zweite Klasse, TVisMapping, ist eine einfache Datenstruktur mit zwei Eigenschaften: einem Verweis auf den Typ TVisClassRef und einem String-Eigenschaft Command.  Eine Klasse wird benötigt, um die Operationen zu vergleichen, die mit ihrem Namen (einem Befehl, z. B. "Speichern") ausgeführt werden, und der Besucherklasse, die diese Befehle ausführen.  Fügen Sie dem Projekt seinen Code hinzu: <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TVisMapping</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObject) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>   FCommand: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>;   FVisitorClass: TVisClassRef; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> VisitorClass: TVisClassRef <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FVisitorClass <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FVisitorClass;   <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Command: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FCommand <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FCommand; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Und die letzte Klasse ist TtiVisitorManager.  Wenn wir den Besucher mit dem Manager registrieren, wird eine Instanz der TVisMapping-Klasse erstellt, die in die Managerliste eingetragen wird. <br>  Daher wird im Manager eine Liste von Besuchern mit einem übereinstimmenden Zeichenfolgenbefehl erstellt, nach dessen Empfang sie ausgeführt werden.  Die Klassenschnittstelle wird dem Modul hinzugefügt: <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TtiVisitorManager</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObject) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>   FList: TObjectList; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterVisitor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pCommand: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; pVisitorClass: TVisClassRef)</span></span></span><span class="hljs-function">;</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pCommand: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; pData: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Die wichtigsten Methoden sind RegisterVisitor und Execute.  Der erste wird normalerweise im Initialisierungsabschnitt des Moduls aufgerufen, der die Visitor-Klasse beschreibt und ungefähr so ​​aussieht: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">initialization</span></span>  gTIOPFManager.VisitorManager.RegisterVisitor(<span class="hljs-string"><span class="hljs-string">'show'</span></span>, TShowNameVisitor);  gTIOPFManager.VisitorManager.RegisterVisitor(<span class="hljs-string"><span class="hljs-string">'show'</span></span>, TShowEMailAdrsVisitor);</code> </pre> <br>  Der Code der Methode selbst lautet wie folgt: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TtiVisitorManager</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterVisitor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pCommand: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; pVisitorClass: TVisClassRef)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lData: TVisMapping; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> lData := TVisMapping.Create; lData.Command := pCommand; lData.VisitorClass := pVisitorClass; FList.Add(lData); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Es ist nicht schwer zu bemerken, dass dieser Code der Pascal-Implementierung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Factory-</a> Vorlage sehr ähnlich ist. <br><br>  Eine andere wichtige Execute-Methode akzeptiert zwei Parameter: den Befehl, mit dem der Besucher oder seine zu identifizierende Gruppe identifiziert wird, sowie das Datenobjekt, dessen Iterate-Methode mit einem Link zur Instanz des gewünschten Besuchers aufgerufen wird.  Der vollständige Code für die Execute-Methode ist unten angegeben: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TtiVisitorManager</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pCommand: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; pData: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; lVisitor: TVisitor; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> FList.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> SameText(pCommand, TVisMapping(FList.Items[i]).Command) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>     lVisitor := TVisMapping(FList.Items[i]).VisitorClass.Create;     <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>       pData.Iterate(lVisitor);     <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>       lVisitor.Free;     <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Um zwei zuvor registrierte Besucher mit einem Team zu betreiben, benötigen wir nur eine Codezeile: <br><br><pre> <code class="delphi hljs">gTIOPFManager.VisitorManager.Execute(<span class="hljs-string"><span class="hljs-string">'show'</span></span>, FPeople);</code> </pre> <br>  Als nächstes werden wir unser Projekt ergänzen, damit Sie ähnliche Befehle aufrufen können: <br><br><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">//      gTIOPFManager.VisitorManager.Execute('read', FPeople); //      gTIOPFManager.VisitorManager.Execute('save', FPeople).</span></span></code> </pre> <br><h3>  Schritt 7. Anpassen von Geschäftslogikklassen </h3><br>  Durch Hinzufügen des Vorfahren der Klassen TtiObject und TtiObjectList für unsere Geschäftsobjekte TPerson und TPeople können wir die Iteratorlogik in der Basisklasse kapseln und nicht mehr berühren. Außerdem können Objekte mit Daten an den Visitor Manager übertragen werden. <br><br>  Die neue Containerklassendeklaration sieht folgendermaßen aus: <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TPeople</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TtiObjectList);</code> </pre> <br>  Tatsächlich muss die TPeople-Klasse nicht einmal etwas implementieren.  Theoretisch könnten wir überhaupt auf eine TPeople-Deklaration verzichten und Objekte in einer Instanz der TtiObjectList-Klasse speichern. Da wir jedoch planen, Besucher zu schreiben, die nur TPeople-Instanzen verarbeiten, benötigen wir diese Klasse.  In der AcceptVisitor-Funktion werden folgende Überprüfungen durchgeführt: <br><br><pre> <code class="delphi hljs">Result := pVisited <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> TPeople.</code> </pre> <br>  Für die TPerson-Klasse fügen wir den TtiObject-Vorfahren hinzu und verschieben die beiden vorhandenen Eigenschaften in den veröffentlichten Bereich, da wir in Zukunft RTTI mit diesen Eigenschaften bearbeiten müssen.  Dies wird viel später den Code für die Zuordnung von Objekten und Datensätzen in einer relationalen Datenbank erheblich reduzieren: <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TPerson</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TtiObject) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>   FEMailAdrs: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>;   FName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">published</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FName <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FName;   <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> EMailAdrs: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FEMailAdrs <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FEMailAdrs; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><h3>  Schritt 8. Erstellen Sie eine Prototypansicht </h3><br>  <b><i>Bemerkung</i></b> .  Im ursprünglichen Artikel basierte die GUI auf den Komponenten, die der Autor von tiOPF erstellt hatte, um die Arbeit mit seinem Framework in Delphi zu vereinfachen.  Dies waren Analoga von DB Aware-Komponenten, bei denen es sich um Standardsteuerelemente wie Beschriftungen, Eingabefelder, Kontrollkästchen, Listen usw. handelte, die jedoch bestimmten Eigenschaften von tiObject-Objekten auf dieselbe Weise zugeordnet wurden wie Datenanzeigekomponenten Feldern in Datenbanktabellen.  Im Laufe der Zeit hat der Autor des Frameworks Pakete mit diesen visuellen Komponenten als veraltet und unerwünscht markiert.  Im Gegenzug schlägt er vor, mithilfe des Mediator-Entwurfsmusters eine Verknüpfung zwischen visuellen Komponenten und Klasseneigenschaften herzustellen.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Vorlage ist die zweitwichtigste in der gesamten Architektur des Frameworks. </font><font style="vertical-align: inherit;">Die Beschreibung des Vermittlers durch den Autor wird in einem separaten Artikel behandelt, dessen Umfang mit diesem Handbuch vergleichbar ist. Daher biete ich meine vereinfachte Version hier als GUI an. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benennen Sie die Schaltfläche 1 im Projektformular in "Befehl anzeigen" um, und Schaltfläche 2 lässt sie entweder vorerst ohne Handler oder nennt sie sofort "Befehl speichern". </font><font style="vertical-align: inherit;">Werfen Sie eine Memokomponente auf das Formular und platzieren Sie alle Elemente nach Ihrem Geschmack. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fügen Sie eine Besucherklasse hinzu, die den Befehl show implementiert: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interface -</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TShowVisitor</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TVisitor) <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcceptVisitor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">:</span></span> boolean; <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und die Implementierung ist - </font></font><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TShowVisitor</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcceptVisitor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">:</span></span> boolean; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := (pVisited <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> TPerson); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TShowVisitor</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> AcceptVisitor(pVisited) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; Form1.Memo1.Lines.Add(TPerson(pVisited).<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> + <span class="hljs-string"><span class="hljs-string">': '</span></span> + TPerson(pVisited).EMailAdrs); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AcceptVisitor überprüft, ob das übertragene Objekt eine Instanz von TPerson ist, da der Besucher den Befehl nur mit solchen Objekten ausführen sollte. Wenn der Typ übereinstimmt, wird der Befehl ausgeführt und dem Textfeld eine Zeile mit Objekteigenschaften hinzugefügt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterstützende Maßnahmen für den Zustand des Codes sind wie folgt. Fügen Sie der Beschreibung des Formulars selbst im privaten Bereich zwei Eigenschaften hinzu: FPeople vom Typ TPeople und VM vom Typ TtiVisitorManager. Im Ereignishandler für die Formularerstellung müssen wir diese Eigenschaften initiieren und den Besucher mit dem Befehl "show" registrieren:</font></font><br><br><pre> <code class="delphi hljs">FPeople := TPeople.Create; FillPeople; VM := TtiVisitorManager.Create; VM.RegisterVisitor(<span class="hljs-string"><span class="hljs-string">'show'</span></span>,TShowVisitor);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FilPeople ist auch eine Hilfsprozedur, die eine Liste mit drei Objekten füllt. Der Code stammt aus dem vorherigen Listenkonstruktor. </font><font style="vertical-align: inherit;">Vergessen Sie nicht, alle erstellten Objekte zu zerstören. </font><font style="vertical-align: inherit;">In diesem Fall schreiben wir FPeople.Free und VM.Free in den Handler zum Schließen von Formularen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und jetzt - Bams! </font><font style="vertical-align: inherit;">- Handler der ersten Schaltfläche:</font></font><br><br><pre> <code class="delphi hljs">Memo1.Clear; VM.Execute(<span class="hljs-string"><span class="hljs-string">'show'</span></span>,FPeople);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stimmen Sie zu, so viel mehr Spaß. </font><font style="vertical-align: inherit;">Und schwöre nicht auf den Hash aller Klassen in einem Modul. </font><font style="vertical-align: inherit;">Ganz am Ende des Handbuchs werden wir diese Trümmer harken.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schritt 9. Die Basisklasse des Besuchers, der mit Textdateien arbeitet </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In dieser Phase erstellen wir die Basisklasse des Besuchers, der weiß, wie man mit Textdateien arbeitet. Es gibt drei Möglichkeiten, mit Dateien im Objektpascal zu arbeiten: alte Prozeduren aus der Zeit des ersten Pascal (wie AssignFile und ReadLn), Streams (TStringStream oder TFileStream) und das TStringList-Objekt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die erste Methode sehr veraltet ist, sind die zweite und dritte eine gute Alternative, die auf OOP basiert. </font><font style="vertical-align: inherit;">Gleichzeitig bietet das Arbeiten mit Streams zusätzliche Vorteile wie die Möglichkeit, Daten zu komprimieren und zu verschlüsseln. Das zeilenweise Lesen und Schreiben in einen Stream ist in unserem Beispiel jedoch eine Art Redundanz. </font><font style="vertical-align: inherit;">Der Einfachheit halber wählen wir eine TStringList mit zwei einfachen Methoden - LoadFromFile und SaveToFile. </font><font style="vertical-align: inherit;">Denken Sie jedoch daran, dass diese Methoden bei großen Dateien erheblich langsamer werden, sodass der Stream die optimale Wahl für sie ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisFile-Basisklassenschnittstelle:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TVisFile</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TVisitor) <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>   FList: TStringList;   FFileName: TFileName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und die Konstruktor- und Destruktor-Implementierung: </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Create; FList := TStringList.Create; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FileExists(FFileName) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>   FList.LoadFromFile(FFileName); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FList.SaveToFile(FFileName); FList.Free; <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Wert der FFileName-Eigenschaft wird in den Konstruktoren der Nachkommen dieser Basisklasse zugewiesen (verwenden Sie einfach nicht die hier angeordnete Hardcodierung als Hauptprogrammierstil danach!). </font><font style="vertical-align: inherit;">Das Diagramm der Besucherklassen, die mit Dateien arbeiten </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/717/969/104/717969104d4b13d73ba1844fe0c2ddf9.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sieht </font><font style="vertical-align: inherit;">wie folgt aus: </font><font style="vertical-align: inherit;">In Übereinstimmung mit dem folgenden Diagramm erstellen wir zwei Nachkommen der TVisFile-Basisklasse: TVisTXTFile und TVisCSVFile. </font><font style="vertical-align: inherit;">Eine arbeitet mit * .csv-Dateien, in denen Datenfelder durch ein Symbol (Komma) getrennt sind, die zweite mit Textdateien, in denen einzelne Datenfelder eine feste Länge pro Zeile haben. </font><font style="vertical-align: inherit;">Für diese Klassen definieren wir die Konstruktoren nur wie folgt neu:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisCSVFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FFileName := <span class="hljs-string"><span class="hljs-string">'contacts.csv'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Create; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisTXTFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FFileName := <span class="hljs-string"><span class="hljs-string">'contacts.txt'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Create; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schritt 10. Fügen Sie den Visitor-Handler für Textdateien hinzu </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier werden wir zwei spezifische Besucher hinzufügen, einer liest eine Textdatei, der zweite schreibt darauf. </font><font style="vertical-align: inherit;">Der lesende Besucher muss die Methoden AcceptVisitor und Execute base class überschreiben. </font><font style="vertical-align: inherit;">AcceptVisitor überprüft, ob das TPeople-Klassenobjekt an den Besucher übergeben wird:</font></font><br><br><pre> <code class="delphi hljs">Result := pVisited <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> TPeople;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Ausführungsimplementierung ist wie folgt: </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisTXtRead</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; lData: TPerson; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> AcceptVisitor(pVisited) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-comment"><span class="hljs-comment">//==&gt; TPeople(pVisited).Clear; for i := 0 to FList.Count - 1 do begin   lData := TPerson.Create;   lData.Name := Trim(Copy(FList.Strings[i], 1, 20));   lData.EMailAdrs := Trim(Copy(FList.Strings[i], 21, 80));   TPeople(pVisited).Add(lData); end; end;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Besucher löscht zuerst die Liste des TPeople-Objekts, das ihm vom Parameter übergeben wurde, liest dann die Zeilen aus seinem TStringList-Objekt, in das der Inhalt der Datei geladen wird, erstellt in jeder Zeile ein TPerson-Objekt und fügt es der TPeople-Containerliste hinzu. </font><font style="vertical-align: inherit;">Der Einfachheit halber sind die Eigenschaften name und emailadrs in der Textdatei durch Leerzeichen getrennt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Datensatzbesucher implementiert die inverse Operation. Sein Konstruktor (überschrieben) löscht die interne TStringList (d. H. Führt die FList.Clear-Operation aus; sie ist nach der Vererbung obligatorisch). AcceptVisitor überprüft, ob das TPerson-Klassenobjekt übergeben wurde. Dies ist kein Fehler, sondern ein wichtiger Unterschied zu derselben Besuchermethode. Es scheint einfacher zu sein, die Aufzeichnung auf dieselbe Weise zu implementieren: Scannen Sie alle Containerobjekte, fügen Sie sie einer StringList hinzu und speichern Sie sie dann in einer Datei. All dies war so, wenn wir wirklich über das endgültige Schreiben von Daten in eine Datei sprachen, wir jedoch planen, Daten einer relationalen Datenbank zuzuordnen, sollte dies beachtet werden. In diesem Fall sollten wir den SQL-Code nur für die Objekte ausführen, die geändert (erstellt, gelöscht oder bearbeitet) wurden. Aus diesem Grund, bevor der Besucher eine Operation an dem Objekt ausführt,er muss die Korrespondenz seines Typs überprüfen:</font></font><br><br><pre> <code class="delphi hljs">Result := pVisited <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Tperson;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Methode execute fügt der internen StringList einfach eine Zeichenfolge hinzu, die mit der angegebenen Regel formatiert ist: Zuerst der Inhalt der Eigenschaft name des übergebenen Objekts, aufgefüllt mit Leerzeichen mit bis zu 20 Zeichen, dann der Inhalt der Eigenschaft emaiadrs: </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisTXTSave</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> AcceptVisitor(pVisited) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; FList.Add(PadRight(TPerson(pVisited).<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>,<span class="hljs-number"><span class="hljs-number">20</span></span>)+PadRight(TPerson(pVisited).EMailAdrs,<span class="hljs-number"><span class="hljs-number">60</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schritt 11. Fügen Sie den Visitor-Handler für CSV-Dateien hinzu </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Besucher des Lesens und Schreibens sind in fast allen Kollegen aus TXT-Klassen ähnlich, mit Ausnahme der Art und Weise, wie die letzte Zeile einer Datei formatiert wird: Im CSV-Standard werden Eigenschaftswerte durch Kommas getrennt. </font><font style="vertical-align: inherit;">Um Zeilen zu lesen und in Eigenschaften zu analysieren, verwenden wir die ExtractDelimited-Funktion aus dem Strutils-Modul. Das Schreiben erfolgt durch einfaches Verketten der Zeilen:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisCSVRead</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; lData: TPerson; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> AcceptVisitor(pVisited) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; TPeople(pVisited).Clear; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> FList.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>   lData := TPerson.Create;   lData.<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> := ExtractDelimited(<span class="hljs-number"><span class="hljs-number">1</span></span>, FList.Strings[i], [<span class="hljs-string"><span class="hljs-string">','</span></span>]);   lData.EMailAdrs := ExtractDelimited(<span class="hljs-number"><span class="hljs-number">2</span></span>, FList.Strings[i], [<span class="hljs-string"><span class="hljs-string">','</span></span>]);   TPeople(pVisited).Add(lData); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisCSVSave</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> AcceptVisitor(pVisited) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; FList.Add(TPerson(pVisited).<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> + <span class="hljs-string"><span class="hljs-string">','</span></span> + TPerson(pVisited).EMailAdrs); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir müssen nur noch neue Besucher im Manager registrieren und den Betrieb der Anwendung überprüfen. </font><font style="vertical-align: inherit;">Fügen Sie im Handler für die Formularerstellung den folgenden Code hinzu:</font></font><br><br><pre> <code class="delphi hljs">VM.RegisterVisitor(<span class="hljs-string"><span class="hljs-string">'readTXT'</span></span>, TVisTXTRead); VM.RegisterVisitor(<span class="hljs-string"><span class="hljs-string">'saveTXT'</span></span>,TVisTXTSave); VM.RegisterVisitor(<span class="hljs-string"><span class="hljs-string">'readCSV'</span></span>,TVisCSVRead); VM.RegisterVisitor(<span class="hljs-string"><span class="hljs-string">'saveCSV'</span></span>,TVisCSVSave);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Docken Sie die erforderlichen Schaltflächen im Formular an und weisen Sie ihnen die entsprechenden Handler zu: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/112/0c2/7c3/1120c27c31300af40162387ac222d33c.png"><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadCSVbtnClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> VM.Execute(<span class="hljs-string"><span class="hljs-string">'readCSV'</span></span>, FPeople); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadTXTbtnClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> VM.Execute(<span class="hljs-string"><span class="hljs-string">'readTXT'</span></span>, FPeople); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SaveCSVbtnClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> VM.Execute(<span class="hljs-string"><span class="hljs-string">'saveCSV'</span></span>, FPeople); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SaveTXTbtnClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> VM.Execute(<span class="hljs-string"><span class="hljs-string">'saveTXT'</span></span>, FPeople); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zusätzliche Dateiformate zum Speichern von Daten werden implementiert, indem einfach die entsprechenden Besucher hinzugefügt und im Manager registriert werden. </font><font style="vertical-align: inherit;">Beachten Sie Folgendes: Wir haben die Befehle absichtlich anders benannt, dh saveTXT und saveCSV. </font><font style="vertical-align: inherit;">Wenn beide Besucher mit einem Speicherbefehl übereinstimmen, starten beide mit demselben Befehl. Überprüfen Sie dies selbst.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schritt 12. Endgültige Codebereinigung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Schönheit und Reinheit des Codes zu erhöhen und ein Projekt für die Weiterentwicklung der Interaktion mit dem DBMS vorzubereiten, werden wir unsere Klassen entsprechend der Logik und ihrem Zweck in verschiedene Module verteilen. </font><font style="vertical-align: inherit;">Letztendlich sollten wir die folgende Struktur von Modulen im Projektordner haben, die es uns ermöglicht, auf eine kreisförmige Beziehung zwischen ihnen zu verzichten (ordnen Sie beim Zusammenstellen die erforderlichen Module in Verwendungsabschnitten an):</font></font><br><br><table><tbody><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modul </font></font><br></td><td>  Funktion <br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klassen </font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tivisitor.pas </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Basisklassen der Besucher- und Manager-Vorlage </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisitor </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisited </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisMapping </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TtiVisitorManager</font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tiobject.pas </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Basisgeschäftslogikklassen </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TtiObject </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TtiObjectList</font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> people_BOM.pas </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spezifische Geschäftslogikklassen </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TPerson </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TPeople</font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> people_SRV.pas </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konkrete Klassen, die für die Interaktion verantwortlich sind </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisFile </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisTXTFile </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisCSVFile </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisCSVSave </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisCSVRead </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisTXTSave </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisTXTRead</font></font><br></td></tr></tbody></table><br><h3>  Fazit </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Artikel haben wir das Problem der Iteration über eine Sammlung oder Liste von Objekten untersucht, die unterschiedliche Typen haben können. </font><font style="vertical-align: inherit;">Wir haben die von GoF vorgeschlagene Besuchervorlage verwendet, um zwei verschiedene Methoden zum Zuordnen von Daten von Objekten zu Dateien unterschiedlicher Formate optimal zu implementieren. </font><font style="vertical-align: inherit;">Gleichzeitig können durch die Erstellung des Besuchermanagers verschiedene Methoden von einem Team ausgeführt werden. </font><font style="vertical-align: inherit;">Letztendlich helfen uns die einfachen und anschaulichen Beispiele, die im Artikel diskutiert werden, ein ähnliches System für die Zuordnung von Objekten zu einer relationalen Datenbank weiterzuentwickeln. </font></font><br><br> <i><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Archiv mit Quellcode von Beispielen - hier</font></font></a></b></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441266/">https://habr.com/ru/post/de441266/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441254/index.html">Seminar „Warum wir mit Kubernetes in Kontakt getreten sind und was wir davon haben“, 28. Februar, Moskau</a></li>
<li><a href="../de441258/index.html">Voll funktionsfähiges dynamisches Tracing unter Linux mit eBPF und bpftrace</a></li>
<li><a href="../de441260/index.html">Wie neuronale Netzwerkgrafiken geholfen haben</a></li>
<li><a href="../de441262/index.html">Einfache und lange Aufgaben beseitigen Kandidaten besser als kurze und komplexe</a></li>
<li><a href="../de441264/index.html">Kibana Benutzerhandbuch. Visualisierung. Teil 2</a></li>
<li><a href="../de441268/index.html">Ceedling + Eclipse oder Unit-Tests für Mikrocontroller</a></li>
<li><a href="../de441270/index.html">Schauen Sie sich zuerst Apples FoundationDB an</a></li>
<li><a href="../de441274/index.html">Wie man ein Tester wird - die notwendigen Kenntnisse und Fähigkeiten</a></li>
<li><a href="../de441278/index.html">So erstellen Sie eine schöne Farbpalette</a></li>
<li><a href="../de441280/index.html">GAL-Setup in der Zimbra Collaboration Suite</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>