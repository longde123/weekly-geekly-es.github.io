<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üìá ü§¥üèª üë®üèº Wie das tiOPF-Framework f√ºr Delphi / Lazarus funktioniert. Besuchervorlage üîÑ üëâüèæ üî™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vom √úbersetzer 
 Es gibt zwei Gr√ºnde, warum ich mich verpflichtet habe, mehrere Materialien zu dem vor zwanzig Jahren f√ºr die nicht sehr beliebte Prog...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wie das tiOPF-Framework f√ºr Delphi / Lazarus funktioniert. Besuchervorlage</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441266/"><h3>  Vom √úbersetzer </h3><br>  Es gibt zwei Gr√ºnde, warum ich mich verpflichtet habe, mehrere Materialien zu dem vor zwanzig Jahren f√ºr die nicht sehr beliebte Programmierumgebung entwickelten Framework zu √ºbersetzen: <br><br>  1. Nachdem ich vor einigen Jahren viele der Freuden der Arbeit mit dem Entity Framework als ORM f√ºr die .Net-Plattform kennengelernt hatte, suchte ich vergeblich nach Analoga f√ºr die Lazarus-Umgebung und im Allgemeinen nach Freepascal. <br>  √úberraschenderweise fehlen ihr gute ORMs.  Alles, was damals gefunden wurde, war ein Open-Source-Projekt namens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">tiOPF</a> , das Ende der 90er Jahre f√ºr Delphi entwickelt und sp√§ter auf Freepascal portiert wurde.  Dieses Framework unterscheidet sich jedoch grundlegend vom √ºblichen Aussehen gro√üer und dicker ORMs. <br><br>  Es gibt keine visuellen M√∂glichkeiten, Objekte (in Entity - Modell zuerst) zu entwerfen und Objekte Feldern in relationalen Datenbanktabellen (in Entit√§t - Datenbank zuerst) in tiOPF zuzuordnen.  Der Entwickler selbst positioniert diese Tatsache als einen der M√§ngel des Projekts. Als Verdienst bietet er jedoch eine vollst√§ndige Orientierung speziell auf das Gesch√§ftsmodell des Objekts, es ist nur einen Hardcode wert ... <br><a name="habracut"></a><br>  Auf der Ebene der vorgeschlagenen Hardcodierung hatte ich Probleme.  Zu dieser Zeit war ich nicht sehr gut mit den Paradigmen und Methoden vertraut, die der Framework-Entwickler vollst√§ndig verwendete und in der Dokumentation mehrmals pro Absatz erw√§hnte (Entwurfsmuster des Besuchers, Linkers, Beobachters, verschiedene Abstraktionsebenen f√ºr die Unabh√§ngigkeit von DBMS usw.). .).  Mein gro√ües Projekt, das zu dieser Zeit mit der Datenbank arbeitete, konzentrierte sich vollst√§ndig auf die visuellen Komponenten von Lazarus und die Art und Weise, mit Datenbanken zu arbeiten, die von der visuellen Umgebung angeboten werden. Das Ergebnis waren Tonnen desselben Codes: drei Tabellen in der Datenbank selbst mit fast derselben Struktur und homogenen Daten, Drei identische Formulare zum Anzeigen, drei identische Formulare zum Bearbeiten, drei identische Formulare f√ºr Berichte und alles andere oben in der √úberschrift ‚ÄûSo entwerfen Sie keine Software‚Äú. <br><br>  Nachdem ich gen√ºgend Literatur zu den Prinzipien des korrekten Entwurfs von Datenbanken und Informationssystemen, einschlie√ülich des Studiums von Vorlagen, gelesen und das Entity Framework kennengelernt hatte, entschied ich mich f√ºr ein vollst√§ndiges Refactoring sowohl der Datenbank selbst als auch meiner Anwendung.  Und wenn ich die erste Aufgabe vollst√§ndig bew√§ltigt habe, gab es f√ºr die Implementierung der zweiten zwei Wege, die in verschiedene Richtungen f√ºhrten: entweder vollst√§ndig .net, C # und das Entity Framework studieren oder ein geeignetes ORM f√ºr das vertraute Lazarus-System finden.  Es gab auch einen dritten, ersten, unauff√§lligen Radweg - ORM zu schreiben, um Ihren Bed√ºrfnissen selbst zu entsprechen, aber das ist jetzt nicht der Punkt. <br><br>  Der Quellcode des Frameworks wird nicht viel kommentiert, aber die Entwickler haben dennoch (anscheinend in der Anfangsphase der Entwicklung) eine bestimmte Menge an Dokumentation vorbereitet.  Nat√ºrlich ist alles englischsprachig, und die Erfahrung zeigt, dass trotz der F√ºlle an Code, Diagrammen und Vorlagenprogrammierphrasen viele russischsprachige Programmierer in der englischsprachigen Dokumentation immer noch schlecht orientiert sind.  Nicht immer und nicht jeder hat den Wunsch, die F√§higkeit zu trainieren, den englischen technischen Text zu verstehen, ohne dass der Verstand ihn ins Russische √ºbersetzen muss. <br><br>  Durch wiederholtes Korrekturlesen des zu √ºbersetzenden Textes k√∂nnen Sie au√üerdem sehen, was ich beim ersten Treffen mit der Dokumentation verpasst habe. Ich habe es nicht vollst√§ndig oder falsch verstanden.  Das hei√üt, dies ist f√ºr ihn eine Gelegenheit, den untersuchten Rahmen besser zu lernen. <br><br>  2. In der Dokumentation √ºberspringt der Autor absichtlich oder nicht einige Codeteile, was seiner Meinung nach wahrscheinlich offensichtlich ist.  Aufgrund der Einschr√§nkungen beim Schreiben werden in der Dokumentation veraltete Mechanismen und Objekte als Beispiele verwendet, die in neuen Versionen des Frameworks gel√∂scht oder nicht mehr verwendet werden (habe ich nicht gesagt, dass es sich selbst weiterentwickelt?).  Als ich die entwickelten Beispiele selbst wiederholte, fand ich einige Fehler, die behoben werden sollten.  Daher erlaubte ich mir an einigen Stellen, den Text nicht nur zu √ºbersetzen, sondern ihn auch zu erg√§nzen oder zu √ºberarbeiten, damit er relevant bleibt, und die Beispiele funktionierten. <br><br>  Ich m√∂chte mit der √úbersetzung von Materialien aus einem Artikel von Peter Henrikson √ºber den ersten ‚ÄûWal‚Äú beginnen, auf dem das gesamte Framework steht - die Besuchervorlage.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Originaltext hier gepostet</a> . <br><br><h2>  Besucher- und tiOPF-Vorlage </h2><br>  In diesem Artikel wird die Besuchervorlage vorgestellt, deren Verwendung eines der Hauptkonzepte des tiOPF-Frameworks (TechInsite Object Persistence Framework) ist.  Wir werden das Problem im Detail betrachten, nachdem wir alternative L√∂sungen analysiert haben, bevor wir den Besucher verwenden.  Bei der Entwicklung unseres eigenen Besucherkonzepts stehen wir vor einer weiteren Herausforderung: der Notwendigkeit, alle Objekte in der Sammlung zu durchlaufen.  Dieses Problem wird ebenfalls untersucht. <br><br>  Die Hauptaufgabe besteht darin, eine allgemeine Methode zu finden, um eine Reihe verwandter Methoden f√ºr einige Objekte in der Sammlung auszuf√ºhren.  Die durchgef√ºhrten Methoden k√∂nnen je nach internem Status der Objekte variieren.  Wir k√∂nnen √ºberhaupt keine Methoden ausf√ºhren, aber wir k√∂nnen mehrere Methoden f√ºr dieselben Objekte ausf√ºhren. <br><br><h3>  Das notwendige Ausbildungsniveau </h3><br>  Der Leser sollte mit dem Objekt Pascal vertraut sein und die Grundprinzipien der objektorientierten Programmierung beherrschen. <br><br><h3>  Beispiel einer Gesch√§ftsaufgabe in diesem Artikel </h3><br>  Als Beispiel entwickeln wir ein Adressbuch, mit dem Sie Aufzeichnungen √ºber Personen und deren Kontaktinformationen erstellen k√∂nnen.  Mit der Zunahme der m√∂glichen Kommunikationswege zwischen Personen sollte die Anwendung es Ihnen erm√∂glichen, solche Methoden flexibel ohne nennenswerte Codeverarbeitung hinzuzuf√ºgen (ich erinnere mich, dass ich den Code zum Hinzuf√ºgen einer Telefonnummer sofort erneut verarbeiten musste, um E-Mails hinzuzuf√ºgen).  Wir m√ºssen zwei Kategorien von Adressen angeben: echte Adressen wie Privatadresse, Post, Arbeit und Elektronik: Festnetztelefon, Fax, Handy, E-Mail, Website. <br><br>  Auf Pr√§sentationsebene sollte unsere Anwendung wie Explorer / Outlook aussehen, dh sie sollte Standardkomponenten wie TreeView und ListView verwenden.  Die Anwendung sollte schnell funktionieren und nicht den Eindruck einer umfangreichen Client-Server-Software erwecken. <br><br>  Eine Anwendung k√∂nnte ungef√§hr so ‚Äã‚Äãaussehen: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/18a/fa8/773/18afa8773d4df14f7c08b3e4ae5ec204.png"><br><br>  Im Kontextmen√º der Baumstruktur k√∂nnen Sie den Kontakt einer Person oder eines Unternehmens hinzuf√ºgen / entfernen und mit der rechten Maustaste auf die Kontaktdatenliste klicken, um deren Bearbeitungsdialog aufzurufen, Daten zu l√∂schen oder hinzuzuf√ºgen. <br><br>  Daten k√∂nnen in verschiedenen Formen gespeichert werden. In Zukunft werden wir √ºberlegen, wie diese Vorlage zur Implementierung dieser Funktion verwendet werden kann. <br><br><h3>  Bevor Sie anfangen </h3><br>  Wir beginnen mit einer einfachen Sammlung von Objekten - einer Liste von Personen, die wiederum zwei Eigenschaften haben - Name (Name) und Adresse (EmailAdrs).  Zun√§chst wird die Liste mit Daten im Konstruktor gef√ºllt und anschlie√üend aus einer Datei oder Datenbank geladen.  Dies ist nat√ºrlich ein sehr vereinfachtes Beispiel, aber es reicht aus, um die Besuchervorlage vollst√§ndig zu implementieren. <br><br>  Erstellen Sie eine neue Anwendung und f√ºgen Sie zwei Klassen des Schnittstellenabschnitts des Hauptmoduls hinzu: TPersonList (von TObjectList geerbt und erfordert die Verbindung des Contnrs-Moduls in Verwendungen) und TPerson (von TObject geerbt): <br><br><pre><code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TPersonList</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObjectList)  <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>    <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;  <span class="hljs-title"><span class="hljs-title">TPerson</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObject)  <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>    FEMailAdrs: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>;    FName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>    <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FName <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FName;    <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> EMailAdrs: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FEMailAdrs <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FEMailAdrs;  <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Im TPersonList-Konstruktor erstellen wir drei TPerson-Objekte und f√ºgen sie der Liste hinzu: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPersonList</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lData: TPerson; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span>; lData := TPerson.Create; lData.<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> := <span class="hljs-string"><span class="hljs-string">'Malcolm Groves'</span></span>; lData.EMailAdrs := <span class="hljs-string"><span class="hljs-string">'malcolm@dontspamme.com'</span></span>;  <span class="hljs-comment"><span class="hljs-comment">// (ADUG Vice President) Add(lData); lData := TPerson.Create; lData.Name := 'Don MacRae';  // (ADUG President) lData.EMailAdrs := 'don@dontspamme.com'; Add(lData); lData := TPerson.Create; lData.Name := 'Peter Hinrichsen';  // (Yours truly) lData.EMailAdrs := 'peter_hinrichsen@dontspamme.com'; Add(lData); end;</span></span></code> </pre> <br>  Zuerst gehen wir die Liste durch und f√ºhren zwei Operationen f√ºr jedes Element der Liste aus.  Die Vorg√§nge sind √§hnlich, aber nicht identisch: Ein einfacher ShowMessage-Aufruf, der den Inhalt der Eigenschaften Name und EmailAdrs von TPerson-Objekten anzeigt.  F√ºgen Sie dem Formular zwei Schaltfl√§chen hinzu und benennen Sie sie wie folgt: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/201/819/5ce/2018195cee6acbb2348e3ceb78abeaea.png"><br><br>  Im bevorzugten Bereich Ihres Formulars sollten Sie au√üerdem eine Eigenschaft (oder nur ein Feld) FPersonList vom Typ TPersonList hinzuf√ºgen (wenn der Typ unter dem Formular deklariert ist, √§ndern Sie entweder die Reihenfolge oder erstellen Sie eine vorl√§ufige Typdeklaration) und rufen Sie den Konstruktor im onCreate-Ereignishandler auf: <br><br><pre> <code class="delphi hljs">FPersonList := TPersonList.Create;</code> </pre> <br>  Um den Speicher im onClose-Ereignishandler des Formulars ordnungsgem√§√ü freizugeben, muss dieses Objekt zerst√∂rt werden: <br><br><pre> <code class="delphi hljs">FPersonList.Free.</code> </pre> <br><h3>  Schritt 1. Hardcode-Iteration </h3><br>  F√ºgen Sie dem onClick-Ereignishandler der ersten Schaltfl√§che den folgenden Code hinzu, um Namen von TPerson-Objekten anzuzeigen: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button1Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> FPersonList.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>   ShowMessage(TPerson(FPersonList.Items[i]).<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  F√ºr die zweite Schaltfl√§che lautet der Handlercode wie folgt: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button2Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> FPersonList.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>   ShowMessage(TPerson(FPersonList.Items[i]).EMailAdrs); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Hier sind die offensichtlichen Schulen dieses Codes: <br><br><ul><li>  zwei Methoden, die fast dasselbe tun.  Der Unterschied besteht nur im Namen der Eigenschaft des Objekts, das sie anzeigen. <br></li><li>  Die Iteration ist langwierig, insbesondere wenn Sie gezwungen sind, eine √§hnliche Schleife an hundert Stellen im Code zu schreiben. <br></li><li>  Eine harte Besetzung f√ºr TPerson ist mit Ausnahmesituationen behaftet.  Was ist, wenn die Liste eine Instanz von TAnimal ohne Adresseneigenschaft enth√§lt?  In diesem Code gibt es keinen Mechanismus, um den Fehler zu stoppen und sich dagegen zu verteidigen. <br></li></ul><br>  Lassen Sie uns herausfinden, wie der Code durch Einf√ºhrung einer Abstraktion verbessert werden kann: Wir √ºbergeben den Iteratorcode an die √ºbergeordnete Klasse. <br><br><h3>  Schritt 2. Iterator abstrahieren </h3><br>  Wir wollen also die Iteratorlogik in die Basisklasse verschieben.  Der Listeniterator selbst ist sehr einfach: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> FList.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-comment"><span class="hljs-comment">// -    ‚Ä¶</span></span></code> </pre> <br>  Es h√∂rt sich so an, als w√ºrden wir eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Iterator-</a> Vorlage verwenden.  Aus dem Buch √ºber das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gang-of-Four-Entwurfsmusterbuch</a> ist bekannt, dass der Iterator extern und intern sein kann.  Bei Verwendung eines externen Iterators steuert der Client die Durchquerung explizit durch Aufrufen der Next-Methode (z. B. wird die Aufz√§hlung von TCollection-Elementen durch die Methoden First, Next, Last gesteuert).  Wir werden hier den internen Iterator verwenden, da es einfacher ist, die Baumdurchquerung mit seiner Hilfe zu implementieren, was unser Ziel ist.  Wir werden die Iterate-Methode zu unserer Listenklasse hinzuf√ºgen und ihr eine R√ºckrufmethode √ºbergeben, die f√ºr jedes Element der Liste ausgef√ºhrt werden muss.  R√ºckruf in Objekt Pascal wird als prozeduraler Typ deklariert, wir haben zum Beispiel TDoSomethingToAPerson. <br><br>  Daher deklarieren wir einen prozeduralen Typ TDoSomethingToAPerson, der einen Parameter vom Typ TPerson verwendet.  Mit dem Prozedurtyp k√∂nnen Sie die Methode als Parameter einer anderen Methode verwenden, dh einen R√ºckruf implementieren.  Auf diese Weise erstellen wir zwei Methoden, von denen eine die Name-Eigenschaft des Objekts und die andere die EmailAdrs-Eigenschaft anzeigt und die selbst als Parameter an den allgemeinen Iterator √ºbergeben werden.  Schlie√ülich sollte der Abschnitt zur Typdeklaration folgenderma√üen aussehen: <br><br><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{ TPerson }</span></span> <span class="hljs-title"><span class="hljs-title">TPerson</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObject) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>   FEMailAdrs: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>;   FName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FName <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FName;   <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> EMailAdrs: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FEMailAdrs <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FEMailAdrs; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; TDoSomethingToAPerson = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData: TPerson)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">of</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">object</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-comment"><span class="hljs-comment">{ TPersonList }</span></span> <span class="hljs-title"><span class="hljs-title">TPersonList</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObjectList) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function">   </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pMethod: TDoSomethingToAPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;   DoSomething: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPersonList</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pMethod: TDoSomethingToAPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>   pMethod(TPerson(Items[i])); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Um nun die erforderlichen Aktionen f√ºr die Listenelemente auszuf√ºhren, m√ºssen wir zwei Dinge tun.  Definieren Sie zun√§chst die erforderlichen Operationen mit Methoden, deren Signatur von TDoSomethingToAPerson angegeben wurde, und schreiben Sie zweitens DoSomething-Aufrufe mit den Zeigern auf diese als Parameter √ºbergebenen Methoden.  F√ºgen Sie im Abschnitt Formularbeschreibung zwei Deklarationen hinzu: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span>   FPersonList: TPersonList;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoShowName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData: TPerson)</span></span></span><span class="hljs-function">;</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoShowEmail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData: TPerson)</span></span></span><span class="hljs-function">;</span></span></code> </pre> <br>  Bei der Implementierung dieser Methoden geben wir Folgendes an: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoShowName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData: TPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ShowMessage(pData.<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoShowEmail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData: TPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> ShowMessage(pData.EMailAdrs); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Der Code f√ºr Schaltfl√§chenhandler wird wie folgt ge√§ndert: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button1Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FPersonList.DoSomething(@DoShowName); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button2Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FPersonList.DoSomething(@DoShowEmail); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Schon besser.  Wir haben jetzt drei Abstraktionsebenen in unserem Code.  Ein generischer Iterator ist eine Klassenmethode, die eine Sammlung von Objekten implementiert.  Gesch√§ftslogik (bisher nur endlose Nachrichtenausgabe √ºber ShowMessage) wird separat platziert.  Auf der Ebene der Pr√§sentation (grafische Oberfl√§che) wird die Gesch√§ftslogik in einer Zeile aufgerufen. <br><br>  Es ist leicht vorstellbar, wie ein Aufruf von ShowMessage durch Code ersetzt werden kann, der unsere Daten von TPerson in einer relationalen Datenbank mithilfe der SQL-Abfrage des TQuery-Objekts speichert.  Zum Beispiel so: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SavePerson</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData: TPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lQuery: TQuery; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> lQuery := TQuery.Create(<span class="hljs-keyword"><span class="hljs-keyword">nil</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>   lQuery.SQL.Text := <span class="hljs-string"><span class="hljs-string">'insert into people values (:Name, :EMailAdrs)'</span></span>;   lQuery.ParamByName(<span class="hljs-string"><span class="hljs-string">'Name'</span></span>).AsString := pData.<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>;   lQuery.ParamByName(<span class="hljs-string"><span class="hljs-string">'EMailAdrs'</span></span>).AsString := pData.EMailAdrs;   lQuery.Datababase := gAppDatabase;   lQuery.ExecSQL; <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>   lQuery.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Dies f√ºhrt √ºbrigens zu einem neuen Problem bei der Aufrechterhaltung einer Verbindung zur Datenbank.  In unserer Anfrage wird die Verbindung zur Datenbank √ºber ein globales gAppDatabase-Objekt hergestellt.  Aber wo wird es sich befinden und wie soll man arbeiten?  Dar√ºber hinaus werden wir bei jedem Schritt des Iterators gequ√§lt, um TQuery-Objekte zu erstellen, die Verbindung zu konfigurieren, die Abfrage auszuf√ºhren und nicht zu vergessen, den Speicher freizugeben.  Es ist besser, diesen Code in eine Klasse zu packen, die die Logik zum Erstellen und Ausf√ºhren von SQL-Abfragen sowie zum Einrichten und Aufrechterhalten einer Verbindung zur Datenbank enth√§lt. <br><br><h3>  Schritt 3. √úbergeben eines Objekts anstelle eines Zeigers auf einen R√ºckruf </h3><br>  Durch √úbergeben des Objekts an die Iteratormethode der Basisklasse wird das Problem der Statusverwaltung gel√∂st.  Wir werden eine abstrakte Besucherklasse TPersonVisitor mit einer einzelnen Execute-Methode erstellen und das Objekt als Parameter an diese Methode √ºbergeben.  Die abstrakte Besucheroberfl√§che ist unten dargestellt: <br><br><pre> <code class="delphi hljs">  <span class="hljs-title"><span class="hljs-title">TPersonVisitor</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObject) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pPerson: TPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  F√ºgen Sie als N√§chstes die Iterate-Methode zu unserer TPersonList-Klasse hinzu: <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TPersonList</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObjectList) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Iterate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisitor: TPersonVisitor)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Die Implementierung dieser Methode erfolgt wie folgt: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TPersonList</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Iterate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisitor: TPersonVisitor)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>   pVisitor.Execute(TPerson(Items[i])); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Ein Objekt des implementierten Visitors der TPersonVisitor-Klasse wird an die Iterate-Methode √ºbergeben, und beim Durchlaufen der Listenelemente f√ºr jedes dieser Elemente wird der angegebene Visitor (seine Ausf√ºhrungsmethode) mit der TPerson-Instanz als Parameter aufgerufen. <br><br>  Erstellen wir zwei Implementierungen des Visitors - TShowNameVisitor und TShowEmailVistor, die die erforderlichen Arbeiten ausf√ºhren.  So f√ºllen Sie den Abschnitt mit den Modulschnittstellen auf: <br><br><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">{ TShowNameVisitor }</span></span> <span class="hljs-title"><span class="hljs-title">TShowNameVisitor</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TPersonVisitor) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pPerson: TPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-comment"><span class="hljs-comment">{ TShowEmailVisitor }</span></span> <span class="hljs-title"><span class="hljs-title">TShowEmailVisitor</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TPersonVisitor) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pPerson: TPerson)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Der Einfachheit halber besteht die Implementierung der Ausf√ºhrungsmethoden f√ºr sie weiterhin aus einer einzelnen Zeile - ShowMessage (pPerson.Name) und ShowMessage (pPerson.EMailAdrs). <br><br>  √Ñndern Sie den Code f√ºr die Schaltfl√§chenklick-Handler: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button1Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lVis: TPersonVisitor; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> lVis := TShowNameVisitor.Create; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>   FPersonList.Iterate(lVis); <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>   lVis.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Button2Click</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lVis: TPersonVisitor; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> lVis := TShowEmailVisitor.Create; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>   FPersonList.Iterate(lVis); <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>   lVis.Free; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Nachdem wir ein Problem gel√∂st haben, haben wir uns ein anderes geschaffen.  Die Iteratorlogik ist in einer separaten Klasse gekapselt.  Die w√§hrend der Iteration ausgef√ºhrten Operationen sind in Objekte eingeschlossen, wodurch wir einige Informationen √ºber den Status speichern k√∂nnen. Die Gr√∂√üe des Codes ist jedoch von einer Zeile (FPersonList.DoSomething (@DoShowName) auf neun Zeilen f√ºr jeden Schaltfl√§chenhandler angewachsen. Jetzt wird es uns helfen - dies ist der Besuchermanager, der sich um das Erstellen und Freigeben seiner Kopien k√ºmmert. M√∂glicherweise k√∂nnen wir mehrere Vorg√§nge mit Objekten vorsehen, die w√§hrend der Iteration ausgef√ºhrt werden sollen. Dazu speichert der Besuchermanager seine Liste und geht sie bei jedem Schritt durch, Sie  CREATE, DELETE und UPDATE:. Durch drei verschiedene Operatoren SQL werden kann, speichern Olnyaya nur Weiter ausgew√§hlte Operationen werden die Vorteile dieses Ansatzes deutlich zeigen, werden wir die Besucher, um die Daten in einer relationalen Datenbank als eine einfache Datensicherung Betriebes durchgef√ºhrt. <br><br><h3>  Schritt 4. Weitere Verkapselung des Besuchers </h3><br>  Bevor wir fortfahren, m√ºssen wir die Logik der Arbeit des Besuchers kapseln und sie von der Gesch√§ftslogik der Anwendung trennen, damit sie nicht zu ihr zur√ºckkehrt.  Dazu ben√∂tigen wir drei Schritte: Erstellen Sie die Basisklassen TVisited und TVisitor, dann die Basisklassen f√ºr das Gesch√§ftsobjekt und die Sammlung von Gesch√§ftsobjekten, und passen Sie dann unsere spezifischen Klassen TPerson und TPersonList (oder TPeople) geringf√ºgig an, sodass sie Erben der erstellten Basis werden Klassen.  Im Allgemeinen entspricht die Klassenstruktur einem solchen Diagramm: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8bb/f5e/b62/8bbf5eb6201de628050d085c061fe800.png"><br><br>  Das TVisitor-Objekt implementiert zwei Methoden: die AcceptVisitor-Funktion und die Execute-Prozedur, an die das TVisited-Typobjekt √ºbergeben wird.  Das TVisited-Objekt implementiert wiederum die Iterate-Methode mit einem Parameter vom Typ TVisitor.  Das hei√üt, TVisited.Iterate muss die Execute-Methode f√ºr das √ºbertragene TVisitor-Objekt aufrufen und einen Link zu seiner eigenen Instanz als Parameter senden. Wenn die Instanz eine Sammlung ist, wird die Execute-Methode f√ºr jedes Element in der Sammlung aufgerufen.  Die AcceptVisitor-Funktion ist erforderlich, da wir ein verallgemeinertes System entwickeln.  Es ist m√∂glich, eine Instanz der TDog-Klasse an den Besucher zu √ºbergeben, der nur mit TPerson-Typen arbeitet, und es muss einen Mechanismus geben, um Ausnahmen und Zugriffsfehler aufgrund von Typinkongruenz zu verhindern.  Die TVisited-Klasse ist der Nachkomme der TPersistent-Klasse, da wir wenig sp√§ter Funktionen implementieren m√ºssen, die sich auf die Verwendung von RTTI beziehen. <br><br>  Der Schnittstellenteil des Moduls sieht nun folgenderma√üen aus: <br><br><pre> <code class="delphi hljs">TVisited = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>; <span class="hljs-comment"><span class="hljs-comment">{ TVisitor }</span></span> <span class="hljs-title"><span class="hljs-title">TVisitor</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObject) <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcceptVisitor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">:</span></span> boolean; <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-comment"><span class="hljs-comment">{ TVisited }</span></span> <span class="hljs-title"><span class="hljs-title">TVisited</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TPersistent) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Iterate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisitor: TVisitor)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Die Methoden der TVisitor Abstract-Klasse werden von den Erben implementiert, und die allgemeine Implementierung der Iterate-Methode f√ºr TVisited ist unten angegeben: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisited</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Iterate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisitor: TVisitor)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> pVisitor.Execute(self); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Gleichzeitig wird die Methode f√ºr die M√∂glichkeit ihrer √úberschreibung bei den Erben als virtuell deklariert. <br><br><h3>  Schritt 5. Erstellen Sie ein freigegebenes Gesch√§ftsobjekt und eine Sammlung </h3><br>  Unser Framework ben√∂tigt zwei weitere Basisklassen: das Definieren eines Gesch√§ftsobjekts und eine Sammlung solcher Objekte.  Nennen Sie sie TtiObject und TtiObjectList.  Die Schnittstelle des ersten von ihnen: <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TtiObject</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TVisited) <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Sp√§ter im Entwicklungsprozess werden wir diese Klasse komplizieren, aber f√ºr die aktuelle Aufgabe reicht nur ein virtueller Konstruktor mit der M√∂glichkeit, sie in den Erben zu √ºberschreiben. <br><br>  Wir planen, die TtiObjectList-Klasse aus TVisited zu generieren, um das Verhalten in Methoden zu verwenden, die bereits vom Vorfahren implementiert wurden (es gibt auch andere Gr√ºnde f√ºr diese Vererbung, die an seiner Stelle er√∂rtert werden).  Dar√ºber hinaus verbietet nichts die Verwendung von <abbr title="Der Autor hat den Teil mit Schnittstellen im Handbuch nicht implementiert, weil Der Artikel wurde in den 90ern geschrieben und der Mod f√ºr ihre Verwendung in Freepascal ist noch nicht eingetroffen.">Schnittstellen</abbr> (Interfaces) anstelle von abstrakten Klassen. <br><br>  Der Schnittstellenteil der TtiObjectList-Klasse lautet wie folgt: <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TtiObjectList</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TtiObject) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>   FList: TObjectList; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Clear</span></span></span><span class="hljs-function">;</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Iterate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisitor: TVisitor)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pData: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Wie Sie sehen, befindet sich der Container selbst mit den Objektelementen im gesch√ºtzten Bereich und steht Kunden dieser Klasse nicht zur Verf√ºgung.  Der wichtigste Teil der Klasse ist die Implementierung der √ºberschriebenen Iterate-Methode.  Wenn in der Basisklasse die Methode einfach pVisitor.Execute (self) hei√üt, dann ist hier die Implementierung mit der Aufz√§hlung der Liste verbunden: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TtiObjectList</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Iterate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisitor: TVisitor)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Iterate(pVisitor); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> FList.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>   (FList.Items[i] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> TVisited).Iterate(pVisitor); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Die Implementierung anderer Klassenmethoden erfordert eine Codezeile, ohne automatisch platzierte geerbte Ausdr√ºcke zu ber√ºcksichtigen: <br><br><pre> <code class="delphi hljs">Create: FList := TObjectList.Create; Destroy: FList.Free; Clear: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Assigned(FList) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> FList.Clear; Add: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> Assigned(FList) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> FList.Add(pData);</code> </pre> <br>  Dies ist ein wichtiger Teil des gesamten Systems.  Wir haben zwei grundlegende Klassen von Gesch√§ftslogik: TtiObject und TtiObjectList.  Beide haben eine Iterate-Methode, an die eine Instanz der TVisited-Klasse √ºbergeben wird.  Der Iterator selbst ruft die Execute-Methode der TVisitor-Klasse auf und √ºbergibt ihr einen Verweis auf das Objekt selbst.  Dieser Aufruf ist im Klassenverhalten auf der obersten Vererbungsebene vordefiniert.  F√ºr eine Containerklasse verf√ºgt jedes in der Liste gespeicherte Objekt auch √ºber eine Iterate-Methode, die mit einem Parameter vom Typ TVisitor aufgerufen wird. Das hei√üt, es wird garantiert, dass jeder bestimmte Besucher alle in der Liste gespeicherten Objekte sowie die Liste selbst als Containerobjekt umgeht. <br><br><h3>  Schritt 6. Erstellen eines Besuchermanagers </h3><br>  Zur√ºck zu dem Problem, das wir selbst beim dritten Schritt gezogen haben.  Da wir nicht jedes Mal Kopien von Besuchern erstellen und zerst√∂ren m√∂chten, ist die Entwicklung des Managers die L√∂sung.  Es sollte zwei Hauptaufgaben ausf√ºhren: Verwalten der Liste der Besucher (die im Initialisierungsabschnitt der einzelnen Module als solche registriert sind) und Ausf√ºhren, wenn sie den entsprechenden Befehl vom Client erhalten. <br>  Zur Implementierung des Managers erg√§nzen wir unser Modul um drei zus√§tzliche Klassen: TVisClassRef, TVisMapping und TtiVisitorManager. <br><br><pre> <code class="delphi hljs">TVisClassRef = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> TVisitor;</code> </pre> <br>  TVisClassRef ist ein Referenztyp und gibt den Namen einer bestimmten Klasse an - ein Nachkomme von TVisitor.  Die Verwendung eines Referenztyps hat folgende Bedeutung: Wenn die Base Execute-Methode mit einer Signatur aufgerufen wird <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pData: TVisited; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pVisClass: TVisClassRef)</span></span></span><span class="hljs-function">,</span></span></code> </pre> <br>  Intern kann diese Methode einen Ausdruck wie lVisitor: = pVisClass.Create verwenden, um eine Instanz eines bestimmten Besuchers zu erstellen, ohne zuvor den Typ zu kennen.  Das hei√üt, jede Klasse - ein Nachkomme von TVisitor kann dynamisch innerhalb derselben Execute-Methode erstellt werden, wenn der Name seiner Klasse als Parameter √ºbergeben wird. <br><br>  Die zweite Klasse, TVisMapping, ist eine einfache Datenstruktur mit zwei Eigenschaften: einem Verweis auf den Typ TVisClassRef und einem String-Eigenschaft Command.  Eine Klasse wird ben√∂tigt, um die Operationen zu vergleichen, die mit ihrem Namen (einem Befehl, z. B. "Speichern") ausgef√ºhrt werden, und der Besucherklasse, die diese Befehle ausf√ºhren.  F√ºgen Sie dem Projekt seinen Code hinzu: <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TVisMapping</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObject) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>   FCommand: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>;   FVisitorClass: TVisClassRef; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> VisitorClass: TVisClassRef <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FVisitorClass <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FVisitorClass;   <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> Command: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FCommand <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FCommand; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Und die letzte Klasse ist TtiVisitorManager.  Wenn wir den Besucher mit dem Manager registrieren, wird eine Instanz der TVisMapping-Klasse erstellt, die in die Managerliste eingetragen wird. <br>  Daher wird im Manager eine Liste von Besuchern mit einem √ºbereinstimmenden Zeichenfolgenbefehl erstellt, nach dessen Empfang sie ausgef√ºhrt werden.  Die Klassenschnittstelle wird dem Modul hinzugef√ºgt: <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TtiVisitorManager</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TObject) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>   FList: TObjectList; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterVisitor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pCommand: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; pVisitorClass: TVisClassRef)</span></span></span><span class="hljs-function">;</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pCommand: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; pData: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Die wichtigsten Methoden sind RegisterVisitor und Execute.  Der erste wird normalerweise im Initialisierungsabschnitt des Moduls aufgerufen, der die Visitor-Klasse beschreibt und ungef√§hr so ‚Äã‚Äãaussieht: <br><br><pre> <code class="delphi hljs"><span class="hljs-keyword"><span class="hljs-keyword">initialization</span></span>  gTIOPFManager.VisitorManager.RegisterVisitor(<span class="hljs-string"><span class="hljs-string">'show'</span></span>, TShowNameVisitor);  gTIOPFManager.VisitorManager.RegisterVisitor(<span class="hljs-string"><span class="hljs-string">'show'</span></span>, TShowEMailAdrsVisitor);</code> </pre> <br>  Der Code der Methode selbst lautet wie folgt: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TtiVisitorManager</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RegisterVisitor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pCommand: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; pVisitorClass: TVisClassRef)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> lData: TVisMapping; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> lData := TVisMapping.Create; lData.Command := pCommand; lData.VisitorClass := pVisitorClass; FList.Add(lData); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Es ist nicht schwer zu bemerken, dass dieser Code der Pascal-Implementierung der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Factory-</a> Vorlage sehr √§hnlich ist. <br><br>  Eine andere wichtige Execute-Methode akzeptiert zwei Parameter: den Befehl, mit dem der Besucher oder seine zu identifizierende Gruppe identifiziert wird, sowie das Datenobjekt, dessen Iterate-Methode mit einem Link zur Instanz des gew√ºnschten Besuchers aufgerufen wird.  Der vollst√§ndige Code f√ºr die Execute-Methode ist unten angegeben: <br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TtiVisitorManager</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pCommand: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">; pData: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; lVisitor: TVisitor; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> FList.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> SameText(pCommand, TVisMapping(FList.Items[i]).Command) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>     lVisitor := TVisMapping(FList.Items[i]).VisitorClass.Create;     <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>       pData.Iterate(lVisitor);     <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span>       lVisitor.Free;     <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;   <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br>  Um zwei zuvor registrierte Besucher mit einem Team zu betreiben, ben√∂tigen wir nur eine Codezeile: <br><br><pre> <code class="delphi hljs">gTIOPFManager.VisitorManager.Execute(<span class="hljs-string"><span class="hljs-string">'show'</span></span>, FPeople);</code> </pre> <br>  Als n√§chstes werden wir unser Projekt erg√§nzen, damit Sie √§hnliche Befehle aufrufen k√∂nnen: <br><br><pre> <code class="delphi hljs"><span class="hljs-comment"><span class="hljs-comment">//      gTIOPFManager.VisitorManager.Execute('read', FPeople); //      gTIOPFManager.VisitorManager.Execute('save', FPeople).</span></span></code> </pre> <br><h3>  Schritt 7. Anpassen von Gesch√§ftslogikklassen </h3><br>  Durch Hinzuf√ºgen des Vorfahren der Klassen TtiObject und TtiObjectList f√ºr unsere Gesch√§ftsobjekte TPerson und TPeople k√∂nnen wir die Iteratorlogik in der Basisklasse kapseln und nicht mehr ber√ºhren. Au√üerdem k√∂nnen Objekte mit Daten an den Visitor Manager √ºbertragen werden. <br><br>  Die neue Containerklassendeklaration sieht folgenderma√üen aus: <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TPeople</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TtiObjectList);</code> </pre> <br>  Tats√§chlich muss die TPeople-Klasse nicht einmal etwas implementieren.  Theoretisch k√∂nnten wir √ºberhaupt auf eine TPeople-Deklaration verzichten und Objekte in einer Instanz der TtiObjectList-Klasse speichern. Da wir jedoch planen, Besucher zu schreiben, die nur TPeople-Instanzen verarbeiten, ben√∂tigen wir diese Klasse.  In der AcceptVisitor-Funktion werden folgende √úberpr√ºfungen durchgef√ºhrt: <br><br><pre> <code class="delphi hljs">Result := pVisited <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> TPeople.</code> </pre> <br>  F√ºr die TPerson-Klasse f√ºgen wir den TtiObject-Vorfahren hinzu und verschieben die beiden vorhandenen Eigenschaften in den ver√∂ffentlichten Bereich, da wir in Zukunft RTTI mit diesen Eigenschaften bearbeiten m√ºssen.  Dies wird viel sp√§ter den Code f√ºr die Zuordnung von Objekten und Datens√§tzen in einer relationalen Datenbank erheblich reduzieren: <br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TPerson</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TtiObject) <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>   FEMailAdrs: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>;   FName: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">published</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FName <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FName;   <span class="hljs-keyword"><span class="hljs-keyword">property</span></span> EMailAdrs: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-keyword"><span class="hljs-keyword">read</span></span> FEMailAdrs <span class="hljs-keyword"><span class="hljs-keyword">write</span></span> FEMailAdrs; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><h3>  Schritt 8. Erstellen Sie eine Prototypansicht </h3><br>  <b><i>Bemerkung</i></b> .  Im urspr√ºnglichen Artikel basierte die GUI auf den Komponenten, die der Autor von tiOPF erstellt hatte, um die Arbeit mit seinem Framework in Delphi zu vereinfachen.  Dies waren Analoga von DB Aware-Komponenten, bei denen es sich um Standardsteuerelemente wie Beschriftungen, Eingabefelder, Kontrollk√§stchen, Listen usw. handelte, die jedoch bestimmten Eigenschaften von tiObject-Objekten auf dieselbe Weise zugeordnet wurden wie Datenanzeigekomponenten Feldern in Datenbanktabellen.  Im Laufe der Zeit hat der Autor des Frameworks Pakete mit diesen visuellen Komponenten als veraltet und unerw√ºnscht markiert.  Im Gegenzug schl√§gt er vor, mithilfe des Mediator-Entwurfsmusters eine Verkn√ºpfung zwischen visuellen Komponenten und Klasseneigenschaften herzustellen.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Diese Vorlage ist die zweitwichtigste in der gesamten Architektur des Frameworks. </font><font style="vertical-align: inherit;">Die Beschreibung des Vermittlers durch den Autor wird in einem separaten Artikel behandelt, dessen Umfang mit diesem Handbuch vergleichbar ist. Daher biete ich meine vereinfachte Version hier als GUI an. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Benennen Sie die Schaltfl√§che 1 im Projektformular in "Befehl anzeigen" um, und Schaltfl√§che 2 l√§sst sie entweder vorerst ohne Handler oder nennt sie sofort "Befehl speichern". </font><font style="vertical-align: inherit;">Werfen Sie eine Memokomponente auf das Formular und platzieren Sie alle Elemente nach Ihrem Geschmack. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">F√ºgen Sie eine Besucherklasse hinzu, die den Befehl show implementiert: </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interface -</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TShowVisitor</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TVisitor) <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcceptVisitor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">:</span></span> boolean; <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und die Implementierung ist - </font></font><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TShowVisitor</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AcceptVisitor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">:</span></span> boolean; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> Result := (pVisited <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> TPerson); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TShowVisitor</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> AcceptVisitor(pVisited) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; Form1.Memo1.Lines.Add(TPerson(pVisited).<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> + <span class="hljs-string"><span class="hljs-string">': '</span></span> + TPerson(pVisited).EMailAdrs); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">AcceptVisitor √ºberpr√ºft, ob das √ºbertragene Objekt eine Instanz von TPerson ist, da der Besucher den Befehl nur mit solchen Objekten ausf√ºhren sollte. Wenn der Typ √ºbereinstimmt, wird der Befehl ausgef√ºhrt und dem Textfeld eine Zeile mit Objekteigenschaften hinzugef√ºgt. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unterst√ºtzende Ma√ünahmen f√ºr den Zustand des Codes sind wie folgt. F√ºgen Sie der Beschreibung des Formulars selbst im privaten Bereich zwei Eigenschaften hinzu: FPeople vom Typ TPeople und VM vom Typ TtiVisitorManager. Im Ereignishandler f√ºr die Formularerstellung m√ºssen wir diese Eigenschaften initiieren und den Besucher mit dem Befehl "show" registrieren:</font></font><br><br><pre> <code class="delphi hljs">FPeople := TPeople.Create; FillPeople; VM := TtiVisitorManager.Create; VM.RegisterVisitor(<span class="hljs-string"><span class="hljs-string">'show'</span></span>,TShowVisitor);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">FilPeople ist auch eine Hilfsprozedur, die eine Liste mit drei Objekten f√ºllt. Der Code stammt aus dem vorherigen Listenkonstruktor. </font><font style="vertical-align: inherit;">Vergessen Sie nicht, alle erstellten Objekte zu zerst√∂ren. </font><font style="vertical-align: inherit;">In diesem Fall schreiben wir FPeople.Free und VM.Free in den Handler zum Schlie√üen von Formularen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und jetzt - Bams! </font><font style="vertical-align: inherit;">- Handler der ersten Schaltfl√§che:</font></font><br><br><pre> <code class="delphi hljs">Memo1.Clear; VM.Execute(<span class="hljs-string"><span class="hljs-string">'show'</span></span>,FPeople);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Stimmen Sie zu, so viel mehr Spa√ü. </font><font style="vertical-align: inherit;">Und schw√∂re nicht auf den Hash aller Klassen in einem Modul. </font><font style="vertical-align: inherit;">Ganz am Ende des Handbuchs werden wir diese Tr√ºmmer harken.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schritt 9. Die Basisklasse des Besuchers, der mit Textdateien arbeitet </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In dieser Phase erstellen wir die Basisklasse des Besuchers, der wei√ü, wie man mit Textdateien arbeitet. Es gibt drei M√∂glichkeiten, mit Dateien im Objektpascal zu arbeiten: alte Prozeduren aus der Zeit des ersten Pascal (wie AssignFile und ReadLn), Streams (TStringStream oder TFileStream) und das TStringList-Objekt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn die erste Methode sehr veraltet ist, sind die zweite und dritte eine gute Alternative, die auf OOP basiert. </font><font style="vertical-align: inherit;">Gleichzeitig bietet das Arbeiten mit Streams zus√§tzliche Vorteile wie die M√∂glichkeit, Daten zu komprimieren und zu verschl√ºsseln. Das zeilenweise Lesen und Schreiben in einen Stream ist in unserem Beispiel jedoch eine Art Redundanz. </font><font style="vertical-align: inherit;">Der Einfachheit halber w√§hlen wir eine TStringList mit zwei einfachen Methoden - LoadFromFile und SaveToFile. </font><font style="vertical-align: inherit;">Denken Sie jedoch daran, dass diese Methoden bei gro√üen Dateien erheblich langsamer werden, sodass der Stream die optimale Wahl f√ºr sie ist. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisFile-Basisklassenschnittstelle:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-title"><span class="hljs-title">TVisFile</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">class</span></span>(TVisitor) <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span>   FList: TStringList;   FFileName: TFileName; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span>;   <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und die Konstruktor- und Destruktor-Implementierung: </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Create; FList := TStringList.Create; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> FileExists(FFileName) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>   FList.LoadFromFile(FFileName); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">destructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Destroy</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FList.SaveToFile(FFileName); FList.Free; <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Wert der FFileName-Eigenschaft wird in den Konstruktoren der Nachkommen dieser Basisklasse zugewiesen (verwenden Sie einfach nicht die hier angeordnete Hardcodierung als Hauptprogrammierstil danach!). </font><font style="vertical-align: inherit;">Das Diagramm der Besucherklassen, die mit Dateien arbeiten </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/717/969/104/717969104d4b13d73ba1844fe0c2ddf9.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, sieht </font><font style="vertical-align: inherit;">wie folgt aus: </font><font style="vertical-align: inherit;">In √úbereinstimmung mit dem folgenden Diagramm erstellen wir zwei Nachkommen der TVisFile-Basisklasse: TVisTXTFile und TVisCSVFile. </font><font style="vertical-align: inherit;">Eine arbeitet mit * .csv-Dateien, in denen Datenfelder durch ein Symbol (Komma) getrennt sind, die zweite mit Textdateien, in denen einzelne Datenfelder eine feste L√§nge pro Zeile haben. </font><font style="vertical-align: inherit;">F√ºr diese Klassen definieren wir die Konstruktoren nur wie folgt neu:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisCSVFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FFileName := <span class="hljs-string"><span class="hljs-string">'contacts.csv'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Create; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisTXTFile</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Create</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> FFileName := <span class="hljs-string"><span class="hljs-string">'contacts.txt'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">inherited</span></span> Create; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>.</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schritt 10. F√ºgen Sie den Visitor-Handler f√ºr Textdateien hinzu </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hier werden wir zwei spezifische Besucher hinzuf√ºgen, einer liest eine Textdatei, der zweite schreibt darauf. </font><font style="vertical-align: inherit;">Der lesende Besucher muss die Methoden AcceptVisitor und Execute base class √ºberschreiben. </font><font style="vertical-align: inherit;">AcceptVisitor √ºberpr√ºft, ob das TPeople-Klassenobjekt an den Besucher √ºbergeben wird:</font></font><br><br><pre> <code class="delphi hljs">Result := pVisited <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> TPeople;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Ausf√ºhrungsimplementierung ist wie folgt: </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisTXtRead</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; lData: TPerson; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> AcceptVisitor(pVisited) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">Exit</span></span>; <span class="hljs-comment"><span class="hljs-comment">//==&gt; TPeople(pVisited).Clear; for i := 0 to FList.Count - 1 do begin   lData := TPerson.Create;   lData.Name := Trim(Copy(FList.Strings[i], 1, 20));   lData.EMailAdrs := Trim(Copy(FList.Strings[i], 21, 80));   TPeople(pVisited).Add(lData); end; end;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Besucher l√∂scht zuerst die Liste des TPeople-Objekts, das ihm vom Parameter √ºbergeben wurde, liest dann die Zeilen aus seinem TStringList-Objekt, in das der Inhalt der Datei geladen wird, erstellt in jeder Zeile ein TPerson-Objekt und f√ºgt es der TPeople-Containerliste hinzu. </font><font style="vertical-align: inherit;">Der Einfachheit halber sind die Eigenschaften name und emailadrs in der Textdatei durch Leerzeichen getrennt.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Datensatzbesucher implementiert die inverse Operation. Sein Konstruktor (√ºberschrieben) l√∂scht die interne TStringList (d. H. F√ºhrt die FList.Clear-Operation aus; sie ist nach der Vererbung obligatorisch). AcceptVisitor √ºberpr√ºft, ob das TPerson-Klassenobjekt √ºbergeben wurde. Dies ist kein Fehler, sondern ein wichtiger Unterschied zu derselben Besuchermethode. Es scheint einfacher zu sein, die Aufzeichnung auf dieselbe Weise zu implementieren: Scannen Sie alle Containerobjekte, f√ºgen Sie sie einer StringList hinzu und speichern Sie sie dann in einer Datei. All dies war so, wenn wir wirklich √ºber das endg√ºltige Schreiben von Daten in eine Datei sprachen, wir jedoch planen, Daten einer relationalen Datenbank zuzuordnen, sollte dies beachtet werden. In diesem Fall sollten wir den SQL-Code nur f√ºr die Objekte ausf√ºhren, die ge√§ndert (erstellt, gel√∂scht oder bearbeitet) wurden. Aus diesem Grund, bevor der Besucher eine Operation an dem Objekt ausf√ºhrt,er muss die Korrespondenz seines Typs √ºberpr√ºfen:</font></font><br><br><pre> <code class="delphi hljs">Result := pVisited <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Tperson;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Die Methode execute f√ºgt der internen StringList einfach eine Zeichenfolge hinzu, die mit der angegebenen Regel formatiert ist: Zuerst der Inhalt der Eigenschaft name des √ºbergebenen Objekts, aufgef√ºllt mit Leerzeichen mit bis zu 20 Zeichen, dann der Inhalt der Eigenschaft emaiadrs: </font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisTXTSave</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> AcceptVisitor(pVisited) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; FList.Add(PadRight(TPerson(pVisited).<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span>,<span class="hljs-number"><span class="hljs-number">20</span></span>)+PadRight(TPerson(pVisited).EMailAdrs,<span class="hljs-number"><span class="hljs-number">60</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schritt 11. F√ºgen Sie den Visitor-Handler f√ºr CSV-Dateien hinzu </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Besucher des Lesens und Schreibens sind in fast allen Kollegen aus TXT-Klassen √§hnlich, mit Ausnahme der Art und Weise, wie die letzte Zeile einer Datei formatiert wird: Im CSV-Standard werden Eigenschaftswerte durch Kommas getrennt. </font><font style="vertical-align: inherit;">Um Zeilen zu lesen und in Eigenschaften zu analysieren, verwenden wir die ExtractDelimited-Funktion aus dem Strutils-Modul. Das Schreiben erfolgt durch einfaches Verketten der Zeilen:</font></font><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisCSVRead</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i: integer; lData: TPerson; <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> AcceptVisitor(pVisited) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; TPeople(pVisited).Clear; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> FList.Count - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span>   lData := TPerson.Create;   lData.<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> := ExtractDelimited(<span class="hljs-number"><span class="hljs-number">1</span></span>, FList.Strings[i], [<span class="hljs-string"><span class="hljs-string">','</span></span>]);   lData.EMailAdrs := ExtractDelimited(<span class="hljs-number"><span class="hljs-number">2</span></span>, FList.Strings[i], [<span class="hljs-string"><span class="hljs-string">','</span></span>]);   TPeople(pVisited).Add(lData); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TVisCSVSave</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(pVisited: TVisited)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> AcceptVisitor(pVisited) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">exit</span></span>; FList.Add(TPerson(pVisited).<span class="hljs-keyword"><span class="hljs-keyword">Name</span></span> + <span class="hljs-string"><span class="hljs-string">','</span></span> + TPerson(pVisited).EMailAdrs); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir m√ºssen nur noch neue Besucher im Manager registrieren und den Betrieb der Anwendung √ºberpr√ºfen. </font><font style="vertical-align: inherit;">F√ºgen Sie im Handler f√ºr die Formularerstellung den folgenden Code hinzu:</font></font><br><br><pre> <code class="delphi hljs">VM.RegisterVisitor(<span class="hljs-string"><span class="hljs-string">'readTXT'</span></span>, TVisTXTRead); VM.RegisterVisitor(<span class="hljs-string"><span class="hljs-string">'saveTXT'</span></span>,TVisTXTSave); VM.RegisterVisitor(<span class="hljs-string"><span class="hljs-string">'readCSV'</span></span>,TVisCSVRead); VM.RegisterVisitor(<span class="hljs-string"><span class="hljs-string">'saveCSV'</span></span>,TVisCSVSave);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Docken Sie die erforderlichen Schaltfl√§chen im Formular an und weisen Sie ihnen die entsprechenden Handler zu: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/112/0c2/7c3/1120c27c31300af40162387ac222d33c.png"><br><br><pre> <code class="delphi hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadCSVbtnClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> VM.Execute(<span class="hljs-string"><span class="hljs-string">'readCSV'</span></span>, FPeople); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadTXTbtnClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> VM.Execute(<span class="hljs-string"><span class="hljs-string">'readTXT'</span></span>, FPeople); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SaveCSVbtnClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> VM.Execute(<span class="hljs-string"><span class="hljs-string">'saveCSV'</span></span>, FPeople); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">procedure</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TForm1</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SaveTXTbtnClick</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Sender: TObject)</span></span></span><span class="hljs-function">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">begin</span></span> VM.Execute(<span class="hljs-string"><span class="hljs-string">'saveTXT'</span></span>, FPeople); <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>;</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zus√§tzliche Dateiformate zum Speichern von Daten werden implementiert, indem einfach die entsprechenden Besucher hinzugef√ºgt und im Manager registriert werden. </font><font style="vertical-align: inherit;">Beachten Sie Folgendes: Wir haben die Befehle absichtlich anders benannt, dh saveTXT und saveCSV. </font><font style="vertical-align: inherit;">Wenn beide Besucher mit einem Speicherbefehl √ºbereinstimmen, starten beide mit demselben Befehl. √úberpr√ºfen Sie dies selbst.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Schritt 12. Endg√ºltige Codebereinigung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Sch√∂nheit und Reinheit des Codes zu erh√∂hen und ein Projekt f√ºr die Weiterentwicklung der Interaktion mit dem DBMS vorzubereiten, werden wir unsere Klassen entsprechend der Logik und ihrem Zweck in verschiedene Module verteilen. </font><font style="vertical-align: inherit;">Letztendlich sollten wir die folgende Struktur von Modulen im Projektordner haben, die es uns erm√∂glicht, auf eine kreisf√∂rmige Beziehung zwischen ihnen zu verzichten (ordnen Sie beim Zusammenstellen die erforderlichen Module in Verwendungsabschnitten an):</font></font><br><br><table><tbody><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modul </font></font><br></td><td>  Funktion <br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klassen </font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tivisitor.pas </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Basisklassen der Besucher- und Manager-Vorlage </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisitor </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisited </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisMapping </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TtiVisitorManager</font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> tiobject.pas </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Basisgesch√§ftslogikklassen </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TtiObject </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TtiObjectList</font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> people_BOM.pas </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Spezifische Gesch√§ftslogikklassen </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TPerson </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TPeople</font></font><br></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> people_SRV.pas </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konkrete Klassen, die f√ºr die Interaktion verantwortlich sind </font></font><br></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisFile </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisTXTFile </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisCSVFile </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisCSVSave </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisCSVRead </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisTXTSave </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">TVisTXTRead</font></font><br></td></tr></tbody></table><br><h3>  Fazit </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In diesem Artikel haben wir das Problem der Iteration √ºber eine Sammlung oder Liste von Objekten untersucht, die unterschiedliche Typen haben k√∂nnen. </font><font style="vertical-align: inherit;">Wir haben die von GoF vorgeschlagene Besuchervorlage verwendet, um zwei verschiedene Methoden zum Zuordnen von Daten von Objekten zu Dateien unterschiedlicher Formate optimal zu implementieren. </font><font style="vertical-align: inherit;">Gleichzeitig k√∂nnen durch die Erstellung des Besuchermanagers verschiedene Methoden von einem Team ausgef√ºhrt werden. </font><font style="vertical-align: inherit;">Letztendlich helfen uns die einfachen und anschaulichen Beispiele, die im Artikel diskutiert werden, ein √§hnliches System f√ºr die Zuordnung von Objekten zu einer relationalen Datenbank weiterzuentwickeln. </font></font><br><br> <i><b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Archiv mit Quellcode von Beispielen - hier</font></font></a></b></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de441266/">https://habr.com/ru/post/de441266/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de441254/index.html">Seminar ‚ÄûWarum wir mit Kubernetes in Kontakt getreten sind und was wir davon haben‚Äú, 28. Februar, Moskau</a></li>
<li><a href="../de441258/index.html">Voll funktionsf√§higes dynamisches Tracing unter Linux mit eBPF und bpftrace</a></li>
<li><a href="../de441260/index.html">Wie neuronale Netzwerkgrafiken geholfen haben</a></li>
<li><a href="../de441262/index.html">Einfache und lange Aufgaben beseitigen Kandidaten besser als kurze und komplexe</a></li>
<li><a href="../de441264/index.html">Kibana Benutzerhandbuch. Visualisierung. Teil 2</a></li>
<li><a href="../de441268/index.html">Ceedling + Eclipse oder Unit-Tests f√ºr Mikrocontroller</a></li>
<li><a href="../de441270/index.html">Schauen Sie sich zuerst Apples FoundationDB an</a></li>
<li><a href="../de441274/index.html">Wie man ein Tester wird - die notwendigen Kenntnisse und F√§higkeiten</a></li>
<li><a href="../de441278/index.html">So erstellen Sie eine sch√∂ne Farbpalette</a></li>
<li><a href="../de441280/index.html">GAL-Setup in der Zimbra Collaboration Suite</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>