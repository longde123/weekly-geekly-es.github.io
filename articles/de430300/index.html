<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèæ‚Äçü§ù‚Äçüßëüèæ üî£ üèîÔ∏è Microservices on Go mit dem Go-Kit: Einf√ºhrung üçö üñãÔ∏è üë®‚Äçüíº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werde ich die Verwendung des Go-Kits beschreiben, einer Reihe von Tools und Bibliotheken zum Erstellen von Microservices unter Go. D...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Microservices on Go mit dem Go-Kit: Einf√ºhrung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430300/"><p>  In diesem Artikel werde ich die Verwendung des Go-Kits beschreiben, einer Reihe von Tools und Bibliotheken zum Erstellen von Microservices unter Go.  Dieser Artikel ist eine Einf√ºhrung in das Go-Kit.  Der erste Teil meines Blogs, der Quellcode f√ºr die Beispiele, ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> verf√ºgbar. </p><a name="habracut"></a><br><p> Go wird zunehmend f√ºr die Entwicklung moderner verteilter Systeme ausgew√§hlt.  Wenn Sie ein Cloud-basiertes verteiltes System entwickeln, m√ºssen Sie m√∂glicherweise verschiedene spezifische Funktionen in Ihren Diensten unterst√ºtzen, z <em>. B</em> .: Verschiedene Transportprotokolle ( <em>usw., √ºbersetzt HTTP, gRPC usw.</em> ) und Nachrichtenkodierungsformate f√ºr diese, RPC-Zuverl√§ssigkeit, Protokollierung , Ablaufverfolgung, Metriken und Profilerstellung, Unterbrechen von Anforderungen, Begrenzen der Anzahl von Anforderungen, Integration in die Infrastruktur und sogar Beschreiben der Architektur.  Go ist aufgrund seiner Einfachheit und seiner ‚ÄûNo Magic‚Äú -Ans√§tze eine beliebte Sprache. Daher eignen sich Go-Pakete, beispielsweise eine Standardbibliothek, bereits besser f√ºr die Entwicklung verteilter Systeme als die Verwendung eines vollwertigen Frameworks mit viel ‚ÄûMagic under the Hood‚Äú.  Pers√∂nlich habe ich [ <em>ca.</em>  <em>trans.</em>  <em>Shiju Varghese</em> ] Ich unterst√ºtze die Verwendung vollwertiger Frameworks nicht, ich bevorzuge Bibliotheken, die dem Entwickler mehr Freiheit geben.  Das Go-Kit f√ºllte die L√ºcke im Go-√ñkosystem und erm√∂glichte die Verwendung einer Reihe von Bibliotheken und Paketen beim Erstellen von Microservices, die wiederum die Verwendung guter Prinzipien f√ºr das Entwerfen einzelner Dienste in verteilten Systemen erm√∂glichen. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0d0/826/505/0d082650579f840f84d034c10c48e013.png" alt="Bild"></p><br><h3 id="vvedenie-v-go-kit">  Einf√ºhrung in das Go-Kit </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Go-Kit</a> besteht aus einer Reihe von Go-Paketen, mit denen sich auf einfache Weise zuverl√§ssige und unterst√ºtzte Microservices erstellen lassen.  Das Go-Kit bietet Bibliotheken zum Implementieren verschiedener Komponenten einer transparenten und zuverl√§ssigen Anwendungsarchitektur unter Verwendung von Ebenen wie Protokollierung, Metriken, Ablaufverfolgung, Begrenzung und Unterbrechung von Anforderungen, die zum Ausf√ºhren von Microservices auf dem Produkt erforderlich sind.  Das Go-Kit ist gut, da es gut implementierte Tools f√ºr die Interaktion mit verschiedenen Infrastrukturen, Nachrichtenkodierungsformaten und verschiedenen Transportschichten enth√§lt. </p><br><p>  Zus√§tzlich zu den Bibliotheken f√ºr Dienste in Entwicklungsl√§ndern bietet und f√∂rdert es die Verwendung guter Prinzipien f√ºr die Gestaltung der Architektur Ihrer Dienste.  Mit dem Go-Kit k√∂nnen Sie die SOLID-Prinzipien, den von <em>Alistair Cockburn</em> vorgeschlagenen themenorientierten Ansatz (DDD) und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hexagonale Architektur</a> oder einen anderen Ansatz aus den von <em>Jeffrey Palermo</em> als ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zwiebelarchitektur</a> ‚Äú und von <em>Robert C. Martin</em> als ‚Äû <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">saubere Architektur</a> ‚Äú bekannten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Architekturprinzipien</a> einhalten.  Obwohl das Go-Kit als Paket f√ºr die Entwicklung von Microservices konzipiert wurde, eignet es sich auch f√ºr die Entwicklung eleganter Monolithen. </p><br><h3 id="arhitektura-go-kit">  Architektur Go Kit </h3><br><p>  Die drei Hauptebenen in der Architektur von Anwendungen, die mit dem Go-Kit entwickelt wurden, sind: </p><br><ul><li>  Transportniveau </li><li>  Endpunktebene </li><li>  Service Level </li></ul><br><h4 id="transportnyy-uroven">  Transportniveau </h4><br><p>  Wenn Sie Microservices f√ºr verteilte Systeme schreiben, m√ºssen die darin enthaltenen Dienste h√§ufig √ºber verschiedene Transportprotokolle wie HTTP oder gRPC miteinander kommunizieren oder Pub / Sub-Systeme wie NATS verwenden.  Die Transportschicht im Go-Kit ist an ein bestimmtes Transportprotokoll gebunden (im Folgenden: Transport).  Das Go-Kit unterst√ºtzt verschiedene Transporte f√ºr Ihren Dienst, z. B. HTTP, gRPC, NATS, AMQP und Thirft ( <em>ca. Sie k√∂nnen auch Ihren eigenen Transport f√ºr Ihr Protokoll entwickeln</em> ).  Daher konzentrieren sich Services, die mit dem Go-Kit geschrieben wurden, h√§ufig auf die Implementierung einer bestimmten Gesch√§ftslogik, die nichts √ºber den verwendeten Transport wei√ü. Sie k√∂nnen verschiedene Transporte f√ºr denselben Service verwenden.  Beispielsweise kann ein in Go Kit geschriebener Dienst gleichzeitig √ºber HTTP und gRPC Zugriff darauf gew√§hren. </p><br><h4 id="endpointy">  Endpunkte </h4><br><p>  Ein Endpunkt oder Endpunkt ist der grundlegende Baustein f√ºr Services und Kunden.  Im Go-Kit ist das Hauptkommunikationsmuster RPC.  Der Endpunkt wird als separate RPC-Methode dargestellt.  Jede Dienstmethode im Go-Kit wird in einen Endpunkt konvertiert, sodass Sie im RCP-Stil zwischen Server und Client kommunizieren k√∂nnen.  Jeder Endpunkt stellt eine Dienstmethode unter Verwendung der Transportschicht bereit, die wiederum verschiedene Transportprotokolle wie HTTP oder gRPC verwendet.  Ein separater Endpunkt kann √ºber mehrere Transporte gleichzeitig aus dem Dienst entfernt werden ( <em>ca. Lane HTTP und gRPC an verschiedenen Ports</em> ). </p><br><h4 id="servisy">  Dienstleistungen </h4><br><p>  Gesch√§ftslogik ist in der Serviceschicht implementiert.  Mit dem Go-Kit geschriebene Dienste sind als Schnittstellen konzipiert.  Die Gesch√§ftslogik in der Serviceschicht enth√§lt den Hauptkern der Gesch√§ftslogik, die nichts √ºber die verwendeten Endpunkte oder ein bestimmtes Transportprotokoll wie HTTP oder gRPC oder √ºber das Codieren oder Decodieren von Anforderungen und Antworten verschiedener Nachrichtentypen wissen muss.  Auf diese Weise k√∂nnen Sie bei Diensten, die mit dem Go-Kit geschrieben wurden, eine saubere Architektur einhalten.  Jede Servicemethode wird mithilfe eines Adapters in einen Endpunkt konvertiert und mithilfe eines bestimmten Transports au√üerhalb verf√ºgbar gemacht.  Durch die Verwendung einer sauberen Architektur kann eine einzelne Methode mit mehreren Transporten gleichzeitig festgelegt werden. </p><br><h3 id="primery">  Beispiele </h3><br><p>  Schauen wir uns nun die oben beschriebenen Ebenen anhand eines Beispiels einer einfachen Anwendung an. </p><br><h4 id="biznes-logika-v-servise">  Gesch√§ftslogik im Service </h4><br><p>  Die Gesch√§ftslogik im Service wird mithilfe von Schnittstellen entworfen.  Wir werden uns ein Beispiel f√ºr eine Bestellung im E-Commerce ansehen: </p><br><pre><code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Service describes the Order service. type Service interface { Create(ctx context.Context, order Order) (string, error) GetByID(ctx context.Context, id string) (Order, error) ChangeStatus(ctx context.Context, id string, status string) error }</span></span></code> </pre> <br><p>  Die Order Service-Schnittstelle funktioniert mit der Order Domain Entity: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Order represents an order type Order struct { ID string `json:"id,omitempty"` CustomerID string `json:"customer_id"` Status string `json:"status"` CreatedOn int64 `json:"created_on,omitempty"` RestaurantId string `json:"restaurant_id"` OrderItems []OrderItem `json:"order_items,omitempty"` } // OrderItem represents items in an order type OrderItem struct { ProductCode string `json:"product_code"` Name string `json:"name"` UnitPrice float32 `json:"unit_price"` Quantity int32 `json:"quantity"` } // Repository describes the persistence on order model type Repository interface { CreateOrder(ctx context.Context, order Order) error GetOrderByID(ctx context.Context, id string) (Order, error) ChangeOrderStatus(ctx context.Context, id string, status string) error }</span></span></code> </pre> <br><p>  Hier implementieren wir die Schnittstelle des Bestellservices: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> implementation <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-string"><span class="hljs-string">"database/sql"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/log"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/log/level"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/gofrs/uuid"</span></span> ordersvc <span class="hljs-string"><span class="hljs-string">"github.com/shijuvar/gokit-examples/services/order"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// service implements the Order Service type service struct { repository ordersvc.Repository logger log.Logger } // NewService creates and returns a new Order service instance func NewService(rep ordersvc.Repository, logger log.Logger) ordersvc.Service { return &amp;service{ repository: rep, logger: logger, } } // Create makes an order func (s *service) Create(ctx context.Context, order ordersvc.Order) (string, error) { logger := log.With(s.logger, "method", "Create") uuid, _ := uuid.NewV4() id := uuid.String() order.ID = id order.Status = "Pending" order.CreatedOn = time.Now().Unix() if err := s.repository.CreateOrder(ctx, order); err != nil { level.Error(logger).Log("err", err) return "", ordersvc.ErrCmdRepository } return id, nil } // GetByID returns an order given by id func (s *service) GetByID(ctx context.Context, id string) (ordersvc.Order, error) { logger := log.With(s.logger, "method", "GetByID") order, err := s.repository.GetOrderByID(ctx, id) if err != nil { level.Error(logger).Log("err", err) if err == sql.ErrNoRows { return order, ordersvc.ErrOrderNotFound } return order, ordersvc.ErrQueryRepository } return order, nil } // ChangeStatus changes the status of an order func (s *service) ChangeStatus(ctx context.Context, id string, status string) error { logger := log.With(s.logger, "method", "ChangeStatus") if err := s.repository.ChangeOrderStatus(ctx, id, status); err != nil { level.Error(logger).Log("err", err) return ordersvc.ErrCmdRepository } return nil }</span></span></code> </pre> <br><h4 id="zaprosy-i-otvety-dlya-rpc-endpointov">  Anfragen und Antworten f√ºr RPC-Endpunkte </h4><br><p>  Dienstmethoden werden als RPC-Endpunkte verf√ºgbar gemacht.  Daher m√ºssen wir die Nachrichtentypen ( <em>ca. Per. DTO - Daten√ºbertragungsobjekt</em> ) bestimmen, die zum Senden und Empfangen von Nachrichten √ºber RPC-Endpunkte verwendet werden.  Definieren wir nun Strukturen f√ºr Anforderungs- und Antworttypen f√ºr RPC-Endpunkte im Bestellservice: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// CreateRequest holds the request parameters for the Create method. type CreateRequest struct { Order order.Order } // CreateResponse holds the response values for the Create method. type CreateResponse struct { ID string `json:"id"` Err error `json:"error,omitempty"` } // GetByIDRequest holds the request parameters for the GetByID method. type GetByIDRequest struct { ID string } // GetByIDResponse holds the response values for the GetByID method. type GetByIDResponse struct { Order order.Order `json:"order"` Err error `json:"error,omitempty"` } // ChangeStatusRequest holds the request parameters for the ChangeStatus method. type ChangeStatusRequest struct { ID string `json:"id"` Status string `json:"status"` } // ChangeStatusResponse holds the response values for the ChangeStatus method. type ChangeStatusResponse struct { Err error `json:"error,omitempty"` }</span></span></code> </pre> <br><h4 id="endpointy-go-kit-dlya-metodov-servisa-kak-rpc-endpointy">  Go-Kit-Endpunkte f√ºr Servicemethoden wie RPC-Endpunkte </h4><br><p>  Der Kern unserer Gesch√§ftslogik wird vom Rest des Codes getrennt und in die Serviceschicht eingef√ºgt, die mithilfe von RPC-Endpunkten verf√ºgbar gemacht wird, die die Go-Kit-Abstraktion namens <code>Endpoint</code> . </p><br><p>  So sieht der Endpunkt aus dem Go-Kit aus: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Endpoint <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, request </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, err error)</span></span></span></span></code> </pre> <br><p>  Wie oben erw√§hnt, stellt der Endpunkt eine separate RPC-Methode dar.  Jede Servicemethode wird mithilfe von Adaptern in <code>endpoint.Endpoint</code> konvertiert.  Lassen Sie uns Go-Kit-Endpunkte f√ºr Bestelldienstmethoden erstellen: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/endpoint"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/shijuvar/gokit-examples/services/order"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// Endpoints holds all Go kit endpoints for the Order service. type Endpoints struct { Create endpoint.Endpoint GetByID endpoint.Endpoint ChangeStatus endpoint.Endpoint } // MakeEndpoints initializes all Go kit endpoints for the Order service. func MakeEndpoints(s order.Service) Endpoints { return Endpoints{ Create: makeCreateEndpoint(s), GetByID: makeGetByIDEndpoint(s), ChangeStatus: makeChangeStatusEndpoint(s), } } func makeCreateEndpoint(s order.Service) endpoint.Endpoint { return func(ctx context.Context, request interface{}) (interface{}, error) { req := request.(CreateRequest) id, err := s.Create(ctx, req.Order) return CreateResponse{ID: id, Err: err}, nil } } func makeGetByIDEndpoint(s order.Service) endpoint.Endpoint { return func(ctx context.Context, request interface{}) (interface{}, error) { req := request.(GetByIDRequest) orderRes, err := s.GetByID(ctx, req.ID) return GetByIDResponse{Order: orderRes, Err: err}, nil } } func makeChangeStatusEndpoint(s order.Service) endpoint.Endpoint { return func(ctx context.Context, request interface{}) (interface{}, error) { req := request.(ChangeStatusRequest) err := s.ChangeStatus(ctx, req.ID, req.Status) return ChangeStatusResponse{Err: err}, nil } }</span></span></code> </pre> <br><p>  Der Endpunktadapter akzeptiert die Schnittstelle als Argument f√ºr die Eingabe und konvertiert sie in eine Abstraktion des Go-Kit- <code>endpoint.Enpoint</code> macht jede einzelne Dienstmethode zu einem Endpunkt.  Diese Adapterfunktion f√ºhrt Vergleichs- und Typkonvertierungen f√ºr Anforderungen durch, ruft eine Dienstmethode auf und gibt eine Antwortnachricht zur√ºck. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeCreateEndpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s order.Service)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">endpoint</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Endpoint</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, request </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { req := request.(CreateRequest) id, err := s.Create(ctx, req.Order) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CreateResponse{ID: id, Err: err}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } }</code> </pre> <br><h4 id="vystavlenie-servisa-naruzhu-s-pomoschyu-http">  Bereitstellen eines Dienstes √ºber HTTP </h4><br><p>  Wir haben unseren Service erstellt und RPC-Endpunkte f√ºr die Bereitstellung unserer Servicemethoden beschrieben.  Jetzt m√ºssen wir unseren Service au√üerhalb ver√∂ffentlichen, damit andere Services RCP-Endpunkte aufrufen k√∂nnen.  Um unseren Service verf√ºgbar zu machen, m√ºssen wir das Transportprotokoll f√ºr unseren Service festlegen, nach dem Anfragen angenommen werden.  Das Go-Kit unterst√ºtzt verschiedene Transporte wie HTTP, gRPC, NATS, AMQP und Thrift. </p><br><p>  Zum Beispiel verwenden wir den HTTP-Transport f√ºr unseren Service.  Das Go-Kit-Paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=http://github.com/go-kit/kit/transport/">github.com/go-kit/kit/transport/http</a> bietet die M√∂glichkeit, HTTP-Anforderungen zu bearbeiten.  Die <code>NewServer</code> Funktion aus dem <code>transport/http</code> Paket erstellt einen neuen http-Server, der <code>http.Handler</code> implementiert und die bereitgestellten Endpunkte <code>http.Handler</code> . </p><br><p>  Im Folgenden finden Sie den Code, der Go-Kit-Endpunkte in einen HTTP-Transport konvertiert, der HTTP-Anforderungen bedient: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> http <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-string"><span class="hljs-string">"encoding/json"</span></span> <span class="hljs-string"><span class="hljs-string">"errors"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/shijuvar/gokit-examples/services/order"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/log"</span></span> kithttp <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/transport/http"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/gorilla/mux"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/shijuvar/gokit-examples/services/order/transport"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( ErrBadRouting = errors.New(<span class="hljs-string"><span class="hljs-string">"bad routing"</span></span>) ) <span class="hljs-comment"><span class="hljs-comment">// NewService wires Go kit endpoints to the HTTP transport. func NewService( svcEndpoints transport.Endpoints, logger log.Logger, ) http.Handler { // set-up router and initialize http endpoints r := mux.NewRouter() options := []kithttp.ServerOption{ kithttp.ServerErrorLogger(logger), kithttp.ServerErrorEncoder(encodeError), } // HTTP Post - /orders r.Methods("POST").Path("/orders").Handler(kithttp.NewServer( svcEndpoints.Create, decodeCreateRequest, encodeResponse, options..., )) // HTTP Post - /orders/{id} r.Methods("GET").Path("/orders/{id}").Handler(kithttp.NewServer( svcEndpoints.GetByID, decodeGetByIDRequest, encodeResponse, options..., )) // HTTP Post - /orders/status r.Methods("POST").Path("/orders/status").Handler(kithttp.NewServer( svcEndpoints.ChangeStatus, decodeChangeStausRequest, encodeResponse, options..., )) return r } func decodeCreateRequest(_ context.Context, r *http.Request) (request interface{}, err error) { var req transport.CreateRequest if e := json.NewDecoder(r.Body).Decode(&amp;req.Order); e != nil { return nil, e } return req, nil } func decodeGetByIDRequest(_ context.Context, r *http.Request) (request interface{}, err error) { vars := mux.Vars(r) id, ok := vars["id"] if !ok { return nil, ErrBadRouting } return transport.GetByIDRequest{ID: id}, nil } func decodeChangeStausRequest(_ context.Context, r *http.Request) (request interface{}, err error) { var req transport.ChangeStatusRequest if e := json.NewDecoder(r.Body).Decode(&amp;req); e != nil { return nil, e } return req, nil } func encodeResponse(ctx context.Context, w http.ResponseWriter, response interface{}) error { if e, ok := response.(errorer); ok &amp;&amp; e.error() != nil { // Not a Go kit transport error, but a business-logic error. // Provide those as HTTP errors. encodeError(ctx, e.error(), w) return nil } w.Header().Set("Content-Type", "application/json; charset=utf-8") return json.NewEncoder(w).Encode(response) }</span></span></code> </pre> <br><p>  Wir erstellen <code>http.Handler</code> mit der <code>NewServer</code> Funktion aus dem <code>transport/http</code> Paket, das Endpunkte und Anforderungsdecodierungsfunktionen (gibt den Wert vom <code>type DecodeRequestFunc func</code> ) und Antwortcodierung (z. B. <code>type EncodeReponseFunc func</code> ) <code>type EncodeReponseFunc func</code> . </p><br><p>  Das Folgende sind Beispiele f√ºr <code>DecodeRequestFunc</code> und <code>EncodeResponseFunc</code> : </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// For decoding request type DecodeRequestFunc func(context.Context, *http.Request) (request interface{}, err error)</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// For encoding response type EncodeResponseFunc func(context.Context, http.ResponseWriter, interface{}) error</span></span></code> </pre> <br><h4 id="zapusk-http-servera">  HTTP-Server starten </h4><br><p>  Schlie√ülich k√∂nnen wir unseren HTTP-Server ausf√ºhren, um Anforderungen zu verarbeiten.  Die <code>NewService</code> beschriebene <code>NewService</code> Funktion implementiert die <code>http.Handler</code> Schnittstelle <code>http.Handler</code> der wir sie als HTTP-Server ausf√ºhren k√∂nnen: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( httpAddr = flag.String(<span class="hljs-string"><span class="hljs-string">"http.addr"</span></span>, <span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-string"><span class="hljs-string">"HTTP listen address"</span></span>) ) flag.Parse() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> logger log.Logger { logger = log.NewLogfmtLogger(os.Stderr) logger = log.NewSyncLogger(logger) logger = level.NewFilter(logger, level.AllowDebug()) logger = log.With(logger, <span class="hljs-string"><span class="hljs-string">"svc"</span></span>, <span class="hljs-string"><span class="hljs-string">"order"</span></span>, <span class="hljs-string"><span class="hljs-string">"ts"</span></span>, log.DefaultTimestampUTC, <span class="hljs-string"><span class="hljs-string">"caller"</span></span>, log.DefaultCaller, ) } level.Info(logger).Log(<span class="hljs-string"><span class="hljs-string">"msg"</span></span>, <span class="hljs-string"><span class="hljs-string">"service started"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> level.Info(logger).Log(<span class="hljs-string"><span class="hljs-string">"msg"</span></span>, <span class="hljs-string"><span class="hljs-string">"service ended"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> db *sql.DB { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> err error <span class="hljs-comment"><span class="hljs-comment">// Connect to the "ordersdb" database db, err = sql.Open("postgres", "postgresql://shijuvar@localhost:26257/ordersdb?sslmode=disable") if err != nil { level.Error(logger).Log("exit", err) os.Exit(-1) } } // Create Order Service var svc order.Service { repository, err := cockroachdb.New(db, logger) if err != nil { level.Error(logger).Log("exit", err) os.Exit(-1) } svc = ordersvc.NewService(repository, logger) } var h http.Handler { endpoints := transport.MakeEndpoints(svc) h = httptransport.NewService(endpoints, logger) } errs := make(chan error) go func() { c := make(chan os.Signal) signal.Notify(c, syscall.SIGINT, syscall.SIGTERM) errs &lt;- fmt.Errorf("%s", &lt;-c) }() go func() { level.Info(logger).Log("transport", "HTTP", "addr", *httpAddr) server := &amp;http.Server{ Addr: *httpAddr, Handler: h, } errs &lt;- server.ListenAndServe() }() level.Error(logger).Log("exit", &lt;-errs) }</span></span></code> </pre> <br><p>  Jetzt wird unser Dienst gestartet und verwendet das HTTP-Protokoll auf Transportebene.  Derselbe Dienst kann mit einem anderen Transport gestartet werden. Beispielsweise kann ein Dienst mit gRPC oder Apache Thrift verf√ºgbar gemacht werden. </p><br><p>  F√ºr den Einf√ºhrungsartikel haben wir bereits genug Go-Kit-Grundelemente verwendet, aber es bietet auch mehr Funktionen zum Erstellen von Systemen mit transparenten, zuverl√§ssigen Mustern, Serviceerkennung, Lastausgleich usw.  Wir werden diese und andere Dinge im Go-Kit in den folgenden Artikeln diskutieren. </p><br><h3 id="ishodnyy-kod">  Quellcode </h3><br><p>  Der gesamte Quellcode f√ºr die Beispiele kann hier auf GitHub eingesehen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden.</a> </p><br><h3 id="middlewares-v-go-kit">  Middleware im Go-Kit </h3><br><p>  Das Go-Kit ist pr√§disponiert f√ºr die Verwendung guter Prinzipien des Systemdesigns, wie z. B. Layering.  Die Isolierung von Servicekomponenten und Endpunkten ist mit Middlewares m√∂glich ( <em>ca. Lane Mediator Pattern</em> ).  Middlewares im Go-Kit bietet einen leistungsstarken Mechanismus, mit dem Sie Dienste und Endpunkte umschlie√üen und Funktionen (isolierte Komponenten) hinzuf√ºgen k√∂nnen, z. B. Protokollierung, Unterbrechung von Anforderungen, Begrenzung der Anzahl von Anforderungen, Lastausgleich oder verteilte Ablaufverfolgung. </p><br><p>  Unten sehen Sie ein Bild von der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Go-Kit-</a> Website, das als typische ‚ÄûZwiebelarchitektur‚Äú mit Middlewares im Go-Kit dargestellt wird: <br><img src="https://habrastorage.org/getpro/habr/post_images/996/daa/da6/996daada64744e2f5b702ca8ea53c19a.png" alt="Bild"></p><br><h3 id="osteregaytes-sindroma-spring-boot-misroservices">  Vorsicht vor dem Spring Boot Microservices Syndrom </h3><br><p>  Wie das Go-Kit ist Spring Boot ein Microservice-Toolkit in der Java-Welt.  Im Gegensatz zum Go-Kit ist Spring Boot jedoch ein sehr ausgereiftes Framework.  Viele Java-Entwickler verwenden Spring Boot, um mithilfe des Java-Stacks World Services mit positivem Feedback aus der Verwendung zu erstellen. Einige von ihnen glauben, dass es bei Microservices nur um die Verwendung von Spring Boot geht.  Ich sehe viele Entwicklungsteams, die die Verwendung von Microservices falsch interpretieren, dass sie nur mit Spring Boot und OSS Netflix entwickelt werden k√∂nnen und Microservices bei der Entwicklung verteilter Systeme nicht als Muster wahrnehmen. </p><br><p>  Denken Sie also daran, dass Sie mit einer Reihe von Tools, wie einem Go-Kit oder einem Framework, Ihre Entwicklung auf Mikroseurises als Entwurfsmuster ausrichten.  Obwohl Microservices viele Skalierungsprobleme sowohl von Befehlen als auch von Systemen l√∂sen, entstehen auch viele Probleme, da die Daten in Microservice-Systemen auf verschiedene Datenbanken verteilt sind, was manchmal viele Probleme beim Erstellen von Transaktions- oder Datenabfragen verursacht.  Es h√§ngt alles vom Problem des Themenbereichs und dem Kontext Ihres Systems ab.  Das Coole ist, dass das Go-Kit, das als Tool zum Erstellen von Microservices entwickelt wurde, auch zum Erstellen eleganter Monolithen geeignet ist, die mit einem guten Architekturdesign f√ºr Ihre Systeme erstellt wurden. </p><br><p>  Einige Funktionen des Go-Kits, z. B. das Unterbrechen und Einschr√§nken von Anforderungen, sind auch auf Service-Mesh-Plattformen wie Istio verf√ºgbar.  Wenn Sie also etwas wie Istio verwenden, um Ihre Mikroseurises zu starten, ben√∂tigen Sie m√∂glicherweise nicht einige Dinge aus dem Go-Kit, aber nicht jeder hat genug Kanalbreite, um das Service-Mesh zum Erstellen einer dienst√ºbergreifenden Kommunikation zu verwenden, da dies mehr hinzuf√ºgt eine Ebene und zus√§tzliche Komplexit√§t. </p><br><h2 id="ps">  PS </h2><br><p>  Der Autor der √úbersetzung teilt m√∂glicherweise nicht die Meinung des Autors des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Originaltextes</a> . Dieser Artikel wurde nur zu Bildungszwecken f√ºr die russische Sprachgemeinschaft Go √ºbersetzt. </p><br><p>  <strong>UPD</strong> <br>  Dies ist auch der erste Artikel im √úbersetzungsbereich und ich w√§re f√ºr jedes Feedback zur √úbersetzung dankbar. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430300/">https://habr.com/ru/post/de430300/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430286/index.html">Details zur chaotischen und dunklen Seite von Piratenspielen f√ºr Nintendo Switch</a></li>
<li><a href="../de430290/index.html">Ein Versuch, die vierte Iteration des SpaceX BFR-Projekts vorherzusagen</a></li>
<li><a href="../de430292/index.html">Electronic Frontier Foundation: Die Netzwerkleistung des US-Polizeikennzeichens betr√§gt 0,5%</a></li>
<li><a href="../de430294/index.html">10 nicht offensichtliche Vorteile der Verwendung von Rust</a></li>
<li><a href="../de430296/index.html">Machen Sie Ihre Ideen App. Serverlose Anwendung - Schritt-f√ºr-Schritt-Anleitung</a></li>
<li><a href="../de430302/index.html">Eine Einf√ºhrung in ptrace oder Code Injection in sshd zum Spa√ü</a></li>
<li><a href="../de430304/index.html">Ein wunderbarer Au√üenposten im Orbit</a></li>
<li><a href="../de430306/index.html">Der erste Tunnel der Boring Company wurde von Ilona Mask gebohrt</a></li>
<li><a href="../de430308/index.html">Python-Interna. Ostereier</a></li>
<li><a href="../de430312/index.html">Validierung komplexer Reaktionsformen. Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>