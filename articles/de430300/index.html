<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧑🏾‍🤝‍🧑🏾 🔣 🏔️ Microservices on Go mit dem Go-Kit: Einführung 🍚 🖋️ 👨‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In diesem Artikel werde ich die Verwendung des Go-Kits beschreiben, einer Reihe von Tools und Bibliotheken zum Erstellen von Microservices unter Go. D...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Microservices on Go mit dem Go-Kit: Einführung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430300/"><p>  In diesem Artikel werde ich die Verwendung des Go-Kits beschreiben, einer Reihe von Tools und Bibliotheken zum Erstellen von Microservices unter Go.  Dieser Artikel ist eine Einführung in das Go-Kit.  Der erste Teil meines Blogs, der Quellcode für die Beispiele, ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> verfügbar. </p><a name="habracut"></a><br><p> Go wird zunehmend für die Entwicklung moderner verteilter Systeme ausgewählt.  Wenn Sie ein Cloud-basiertes verteiltes System entwickeln, müssen Sie möglicherweise verschiedene spezifische Funktionen in Ihren Diensten unterstützen, z <em>. B</em> .: Verschiedene Transportprotokolle ( <em>usw., übersetzt HTTP, gRPC usw.</em> ) und Nachrichtenkodierungsformate für diese, RPC-Zuverlässigkeit, Protokollierung , Ablaufverfolgung, Metriken und Profilerstellung, Unterbrechen von Anforderungen, Begrenzen der Anzahl von Anforderungen, Integration in die Infrastruktur und sogar Beschreiben der Architektur.  Go ist aufgrund seiner Einfachheit und seiner „No Magic“ -Ansätze eine beliebte Sprache. Daher eignen sich Go-Pakete, beispielsweise eine Standardbibliothek, bereits besser für die Entwicklung verteilter Systeme als die Verwendung eines vollwertigen Frameworks mit viel „Magic under the Hood“.  Persönlich habe ich [ <em>ca.</em>  <em>trans.</em>  <em>Shiju Varghese</em> ] Ich unterstütze die Verwendung vollwertiger Frameworks nicht, ich bevorzuge Bibliotheken, die dem Entwickler mehr Freiheit geben.  Das Go-Kit füllte die Lücke im Go-Ökosystem und ermöglichte die Verwendung einer Reihe von Bibliotheken und Paketen beim Erstellen von Microservices, die wiederum die Verwendung guter Prinzipien für das Entwerfen einzelner Dienste in verteilten Systemen ermöglichen. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0d0/826/505/0d082650579f840f84d034c10c48e013.png" alt="Bild"></p><br><h3 id="vvedenie-v-go-kit">  Einführung in das Go-Kit </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Go-Kit</a> besteht aus einer Reihe von Go-Paketen, mit denen sich auf einfache Weise zuverlässige und unterstützte Microservices erstellen lassen.  Das Go-Kit bietet Bibliotheken zum Implementieren verschiedener Komponenten einer transparenten und zuverlässigen Anwendungsarchitektur unter Verwendung von Ebenen wie Protokollierung, Metriken, Ablaufverfolgung, Begrenzung und Unterbrechung von Anforderungen, die zum Ausführen von Microservices auf dem Produkt erforderlich sind.  Das Go-Kit ist gut, da es gut implementierte Tools für die Interaktion mit verschiedenen Infrastrukturen, Nachrichtenkodierungsformaten und verschiedenen Transportschichten enthält. </p><br><p>  Zusätzlich zu den Bibliotheken für Dienste in Entwicklungsländern bietet und fördert es die Verwendung guter Prinzipien für die Gestaltung der Architektur Ihrer Dienste.  Mit dem Go-Kit können Sie die SOLID-Prinzipien, den von <em>Alistair Cockburn</em> vorgeschlagenen themenorientierten Ansatz (DDD) und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hexagonale Architektur</a> oder einen anderen Ansatz aus den von <em>Jeffrey Palermo</em> als „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Zwiebelarchitektur</a> “ und von <em>Robert C. Martin</em> als „ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">saubere Architektur</a> “ bekannten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Architekturprinzipien</a> einhalten.  Obwohl das Go-Kit als Paket für die Entwicklung von Microservices konzipiert wurde, eignet es sich auch für die Entwicklung eleganter Monolithen. </p><br><h3 id="arhitektura-go-kit">  Architektur Go Kit </h3><br><p>  Die drei Hauptebenen in der Architektur von Anwendungen, die mit dem Go-Kit entwickelt wurden, sind: </p><br><ul><li>  Transportniveau </li><li>  Endpunktebene </li><li>  Service Level </li></ul><br><h4 id="transportnyy-uroven">  Transportniveau </h4><br><p>  Wenn Sie Microservices für verteilte Systeme schreiben, müssen die darin enthaltenen Dienste häufig über verschiedene Transportprotokolle wie HTTP oder gRPC miteinander kommunizieren oder Pub / Sub-Systeme wie NATS verwenden.  Die Transportschicht im Go-Kit ist an ein bestimmtes Transportprotokoll gebunden (im Folgenden: Transport).  Das Go-Kit unterstützt verschiedene Transporte für Ihren Dienst, z. B. HTTP, gRPC, NATS, AMQP und Thirft ( <em>ca. Sie können auch Ihren eigenen Transport für Ihr Protokoll entwickeln</em> ).  Daher konzentrieren sich Services, die mit dem Go-Kit geschrieben wurden, häufig auf die Implementierung einer bestimmten Geschäftslogik, die nichts über den verwendeten Transport weiß. Sie können verschiedene Transporte für denselben Service verwenden.  Beispielsweise kann ein in Go Kit geschriebener Dienst gleichzeitig über HTTP und gRPC Zugriff darauf gewähren. </p><br><h4 id="endpointy">  Endpunkte </h4><br><p>  Ein Endpunkt oder Endpunkt ist der grundlegende Baustein für Services und Kunden.  Im Go-Kit ist das Hauptkommunikationsmuster RPC.  Der Endpunkt wird als separate RPC-Methode dargestellt.  Jede Dienstmethode im Go-Kit wird in einen Endpunkt konvertiert, sodass Sie im RCP-Stil zwischen Server und Client kommunizieren können.  Jeder Endpunkt stellt eine Dienstmethode unter Verwendung der Transportschicht bereit, die wiederum verschiedene Transportprotokolle wie HTTP oder gRPC verwendet.  Ein separater Endpunkt kann über mehrere Transporte gleichzeitig aus dem Dienst entfernt werden ( <em>ca. Lane HTTP und gRPC an verschiedenen Ports</em> ). </p><br><h4 id="servisy">  Dienstleistungen </h4><br><p>  Geschäftslogik ist in der Serviceschicht implementiert.  Mit dem Go-Kit geschriebene Dienste sind als Schnittstellen konzipiert.  Die Geschäftslogik in der Serviceschicht enthält den Hauptkern der Geschäftslogik, die nichts über die verwendeten Endpunkte oder ein bestimmtes Transportprotokoll wie HTTP oder gRPC oder über das Codieren oder Decodieren von Anforderungen und Antworten verschiedener Nachrichtentypen wissen muss.  Auf diese Weise können Sie bei Diensten, die mit dem Go-Kit geschrieben wurden, eine saubere Architektur einhalten.  Jede Servicemethode wird mithilfe eines Adapters in einen Endpunkt konvertiert und mithilfe eines bestimmten Transports außerhalb verfügbar gemacht.  Durch die Verwendung einer sauberen Architektur kann eine einzelne Methode mit mehreren Transporten gleichzeitig festgelegt werden. </p><br><h3 id="primery">  Beispiele </h3><br><p>  Schauen wir uns nun die oben beschriebenen Ebenen anhand eines Beispiels einer einfachen Anwendung an. </p><br><h4 id="biznes-logika-v-servise">  Geschäftslogik im Service </h4><br><p>  Die Geschäftslogik im Service wird mithilfe von Schnittstellen entworfen.  Wir werden uns ein Beispiel für eine Bestellung im E-Commerce ansehen: </p><br><pre><code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Service describes the Order service. type Service interface { Create(ctx context.Context, order Order) (string, error) GetByID(ctx context.Context, id string) (Order, error) ChangeStatus(ctx context.Context, id string, status string) error }</span></span></code> </pre> <br><p>  Die Order Service-Schnittstelle funktioniert mit der Order Domain Entity: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// Order represents an order type Order struct { ID string `json:"id,omitempty"` CustomerID string `json:"customer_id"` Status string `json:"status"` CreatedOn int64 `json:"created_on,omitempty"` RestaurantId string `json:"restaurant_id"` OrderItems []OrderItem `json:"order_items,omitempty"` } // OrderItem represents items in an order type OrderItem struct { ProductCode string `json:"product_code"` Name string `json:"name"` UnitPrice float32 `json:"unit_price"` Quantity int32 `json:"quantity"` } // Repository describes the persistence on order model type Repository interface { CreateOrder(ctx context.Context, order Order) error GetOrderByID(ctx context.Context, id string) (Order, error) ChangeOrderStatus(ctx context.Context, id string, status string) error }</span></span></code> </pre> <br><p>  Hier implementieren wir die Schnittstelle des Bestellservices: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> implementation <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-string"><span class="hljs-string">"database/sql"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/log"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/log/level"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/gofrs/uuid"</span></span> ordersvc <span class="hljs-string"><span class="hljs-string">"github.com/shijuvar/gokit-examples/services/order"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// service implements the Order Service type service struct { repository ordersvc.Repository logger log.Logger } // NewService creates and returns a new Order service instance func NewService(rep ordersvc.Repository, logger log.Logger) ordersvc.Service { return &amp;service{ repository: rep, logger: logger, } } // Create makes an order func (s *service) Create(ctx context.Context, order ordersvc.Order) (string, error) { logger := log.With(s.logger, "method", "Create") uuid, _ := uuid.NewV4() id := uuid.String() order.ID = id order.Status = "Pending" order.CreatedOn = time.Now().Unix() if err := s.repository.CreateOrder(ctx, order); err != nil { level.Error(logger).Log("err", err) return "", ordersvc.ErrCmdRepository } return id, nil } // GetByID returns an order given by id func (s *service) GetByID(ctx context.Context, id string) (ordersvc.Order, error) { logger := log.With(s.logger, "method", "GetByID") order, err := s.repository.GetOrderByID(ctx, id) if err != nil { level.Error(logger).Log("err", err) if err == sql.ErrNoRows { return order, ordersvc.ErrOrderNotFound } return order, ordersvc.ErrQueryRepository } return order, nil } // ChangeStatus changes the status of an order func (s *service) ChangeStatus(ctx context.Context, id string, status string) error { logger := log.With(s.logger, "method", "ChangeStatus") if err := s.repository.ChangeOrderStatus(ctx, id, status); err != nil { level.Error(logger).Log("err", err) return ordersvc.ErrCmdRepository } return nil }</span></span></code> </pre> <br><h4 id="zaprosy-i-otvety-dlya-rpc-endpointov">  Anfragen und Antworten für RPC-Endpunkte </h4><br><p>  Dienstmethoden werden als RPC-Endpunkte verfügbar gemacht.  Daher müssen wir die Nachrichtentypen ( <em>ca. Per. DTO - Datenübertragungsobjekt</em> ) bestimmen, die zum Senden und Empfangen von Nachrichten über RPC-Endpunkte verwendet werden.  Definieren wir nun Strukturen für Anforderungs- und Antworttypen für RPC-Endpunkte im Bestellservice: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// CreateRequest holds the request parameters for the Create method. type CreateRequest struct { Order order.Order } // CreateResponse holds the response values for the Create method. type CreateResponse struct { ID string `json:"id"` Err error `json:"error,omitempty"` } // GetByIDRequest holds the request parameters for the GetByID method. type GetByIDRequest struct { ID string } // GetByIDResponse holds the response values for the GetByID method. type GetByIDResponse struct { Order order.Order `json:"order"` Err error `json:"error,omitempty"` } // ChangeStatusRequest holds the request parameters for the ChangeStatus method. type ChangeStatusRequest struct { ID string `json:"id"` Status string `json:"status"` } // ChangeStatusResponse holds the response values for the ChangeStatus method. type ChangeStatusResponse struct { Err error `json:"error,omitempty"` }</span></span></code> </pre> <br><h4 id="endpointy-go-kit-dlya-metodov-servisa-kak-rpc-endpointy">  Go-Kit-Endpunkte für Servicemethoden wie RPC-Endpunkte </h4><br><p>  Der Kern unserer Geschäftslogik wird vom Rest des Codes getrennt und in die Serviceschicht eingefügt, die mithilfe von RPC-Endpunkten verfügbar gemacht wird, die die Go-Kit-Abstraktion namens <code>Endpoint</code> . </p><br><p>  So sieht der Endpunkt aus dem Go-Kit aus: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Endpoint <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, request </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, err error)</span></span></span></span></code> </pre> <br><p>  Wie oben erwähnt, stellt der Endpunkt eine separate RPC-Methode dar.  Jede Servicemethode wird mithilfe von Adaptern in <code>endpoint.Endpoint</code> konvertiert.  Lassen Sie uns Go-Kit-Endpunkte für Bestelldienstmethoden erstellen: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/endpoint"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/shijuvar/gokit-examples/services/order"</span></span> ) <span class="hljs-comment"><span class="hljs-comment">// Endpoints holds all Go kit endpoints for the Order service. type Endpoints struct { Create endpoint.Endpoint GetByID endpoint.Endpoint ChangeStatus endpoint.Endpoint } // MakeEndpoints initializes all Go kit endpoints for the Order service. func MakeEndpoints(s order.Service) Endpoints { return Endpoints{ Create: makeCreateEndpoint(s), GetByID: makeGetByIDEndpoint(s), ChangeStatus: makeChangeStatusEndpoint(s), } } func makeCreateEndpoint(s order.Service) endpoint.Endpoint { return func(ctx context.Context, request interface{}) (interface{}, error) { req := request.(CreateRequest) id, err := s.Create(ctx, req.Order) return CreateResponse{ID: id, Err: err}, nil } } func makeGetByIDEndpoint(s order.Service) endpoint.Endpoint { return func(ctx context.Context, request interface{}) (interface{}, error) { req := request.(GetByIDRequest) orderRes, err := s.GetByID(ctx, req.ID) return GetByIDResponse{Order: orderRes, Err: err}, nil } } func makeChangeStatusEndpoint(s order.Service) endpoint.Endpoint { return func(ctx context.Context, request interface{}) (interface{}, error) { req := request.(ChangeStatusRequest) err := s.ChangeStatus(ctx, req.ID, req.Status) return ChangeStatusResponse{Err: err}, nil } }</span></span></code> </pre> <br><p>  Der Endpunktadapter akzeptiert die Schnittstelle als Argument für die Eingabe und konvertiert sie in eine Abstraktion des Go-Kit- <code>endpoint.Enpoint</code> macht jede einzelne Dienstmethode zu einem Endpunkt.  Diese Adapterfunktion führt Vergleichs- und Typkonvertierungen für Anforderungen durch, ruft eine Dienstmethode auf und gibt eine Antwortnachricht zurück. </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">makeCreateEndpoint</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s order.Service)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">endpoint</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Endpoint</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ctx context.Context, request </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{})</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">interface</span></span></span></span><span class="hljs-function"><span class="hljs-params">{}, error)</span></span></span></span> { req := request.(CreateRequest) id, err := s.Create(ctx, req.Order) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> CreateResponse{ID: id, Err: err}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } }</code> </pre> <br><h4 id="vystavlenie-servisa-naruzhu-s-pomoschyu-http">  Bereitstellen eines Dienstes über HTTP </h4><br><p>  Wir haben unseren Service erstellt und RPC-Endpunkte für die Bereitstellung unserer Servicemethoden beschrieben.  Jetzt müssen wir unseren Service außerhalb veröffentlichen, damit andere Services RCP-Endpunkte aufrufen können.  Um unseren Service verfügbar zu machen, müssen wir das Transportprotokoll für unseren Service festlegen, nach dem Anfragen angenommen werden.  Das Go-Kit unterstützt verschiedene Transporte wie HTTP, gRPC, NATS, AMQP und Thrift. </p><br><p>  Zum Beispiel verwenden wir den HTTP-Transport für unseren Service.  Das Go-Kit-Paket <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=http://github.com/go-kit/kit/transport/">github.com/go-kit/kit/transport/http</a> bietet die Möglichkeit, HTTP-Anforderungen zu bearbeiten.  Die <code>NewServer</code> Funktion aus dem <code>transport/http</code> Paket erstellt einen neuen http-Server, der <code>http.Handler</code> implementiert und die bereitgestellten Endpunkte <code>http.Handler</code> . </p><br><p>  Im Folgenden finden Sie den Code, der Go-Kit-Endpunkte in einen HTTP-Transport konvertiert, der HTTP-Anforderungen bedient: </p><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> http <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-string"><span class="hljs-string">"encoding/json"</span></span> <span class="hljs-string"><span class="hljs-string">"errors"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/shijuvar/gokit-examples/services/order"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/log"</span></span> kithttp <span class="hljs-string"><span class="hljs-string">"github.com/go-kit/kit/transport/http"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/gorilla/mux"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/shijuvar/gokit-examples/services/order/transport"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( ErrBadRouting = errors.New(<span class="hljs-string"><span class="hljs-string">"bad routing"</span></span>) ) <span class="hljs-comment"><span class="hljs-comment">// NewService wires Go kit endpoints to the HTTP transport. func NewService( svcEndpoints transport.Endpoints, logger log.Logger, ) http.Handler { // set-up router and initialize http endpoints r := mux.NewRouter() options := []kithttp.ServerOption{ kithttp.ServerErrorLogger(logger), kithttp.ServerErrorEncoder(encodeError), } // HTTP Post - /orders r.Methods("POST").Path("/orders").Handler(kithttp.NewServer( svcEndpoints.Create, decodeCreateRequest, encodeResponse, options..., )) // HTTP Post - /orders/{id} r.Methods("GET").Path("/orders/{id}").Handler(kithttp.NewServer( svcEndpoints.GetByID, decodeGetByIDRequest, encodeResponse, options..., )) // HTTP Post - /orders/status r.Methods("POST").Path("/orders/status").Handler(kithttp.NewServer( svcEndpoints.ChangeStatus, decodeChangeStausRequest, encodeResponse, options..., )) return r } func decodeCreateRequest(_ context.Context, r *http.Request) (request interface{}, err error) { var req transport.CreateRequest if e := json.NewDecoder(r.Body).Decode(&amp;req.Order); e != nil { return nil, e } return req, nil } func decodeGetByIDRequest(_ context.Context, r *http.Request) (request interface{}, err error) { vars := mux.Vars(r) id, ok := vars["id"] if !ok { return nil, ErrBadRouting } return transport.GetByIDRequest{ID: id}, nil } func decodeChangeStausRequest(_ context.Context, r *http.Request) (request interface{}, err error) { var req transport.ChangeStatusRequest if e := json.NewDecoder(r.Body).Decode(&amp;req); e != nil { return nil, e } return req, nil } func encodeResponse(ctx context.Context, w http.ResponseWriter, response interface{}) error { if e, ok := response.(errorer); ok &amp;&amp; e.error() != nil { // Not a Go kit transport error, but a business-logic error. // Provide those as HTTP errors. encodeError(ctx, e.error(), w) return nil } w.Header().Set("Content-Type", "application/json; charset=utf-8") return json.NewEncoder(w).Encode(response) }</span></span></code> </pre> <br><p>  Wir erstellen <code>http.Handler</code> mit der <code>NewServer</code> Funktion aus dem <code>transport/http</code> Paket, das Endpunkte und Anforderungsdecodierungsfunktionen (gibt den Wert vom <code>type DecodeRequestFunc func</code> ) und Antwortcodierung (z. B. <code>type EncodeReponseFunc func</code> ) <code>type EncodeReponseFunc func</code> . </p><br><p>  Das Folgende sind Beispiele für <code>DecodeRequestFunc</code> und <code>EncodeResponseFunc</code> : </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// For decoding request type DecodeRequestFunc func(context.Context, *http.Request) (request interface{}, err error)</span></span></code> </pre> <br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// For encoding response type EncodeResponseFunc func(context.Context, http.ResponseWriter, interface{}) error</span></span></code> </pre> <br><h4 id="zapusk-http-servera">  HTTP-Server starten </h4><br><p>  Schließlich können wir unseren HTTP-Server ausführen, um Anforderungen zu verarbeiten.  Die <code>NewService</code> beschriebene <code>NewService</code> Funktion implementiert die <code>http.Handler</code> Schnittstelle <code>http.Handler</code> der wir sie als HTTP-Server ausführen können: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( httpAddr = flag.String(<span class="hljs-string"><span class="hljs-string">"http.addr"</span></span>, <span class="hljs-string"><span class="hljs-string">":8080"</span></span>, <span class="hljs-string"><span class="hljs-string">"HTTP listen address"</span></span>) ) flag.Parse() <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> logger log.Logger { logger = log.NewLogfmtLogger(os.Stderr) logger = log.NewSyncLogger(logger) logger = level.NewFilter(logger, level.AllowDebug()) logger = log.With(logger, <span class="hljs-string"><span class="hljs-string">"svc"</span></span>, <span class="hljs-string"><span class="hljs-string">"order"</span></span>, <span class="hljs-string"><span class="hljs-string">"ts"</span></span>, log.DefaultTimestampUTC, <span class="hljs-string"><span class="hljs-string">"caller"</span></span>, log.DefaultCaller, ) } level.Info(logger).Log(<span class="hljs-string"><span class="hljs-string">"msg"</span></span>, <span class="hljs-string"><span class="hljs-string">"service started"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> level.Info(logger).Log(<span class="hljs-string"><span class="hljs-string">"msg"</span></span>, <span class="hljs-string"><span class="hljs-string">"service ended"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> db *sql.DB { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> err error <span class="hljs-comment"><span class="hljs-comment">// Connect to the "ordersdb" database db, err = sql.Open("postgres", "postgresql://shijuvar@localhost:26257/ordersdb?sslmode=disable") if err != nil { level.Error(logger).Log("exit", err) os.Exit(-1) } } // Create Order Service var svc order.Service { repository, err := cockroachdb.New(db, logger) if err != nil { level.Error(logger).Log("exit", err) os.Exit(-1) } svc = ordersvc.NewService(repository, logger) } var h http.Handler { endpoints := transport.MakeEndpoints(svc) h = httptransport.NewService(endpoints, logger) } errs := make(chan error) go func() { c := make(chan os.Signal) signal.Notify(c, syscall.SIGINT, syscall.SIGTERM) errs &lt;- fmt.Errorf("%s", &lt;-c) }() go func() { level.Info(logger).Log("transport", "HTTP", "addr", *httpAddr) server := &amp;http.Server{ Addr: *httpAddr, Handler: h, } errs &lt;- server.ListenAndServe() }() level.Error(logger).Log("exit", &lt;-errs) }</span></span></code> </pre> <br><p>  Jetzt wird unser Dienst gestartet und verwendet das HTTP-Protokoll auf Transportebene.  Derselbe Dienst kann mit einem anderen Transport gestartet werden. Beispielsweise kann ein Dienst mit gRPC oder Apache Thrift verfügbar gemacht werden. </p><br><p>  Für den Einführungsartikel haben wir bereits genug Go-Kit-Grundelemente verwendet, aber es bietet auch mehr Funktionen zum Erstellen von Systemen mit transparenten, zuverlässigen Mustern, Serviceerkennung, Lastausgleich usw.  Wir werden diese und andere Dinge im Go-Kit in den folgenden Artikeln diskutieren. </p><br><h3 id="ishodnyy-kod">  Quellcode </h3><br><p>  Der gesamte Quellcode für die Beispiele kann hier auf GitHub eingesehen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden.</a> </p><br><h3 id="middlewares-v-go-kit">  Middleware im Go-Kit </h3><br><p>  Das Go-Kit ist prädisponiert für die Verwendung guter Prinzipien des Systemdesigns, wie z. B. Layering.  Die Isolierung von Servicekomponenten und Endpunkten ist mit Middlewares möglich ( <em>ca. Lane Mediator Pattern</em> ).  Middlewares im Go-Kit bietet einen leistungsstarken Mechanismus, mit dem Sie Dienste und Endpunkte umschließen und Funktionen (isolierte Komponenten) hinzufügen können, z. B. Protokollierung, Unterbrechung von Anforderungen, Begrenzung der Anzahl von Anforderungen, Lastausgleich oder verteilte Ablaufverfolgung. </p><br><p>  Unten sehen Sie ein Bild von der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Go-Kit-</a> Website, das als typische „Zwiebelarchitektur“ mit Middlewares im Go-Kit dargestellt wird: <br><img src="https://habrastorage.org/getpro/habr/post_images/996/daa/da6/996daada64744e2f5b702ca8ea53c19a.png" alt="Bild"></p><br><h3 id="osteregaytes-sindroma-spring-boot-misroservices">  Vorsicht vor dem Spring Boot Microservices Syndrom </h3><br><p>  Wie das Go-Kit ist Spring Boot ein Microservice-Toolkit in der Java-Welt.  Im Gegensatz zum Go-Kit ist Spring Boot jedoch ein sehr ausgereiftes Framework.  Viele Java-Entwickler verwenden Spring Boot, um mithilfe des Java-Stacks World Services mit positivem Feedback aus der Verwendung zu erstellen. Einige von ihnen glauben, dass es bei Microservices nur um die Verwendung von Spring Boot geht.  Ich sehe viele Entwicklungsteams, die die Verwendung von Microservices falsch interpretieren, dass sie nur mit Spring Boot und OSS Netflix entwickelt werden können und Microservices bei der Entwicklung verteilter Systeme nicht als Muster wahrnehmen. </p><br><p>  Denken Sie also daran, dass Sie mit einer Reihe von Tools, wie einem Go-Kit oder einem Framework, Ihre Entwicklung auf Mikroseurises als Entwurfsmuster ausrichten.  Obwohl Microservices viele Skalierungsprobleme sowohl von Befehlen als auch von Systemen lösen, entstehen auch viele Probleme, da die Daten in Microservice-Systemen auf verschiedene Datenbanken verteilt sind, was manchmal viele Probleme beim Erstellen von Transaktions- oder Datenabfragen verursacht.  Es hängt alles vom Problem des Themenbereichs und dem Kontext Ihres Systems ab.  Das Coole ist, dass das Go-Kit, das als Tool zum Erstellen von Microservices entwickelt wurde, auch zum Erstellen eleganter Monolithen geeignet ist, die mit einem guten Architekturdesign für Ihre Systeme erstellt wurden. </p><br><p>  Einige Funktionen des Go-Kits, z. B. das Unterbrechen und Einschränken von Anforderungen, sind auch auf Service-Mesh-Plattformen wie Istio verfügbar.  Wenn Sie also etwas wie Istio verwenden, um Ihre Mikroseurises zu starten, benötigen Sie möglicherweise nicht einige Dinge aus dem Go-Kit, aber nicht jeder hat genug Kanalbreite, um das Service-Mesh zum Erstellen einer dienstübergreifenden Kommunikation zu verwenden, da dies mehr hinzufügt eine Ebene und zusätzliche Komplexität. </p><br><h2 id="ps">  PS </h2><br><p>  Der Autor der Übersetzung teilt möglicherweise nicht die Meinung des Autors des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Originaltextes</a> . Dieser Artikel wurde nur zu Bildungszwecken für die russische Sprachgemeinschaft Go übersetzt. </p><br><p>  <strong>UPD</strong> <br>  Dies ist auch der erste Artikel im Übersetzungsbereich und ich wäre für jedes Feedback zur Übersetzung dankbar. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430300/">https://habr.com/ru/post/de430300/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430286/index.html">Details zur chaotischen und dunklen Seite von Piratenspielen für Nintendo Switch</a></li>
<li><a href="../de430290/index.html">Ein Versuch, die vierte Iteration des SpaceX BFR-Projekts vorherzusagen</a></li>
<li><a href="../de430292/index.html">Electronic Frontier Foundation: Die Netzwerkleistung des US-Polizeikennzeichens beträgt 0,5%</a></li>
<li><a href="../de430294/index.html">10 nicht offensichtliche Vorteile der Verwendung von Rust</a></li>
<li><a href="../de430296/index.html">Machen Sie Ihre Ideen App. Serverlose Anwendung - Schritt-für-Schritt-Anleitung</a></li>
<li><a href="../de430302/index.html">Eine Einführung in ptrace oder Code Injection in sshd zum Spaß</a></li>
<li><a href="../de430304/index.html">Ein wunderbarer Außenposten im Orbit</a></li>
<li><a href="../de430306/index.html">Der erste Tunnel der Boring Company wurde von Ilona Mask gebohrt</a></li>
<li><a href="../de430308/index.html">Python-Interna. Ostereier</a></li>
<li><a href="../de430312/index.html">Validierung komplexer Reaktionsformen. Teil 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>