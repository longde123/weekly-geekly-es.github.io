<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçü§ù‚Äçüë®üèª üéí ü§ô Sortie de .NET Core 3.0 (Preview 6) ‚ô£Ô∏è üë®‚Äçüë©‚Äçüëß‚Äçüëß ü§∑üèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La semaine derni√®re, .NET Core 3.0 (Preview 6) est sorti . Il comprend des mises √† jour de compilation d'assembly pour am√©liorer le lancement, am√©lior...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sortie de .NET Core 3.0 (Preview 6)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/456218/"><p>  La semaine derni√®re, <a href="" rel="nofollow">.NET Core 3.0 (Preview 6) est sorti</a> .  Il comprend des mises √† jour de compilation d'assembly pour am√©liorer le lancement, am√©liorer l'optimisation de la taille de l'application avec des am√©liorations de l'√©diteur de liens et EventPipe.  Nous avons √©galement publi√© de nouvelles images Docker pour Alpine sur ARM64. </p><br><ul><li><p>  <a href="" rel="nofollow">T√©l√©chargez .NET Core 3.0 (Preview 6)</a> sur Windows, macOS et Linux. </p></li><li><p>  <a href="">Notes de version</a> publi√©es sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dotnet / core</a> .  <a href="">Les diff√©rences d'API entre les aper√ßus 5 et 6 sont</a> √©galement disponibles. </p></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ASP.NET Core</a> et EF Core ont √©galement √©t√© publi√©s la semaine derni√®re. </p></li><li><p>  Si vous avez manqu√©, consultez les mises √† jour pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">.NET Core 3.0 (aper√ßu 5) le</a> mois dernier. </p></li></ul><br><img src="https://habrastorage.org/webt/m8/il/ym/m8ilymhs6vkajgs1wfbpnzud3lw.jpeg"><a name="habracut"></a><br><br><h2>  Mises √† jour WPF et Windows Forms </h2><br><p>  L'√©quipe WPF a compl√®tement termin√© de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">publier la plupart du code WPF sur GitHub</a> .  En fait, ils viennent de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">publier le code source de quinze versions</a> .  Pour ceux qui connaissent WPF, les noms d'assembly doivent √™tre tr√®s familiers. </p><br><p>  Dans certains cas, les tests sont toujours dans le backlog et doivent √™tre publi√©s dans ou avant 3.0 GA.  Cependant, la pr√©sence de tout ce code devrait permettre √† la communaut√© WPF de participer pleinement √† la modification de WPF.  Apr√®s avoir lu certains probl√®mes avec GitHub, il devient √©vident que la communaut√© a son propre backlog de nouveaux produits que vous souhaitez impl√©menter.  Que pensez-vous du sujet sombre? </p><br><h2>  Images Alpine Docker </h2><br><p>  Les images Docker sont d√©sormais disponibles pour .NET Core et ASP.NET Core sur ARM64.  Auparavant, ils n'√©taient disponibles que pour x64. </p><br><p> Les images suivantes peuvent √™tre utilis√©es dans le <code>Dockerfile</code> , ou avec le <code>docker pull</code> , comme illustr√© ci-dessous: </p><br><ul><li> <code>docker pull mcr.microsoft.com/dotnet/core/runtime:3.0-alpine-arm64v8</code> </li> <li> <code>docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0-alpine-arm64v8</code> </li> </ul><br><h2>  Am√©liorations apport√©es aux canaux d'√©v√©nements </h2><br><p>  Event Pipe prend d√©sormais en charge la multisessionnalit√©. </p><br><p>  Nouveaux compteurs de performances ajout√©s: </p><br><ul><li>  % Temps en GC </li><li>  Taille de tas Gen 0 </li><li>  Taille de tas de g√©n√©ration 1 </li><li>  Taille de tas Gen 2 </li><li>  Taille du tas LOH </li><li>  Taux d'allocation </li><li>  Nombre d'ensembles charg√©s </li><li>  Nombre de threads ThreadPool </li><li>  Surveiller le taux de conflit de verrouillage </li><li>  File d'attente des √©l√©ments de travail ThreadPool </li><li>  Taux d'√©l√©ments de travail termin√©s ThreadPool </li></ul><br><p>  Les jointures de profileur sont d√©sormais impl√©ment√©es √† l'aide de la m√™me infrastructure Event Pipe. </p><br><p>  Lisez le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">jeu de comptage</a> de David Fowler pour avoir une id√©e de ce que vous pouvez faire avec le tuyau d'√©v√©nement pour effectuer vos propres recherches de performances ou simplement suivre l'√©tat de l'application. </p><br><p>  Lisez <a href="">dotnet-counters</a> pour installer l'outil dotnet-counters. </p><br><h2>  Optimisez vos applications .NET Core avec les images ReadyToRun </h2><br><p>  Vous pouvez am√©liorer le temps de d√©marrage d'une application .NET Core en compilant les versions d'application au format ReadyToRun (R2R).  R2R est une forme de compilation de premier plan (AOT). </p><br><p>  Les binaires R2R am√©liorent les performances de d√©marrage en r√©duisant la quantit√© de travail que JIT doit faire lors du chargement de l'application.  Les binaires contiennent un code machine similaire √† celui g√©n√©r√© par le JIT, ce qui donne du repos au JIT lorsque les performances sont les plus importantes (au d√©marrage).  Les fichiers binaires au format R2R sont plus volumineux car ils contiennent √† la fois du code de langage interm√©diaire (IL), qui est toujours n√©cessaire pour certains sc√©narios, et une version machine du m√™me code pour am√©liorer le d√©marrage. </p><br><p>  R2R est pris en charge par .NET Core 3.0.  Il ne peut pas √™tre utilis√© avec des versions ant√©rieures de .NET Core. </p><br><h3>  Exemples de chiffres de performance </h3><br><p>  Les figures suivantes pr√©sentent les performances des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemples d'applications WPF</a> .  L'application a √©t√© publi√©e en tant que version autonome et n'a pas utilis√© l'√©diteur de liens d'assembly (abord√© plus loin dans cet article). </p><br><p>  Application IL uniquement: </p><br><ul><li>  Temps de d√©marrage: 1,9 secondes </li><li>  Utilisation de la m√©moire: 69,1 Mo </li><li>  Taille de l'application: 150 Mo </li></ul><br><p>  Avec les images ReadyToRun: </p><br><ul><li>  Temps de d√©marrage: 1,3 seconde. </li><li>  Utilisation de la m√©moire: 55,7 Mo </li><li>  Taille de l'application: 156 Mo </li></ul><br><h2>  En savoir plus sur les images ReadyToRun </h2><br><p>  Vous pouvez compiler R2R √† la fois des biblioth√®ques et des fichiers binaires d'application.  Actuellement, les biblioth√®ques ne peuvent √™tre compil√©es dans R2R que dans le cadre de l'application, et non pour √™tre livr√©es en tant que package NuGet.  Nous aimerions avoir plus de commentaires sur l'importance de ce sc√©nario. </p><br><p>  La compilation des assemblages AOT est depuis longtemps disponible en tant que concept pour .NET, revenant au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">.NET Framework et NGEN</a> .  Un inconv√©nient majeur de NGEN est que la compilation doit √™tre effectu√©e sur les machines clientes √† l'aide de l'outil NGEN.  Il n'est pas possible de g√©n√©rer des images NGEN dans le cadre de la cr√©ation de votre application. </p><br><p>  Maintenant .NET Core.  Il est livr√© avec <a href="">crossgen</a> , qui produit des images de machine au nouveau format <a href="">ReadyToRun</a> .  Le nom d√©crit sa valeur fondamentale, √† savoir que ces images de machine peuvent √™tre cr√©√©es dans le cadre de votre assemblage et sont ¬´pr√™tes √† fonctionner¬ª sans aucun travail suppl√©mentaire sur les machines clientes.  Il s'agit d'une am√©lioration majeure, ainsi que d'une victoire importante dans la lutte contre le changement climatique. </p><br><p>  En termes de compatibilit√©, les images ReadyToRun sont similaires aux assemblys IL avec quelques diff√©rences cl√©s. </p><br><ul><li>  Les assemblys IL contiennent uniquement du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">code IL</a> .  Ils peuvent fonctionner dans n'importe quel environnement d'ex√©cution prenant en charge l'infrastructure cible sp√©cifi√©e pour cet assembly.  Par exemple, la version <code>netstandard2.0</code> peut s'ex√©cuter sur .NET Framework 4.6+ et .NET Core 2.0+, sur n'importe quel syst√®me d'exploitation pris en charge (Windows, macOS, Linux) et architecture (Intel, ARM, 32 bits, 64 bits). </li><li>  Les assemblys R2R contiennent IL et du code natif.  Ils sont compil√©s pour une version minimale sp√©cifique du runtime .NET Core et de l'environnement d'ex√©cution (RID).  par exemple, la version <code>netstandard2.0</code> peut √™tre compil√©e R2R pour .NET Core 3.0 et Linux x64.  Il ne sera utilis√© que dans cette configuration ou dans une configuration compatible (par exemple, .NET Core 3.1 ou .NET Core 5.0 sous Linux x64), car il contient du code natif qui ne peut √™tre utilis√© que dans cet environnement d'ex√©cution. </li></ul><br><h3>  Instructions </h3><br><p>  La compilation ReadyToRun est disponible pour publication uniquement.  La version d'aper√ßu a √©t√© publi√©e dans .NET Core 3.0 (aper√ßu 5). </p><br><p>  Pour activer la compilation ReadyToRun, vous devez: </p><br><ul><li>  D√©finissez la valeur de la propri√©t√© <code>PublishReadyToRun</code> sur <code>true</code> . </li><li>  Publiez en utilisant le <code>RuntimeIdentifier</code> exact. </li></ul><br><p>  Remarque  Lorsque les versions de l'application sont compil√©es, le code natif g√©n√©r√© d√©pend de la plate-forme et de l'architecture (par cons√©quent, lors de la publication, vous devez sp√©cifier un RuntimeIdentifier valide). </p><br><p>  Voici un exemple: </p><br><pre> <code class="cs hljs">&lt;Project Sdk=<span class="hljs-string"><span class="hljs-string">"Microsoft.NET.Sdk"</span></span>&gt; &lt;PropertyGroup&gt; &lt;OutputType&gt;Exe&lt;/OutputType&gt; &lt;TargetFramework&gt;netcoreapp3<span class="hljs-number"><span class="hljs-number">.0</span></span>&lt;/TargetFramework&gt; &lt;PublishReadyToRun&gt;<span class="hljs-literal"><span class="hljs-literal">true</span></span>&lt;/PublishReadyToRun&gt; &lt;/PropertyGroup&gt; &lt;/Project&gt;</code> </pre> <br><p>  Et la publication √† l'aide de la commande suivante: </p><br><pre> <code class="cs hljs">dotnet publish -r win-x64 -c Release</code> </pre> <br><p>  Remarque: <code>RuntimeIdentifier</code> peut √™tre d√©fini dans le fichier de projet. </p><br><p>  Remarque: ReadyToRun n'est actuellement pris en charge que pour les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">applications autonomes</a> .  Il sera ajout√© pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">les applications d√©pendantes</a> du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">framework</a> dans une annonce ult√©rieure. </p><br><p>  La g√©n√©ration de caract√®res d' <code>PublishReadyToRunEmitSymbols</code> peut √™tre activ√©e en d√©finissant la propri√©t√© <code>PublishReadyToRunEmitSymbols</code> sur <code>true</code> .  Vous n'avez pas besoin de cr√©er des caract√®res machine √† des fins de d√©bogage.  Ces caract√®res ne sont utiles qu'√† des fins de profilage. </p><br><p>  Actuellement, le SDK prend en charge un moyen d'exclure certains assemblys de la compilation dans des images ReadyToRun.  Cela peut √™tre utile dans les cas o√π les assemblages n'ont pas besoin d'√™tre optimis√©s pour am√©liorer les performances.  L'exclusion d'assemblys dans ce cas peut aider √† r√©duire la taille de l'application.  Dans le cas o√π le compilateur ReadyToRun ne parvient pas √† compiler un assembly sp√©cifique, la solution peut √©galement √™tre de l'√©liminer. </p><br><p>  Une exception est lev√©e √† l'aide du groupe d'√©l√©ments PublishReadyToRunExclude: </p><br><pre> <code class="cs hljs">&lt;ItemGroup&gt; &lt;PublishReadyToRunExclude Include=<span class="hljs-string"><span class="hljs-string">"FilenameOfAssemblyToExclude.dll"</span></span> /&gt; &lt;/ItemGroup&gt;</code> </pre> <br><h2>  Compilation multiplateforme / architecturale </h2><br><p>  Le compilateur ReadyToRun ne prend pas encore en charge le ciblage crois√©.  Vous devez compiler pour un objectif donn√©.  Par exemple, si vous avez besoin d'images R2R pour Windows x64, vous devez ex√©cuter la commande de publication dans cet environnement. </p><br><p>  Exceptions: </p><br><ul><li>  Windows x64 peut √™tre utilis√© pour compiler des images Windows ARM32, ARM64 et x86. </li><li>  Windows x86 peut √™tre utilis√© pour compiler des images Windows ARM32. </li><li>  Linux x64 peut √™tre utilis√© pour compiler des images Linux ARM32 et ARM64. </li></ul><br><h2>  Disposition de l'assemblage </h2><br><p>  Le SDK NET core 3.0 est livr√© avec un outil qui peut r√©duire la taille des applications en analysant IL et en √©liminant les versions inutilis√©es. </p><br><p>  Avec .NET Core, vous pouvez toujours publier des applications autonomes qui incluent tout ce dont vous avez besoin pour ex√©cuter votre code, sans avoir √† installer .NET sur la cible de d√©ploiement.  Dans certains cas, l'application ne n√©cessite qu'un petit sous-ensemble du cadre, et elle pourrait √™tre beaucoup plus petite en n'incluant que les biblioth√®ques utilis√©es. </p><br><p>  Nous utilisons le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">g√©n√©rateur IL</a> pour analyser l'IL de votre application afin de d√©terminer quel code est r√©ellement requis, puis exclure les biblioth√®ques d'infrastructure inutilis√©es.  Cela peut r√©duire consid√©rablement la taille de certaines applications.  En r√®gle g√©n√©rale, les petites applications de console comme les outils tirent le meilleur parti, car elles utilisent souvent de petits sous-ensembles du cadre et se pr√™tent g√©n√©ralement bien au recadrage. </p><br><p>  Pour utiliser cet outil, d√©finissez <code>PublishTrimmed=true</code> dans votre projet et publiez l'application autonome: </p><br><pre> <code class="cs hljs">dotnet publish -r &lt;rid&gt; -c Release</code> </pre> <br><p>  La sortie de publication comprendra un sous-ensemble des biblioth√®ques d'infrastructure, selon le code d'application qui invoque.  Pour l'application helloworld, l'√©diteur de liens r√©duit la taille de ~ 68 Mo √† ~ 28 Mo. </p><br><p>  Les applications ou les frameworks (y compris ASP.NET Core et WPF) qui utilisent la r√©flexion ou les fonctions dynamiques associ√©es se cassent souvent lors du recadrage car l'√©diteur de liens ignore ce comportement dynamique et ne peut g√©n√©ralement pas d√©terminer quels types de frameworks seront requis pour la r√©flexion lors de l'ex√©cution .  Pour recadrer de telles applications, vous devez indiquer √† l'√©diteur de liens tous les types n√©cessaires √† la r√©flexion dans votre code et dans tous les packages ou environnements dont vous d√©pendez.  Assurez-vous de tester vos applications apr√®s le recadrage. </p><br><p>  Pour plus d'informations sur IL Linker, consultez la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">documentation</a> ou visitez le r√©f√©rentiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mono / linker</a> . </p><br><p>  Remarque: Dans les versions pr√©c√©dentes de .NET Core, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">ILLink.Tasks √©tait</a> fourni en tant que package NuGet externe et offrait la plupart des m√™mes fonctionnalit√©s.  Il n'est plus pris en charge - passez √† la derni√®re version du SDK 3.0. </p><br><h2>  Linker et partage de l'√©diteur de liens ReadToRun </h2><br><p>  Linker Linker et ReadyToRun Linker peuvent √™tre utilis√©s pour la m√™me application.  En g√©n√©ral, l'√©diteur de liens rend votre application plus petite, puis le compilateur pr√™t √† l'emploi la rendra un peu plus grande, mais avec un gain de performances significatif.  Il vaut la peine de tester diff√©rentes configurations pour comprendre l'effet de chaque option. </p><br><p>  Remarque: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dotnet / sdk # 3257</a> emp√™che l'√©diteur de liens et le partage ReadyToRun pour les applications WPF et Windows Forms.  Nous travaillons √† r√©soudre ce probl√®me dans le cadre de la version .NET Core 3.0. </p><br><h2>  Exemple d'h√©bergement natif </h2><br><p>  R√©cemment publi√© un exemple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d'h√©bergement natif</a> .  Il illustre la meilleure approche pour l'h√©bergement de .NET Core dans une application native. </p><br><p>  Dans le cadre de .NET Core 3.0, nous fournissons d√©sormais des fonctionnalit√©s communes √† nos propres services d'h√©bergement .NET Core, qui n'√©taient auparavant disponibles que pour les applications g√©r√©es .NET Core via les services d'h√©bergement .NET Core officiellement fournis.  La fonctionnalit√© est principalement associ√©e au chargement de l'assemblage.  Cette fonctionnalit√© devrait faciliter la cr√©ation de vos propres services d'h√©bergement qui peuvent utiliser la gamme compl√®te des fonctionnalit√©s de .NET Core. </p><br><h2>  Prise en charge HTTP / 2 dans HttpClient </h2><br><p>  HTTP / 2 est la version principale du protocole HTTP.  Certaines des caract√©ristiques notables de HTTP / 2 sont la prise en charge de la compression d'en-t√™te et les flux enti√®rement multiplex√©s sur une seule connexion.  Bien que HTTP / 2 conserve la s√©mantique de HTTP (en-t√™tes HTTP, m√©thodes, etc.), il diff√®re de HTTP / 1.x dans la fa√ßon dont les donn√©es sont envoy√©es. </p><br><p>  <code>HttpClient</code> prend d√©sormais en charge les requ√™tes HTTP / 2.  Par d√©faut, tout reste √©galement HTTP / 1.1, mais vous pouvez le d√©sactiver en faveur de HTTP / 2 en installant la version √† l'aide d'une requ√™te HTTP. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient() { BaseAddress = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"https://localhost:5001"</span></span>) }; <span class="hljs-comment"><span class="hljs-comment">// HTTP/1.1 request using (var response = await client.GetAsync("/")) { Console.WriteLine(response.Content); } // HTTP/2 request using (var request = new HttpRequestMessage(HttpMethod.Get, "/") { Version = new Version(2, 0) }) using (var response = await client.SendAsync(request)) { Console.WriteLine(response.Content); }</span></span></code> </pre> <br><p>  Vous pouvez √©galement envoyer des demandes HTTP / 2 par d√©faut en d√©finissant <code>DefaultRequestVersion</code> sur <code>HttpClient</code> . </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient() { BaseAddress = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"https://localhost:5001"</span></span>), DefaultRequestVersion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Version(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) }; <span class="hljs-comment"><span class="hljs-comment">// Defaults to HTTP/2 using (var response = await client.GetAsync("/")) { Console.WriteLine(response.Content); }</span></span></code> </pre> <br><p>  √Ä la suite de ce changement, les serveurs et les clients doivent se mettre d'accord sur la version de protocole utilis√©e.  ALPN (Application-Layer Protocol Negotiation) est une extension TLS qui permet au serveur et au client de n√©gocier la version du protocole utilis√©e dans le cadre de leur interaction.  Cependant, gardez √† l'esprit que la plupart des serveurs ne prennent en charge ALPN que comme seul moyen d'√©tablir une connexion HTTP / 2.  Ainsi, HTTP / 2 est n√©goci√© par <code>HttpClient</code> uniquement sur la connexion TLS. </p><br><p>  Dans les sc√©narios de d√©veloppement, lorsque le serveur et le client savent a priori qu'ils parleront tous les deux HTTP / 2 sans chiffrement, vous pouvez √©tablir une connexion HTTP / 2 via du texte clair en d√©finissant le commutateur <code>AppContext</code> ou la variable d'environnement.  ( <code>DOTNET_SYSTEM_NET_HTTP_SOCKETSHTTPHANDLER_HTTP2UNENCRYPTEDSUPPORT=1</code> ). </p><br><pre> <code class="cs hljs">AppContext.SetSwitch(<span class="hljs-string"><span class="hljs-string">"System.Net.Http.SocketsHttpHandler.Http2UnencryptedSupport"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br><h2>  Ach√®vement </h2><br><p>  Nous serons tr√®s heureux si vous essayez de nouvelles fonctionnalit√©s.  Veuillez signaler les probl√®mes ou bogues que vous rencontrez.  Vous pouvez √©galement soumettre des demandes de nouvelles fonctionnalit√©s, mais leur mise en ≈ìuvre devra attendre la prochaine version. </p><br><p>  Nous sommes maintenant sur le point d'achever les travaux sur le composant .NET Core 3.0 et nous attirons maintenant l'attention de l'√©quipe sur l'am√©lioration de la qualit√© des versions.  Nous avons des mois √† l'avance pour corriger les bogues et am√©liorer les performances. </p><br><p>  Soit dit en passant, pour la prochaine mise √† jour majeure, nous changerons les branches principales dans les r√©f√©rentiels .NET Core.  Cela se produira tr√®s probablement imm√©diatement apr√®s l'aper√ßu 7 en juillet. </p><br><p>  Merci d'avoir test√© .NET Core 3.0.  Nous appr√©cions votre aide.  En ce moment, nous nous effor√ßons de faire de la version finale la plus int√©ressante et de haute qualit√© pour vous. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr456218/">https://habr.com/ru/post/fr456218/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr456206/index.html">Comment Moovit a am√©lior√© son application pour aider les personnes handicap√©es √† voyager en toute confiance</a></li>
<li><a href="../fr456208/index.html">90 milliards de roubles pour le d√©veloppement de l'intelligence artificielle</a></li>
<li><a href="../fr456210/index.html">Comment une application mobile aide un √©tudiant ayant des probl√®mes de vision √† se d√©placer dans Moscou</a></li>
<li><a href="../fr456214/index.html">Utilisez __main__.py</a></li>
<li><a href="../fr456216/index.html">Faire un jeu r√©tro des ann√©es 80 ou comment faire des maquettes pour la d√©coupe laser</a></li>
<li><a href="../fr456220/index.html">G√©n√©ralisation du probl√®me Brokar</a></li>
<li><a href="../fr456222/index.html">Le g√©nie g√©n√©tique des embryons humains deviendra s√ªr et efficace dans deux ans</a></li>
<li><a href="../fr456224/index.html">Annonce de l'aper√ßu 6 de .NET Core 3.0</a></li>
<li><a href="../fr456226/index.html">Pr√©diction des r√©sultats du football</a></li>
<li><a href="../fr456230/index.html">Iobroker quest for quests in reality games</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>