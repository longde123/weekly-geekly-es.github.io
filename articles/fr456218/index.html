<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🤝‍👨🏻 🎒 🤙 Sortie de .NET Core 3.0 (Preview 6) ♣️ 👨‍👩‍👧‍👧 🤷🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La semaine dernière, .NET Core 3.0 (Preview 6) est sorti . Il comprend des mises à jour de compilation d'assembly pour améliorer le lancement, amélior...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sortie de .NET Core 3.0 (Preview 6)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/456218/"><p>  La semaine dernière, <a href="" rel="nofollow">.NET Core 3.0 (Preview 6) est sorti</a> .  Il comprend des mises à jour de compilation d'assembly pour améliorer le lancement, améliorer l'optimisation de la taille de l'application avec des améliorations de l'éditeur de liens et EventPipe.  Nous avons également publié de nouvelles images Docker pour Alpine sur ARM64. </p><br><ul><li><p>  <a href="" rel="nofollow">Téléchargez .NET Core 3.0 (Preview 6)</a> sur Windows, macOS et Linux. </p></li><li><p>  <a href="">Notes de version</a> publiées sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dotnet / core</a> .  <a href="">Les différences d'API entre les aperçus 5 et 6 sont</a> également disponibles. </p></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ASP.NET Core</a> et EF Core ont également été publiés la semaine dernière. </p></li><li><p>  Si vous avez manqué, consultez les mises à jour pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">.NET Core 3.0 (aperçu 5) le</a> mois dernier. </p></li></ul><br><img src="https://habrastorage.org/webt/m8/il/ym/m8ilymhs6vkajgs1wfbpnzud3lw.jpeg"><a name="habracut"></a><br><br><h2>  Mises à jour WPF et Windows Forms </h2><br><p>  L'équipe WPF a complètement terminé de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">publier la plupart du code WPF sur GitHub</a> .  En fait, ils viennent de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">publier le code source de quinze versions</a> .  Pour ceux qui connaissent WPF, les noms d'assembly doivent être très familiers. </p><br><p>  Dans certains cas, les tests sont toujours dans le backlog et doivent être publiés dans ou avant 3.0 GA.  Cependant, la présence de tout ce code devrait permettre à la communauté WPF de participer pleinement à la modification de WPF.  Après avoir lu certains problèmes avec GitHub, il devient évident que la communauté a son propre backlog de nouveaux produits que vous souhaitez implémenter.  Que pensez-vous du sujet sombre? </p><br><h2>  Images Alpine Docker </h2><br><p>  Les images Docker sont désormais disponibles pour .NET Core et ASP.NET Core sur ARM64.  Auparavant, ils n'étaient disponibles que pour x64. </p><br><p> Les images suivantes peuvent être utilisées dans le <code>Dockerfile</code> , ou avec le <code>docker pull</code> , comme illustré ci-dessous: </p><br><ul><li> <code>docker pull mcr.microsoft.com/dotnet/core/runtime:3.0-alpine-arm64v8</code> </li> <li> <code>docker pull mcr.microsoft.com/dotnet/core/aspnet:3.0-alpine-arm64v8</code> </li> </ul><br><h2>  Améliorations apportées aux canaux d'événements </h2><br><p>  Event Pipe prend désormais en charge la multisessionnalité. </p><br><p>  Nouveaux compteurs de performances ajoutés: </p><br><ul><li>  % Temps en GC </li><li>  Taille de tas Gen 0 </li><li>  Taille de tas de génération 1 </li><li>  Taille de tas Gen 2 </li><li>  Taille du tas LOH </li><li>  Taux d'allocation </li><li>  Nombre d'ensembles chargés </li><li>  Nombre de threads ThreadPool </li><li>  Surveiller le taux de conflit de verrouillage </li><li>  File d'attente des éléments de travail ThreadPool </li><li>  Taux d'éléments de travail terminés ThreadPool </li></ul><br><p>  Les jointures de profileur sont désormais implémentées à l'aide de la même infrastructure Event Pipe. </p><br><p>  Lisez le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">jeu de comptage</a> de David Fowler pour avoir une idée de ce que vous pouvez faire avec le tuyau d'événement pour effectuer vos propres recherches de performances ou simplement suivre l'état de l'application. </p><br><p>  Lisez <a href="">dotnet-counters</a> pour installer l'outil dotnet-counters. </p><br><h2>  Optimisez vos applications .NET Core avec les images ReadyToRun </h2><br><p>  Vous pouvez améliorer le temps de démarrage d'une application .NET Core en compilant les versions d'application au format ReadyToRun (R2R).  R2R est une forme de compilation de premier plan (AOT). </p><br><p>  Les binaires R2R améliorent les performances de démarrage en réduisant la quantité de travail que JIT doit faire lors du chargement de l'application.  Les binaires contiennent un code machine similaire à celui généré par le JIT, ce qui donne du repos au JIT lorsque les performances sont les plus importantes (au démarrage).  Les fichiers binaires au format R2R sont plus volumineux car ils contiennent à la fois du code de langage intermédiaire (IL), qui est toujours nécessaire pour certains scénarios, et une version machine du même code pour améliorer le démarrage. </p><br><p>  R2R est pris en charge par .NET Core 3.0.  Il ne peut pas être utilisé avec des versions antérieures de .NET Core. </p><br><h3>  Exemples de chiffres de performance </h3><br><p>  Les figures suivantes présentent les performances des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemples d'applications WPF</a> .  L'application a été publiée en tant que version autonome et n'a pas utilisé l'éditeur de liens d'assembly (abordé plus loin dans cet article). </p><br><p>  Application IL uniquement: </p><br><ul><li>  Temps de démarrage: 1,9 secondes </li><li>  Utilisation de la mémoire: 69,1 Mo </li><li>  Taille de l'application: 150 Mo </li></ul><br><p>  Avec les images ReadyToRun: </p><br><ul><li>  Temps de démarrage: 1,3 seconde. </li><li>  Utilisation de la mémoire: 55,7 Mo </li><li>  Taille de l'application: 156 Mo </li></ul><br><h2>  En savoir plus sur les images ReadyToRun </h2><br><p>  Vous pouvez compiler R2R à la fois des bibliothèques et des fichiers binaires d'application.  Actuellement, les bibliothèques ne peuvent être compilées dans R2R que dans le cadre de l'application, et non pour être livrées en tant que package NuGet.  Nous aimerions avoir plus de commentaires sur l'importance de ce scénario. </p><br><p>  La compilation des assemblages AOT est depuis longtemps disponible en tant que concept pour .NET, revenant au <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">.NET Framework et NGEN</a> .  Un inconvénient majeur de NGEN est que la compilation doit être effectuée sur les machines clientes à l'aide de l'outil NGEN.  Il n'est pas possible de générer des images NGEN dans le cadre de la création de votre application. </p><br><p>  Maintenant .NET Core.  Il est livré avec <a href="">crossgen</a> , qui produit des images de machine au nouveau format <a href="">ReadyToRun</a> .  Le nom décrit sa valeur fondamentale, à savoir que ces images de machine peuvent être créées dans le cadre de votre assemblage et sont «prêtes à fonctionner» sans aucun travail supplémentaire sur les machines clientes.  Il s'agit d'une amélioration majeure, ainsi que d'une victoire importante dans la lutte contre le changement climatique. </p><br><p>  En termes de compatibilité, les images ReadyToRun sont similaires aux assemblys IL avec quelques différences clés. </p><br><ul><li>  Les assemblys IL contiennent uniquement du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">code IL</a> .  Ils peuvent fonctionner dans n'importe quel environnement d'exécution prenant en charge l'infrastructure cible spécifiée pour cet assembly.  Par exemple, la version <code>netstandard2.0</code> peut s'exécuter sur .NET Framework 4.6+ et .NET Core 2.0+, sur n'importe quel système d'exploitation pris en charge (Windows, macOS, Linux) et architecture (Intel, ARM, 32 bits, 64 bits). </li><li>  Les assemblys R2R contiennent IL et du code natif.  Ils sont compilés pour une version minimale spécifique du runtime .NET Core et de l'environnement d'exécution (RID).  par exemple, la version <code>netstandard2.0</code> peut être compilée R2R pour .NET Core 3.0 et Linux x64.  Il ne sera utilisé que dans cette configuration ou dans une configuration compatible (par exemple, .NET Core 3.1 ou .NET Core 5.0 sous Linux x64), car il contient du code natif qui ne peut être utilisé que dans cet environnement d'exécution. </li></ul><br><h3>  Instructions </h3><br><p>  La compilation ReadyToRun est disponible pour publication uniquement.  La version d'aperçu a été publiée dans .NET Core 3.0 (aperçu 5). </p><br><p>  Pour activer la compilation ReadyToRun, vous devez: </p><br><ul><li>  Définissez la valeur de la propriété <code>PublishReadyToRun</code> sur <code>true</code> . </li><li>  Publiez en utilisant le <code>RuntimeIdentifier</code> exact. </li></ul><br><p>  Remarque  Lorsque les versions de l'application sont compilées, le code natif généré dépend de la plate-forme et de l'architecture (par conséquent, lors de la publication, vous devez spécifier un RuntimeIdentifier valide). </p><br><p>  Voici un exemple: </p><br><pre> <code class="cs hljs">&lt;Project Sdk=<span class="hljs-string"><span class="hljs-string">"Microsoft.NET.Sdk"</span></span>&gt; &lt;PropertyGroup&gt; &lt;OutputType&gt;Exe&lt;/OutputType&gt; &lt;TargetFramework&gt;netcoreapp3<span class="hljs-number"><span class="hljs-number">.0</span></span>&lt;/TargetFramework&gt; &lt;PublishReadyToRun&gt;<span class="hljs-literal"><span class="hljs-literal">true</span></span>&lt;/PublishReadyToRun&gt; &lt;/PropertyGroup&gt; &lt;/Project&gt;</code> </pre> <br><p>  Et la publication à l'aide de la commande suivante: </p><br><pre> <code class="cs hljs">dotnet publish -r win-x64 -c Release</code> </pre> <br><p>  Remarque: <code>RuntimeIdentifier</code> peut être défini dans le fichier de projet. </p><br><p>  Remarque: ReadyToRun n'est actuellement pris en charge que pour les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">applications autonomes</a> .  Il sera ajouté pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">les applications dépendantes</a> du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">framework</a> dans une annonce ultérieure. </p><br><p>  La génération de caractères d' <code>PublishReadyToRunEmitSymbols</code> peut être activée en définissant la propriété <code>PublishReadyToRunEmitSymbols</code> sur <code>true</code> .  Vous n'avez pas besoin de créer des caractères machine à des fins de débogage.  Ces caractères ne sont utiles qu'à des fins de profilage. </p><br><p>  Actuellement, le SDK prend en charge un moyen d'exclure certains assemblys de la compilation dans des images ReadyToRun.  Cela peut être utile dans les cas où les assemblages n'ont pas besoin d'être optimisés pour améliorer les performances.  L'exclusion d'assemblys dans ce cas peut aider à réduire la taille de l'application.  Dans le cas où le compilateur ReadyToRun ne parvient pas à compiler un assembly spécifique, la solution peut également être de l'éliminer. </p><br><p>  Une exception est levée à l'aide du groupe d'éléments PublishReadyToRunExclude: </p><br><pre> <code class="cs hljs">&lt;ItemGroup&gt; &lt;PublishReadyToRunExclude Include=<span class="hljs-string"><span class="hljs-string">"FilenameOfAssemblyToExclude.dll"</span></span> /&gt; &lt;/ItemGroup&gt;</code> </pre> <br><h2>  Compilation multiplateforme / architecturale </h2><br><p>  Le compilateur ReadyToRun ne prend pas encore en charge le ciblage croisé.  Vous devez compiler pour un objectif donné.  Par exemple, si vous avez besoin d'images R2R pour Windows x64, vous devez exécuter la commande de publication dans cet environnement. </p><br><p>  Exceptions: </p><br><ul><li>  Windows x64 peut être utilisé pour compiler des images Windows ARM32, ARM64 et x86. </li><li>  Windows x86 peut être utilisé pour compiler des images Windows ARM32. </li><li>  Linux x64 peut être utilisé pour compiler des images Linux ARM32 et ARM64. </li></ul><br><h2>  Disposition de l'assemblage </h2><br><p>  Le SDK NET core 3.0 est livré avec un outil qui peut réduire la taille des applications en analysant IL et en éliminant les versions inutilisées. </p><br><p>  Avec .NET Core, vous pouvez toujours publier des applications autonomes qui incluent tout ce dont vous avez besoin pour exécuter votre code, sans avoir à installer .NET sur la cible de déploiement.  Dans certains cas, l'application ne nécessite qu'un petit sous-ensemble du cadre, et elle pourrait être beaucoup plus petite en n'incluant que les bibliothèques utilisées. </p><br><p>  Nous utilisons le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">générateur IL</a> pour analyser l'IL de votre application afin de déterminer quel code est réellement requis, puis exclure les bibliothèques d'infrastructure inutilisées.  Cela peut réduire considérablement la taille de certaines applications.  En règle générale, les petites applications de console comme les outils tirent le meilleur parti, car elles utilisent souvent de petits sous-ensembles du cadre et se prêtent généralement bien au recadrage. </p><br><p>  Pour utiliser cet outil, définissez <code>PublishTrimmed=true</code> dans votre projet et publiez l'application autonome: </p><br><pre> <code class="cs hljs">dotnet publish -r &lt;rid&gt; -c Release</code> </pre> <br><p>  La sortie de publication comprendra un sous-ensemble des bibliothèques d'infrastructure, selon le code d'application qui invoque.  Pour l'application helloworld, l'éditeur de liens réduit la taille de ~ 68 Mo à ~ 28 Mo. </p><br><p>  Les applications ou les frameworks (y compris ASP.NET Core et WPF) qui utilisent la réflexion ou les fonctions dynamiques associées se cassent souvent lors du recadrage car l'éditeur de liens ignore ce comportement dynamique et ne peut généralement pas déterminer quels types de frameworks seront requis pour la réflexion lors de l'exécution .  Pour recadrer de telles applications, vous devez indiquer à l'éditeur de liens tous les types nécessaires à la réflexion dans votre code et dans tous les packages ou environnements dont vous dépendez.  Assurez-vous de tester vos applications après le recadrage. </p><br><p>  Pour plus d'informations sur IL Linker, consultez la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">documentation</a> ou visitez le référentiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mono / linker</a> . </p><br><p>  Remarque: Dans les versions précédentes de .NET Core, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">ILLink.Tasks était</a> fourni en tant que package NuGet externe et offrait la plupart des mêmes fonctionnalités.  Il n'est plus pris en charge - passez à la dernière version du SDK 3.0. </p><br><h2>  Linker et partage de l'éditeur de liens ReadToRun </h2><br><p>  Linker Linker et ReadyToRun Linker peuvent être utilisés pour la même application.  En général, l'éditeur de liens rend votre application plus petite, puis le compilateur prêt à l'emploi la rendra un peu plus grande, mais avec un gain de performances significatif.  Il vaut la peine de tester différentes configurations pour comprendre l'effet de chaque option. </p><br><p>  Remarque: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dotnet / sdk # 3257</a> empêche l'éditeur de liens et le partage ReadyToRun pour les applications WPF et Windows Forms.  Nous travaillons à résoudre ce problème dans le cadre de la version .NET Core 3.0. </p><br><h2>  Exemple d'hébergement natif </h2><br><p>  Récemment publié un exemple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d'hébergement natif</a> .  Il illustre la meilleure approche pour l'hébergement de .NET Core dans une application native. </p><br><p>  Dans le cadre de .NET Core 3.0, nous fournissons désormais des fonctionnalités communes à nos propres services d'hébergement .NET Core, qui n'étaient auparavant disponibles que pour les applications gérées .NET Core via les services d'hébergement .NET Core officiellement fournis.  La fonctionnalité est principalement associée au chargement de l'assemblage.  Cette fonctionnalité devrait faciliter la création de vos propres services d'hébergement qui peuvent utiliser la gamme complète des fonctionnalités de .NET Core. </p><br><h2>  Prise en charge HTTP / 2 dans HttpClient </h2><br><p>  HTTP / 2 est la version principale du protocole HTTP.  Certaines des caractéristiques notables de HTTP / 2 sont la prise en charge de la compression d'en-tête et les flux entièrement multiplexés sur une seule connexion.  Bien que HTTP / 2 conserve la sémantique de HTTP (en-têtes HTTP, méthodes, etc.), il diffère de HTTP / 1.x dans la façon dont les données sont envoyées. </p><br><p>  <code>HttpClient</code> prend désormais en charge les requêtes HTTP / 2.  Par défaut, tout reste également HTTP / 1.1, mais vous pouvez le désactiver en faveur de HTTP / 2 en installant la version à l'aide d'une requête HTTP. </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient() { BaseAddress = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"https://localhost:5001"</span></span>) }; <span class="hljs-comment"><span class="hljs-comment">// HTTP/1.1 request using (var response = await client.GetAsync("/")) { Console.WriteLine(response.Content); } // HTTP/2 request using (var request = new HttpRequestMessage(HttpMethod.Get, "/") { Version = new Version(2, 0) }) using (var response = await client.SendAsync(request)) { Console.WriteLine(response.Content); }</span></span></code> </pre> <br><p>  Vous pouvez également envoyer des demandes HTTP / 2 par défaut en définissant <code>DefaultRequestVersion</code> sur <code>HttpClient</code> . </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient() { BaseAddress = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Uri(<span class="hljs-string"><span class="hljs-string">"https://localhost:5001"</span></span>), DefaultRequestVersion = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Version(<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) }; <span class="hljs-comment"><span class="hljs-comment">// Defaults to HTTP/2 using (var response = await client.GetAsync("/")) { Console.WriteLine(response.Content); }</span></span></code> </pre> <br><p>  À la suite de ce changement, les serveurs et les clients doivent se mettre d'accord sur la version de protocole utilisée.  ALPN (Application-Layer Protocol Negotiation) est une extension TLS qui permet au serveur et au client de négocier la version du protocole utilisée dans le cadre de leur interaction.  Cependant, gardez à l'esprit que la plupart des serveurs ne prennent en charge ALPN que comme seul moyen d'établir une connexion HTTP / 2.  Ainsi, HTTP / 2 est négocié par <code>HttpClient</code> uniquement sur la connexion TLS. </p><br><p>  Dans les scénarios de développement, lorsque le serveur et le client savent a priori qu'ils parleront tous les deux HTTP / 2 sans chiffrement, vous pouvez établir une connexion HTTP / 2 via du texte clair en définissant le commutateur <code>AppContext</code> ou la variable d'environnement.  ( <code>DOTNET_SYSTEM_NET_HTTP_SOCKETSHTTPHANDLER_HTTP2UNENCRYPTEDSUPPORT=1</code> ). </p><br><pre> <code class="cs hljs">AppContext.SetSwitch(<span class="hljs-string"><span class="hljs-string">"System.Net.Http.SocketsHttpHandler.Http2UnencryptedSupport"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br><h2>  Achèvement </h2><br><p>  Nous serons très heureux si vous essayez de nouvelles fonctionnalités.  Veuillez signaler les problèmes ou bogues que vous rencontrez.  Vous pouvez également soumettre des demandes de nouvelles fonctionnalités, mais leur mise en œuvre devra attendre la prochaine version. </p><br><p>  Nous sommes maintenant sur le point d'achever les travaux sur le composant .NET Core 3.0 et nous attirons maintenant l'attention de l'équipe sur l'amélioration de la qualité des versions.  Nous avons des mois à l'avance pour corriger les bogues et améliorer les performances. </p><br><p>  Soit dit en passant, pour la prochaine mise à jour majeure, nous changerons les branches principales dans les référentiels .NET Core.  Cela se produira très probablement immédiatement après l'aperçu 7 en juillet. </p><br><p>  Merci d'avoir testé .NET Core 3.0.  Nous apprécions votre aide.  En ce moment, nous nous efforçons de faire de la version finale la plus intéressante et de haute qualité pour vous. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr456218/">https://habr.com/ru/post/fr456218/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr456206/index.html">Comment Moovit a amélioré son application pour aider les personnes handicapées à voyager en toute confiance</a></li>
<li><a href="../fr456208/index.html">90 milliards de roubles pour le développement de l'intelligence artificielle</a></li>
<li><a href="../fr456210/index.html">Comment une application mobile aide un étudiant ayant des problèmes de vision à se déplacer dans Moscou</a></li>
<li><a href="../fr456214/index.html">Utilisez __main__.py</a></li>
<li><a href="../fr456216/index.html">Faire un jeu rétro des années 80 ou comment faire des maquettes pour la découpe laser</a></li>
<li><a href="../fr456220/index.html">Généralisation du problème Brokar</a></li>
<li><a href="../fr456222/index.html">Le génie génétique des embryons humains deviendra sûr et efficace dans deux ans</a></li>
<li><a href="../fr456224/index.html">Annonce de l'aperçu 6 de .NET Core 3.0</a></li>
<li><a href="../fr456226/index.html">Prédiction des résultats du football</a></li>
<li><a href="../fr456230/index.html">Iobroker quest for quests in reality games</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>