<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëèüèª üè® üë≤üèª CSS nach und vor der Verarbeitung üëà üçÑ ‚òÄÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo Leser. Haben Sie auf Ihrem Weg zum Lernen von Layouts CSS gelernt und m√∂chten weitermachen? Dann zu dir unter Katze. Achtung, viel Code. 

 In d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>CSS nach und vor der Verarbeitung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434098/">  Hallo Leser.  Haben Sie auf Ihrem Weg zum Lernen von Layouts CSS gelernt und m√∂chten weitermachen?  Dann zu dir unter Katze.  Achtung, viel Code. <a name="habracut"></a><br><br>  In diesem Artikel werde ich Pr√§prozessoren und Postprozessoren √ºberpr√ºfen. <br><br>  Ich werde nicht auf Details zu CSS eingehen, was bedeutet, dass Sie es bereits wissen.  Ich werde Klassen in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">BEM-</a> Notation benennen.  Ich werde mich auch nicht mit der Installation und Konfiguration von allem befassen, wor√ºber ich schreiben werde, aber ich werde trotzdem Links hinterlassen, denen Sie folgen k√∂nnen, und lernen, wie man es selbst macht. <br><br>  Beginnen wir mit den Pr√§prozessoren. <br><br><h2>  Pr√§prozessoren </h2><br>  Was ist ein Pr√§prozessor au√üerhalb des Kontexts mit CSS?  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Vicki</a> kennt die Antwort. <br><br>  Was ist ein Pr√§prozessor im Kontext von CSS?  In unserem Fall ist der Pr√§prozessor ein Programm, das Code in der Sprache des Pr√§prozessors als Eingabe empf√§ngt, und bei der Ausgabe erhalten wir CSS, das wir in unseren Browser eingeben k√∂nnen. <br><br>  Was sind die Pr√§prozessoren?  Es gibt mehrere Vertreter, zum Beispiel: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sass</a> (.sass, .scss), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Less</a> (.less) und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stylys</a> (.stylus). <br>  Auch unter den Pr√§prozessoren kann <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PostCSS</a> (oder besser gesagt der SugarSS-Parser und das PreCSS-Plugin) separat herausgegriffen werden.  Mit Blick auf die Zukunft werde ich sagen, dass PostCSS nicht nur ein Postprozessor ist. <br><br>  Ich werde das Beispiel von Sass √ºberpr√ºfen.  Genauer gesagt zu seiner neuen Syntax - SCSS, da es n√§her an CSS liegt als die alte Syntax.  Beginnen wir mit den Funktionen, die Pr√§prozessoren hinzuf√ºgen, die nicht in CSS enthalten sind, und enden mit den Problemen, die gel√∂st werden. <br><br><h3>  Die M√∂glichkeiten </h3><br><h4>  Variablen </h4><br><pre><code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scss</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: <span class="hljs-selector-id"><span class="hljs-selector-id">#fff</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: $color; <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: $color; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-number"><span class="hljs-number">#fff</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">background</span></span>: <span class="hljs-number"><span class="hljs-number">#fff</span></span>; }</code> </pre> <br>  Der Nutzen von Variablen ist schwer zu √ºbersch√§tzen.  Jetzt k√∂nnen Sie Farben ($omato: rgb (255,99,71)) aussagekr√§ftige Namen geben, Werte nicht durch Konstanten, sondern durch Variablen (H√∂he: $ body_height - $ footer_height) berechnen und vieles mehr.  Viele m√∂gen argumentieren, dass es in CSS Variablen gibt.  Aber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Can I Use</a> sagt, dass es keine Unterst√ºtzung f√ºr IE gibt (und aus offensichtlichen Gr√ºnden wird dies nicht erwartet). <br><br><h4>  Nisten </h4><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scss</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.chat-area</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">40%</span></span>; &amp;__button { // &amp; -    (   &amp; = .chat-area) <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: inline-block; <span class="hljs-attribute"><span class="hljs-attribute">height</span></span>:<span class="hljs-number"><span class="hljs-number">36px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; } } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.chat-area</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">40%</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.chat-area__button</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: inline-block; <span class="hljs-attribute"><span class="hljs-attribute">height</span></span>:<span class="hljs-number"><span class="hljs-number">36px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.chat-area</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; }</code> </pre><br>  Am Anfang des Artikels habe ich mich auf BEM bezogen.  In diesem Beispiel ist das Element mit der Chat-Bereichsklasse ein Block.  Falls es pl√∂tzlich umbenannt werden muss, ist es jetzt m√∂glich, dies an einer Stelle zu tun. Dies wird zur Routine, wenn mehrere Dutzend Selektoren in eine Datei eingegeben werden, die den Namen des Blocks enth√§lt.  Ich m√∂chte auch darauf hinweisen, dass dies eine Art Schutz gegen Tippfehler ist, da der Name des Blocks einmal geschrieben wird. <br><br><h4>  Mixins </h4><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scss</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">mixin</span></span> border-radius($radius) { <span class="hljs-selector-tag"><span class="hljs-selector-tag">-webkit-border-radius</span></span>: $<span class="hljs-selector-tag"><span class="hljs-selector-tag">radius</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">-moz-border-radius</span></span>: $<span class="hljs-selector-tag"><span class="hljs-selector-tag">radius</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">-ms-border-radius</span></span>: $<span class="hljs-selector-tag"><span class="hljs-selector-tag">radius</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">border-radius</span></span>: $<span class="hljs-selector-tag"><span class="hljs-selector-tag">radius</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.box</span></span> { @include border-radius(10px); } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.box</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">-webkit-border-radius</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">-moz-border-radius</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">-ms-border-radius</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">border-radius</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; }</code> </pre><br>  Mixins sind eines der am schwierigsten zu verstehenden Themen.  Grob gesagt ist ein Mixin eine Funktion, die Argumente akzeptiert und Regeln, die von diesen Argumenten abh√§ngen, auf einen bestimmten Selektor anwendet.  In diesem Beispiel wurde das Rand-Radius-Mixin auf den .box-Selektor angewendet <br><br><h4>  Zus√§tzliche Funktionen </h4><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scss</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: <span class="hljs-selector-id"><span class="hljs-selector-id">#202020</span></span>; <span class="hljs-selector-tag"><span class="hljs-selector-tag">h1</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">h2</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">lighten</span></span>($color, 40%); } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">h1</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">h2</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-number"><span class="hljs-number">#868686</span></span>; }</code> </pre><br>  Grunds√§tzlich erleichtern neue Funktionen das Arbeiten mit Farben.  Zum Beispiel die Aufhellungsfunktion - hellt die Farbe um die angegebene Anzahl von Prozent auf (das Gegenteil ist die Verdunkelungsfunktion). <br><br><h3>  Probleme gel√∂st </h3><br><h4>  Modularit√§t </h4><br>  Das Problem beim Standardimport besteht darin, dass eine zus√§tzliche Anforderung an den Server erstellt wird, was eine teure Operation ist.  Es w√§re sch√∂n, wenn der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Import</a> sofort den gesamten Text des Importierten in die Quelldatei einf√ºgen w√ºrde, oder? <br><br>  Auf die eine oder andere Weise gab es vorher keine Pr√§prozessoren, und das Problem musste irgendwie gel√∂st werden.  Sie k√∂nnen beispielsweise den gesamten Code in eine Datei schreiben. <br><br><div class="spoiler">  <b class="spoiler_title">Wie sieht es aus?</b> <div class="spoiler_text"><pre> <code class="css hljs"> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span></code> </pre><br><div class="spoiler">  <b class="spoiler_title">Wie es wirklich aussieht</b> <div class="spoiler_text"><pre> <code class="css hljs"> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* -  */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  -  */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span></code> </pre><br></div></div><br></div></div><br>  Wir haben jedoch Pr√§prozessoren, die dieses Problem f√ºr uns l√∂sen.  Der Pr√§prozessor √ºberschreibt den Standardimport und f√ºgt nun, anstatt nach dem Server zu fragen, den Import wie gew√ºnscht in die Quelldatei ein. <br><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scss</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"selector1"</span></span>; @<span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">"selector2"</span></span>; //<span class="hljs-selector-tag"><span class="hljs-selector-tag">selector1</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scss</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: white; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">selector2</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scss</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: gold; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: gold; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: white; }</code> </pre><br>  Bitte beachten Sie, dass die Quelldateien in eine konvertiert wurden.  Eine Anfrage an den Server f√ºr Statik - eine Antwort. <br><br><h4>  Vererbung </h4><br>  &lt;Sarkasmus&gt; Wir haben Klassen, aber keine Vererbung, wie? &lt;/ Sarkasmus&gt;.  Jetzt ist es m√∂glich, die sogenannten "Template-Selektoren" auszuw√§hlen und mit anderen Selektoren zu erweitern. <br><br><pre> <code class="css hljs">// <span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.scss</span></span> %<span class="hljs-selector-tag"><span class="hljs-selector-tag">equal-heights</span></span> { //   <span class="hljs-attribute"><span class="hljs-attribute">height</span></span>: <span class="hljs-number"><span class="hljs-number">100%</span></span>; } %<span class="hljs-selector-tag"><span class="hljs-selector-tag">message</span></span> { //   <span class="hljs-attribute"><span class="hljs-attribute">padding</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.success</span></span> { @extend %message; <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: green; } <span class="hljs-selector-class"><span class="hljs-selector-class">.error</span></span> { @extend %message; <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; } // <span class="hljs-selector-tag"><span class="hljs-selector-tag">style</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.success</span></span>, <span class="hljs-selector-class"><span class="hljs-selector-class">.error</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">padding</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.success</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: green; } <span class="hljs-selector-class"><span class="hljs-selector-class">.error</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; }</code> </pre><br>  Das Sch√∂ne an Vorlagen-Selektoren ist, dass sie nicht in die generierten Stile passen.  Der Template Equalizer% Equal-Heights war nicht am Code beteiligt und hinterlie√ü keine Spuren in CSS.  Die Selector% -Nachricht wurde in Form von Regeln f√ºr Selektoren wiedergegeben, die sie erweitert haben.  Sie k√∂nnen von normalen Selektoren erben, es ist jedoch vorzuziehen, Vorlagen-Selektoren zu verwenden, damit kein √ºberm√§√üiger M√ºll entsteht. <br><br><h4>  Formatierung </h4><br>  Nachdem der Code geschrieben wurde, muss er formatiert (f√ºr die Produktion komprimiert) werden.  Sie k√∂nnen dies mit Hilfe von Sammlern wie Webpack oder mit Standardwerkzeugen tun. <br><br>  Es gibt 4 Arten der Formatierung in Sass. <br><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">expanded</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: gold; <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: block; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">nested</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: gold; <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: block; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">compact</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: gold; <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: block; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: red; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">compressed</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">span</span></span>{<span class="hljs-attribute"><span class="hljs-attribute">color</span></span>:gold;<span class="hljs-attribute"><span class="hljs-attribute">display</span></span>:block}<span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span>{<span class="hljs-attribute"><span class="hljs-attribute">color</span></span>:red}</code> </pre><br>  erweitert - Am √§hnlichsten zu von Menschen geschriebenem Code. <br>  verschachtelt - Ann√§herung an das Format der alten Syntax.  Die Lesbarkeit geht nicht verloren, aber es handelt sich um ein Hollywood-Problem. <br>  kompakt - Beibehaltung der Lesbarkeit, jedoch mit Schwierigkeiten.  N√ºtzlich, um die Anzahl der Selektoren in einem Projekt per Auge zu bestimmen. <br>  komprimiert - Bereits v√∂llig unlesbares Format.  Alle Zeichen, die gel√∂scht werden k√∂nnen, werden gel√∂scht.  Geeignet zum F√ºttern des Browsers. <br><br><h3>  Nachtrag </h3><br>  Ich habe einige der von Sass hinzugef√ºgten Funktionen nicht verstanden.  Zum Beispiel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schleifen</a> oder <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Merkmale von arithmetischen Operatoren</a> .  Ich √ºberlasse es Ihnen, sich mit Ihnen vertraut zu machen. <br><br><h2>  Postprozessoren </h2><br>  Nachdem wir uns mit Pr√§prozessoren befasst haben, wechseln wir zu Postprozessoren. <br><br>  Im Kontext von Css ist der Postprozessor im Wesentlichen derselbe wie der Pr√§prozessor, aber die Eingabe in den Postprozessor erh√§lt keinen Code, der in der Sprache des Pr√§prozessors geschrieben ist, sondern auch CSS.  Das hei√üt, der Postprozessor ist ein Programm, an dessen Eingabe CSS angegeben ist, und die Ausgabe ist CSS.  Es ist nicht sehr klar, warum dies notwendig ist. <br><br>  Ich werde anhand eines konkreten Beispiels die Funktionsweise von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PostCSS erl√§utern</a> - dem einzigen Vertreter von Postprozessoren im Kontext von CSS. <br><br>  PostCSS out of the box macht mit CSS eigentlich nichts.  Es gibt einfach die Datei zur√ºck, die ihm bei der Eingabe √ºbergeben wurde.  √Ñnderungen beginnen, wenn Plugins mit PostCSS verbunden sind. <br><br>  Der gesamte Zyklus von PostCSS kann wie folgt beschrieben werden: <br><br><ul><li>  Die Quelldatei wird an die PostCSS-Eingabe √ºbergeben und analysiert. </li><li>  Plugin 1 macht etwas </li><li>  ... </li><li>  Plugin n macht etwas </li><li>  Das Ergebnis wird in eine Zeichenfolge konvertiert und in die Ausgabedatei geschrieben. </li></ul><br>  Betrachten Sie die wichtigsten Plugins im PostCSS-√ñkosystem <br><br><h3>  Plugins </h3><br><h4>  Autoprefixer </h4><br>  Dieses Plugin ist so beliebt, dass viele Leute denken, dass sie dieses Plugin verwenden, aber kein PostCSS verwenden.  Sie sind falsch. <br><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">in</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: flex } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">out</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: -webkit-box; <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: -webkit-flex; <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: -moz-box; <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: -ms-flexbox; <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: flex }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Autoprefixer</a> f√ºgt Ihren Regeln <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Browserpr√§fixe</a> hinzu.  Eines der wichtigsten Plugins, mit dem die Geschichte von PostCSS begann und das nicht ersetzt werden konnte.  Man k√∂nnte sogar sagen, dass es sinnvoll ist, PostCss nur f√ºr dieses Plugin zu verwenden. <br><br><h2>  Preset env </h2><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">in</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">custom</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">media</span></span> --med (width &lt;= <span class="hljs-number"><span class="hljs-number">50rem</span></span>); @<span class="hljs-keyword"><span class="hljs-keyword">media</span></span> (--med) { <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:hover</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">color-mod</span></span>(black alpha(54%)); } } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">out</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> @<span class="hljs-keyword"><span class="hljs-keyword">media</span></span> (max-width: <span class="hljs-number"><span class="hljs-number">50rem</span></span>) { <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span><span class="hljs-selector-pseudo"><span class="hljs-selector-pseudo">:hover</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">rgba</span></span>(0, 0, 0, 0.54); } }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PostCSS Preset Env</a> f√ºgt Funktionen hinzu, die nur in Entw√ºrfen von CSS-Entwicklern behandelt werden.  In diesem Beispiel wurde die @ custom-media-Direktive sowie die Color-Mod-Funktion implementiert.  Nutzen Sie noch heute das CSS der Zukunft! <br><br><h4>  CSS-Module </h4><br>  Alle diese BEMs sind nichts f√ºr Sie, aber gibt es immer noch ein Problem mit Klassennamenkonflikten?  Dann bietet PostCSS eine andere L√∂sung. <br><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">in</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.name</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: gray; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">out</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.Logo__name__SVK0g</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: gray; }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CSS-Module</a> √§ndern Klassennamen nach einem bestimmten Muster (alles ist anpassbar).  Jetzt kennen wir den Namen der Klasse nicht im Voraus, da er dynamisch bestimmt wird.  Wie klassifiziere ich jetzt Elemente, wenn wir sie nicht im Voraus kennen?  Durch die Kombination von PostCSS, Webpack und ES6 kann ich folgende L√∂sung anbieten: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./style.css'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  import styles from './style.css'; // </span></span></code> </pre><br>  Jetzt importieren wir nicht nur eine Datei mit Stilen (z. B. in der React-Datei einer Komponente) und ersetzen uns zuvor bekannte Werte, sondern importieren ein Objekt.  Die Schl√ºssel dieses Objekts sind die urspr√ºnglichen Selektoren, und die Werte werden konvertiert.  Das hei√üt, in diesem Beispiel ist styles ['name'] = 'Logo__name__SVK0g'. <br><br><h4>  Kurz </h4><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">in</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.icon</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">size</span></span>: <span class="hljs-number"><span class="hljs-number">48px</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.canvas</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-number"><span class="hljs-number">#abccfc</span></span> <span class="hljs-number"><span class="hljs-number">#212231</span></span>; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">out</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.icon</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">48px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">height</span></span>: <span class="hljs-number"><span class="hljs-number">48px</span></span>; } <span class="hljs-selector-class"><span class="hljs-selector-class">.canvas</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-number"><span class="hljs-number">#abccfc</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">background-color</span></span>: <span class="hljs-number"><span class="hljs-number">#212231</span></span>; }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PostCSS Short</a> f√ºgt eine Reihe verk√ºrzter Eintr√§ge f√ºr verschiedene Regeln hinzu.  Der Code wird k√ºrzer und daher gibt es weniger Raum f√ºr Fehler.  Plus erh√∂ht die Lesbarkeit. <br><br><h4>  Auto-Reset </h4><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">in</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">margin</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: blue; } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">out</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">all</span></span>: initial; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">margin</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: blue; }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mit PostCSS Auto Reset</a> k√∂nnen wir keine separate Datei mit einem Reset aller Stile erstellen.  Das Plugin erstellt einen gro√üen Selektor f√ºr alle Selektoren, in dem die Regeln platziert und alle Stile zur√ºckgesetzt werden.  Standardm√§√üig wird nur die Regel all mit dem Wert initial erstellt.  Dies ist n√ºtzlich in Kombination mit dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Postcss-Initial-</a> Plugin, das diese Regel wiederum in eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Regentasche</a> f√ºr 4 Bildschirme verwandelt.  Es kann jedoch alles wie folgt konfiguriert und zur√ºckgesetzt werden: <br><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">out</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">margin</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">padding</span></span>: <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">margin</span></span>: <span class="hljs-number"><span class="hljs-number">10px</span></span>; } <span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: blue; }</code> </pre><br>  Erinnern Sie sich am Anfang des Artikels, dass PostCSS nicht nur ein Postprozessor ist? <br><br><h3>  PostCSS - Pr√§prozessor? </h3><br>  Betrachten Sie einen Parser und ein Plugin. Danach √§ndern Sie Ihre aktuelle Meinung zu PostCSS. <br><br><h4>  Sugararss </h4><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">in</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.sss</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.parent</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">white</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.parent</span></span> &gt; <span class="hljs-selector-class"><span class="hljs-selector-class">.child</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">black</span></span> //<span class="hljs-selector-tag"><span class="hljs-selector-tag">out</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.parent</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: white } <span class="hljs-selector-class"><span class="hljs-selector-class">.parent</span></span> &gt; <span class="hljs-selector-class"><span class="hljs-selector-class">.child</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: black }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SugarSS</a> ist ein Parser (kein Plugin!), Der standardm√§√üig auf <u>Einr√ºckungen</u> und nicht auf geschweiften Klammern basiert.  Es hat eine separate Erweiterung ".sss".  Mit SugarSS geschriebener Code √§hnelt im Stil der alten Sass-Syntax, jedoch ohne Lotionen wie Variablen, Mixins, Vererbung usw. <br><br>  Sie haben erraten, was das n√§chste Plugin hinzuf√ºgen wird? <br><br><h4>  Precss </h4><br><pre> <code class="css hljs">//<span class="hljs-selector-tag"><span class="hljs-selector-tag">in</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.sss</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">black</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.parent</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.child</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: $<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span> //  <span class="hljs-selector-tag"><span class="hljs-selector-tag">SugarSS</span></span> $<span class="hljs-selector-tag"><span class="hljs-selector-tag">color</span></span>: <span class="hljs-selector-tag"><span class="hljs-selector-tag">black</span></span>; <span class="hljs-selector-class"><span class="hljs-selector-class">.parent</span></span> { .child { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: $color } } //<span class="hljs-selector-tag"><span class="hljs-selector-tag">out</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.css</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.parent</span></span> <span class="hljs-selector-class"><span class="hljs-selector-class">.child</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: black }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PreCSS</a> f√ºgt lediglich die Funktionen der Pr√§prozessoren hinzu, √ºber die in der ersten H√§lfte des Artikels geschrieben wurde. <br><br>  Und warum ist PostCSS jetzt kein Pr√§prozessor? <br><br><h3>  Stylelint </h3><br>  √úber <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stylelint</a> wurde bereits viel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">geschrieben</a> .  Er nahm an dieser √úberpr√ºfung teil, weil er PostCSS als Parser f√ºr Zeilen von CSS-Dateien verwendet.  Angenommen, wir haben eine solche Datei. <br><br><pre> <code class="css hljs"><span class="hljs-selector-tag"><span class="hljs-selector-tag">a</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">rgb</span></span>(1, 1, 1) } <span class="hljs-selector-tag"><span class="hljs-selector-tag">div</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">rgb</span></span>(0, 0, 0) }</code> </pre><br>  Hier ist die Ausgabe f√ºr die aktuelle Datei: <br><br><pre> <code class="plaintext hljs"> 2:21 Expected a trailing semicolon declaration-block-trailing-semicolon 6:21 Expected a trailing semicolon declaration-block-trailing-semicolon 7:1 Unexpected missing end-of-source newline no-missing-end-of-source-newline</code> </pre><br>  Der Nutzen dieses Tools ist schwer zu √ºbersch√§tzen. <br><br><h2>  Schlussfolgerungen </h2><br>  Pr√§prozessoren f√ºgen viele neue Funktionen hinzu, die nicht in CSS enthalten sind.  Sobald Sie es versuchen, werden Sie kaum wieder zu normalem CSS zur√ºckkehren. <br><br>  PostCSS ist dem urspr√ºnglichen CSS viel n√§her als Pr√§prozessoren, kann jedoch mit bestimmten angeschlossenen Plugins dieselbe Funktionalit√§t (und sogar eine √§hnliche Syntax) aufweisen.  Anf√§nger k√∂nnen setzen, ohne zu denken, dass Layouts nicht in reinem CSS sind.  Einige Plugins (zum Beispiel Autoprefixer) haben keine Analoga in der Pr√§prozessorwelt. <br><br>  Niemand st√∂rt die Verwendung von Pr√§prozessoren und PostCSS in Verbindung.  Die Option ist ziemlich gut f√ºr Projekte, die bereits Pr√§prozessoren verwenden und einen Wohnort haben. <br><br>  F√ºr neue Projekte w√ºrde ich empfehlen, nur PostCSS zu verwenden.  Layout-Designer sind an die Pr√§prozessorsyntax gew√∂hnt?  Installieren Sie das PreCSS-Plugin und den SugarSS-Parser.  Ben√∂tigen Sie Cross-Browser-Kompatibilit√§t?  Installieren Sie das Autoprefixer-Plugin.  Browser√ºbergreifende Kompatibilit√§t ist nicht mehr erforderlich (z. B. wurde Ihr Projekt in ein Elektron eingewickelt und wurde zum Desktop)?  Deinstallieren Sie einfach Autoprefixer!  Mit PostCSS k√∂nnen Sie wie mit dem Konstruktor genau das erstellen, was Ihr Projekt ben√∂tigt. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de434098/">https://habr.com/ru/post/de434098/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de434086/index.html">Embedded-Bereitstellung f√ºr Windows und Linux</a></li>
<li><a href="../de434088/index.html">So helfen Sie Remote-Mitarbeitern, Einsamkeit und Burnout zu vermeiden</a></li>
<li><a href="../de434090/index.html">Einf√ºhrung eines Vakuumtransistors: Ein Ger√§t aus der Leere</a></li>
<li><a href="../de434092/index.html">Die Menschen, die 1968 gerettet haben</a></li>
<li><a href="../de434096/index.html">Heisenbug 2018 Moskau: Ein Blick aus der Menge</a></li>
<li><a href="../de434100/index.html">3D-Drucker√ºbersicht f√ºr Anet A6 und Anet A8</a></li>
<li><a href="../de434102/index.html">Sch√∂ne und informative Animation: F√§lle von Kreisbewegungen und Vibrationen</a></li>
<li><a href="../de434104/index.html">UKW-Boden oder Entmystifizierung von Doppel- / Dreifachquadratantennen</a></li>
<li><a href="../de434106/index.html">Vertrauen Sie auf mobile SDKs</a></li>
<li><a href="../de434110/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends f√ºr die letzte Woche Nr. 344 (17. - 23. Dezember 2018)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>