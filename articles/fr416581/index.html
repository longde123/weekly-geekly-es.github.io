<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôé üöÉ üß§ Mod√®les de troisi√®me ordre ou comment j'ai port√© Jinja2 en C ++ üëÉüèæ üë©üèΩ‚Äçü§ù‚Äçüë©üèª üè≥Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les ¬´mod√®les¬ª dans le contexte de C ++ se r√©f√®rent g√©n√©ralement √† des constructions de langage tr√®s sp√©cifiques. Il existe des mod√®les simples qui sim...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mod√®les de troisi√®me ordre ou comment j'ai port√© Jinja2 en C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416581/"><img src="https://habrastorage.org/getpro/habr/post_images/c81/fe0/548/c81fe0548837b911b9569cdf49d90ca2.jpg" alt="Logo Jinja2" align="left">  Les ¬´mod√®les¬ª dans le contexte de C ++ se r√©f√®rent g√©n√©ralement √† des constructions de langage tr√®s sp√©cifiques.  Il existe des mod√®les simples qui simplifient le travail avec le m√™me type de code - ce sont des mod√®les de classe et de fonction.  Si un mod√®le poss√®de l'un des param√®tres par lui-m√™me, il peut s'agir de mod√®les de second ordre et ils g√©n√®rent d'autres mod√®les en fonction de leurs param√®tres.  Mais que faire si leurs capacit√©s ne sont pas suffisantes et plus faciles pour g√©n√©rer imm√©diatement le texte source?  Beaucoup de code source? <br>  Les fans de Python et de mises en page HTML connaissent un outil (moteur, biblioth√®que) pour travailler avec des mod√®les de texte appel√© <b>Jinja2</b> .  √Ä l'entr√©e, ce moteur re√ßoit un fichier mod√®le dans lequel le texte peut √™tre m√©lang√© avec des structures de contr√¥le, la sortie est un texte clair dans lequel toutes les structures de contr√¥le sont remplac√©es par du texte conform√©ment aux param√®tres sp√©cifi√©s de l'ext√©rieur (ou de l'int√©rieur).  En gros, c'est quelque chose comme des pages ASP (ou C ++ - pr√©processeur), seul le langage de balisage est diff√©rent. <br>  Jusqu'√† pr√©sent, l'impl√©mentation de ce moteur √©tait uniquement pour Python.  Maintenant c'est pour C ++.  Comment et pourquoi cela s'est produit, et sera discut√© dans l'article. <br><a name="habracut"></a><br><h2>  Pourquoi ai-je m√™me repris √ßa </h2><br>  En effet, pourquoi?  Apr√®s tout, il y a Python, pour cela - une excellente impl√©mentation, un tas de fonctionnalit√©s, une sp√©cification compl√®te pour le langage.  Prenez et utilisez!  Je n'aime pas Python - vous pouvez prendre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jinja2CppLight</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">inja</a> , des ports partiels Jinja2 en C ++.  Vous pouvez, √† la fin, prendre le port C ++ {{ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Moustache</a> }}.  Le diable, comme d'habitude, dans les d√©tails.  Donc, disons, j'avais besoin de la fonctionnalit√© des filtres de Jinja2 et des capacit√©s de la construction extend, qui vous permet de cr√©er des mod√®les extensibles (et aussi des macros et include, mais plus tard).  Et aucune des impl√©mentations mentionn√©es ne prend en charge cela.  Puis-je m'en passer?  Aussi une bonne question.  Jugez par vous-m√™me.  J'ai un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">projet</a> dont le but est de cr√©er un g√©n√©rateur de code passe-partout C ++ - to-C ++.  Cet autog√©n√©rateur re√ßoit, disons, un fichier d'en-t√™te √©crit manuellement avec des structures ou des √©num√©rations, et g√©n√®re en fonction de lui des fonctions de s√©rialisation / d√©s√©rialisation ou, par exemple, de conversion d'√©l√©ments d'√©num√©ration en cha√Ænes (et vice versa).  Vous pouvez √©couter plus de d√©tails sur cet utilitaire dans mes rapports <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> (eng) ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> (rus). <br>  Ainsi, une t√¢che typique r√©solue dans le processus de travail sur l'utilitaire est la cr√©ation de fichiers d'en-t√™te, dont chacun a un en-t√™te (avec ifdefs et inclut), un corps avec le contenu principal et un pied de page.  De plus, le contenu principal est les d√©clarations g√©n√©r√©es bourr√©es d'espace de noms.  En ex√©cution C ++, le code pour cr√©er un tel fichier d'en-t√™te ressemble √† ceci (et ce n'est pas tout): <br><div class="spoiler">  <b class="spoiler_title">Beaucoup de code C ++</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Enum2StringGenerator::WriteHeaderContent(CppSourceStream &amp;hdrOs) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;reflection::EnumInfoPtr&gt; enums; WriteNamespaceContents(hdrOs, m_namespaces.GetRootNamespace(), [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;enums](CppSourceStream &amp;os, reflection::NamespaceInfoPtr ns) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; enumInfo : ns-&gt;enums) { WriteEnumToStringConversion(os, enumInfo); WriteEnumFromStringConversion(os, enumInfo); enums.push_back(enumInfo); } }); hdrOs &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n\n"</span></span>; { out::<span class="hljs-function"><span class="hljs-function">BracedStreamScope </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flNs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\nnamespace flex_lib"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\n\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; flNs; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (reflection::EnumInfoPtr enumInfo : enums) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> scopedParams = MakeScopedParams(hdrOs, enumInfo); { hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"template&lt;&gt;"</span></span>; out::<span class="hljs-function"><span class="hljs-function">BracedStreamScope </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"inline const char* Enum2String($enumFullQualifiedName$ e)"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; body; hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"return $namespaceQual$::$enumName$ToString(e);"</span></span>; } { hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"template&lt;&gt;"</span></span>; out::<span class="hljs-function"><span class="hljs-function">BracedStreamScope </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"inline $enumFullQualifiedName$ String2Enum&lt;$enumFullQualifiedName$&gt;(const char* itemName)"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; body; hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"return $namespaceQual$::StringTo$enumName$(itemName);"</span></span>; } } } { out::<span class="hljs-function"><span class="hljs-function">BracedStreamScope </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flNs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\nnamespace std"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\n\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; flNs; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (reflection::EnumInfoPtr enumInfo : enums) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> scopedParams = MakeScopedParams(hdrOs, enumInfo); out::<span class="hljs-function"><span class="hljs-function">BracedStreamScope </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"inline std::string to_string($enumFullQualifiedName$ e)"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; body; hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"return $namespaceQual$::$enumName$ToString(e);"</span></span>; } } } <span class="hljs-comment"><span class="hljs-comment">// Enum item to string conversion writer void Enum2StringGenerator::WriteEnumToStringConversion(CppSourceStream &amp;hdrOs, const reflection::EnumInfoPtr &amp;enumDescr) { auto scopedParams = MakeScopedParams(hdrOs, enumDescr); out::BracedStreamScope fnScope("inline const char* $enumName$ToString($enumScopedName$ e)", "\n"); hdrOs &lt;&lt; out::new_line(1) &lt;&lt; fnScope; { out::BracedStreamScope switchScope("switch (e)", "\n"); hdrOs &lt;&lt; out::new_line(1) &lt;&lt; switchScope; out::OutParams innerParams; for (auto&amp; i : enumDescr-&gt;items) { innerParams["itemName"] = i.itemName; hdrOs &lt;&lt; out::with_params(innerParams) &lt;&lt; out::new_line(-1) &lt;&lt; "case $prefix$$itemName$:" &lt;&lt; out::new_line(1) &lt;&lt; "return \"$itemName$\";"; } } hdrOs &lt;&lt; out::new_line(1) &lt;&lt; "return \"Unknown Item\";"; } // String to enum conversion writer void Enum2StringGenerator::WriteEnumFromStringConversion(CppSourceStream &amp;hdrOs, const reflection::EnumInfoPtr &amp;enumDescr) { auto params = MakeScopedParams(hdrOs, enumDescr); out::BracedStreamScope fnScope("inline $enumScopedName$ StringTo$enumName$(const char* itemName)", "\n"); hdrOs &lt;&lt; out::new_line(1) &lt;&lt; fnScope; { out::BracedStreamScope itemsScope("static std::pair&lt;const char*, $enumScopedName$&gt; items[] = ", ";\n"); hdrOs &lt;&lt; out::new_line(1) &lt;&lt; itemsScope; out::OutParams&amp; innerParams = params.GetParams(); auto items = enumDescr-&gt;items; std::sort(begin(items), end(items), [](auto&amp; i1, auto&amp; i2) {return i1.itemName &lt; i2.itemName;}); for (auto&amp; i : items) { innerParams["itemName"] = i.itemName; hdrOs &lt;&lt; out::with_params(innerParams) &lt;&lt; out::new_line(1) &lt;&lt; "{\"$itemName$\", $prefix$$itemName$},"; } } hdrOs &lt;&lt; out::with_params(params.GetParams()) &lt;&lt; R"( $enumScopedName$ result; if (!flex_lib::detail::String2Enum(itemName, items, result)) flex_lib::bad_enum_name::Throw(itemName, "$enumName$"); return result;)"; }</span></span></code> </pre> <br>  <a href="">D'ici</a> . <br></div></div><br>  De plus, ce code change peu d'un fichier √† l'autre.  Bien s√ªr, vous pouvez utiliser le format clang pour le formatage.  Mais cela n'annule pas le reste du travail manuel sur la g√©n√©ration du texte source. <br>  Et puis un beau moment, j'ai r√©alis√© que ma vie devait √™tre simplifi√©e.  Je n'ai pas envisag√© l'option de visser un langage de script √† part enti√®re en raison de la complexit√© de la prise en charge du r√©sultat final.  Mais pour trouver un moteur de mod√®le appropri√© - pourquoi pas?  Je l'ai trouv√© utile pour rechercher, je l'ai trouv√©, puis j'ai trouv√© la sp√©cification Jinja2 et j'ai r√©alis√© que c'√©tait exactement ce dont j'avais besoin.  Pour, conform√©ment √† cette sp√©cification, les mod√®les de g√©n√©ration d'en-t√™tes devraient ressembler √† ceci: <br><pre> <code class="cpp hljs">{% extends <span class="hljs-string"><span class="hljs-string">"header_skeleton.j2tpl"</span></span> %} {% block generator_headers %} <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;flex_lib/stringized_enum.h&gt; #include &lt;algorithm&gt; #include &lt;utility&gt; {% endblock %} {% block namespaced_decls %}{{super()}}{% endblock %} {% block namespace_content %} {% for enum in ns.enums | sort(attribute="name") %} {% set enumName = enum.name %} {% set scopeSpec = enum.scopeSpecifier %} {% set scopedName = scopeSpec ~ ('::' if scopeSpec) ~ enumName %} {% set prefix = (scopedName + '::') if not enumInfo.isScoped else (scopedName ~ '::' ~ scopeSpec ~ ('::' if scopeSpec)) %} inline const char* {{enumName}}ToString({{scopedName}} e) { switch (e) { {% for itemName in enum.items | map(attribute="itemName") | sort%} case {{prefix}}{{itemName}}: return "{{itemName}}"; {% endfor %} } return "Unknown Item"; } inline {{scopedName}} StringTo{{enumName}}(const char* itemName) { static std::pair&lt;const char*, {{scopedName}}&gt; items[] = { {% for itemName in enum.items | map(attribute="itemName") | sort %} {"{{itemName}}", {{prefix}}{{itemName}} } {{',' if not loop.last }} {% endfor %} }; {{scopedName}} result; if (!flex_lib::detail::String2Enum(itemName, items, result)) flex_lib::bad_enum_name::Throw(itemName, "{{enumName}}"); return result; } {% endfor %}{% endblock %} {% block global_decls %} {% for ns in [rootNamespace] recursive %} {% for enum in ns.enums %} template&lt;&gt; inline const char* flex_lib::Enum2String({{enum.fullQualifiedName}} e) { return {{enum.namespaceQualifier}}::{{enum.name}}ToString(e); } template&lt;&gt; inline {{enum.fullQualifiedName}} flex_lib::String2Enum&lt;{{enum.fullQualifiedName}}&gt;(const char* itemName) { return {{enum.namespaceQualifier}}::StringTo{{enum.name}}(itemName); } inline std::string to_string({{enum.fullQualifiedName}} e) { return {{enum.namespaceQualifier}}::{{enum.name}}ToString(e); } {% endfor %} {{loop(ns.namespaces)}} {% endfor %} {% endblock %}</span></span></span></span></code> </pre> <br>  <a href="">D'ici</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c98/7d6/5da/c987d65da32b047a4eb3d2b7630fb99c.jpg" alt="image" align="right" width="50%">  Il n'y avait qu'un seul probl√®me: aucun des moteurs que j'ai trouv√©s ne supportait l'ensemble des fonctionnalit√©s dont j'avais besoin.  Eh bien, bien s√ªr, tout le monde avait une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">faille fatale</a> standard.  J'ai r√©fl√©chi un peu et j'ai d√©cid√© qu'un autre monde n'empirerait pas d'une autre impl√©mentation du moteur de mod√®le.  De plus, selon les estimations, la fonctionnalit√© de base n'√©tait pas tellement difficile √† mettre en ≈ìuvre.  Apr√®s tout, maintenant en C ++ il y a des expressions rationnelles! <br>  Et donc le projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jinja2Cpp est n√©</a> .  Au d√©triment de la complexit√© de la mise en ≈ìuvre de la fonctionnalit√© de base (tr√®s basique), j'ai presque devin√©.  Dans l'ensemble, j'ai rat√© exactement le coefficient Pi au carr√©: il m'a fallu un peu moins de trois mois pour √©crire tout ce dont j'avais besoin.  Mais quand tout a √©t√© fini, fini et ins√©r√© dans le "Programmeur automatique" - j'ai r√©alis√© que je n'ai pas essay√© en vain.  En fait, l'utilitaire de g√©n√©ration de code a re√ßu un langage de script puissant combin√© √† des mod√®les, ce qui lui a ouvert de nouvelles opportunit√©s de d√©veloppement. <br>  NB: J'ai eu une id√©e pour fixer Python (ou Lua).  Mais aucun des moteurs de script √† part enti√®re existants ne r√©sout les probl√®mes ¬´pr√™ts √† l'emploi¬ª lors de la g√©n√©ration de texte √† partir de mod√®les.  Autrement dit, Python devrait encore visser le m√™me Jinja2, mais pour Lua, recherchez quelque chose de diff√©rent.  Pourquoi ai-je besoin de ce lien suppl√©mentaire? <br><br><h2>  Impl√©mentation de l'analyseur </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/d32/570/463/d325704634011d586894096d9e09b20f.png" alt="image" align="left" width="60%">  L'id√©e derri√®re la structure des mod√®les Jinja2 est assez simple.  S'il y a quelque chose dans le texte inclus dans une paire de "{{" / "}}", alors c'est "quelque chose" - une expression qui doit √™tre √©valu√©e, convertie en une repr√©sentation textuelle et ins√©r√©e dans le r√©sultat final.  A l'int√©rieur de la paire "{%" / "%}" se trouvent des op√©rateurs tels que, si, set, etc.  Apr√®s avoir √©tudi√© l'impl√©mentation de Jinja2CppLight, j'ai d√©cid√© qu'essayer de trouver manuellement toutes ces structures de contr√¥le dans le texte du mod√®le n'√©tait pas une tr√®s bonne id√©e.  Par cons√©quent, je me suis arm√© d'une expression rationnelle assez simple: ((\ \ {\ {) | (\} \}) | (\ {%) | (% \}) | (\ {#) | (# \}) | (\ n.  Et l'a appel√© la phase approximative de l'analyse.  Au stade initial du travail, l'id√©e a montr√© son efficacit√© (oui, en fait, elle montre toujours), mais, dans le bon sens, elle devra √™tre refactoris√©e √† l'avenir, car maintenant des restrictions mineures sont impos√©es sur le texte du mod√®le: paires d'√©chappement "{{" et "}}" dans le texte est √©galement trait√© "front". <br>  Dans la deuxi√®me phase, seul ce qui se trouve √† l'int√©rieur des ¬´crochets¬ª est analys√© en d√©tail.  Et ici, je devais bricoler.  Avec inja, avec Jinja2CppLight, l'analyseur d'expression est assez simple.  Dans le premier cas - sur la m√™me expression rationnelle, dans le second - manuscrite, mais ne supportant que des conceptions tr√®s simples.  La prise en charge des filtres, des testeurs, de l'arithm√©tique complexe ou de l'indexation est hors de question.  Et c'est pr√©cis√©ment ces caract√©ristiques de Jinja2 que je voulais le plus.  Par cons√©quent, je n'avais pas d'autre choix que de froisser un analyseur LL (1) √† part enti√®re (√† certains endroits - sensible au contexte) qui impl√©mente la grammaire n√©cessaire.  Il y a environ dix √† quinze ans, je prendrais probablement Bison ou ANTLR pour cela et impl√©menterais un analyseur avec leur aide.  Il y a environ sept ans, j'aurais essay√© Boost.Spirit.  Maintenant, je viens d'impl√©menter l'analyseur dont j'ai besoin, en utilisant la m√©thode de descente r√©cursive, sans g√©n√©rer de d√©pendances inutiles et augmenter consid√©rablement le temps de compilation, comme ce serait le cas si des utilitaires externes ou Boost.Spirit √©taient utilis√©s.  √Ä la sortie de l'analyseur, j'obtiens un AST (pour les expressions ou pour les op√©rateurs), qui est enregistr√© en tant que mod√®le, pr√™t pour le rendu ult√©rieur. <br><div class="spoiler">  <b class="spoiler_title">Un exemple de logique d'analyse</b> <div class="spoiler_text"><pre> <code class="cpp hljs">ExpressionEvaluatorPtr&lt;FullExpressionEvaluator&gt; ExpressionParser::ParseFullExpression(LexScanner &amp;lexer, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> includeIfPart) { ExpressionEvaluatorPtr&lt;FullExpressionEvaluator&gt; result; LexScanner::<span class="hljs-function"><span class="hljs-function">StateSaver </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lexer)</span></span></span></span>; ExpressionEvaluatorPtr&lt;FullExpressionEvaluator&gt; evaluator = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;FullExpressionEvaluator&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> value = ParseLogicalOr(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!value) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; evaluator-&gt;SetExpression(value); ExpressionEvaluatorPtr&lt;ExpressionFilter&gt; filter; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lexer.PeekNextToken() == <span class="hljs-string"><span class="hljs-string">'|'</span></span>) { lexer.EatToken(); filter = ParseFilterExpression(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!filter) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; evaluator-&gt;SetFilter(filter); } ExpressionEvaluatorPtr&lt;IfExpression&gt; ifExpr; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lexer.PeekNextToken() == Token::If) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (includeIfPart) { lexer.EatToken(); ifExpr = ParseIfExpression(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ifExpr) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; evaluator-&gt;SetTester(ifExpr); } } saver.Commit(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluator; } ExpressionEvaluatorPtr&lt;Expression&gt; ExpressionParser::ParseLogicalOr(LexScanner&amp; lexer) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> left = ParseLogicalAnd(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!left) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpressionEvaluatorPtr&lt;Expression&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lexer.NextToken() != Token::LogicalOr) { lexer.ReturnToken(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left; } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> right = ParseLogicalOr(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!right) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpressionEvaluatorPtr&lt;Expression&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;BinaryExpression&gt;(BinaryExpression::LogicalOr, left, right); } ExpressionEvaluatorPtr&lt;Expression&gt; ExpressionParser::ParseLogicalAnd(LexScanner&amp; lexer) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> left = ParseLogicalCompare(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!left) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpressionEvaluatorPtr&lt;Expression&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lexer.NextToken() != Token::LogicalAnd) { lexer.ReturnToken(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left; } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> right = ParseLogicalAnd(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!right) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpressionEvaluatorPtr&lt;Expression&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;BinaryExpression&gt;(BinaryExpression::LogicalAnd, left, right); } ExpressionEvaluatorPtr&lt;Expression&gt; ExpressionParser::ParseLogicalCompare(LexScanner&amp; lexer) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> left = ParseStringConcat(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!left) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpressionEvaluatorPtr&lt;Expression&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tok = lexer.NextToken(); BinaryExpression::Operation operation; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (tok.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Token::Equal: operation = BinaryExpression::LogicalEq; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Token::NotEqual: operation = BinaryExpression::LogicalNe; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'&lt;'</span></span>: operation = BinaryExpression::LogicalLt; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'&gt;'</span></span>: operation = BinaryExpression::LogicalGt; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Token::GreaterEqual: operation = BinaryExpression::LogicalGe; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Token::LessEqual: operation = BinaryExpression::LogicalLe; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Token::In: operation = BinaryExpression::In; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Token::Is: { Token nextTok = lexer.NextToken(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextTok != Token::Identifier) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpressionEvaluatorPtr&lt;Expression&gt;(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name = AsString(nextTok.value); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> valid = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; CallParams params; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lexer.NextToken() == <span class="hljs-string"><span class="hljs-string">'('</span></span>) params = ParseCallParams(lexer, valid); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> lexer.ReturnToken(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!valid) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpressionEvaluatorPtr&lt;Expression&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;IsExpression&gt;(left, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(name), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(params)); } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: lexer.ReturnToken(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left; } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> right = ParseStringConcat(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!right) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpressionEvaluatorPtr&lt;Expression&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;BinaryExpression&gt;(operation, left, right); }</code> </pre> <br>  <a href="">D'ici</a> . <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Fragment de classes d'arbres d'expression AST</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExpressionFilter</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IfExpression</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FullExpressionEvaluator</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ExpressionEvaluatorBase { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetExpression</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ExpressionEvaluatorPtr&lt;Expression&gt; expr)</span></span></span><span class="hljs-function"> </span></span>{ m_expression = expr; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetFilter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ExpressionEvaluatorPtr&lt;ExpressionFilter&gt; expr)</span></span></span><span class="hljs-function"> </span></span>{ m_filter = expr; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTester</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ExpressionEvaluatorPtr&lt;IfExpression&gt; expr)</span></span></span><span class="hljs-function"> </span></span>{ m_tester = expr; } <span class="hljs-function"><span class="hljs-function">InternalValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RenderContext&amp; values)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OutStream &amp;stream, RenderContext &amp;values)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: ExpressionEvaluatorPtr&lt;Expression&gt; m_expression; ExpressionEvaluatorPtr&lt;ExpressionFilter&gt; m_filter; ExpressionEvaluatorPtr&lt;IfExpression&gt; m_tester; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ValueRefExpression</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Expression { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ValueRefExpression(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> valueName) : m_valueName(valueName) { } <span class="hljs-function"><span class="hljs-function">InternalValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RenderContext&amp; values)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_valueName; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SubscriptExpression</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Expression { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: SubscriptExpression(ExpressionEvaluatorPtr&lt;Expression&gt; value, ExpressionEvaluatorPtr&lt;Expression&gt; subscriptExpr) : m_value(value) , m_subscriptExpr(subscriptExpr) { } <span class="hljs-function"><span class="hljs-function">InternalValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RenderContext&amp; values)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: ExpressionEvaluatorPtr&lt;Expression&gt; m_value; ExpressionEvaluatorPtr&lt;Expression&gt; m_subscriptExpr; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConstantExpression</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Expression { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ConstantExpression(InternalValue constant) : m_constant(constant) {} <span class="hljs-function"><span class="hljs-function">InternalValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RenderContext&amp;)</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_constant; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: InternalValue m_constant; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TupleCreator</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Expression { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TupleCreator(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;ExpressionEvaluatorPtr&lt;&gt;&gt; exprs) : m_exprs(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(exprs)) { } <span class="hljs-function"><span class="hljs-function">InternalValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RenderContext&amp;)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;ExpressionEvaluatorPtr&lt;&gt;&gt; m_exprs; };</code> </pre> <br>  <a href="">D'ici</a> . <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Exemples de classes d'op√©rateurs d'arbre AST</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Statement</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RendererBase { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T = Statement&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> StatementPtr = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;T&gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> CharT&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TemplateImpl</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ForStatement</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Statement { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ForStatement(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; vars, ExpressionEvaluatorPtr&lt;&gt; expr, ExpressionEvaluatorPtr&lt;&gt; ifExpr, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isRecursive) : m_vars(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(vars)) , m_value(expr) , m_ifExpr(ifExpr) , m_isRecursive(isRecursive) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetMainBody</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RendererPtr renderer)</span></span></span><span class="hljs-function"> </span></span>{ m_mainBody = renderer; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetElseBody</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RendererPtr renderer)</span></span></span><span class="hljs-function"> </span></span>{ m_elseBody = renderer; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OutStream&amp; os, RenderContext&amp; values)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RenderLoop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> InternalValue&amp; val, OutStream&amp; os, RenderContext&amp; values)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; m_vars; ExpressionEvaluatorPtr&lt;&gt; m_value; ExpressionEvaluatorPtr&lt;&gt; m_ifExpr; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_isRecursive; RendererPtr m_mainBody; RendererPtr m_elseBody; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ElseBranchStatement</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IfStatement</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Statement { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: IfStatement(ExpressionEvaluatorPtr&lt;&gt; expr) : m_expr(expr) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetMainBody</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RendererPtr renderer)</span></span></span><span class="hljs-function"> </span></span>{ m_mainBody = renderer; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddElseBranch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StatementPtr&lt;ElseBranchStatement&gt; branch)</span></span></span><span class="hljs-function"> </span></span>{ m_elseBranches.push_back(branch); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OutStream&amp; os, RenderContext&amp; values)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: ExpressionEvaluatorPtr&lt;&gt; m_expr; RendererPtr m_mainBody; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;StatementPtr&lt;ElseBranchStatement&gt;&gt; m_elseBranches; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ElseBranchStatement</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Statement { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ElseBranchStatement(ExpressionEvaluatorPtr&lt;&gt; expr) : m_expr(expr) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShouldRender</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RenderContext&amp; values)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetMainBody</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RendererPtr renderer)</span></span></span><span class="hljs-function"> </span></span>{ m_mainBody = renderer; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OutStream&amp; os, RenderContext&amp; values)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: ExpressionEvaluatorPtr&lt;&gt; m_expr; RendererPtr m_mainBody; };</code> </pre><br>  <a href="">D'ici</a> . <br></div></div><br>  Les n≈ìuds AST sont associ√©s uniquement au texte du mod√®le et sont convertis en valeurs totales au moment du rendu, en tenant compte du contexte de rendu actuel et de ses param√®tres.  Cela nous a permis de cr√©er des mod√®les thread-safe.  Mais plus √† ce sujet en termes de rendu r√©el. <br>  En tant que tokenizer principal, j'ai choisi la biblioth√®que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lexertk</a> .  Il a la licence dont j'ai besoin et uniquement en-t√™te.  Certes, j'ai d√ª couper toutes les cloches et les sifflets du calcul de l'√©quilibre des crochets, etc., et ne laisser que le tokenizer lui-m√™me, qui (apr√®s un peu de redressement avec un fichier) a appris √† fonctionner non seulement avec char, mais aussi avec les caract√®res wchar_t.  En plus de ce tokenizer, j'ai encapsul√© une autre classe qui remplit trois fonctions principales: a) il extrait le code de l'analyseur du type de caract√®res avec lequel nous travaillons, b) reconna√Æt les mots cl√©s sp√©cifiques √† Jinja2 et c) fournit une interface pratique pour travailler avec le flux de jetons: <br><div class="spoiler">  <b class="spoiler_title">LexScanner</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LexScanner</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> {</span></span> Lexer::TokensList::const_iterator m_begin; Lexer::TokensList::const_iterator m_end; Lexer::TokensList::const_iterator m_cur; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StateSaver</span></span></span><span class="hljs-class"> {</span></span> StateSaver(LexScanner&amp; scanner) : m_state(scanner.m_state) , m_scanner(scanner) { } ~StateSaver() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_commited) m_scanner.m_state = m_state; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Commit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_commited = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } State m_state; LexScanner&amp; m_scanner; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_commited = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }; LexScanner(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Lexer&amp; lexer) { m_state.m_begin = lexer.GetTokens().begin(); m_state.m_end = lexer.GetTokens().end(); Reset(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_state.m_cur = m_state.m_begin; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_state; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RestoreState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> State&amp; state)</span></span></span><span class="hljs-function"> </span></span>{ m_state = state; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> Token&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_state.m_cur == m_state.m_end) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EofToken(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_state.m_cur ++; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EatToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_state.m_cur != m_state.m_end) ++ m_state.m_cur; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReturnToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_state.m_cur != m_state.m_begin) -- m_state.m_cur; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> Token&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PeekNextToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_state.m_cur == m_state.m_end) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EofToken(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_state.m_cur; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EatIfEqual</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type, Token* tok = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nullptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EatIfEqual(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Token::Type&gt;(type), tok); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EatIfEqual</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Token::Type type, Token* tok = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nullptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_state.m_cur == m_state.m_end) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(type == Token::Type::Eof &amp;&amp; tok) *tok = EofToken(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type == Token::Type::Eof; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_state.m_cur-&gt;type == type) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tok) *tok = *m_state.m_cur; ++ m_state.m_cur; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: State m_state; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> Token&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EofToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Token eof; eof.type = Token::Eof; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> eof; } };</code> </pre> <br>  <a href="">D'ici</a> . <br></div></div><br>  Ainsi, malgr√© le fait que le moteur puisse fonctionner √† la fois avec char et wchar_t-templates, le code d'analyse principal ne d√©pend pas du type de caract√®re.  Mais plus √† ce sujet dans la section sur les aventures avec les types de personnages. <br>  S√©par√©ment, j'ai d√ª bricoler avec les structures de contr√¥le.  √Ä Jinja2, beaucoup d'entre eux sont jumel√©s.  Par exemple, pour / endfor, if / endif, block / endblock, etc. Chaque √©l√©ment de la paire va dans ses propres ¬´crochets¬ª, et entre les √©l√©ments il peut y avoir un tas de tout: juste du texte brut et d'autres blocs de contr√¥le.  Par cons√©quent, l'algorithme d'analyse syntaxique du mod√®le devait √™tre fait sur la base de la pile, √† l'√©l√©ment sup√©rieur actuel dont toutes les constructions et instructions nouvellement trouv√©es, ainsi que des fragments de texte simple entre eux, ¬´s'accrochent¬ª.  En utilisant la m√™me pile, l'absence de d√©s√©quilibrage du type if-for-endif-endfor est v√©rifi√©e.  √Ä la suite de tout cela, le code s'est av√©r√© ne pas √™tre aussi "compact" que, disons, Jinja2CppLight (ou inja), o√π l'impl√©mentation enti√®re est dans une seule source (ou en-t√™te).  Mais la logique d'analyse et, en fait, la grammaire du code sont plus clairement visibles, ce qui simplifie son support et son extension.  C'est du moins ce que je visais.  Il n'est toujours pas possible de minimiser le nombre de d√©pendances ou la quantit√© de code, vous devez donc le rendre plus clair. <br><br>  Dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie suivante,</a> nous parlerons du processus de rendu des mod√®les, mais pour l'instant - liens: <br>  Sp√©cification Jinja2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://jinja.pocoo.org/docs/2.10/templates/</a> <br>  Impl√©mentation de Jinja2Cpp: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/flexferrum/Jinja2Cpp</a> <br>  Impl√©mentation de Jinja2CppLight: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/hughperkins/Jinja2CppLight</a> <br>  Impl√©mentation endommag√©e: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/pantor/inja</a> <br>  Utilitaire pour g√©n√©rer du code bas√© sur des mod√®les Jinja2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/flexferrum/autoprogrammer/tree/jinja2cpp_refactor</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr416581/">https://habr.com/ru/post/fr416581/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr416569/index.html">Comme Prius, mais uniquement sous Linux: penser √† un bureau hybride</a></li>
<li><a href="../fr416573/index.html">Envoi d'e-mails √† partir de n'importe quelle adresse</a></li>
<li><a href="../fr416575/index.html">Analyse des perturbations de supraconductivit√© des grands aimants collisionneurs de hadrons au CERN</a></li>
<li><a href="../fr416577/index.html">Digest MBLT DEV - frais pour les d√©veloppeurs iOS</a></li>
<li><a href="../fr416579/index.html">Nous contr√¥lons les LED √† l'aide de l'API Web Bluetooth et d'Arduino</a></li>
<li><a href="../fr416583/index.html">Quel scanner 3D acheter? TOP 5 des meilleurs scanners 3D de 2018 de 3Dtool</a></li>
<li><a href="../fr416585/index.html">Extension Web multi-navigateur pour les scripts personnalis√©s Partie 3</a></li>
<li><a href="../fr416587/index.html">Quelques mots sur les subwoofers et pourquoi ils conviennent √† presque tout le monde</a></li>
<li><a href="../fr416589/index.html">Cellules mortes: utilisation du pipeline 3D pour l'animation 2D</a></li>
<li><a href="../fr416591/index.html">"Resserrer les noix": pourquoi tout le monde a commenc√© √† parler de resserrement de la r√©glementation du secteur informatique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>