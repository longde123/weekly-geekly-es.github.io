<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙎 🚃 🧤 Modèles de troisième ordre ou comment j'ai porté Jinja2 en C ++ 👃🏾 👩🏽‍🤝‍👩🏻 🏳️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les «modèles» dans le contexte de C ++ se réfèrent généralement à des constructions de langage très spécifiques. Il existe des modèles simples qui sim...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Modèles de troisième ordre ou comment j'ai porté Jinja2 en C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416581/"><img src="https://habrastorage.org/getpro/habr/post_images/c81/fe0/548/c81fe0548837b911b9569cdf49d90ca2.jpg" alt="Logo Jinja2" align="left">  Les «modèles» dans le contexte de C ++ se réfèrent généralement à des constructions de langage très spécifiques.  Il existe des modèles simples qui simplifient le travail avec le même type de code - ce sont des modèles de classe et de fonction.  Si un modèle possède l'un des paramètres par lui-même, il peut s'agir de modèles de second ordre et ils génèrent d'autres modèles en fonction de leurs paramètres.  Mais que faire si leurs capacités ne sont pas suffisantes et plus faciles pour générer immédiatement le texte source?  Beaucoup de code source? <br>  Les fans de Python et de mises en page HTML connaissent un outil (moteur, bibliothèque) pour travailler avec des modèles de texte appelé <b>Jinja2</b> .  À l'entrée, ce moteur reçoit un fichier modèle dans lequel le texte peut être mélangé avec des structures de contrôle, la sortie est un texte clair dans lequel toutes les structures de contrôle sont remplacées par du texte conformément aux paramètres spécifiés de l'extérieur (ou de l'intérieur).  En gros, c'est quelque chose comme des pages ASP (ou C ++ - préprocesseur), seul le langage de balisage est différent. <br>  Jusqu'à présent, l'implémentation de ce moteur était uniquement pour Python.  Maintenant c'est pour C ++.  Comment et pourquoi cela s'est produit, et sera discuté dans l'article. <br><a name="habracut"></a><br><h2>  Pourquoi ai-je même repris ça </h2><br>  En effet, pourquoi?  Après tout, il y a Python, pour cela - une excellente implémentation, un tas de fonctionnalités, une spécification complète pour le langage.  Prenez et utilisez!  Je n'aime pas Python - vous pouvez prendre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jinja2CppLight</a> ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">inja</a> , des ports partiels Jinja2 en C ++.  Vous pouvez, à la fin, prendre le port C ++ {{ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Moustache</a> }}.  Le diable, comme d'habitude, dans les détails.  Donc, disons, j'avais besoin de la fonctionnalité des filtres de Jinja2 et des capacités de la construction extend, qui vous permet de créer des modèles extensibles (et aussi des macros et include, mais plus tard).  Et aucune des implémentations mentionnées ne prend en charge cela.  Puis-je m'en passer?  Aussi une bonne question.  Jugez par vous-même.  J'ai un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">projet</a> dont le but est de créer un générateur de code passe-partout C ++ - to-C ++.  Cet autogénérateur reçoit, disons, un fichier d'en-tête écrit manuellement avec des structures ou des énumérations, et génère en fonction de lui des fonctions de sérialisation / désérialisation ou, par exemple, de conversion d'éléments d'énumération en chaînes (et vice versa).  Vous pouvez écouter plus de détails sur cet utilitaire dans mes rapports <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> (eng) ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> (rus). <br>  Ainsi, une tâche typique résolue dans le processus de travail sur l'utilitaire est la création de fichiers d'en-tête, dont chacun a un en-tête (avec ifdefs et inclut), un corps avec le contenu principal et un pied de page.  De plus, le contenu principal est les déclarations générées bourrées d'espace de noms.  En exécution C ++, le code pour créer un tel fichier d'en-tête ressemble à ceci (et ce n'est pas tout): <br><div class="spoiler">  <b class="spoiler_title">Beaucoup de code C ++</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Enum2StringGenerator::WriteHeaderContent(CppSourceStream &amp;hdrOs) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;reflection::EnumInfoPtr&gt; enums; WriteNamespaceContents(hdrOs, m_namespaces.GetRootNamespace(), [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;enums](CppSourceStream &amp;os, reflection::NamespaceInfoPtr ns) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; enumInfo : ns-&gt;enums) { WriteEnumToStringConversion(os, enumInfo); WriteEnumFromStringConversion(os, enumInfo); enums.push_back(enumInfo); } }); hdrOs &lt;&lt; <span class="hljs-string"><span class="hljs-string">"\n\n"</span></span>; { out::<span class="hljs-function"><span class="hljs-function">BracedStreamScope </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flNs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\nnamespace flex_lib"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\n\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; flNs; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (reflection::EnumInfoPtr enumInfo : enums) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> scopedParams = MakeScopedParams(hdrOs, enumInfo); { hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"template&lt;&gt;"</span></span>; out::<span class="hljs-function"><span class="hljs-function">BracedStreamScope </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"inline const char* Enum2String($enumFullQualifiedName$ e)"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; body; hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"return $namespaceQual$::$enumName$ToString(e);"</span></span>; } { hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"template&lt;&gt;"</span></span>; out::<span class="hljs-function"><span class="hljs-function">BracedStreamScope </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"inline $enumFullQualifiedName$ String2Enum&lt;$enumFullQualifiedName$&gt;(const char* itemName)"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; body; hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"return $namespaceQual$::StringTo$enumName$(itemName);"</span></span>; } } } { out::<span class="hljs-function"><span class="hljs-function">BracedStreamScope </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">flNs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\nnamespace std"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\n\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; flNs; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (reflection::EnumInfoPtr enumInfo : enums) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> scopedParams = MakeScopedParams(hdrOs, enumInfo); out::<span class="hljs-function"><span class="hljs-function">BracedStreamScope </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">body</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"inline std::string to_string($enumFullQualifiedName$ e)"</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"\n"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; body; hdrOs &lt;&lt; out::new_line(<span class="hljs-number"><span class="hljs-number">1</span></span>) &lt;&lt; <span class="hljs-string"><span class="hljs-string">"return $namespaceQual$::$enumName$ToString(e);"</span></span>; } } } <span class="hljs-comment"><span class="hljs-comment">// Enum item to string conversion writer void Enum2StringGenerator::WriteEnumToStringConversion(CppSourceStream &amp;hdrOs, const reflection::EnumInfoPtr &amp;enumDescr) { auto scopedParams = MakeScopedParams(hdrOs, enumDescr); out::BracedStreamScope fnScope("inline const char* $enumName$ToString($enumScopedName$ e)", "\n"); hdrOs &lt;&lt; out::new_line(1) &lt;&lt; fnScope; { out::BracedStreamScope switchScope("switch (e)", "\n"); hdrOs &lt;&lt; out::new_line(1) &lt;&lt; switchScope; out::OutParams innerParams; for (auto&amp; i : enumDescr-&gt;items) { innerParams["itemName"] = i.itemName; hdrOs &lt;&lt; out::with_params(innerParams) &lt;&lt; out::new_line(-1) &lt;&lt; "case $prefix$$itemName$:" &lt;&lt; out::new_line(1) &lt;&lt; "return \"$itemName$\";"; } } hdrOs &lt;&lt; out::new_line(1) &lt;&lt; "return \"Unknown Item\";"; } // String to enum conversion writer void Enum2StringGenerator::WriteEnumFromStringConversion(CppSourceStream &amp;hdrOs, const reflection::EnumInfoPtr &amp;enumDescr) { auto params = MakeScopedParams(hdrOs, enumDescr); out::BracedStreamScope fnScope("inline $enumScopedName$ StringTo$enumName$(const char* itemName)", "\n"); hdrOs &lt;&lt; out::new_line(1) &lt;&lt; fnScope; { out::BracedStreamScope itemsScope("static std::pair&lt;const char*, $enumScopedName$&gt; items[] = ", ";\n"); hdrOs &lt;&lt; out::new_line(1) &lt;&lt; itemsScope; out::OutParams&amp; innerParams = params.GetParams(); auto items = enumDescr-&gt;items; std::sort(begin(items), end(items), [](auto&amp; i1, auto&amp; i2) {return i1.itemName &lt; i2.itemName;}); for (auto&amp; i : items) { innerParams["itemName"] = i.itemName; hdrOs &lt;&lt; out::with_params(innerParams) &lt;&lt; out::new_line(1) &lt;&lt; "{\"$itemName$\", $prefix$$itemName$},"; } } hdrOs &lt;&lt; out::with_params(params.GetParams()) &lt;&lt; R"( $enumScopedName$ result; if (!flex_lib::detail::String2Enum(itemName, items, result)) flex_lib::bad_enum_name::Throw(itemName, "$enumName$"); return result;)"; }</span></span></code> </pre> <br>  <a href="">D'ici</a> . <br></div></div><br>  De plus, ce code change peu d'un fichier à l'autre.  Bien sûr, vous pouvez utiliser le format clang pour le formatage.  Mais cela n'annule pas le reste du travail manuel sur la génération du texte source. <br>  Et puis un beau moment, j'ai réalisé que ma vie devait être simplifiée.  Je n'ai pas envisagé l'option de visser un langage de script à part entière en raison de la complexité de la prise en charge du résultat final.  Mais pour trouver un moteur de modèle approprié - pourquoi pas?  Je l'ai trouvé utile pour rechercher, je l'ai trouvé, puis j'ai trouvé la spécification Jinja2 et j'ai réalisé que c'était exactement ce dont j'avais besoin.  Pour, conformément à cette spécification, les modèles de génération d'en-têtes devraient ressembler à ceci: <br><pre> <code class="cpp hljs">{% extends <span class="hljs-string"><span class="hljs-string">"header_skeleton.j2tpl"</span></span> %} {% block generator_headers %} <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;flex_lib/stringized_enum.h&gt; #include &lt;algorithm&gt; #include &lt;utility&gt; {% endblock %} {% block namespaced_decls %}{{super()}}{% endblock %} {% block namespace_content %} {% for enum in ns.enums | sort(attribute="name") %} {% set enumName = enum.name %} {% set scopeSpec = enum.scopeSpecifier %} {% set scopedName = scopeSpec ~ ('::' if scopeSpec) ~ enumName %} {% set prefix = (scopedName + '::') if not enumInfo.isScoped else (scopedName ~ '::' ~ scopeSpec ~ ('::' if scopeSpec)) %} inline const char* {{enumName}}ToString({{scopedName}} e) { switch (e) { {% for itemName in enum.items | map(attribute="itemName") | sort%} case {{prefix}}{{itemName}}: return "{{itemName}}"; {% endfor %} } return "Unknown Item"; } inline {{scopedName}} StringTo{{enumName}}(const char* itemName) { static std::pair&lt;const char*, {{scopedName}}&gt; items[] = { {% for itemName in enum.items | map(attribute="itemName") | sort %} {"{{itemName}}", {{prefix}}{{itemName}} } {{',' if not loop.last }} {% endfor %} }; {{scopedName}} result; if (!flex_lib::detail::String2Enum(itemName, items, result)) flex_lib::bad_enum_name::Throw(itemName, "{{enumName}}"); return result; } {% endfor %}{% endblock %} {% block global_decls %} {% for ns in [rootNamespace] recursive %} {% for enum in ns.enums %} template&lt;&gt; inline const char* flex_lib::Enum2String({{enum.fullQualifiedName}} e) { return {{enum.namespaceQualifier}}::{{enum.name}}ToString(e); } template&lt;&gt; inline {{enum.fullQualifiedName}} flex_lib::String2Enum&lt;{{enum.fullQualifiedName}}&gt;(const char* itemName) { return {{enum.namespaceQualifier}}::StringTo{{enum.name}}(itemName); } inline std::string to_string({{enum.fullQualifiedName}} e) { return {{enum.namespaceQualifier}}::{{enum.name}}ToString(e); } {% endfor %} {{loop(ns.namespaces)}} {% endfor %} {% endblock %}</span></span></span></span></code> </pre> <br>  <a href="">D'ici</a> . <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c98/7d6/5da/c987d65da32b047a4eb3d2b7630fb99c.jpg" alt="image" align="right" width="50%">  Il n'y avait qu'un seul problème: aucun des moteurs que j'ai trouvés ne supportait l'ensemble des fonctionnalités dont j'avais besoin.  Eh bien, bien sûr, tout le monde avait une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">faille fatale</a> standard.  J'ai réfléchi un peu et j'ai décidé qu'un autre monde n'empirerait pas d'une autre implémentation du moteur de modèle.  De plus, selon les estimations, la fonctionnalité de base n'était pas tellement difficile à mettre en œuvre.  Après tout, maintenant en C ++ il y a des expressions rationnelles! <br>  Et donc le projet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jinja2Cpp est né</a> .  Au détriment de la complexité de la mise en œuvre de la fonctionnalité de base (très basique), j'ai presque deviné.  Dans l'ensemble, j'ai raté exactement le coefficient Pi au carré: il m'a fallu un peu moins de trois mois pour écrire tout ce dont j'avais besoin.  Mais quand tout a été fini, fini et inséré dans le "Programmeur automatique" - j'ai réalisé que je n'ai pas essayé en vain.  En fait, l'utilitaire de génération de code a reçu un langage de script puissant combiné à des modèles, ce qui lui a ouvert de nouvelles opportunités de développement. <br>  NB: J'ai eu une idée pour fixer Python (ou Lua).  Mais aucun des moteurs de script à part entière existants ne résout les problèmes «prêts à l'emploi» lors de la génération de texte à partir de modèles.  Autrement dit, Python devrait encore visser le même Jinja2, mais pour Lua, recherchez quelque chose de différent.  Pourquoi ai-je besoin de ce lien supplémentaire? <br><br><h2>  Implémentation de l'analyseur </h2><br><img src="https://habrastorage.org/getpro/habr/post_images/d32/570/463/d325704634011d586894096d9e09b20f.png" alt="image" align="left" width="60%">  L'idée derrière la structure des modèles Jinja2 est assez simple.  S'il y a quelque chose dans le texte inclus dans une paire de "{{" / "}}", alors c'est "quelque chose" - une expression qui doit être évaluée, convertie en une représentation textuelle et insérée dans le résultat final.  A l'intérieur de la paire "{%" / "%}" se trouvent des opérateurs tels que, si, set, etc.  Après avoir étudié l'implémentation de Jinja2CppLight, j'ai décidé qu'essayer de trouver manuellement toutes ces structures de contrôle dans le texte du modèle n'était pas une très bonne idée.  Par conséquent, je me suis armé d'une expression rationnelle assez simple: ((\ \ {\ {) | (\} \}) | (\ {%) | (% \}) | (\ {#) | (# \}) | (\ n.  Et l'a appelé la phase approximative de l'analyse.  Au stade initial du travail, l'idée a montré son efficacité (oui, en fait, elle montre toujours), mais, dans le bon sens, elle devra être refactorisée à l'avenir, car maintenant des restrictions mineures sont imposées sur le texte du modèle: paires d'échappement "{{" et "}}" dans le texte est également traité "front". <br>  Dans la deuxième phase, seul ce qui se trouve à l'intérieur des «crochets» est analysé en détail.  Et ici, je devais bricoler.  Avec inja, avec Jinja2CppLight, l'analyseur d'expression est assez simple.  Dans le premier cas - sur la même expression rationnelle, dans le second - manuscrite, mais ne supportant que des conceptions très simples.  La prise en charge des filtres, des testeurs, de l'arithmétique complexe ou de l'indexation est hors de question.  Et c'est précisément ces caractéristiques de Jinja2 que je voulais le plus.  Par conséquent, je n'avais pas d'autre choix que de froisser un analyseur LL (1) à part entière (à certains endroits - sensible au contexte) qui implémente la grammaire nécessaire.  Il y a environ dix à quinze ans, je prendrais probablement Bison ou ANTLR pour cela et implémenterais un analyseur avec leur aide.  Il y a environ sept ans, j'aurais essayé Boost.Spirit.  Maintenant, je viens d'implémenter l'analyseur dont j'ai besoin, en utilisant la méthode de descente récursive, sans générer de dépendances inutiles et augmenter considérablement le temps de compilation, comme ce serait le cas si des utilitaires externes ou Boost.Spirit étaient utilisés.  À la sortie de l'analyseur, j'obtiens un AST (pour les expressions ou pour les opérateurs), qui est enregistré en tant que modèle, prêt pour le rendu ultérieur. <br><div class="spoiler">  <b class="spoiler_title">Un exemple de logique d'analyse</b> <div class="spoiler_text"><pre> <code class="cpp hljs">ExpressionEvaluatorPtr&lt;FullExpressionEvaluator&gt; ExpressionParser::ParseFullExpression(LexScanner &amp;lexer, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> includeIfPart) { ExpressionEvaluatorPtr&lt;FullExpressionEvaluator&gt; result; LexScanner::<span class="hljs-function"><span class="hljs-function">StateSaver </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">saver</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(lexer)</span></span></span></span>; ExpressionEvaluatorPtr&lt;FullExpressionEvaluator&gt; evaluator = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;FullExpressionEvaluator&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> value = ParseLogicalOr(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!value) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; evaluator-&gt;SetExpression(value); ExpressionEvaluatorPtr&lt;ExpressionFilter&gt; filter; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lexer.PeekNextToken() == <span class="hljs-string"><span class="hljs-string">'|'</span></span>) { lexer.EatToken(); filter = ParseFilterExpression(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!filter) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; evaluator-&gt;SetFilter(filter); } ExpressionEvaluatorPtr&lt;IfExpression&gt; ifExpr; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lexer.PeekNextToken() == Token::If) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (includeIfPart) { lexer.EatToken(); ifExpr = ParseIfExpression(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!ifExpr) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; evaluator-&gt;SetTester(ifExpr); } } saver.Commit(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evaluator; } ExpressionEvaluatorPtr&lt;Expression&gt; ExpressionParser::ParseLogicalOr(LexScanner&amp; lexer) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> left = ParseLogicalAnd(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!left) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpressionEvaluatorPtr&lt;Expression&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lexer.NextToken() != Token::LogicalOr) { lexer.ReturnToken(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left; } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> right = ParseLogicalOr(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!right) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpressionEvaluatorPtr&lt;Expression&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;BinaryExpression&gt;(BinaryExpression::LogicalOr, left, right); } ExpressionEvaluatorPtr&lt;Expression&gt; ExpressionParser::ParseLogicalAnd(LexScanner&amp; lexer) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> left = ParseLogicalCompare(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!left) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpressionEvaluatorPtr&lt;Expression&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lexer.NextToken() != Token::LogicalAnd) { lexer.ReturnToken(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left; } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> right = ParseLogicalAnd(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!right) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpressionEvaluatorPtr&lt;Expression&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;BinaryExpression&gt;(BinaryExpression::LogicalAnd, left, right); } ExpressionEvaluatorPtr&lt;Expression&gt; ExpressionParser::ParseLogicalCompare(LexScanner&amp; lexer) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> left = ParseStringConcat(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!left) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpressionEvaluatorPtr&lt;Expression&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> tok = lexer.NextToken(); BinaryExpression::Operation operation; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (tok.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Token::Equal: operation = BinaryExpression::LogicalEq; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Token::NotEqual: operation = BinaryExpression::LogicalNe; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'&lt;'</span></span>: operation = BinaryExpression::LogicalLt; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'&gt;'</span></span>: operation = BinaryExpression::LogicalGt; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Token::GreaterEqual: operation = BinaryExpression::LogicalGe; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Token::LessEqual: operation = BinaryExpression::LogicalLe; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Token::In: operation = BinaryExpression::In; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Token::Is: { Token nextTok = lexer.NextToken(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (nextTok != Token::Identifier) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpressionEvaluatorPtr&lt;Expression&gt;(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name = AsString(nextTok.value); <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> valid = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; CallParams params; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (lexer.NextToken() == <span class="hljs-string"><span class="hljs-string">'('</span></span>) params = ParseCallParams(lexer, valid); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> lexer.ReturnToken(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!valid) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpressionEvaluatorPtr&lt;Expression&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;IsExpression&gt;(left, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(name), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(params)); } <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: lexer.ReturnToken(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> left; } <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> right = ParseStringConcat(lexer); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!right) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ExpressionEvaluatorPtr&lt;Expression&gt;(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt;BinaryExpression&gt;(operation, left, right); }</code> </pre> <br>  <a href="">D'ici</a> . <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Fragment de classes d'arbres d'expression AST</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ExpressionFilter</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IfExpression</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FullExpressionEvaluator</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> ExpressionEvaluatorBase { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetExpression</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ExpressionEvaluatorPtr&lt;Expression&gt; expr)</span></span></span><span class="hljs-function"> </span></span>{ m_expression = expr; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetFilter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ExpressionEvaluatorPtr&lt;ExpressionFilter&gt; expr)</span></span></span><span class="hljs-function"> </span></span>{ m_filter = expr; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetTester</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ExpressionEvaluatorPtr&lt;IfExpression&gt; expr)</span></span></span><span class="hljs-function"> </span></span>{ m_tester = expr; } <span class="hljs-function"><span class="hljs-function">InternalValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RenderContext&amp; values)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OutStream &amp;stream, RenderContext &amp;values)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: ExpressionEvaluatorPtr&lt;Expression&gt; m_expression; ExpressionEvaluatorPtr&lt;ExpressionFilter&gt; m_filter; ExpressionEvaluatorPtr&lt;IfExpression&gt; m_tester; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ValueRefExpression</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Expression { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ValueRefExpression(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> valueName) : m_valueName(valueName) { } <span class="hljs-function"><span class="hljs-function">InternalValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RenderContext&amp; values)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> m_valueName; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SubscriptExpression</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Expression { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: SubscriptExpression(ExpressionEvaluatorPtr&lt;Expression&gt; value, ExpressionEvaluatorPtr&lt;Expression&gt; subscriptExpr) : m_value(value) , m_subscriptExpr(subscriptExpr) { } <span class="hljs-function"><span class="hljs-function">InternalValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RenderContext&amp; values)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: ExpressionEvaluatorPtr&lt;Expression&gt; m_value; ExpressionEvaluatorPtr&lt;Expression&gt; m_subscriptExpr; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConstantExpression</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Expression { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ConstantExpression(InternalValue constant) : m_constant(constant) {} <span class="hljs-function"><span class="hljs-function">InternalValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RenderContext&amp;)</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_constant; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: InternalValue m_constant; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TupleCreator</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Expression { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: TupleCreator(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;ExpressionEvaluatorPtr&lt;&gt;&gt; exprs) : m_exprs(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(exprs)) { } <span class="hljs-function"><span class="hljs-function">InternalValue </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Evaluate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RenderContext&amp;)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;ExpressionEvaluatorPtr&lt;&gt;&gt; m_exprs; };</code> </pre> <br>  <a href="">D'ici</a> . <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Exemples de classes d'opérateurs d'arbre AST</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Statement</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> RendererBase { }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T = Statement&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> StatementPtr = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;T&gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> CharT&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TemplateImpl</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ForStatement</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Statement { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ForStatement(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; vars, ExpressionEvaluatorPtr&lt;&gt; expr, ExpressionEvaluatorPtr&lt;&gt; ifExpr, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> isRecursive) : m_vars(<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(vars)) , m_value(expr) , m_ifExpr(ifExpr) , m_isRecursive(isRecursive) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetMainBody</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RendererPtr renderer)</span></span></span><span class="hljs-function"> </span></span>{ m_mainBody = renderer; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetElseBody</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RendererPtr renderer)</span></span></span><span class="hljs-function"> </span></span>{ m_elseBody = renderer; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OutStream&amp; os, RenderContext&amp; values)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RenderLoop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> InternalValue&amp; val, OutStream&amp; os, RenderContext&amp; values)</span></span></span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; m_vars; ExpressionEvaluatorPtr&lt;&gt; m_value; ExpressionEvaluatorPtr&lt;&gt; m_ifExpr; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_isRecursive; RendererPtr m_mainBody; RendererPtr m_elseBody; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ElseBranchStatement</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IfStatement</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Statement { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: IfStatement(ExpressionEvaluatorPtr&lt;&gt; expr) : m_expr(expr) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetMainBody</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RendererPtr renderer)</span></span></span><span class="hljs-function"> </span></span>{ m_mainBody = renderer; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddElseBranch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(StatementPtr&lt;ElseBranchStatement&gt; branch)</span></span></span><span class="hljs-function"> </span></span>{ m_elseBranches.push_back(branch); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OutStream&amp; os, RenderContext&amp; values)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: ExpressionEvaluatorPtr&lt;&gt; m_expr; RendererPtr m_mainBody; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;StatementPtr&lt;ElseBranchStatement&gt;&gt; m_elseBranches; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ElseBranchStatement</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Statement { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ElseBranchStatement(ExpressionEvaluatorPtr&lt;&gt; expr) : m_expr(expr) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ShouldRender</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RenderContext&amp; values)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SetMainBody</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(RendererPtr renderer)</span></span></span><span class="hljs-function"> </span></span>{ m_mainBody = renderer; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Render</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(OutStream&amp; os, RenderContext&amp; values)</span></span></span><span class="hljs-function"> override</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: ExpressionEvaluatorPtr&lt;&gt; m_expr; RendererPtr m_mainBody; };</code> </pre><br>  <a href="">D'ici</a> . <br></div></div><br>  Les nœuds AST sont associés uniquement au texte du modèle et sont convertis en valeurs totales au moment du rendu, en tenant compte du contexte de rendu actuel et de ses paramètres.  Cela nous a permis de créer des modèles thread-safe.  Mais plus à ce sujet en termes de rendu réel. <br>  En tant que tokenizer principal, j'ai choisi la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">lexertk</a> .  Il a la licence dont j'ai besoin et uniquement en-tête.  Certes, j'ai dû couper toutes les cloches et les sifflets du calcul de l'équilibre des crochets, etc., et ne laisser que le tokenizer lui-même, qui (après un peu de redressement avec un fichier) a appris à fonctionner non seulement avec char, mais aussi avec les caractères wchar_t.  En plus de ce tokenizer, j'ai encapsulé une autre classe qui remplit trois fonctions principales: a) il extrait le code de l'analyseur du type de caractères avec lequel nous travaillons, b) reconnaît les mots clés spécifiques à Jinja2 et c) fournit une interface pratique pour travailler avec le flux de jetons: <br><div class="spoiler">  <b class="spoiler_title">LexScanner</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LexScanner</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State</span></span></span><span class="hljs-class"> {</span></span> Lexer::TokensList::const_iterator m_begin; Lexer::TokensList::const_iterator m_end; Lexer::TokensList::const_iterator m_cur; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StateSaver</span></span></span><span class="hljs-class"> {</span></span> StateSaver(LexScanner&amp; scanner) : m_state(scanner.m_state) , m_scanner(scanner) { } ~StateSaver() { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!m_commited) m_scanner.m_state = m_state; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Commit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_commited = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } State m_state; LexScanner&amp; m_scanner; <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> m_commited = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }; LexScanner(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Lexer&amp; lexer) { m_state.m_begin = lexer.GetTokens().begin(); m_state.m_end = lexer.GetTokens().end(); Reset(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ m_state.m_cur = m_state.m_begin; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_state; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">RestoreState</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> State&amp; state)</span></span></span><span class="hljs-function"> </span></span>{ m_state = state; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> Token&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_state.m_cur == m_state.m_end) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EofToken(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_state.m_cur ++; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EatToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_state.m_cur != m_state.m_end) ++ m_state.m_cur; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReturnToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_state.m_cur != m_state.m_begin) -- m_state.m_cur; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> Token&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PeekNextToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_state.m_cur == m_state.m_end) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EofToken(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *m_state.m_cur; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EatIfEqual</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> type, Token* tok = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nullptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> EatIfEqual(<span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Token::Type&gt;(type), tok); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EatIfEqual</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Token::Type type, Token* tok = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">nullptr</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_state.m_cur == m_state.m_end) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(type == Token::Type::Eof &amp;&amp; tok) *tok = EofToken(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> type == Token::Type::Eof; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (m_state.m_cur-&gt;type == type) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tok) *tok = *m_state.m_cur; ++ m_state.m_cur; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: State m_state; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> Token&amp; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">EofToken</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Token eof; eof.type = Token::Eof; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> eof; } };</code> </pre> <br>  <a href="">D'ici</a> . <br></div></div><br>  Ainsi, malgré le fait que le moteur puisse fonctionner à la fois avec char et wchar_t-templates, le code d'analyse principal ne dépend pas du type de caractère.  Mais plus à ce sujet dans la section sur les aventures avec les types de personnages. <br>  Séparément, j'ai dû bricoler avec les structures de contrôle.  À Jinja2, beaucoup d'entre eux sont jumelés.  Par exemple, pour / endfor, if / endif, block / endblock, etc. Chaque élément de la paire va dans ses propres «crochets», et entre les éléments il peut y avoir un tas de tout: juste du texte brut et d'autres blocs de contrôle.  Par conséquent, l'algorithme d'analyse syntaxique du modèle devait être fait sur la base de la pile, à l'élément supérieur actuel dont toutes les constructions et instructions nouvellement trouvées, ainsi que des fragments de texte simple entre eux, «s'accrochent».  En utilisant la même pile, l'absence de déséquilibrage du type if-for-endif-endfor est vérifiée.  À la suite de tout cela, le code s'est avéré ne pas être aussi "compact" que, disons, Jinja2CppLight (ou inja), où l'implémentation entière est dans une seule source (ou en-tête).  Mais la logique d'analyse et, en fait, la grammaire du code sont plus clairement visibles, ce qui simplifie son support et son extension.  C'est du moins ce que je visais.  Il n'est toujours pas possible de minimiser le nombre de dépendances ou la quantité de code, vous devez donc le rendre plus clair. <br><br>  Dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">partie suivante,</a> nous parlerons du processus de rendu des modèles, mais pour l'instant - liens: <br>  Spécification Jinja2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">http://jinja.pocoo.org/docs/2.10/templates/</a> <br>  Implémentation de Jinja2Cpp: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/flexferrum/Jinja2Cpp</a> <br>  Implémentation de Jinja2CppLight: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/hughperkins/Jinja2CppLight</a> <br>  Implémentation endommagée: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/pantor/inja</a> <br>  Utilitaire pour générer du code basé sur des modèles Jinja2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://github.com/flexferrum/autoprogrammer/tree/jinja2cpp_refactor</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr416581/">https://habr.com/ru/post/fr416581/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr416569/index.html">Comme Prius, mais uniquement sous Linux: penser à un bureau hybride</a></li>
<li><a href="../fr416573/index.html">Envoi d'e-mails à partir de n'importe quelle adresse</a></li>
<li><a href="../fr416575/index.html">Analyse des perturbations de supraconductivité des grands aimants collisionneurs de hadrons au CERN</a></li>
<li><a href="../fr416577/index.html">Digest MBLT DEV - frais pour les développeurs iOS</a></li>
<li><a href="../fr416579/index.html">Nous contrôlons les LED à l'aide de l'API Web Bluetooth et d'Arduino</a></li>
<li><a href="../fr416583/index.html">Quel scanner 3D acheter? TOP 5 des meilleurs scanners 3D de 2018 de 3Dtool</a></li>
<li><a href="../fr416585/index.html">Extension Web multi-navigateur pour les scripts personnalisés Partie 3</a></li>
<li><a href="../fr416587/index.html">Quelques mots sur les subwoofers et pourquoi ils conviennent à presque tout le monde</a></li>
<li><a href="../fr416589/index.html">Cellules mortes: utilisation du pipeline 3D pour l'animation 2D</a></li>
<li><a href="../fr416591/index.html">"Resserrer les noix": pourquoi tout le monde a commencé à parler de resserrement de la réglementation du secteur informatique</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>