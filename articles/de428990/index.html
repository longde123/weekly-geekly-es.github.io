<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👏🏽 👨🏻‍💻 🐥 Konfigurationsbeispiele für UIViewController mit RouteComposer 👩🏿‍⚖️ 🙆🏿 🙅🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="In einem früheren Artikel habe ich über den Ansatz gesprochen, den wir zum Erstellen und Navigieren zwischen Ansichtscontrollern in mehreren Anwendung...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Konfigurationsbeispiele für UIViewController mit RouteComposer</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428990/"><p>  In einem früheren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel habe</a> ich über den Ansatz gesprochen, den wir zum Erstellen und Navigieren zwischen Ansichtscontrollern in mehreren Anwendungen verwenden, an denen ich arbeite, was zu einer separaten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RouteComposer-</a> Bibliothek führte.  Ich erhielt eine beträchtliche Menge angenehmer Rückmeldungen zum vorherigen Artikel und einige praktische Ratschläge, die mich dazu veranlassten, einen weiteren zu schreiben, der etwas mehr über die Konfiguration der Bibliothek erklärt.  Unter dem Schnitt werde ich versuchen, einige der häufigsten Konfigurationen zu erkennen. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d7f/4aa/20b/d7f4aa20b4b089f9de5a0f13600f9a1f.jpg"></p><a name="habracut"></a><br><h3 id="kak-router-razbiraet-konfiguraciyu">  Wie der Router die Konfiguration analysiert </h3><br><p>  Überlegen Sie zunächst, wie der Router die von Ihnen geschriebene Konfiguration analysiert.  Nehmen Sie das Beispiel aus dem vorherigen Artikel: </p><br><pre><code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> productScreen = <span class="hljs-type"><span class="hljs-type">StepAssembly</span></span>(finder: <span class="hljs-type"><span class="hljs-type">ClassFinder</span></span>(options: [.current, .visible]), factory: <span class="hljs-type"><span class="hljs-type">ProductViewControllerFactory</span></span>()) .using(<span class="hljs-type"><span class="hljs-type">UINavigationController</span></span>.pushToNavigation()) .from(<span class="hljs-type"><span class="hljs-type">SingleContainerStep</span></span>(finder: <span class="hljs-type"><span class="hljs-type">NilFinder</span></span>(), factory: <span class="hljs-type"><span class="hljs-type">NavigationControllerFactory</span></span>())) .using(<span class="hljs-type"><span class="hljs-type">GeneralAction</span></span>.presentModally()) .from(<span class="hljs-type"><span class="hljs-type">GeneralStep</span></span>.current()) .assemble()</code> </pre> <br><p>  Der Router durchläuft die Schrittkette von Anfang an, bis einer der Schritte (mithilfe des mitgelieferten <code>Finder</code> ) „meldet“, dass sich der gewünschte <code>UIViewController</code> bereits auf dem Stapel befindet.  <em>(So ​​ist beispielsweise <code>GeneralStep.current()</code> garantiert im Controller-Ansichtsstapel vorhanden.)</em> Anschließend bewegt sich der Router entlang der <code>UIViewController</code> , erstellt die erforderlichen <code>UIViewController</code> mit den bereitgestellten <code>UIViewController</code> und integriert sie mit den angegebenen <code>Action</code> .  Dank der Typprüfung können Sie bereits in der Kompilierungsphase häufig keine <code>UITabBarController.addTab</code> , die mit der bereitgestellten <code>Fabric</code> nicht kompatibel sind ( <code>UITabBarController.addTab</code> Sie können <code>UITabBarController.addTab</code> in dem von <code>NavigationControllerFactory</code> <code>UITabBarController.addTab</code> ). </p><br><p>  Wenn Sie sich die oben beschriebene Konfiguration vorstellen und nur einen bestimmten <code>ProductViewController</code> auf dem Bildschirm haben, werden die folgenden Schritte ausgeführt: </p><br><ol><li>  <code>ProductViewController</code> findet <code>ProductViewController</code> und der Router <code>ProductViewController</code> fort </li><li>  <code>NilFinder</code> wird niemals etwas finden und der Router wird <code>NilFinder</code> </li><li>  <code>GeneralStep.current</code> gibt immer den obersten <code>UIViewController</code> auf dem Stapel zurück. </li><li>  <code>UIViewController</code> , wird der Router zurückgeschaltet </li><li>  <code>UINavigationController</code> einen <code>UINavigationController</code> mit der NavigationControllerFactory </li><li>  Zeigt es modal mit <code>GeneralAction.presentModally</code> </li><li>  <code>ProductViewController</code> ProductViewController <code>ProductViewControllerFactory</code> </li><li>  Integriert den erstellten <code>UINavigationController</code> mithilfe von <code>UINavigationController.pushToNavigation</code> in den vorherigen <code>UINavigationController.pushToNavigation</code> </li><li>  Beenden Sie die Navigation </li></ol><br><p>  <strong>NB:</strong> <em>Es versteht sich, dass es in der Realität unmöglich ist, einen <code>UINavigationController</code> ohne einen darin enthaltenen <code>UINavigationController</code> modal <code>UIViewController</code> .</em>  <em>Daher werden die Schritte 5 bis 8 vom Router in einer etwas anderen Reihenfolge ausgeführt.</em>  <em>Aber du solltest nicht darüber nachdenken.</em>  <em>Die Konfiguration wird nacheinander beschrieben.</em> </p><br><p>  Wenn Sie eine Konfiguration schreiben, sollten Sie davon ausgehen, dass sich der Benutzer derzeit an einer beliebigen Stelle in Ihrer Anwendung befindet und plötzlich eine Push-Nachricht mit der Aufforderung erhält, zu dem von Ihnen beschriebenen Bildschirm zu gelangen, und versuchen, die Frage zu beantworten: "Wie soll sich die Anwendung verhalten?" ? "," Wie verhält sich der <code>Finder</code> in der von mir beschriebenen Konfiguration? ".  Wenn all diese Fragen berücksichtigt werden, erhalten Sie eine Konfiguration, die dem Benutzer garantiert den gewünschten Bildschirm anzeigt, wo immer er sich befindet.  Dies ist die Hauptanforderung für moderne Anwendungen der Teams, die mit dem Marketing und der Gewinnung <em>(Einbeziehung) von</em> Benutzern befasst sind. </p><br><h3 id="stackiteratingfinder-i-ego-opcii">  <code>StackIteratingFinder</code> und seine Optionen: </h3><br><p>  Sie können das <code>Finder</code> Konzept so implementieren, wie Sie es für am akzeptabelsten halten.  Am einfachsten ist es jedoch, das Diagramm der Ansichtssteuerungen auf dem Bildschirm zu durchlaufen.  Um dieses Ziel zu vereinfachen, bietet die Bibliothek <code>StackIteratingFinder</code> und verschiedene Implementierungen, die diese Aufgabe übernehmen.  Sie müssen nur die Frage beantworten - ist dies der <code>UIViewController</code> , den Sie erwarten. </p><br><p>  Um das Verhalten des <code>StackIteratingFinder</code> zu beeinflussen und <code>StackIteratingFinder</code> , in welchen Teilen des Diagramms (Stacks) die Controller suchen sollen, können <code>SearchOptions</code> beim Erstellen eine Kombination von <code>SearchOptions</code> angeben.  Und sie sollten genauer darauf eingehen: </p><br><ul><li>  <code>current</code> : Der oberste Ansichtscontroller auf dem Stapel.  ( <code>rootViewController</code> der <code>UIWindow</code> des <code>UIWindow</code> oder derjenige, der ganz oben modal angezeigt wird) </li><li>  <code>visible</code> : Wenn der <code>UIViewController</code> ein Container ist, schauen Sie in seinen sichtbaren <code>UIViewController</code> (Beispiel: <code>UINavigationController</code> immer einen sichtbaren <code>UIViewController</code> , <code>UISplitController</code> kann je nach <code>UISplitController</code> einen oder zwei haben). </li><li>  <code>contained</code> : Falls der <code>UIViewController</code> ein Container ist, suchen Sie in allen verschachtelten <code>UIViewController</code> (Beispiel: Gehen Sie alle View-Controller des <code>UINavigationController</code> einschließlich des sichtbaren). </li><li>  <code>presenting</code> : Suche auch in allen <code>UIViewController</code> ah unter dem <code>UIViewController</code> (wenn es natürlich gibt) </li><li>  <em><code>presented</code></em> : <code>UIViewController</code> nach dem bereitgestellten (für <code>StackIteratingFinder</code> diese Option nicht sinnvoll, da sie immer von oben beginnt). </li></ul><br><p>  Die folgende Abbildung kann die obige Erklärung deutlicher machen: <br><img src="https://habrastorage.org/webt/4j/pn/p5/4jpnp5peadzdj-cbk0tlfusbwxe.png"></p><br><p>  Ich würde empfehlen, sich in einem früheren Artikel mit dem Konzept der Container vertraut zu machen. </p><br><p>  <em>Beispiel</em> Wenn Ihr <code>Finder</code> im gesamten Stapel nach einem <code>AccountViewController</code> suchen soll, jedoch nur unter den sichtbaren <code>UIViewController</code> , sollte dies folgendermaßen geschrieben werden: </p><br><pre> <code class="swift hljs"><span class="hljs-type"><span class="hljs-type">ClassFinder</span></span>&lt;<span class="hljs-type"><span class="hljs-type">AccountViewController</span></span>, <span class="hljs-type"><span class="hljs-type">Any?</span></span>&gt;(options: [.current, .visible, .presenting])</code> </pre> <br><p>  <strong>NB</strong> <em>Wenn aus irgendeinem Grund nur wenige Einstellungen zur Verfügung stehen, können Sie Ihre Implementierung von <code>Finder</code> a jederzeit problemlos schreiben.</em>  <em>Ein Beispiel wird in diesem Artikel sein.</em> </p><br><p>  Kommen wir tatsächlich zu den Beispielen. </p><br><h3 id="primery-konfiguraciy-s-poyasneniyami">  Beispiele für Konfigurationen mit Erläuterungen </h3><br><h4 id="u-menya-est-nekiy-uiviewcontroller-kotoryy-yavlyaetsya-rootviewcontrollerom-uiwindow-i-ya-hochu-chtoby-po-okonchanii-navigacii-on-zamenilsya-na-nekiy-homeviewcontroller">  Ich habe einen bestimmten <code>UIViewController</code> , den <code>rootViewController</code> <code>UIWindow</code> , und möchte, dass er am Ende der Navigation durch einen bestimmten <code>HomeViewController</code> ersetzt wird: </h4><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> screen = <span class="hljs-type"><span class="hljs-type">StepAssembly</span></span>( finder: <span class="hljs-type"><span class="hljs-type">ClassFinder</span></span>&lt;<span class="hljs-type"><span class="hljs-type">HomeViewController</span></span>, <span class="hljs-type"><span class="hljs-type">Any?</span></span>&gt;(), factory: <span class="hljs-type"><span class="hljs-type">XibFactory</span></span>()) .using(<span class="hljs-type"><span class="hljs-type">GeneralAction</span></span>.replaceRoot()) .from(<span class="hljs-type"><span class="hljs-type">GeneralStep</span></span>.root()) .assemble()</code> </pre><br><p>  <em><code>XibFactory</code> lädt <code>HomeViewController</code> aus der xib-Datei von <code>HomeViewController.xib</code></em> </p><br><p>  <em>Vergessen Sie nicht, dass Sie, wenn Sie abstrakte Implementierungen von <code>Finder</code> und <code>Factory</code> in Kombination verwenden, den Typ von <code>UIViewController</code> und den Kontext für mindestens eine der Entitäten angeben müssen - <code>ClassFinder&lt;HomeViewController, Any?&gt;</code></em> </p><br><h4 id="chto-proizoydet-esli-v-primere-vyshe-ya-zamenyu-generalsteproot-na-generalstepcurrent">  Was passiert, wenn ich im obigen Beispiel <code>GeneralStep.root</code> durch <code>GeneralStep.current</code> ersetze? </h4><br><p>  Die Konfiguration funktioniert so lange, bis sie aufgerufen wird, wenn ein modaler <code>UIViewController</code> auf dem Bildschirm angezeigt wird.  In diesem Fall kann <code>GeneralAction.replaceRoot</code> den Root-Controller nicht ersetzen, da sich darüber ein modaler Controller befindet und der Router einen Fehler meldet.  Wenn diese Konfiguration trotzdem funktionieren soll, müssen Sie dem Router erklären, dass <code>GeneralAction.replaceRoot</code> speziell auf den Root- <code>UIViewController</code> angewendet werden <code>UIViewController</code> .  Dann entfernt der Router alle modal dargestellten <code>UIViewController</code> und die Konfiguration funktioniert in jeder Situation. </p><br><h4 id="ya-hochu-pokazat-nekiy-accountviewcontroller-v-sluchae-esli-on-esche-nu-pokazan-vnutri-lyubogo-uinavigationcontrollera-kotoryy-v-dannyy-moment-est-gde-libo-na-ekrane-dazhe-esli-etot-uinavigationcontroller-pod-nekim-modalnym-uiviewcontrollerom">  Ich möchte einen <code>AccountViewController</code> in einem <code>UINavigationController</code> <code>AccountViewController</code> , wenn er noch gut <code>UINavigationController</code> und der sich derzeit irgendwo auf dem Bildschirm befindet (selbst wenn sich dieser <code>UINavigationController</code> unter einem modalen <code>UIViewController</code> ): </h4><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> screen = <span class="hljs-type"><span class="hljs-type">StepAssembly</span></span>( finder: <span class="hljs-type"><span class="hljs-type">ClassFinder</span></span>&lt;<span class="hljs-type"><span class="hljs-type">AccountViewController</span></span>, <span class="hljs-type"><span class="hljs-type">Any?</span></span>&gt;(), factory: <span class="hljs-type"><span class="hljs-type">XibFactory</span></span>()) .using(<span class="hljs-type"><span class="hljs-type">UINavigationController</span></span>.pushToNavigation()) .from(<span class="hljs-type"><span class="hljs-type">SingleStep</span></span>(<span class="hljs-type"><span class="hljs-type">ClassFinder</span></span>&lt;<span class="hljs-type"><span class="hljs-type">UINavigationController</span></span>, <span class="hljs-type"><span class="hljs-type">Any?</span></span>&gt;(), <span class="hljs-type"><span class="hljs-type">NilFactory</span></span>())) .from(<span class="hljs-type"><span class="hljs-type">GeneralStep</span></span>.current()) .assemble()</code> </pre><br><p>  Was bedeutet <code>NilFactory</code> in dieser Konfiguration?  Auf diese Weise teilen Sie dem Router mit, dass er, wenn er keinen <code>UINavigationController</code> auf dem Bildschirm finden konnte, ihn nicht erstellen und in diesem Fall nur nichts tun soll.  Da dies <code>NilFactory</code> , können Sie danach keine <code>Action</code> mehr verwenden. </p><br><h4 id="ya-hochu-pokazat-nekiy-accountviewcontroller-v-sluchae-esli-on-esche-ne-pokazan-vnutri-lyubogo-uinavigationcontrollera-kotoryy-v-dannyy-moment-est-gde-libo-na-ekrane-a-esli-takovogo-uinavigationcontrollera-ne-okazhetsya---sozdat-ego-i-pokazat-modalno">  Ich möchte einen <code>AccountViewController</code> in einem <code>UINavigationController</code> der sich noch irgendwo auf dem Bildschirm befindet. Wenn er sich nicht als solcher herausstellt, erstellen Sie ihn und zeigen Sie ihn modal an: </h4><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> screen = <span class="hljs-type"><span class="hljs-type">StepAssembly</span></span>( finder: <span class="hljs-type"><span class="hljs-type">ClassFinder</span></span>&lt;<span class="hljs-type"><span class="hljs-type">AccountViewController</span></span>, <span class="hljs-type"><span class="hljs-type">Any?</span></span>&gt;(), factory: <span class="hljs-type"><span class="hljs-type">XibFactory</span></span>()) .using(<span class="hljs-type"><span class="hljs-type">UINavigationController</span></span>.<span class="hljs-type"><span class="hljs-type">PushToNavigation</span></span>()) .from(<span class="hljs-type"><span class="hljs-type">SwitchAssembly</span></span>&lt;<span class="hljs-type"><span class="hljs-type">UINavigationController</span></span>, <span class="hljs-type"><span class="hljs-type">Any?</span></span>&gt;() .addCase(expecting: <span class="hljs-type"><span class="hljs-type">ClassFinder</span></span>&lt;<span class="hljs-type"><span class="hljs-type">UINavigationController</span></span>, <span class="hljs-type"><span class="hljs-type">Any?</span></span>&gt;(options: .visible)) <span class="hljs-comment"><span class="hljs-comment">//   -    .assemble(default: { //      return ChainAssembly() .from(SingleContainerStep(finder: NilFinder(), factory: NavigationControllerFactory())) .using(GeneralAction.presentModally()) .from(GeneralStep.current()) .assemble() }) ).assemble()</span></span></code> </pre> <br><h4 id="ya-hochu-pokazat-uitabbarcontroller-s-tabami-soderzhaschimi-homeviewcontroller-i-accountviewcontroller-zameniv-im-tekuschiy-rut">  Ich möchte <code>UITabBarController</code> mit <code>UITabBarController</code> <code>HomeViewController</code> die <code>HomeViewController</code> und <code>AccountViewController</code> und diese durch das aktuelle Stammverzeichnis ersetzen: </h4><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> tabScreen = <span class="hljs-type"><span class="hljs-type">SingleContainerStep</span></span>( finder: <span class="hljs-type"><span class="hljs-type">ClassFinder</span></span>(), factory: <span class="hljs-type"><span class="hljs-type">CompleteFactoryAssembly</span></span>(factory: <span class="hljs-type"><span class="hljs-type">TabBarControllerFactory</span></span>()) .with(<span class="hljs-type"><span class="hljs-type">XibFactory</span></span>&lt;<span class="hljs-type"><span class="hljs-type">HomeViewController</span></span>, <span class="hljs-type"><span class="hljs-type">Any?</span></span>&gt;(), using: <span class="hljs-type"><span class="hljs-type">UITabBarController</span></span>.addTab()) .with(<span class="hljs-type"><span class="hljs-type">XibFactory</span></span>&lt;<span class="hljs-type"><span class="hljs-type">AccountViewController</span></span>, <span class="hljs-type"><span class="hljs-type">Any?</span></span>&gt;(), using: <span class="hljs-type"><span class="hljs-type">UITabBarController</span></span>.addTab()) .assemble()) .using(<span class="hljs-type"><span class="hljs-type">GeneralAction</span></span>.replaceRoot()) .from(<span class="hljs-type"><span class="hljs-type">GeneralStep</span></span>.root()) .assemble()</code> </pre> <br><h4 id="mogu-li-ya-ispolzovat-kastomnyy-uiviewcontrollertransitioningdelegate-s-ekshenom-generalactionpresentmodally">  Kann ich das benutzerdefinierte <code>UIViewControllerTransitioningDelegate</code> mit der Aktion <code>GeneralAction.presentModally</code> : </h4><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> transitionController = <span class="hljs-type"><span class="hljs-type">CustomViewControllerTransitioningDelegate</span></span>() <span class="hljs-comment"><span class="hljs-comment">//     .using(GeneralAction.PresentModally(transitioningDelegate: transitionController))</span></span></code> </pre> <br><h4 id="ya-hochu-pereyti-v-accountviewcontroller-gde-by-polzovatel-ne-nahodilsya-v-drugom-tabe-ili-dazhe-v-kakom-to-modalnom-okne">  Ich möchte zu <code>AccountViewController</code> gehen, wo immer sich der Benutzer befindet, auf einer anderen Registerkarte oder sogar in einem modalen Fenster: </h4><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> screen = <span class="hljs-type"><span class="hljs-type">StepAssembly</span></span>( finder: <span class="hljs-type"><span class="hljs-type">ClassFinder</span></span>&lt;<span class="hljs-type"><span class="hljs-type">AccountViewController</span></span>, <span class="hljs-type"><span class="hljs-type">Any?</span></span>&gt;(), factory: <span class="hljs-type"><span class="hljs-type">NilFactory</span></span>()) .from(tabScreen) .assemble()</code> </pre> <br><p>  <em>Warum verwenden wir <code>NilFactory</code> ?</em>  <em>Wir müssen keinen <code>AccountViewController</code> wenn er nicht gefunden wird.</em>  <em>Es wird in der <code>tabScreen</code> Konfiguration erstellt.</em>  <em>Sehen Sie sie oben.</em> </p><br><h4 id="ya-hochu-pokazat-modalno-forgotpasswordviewcontroller-no-obyazatelno-posle-loginviewcontrollera-vnutri-uinavigationcontrollera">  Ich möchte <code>ForgotPasswordViewController</code> modal <code>ForgotPasswordViewController</code> , aber <code>LoginViewController</code> nach <code>LoginViewController</code> in <code>UINavigationController</code> : </h4><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> loginScreen = <span class="hljs-type"><span class="hljs-type">StepAssembly</span></span>( finder: <span class="hljs-type"><span class="hljs-type">ClassFinder</span></span>&lt;<span class="hljs-type"><span class="hljs-type">LoginViewController</span></span>, <span class="hljs-type"><span class="hljs-type">Any?</span></span>&gt;(), factory: <span class="hljs-type"><span class="hljs-type">XibFactory</span></span>()) .using(<span class="hljs-type"><span class="hljs-type">UINavigationController</span></span>.pushToNavigation()) .from(<span class="hljs-type"><span class="hljs-type">NavigationControllerStep</span></span>()) .using(<span class="hljs-type"><span class="hljs-type">GeneralAction</span></span>.presentModally()) .from(<span class="hljs-type"><span class="hljs-type">GeneralStep</span></span>.current()) .assemble() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> forgotPasswordScreen = <span class="hljs-type"><span class="hljs-type">StepAssembly</span></span>( finder: <span class="hljs-type"><span class="hljs-type">ClassFinder</span></span>&lt;<span class="hljs-type"><span class="hljs-type">ForgotPasswordViewController</span></span>, <span class="hljs-type"><span class="hljs-type">Any?</span></span>&gt;(), factory: <span class="hljs-type"><span class="hljs-type">XibFactory</span></span>()) .using(<span class="hljs-type"><span class="hljs-type">UINavigationController</span></span>.pushToNavigation()) .from(loginScreen.expectingContainer()) .assemble()</code> </pre> <br><p>  <em>Sie können die Konfiguration im Beispiel für die Navigation in <code>ForgotPasswordViewController</code> und <code>LoginViewController</code></em> </p><br><h4 id="dlya-chego-expectingcontainer-v-primere-vyshe">  Warum im obigen Beispiel Container <code>expectingContainer</code> ? </h4><br><p>  Da für die <code>pushToNavigation</code> Aktion ein <code>UINavigationController</code> und in der darauf folgenden Konfiguration erforderlich ist, können wir mit der <code>UINavigationController</code> Methode einen Kompilierungsfehler vermeiden, indem wir sicherstellen, dass der <code>loginScreen</code> , wenn der Router <code>loginScreen</code> <code>UINavigationController</code> . </p><br><h4 id="chto-proizoydet-esli-v-konfiguracii-vyshe-ya-zamenyu-generalstepcurrent-na-generalsteproot">  Was passiert, wenn ich in der obigen Konfiguration <code>GeneralStep.current</code> durch <code>GeneralStep.root</code> ersetze? </h4><br><p>  Es wird funktionieren, aber da Sie dem Router mitteilen, dass er eine Kette aus dem Root- <code>UIViewController</code> , werden modale <code>UIViewController</code> über dem Router <code>UIViewController</code> , bevor Sie mit dem <code>UIViewController</code> der Kette beginnen. </p><br><h4 id="v-moem-prilozhenii-est-uitabbarcontroller-soderzhaschiy-homeviewcontroller-i-bagviewcontroller-v-kachestve-tabov-ya-hochu-chtoby-polzovatel-mog-mezhdu-nimi-pereklyuchatsya-ispolzuya-ikonki-na-tabah-kak-obychno-no-esli-ya-vyzovu-konfiguraciya-programmno-naprimer-polzovatel-nazhmet-go-to-bag-vnutri-homeviewcontroller-prilozhenie-dolzhno-ne-pereklyuchit-tab-a-pokazat-bagviewcontroller-modalno">  Meine Anwendung verfügt über einen <code>UITabBarController</code> , der <code>HomeViewController</code> und <code>BagViewController</code> als Registerkarten enthält.  Ich möchte, dass der Benutzer wie gewohnt mithilfe der Symbole auf den Registerkarten zwischen ihnen wechseln kann.  Wenn ich die Konfiguration jedoch programmgesteuert <code>HomeViewController</code> (z. B. wenn der Benutzer im <code>HomeViewController</code> "Gehe zu Tasche" <code>HomeViewController</code> ), sollte die Anwendung die Registerkarte nicht wechseln, sondern den <code>BagViewController</code> modal <code>BagViewController</code> . </h4><br><p>  In der Konfiguration gibt es drei Möglichkeiten, dies zu erreichen: </p><br><ol><li>  <code>StackIteratingFinder</code> Sie <code>StackIteratingFinder</code> , dass nur in sichtbaren mit [.current, .visible] gesucht wird. </li><li>  Verwenden Sie <code>NilFinder</code> was bedeutet, dass der Router den BagViewController niemals in den <code>BagViewController</code> und ihn immer erstellt.  Dieser Ansatz hat jedoch einen Nebeneffekt: Wenn beispielsweise ein Benutzer, der sich bereits in <code>BagViewController</code> befindet, modal dargestellt wird und beispielsweise auf einen universellen Link <code>BagViewController</code> , den <code>BagViewController</code> soll, findet der Router ihn nicht und erstellt eine andere Instanz und zeigt ihn darüber an modal.  Dies ist möglicherweise nicht das, was Sie wollen. </li><li>  Ändern Sie einen kleinen <code>ClassFinder</code> so, dass nur der <code>BagViewController</code> , der modal <code>BagViewController</code> , den Rest ignoriert und ihn bereits in der Konfiguration verwendet. </li></ol><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ModalBagFinder</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StackIteratingFinder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">isTarget</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">_</span></span></span></span><span class="hljs-function"><span class="hljs-params"> viewController: BagViewController, with context: </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Any</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">Bool</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewController.presentingViewController != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> screen = <span class="hljs-type"><span class="hljs-type">StepAssembly</span></span>( finder: <span class="hljs-type"><span class="hljs-type">ModalBagFinder</span></span>(), factory: <span class="hljs-type"><span class="hljs-type">XibFactory</span></span>()) .using(<span class="hljs-type"><span class="hljs-type">UINavigationController</span></span>.pushToNavigation()) .from(<span class="hljs-type"><span class="hljs-type">NavigationControllerStep</span></span>()) .using(<span class="hljs-type"><span class="hljs-type">GeneralAction</span></span>.presentModally()) .from(<span class="hljs-type"><span class="hljs-type">GeneralStep</span></span>.current()) .assemble()</code> </pre> <br><h3 id="vmesto-zaklyucheniya">  Anstelle einer Schlussfolgerung </h3><br><p>  Ich hoffe, die Methoden zur Konfiguration des Routers sind etwas klarer geworden.  Wie gesagt, wir verwenden diesen Ansatz in drei Anwendungen und sind noch nicht auf eine Situation gestoßen, in der er nicht flexibel genug ist.  Die Bibliothek sowie die Implementierung des ihr zur Verfügung gestellten Routers verwenden keine objektiven Tricks zur Laufzeit und folgen vollständig allen Cocoa Touch-Konzepten. Sie helfen nur dabei, den Kompositionsprozess in Schritte zu unterteilen und in der angegebenen Reihenfolge auszuführen und mit den iOS-Versionen 9 bis 12 zu testen Dieser Ansatz passt in alle Architekturmuster, bei denen mit dem <code>UIViewController</code> Stack gearbeitet wird (MVC, MVVM, VIP, RIB, VIPER usw.). </p><br><p>  Ich würde mich über Ihre Kommentare und Vorschläge freuen.  Vor allem, wenn Sie der Meinung sind, dass es sich lohnt, einige Aspekte genauer zu betrachten.  Vielleicht muss das Konzept der Kontexte geklärt werden. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428990/">https://habr.com/ru/post/de428990/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428980/index.html">Offline JavaScript Broker</a></li>
<li><a href="../de428982/index.html">Wie schreibe ich D auf ARM</a></li>
<li><a href="../de428984/index.html">Julia und Phasenporträts dynamischer Systeme</a></li>
<li><a href="../de428986/index.html">ThinkJava-Konferenz Nr. 8 in Charkow</a></li>
<li><a href="../de428988/index.html">Tipps der Natur - Bewölktes Nachtlicht</a></li>
<li><a href="../de428992/index.html">Selektiver Bypass von Sperren auf Routern mit Padavan- und Keenetic OS-Firmware</a></li>
<li><a href="../de428994/index.html">Vernetzung in Android mit Corutin und Retrofit</a></li>
<li><a href="../de428996/index.html">Club der anonymen Weihnachtsmänner 2018-2019 auf Habrahabr</a></li>
<li><a href="../de428998/index.html">Verwendung der neuen experimentellen Profiler-Funktion in React</a></li>
<li><a href="../de429000/index.html">Warum Bill Gates die Toilette für 233 Milliarden Dollar erfunden hat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>