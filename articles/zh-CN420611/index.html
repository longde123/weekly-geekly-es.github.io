<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍❤️‍💋‍👨 ✌🏾 👨‍👩‍👧‍👧 C＃中的量子纠缠建模 🥦 🕑 🧓🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="随着量子纠缠的话题越来越频繁地出现，我想更深入些。 从有关量子纠缠的文章的评论来看，这些信息对我个人而言不会有用。 好吧，考虑到对于我们大多数人来说，程序代码比其他寓言要方便得多，因此决定以代码形式表达我的理解。 

 本文扩展了另一位作者的文章“傻瓜的量子纠缠” （我建议阅读它，对我有很大帮助）。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C＃中的量子纠缠建模</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420611/"> 随着量子纠缠的话题越来越频繁地出现，我想更深入些。 从有关量子纠缠的文章的评论来看，这些信息对我个人而言不会有用。 好吧，考虑到对于我们大多数人来说，程序代码比其他寓言要方便得多，因此决定以代码形式表达我的理解。 <br><a name="habracut"></a><br> 本文扩展了另一位作者<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a>文章<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">“傻瓜的量子纠缠”</a> （我建议阅读它，对我有很大帮助）。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">indomit</a>在他的文章中给出了一个程序示例，该程序清楚地说明了隐藏参数理论的问题，但无法给出重叠粒子的代码示例。 在本文中，我们将尝试模拟2种情况： <br><br><ol><li> 当在测量之前确定粒子的状态时，纠缠的粒子如何在确定性中表现，我们根本无法在不引入失真的情况下对其进行测量（隐藏参数的理论）。 我们得到了数字，看到了与实践的差异。 </li><li> 我们将编写一个重叠的纠缠粒子模型（在测量之前未定义粒子的状态）。 让我们尝试假设粒子是如何在内部编程的，也就是说，我们将其代码适合通过实验获得的数据。 </li></ol><br> 本文基于对Mermin量子纠缠现象的流行解释： <br><br><div class="spoiler">  <b class="spoiler_title">Mermin悖论解释</b> <div class="spoiler_text"> 对于悖论的流行报道，D。Mermin建议构造一个简单的设备[23]。 该设备应包括一个粒子发射器和两个检测器。 两个相同的粒子发射到每个粒子。 捕获到粒子后，检测器会给出一个二进制答案（0或1），具体取决于粒子及其三位置调谐开关。 检测一对粒子应该给出相同的答案： <br><br><ol><li> 只要检测器的配置方式相同。 </li><li> 据统计，一半情况是随机配置的。 </li></ol><br> 第一个属性要求所有检测器使用相同的编码，切换位置为∈{1,2,3}↦response∈{0,1}，没有任何随机性元素。 也就是说，他们必须事先同意将0或1中的哪个响应赋予开关位置，为每个粒子选择八个可能的函数000、001、010、011、100、101、110和111中的一个。将选择000或111不论控制旋钮的位置如何，检测器读数的100％一致。 如果检测器执行其余六个功能之一，则在2/3的情况下，其中一个数字将由随机调谐的开关拉出，另一个数字的可能性为1/3。 这两个答案的重合概率为（⅔）²+（⅓）²= 5/9。 因此，无论自动机算法是什么，相关性都不可避免地超过50％，违反了第二个要求。 <br><br>  <i>但是由于仍然可以制造这样的机器（例如，按照波姆的实验将偏振器定位在120°），因此即使是隐藏形式也没有确定性（参数）。</i>  <i>取而代之的是，通过将信息从一个“被测量”的粒子传输到另一个粒子的速度比第二个测量更快地保持了响应相关性。</i> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">取自这里</a> 。 <br></div></div><br> 不幸的是，我没有专业的物理学知识，甚至没有业余水平的物理学知识，我也不装得很完美。 本文的主要目的是演示如何使熟悉编程的人可以理解模型。 如果有人在该领域从事专业工作，那么不要指责，而是尝试根据我的文章编写更准确的交互模型。 <br><br><h2>  [更新]对Mermin的描述的说明 </h2><br> 尽管自撰写本文以来已过去了几个月，但没有人会再讨论它，但我还是决定澄清一下，以平息我的良心。 <br><br> 我进行了进一步的总结，得出结论，大大简化了根据Mermin的描述，并将其与真实的物理实验联系起来<i>毫无意义</i> 。 <br><br> 最初，我试图将文章链接到具有圆极化的真实实验，但在此方面我犯了一个错误。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">ARad</a>尝试开发与实际物理实验的绑定，写出所犯的错误，甚至提出<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了自己的代码版本</a> （也不与任何物理实验相对应）。 <br><br> 为了使本文至少有意义，决定删除所有与实际物理实验的虚构链接，并简单地<i>在代码中解释Mermin的描述</i>并使其更加直观。 真实的实验更加复杂，要模拟它们，您需要花费更多的时间。 <br><br> 在本文的第一个版本中，我们接受了在第一个实验中（传感器的位置重合），粒子给出了镜面结果，但是根据Mermin的原始描述，传感器位置相同的测量结果始终重合。 这是<i>固定的</i> 。 <br><br> 另外，我将对此Mermin自己添加一个“解释说明”，因为它的含义并不明确： <br><br><blockquote> 也就是说，他们必须事先同意将0或1中的哪个响应赋予开关位置，为每个粒子选择八个可能的函数000、001、010、011、100、101、110和111中的一个。 <br></blockquote><br> 短语“八个可能的功能”是模棱两可的。 讨论了颗粒对传感器的<i>潜在</i>影响的八种可能的变体。 传感器具有三个位置（请参见上面的完整说明）。 如果我们相信两个粒子的状态是重合的并且是预先设置的，那么我们可以预先确定对于开关的三个位置中的每个位置，我们可能会收到哪个响应（0或1）（尽管我们只能“测量”三个选项之一）。 <br><br><blockquote> 选择000或111将导致检测器读数的100％匹配，而与调节旋钮的位置无关。 </blockquote><br> 如果粒子的值可以使我们对任何开关位置都可能收到“ 1”的响应（对于任何开关位置都可以得到0），那么在这些情况下的第二个实验将给出100％的重合。 要达到50％，可以排除这些选项。 <br><br><blockquote> 如果检测器执行其余六个功能之一，则在2/3的情况下，其中一个数字将由随机调谐的开关拉出，另一个数字的可能性为1/3。 </blockquote><br> 这意味着，在6个三元组（001、010、011、100、101、110）中的每一个中，三个数字中只有两个匹配（在第一个版本中，三个数字中的两个为“ 0”，三个数字中的一个为“ 1”） ） <br><br> 为了评估可能性，我们为第一种情况<b>001</b>编译了一个表： <br><br><table><tbody><tr><th> 传感器位置1 </th><th> 传感器位置2 </th><th> 尺寸是否匹配 </th></tr><tr><td>  1个 </td><td>  1个 </td><td>  + </td></tr><tr><td>  1个 </td><td>  2 </td><td>  + </td></tr><tr><td>  1个 </td><td>  3 </td><td>  -- </td></tr><tr><td>  2 </td><td>  1个 </td><td>  + </td></tr><tr><td>  2 </td><td>  2 </td><td>  + </td></tr><tr><td>  2 </td><td>  3 </td><td>  -- </td></tr><tr><td>  3 </td><td>  1个 </td><td>  -- </td></tr><tr><td>  3 </td><td>  2 </td><td>  -- </td></tr><tr><td>  3 </td><td>  3 </td><td>  + </td></tr></tbody></table><br> 可以看出，在九种测量中有五种是重合的。 这六个选项中的每个都有相同的概率（毕竟，在每个选项中，两个数字相同）。 <br><br><h2> 测量值 </h2><br> 在每个模型（确定性模型和叠加模型）中，我们将根据Mermin对与第一和第二条件相对应的纠缠粒子进行两个实验： <br><br><ol><li> 首先，将两个传感器设置在同一位置。 在这种情况下，我们将获得100％相同的结果（如果第一个光子通过偏振器，则关联的光子也将以相同的角度通过偏振器）。 </li><li> 然后，我们将随机设置传感器的位置。 </li></ol><br> 这是第一个实验的代码： <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> totalAttempts = <span class="hljs-number"><span class="hljs-number">10000</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     var position = GetRandomInteger(1, 3); //        //            int firstSensorPosition = position; int secondSensorPosition = position; bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" №1: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); //  </span></span></code> </pre> <br> 这是第二个实验的代码： <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> totalAttempts = <span class="hljs-number"><span class="hljs-number">10000</span></span>; <span class="hljs-comment"><span class="hljs-comment">//   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     int firstSensorPosition = GetRandomInteger(1, 3); //      1 int secondSensorPosition = GetRandomInteger(1, 3); //      2 bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" №2: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100);</span></span></code> </pre><br> 所有粒子模型都将进行相同的测试，只有确定性模型和叠加模型的粒子代码会有所不同（更多内容请参见下文）。 <br><br><h2> 确定性模型 </h2><br> 注意！ 请参阅本文结尾处的UPDATE！ <br><br> 对于那些想立即运行代码的人，可以从浏览器中完成： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">dotnetfiddle.net/N5Xg18</a> <br><br> 因此，根据Mermin的解释，我们有一个带有3个参数的量子粒子： <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   ( , ) public class Particle { private bool _measured = false; public bool A { get; private set; } //       1 public bool B { get; private set; } //       2 public bool C { get; private set; } //       3 public Particle(bool a, bool b, bool c) { A = a; B = b; C = c; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (_measured) throw new InvalidOperationException("    !"); _measured = true; switch (sensorPosition) { case 1: return A; case 2: return B; case 3: return C; default: throw new ArgumentOutOfRangeException(); } } }</span></span></code> </pre><br> 由于模型是确定性的，因此在创建粒子时即直接在构造函数中初始化粒子的所有参数。 唯一的条件是只能进行一次测量！ <br><br> 下一个 一对纠缠的粒子： <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (   ,         ) public EntanglementParticles() { //         bool a; bool b; bool c; do { a = GetRandomBoolean(); //     1 b = GetRandomBoolean(); //     2 c = GetRandomBoolean(); ; //     3 } while (a == b &amp;&amp; b == c); //   000  111 (    ,       ) First = new Particle(a, b, c); Second = new Particle(a, b, c); //       } }</span></span></code> </pre><br><br> 可以看出，每个粒子的值是在创建一对纠缠粒子时设置的，第二个粒子的参数与第一个粒子的参数相对应（没有这个参数，我们将无法通过第一个测试）。 我们使用随机数，但根据模型，参数取决于缠结时的因素（由于轮盘赌，它取决于解捻时的许多因素）。 <br><br> 完整的示例代码： <br><br><div class="spoiler">  <b class="spoiler_title">确定性模型的C＃代码（固定）</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Random Random = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); <span class="hljs-comment"><span class="hljs-comment">//   public class Particle { private bool _measured = false; public bool A { get; private set; } //       1 public bool B { get; private set; } //       2 public bool C { get; private set; } //       3 public Particle(bool a, bool b, bool c) { A = a; B = b; C = c; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (_measured) throw new InvalidOperationException("    !"); _measured = true; switch (sensorPosition) { case 1: return A; case 2: return B; case 3: return C; default: throw new ArgumentOutOfRangeException(); } } } //    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (   ,         ) public EntanglementParticles() { //         bool a; bool b; bool c; do { a = GetRandomBoolean(); //     1 b = GetRandomBoolean(); //     2 c = GetRandomBoolean();; //     3 } while (a == b &amp;&amp; b == c); //   000  111 (   ,       ) First = new Particle(a, b, c); Second = new Particle(a, b, c); //       } } public static void Main(string[] args) { Experiment1(); Experiment2(); } private static void Experiment1() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     var position = GetRandomInteger(1, 3); //        //            int firstSensorPosition = position; int secondSensorPosition = position; bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" №1: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); //   } private static void Experiment2() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     int firstSensorPosition = GetRandomInteger(1, 3); //      1 int secondSensorPosition = GetRandomInteger(1, 3); //      2 bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" №2: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); } private static bool GetRandomBoolean() { return GetRandomInteger(0, 1) == 1; } private static int GetRandomInteger(int from, int to) { return Random.Next(from, to + 1); //          } }</span></span></code> </pre><br></div></div><br> 您可以从浏览器中启动它（再次<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">单击</a>链接： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">dotnetfiddle.net/N5Xg18</a> ）。 <br><br> 启动后，结果如下： <br><br><blockquote> 实验1：100％的值重合 <br> 实验2：匹配值的55.6700％ <br></blockquote><br> 通过的第一个测试对应于实际情况。 但是第二个-不匹配，因为他们应该获得50％！ <br><br> 结果，物理学家被迫得出结论，即隐藏参数的理论是错误的。 与此<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">相抵触的是局部性</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">原理，</a>甚至动摇<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">了因果关系原理</a> 。 <br><br><h2> 叠加模型 </h2><br> 紧接着提供了一个示例代码的链接，供那些喜欢特定细节的人使用（可以在浏览器中启动）： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">dotnetfiddle.net/Mb7JqU</a> <br><br> 为了解释实验期间获得的结果，有必要使用更复杂的模型。 在现代模型中，粒子参数的状态未在测量前定义，并且纠缠的粒子本身具有立即（超过光速）影响彼此状态的能力。 这是我们的粒子模型现在的样子： <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//   public class Particle { private Particle _superluminalChannel; //         . private int? _measuredPosition; public bool? A { get; private set; } //       1 public bool? B { get; private set; } //       2 public bool? C { get; private set; } //       3 internal void CreateSuperluminalChannelWith(Particle particle) { _superluminalChannel = particle; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (null != _measuredPosition) throw new InvalidOperationException("    !"); _measuredPosition = sensorPosition; if (null != _superluminalChannel._measuredPosition) //        { var measuredValue = _superluminalChannel.GetNakedValue(); //         (    ),   ,     . if (sensorPosition == _superluminalChannel._measuredPosition) return measuredValue; if (GetRandomInteger(1, 4) == 1) return measuredValue; return !measuredValue; } //  .        ,       -  . //   ! var value = GetRandomBoolean(); SetValue(sensorPosition, value); return value; } private bool GetNakedValue() //           ,    . { if (null == _measuredPosition) throw new InvalidOperationException(); switch (_measuredPosition.Value) { case 1: return A.Value; case 2: return B.Value; case 3: return C.Value; default: throw new InvalidOperationException(); } } private void SetValue(int position, bool value) { switch (position) { case 1: A = value; break; case 2: B = value; break; case 3: C = value; break; default: throw new ArgumentOutOfRangeException(); } } }</span></span></code> </pre><br> 首先，参数是可空的（它们可能无关紧要），并且我们不在构造函数中设置它们。 其次，使用CreateSuperluminalChannelWith方法设置粒子之间的超光通道，即 现在，无论距离多远，一个粒子都可以立即获得另一个粒子的状态。 好，最重要的是，现在<i>仅在测量时才建立</i>粒子的状态（称为GetValue方法），并且取决于是否已测量与其相关的另一个粒子。 <br><br>  GetValue方法的内部是纯粹的推测。 没有人知道粒子在内部的排列方式，但是我们知道它的工作原理是：测量相同参数时100％不匹配，而以随机顺序测量参数时50％不匹配。 <br><br> 在我的代码版本中，通过超光通道的粒子检查是否将测量结果与它混淆，并且行为如下： <br><br><ol><li> 如果另一个粒子的测量参数与我们尝试测量的参数相同，则其值相同。 </li><li> 如果参数不同，则在1/4的情况下将给出相同的值，在3/4的情况下将给出相反的值（因为得到50/50）。 </li></ol><br> 如果未执行测量，则粒子将使用真正的随机性来设置其值，即违反因果关系（该值在测量之前不存在，并且测量本身无法确定其值）。 <br><br>  <i>对了！</i>  <i>您可以用另一种方式重写此功能，但是测试结果相同。</i>  <i>无论如何，没有人知道基本粒子的排列方式以及第二次测试如何达到50％。</i> <i><br></i> <br> 一对纠缠的粒子变得更容易，因为在纠缠时未设置任何值（尚未确定值）： <br><br><pre> <code class="cs hljs"><span class="hljs-comment"><span class="hljs-comment">//    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (  ,   ) public EntanglementParticles() { First = new Particle(); //   ,    Second = new Particle(); //   ,    //         First.CreateSuperluminalChannelWith(Second); Second.CreateSuperluminalChannelWith(First); } }</span></span></code> </pre><br> 完整的示例代码： <br><br><div class="spoiler">  <b class="spoiler_title">C＃中的叠加模型</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> Random Random = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Random(); <span class="hljs-comment"><span class="hljs-comment">//   public class Particle { private Particle _superluminalChannel; //         . private int? _measuredPosition; public bool? A { get; private set; } //       1 public bool? B { get; private set; } //       2 public bool? C { get; private set; } //       3 internal void CreateSuperluminalChannelWith(Particle particle) { _superluminalChannel = particle; } //         ( 3 ). public bool GetValue(int sensorPosition) { if (null != _measuredPosition) throw new InvalidOperationException("    !"); _measuredPosition = sensorPosition; if (null != _superluminalChannel._measuredPosition) //        { var measuredValue = _superluminalChannel.GetNakedValue(); //         (    ),   ,     . if (sensorPosition == _superluminalChannel._measuredPosition) return measuredValue; if (GetRandomInteger(1, 4) == 1) return measuredValue; return !measuredValue; } //  .        ,       -  . //   ! var value = GetRandomBoolean(); SetValue(sensorPosition, value); return value; } private bool GetNakedValue() //           ,    . { if (null == _measuredPosition) throw new InvalidOperationException(); switch (_measuredPosition.Value) { case 1: return A.Value; case 2: return B.Value; case 3: return C.Value; default: throw new InvalidOperationException(); } } private void SetValue(int position, bool value) { switch (position) { case 1: A = value; break; case 2: B = value; break; case 3: C = value; break; default: throw new ArgumentOutOfRangeException(); } } } //    public class EntanglementParticles { public Particle First { get; private set; } //   public Particle Second { get; private set; } //   //     (  ,   ) public EntanglementParticles() { First = new Particle(); //   ,    Second = new Particle(); //   ,    //         First.CreateSuperluminalChannelWith(Second); Second.CreateSuperluminalChannelWith(First); } } public static void Main(string[] args) { Experiment1(); Experiment2(); } private static void Experiment1() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     var position = GetRandomInteger(1, 3); //        //            int firstSensorPosition = position; int secondSensorPosition = position; bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" №1: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); //   } private static void Experiment2() { var totalAttempts = 10000; //   var coincidenceCount = 0; //    for (int attemptNumber = 1; attemptNumber &lt;= totalAttempts; attemptNumber++) { var entanglementParticles = new EntanglementParticles(); //     int firstSensorPosition = GetRandomInteger(1, 3); //      1 int secondSensorPosition = GetRandomInteger(1, 3); //      2 bool firstValue = entanglementParticles.First.GetValue(firstSensorPosition); //         bool secondValue = entanglementParticles.Second.GetValue(secondSensorPosition); //         if (firstValue == secondValue) //     coincidenceCount ++; } Console.WriteLine(" №2: {0}%  ", (decimal)coincidenceCount / totalAttempts * 100); } private static bool GetRandomBoolean() { return GetRandomInteger(0, 1) == 1; } private static int GetRandomInteger(int from, int to) { return Random.Next(from, to + 1); //          } }</span></span></code> </pre><br></div></div><br> 结果： <br><br><blockquote> 实验1：100％的值重合 <br> 实验2：49.7700％的值重合 <br></blockquote><br> 在浏览器中运行： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">dotnetfiddle.net/Mb7JqU</a> <br><br><h2> 结论 </h2><br> 我想提供更多解释，例如Mermin的解释。 基于这种解释，我设法创建了现有理论的可视模型，甚至提出了替代模型，这些模型不是寓言性的-您可以运行它们并查看它们是如何工作的。 <br><br> 不幸的是，我没有时间资源来更深入地了解量子物理学，我希望那些知道的人能够效仿我的榜样，并提供更准确的工作模型。 <br><br>  <b>更新</b> <br>  Mermin的解释与检测器的设计无关。 我主动向A，B和C添加了一个解释，分别表示自旋在X，Y和Z轴上的投影。 也就是说，我想在代码的注释中添加对物理现象的绑定，以使它不会那么干燥。 我误会了... <br><br> 文章已更正，删除了所有将Mermin的解释与实际物理实验联系起来的徒劳尝试。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN420611/">https://habr.com/ru/post/zh-CN420611/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN420599/index.html">莱姆预见的十三件事</a></li>
<li><a href="../zh-CN420603/index.html">特斯拉Model S车主的统计数据</a></li>
<li><a href="../zh-CN420605/index.html">求职面试算法概述-集生成</a></li>
<li><a href="../zh-CN420607/index.html">8月20日至26日在莫斯科举行的数字活动</a></li>
<li><a href="../zh-CN420609/index.html">上周第327期来自前端世界的新鲜材料摘要（2018年8月13日至19日）</a></li>
<li><a href="../zh-CN420613/index.html">您应该在2018年了解的11个React Native库（组件集）</a></li>
<li><a href="../zh-CN420615/index.html">JavaScript：探索对象</a></li>
<li><a href="../zh-CN420617/index.html">开发人员网页设计指南</a></li>
<li><a href="../zh-CN420619/index.html">自适应图像：节省时间的CSS技巧</a></li>
<li><a href="../zh-CN420623/index.html">尽力而为的分布式C ++应用程序</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>