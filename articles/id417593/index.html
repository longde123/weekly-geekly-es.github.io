<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🗞️ 🕛 👨🏿‍💻 NewSQL = NoSQL + ACID ◼️ 👩‍🌾 💝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sampai saat ini, di Odnoklassniki, sekitar 50 TB data waktu-nyata disimpan dalam SQL Server. Untuk volume seperti itu, hampir tidak mungkin untuk meny...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>NewSQL = NoSQL + ACID</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odnoklassniki/blog/417593/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/t5/hc/h2/t5hch2mr-lw9ffeahr_9gaxizlg.jpeg" width="600"></div><br>  Sampai saat ini, di Odnoklassniki, sekitar 50 TB data waktu-nyata disimpan dalam SQL Server.  Untuk volume seperti itu, hampir tidak mungkin untuk menyediakan akses pusat data yang cepat, andal, dan bahkan gagal-aman menggunakan SQL DBMS.  Biasanya dalam kasus seperti itu mereka menggunakan salah satu repositori NoSQL, tetapi tidak semuanya dapat ditransfer ke NoSQL: beberapa entitas memerlukan jaminan transaksi ACID. <br><br>  Ini mendorong kami untuk menggunakan penyimpanan NewSQL, yaitu, DBMS yang memberikan toleransi kesalahan, skalabilitas, dan kinerja sistem NoSQL, tetapi pada saat yang sama menjaga jaminan ACID yang akrab dengan sistem klasik.  Ada beberapa sistem industri yang berfungsi di kelas baru ini, jadi kami menerapkan sistem itu sendiri dan menjalankannya secara komersial. <br><br>  Cara kerjanya dan apa yang terjadi - baca di bawah potongan. <br><a name="habracut"></a><br>  Hari ini, pemirsa bulanan Odnoklassniki adalah lebih dari 70 juta pengunjung unik.  Kami adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">salah satu dari lima</a> jejaring sosial terbesar di dunia, dan dua puluh situs tempat pengguna menghabiskan waktu paling banyak.  Infrastruktur "OK" menangani beban yang sangat tinggi: lebih dari satu juta permintaan HTTP / detik ke garis depan.  Bagian dari armada server dalam jumlah lebih dari 8000 keping terletak berdekatan satu sama lain - di empat pusat data Moskow, yang memungkinkan latensi jaringan kurang dari 1 ms di antaranya. <br><br>  Kami telah menggunakan Cassandra sejak 2010, dimulai dengan versi 0.6.  Saat ini, beberapa lusin cluster sedang beroperasi.  Cluster tercepat memproses lebih dari 4 juta operasi per detik, dan yang terbesar menyimpan 260 TB. <br><br>  Namun, semua ini adalah kluster NoSQL biasa yang digunakan untuk menyimpan data yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lemah konsisten</a> .  Tetapi kami ingin mengganti penyimpanan konsisten utama, Microsoft SQL Server, yang telah digunakan sejak berdirinya Odnoklassniki.  Penyimpanan terdiri dari lebih dari 300 mesin SQL Server Standard Edition, yang berisi 50 TB data - entitas bisnis.  Data ini dimodifikasi sebagai bagian dari transaksi ACID dan membutuhkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">konsistensi yang tinggi</a> . <br><br>  Untuk mendistribusikan data di antara node SQL Server, kami menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">partisi</a> vertikal dan horizontal (sharding).  Secara historis, kami menggunakan skema berbagi data sederhana: setiap entitas dikaitkan dengan token - fungsi ID entitas.  Entitas dengan token yang sama ditempatkan di server SQL yang sama.  Hubungan tipe master-detail diimplementasikan sehingga token dari catatan utama dan yang dihasilkan selalu bertepatan dan berada di server yang sama.  Di jejaring sosial, hampir semua catatan dihasilkan atas nama pengguna - yang berarti bahwa semua data pengguna dalam satu subsistem fungsional disimpan di satu server.  Artinya, tabel dari satu server SQL hampir selalu berpartisipasi dalam transaksi bisnis, yang memungkinkan untuk memastikan konsistensi data menggunakan transaksi ACID lokal, tanpa perlu transaksi ACID yang didistribusikan secara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lambat dan tidak dapat diandalkan</a> . <br><br>  Berkat sharding dan untuk mempercepat SQL: <br><br><ul><li>  Kami tidak menggunakan batasan kunci Asing, karena ketika sharding, ID entitas dapat di server lain. </li><li>  Kami tidak menggunakan prosedur tersimpan dan pemicu karena beban tambahan pada CPU DBMS. </li><li>  Kami tidak menggunakan BERGABUNG karena semua hal di atas dan banyak membaca acak dari disk. </li><li>  Di luar transaksi, untuk mengurangi kebuntuan, kami menggunakan level isolasi Read Uncommitted. </li><li>  Kami hanya melakukan transaksi singkat (rata-rata, lebih pendek dari 100 ms). </li><li>  Kami tidak menggunakan UPDATE dan DELETE multi-baris karena banyaknya kebuntuan - kami hanya memperbarui satu catatan. </li><li>  Kami selalu menjalankan kueri hanya dengan indeks - kueri dengan rencana untuk pemindaian tabel lengkap bagi kami berarti kelebihan database dan kegagalannya. </li></ul><br>  Langkah-langkah ini memungkinkan untuk memeras kinerja maksimum hampir dari server SQL.  Namun, masalahnya menjadi semakin banyak.  Mari lihat mereka. <br><br><h2>  Masalah SQL </h2><br><ul><li>  Karena kami menggunakan sharding berpemilik, administrator secara manual menambahkan pecahan baru.  Selama ini, replika data yang dapat diskalakan tidak melayani permintaan. </li><li>  Saat jumlah catatan dalam tabel meningkat, kecepatan penyisipan dan modifikasi menurun, saat menambahkan indeks ke tabel yang ada, kecepatan turun beberapa kali, pembuatan dan pembuatan ulang indeks berjalan dengan waktu henti. </li><li>  Memiliki sedikit Windows untuk SQL Server dalam produksi membuat mengelola infrastruktur Anda sulit </li></ul><br>  Namun masalah utamanya adalah <br><br><h2>  Toleransi kesalahan </h2><br>  SQL Server klasik memiliki toleransi kesalahan yang buruk.  Misalkan Anda hanya memiliki satu server basis data, dan itu gagal setiap tiga tahun sekali.  Saat ini, situs tidak berfungsi selama 20 menit, ini dapat diterima.  Jika Anda memiliki 64 server, maka situs tersebut tidak berfungsi setiap tiga minggu sekali.  Dan jika Anda memiliki 200 server, maka situs tersebut tidak berfungsi setiap minggu.  Ini masalah. <br><br>  Apa yang dapat dilakukan untuk meningkatkan ketahanan SQL Server?  Wikipedia menawarkan kita untuk membangun sebuah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kluster yang sangat mudah diakses</a> : di mana jika terjadi kegagalan salah satu komponen ada duplikat. <br><br>  Ini membutuhkan armada peralatan mahal: redundansi berganda, serat, penyimpanan bersama, dan penyertaan cadangan tidak berfungsi dengan andal: sekitar 10% inklusi gagal dengan simpul cadangan oleh mesin di belakang simpul utama. <br><br>  Tetapi kelemahan utama dari cluster yang sangat mudah diakses adalah ketersediaan nol jika terjadi kegagalan pusat data di mana ia berdiri.  Odnoklassniki memiliki empat pusat data, dan kami harus menyediakan pekerjaan jika terjadi kecelakaan lengkap di salah satu di antaranya. <br><br>  Untuk melakukan ini, Anda bisa menggunakan replikasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Multi-Master yang</a> dibangun ke dalam SQL Server.  Solusi ini jauh lebih mahal karena biaya perangkat lunak dan menderita masalah terkenal dengan replikasi - keterlambatan transaksi yang tidak dapat diprediksi selama replikasi sinkron dan keterlambatan dalam penggunaan replikasi (dan, akibatnya, kehilangan modifikasi) selama asinkron.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Resolusi konflik yang</a> tersirat secara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">manual</a> membuat opsi ini benar-benar tidak dapat diterapkan kepada kami. <br><br>  Semua masalah ini memerlukan solusi radikal dan kami melanjutkan ke analisis terperinci dari mereka.  Di sini kita perlu berkenalan dengan apa yang SQL Server lakukan - transaksi. <br><br><h2>  Transaksi sederhana </h2><br>  Pertimbangkan yang paling sederhana, dari sudut pandang programmer SQL yang diterapkan, transaksi: menambahkan foto ke album.  Album dan foto disimpan dalam piring yang berbeda.  Album ini memiliki penghitung foto publik.  Kemudian transaksi semacam itu dibagi menjadi langkah-langkah berikut: <br><br><ol><li>  Kami mengunci album dengan kunci. </li><li>  Buat entri di tabel foto. </li><li>  Jika foto memiliki status publik, maka kami akan membuat penghitung foto publik di album, memperbarui catatan, dan melakukan transaksi. </li></ol><br>  Atau dalam bentuk pseudo-code: <br><br><pre><code class="hljs pgsql">TX.<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>("Albums", id); Album album = albums.<span class="hljs-keyword"><span class="hljs-keyword">lock</span></span>(id); Photo photo = photos.<span class="hljs-keyword"><span class="hljs-keyword">create</span></span>(…); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (photo.status == <span class="hljs-built_in"><span class="hljs-built_in">PUBLIC</span></span> ) { album.incPublicPhotosCount(); } album.<span class="hljs-keyword"><span class="hljs-keyword">update</span></span>(); TX.<span class="hljs-keyword"><span class="hljs-keyword">commit</span></span>();</code> </pre> <br>  Kami melihat bahwa skenario transaksi bisnis yang paling umum adalah membaca data dari database ke dalam memori server aplikasi, mengubah sesuatu, dan menyimpan nilai-nilai baru kembali ke database.  Biasanya dalam transaksi seperti itu kami memperbarui beberapa entitas, beberapa tabel. <br><br>  Ketika melakukan transaksi, modifikasi kompetitif dari data yang sama dari sistem lain dapat terjadi.  Sebagai contoh, Antispam dapat memutuskan bahwa pengguna mencurigakan dan oleh karena itu semua foto pengguna tidak boleh lagi publik, mereka harus dikirim untuk moderasi, yang berarti mengubah photo.status ke beberapa nilai lain dan membuka konter yang sesuai.  Jelas, jika operasi ini terjadi tanpa jaminan atomicity aplikasi dan isolasi modifikasi yang bersaing, seperti pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ACID</a> , hasilnya tidak akan menjadi apa yang dibutuhkan - baik penghitung foto akan menunjukkan nilai yang salah, atau tidak semua foto akan dikirim untuk moderasi. <br><br>  Ada banyak kode serupa yang memanipulasi berbagai entitas bisnis dalam kerangka satu transaksi selama seluruh keberadaan Odnoklassniki.  Dari pengalaman bermigrasi ke NoSQL dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Konsistensi Akhir,</a> kita tahu bahwa kesulitan terbesar (dan biaya waktu) adalah kebutuhan untuk mengembangkan kode yang bertujuan menjaga konsistensi data.  Oleh karena itu, kami mempertimbangkan persyaratan utama untuk repositori baru untuk menyediakan transaksi ACID logika nyata untuk logika aplikasi. <br><br>  Persyaratan lain yang sama pentingnya adalah: <br><br><ul><li>  Jika pusat data gagal, baik membaca dan menulis ke penyimpanan baru harus tersedia. </li><li>  Menjaga kecepatan pengembangan saat ini.  Artinya, ketika bekerja dengan repositori baru, jumlah kode harus kira-kira sama, seharusnya tidak perlu menambahkan sesuatu ke repositori, mengembangkan algoritma untuk menyelesaikan konflik, mempertahankan indeks sekunder, dll. </li><li>  Kecepatan penyimpanan baru harus cukup tinggi baik ketika membaca data dan ketika memproses transaksi, yang secara efektif berarti ketidakmampuan solusi yang ketat secara akademis, universal, tetapi lambat, seperti, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">komitmen dua fase</a> . </li><li>  Penskalaan otomatis dengan cepat. </li><li>  Menggunakan server murah biasa, tanpa perlu membeli besi eksotis. </li><li>  Kemungkinan mengembangkan penyimpanan oleh pengembang perusahaan.  Dengan kata lain, prioritas diberikan kepada solusi mereka sendiri atau berbasis sumber terbuka, lebih disukai di Jawa. </li></ul><br><h2>  Keputusan, Keputusan </h2><br>  Menganalisis kemungkinan solusi, kami sampai pada dua pilihan arsitektur yang mungkin: <br><br>  Yang pertama adalah mengambil server SQL apa pun dan mengimplementasikan toleransi kesalahan yang diperlukan, mekanisme penskalaan, kluster failover, resolusi konflik dan transaksi ACID yang terdistribusi, andal dan cepat.  Kami menilai opsi ini sangat tidak sepele dan memakan waktu. <br><br>  Opsi kedua adalah mengambil repositori NoSQL yang sudah jadi dengan penskalaan yang diimplementasikan, kluster failover, resolusi konflik, dan implementasikan transaksi dan SQL sendiri.  Sekilas, bahkan tugas mengimplementasikan SQL, belum lagi transaksi ACID, tampak seperti tugas selama bertahun-tahun.  Tapi kemudian kami menyadari bahwa set fitur SQL yang kami gunakan dalam praktiknya adalah jauh dari ANSI SQL seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Cassandra CQL</a> jauh dari ANSI SQL.  Melihat lebih dekat pada CQL, kami menyadari bahwa itu cukup dekat dengan apa yang kami butuhkan. <br><br><h2>  Cassandra dan CQL </h2><br>  Jadi, apa yang menarik dari Cassandra, kemampuan apa yang dimilikinya? <br><br>  Pertama, di sini Anda dapat membuat tabel dengan dukungan untuk berbagai tipe data, Anda dapat melakukan SELECT atau UPDATE pada kunci utama. <br><br><pre> <code class="hljs sql"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> photos (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span> <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span>, owner <span class="hljs-built_in"><span class="hljs-built_in">bigint</span></span>,…); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> photos <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>=?; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> photos <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> … <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">id</span></span>=?;</code> </pre> <br>  Untuk memastikan data replika yang konsisten, Cassandra menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pendekatan kuorum</a> .  Dalam kasus yang paling sederhana, ini berarti bahwa ketika tiga replika dari baris yang sama ditempatkan pada node yang berbeda dari cluster, catatan dianggap berhasil jika sebagian besar node (yaitu dua dari tiga) mengkonfirmasi keberhasilan operasi penulisan ini.  Data dari suatu seri dianggap konsisten jika, ketika membaca, sebagian besar node diinterogasi dan dikonfirmasi.  Dengan demikian, dengan adanya tiga replika, konsistensi data penuh dan instan dijamin dalam kasus kegagalan satu node.  Pendekatan ini memungkinkan kami untuk menerapkan skema yang bahkan lebih andal: selalu mengirim permintaan ke ketiga replika, menunggu jawaban dari dua yang tercepat.  Respons terlambat dari replika ketiga kemudian dibuang.  Sebuah node yang terlambat dengan jawaban dapat memiliki masalah serius - rem, pengumpulan sampah di JVM, reklamasi memori langsung di kernel linux, kegagalan perangkat keras, terputusnya jaringan.  Namun, ini tidak memengaruhi operasi atau data klien. <br><br>  Pendekatan ketika kita beralih ke tiga node dan mendapatkan jawaban dari dua disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">spekulasi</a> : permintaan komentar tambahan dikirim bahkan sebelum itu "jatuh". <br><br>  Keuntungan lain dari Cassandra adalah Batchlog - sebuah mekanisme yang menjamin aplikasi penuh atau non-aplikasi lengkap dari paket perubahan yang Anda buat.  Ini memungkinkan kita untuk memecahkan A dalam ACID - atomicity di luar kotak. <br><br>  Yang paling dekat dengan transaksi di Cassandra adalah apa yang disebut " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">transaksi ringan</a> ".  Tetapi mereka jauh dari transaksi ACID "nyata": pada kenyataannya, ini adalah kesempatan untuk membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">CAS</a> pada data hanya satu catatan, menggunakan konsensus pada protokol berat Paxos.  Karena itu, kecepatan transaksi seperti itu rendah. <br><br><h2>  Apa yang kami lewatkan di Cassandra </h2><br>  Jadi, kami harus menerapkan transaksi ACID nyata di Cassandra.  Dengan menggunakan itu kita dapat dengan mudah mengimplementasikan dua fitur nyaman lainnya dari DBMS klasik: indeks cepat yang konsisten, yang akan memungkinkan kita untuk melakukan pengambilan sampel data tidak hanya pada kunci primer dan generator yang biasa digunakan ID kenaikan otomatis monoton. <br><br><h4>  C * satu </h4><br>  Jadi <b>C * One</b> DBMS baru lahir, terdiri dari tiga jenis node server: <br><br><ul><li>  Penyimpanan - server Cassandra standar (hampir) yang bertanggung jawab untuk menyimpan data pada drive lokal.  Ketika beban dan jumlah data bertambah, jumlah mereka dapat dengan mudah ditingkatkan menjadi puluhan atau ratusan. </li><li>  Koordinator Transaksi - Memungkinkan eksekusi transaksi. </li><li>  Klien adalah server aplikasi yang menerapkan operasi bisnis dan memulai transaksi.  Mungkin ada ribuan pelanggan seperti itu. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/eb6/f4f/498/eb6f4f4983f44dcbe63cd545e87f8d1a.png"><br><br>  Semua jenis server berada di cluster umum, gunakan protokol pesan Cassandra internal untuk berkomunikasi satu sama lain dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gosip</a> untuk bertukar informasi cluster.  Dengan bantuan Heartbeat, server belajar tentang kegagalan timbal balik, mendukung skema data tunggal - tabel, struktur dan replikasi mereka;  skema partisi, topologi klaster, dll. <br><br><h4>  Pelanggan </h4><br><img src="https://habrastorage.org/getpro/habr/post_images/b83/9ff/971/b839ff971b0049d56d55bd309f44ae4e.png"><br><br>  Alih-alih driver standar, mode Fat Client digunakan.  Node tersebut tidak menyimpan data, tetapi dapat bertindak sebagai koordinator pelaksanaan kueri, yaitu, Klien sendiri melakukan fungsi koordinator permintaannya: ia mengumpulkan repositori replika dan menyelesaikan konflik.  Ini tidak hanya lebih dapat diandalkan dan lebih cepat daripada driver standar yang memerlukan komunikasi dengan koordinator jarak jauh, tetapi juga memungkinkan Anda untuk mengontrol transfer permintaan.  Di luar transaksi terbuka pada klien, permintaan dikirim ke penyimpanan.  Jika klien membuka transaksi, maka semua permintaan dalam transaksi dikirim ke koordinator transaksi. <br><img src="https://habrastorage.org/getpro/habr/post_images/d39/d43/483/d39d43483590319f4d49e41a25316058.png"><br><br><h2>  C * Satu Koordinator Transaksi </h2><br>  Koordinator adalah apa yang kami terapkan untuk C * One dari awal.  Dia bertanggung jawab untuk mengelola transaksi, mengunci, dan urutan transaksi diterapkan. <br><br>  Untuk setiap transaksi yang dilayani, koordinator membuat stempel waktu: masing-masing transaksi berikutnya lebih besar dari transaksi sebelumnya.  Karena sistem resolusi konflik di Cassandra didasarkan pada stempel waktu (dari dua catatan yang saling bertentangan, yang saat ini dengan stempel waktu terakhir dianggap relevan), konflik akan selalu diselesaikan untuk transaksi berikutnya.  Karena itu, kami menerapkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jam tangan Lamport</a> - cara murah untuk menyelesaikan konflik dalam sistem terdistribusi. <br><br><h2>  Kunci </h2><br>  Untuk memastikan isolasi, kami memutuskan untuk menggunakan metode paling sederhana - kunci pesimis pada kunci utama catatan.  Dengan kata lain, dalam suatu transaksi, catatan harus dikunci terlebih dahulu, baru kemudian dibaca, diubah, dan disimpan.  Hanya setelah komit yang berhasil dapat catatan dibuka kuncinya sehingga transaksi yang bersaing dapat menggunakannya. <br><br>  Menerapkan kunci ini sederhana di lingkungan yang tidak terisi.  Ada dua cara utama dalam sistem terdistribusi: menerapkan penguncian terdistribusi pada kluster, atau mendistribusikan transaksi sehingga transaksi yang melibatkan catatan tunggal selalu dilayani oleh koordinator yang sama. <br><br>  Karena dalam kasus kami, data sudah didistribusikan oleh grup transaksi lokal dalam SQL, diputuskan untuk menetapkan grup transaksi lokal ke koordinator: satu koordinator melakukan semua transaksi dengan token dari 0 hingga 9, yang kedua dengan token dari 10 hingga 19, dan seterusnya.  Akibatnya, setiap instance koordinator menjadi master grup transaksi. <br><br>  Kemudian kunci dapat diimplementasikan sebagai HashMap dangkal dalam memori koordinator. <br><br><h2>  Kegagalan Koordinator </h2><br>  Karena satu koordinator secara eksklusif melayani sekelompok transaksi, sangat penting untuk segera menentukan fakta kegagalannya, sehingga upaya berulang untuk mengeksekusi transaksi akan berakhir.  Untuk membuatnya cepat dan andal, kami menerapkan protokol kuorum pendengaran yang sepenuhnya terhubung: <br><br>  Setiap pusat data memiliki setidaknya dua simpul koordinator.  Secara berkala, masing-masing koordinator mengirimkan pesan detak jantung ke koordinator lain dan memberi tahu mereka tentang fungsinya, serta pesan detak jantung dari mana koordinator di cluster untuk terakhir kalinya. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cde/1e4/ccd/cde1e4ccd6d23620eda08adc231aeec7.jpg"><br><br>  Setelah menerima informasi serupa dari yang lain dalam komposisi pesan detak jantung mereka, masing-masing koordinator memutuskan sendiri fungsi gugus simpul mana yang tidak, dipandu oleh prinsip kuorum: jika simpul X menerima informasi dari mayoritas simpul dalam gugus tentang penerimaan pesan yang normal dari simpul Y, maka , Y bekerja.  Sebaliknya, segera setelah mayoritas melaporkan hilangnya pesan dari simpul Y, maka Y telah gagal.  Sangat mengherankan bahwa jika kuorum memberi tahu simpul X bahwa ia tidak menerima lebih banyak pesan darinya, maka simpul X sendiri akan menganggap dirinya gagal. <br><br>  Pesan detak jantung dikirim pada frekuensi tinggi, sekitar 20 kali per detik, dengan periode 50 ms.  Di Jawa, sulit untuk menjamin respons aplikasi 50 ms karena panjang jeda yang sebanding yang disebabkan oleh pengumpul sampah.  Kami dapat mencapai waktu respons seperti itu dengan menggunakan pengumpul sampah G1, yang memungkinkan kami menentukan target untuk durasi jeda GC.  Namun, kadang-kadang, sangat jarang, jeda kolektor melampaui 50 ms, yang dapat menyebabkan kesalahan deteksi kesalahan.  Untuk mencegah hal ini, koordinator tidak melaporkan kegagalan node jauh ketika pesan detak jantung pertama menghilang darinya, hanya jika beberapa secara berurutan menghilang. Jadi kami berhasil mendeteksi kegagalan simpul koordinator dalam 200 ms. <br><br>  Tapi itu tidak cukup untuk dengan cepat memahami simpul mana yang berhenti berfungsi.  Anda perlu melakukan sesuatu tentang itu. <br><br><h2>  Reservasi </h2><br>  Skema klasik mengasumsikan bahwa jika terjadi penolakan master untuk meluncurkan pemilihan baru menggunakan salah satu algoritma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">universal yang</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">modis</a> .  Namun, algoritma tersebut memiliki masalah yang terkenal dengan konvergensi waktu dan lamanya proses pemilihan itu sendiri.  Kami berhasil menghindari penundaan tambahan tersebut dengan menggunakan rangkaian koordinator yang setara dalam jaringan yang sepenuhnya terhubung: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e90/45e/007/e9045e00777362a5846eb78ef15bedea.png"><br><br>  Misalkan kita ingin melakukan transaksi dalam grup 50. Kami akan menentukan terlebih dahulu skema substitusi, yaitu, node mana yang akan melakukan transaksi grup 50 jika terjadi kegagalan koordinator utama.  Tujuan kami adalah menjaga sistem tetap beroperasi jika terjadi kegagalan pusat data.  Kami menentukan bahwa cadangan pertama akan menjadi simpul dari pusat data lain, dan cadangan kedua akan menjadi simpul dari yang ketiga.  Skema ini dipilih sekali dan tidak berubah sampai topologi klaster berubah, yaitu, sampai node baru memasukinya (yang jarang terjadi).  Prosedur untuk memilih master aktif baru jika terjadi kegagalan yang lama akan selalu seperti ini: cadangan pertama akan menjadi tuan aktif, dan jika telah berhenti berfungsi, cadangan kedua akan menjadi. <br><br>  Skema seperti itu lebih dapat diandalkan daripada algoritma universal, karena untuk mengaktifkan master baru cukup untuk menentukan fakta kegagalan yang lama. <br><br>  Tetapi bagaimana pelanggan akan memahami master mana yang bekerja sekarang?  Selama 50 ms, tidak mungkin mengirim informasi ke ribuan pelanggan.  Situasi mungkin terjadi ketika klien mengirim permintaan untuk membuka transaksi, belum mengetahui bahwa wisaya ini tidak lagi berfungsi, dan permintaan akan hangout.  Untuk mencegah hal ini terjadi, klien secara spekulatif mengirim permintaan untuk segera membuka transaksi ke master grup dan kedua cadangannya, tetapi hanya orang yang merupakan master aktif saat ini yang akan menjawab permintaan ini.  Klien akan melakukan semua komunikasi selanjutnya dalam transaksi hanya dengan master aktif. <br><br>  Master cadangan menerima permintaan untuk transaksi non-sendiri dalam antrian transaksi yang belum lahir, di mana mereka disimpan selama beberapa waktu.  Jika master aktif mati, master baru memproses permintaan untuk membuka transaksi dari antriannya dan merespons ke klien.  Jika klien sudah berhasil membuka transaksi dengan master lama, maka respons kedua diabaikan (dan, jelas, transaksi seperti itu tidak akan selesai dan akan diulangi oleh klien). <br><br><h2>  Bagaimana suatu transaksi bekerja </h2><br>  Misalkan klien mengirim permintaan kepada koordinator untuk membuka transaksi untuk entitas dengan kunci utama tersebut.  Koordinator mengunci entitas ini dan menempatkannya di tabel kunci dalam memori.  Jika perlu, koordinator membaca entitas ini dari toko dan menyimpan data yang diterima dalam status transaksi dalam memori koordinator. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4d1/dfb/dcd/4d1dfbdcd92e4b05ca49ef5168177eb8.png"><br><br>  Ketika klien ingin mengubah data dalam transaksi, ia mengirim permintaan koordinator untuk memperbarui entitas, dan ia menempatkan data baru dalam tabel status transaksi dalam memori.  Ini melengkapi perekaman - perekaman tidak dilakukan dalam repositori. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/00e/803/570/00e803570a0fbe19cb76786cbc6f0142.png"><br><br>  Ketika klien meminta, dalam kerangka transaksi aktif, data mereka sendiri yang berubah, koordinator bertindak seperti ini: <br><br><ul><li>  jika ID sudah ada dalam transaksi, maka data diambil dari memori; </li><li>  jika tidak ada ID dalam memori, maka data yang hilang dibaca dari node penyimpanan, dikombinasikan dengan yang sudah ada dalam memori, dan hasilnya dikembalikan ke klien. </li></ul><br>  Dengan demikian, klien dapat membaca perubahannya sendiri, sementara klien lain tidak melihat perubahan ini, karena mereka disimpan hanya dalam memori koordinator, mereka belum berada dalam node Cassandra. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d8e/140/5f7/d8e1405f7995228ec3d061af59f1f685.png"><br><br>  Ketika klien mengirim komit, status dalam memori layanan disimpan oleh koordinator dalam batch yang dicatat, dan sudah dalam bentuk batch yang telah dikirim, dikirim ke repositori Cassandra.  Repositori melakukan segala yang diperlukan agar paket ini diterapkan secara atom (sepenuhnya), dan mengembalikan respons kepada koordinator, yang melepaskan kunci dan mengonfirmasi keberhasilan transaksi kepada klien. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/090/739/9fc/0907399fc025879f16174ff26163a937.png"><br><br>  Dan untuk kembali ke koordinator, cukup membebaskan memori yang ditempati oleh keadaan transaksi. <br><br>  Sebagai hasil dari perbaikan di atas, kami menerapkan prinsip-prinsip ACID: <br><br><ul><li>  <b>Atomicity</b> .  Ini adalah jaminan bahwa tidak ada transaksi yang akan dilakukan sebagian untuk sistem, semua sub-operasinya akan selesai, atau tidak satu pun akan dieksekusi.  Kami mematuhi prinsip ini karena batch yang dicatat di Cassandra. </li><li>  <b>Koherensi</b>  Setiap transaksi yang berhasil, menurut definisi, hanya menangkap hasil yang dapat diterima.  Jika, setelah membuka transaksi dan melakukan bagian dari operasi, ternyata hasilnya tidak valid, rollback dilakukan. </li><li>  <b>Isolasi</b> .  Ketika suatu transaksi dieksekusi, transaksi paralel seharusnya tidak mempengaruhi hasilnya.  Transaksi yang bersaing diisolasi menggunakan kunci pesimistik pada koordinator.  Untuk bacaan di luar transaksi, prinsip isolasi pada tingkat Komitmen Baca dihormati. </li><li>  <b>Keberlanjutan</b> .  Terlepas dari masalah di tingkat bawah - penghentian sistem, kegagalan perangkat keras, - perubahan yang dilakukan oleh transaksi yang berhasil diselesaikan harus tetap disimpan setelah melanjutkan operasi. </li></ul><br><h2>  Pembacaan indeks </h2><br>  Ambil tabel sederhana: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> photos ( id <span class="hljs-type"><span class="hljs-type">bigint</span></span> <span class="hljs-keyword"><span class="hljs-keyword">primary key</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">owner</span></span> <span class="hljs-type"><span class="hljs-type">bigint</span></span>, modified <span class="hljs-type"><span class="hljs-type">timestamp</span></span>, …)</code> </pre> <br>  Dia memiliki ID (kunci utama), pemilik dan tanggal perubahan.  Anda perlu membuat permintaan yang sangat sederhana - pilih data pemilik dengan tanggal perubahan "untuk hari terakhir". <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> owner=? <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> modified&gt;?</code> </pre> <br>  Agar kueri tersebut bekerja dengan cepat, dalam SQL DBMS klasik, Anda perlu membuat indeks menurut kolom (pemilik, dimodifikasi).  Kami dapat melakukan ini dengan cukup sederhana, karena sekarang kami memiliki jaminan ACID! <br><br><h2>  Indeks dalam C * One </h2><br>  Ada tabel sumber dengan foto, di mana ID rekaman adalah kunci utama. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/039/5b3/a78/0395b3a784329992b88ba0618a94a7f1.jpg"><br><br>  Untuk indeks C *, One membuat tabel baru, yang merupakan salinan dari aslinya.  Kunci cocok dengan ekspresi indeks, dan itu juga termasuk kunci utama catatan dari tabel sumber: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/92a/8c2/93e/92a8c293e8c145dc37f49a5126e68095.jpg"><br><br>  Sekarang permintaan untuk "pemilik untuk hari terakhir" dapat ditulis ulang sebagai pilih dari tabel lain: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> i1_test <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> owner=? <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> modified&gt;?</code> </pre> <br>  Konsistensi data dari tabel foto asli dan indeks i1 dikelola secara otomatis oleh koordinator.  Berdasarkan skema data saja, ketika perubahan diterima, koordinator menghasilkan dan mengingat perubahan tidak hanya di tabel utama, tetapi juga di salinan perubahan.  Tidak ada tindakan tambahan yang dilakukan dengan tabel indeks, log tidak dibaca, kunci tidak digunakan.  Artinya, menambahkan indeks hampir tidak memakan sumber daya dan praktis tidak mempengaruhi kecepatan penerapan modifikasi. <br><br>  Menggunakan ACID, kami dapat menerapkan indeks "seperti dalam SQL".  Mereka memiliki konsistensi, dapat diskalakan, bekerja dengan cepat, dapat digabungkan dan dibangun ke dalam bahasa query CQL.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mendukung indeks, Anda tidak perlu membuat perubahan pada kode aplikasi. </font><font style="vertical-align: inherit;">Semuanya sederhana, seperti dalam SQL. </font><font style="vertical-align: inherit;">Dan yang paling penting, indeks tidak mempengaruhi kecepatan eksekusi modifikasi ke tabel transaksi asli.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apa yang terjadi </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami mengembangkan C * Satu tiga tahun lalu dan memasukkannya ke dalam operasi komersial. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apa yang kita dapatkan pada akhirnya? Mari kita evaluasi ini menggunakan contoh subsistem untuk memproses dan menyimpan foto, salah satu jenis data yang paling penting dalam jejaring sosial. Ini bukan tentang tubuh foto itu sendiri, tetapi tentang semua jenis meta-informasi. Sekarang di Odnoklassniki ada sekitar 20 miliar catatan seperti itu, sistem memproses 80 ribu permintaan baca per detik, hingga 8 ribu transaksi ACID per detik yang terkait dengan modifikasi data. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketika kami menggunakan SQL dengan faktor replikasi = 1 (tetapi dalam RAID 10), informasi meta foto disimpan pada kelompok 32 mesin yang sangat mudah diakses dengan Microsoft SQL Server (plus 11 cadangan). Ini juga mengalokasikan 10 server untuk menyimpan cadangan. Sebanyak 50 mobil mahal. Pada saat yang sama, sistem bekerja pada beban terukur, tanpa cadangan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah bermigrasi ke sistem baru, kami mendapat faktor replikasi = 3 - salinan di setiap pusat data. Sistem ini terdiri dari 63 node penyimpanan Cassandra dan 6 mesin koordinator, dengan total 69 server. Tetapi mesin ini jauh lebih murah, total biaya mereka adalah sekitar 30% dari biaya sistem dalam SQL. Dalam hal ini, beban disimpan pada 30%. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan diperkenalkannya C * One, penundaan juga menurun: dalam SQL, operasi penulisan memakan waktu sekitar 4,5 ms. Dalam C * One - sekitar 1,6 ms. Durasi transaksi rata-rata kurang dari 40 ms, komit dilakukan dalam 2 ms, durasi baca dan tulis rata-rata 2 ms. Persentil ke-99 - hanya 3-3,1 ms, jumlah waktu habis berkurang 100 kali - semua karena penggunaan spekulasi yang meluas.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sampai saat ini, sebagian besar node SQL Server telah dinonaktifkan; produk baru dikembangkan hanya menggunakan C * One. </font><font style="vertical-align: inherit;">Kami mengadaptasi C * One untuk bekerja di </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">cloud satu</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kami </font><font style="vertical-align: inherit;">, yang memungkinkan kami untuk mempercepat penyebaran cluster baru, menyederhanakan konfigurasi dan mengotomatisasi operasi. </font><font style="vertical-align: inherit;">Tanpa kode sumber, itu akan jauh lebih sulit dan pembuatan kruk. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang kami sedang berupaya mentransfer fasilitas penyimpanan kami yang lain ke cloud - tetapi ini adalah kisah yang sangat berbeda.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id417593/">https://habr.com/ru/post/id417593/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id417583/index.html">Tomorrow ICFP Contest 2018, tepuk tangan! (+ bermanfaat untuk berpartisipasi untuk pertama kalinya)</a></li>
<li><a href="../id417585/index.html">Cara masuk ke komite program konferensi kelas, dan mengapa Anda membutuhkannya</a></li>
<li><a href="../id417587/index.html">Media: serangan cyber skala besar mempercepat pertumbuhan kapitalisasi perusahaan dari industri keamanan informasi</a></li>
<li><a href="../id417589/index.html">Tujuh Aturan Sederhana untuk Membuat Internet Dapat Diakses oleh Semua Orang</a></li>
<li><a href="../id417591/index.html">Cara "belajar" bahasa Inggris dalam satu tahun sendiri atau artikel untuk mereka yang tidak berhasil dengan bahasa Inggris</a></li>
<li><a href="../id417595/index.html">Barang antik: Palm OS, kode efisien dan foto menjijikkan</a></li>
<li><a href="../id417597/index.html">Penyimpanan Tepercaya dengan DRBD9 dan Proxmox (Bagian 2: iSCSI + LVM)</a></li>
<li><a href="../id417599/index.html">Intisari Fintech: regulator keuangan membutuhkan AI agar dapat bekerja dalam kondisi modern</a></li>
<li><a href="../id417601/index.html">Pilih server. Apa yang harus dicari? Periksa daftar</a></li>
<li><a href="../id417603/index.html">Pengumuman mitap seluler: Apa yang harus dilakukan ketika aplikasi menjadi besar?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>