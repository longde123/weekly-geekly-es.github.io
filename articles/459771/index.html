<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏿 Ⓜ️ 🔽 Implementamos AutoMapper usando Roslyn y generación de código 🛀 🤟 🥓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En un artículo anterior , describí una forma de organizar la generación de código con Roslyn. La tarea de entonces era demostrar un enfoque común. Aho...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementamos AutoMapper usando Roslyn y generación de código</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459771/"><p>  En un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">artículo</a> anterior <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">,</a> describí una forma de organizar la generación de código con Roslyn.  La tarea de entonces era demostrar un enfoque común.  Ahora quiero darme cuenta de algo que tendrá una aplicación real. </p><br><p> Entonces, cualquier persona interesada en ver cómo puede hacer que una biblioteca como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">AutoMapper</a> pida un gato. </p><a name="habracut"></a><br><h1 id="vvedenie">  Introduccion </h1><br><p> En primer lugar, creo que vale la pena describir cómo funcionará mi Ahead of Time Mapper (AOTMapper).  El punto de entrada de nuestro mapeador será el método de extensión genérico <code>MapTo&lt;&gt;</code> .  El analizador lo buscará y ofrecerá implementar el <code>MapToUser</code> extensión <code>MapToUser</code> , donde <code>User</code> es el tipo que se pasa a <code>MapTo&lt;&gt;</code> . </p><br><p>  Como ejemplo, tome las siguientes clases: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">AOTMapper.Benchmark.Data</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">UserEntity</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UserEntity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UserEntity</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Guid id, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> firstName, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> lastName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Id = id; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.FirstName = firstName; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.LastName = lastName; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Guid Id { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FirstName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> LastName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">User</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> FirstName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> LastName { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Name { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } }</code> </pre> <br><p>  El <code>MapToUser</code> generado se verá así: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> AOTMapper.Benchmark.Data.<span class="hljs-function"><span class="hljs-function">User </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MapToUser</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AOTMapper.Benchmark.Data.UserEntity input</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> output = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AOTMapper.Benchmark.Data.User(); output.FirstName = input.FirstName; output.LastName = input.LastName; output.Name = ; <span class="hljs-comment"><span class="hljs-comment">// missing property return output; }</span></span></code> </pre> <br><p>  Como puede ver en este ejemplo, todas las propiedades con los mismos nombres y tipos se asignan automáticamente.  A su vez, aquellos para los que no se encontraron coincidencias continúan "colgándose" creando un error de compilación y el desarrollador de alguna manera debe manejarlos. </p><br><p>  Por ejemplo, así: </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> AOTMapper.Benchmark.Data.<span class="hljs-function"><span class="hljs-function">User </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MapToUser</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> AOTMapper.Benchmark.Data.UserEntity input</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> output = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AOTMapper.Benchmark.Data.User(); output.FirstName = input.FirstName; output.LastName = input.LastName; output.Name = <span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{input.FirstName}</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{input.LastName}</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> output; }</code> </pre> <br><p>  Durante la generación de <code>MapToUser</code> , la <code>MapTo&lt;User&gt;</code> llamada <code>MapTo&lt;User&gt;</code> será reemplazada por <code>MapToUser</code> . </p><br><p>  Cómo funciona en movimiento se puede ver aquí: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/BCznYk2n3II" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  AOTMapper también se puede instalar a través de nuget: </p><br><pre> <code class="plaintext hljs">Install-Package AOTMapper</code> </pre> <br><p>  El código completo del proyecto se puede encontrar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> . </p><br><h1 id="realizaciya">  Implementación </h1><br><p>  Pensé durante mucho tiempo cómo se puede hacer esto de manera diferente y al final llegué a la conclusión de que esto no es tan malo, ya que esto resuelve algunos de los inconvenientes que me atormentaban al usar <code>AutoMapper</code> . </p><br><p>  En primer lugar, obtenemos diferentes métodos de extensión para diferentes tipos, como resultado de lo cual, para algunos tipos de <code>User</code> abstractos, podemos usar IntelliSense muy fácilmente para averiguar qué mapas ya están implementados sin tener que buscar el mismo archivo donde están registrados nuestros mapas.  Solo mira qué métodos de extensión ya tienes. </p><br><p>  En segundo lugar, en tiempo de ejecución es solo un método de extensión y, por lo tanto, evitamos cualquier sobrecarga asociada con la llamada a nuestro mapeador.  Entiendo que los desarrolladores de <code>AutoMapper</code> dedicaron mucho esfuerzo a optimizar la llamada, pero todavía hay algunos costos adicionales.  Mi pequeño punto de referencia mostró que, en promedio, es de 140-150ns por llamada, excluyendo el tiempo de inicialización.  El punto de referencia en sí se puede ver en el repositorio, y los resultados de la medición son más bajos. </p><br><div class="scrollable-table"><table><thead><tr><th>  Método </th><th>  Media </th><th>  Error </th><th>  Stddev </th><th>  Gen 0 </th><th>  Gen 1 </th><th>  Gen 2 </th><th>  Asignado </th></tr></thead><tbody><tr><td>  AutoMapperToUserEntity </td><td>  151,84 ns </td><td>  1.9952 ns </td><td>  1.8663 ns </td><td>  0,0253 </td><td>  - </td><td>  - </td><td>  80 B </td></tr><tr><td>  AOTMapperToUserEntity </td><td>  10,41 ns </td><td>  0.2009 ns </td><td>  0.1879 ns </td><td>  0,0152 </td><td>  - </td><td>  - </td><td>  48 B </td></tr><tr><td>  AutoMapperToUser </td><td>  197,51 ns </td><td>  2.9225 ns </td><td>  2.5907 ns </td><td>  0,0787 </td><td>  - </td><td>  - </td><td>  248 B </td></tr><tr><td>  AOTMapperToUser </td><td>  46,46 ns </td><td>  0.3530 ns </td><td>  0.3129 ns </td><td>  0,0686 </td><td>  - </td><td>  - </td><td>  216 B </td></tr></tbody></table></div><br><p>  Además, las ventajas de este mapeador incluyen el hecho de que generalmente no requiere tiempo para inicializarse cuando se inicia la aplicación, lo que puede ser útil en aplicaciones grandes. </p><br><p>  El analizador tiene la siguiente forma (falta el código de enlace): </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">OperationAnalysisContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> syntax = context.Operation.Syntax; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (syntax <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> InvocationExpressionSyntax invocationSytax &amp;&amp; invocationSytax.Expression <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> MemberAccessExpressionSyntax memberAccessSyntax &amp;&amp; syntax.DescendantNodes().OfType&lt;GenericNameSyntax&gt;().FirstOrDefault() <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> GenericNameSyntax genericNameSyntax &amp;&amp; genericNameSyntax.Identifier.ValueText == <span class="hljs-string"><span class="hljs-string">"MapTo"</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> semanticModel = context.Compilation.GetSemanticModel(syntax.SyntaxTree); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> methodInformation = semanticModel.GetSymbolInfo(genericNameSyntax); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (methodInformation.Symbol.ContainingAssembly.Name != CoreAssemblyName) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fromTypeInfo = semanticModel.GetTypeInfo(memberAccessSyntax.Expression); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fromTypeName = fromTypeInfo.Type.ToDisplayString(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> typeSyntax = genericNameSyntax.TypeArgumentList.Arguments.First(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> toTypeInfo = semanticModel.GetTypeInfo(typeSyntax); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> toTypeName = toTypeInfo.Type.ToDisplayString(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> properties = ImmutableDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;.Empty .Add(<span class="hljs-string"><span class="hljs-string">"fromType"</span></span>, fromTypeName) .Add(<span class="hljs-string"><span class="hljs-string">"toType"</span></span>, toTypeName); context.ReportDiagnostic(Diagnostic.Create(AOTMapperIsNotReadyDescriptor, genericNameSyntax.GetLocation(), properties)); } }</code> </pre> <br><p>  Todo lo que hace es verificar si es el método que necesitamos, extrae el tipo de la entidad en la que se llama <code>MapTo&lt;&gt;</code> desde el primer parámetro del método generalizado y genera un mensaje de diagnóstico. </p><br><p>  A su vez, se procesará dentro del <code>AOTMapperCodeFixProvider</code> .  Aquí obtenemos información sobre los tipos sobre los que ejecutaremos la generación de código.  Luego reemplazamos la llamada a <code>MapTo&lt;&gt;</code> con una implementación específica.  Luego llamamos a <code>AOTMapperGenerator</code> que generará un archivo con el método de extensión. </p><br><p>  En el código, se ve así: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> Task&lt;Document&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Handle</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Diagnostic diagnostic, CodeFixContext context</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fromTypeName = diagnostic.Properties[<span class="hljs-string"><span class="hljs-string">"fromType"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> toTypeName = diagnostic.Properties[<span class="hljs-string"><span class="hljs-string">"toType"</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> document = context.Document; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> semanticModel = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> document.GetSemanticModelAsync(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> root = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> diagnostic.Location.SourceTree.GetRootAsync(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> call = root.FindNode(diagnostic.Location.SourceSpan); root = root.ReplaceNode(call, SyntaxFactory.IdentifierName(<span class="hljs-string"><span class="hljs-string">$"MapTo</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{toTypeName.Split(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'.'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">).Last()}</span></span></span><span class="hljs-string">"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pairs = ImmutableDictionary&lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;.Empty .Add(fromTypeName, toTypeName); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> generator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AOTMapperGenerator(document.Project, semanticModel.Compilation); generator.GenerateMappers(pairs, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { <span class="hljs-string"><span class="hljs-string">"AOTMapper"</span></span>, <span class="hljs-string"><span class="hljs-string">"Mappers"</span></span> }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> newProject = generator.Project; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> documentInNewProject = newProject.GetDocument(document.Id); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> documentInNewProject.WithSyntaxRoot(root); }</code> </pre> <br><p>  <code>AOTMapperGenerator</code> modifica el proyecto entrante creando archivos con mapeos entre los tipos. <br>  Esto se hace de la siguiente manera: </p><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMappers</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ImmutableDictionary&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; values, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] outputNamespace</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> values) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fromSymbol = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Compilation.GetTypeByMetadataName(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Key); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> toSymbol = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Compilation.GetTypeByMetadataName(<span class="hljs-keyword"><span class="hljs-keyword">value</span></span>.Value); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fromSymbolName = fromSymbol.ToDisplayString().Replace(<span class="hljs-string"><span class="hljs-string">"."</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> toSymbolName = toSymbol.ToDisplayString().Replace(<span class="hljs-string"><span class="hljs-string">"."</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fileName = <span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{fromSymbolName}</span></span></span><span class="hljs-string">_To_</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{toSymbolName}</span></span></span><span class="hljs-string">"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> source = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.GenerateMapper(fromSymbol, toSymbol, fileName); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Project = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.Project .AddDocument(<span class="hljs-string"><span class="hljs-string">$"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{fileName}</span></span></span><span class="hljs-string">.cs"</span></span>, source) .WithFolders(outputNamespace) .Project; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateMapper</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">INamedTypeSymbol fromSymbol, INamedTypeSymbol toSymbol, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fileName</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> fromProperties = fromSymbol.GetAllMembers() .OfType&lt;IPropertySymbol&gt;() .Where(o =&gt; (o.DeclaredAccessibility &amp; Accessibility.Public) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) .ToDictionary(o =&gt; o.Name, o =&gt; o.Type); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> toProperties = toSymbol.GetAllMembers() .OfType&lt;IPropertySymbol&gt;() .Where(o =&gt; (o.DeclaredAccessibility &amp; Accessibility.Public) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) .ToDictionary(o =&gt; o.Name, o =&gt; o.Type); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">$@" public static class </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{fileName}</span></span></span><span class="hljs-string">Extentions {{ public static </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{toSymbol.ToDisplayString()}</span></span></span><span class="hljs-string"> MapTo</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{toSymbol.ToDisplayString().Split(</span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">'.'</span></span></span></span><span class="hljs-string"><span class="hljs-subst">).Last()}</span></span></span><span class="hljs-string">(this </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{fromSymbol.ToDisplayString()}</span></span></span><span class="hljs-string"> input) {{ var output = new </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{toSymbol.ToDisplayString()}</span></span></span><span class="hljs-string">(); </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{ toProperties .Where(o =&gt; fromProperties.TryGetValue(o.Key, </span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> </span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> type) &amp;&amp; type == o.Value) .Select(o =&gt; </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">$" output.</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{o.Key}</span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"> = input.</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{o.Key}</span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">;"</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> ) .JoinWithNewLine() }</span></span></span><span class="hljs-string"> </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{ toProperties .Where(o =&gt; !fromProperties.TryGetValue(o.Key, </span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">out</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> </span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">var</span></span></span></span><span class="hljs-string"><span class="hljs-subst"> type) || type != o.Value) .Select(o =&gt; </span></span><span class="hljs-string"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string">$" output.</span></span></span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{o.Key}</span></span></span></span></span><span class="hljs-string"><span class="hljs-subst"><span class="hljs-string"> = ; // missing property"</span></span></span></span><span class="hljs-string"><span class="hljs-subst">) .JoinWithNewLine() }</span></span></span><span class="hljs-string"> return output; }} }} "</span></span>; }</code> </pre> <br><h1 id="vyvody">  Conclusiones </h1><br><p>  En total, tenemos un mapeador que funciona justo al momento de escribir el código, y luego no queda nada de su tiempo de ejecución.  Los planes presentan una forma de agregar capacidades de configuración.  Por ejemplo, configure las plantillas para los nombres de los métodos generados y especifique el directorio donde guardar.  También agregue la capacidad de rastrear cambios en los tipos.  Tengo una idea de cómo se puede organizar esto, pero sospecho que esto puede ser notable en términos de consumo de recursos, y hasta ahora se ha decidido retrasar esto. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/459771/">https://habr.com/ru/post/459771/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459761/index.html">Cómo cuidar una bicicleta eléctrica</a></li>
<li><a href="../459763/index.html">¿Cuántos TPS hay en tu blockchain?</a></li>
<li><a href="../459765/index.html">Inteligencia Artificial Goldeneye 007</a></li>
<li><a href="../459767/index.html">Tesla aumenta dramáticamente la producción de vehículos eléctricos</a></li>
<li><a href="../459769/index.html">Virtual, industrial, hogar</a></li>
<li><a href="../459773/index.html">Cómo construir, implementar y probar la aplicación Waves RIDE dApp</a></li>
<li><a href="../459775/index.html">Lo que aprendí sobre el aprendizaje automático después de trabajar en 12 startups</a></li>
<li><a href="../459785/index.html">Aprendizaje profundo: descripción general</a></li>
<li><a href="../459787/index.html">C ++, si el tipo está definido: declaración preliminar de los objetos necesarios</a></li>
<li><a href="../459789/index.html">Actualización de proyectos de Unity para Android para compatibilidad con la arquitectura ARM64</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>