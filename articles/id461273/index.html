<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🚀 🔬 👩🏻‍💼 Pendekatan serakah dan mesin slot. Analisis tugas ML-track kejuaraan pemrograman ☦️ 🧑 💓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami terus mempublikasikan analisis tugas yang diusulkan di kejuaraan baru-baru ini. Baris berikutnya adalah tugas yang diambil dari babak kualifikasi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pendekatan serakah dan mesin slot. Analisis tugas ML-track kejuaraan pemrograman</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/461273/"><img src="https://habrastorage.org/webt/sd/i7/yd/sdi7ydyv5yabtpudjamnnmm2dge.jpeg"><br><br>  Kami terus mempublikasikan analisis tugas yang diusulkan di kejuaraan baru-baru ini.  Baris berikutnya adalah tugas yang diambil dari babak kualifikasi untuk spesialis pembelajaran mesin.  Ini adalah trek ketiga dari empat (backend, frontend, ML, analytics).  Peserta perlu membuat model untuk memperbaiki kesalahan ketik dalam teks, mengusulkan strategi untuk bermain di mesin slot, mengingatkan sistem rekomendasi untuk konten, dan menyusun beberapa program lagi. <br><br><a name="habracut"></a><h2>  A. Kesalahan Pengetikan </h2><br><h4>  Ketentuan </h4><div class="scrollable-table"><table><tbody><tr><td></td><td>  <b>Semua bahasa</b> </td><td>  <b>python2.7 + numpy</b> </td><td>  <b>python3.5 + numpy</b> </td></tr><tr><td>  Batas waktu </td><td>  1 s </td><td>  5 s </td><td>  5 s </td></tr><tr><td>  Batas memori </td><td>  64 MB </td><td>  256 MB </td><td>  256 MB </td></tr><tr><td>  Masuk </td><td colspan="3">  input standar atau input.txt </td></tr><tr><td>  Kesimpulan </td><td colspan="3">  output standar atau output.txt </td></tr></tbody></table></div>  (epigraf) (dari satu forum) <br>  - Siapa yang menyusun omong kosong ini? <br>  - Ahli astrofisika.  Mereka juga manusia. <br>  - Anda membuat 10 kesalahan dalam kata "jurnalis". <br><br>  Banyak pengguna membuat kesalahan pengetikan, beberapa karena menekan tombol, dan beberapa karena buta huruf.  Kami ingin memeriksa apakah pengguna benar-benar dapat mengingat kata lain selain yang diketiknya. <br><br>  Secara lebih formal, anggaplah bahwa model kesalahan berikut terjadi: pengguna mulai dengan kata yang ingin ia tulis, dan kemudian membuat sejumlah kesalahan di dalamnya.  Setiap kesalahan adalah substitusi dari beberapa substring kata untuk substring lain.  Satu kesalahan terkait dengan mengganti hanya dalam satu posisi (yaitu, jika pengguna ingin membuat kesalahan tunggal dengan aturan "abc" → "cba", maka dari string "abcabc" ia bisa mendapatkan "cbaabc" atau "abccba").  Setelah setiap kesalahan, proses berulang.  Aturan yang sama dapat digunakan beberapa kali dalam langkah yang berbeda (misalnya, dalam contoh di atas, "cbacba" dapat diperoleh dalam dua langkah). <br><br>  Hal ini diperlukan untuk menentukan jumlah kesalahan minimum yang dapat dilakukan pengguna jika ia memikirkan satu kata tertentu dan menulis yang lain. <br><br><div class="spoiler">  <b class="spoiler_title">Format dan Contoh I / O</b> <div class="spoiler_text"><h4>  Format input </h4><br>  Baris pertama berisi kata, yang, menurut asumsi kami, yang ada di benak pengguna (terdiri dari huruf-huruf alfabet Latin dalam huruf kecil, panjangnya tidak melebihi 20). <br><br>  Baris kedua berisi kata yang sebenarnya ia tulis (juga terdiri dari huruf-huruf alfabet Latin dalam huruf kecil, panjangnya tidak melebihi 20). <br><br>  Baris ketiga berisi angka tunggal N (N &lt;50) - jumlah penggantian yang menggambarkan berbagai kesalahan. <br><br>  Baris N berikutnya berisi kemungkinan penggantian dalam format &amp; lt "benar" urutan huruf &amp; gt &lt;spasi&gt; &lt;"salah" urutan huruf&gt;.  Urutan tidak lebih dari 6 karakter. <br><br><h4>  Format output </h4><br>  Diperlukan untuk mencetak satu nomor - jumlah kesalahan minimum yang bisa dilakukan pengguna.  Jika angka ini melebihi 4 atau tidak mungkin mendapatkan yang lain dari satu kata, cetak -1. <br><br><h4>  Contoh </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Masuk</b> </td><td>  <b>Kesimpulan</b> </td></tr><tr><td><code>mlax <br> drum <br> 50 <br> lr <br> mlax gtwt <br> md <br> mlax ujoc <br> ml pq <br> mf <br> ml bf <br> mlax aruq <br> mlax nqdd <br> mlax fglm <br> mlax bfit <br> mlax mziq <br> mla hlb <br> au <br> mlax vmpa <br> mw <br> aw <br> ax ok <br> mla kqf <br> me <br> xx <br> ml if <br> ml gk <br> le <br> mla xrh <br> mj <br> ac <br> ab <br> mq <br> ax fr <br> ml sb <br> mlax gxxx <br> xm <br> mlax hczx <br> lq <br> la sv <br> lg <br> ax eh <br> lax mjh <br> la ec <br> la pv <br> ml iq <br> aq <br> lax jrs <br> la qn <br> lax bjo <br> lo <br> az <br> ln <br> ac</code> </td> <td> <code>4</code> </td> </tr></tbody></table></div></div></div><br><h4>  Solusi </h4><br>  Mari kita coba untuk menghasilkan dari ejaan yang benar semua kata yang mungkin dengan tidak lebih dari 4 kesalahan.  Dalam kasus terburuk, mungkin ada O ((L﹒N) <sup>4</sup> ).  Dalam batasan masalah, ini adalah angka yang agak besar, jadi Anda perlu mencari cara untuk mengurangi kompleksitas.  Alih-alih, Anda dapat menggunakan algoritme meet-in-the-middle: menghasilkan kata-kata dengan tidak lebih dari 2 kesalahan, serta kata-kata dari mana Anda bisa mendapatkan kata yang ditulis pengguna tanpa lebih dari 2 kesalahan.  Perhatikan bahwa ukuran masing-masing set ini tidak akan melebihi 10 <sup>6</sup> .  Jika jumlah kesalahan yang dilakukan oleh pengguna tidak melebihi 4, maka set ini akan berpotongan.  Demikian pula, kami dapat memverifikasi bahwa jumlah kesalahan tidak melebihi 3, 2, dan 1. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FromTo</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> from; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> to; }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; applyRule(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&amp; word, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FromTo &amp;fromTo, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> pos) { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> from = word.find(fromTo.from, pos); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (from == <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos, {}}; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> to = from + fromTo.from.size(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> cpy = word; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = from; i &lt; to; i++) { cpy[i] = fromTo.to[i - from]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> {from, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cpy)}; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">inverseRules</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;FromTo&gt; &amp;rules)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; rule: rules) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap(rule.from, rule.to); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">solve</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; wordOrig, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; wordMissprinted, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">vector</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;FromTo&gt;&amp; replaces)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; mapping; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; mappingInverse; mapping.emplace(wordOrig, <span class="hljs-number"><span class="hljs-number">0</span></span>); mappingInverse.emplace(<span class="hljs-number"><span class="hljs-number">0</span></span>, wordOrig); mapping.emplace(wordMissprinted, <span class="hljs-number"><span class="hljs-number">1</span></span>); mappingInverse.emplace(<span class="hljs-number"><span class="hljs-number">1</span></span>, wordMissprinted); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_map</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; edges; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> buildGraph = [&amp;edges, &amp;mapping, &amp;mappingInverse](<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> startId, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;FromTo&gt;&amp; replaces, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> dir) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; mappingLayer0; mappingLayer0 = {startId}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">2</span></span>; i++) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unordered_set</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; mappingLayer1; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; v: mappingLayer0) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; word = mappingInverse.at(v); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; fromTo: replaces) { <span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> from = <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [tmp, wordCpy] = applyRule(word, fromTo, from); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tmp == <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>::npos) { <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } from = tmp + <span class="hljs-number"><span class="hljs-number">1</span></span>; { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w = mapping.size(); mapping.emplace(wordCpy, w); w = mapping.at(wordCpy); mappingInverse.emplace(w, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(wordCpy)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (dir) { edges[v].emplace(w); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { edges[w].emplace(v); } mappingLayer1.emplace(w); } } } } mappingLayer0 = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(mappingLayer1); } }; buildGraph(<span class="hljs-number"><span class="hljs-number">0</span></span>, replaces, <span class="hljs-literal"><span class="hljs-literal">true</span></span>); inverseRules(replaces); buildGraph(<span class="hljs-number"><span class="hljs-number">1</span></span>, replaces, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&gt; q; q.emplace(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt; mask(mapping.size(), <span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> level{<span class="hljs-number"><span class="hljs-number">0</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (q.size()) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> [w, level] = q.front(); q.pop(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mask[w]) { <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } mask[w] = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mappingInverse.at(w) == wordMissprinted) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> level; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>&amp; v: edges[w]) { q.emplace(v, level + <span class="hljs-number"><span class="hljs-number">1</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; }</code> </pre> <br><h2>  B. Bandit berlengan banyak </h2><br><h4>  Ketentuan </h4><div class="scrollable-table"><table><tbody><tr><td>  Batas waktu </td><td>  2 s </td></tr><tr><td>  Batas memori </td><td>  64 MB </td></tr><tr><td>  Masuk </td><td>  input standar </td></tr><tr><td>  Kesimpulan </td><td>  output standar </td></tr></tbody></table></div>  Ini adalah tugas interaktif. <br><br>  Anda sendiri tidak tahu bagaimana itu terjadi, tetapi Anda mendapati diri Anda berada di aula dengan mesin slot dengan seluruh kantong token.  Sayangnya, di box office, mereka menolak untuk menerima token kembali, dan Anda memutuskan untuk mencoba keberuntungan Anda.  Ada banyak mesin slot di aula yang bisa Anda mainkan.  Untuk satu game dengan mesin slot Anda menggunakan satu token.  Jika menang, mesin memberi Anda satu dolar, jika terjadi kerugian - tidak ada.  Setiap mesin memiliki probabilitas tetap untuk menang (yang Anda tidak tahu), tetapi berbeda untuk mesin yang berbeda.  Setelah mempelajari situs web produsen mesin ini, Anda menemukan bahwa probabilitas menang untuk setiap mesin dipilih secara acak pada tahap pembuatan dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">distribusi beta</a> dengan parameter tertentu. <br><br>  Anda ingin memaksimalkan kemenangan yang Anda harapkan. <br><br><div class="spoiler">  <b class="spoiler_title">Format dan Contoh I / O</b> <div class="spoiler_text"><h4>  Format input </h4><br>  Satu eksekusi dapat terdiri dari beberapa tes. <br><br>  Setiap tes dimulai dengan fakta bahwa program Anda di telepon berisi dua bilangan bulat yang dipisahkan oleh spasi: angka N adalah jumlah token di tas Anda, dan M adalah jumlah mesin di aula (N ≤ 10 <sup>4</sup> , M ≤ min (N, 100) )  Baris berikutnya berisi dua bilangan real α dan β (1 ≤ α, β ≤ 10) - parameter distribusi beta dari probabilitas menang. <br><br>  Protokol komunikasi dengan sistem pemeriksaan adalah ini: Anda membuat permintaan N persis.  Untuk setiap permintaan, cetak dalam baris terpisah nomor mesin yang akan Anda mainkan (dari 1 hingga M inklusif).  Sebagai jawaban, di baris terpisah akan ada "0" atau "1", yang berarti masing-masing kalah dan menang dalam permainan dengan mesin slot yang diminta. <br><br>  Setelah tes terakhir, alih-alih angka N dan M, akan ada dua nol. <br><br><h4>  Format output </h4><br>  Tugas tersebut akan dianggap selesai jika keputusan Anda tidak lebih buruk dari keputusan juri.  Jika keputusan Anda secara signifikan lebih buruk daripada keputusan juri, Anda akan menerima vonis "jawaban salah". <br><br>  Dijamin bahwa jika keputusan Anda tidak lebih buruk dari keputusan juri, maka kemungkinan menerima putusan “jawaban salah” tidak melebihi <sup>10-6</sup> . <br><br><h4>  Catatan </h4><br>  Contoh Interaksi: <br><br><pre> <code class="cpp hljs">____________________  <span class="hljs-built_in"><span class="hljs-built_in">stdin</span></span>     <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> ____________________ ____________________   <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>   <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>              <span class="hljs-number"><span class="hljs-number">2</span></span>    <span class="hljs-number"><span class="hljs-number">1</span></span>              <span class="hljs-number"><span class="hljs-number">1</span></span>    <span class="hljs-number"><span class="hljs-number">0</span></span>              <span class="hljs-number"><span class="hljs-number">1</span></span>    <span class="hljs-number"><span class="hljs-number">1</span></span>              <span class="hljs-number"><span class="hljs-number">2</span></span>    <span class="hljs-number"><span class="hljs-number">1</span></span>              <span class="hljs-number"><span class="hljs-number">2</span></span>    <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </div></div><br><h4>  Solusi </h4><br>  Masalah ini sudah diketahui, bisa diselesaikan dengan berbagai cara.  Keputusan utama juri menerapkan strategi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pengambilan sampel Thompson</a> , tetapi karena jumlah langkah diketahui pada awal program, ada strategi yang lebih optimal (misalnya, UCB1).  Selain itu, seseorang bahkan bisa bertahan dengan strategi epsilon-serakah: dengan probabilitas tertentu ε memainkan mesin acak dan dengan probabilitas (1 - ε) memainkan mesin dengan statistik kemenangan terbaik. <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SolverFromStdIn</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.regrets = [<span class="hljs-number"><span class="hljs-number">0.</span></span>] self.total_win = [<span class="hljs-number"><span class="hljs-number">0.</span></span>] self.moves = [] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ThompsonSampling</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(SolverFromStdIn)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, bandits_total, init_a=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">, init_b=</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" init_a (int): initial value of a in Beta(a, b). init_b (int): initial value of b in Beta(a, b). """</span></span> SolverFromStdIn.__init__(self) self.n = bandits_total self.alpha = init_a self.beta = init_b self._as = [init_a] * self.n <span class="hljs-comment"><span class="hljs-comment"># [random.betavariate(self.alpha, self.beta) for _ in range(self.n)] self._bs = [init_b] * self.n # [random.betavariate(self.alpha, self.beta) for _ in range(self.n)] self.last_move = -1 random.seed(int(time.time())) def move(self): samples = [random.betavariate(self._as[x], self._bs[x]) for x in range(self.n)] self.last_move = max(range(self.n), key=lambda x: samples[x]) self.moves.append(self.last_move) return self.last_move def set_reward(self, reward): i = self.last_move r = reward self._as[i] += r self._bs[i] += (1 - r) return i, r while True: n, m = map(int, sys.stdin.readline().split()) if n == 0 and m == 0: break alpha, beta = map(float, sys.stdin.readline().split()) solver = ThompsonSampling(m) for _ in range(n): print &gt;&gt; sys.stdout, solver.move() + 1 sys.stdout.flush() reward = int(sys.stdin.readline()) solver.set_reward(reward)</span></span></code> </pre> <br><h2>  C. Penyelarasan kalimat </h2><br><h4>  Ketentuan </h4><div class="scrollable-table"><table><tbody><tr><td>  Batas waktu </td><td>  2 s </td></tr><tr><td>  Batas memori </td><td>  64 MB </td></tr><tr><td>  Masuk </td><td>  input standar atau input.txt </td></tr><tr><td>  Kesimpulan </td><td>  output standar atau output.txt </td></tr></tbody></table></div>  Salah satu tugas paling penting untuk melatih model terjemahan mesin yang baik adalah kasus kalimat paralel yang baik.  Biasanya, sumber untuk penawaran paralel adalah dokumen paralel.  Ternyata seringkali untuk membangun korpus kalimat paralel tertentu, Anda tidak perlu tahu apa-apa selain panjangnya.  Secara khusus, Anda mungkin memperhatikan bahwa semakin lama kalimat dalam bahasa sumber, semakin lama kemungkinan akan diterjemahkan.  Beberapa kesulitan terletak pada kenyataan bahwa selama terjemahan jumlah kalimat dalam teks dapat berubah: kadang-kadang dua kalimat yang berdekatan dalam terjemahan dapat digabungkan menjadi satu, atau sebaliknya - satu kalimat dapat dibagi menjadi dua.  Dalam beberapa kasus yang jarang terjadi, kalimat dapat dihilangkan seluruhnya dalam terjemahan, atau terjemahan mungkin muncul dalam terjemahan yang tidak asli. <br><br>  Lebih formal, anggap model generatif berikut untuk penutup paralel adalah benar.  Pada setiap langkah, kami melakukan salah satu dari yang berikut: <br><br>  <b>1. <i>Berhenti</i></b> <br><br>  Dengan probabilitas p <sub>h,</sub> generasi lambung berakhir. <br><br>  <b>2. [1-0] <i>Melewati penawaran</i></b> <br><br>  Dengan probabilitas p <sub>d kita</sub> menganggap satu kalimat ke teks asli.  Kami tidak menghubungkan apa pun dengan terjemahan.  Panjang kalimat dalam bahasa asli L ≥ 1 dipilih dari distribusi diskrit: <br><br><img src="https://habrastorage.org/webt/bm/pe/t_/bmpet_y_ksvwgbohazpgctekbks.png" width="350">  . <br><br>  Di sini <i>μ <sub>s</sub></i> , <i>σ <sub>s</sub></i> adalah parameter distribusi, dan <i>α <sub>s</sub></i> adalah koefisien normalisasi yang dipilih <img src="https://habrastorage.org/webt/fm/ae/ns/fmaensnvy1nauvywiluibhryr6s.png" width="100">  . <br><br>  <b>3. [0-1] <i>Masukkan proposal</i></b> <br><br>  Dengan probabilitas p <sub>i, kami</sub> menetapkan satu kalimat untuk terjemahan.  Kami tidak menganggap apa pun dari aslinya.  Panjang kalimat dalam bahasa terjemahan L ≥ 1 dipilih dari distribusi diskrit: <br><br><img src="https://habrastorage.org/webt/yl/yn/kr/ylynkr3cs_t7dpedebtzqj3uryk.png" width="350">  . <br><br>  Di sini <i>μ <sub>t</sub></i> , <i>σ <sub>t</sub></i> adalah parameter distribusi, dan <i>α <sub>t</sub></i> adalah koefisien normalisasi yang dipilih <img src="https://habrastorage.org/webt/bq/-k/p3/bq-kp37k-c-k5fpq9jrz4r8rkvy.png" width="100">  . <br><br>  <b>4. <i>Terjemahan</i></b> <br><br>  Dengan probabilitas (1 - p <sub>d</sub> - p <sub>i</sub> - p <sub>h</sub> ) kami mengambil panjang kalimat dalam bahasa asli L <sub>s</sub> ≥ 1 dari distribusi p <sub>s</sub> (dengan pembulatan ke atas).  Selanjutnya, kami menghasilkan panjang kalimat dalam bahasa terjemahan <sub>Lt</sub> ≥ 1 dari distribusi diskrit bersyarat: <br><br><img src="https://habrastorage.org/webt/ae/b6/mx/aeb6mx4cols1jplbs-di9emhxf8.png" width="500">  . <br><br>  Di sini, <i>α <sub>st</sub></i> adalah koefisien normalisasi, dan parameter yang tersisa dijelaskan dalam paragraf sebelumnya. <br><br>  Berikutnya adalah langkah lain: <br><br>  1. [2-1] Dengan probabilitas p <sub>split s,</sub> kalimat yang dihasilkan dalam bahasa asli terbagi menjadi dua yang tidak kosong, sehingga jumlah total kata <b><i>bertambah tepat satu</i></b> .  Probabilitas bahwa kalimat dengan panjang Ls <sub>akan</sub> terpisah menjadi bagian-bagian dengan panjang L1 dan L2 (yaitu, L1 + L2 = Ls + 1) sebanding dengan Ps (L <sub>1</sub> ) ⋅ Ps (L <sub>2</sub> ). <br><br>  2. [1-2] Dengan probabilitas p <sub>split t,</sub> kalimat yang dihasilkan dalam bahasa target dibagi menjadi dua kalimat yang tidak kosong, sehingga jumlah total kata bertambah tepat satu.  Probabilitas bahwa kalimat dengan panjang <sub>Lt akan</sub> terpecah menjadi beberapa bagian dengan panjang L1 dan L2 (yaitu, L1 + L2 = <sub>Lt</sub> + 1) sebanding dengan <sub>Pt</sub> (L1) ⋅ Pt (L <sub>2</sub> ). <br><br>  3. 3. [1-1] Dengan probabilitas (1 - <sub>pisah s</sub> - p <sub>split t</sub> ), tidak satu pun dari pasangan kalimat yang dihasilkan akan meluruh. <br><br><div class="spoiler">  <b class="spoiler_title">Format, Contoh, dan Catatan I / O</b> <div class="spoiler_text"><h4>  Format input </h4><br>  Baris pertama file berisi parameter distribusi: p <sub>h</sub> , p <sub>d</sub> , p <sub>i</sub> , p <sub>split s</sub> , p <sub>split t</sub> , μ <sub>s</sub> , σ <sub>s</sub> , μ <sub>t</sub> , σ <sub>t</sub> .  0,1 ≤ σ <sub>s</sub> &lt;σ <sub>t</sub> ≤ 3. 0 ≤ μ <sub>s</sub> , μ <sub>t</sub> ≤ 5. <br><br>  Baris berikutnya berisi angka Ns dan <sub>Nt</sub> - jumlah kalimat dalam kasus dalam bahasa asli dan bahasa target, masing-masing (1 ≤ N <sub>s</sub> , N <sub>t</sub> ≤ 1000). <br><br>  Baris berikutnya berisi bilangan bulat N - panjang kalimat dalam bahasa asli.  Baris berikutnya berisi bilangan bulat N - panjang kalimat dalam bahasa target. <br><br>  Baris berikutnya berisi dua angka: j dan k (1 ≤ j ≤ N <sub>s</sub> , 1 ≤ k ≤ N <sub>t</sub> ). <br><br><h4>  Format output </h4><br>  Diperlukan untuk memperoleh probabilitas bahwa kalimat dengan indeks j dan k dalam teks, masing-masing, adalah paralel (yaitu, bahwa mereka dihasilkan pada satu langkah algoritma dan tidak satupun dari mereka adalah hasil dari pembusukan). <br><br>  Jawaban Anda akan diterima jika kesalahan absolut tidak melebihi <sup>10-4</sup> . <br><br><h4>  Contoh 1 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Masuk</b> </td><td>  <b>Kesimpulan</b> </td></tr><tr><td> <code>0.05 0.08 0.07 0.15 0.1 1 0.3 3 0.5 <br> 1 1 <br> 4 <br> 20 <br> 1 1</code> </td> <td> <code>0.975037457809</code> </td> </tr></tbody></table></div><h4>  Contoh 2 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Masuk</b> </td><td>  <b>Kesimpulan</b> </td></tr><tr><td> <code>0.1 0.2 0.3 0.25 0.3 1 0.3 3 0.5 <br> 2 1 <br> 3 4 <br> 20 <br> 2 1</code> </td> <td> <code>0.247705779810</code> </td> </tr></tbody></table></div><h4>  Contoh 3 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Masuk</b> </td><td>  <b>Kesimpulan</b> </td></tr><tr><td> <code>0.2 0.2 0.2 0.3 0.3 3 0.3 1 1 <br> 5 3 <br> 16 35 24 19 23 <br> 5 6 7 <br> 2 1</code> </td> <td> <code>0.200961101684</code> </td> </tr></tbody></table></div><h4>  Catatan </h4><br>  Dalam contoh pertama, urutan awal angka dapat diperoleh dengan tiga cara: <br><br>  • Pertama, dengan probabilitas p <sub>d</sub> menambahkan satu kalimat ke teks asli, kemudian dengan probabilitas p <sub>i</sub> menambahkan satu kalimat ke terjemahan, kemudian dengan probabilitas p <sub>h</sub> menyelesaikan generasi. <br><br>  Probabilitas acara ini adalah P <sub>1</sub> = p <sub>d</sub> * P <sub>s</sub> (4) * p <sub>i</sub> * P <sub>t</sub> (20) * p <sub>h</sub> . <br><br>  • Pertama, dengan probabilitas p <sub>d</sub> menambahkan satu kalimat ke teks asli, kemudian dengan probabilitas p <sub>i</sub> menambahkan satu kalimat ke terjemahan, kemudian dengan probabilitas p <sub>h</sub> menyelesaikan generasi. <br><br>  Probabilitas acara ini sama dengan P <sub>2</sub> = p <sub>i</sub> * P <sub>t</sub> (20) * p <sub>d</sub> * P <sub>s</sub> (4) * p <sub>h</sub> . <br><br>  • Dengan probabilitas (1 - p <sub>h</sub> - p <sub>d</sub> - p <sub>i</sub> ) menghasilkan dua kalimat, maka dengan probabilitas (1 - p <sub>s s</sub> - p <sub>split t</sub> ) biarkan semuanya apa adanya (yaitu, jangan pisahkan yang asli atau terjemahan menjadi dua kalimat ) dan setelah itu dengan probabilitas p <sub>h</sub> menyelesaikan generasi. <br><br>  Probabilitas acara ini adalah <br><img src="https://habrastorage.org/webt/xw/ka/ys/xwkayskmtg4g3tkt9pb3n-ieyoa.png" width="550">  . <br><br>  Akibatnya, jawabannya dihitung sebagai <img src="https://habrastorage.org/webt/zm/tw/xk/zmtwxkdjhhctfrcbiqsc0tur6g0.png" width="100">  . </div></div><br><h4>  Solusi </h4><br>  Tugas ini merupakan kasus penyelarasan khusus menggunakan model Markov tersembunyi (penyelarasan HMM).  Gagasan utamanya adalah Anda dapat menghitung probabilitas menghasilkan sepasang dokumen tertentu menggunakan model ini dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma penerusan</a> : dalam kasus ini, negara adalah sepasang awalan dokumen.  Dengan demikian, probabilitas yang diperlukan untuk menyelaraskan pasangan kalimat paralel tertentu dapat dihitung dengan algoritma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">maju-mundur</a> . <br><br><div class="spoiler">  <b class="spoiler_title">Kode</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;cmath&gt; #include &lt;vector&gt; double p_h, p_d, p_i, p_tr, p_ss, p_st, mu_s, sigma_s, mu_t, sigma_t; double lognorm_cdf(double x, double mu, double sigma) { if (x &lt; 1e-9) return 0.0; double res = std::log(x) - mu; res /= std::sqrt(2.0) * sigma; res = 0.5 * (1 + std::erf(res)); return res; } double length_probability(int l, double mu, double sigma) { return lognorm_cdf(l, mu, sigma) - lognorm_cdf(l - 1, mu, sigma); } double translation_probability(int ls, int lt) { double res = length_probability(ls, mu_s, sigma_s); double mu = mu_t - mu_s + std::log(ls); double sigma = std::sqrt(sigma_t * sigma_t - sigma_s * sigma_s); res *= length_probability(lt, mu, sigma); return res; } double split_probability(int l1, int l2, double mu, double sigma) { int l_sum = l1 + l2; double total_prob = 0.0; for (int i = 1; i &lt; l_sum; ++i) { total_prob += length_probability(i, mu, sigma) * length_probability(l_sum - i, mu, sigma); } return length_probability(l1, mu, sigma) * length_probability(l2, mu, sigma) / total_prob; } double log_prob10(int ls) { return std::log(p_d * length_probability(ls, mu_s, sigma_s)); } double log_prob01(int lt) { return std::log(p_i * length_probability(lt, mu_t, sigma_t)); } double log_prob11(int ls, int lt) { return std::log(p_tr * (1 - p_ss - p_st) * translation_probability(ls, lt)); } double log_prob21(int ls1, int ls2, int lt) { return std::log(p_tr * p_ss * split_probability(ls1, ls2, mu_s, sigma_s) * translation_probability(ls1 + ls2 - 1, lt)); } double log_prob12(int ls, int lt1, int lt2) { return std::log(p_tr * p_st * split_probability(lt1, lt2, mu_t, sigma_t) * translation_probability(ls, lt1 + lt2 - 1)); } double logsum(double v1, double v2) { double res = std::max(v1, v2); v1 -= res; v2 -= res; v1 = std::min(v1, v2); if (v1 &lt; -30) { return res; } return res + std::log(std::exp(v1) + 1.0); } double loginc(double* to, double from) { *to = logsum(*to, from); } constexpr double INF = 1e25; int main(void) { using std::cin; using std::cout; cin &gt;&gt; p_h &gt;&gt; p_d &gt;&gt; p_i &gt;&gt; p_ss &gt;&gt; p_st &gt;&gt; mu_s &gt;&gt; sigma_s &gt;&gt; mu_t &gt;&gt; sigma_t; p_tr = 1.0 - p_h - p_d - p_i; int Ns, Nt; cin &gt;&gt; Ns &gt;&gt; Nt; using std::vector; vector&lt;int&gt; ls(Ns), lt(Nt); for (int i = 0; i &lt; Ns; ++i) cin &gt;&gt; ls[i]; for (int i = 0; i &lt; Nt; ++i) cin &gt;&gt; lt[i]; vector&lt; vector&lt; double&gt; &gt; fwd(Ns + 1, vector&lt;double&gt;(Nt + 1, -INF)), bwd = fwd; fwd[0][0] = 0; bwd[Ns][Nt] = 0; for (int i = 0; i &lt;= Ns; ++i) { for (int j = 0; j &lt;= Nt; ++j) { if (i &gt;= 1) { loginc(&amp;fwd[i][j], fwd[i - 1][j] + log_prob10(ls[i - 1])); loginc(&amp;bwd[Ns - i][Nt - j], bwd[Ns - i + 1][Nt - j] + log_prob10(ls[Ns - i])); } if (j &gt;= 1) { loginc(&amp;fwd[i][j], fwd[i][j - 1] + log_prob01(lt[j - 1])); loginc(&amp;bwd[Ns - i][Nt - j], bwd[Ns - i][Nt - j + 1] + log_prob01(lt[Nt - j])); } if (i &gt;= 1 &amp;&amp; j &gt;= 1) { loginc(&amp;fwd[i][j], fwd[i - 1][j - 1] + log_prob11(ls[i - 1], lt[j - 1])); loginc(&amp;bwd[Ns - i][Nt - j], bwd[Ns - i + 1][Nt - j + 1] + log_prob11(ls[Ns - i], lt[Nt - j])); } if (i &gt;= 2 &amp;&amp; j &gt;= 1) { loginc(&amp;fwd[i][j], fwd[i - 2][j - 1] + log_prob21(ls[i - 1], ls[i - 2], lt[j - 1])); loginc(&amp;bwd[Ns - i][Nt - j], bwd[Ns - i + 2][Nt - j + 1] + log_prob21(ls[Ns - i], ls[Ns - i + 1], lt[Nt - j])); } if (i &gt;= 1 &amp;&amp; j &gt;= 2) { loginc(&amp;fwd[i][j], fwd[i - 1][j - 2] + log_prob12(ls[i - 1], lt[j - 1], lt[j - 2])); loginc(&amp;bwd[Ns - i][Nt - j], bwd[Ns - i + 1][Nt - j + 2] + log_prob12(ls[Ns - i], lt[Nt - j], lt[Nt - j + 1])); } } } int j, k; cin &gt;&gt; j &gt;&gt; k; double rlog = fwd[j - 1][k - 1] + bwd[j][k] + log_prob11(ls[j - 1], lt[k - 1]) - bwd[0][0]; cout &lt;&lt; std::fixed &lt;&lt; std::setprecision(12) &lt;&lt; std::exp(rlog) &lt;&lt; std::endl; }</span></span></span></span></code> </pre> </div></div><br><h2>  D. Rekaman rekomendasi </h2><br><h4>  Ketentuan </h4><div class="scrollable-table"><table><tbody><tr><td>  Batas waktu </td><td>  2 s </td></tr><tr><td>  Batas memori </td><td>  64 MB </td></tr><tr><td>  Masuk </td><td>  input standar atau input.txt </td></tr><tr><td>  Kesimpulan </td><td>  output standar atau output.txt </td></tr></tbody></table></div>  Pertimbangkan umpan rekomendasi untuk konten heterogen.  Ini mencampur objek dari berbagai jenis (gambar, video, berita, dll.).  Objek-objek ini biasanya dipesan berdasarkan relevansinya dengan pengguna: semakin relevan (menarik) objek dengan pengguna, semakin dekat ke bagian atas daftar rekomendasi.  Namun, dengan pemesanan seperti itu, situasi sering muncul di mana beberapa objek dari jenis yang sama muncul dalam daftar rekomendasi.  Ini sangat memperburuk variasi eksternal dari rekomendasi kami dan oleh karena itu pengguna tidak menyukainya.  Diperlukan untuk mengimplementasikan suatu algoritma yang, sesuai dengan daftar rekomendasi, akan membuat daftar baru yang akan bebas dari masalah ini dan akan menjadi yang paling relevan. <br><br>  Biarkan daftar rekomendasi awal diberi = [a <sub>0</sub> , a <sub>1</sub> , ..., a <sub>n - 1</sub> ] dengan panjang n&gt; 0. Objek dengan angka i memiliki tipe dengan angka b <sub>i</sub> ∈ {0, ..., m - 1}.  Selain itu, objek di bawah angka i memiliki relevansi r (a <sub>i</sub> ) = 2 <sub>−i</sub> .  Pertimbangkan daftar yang diperoleh dari yang awal dengan memilih subset objek dan mengatur ulang mereka: x = [a <sub>i <sub>0</sub></sub> , a <sub>i <sub>1</sub></sub> , ..., a <sub>i <sub>k - 1</sub></sub> ] dengan panjang k (0 ≤ k ≤ n).  Daftar disebut dapat diterima jika tidak ada dua objek berurutan di dalamnya bertepatan dengan tipe, mis., B <sub>i <sub>j</sub></sub> ≠ b <sub>i <sub>j + 1</sub></sub> untuk semua j = 0, ..., k - 2.  Relevansi daftar dihitung oleh rumus <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mtext>&amp;#xA0;</mtext><mi>s</mi><mi>u</mi><msubsup><mi>m</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>k</mi><mo>&amp;#x2212;</mo><mn>1</mn></mrow></msubsup><msub><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x2212;</mo><mi>j</mi></mrow></msub><mi>r</mi><mo stretchy=&quot;false&quot;>(</mo><msub><mi>a</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><msub><mi>i</mi><mi>j</mi></msub></mrow></msub><mo stretchy=&quot;false&quot;>)</mo></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="17.112ex" height="3.503ex" viewBox="0 -987.6 7367.6 1508.3" role="img" focusable="false" style="vertical-align: -1.209ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhDmtpW2xMjEFmULqk8o5yE1MxnzA#MJMATHI-73" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhDmtpW2xMjEFmULqk8o5yE1MxnzA#MJMATHI-75" x="719" y="0"></use><g transform="translate(1292,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhDmtpW2xMjEFmULqk8o5yE1MxnzA#MJMATHI-6D" x="0" y="0"></use><g transform="translate(878,403)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhDmtpW2xMjEFmULqk8o5yE1MxnzA#MJMATHI-6B" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhDmtpW2xMjEFmULqk8o5yE1MxnzA#MJMAIN-2212" x="521" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhDmtpW2xMjEFmULqk8o5yE1MxnzA#MJMAIN-31" x="1300" y="0"></use></g><g transform="translate(878,-308)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhDmtpW2xMjEFmULqk8o5yE1MxnzA#MJMATHI-6A" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhDmtpW2xMjEFmULqk8o5yE1MxnzA#MJMAIN-3D" x="412" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhDmtpW2xMjEFmULqk8o5yE1MxnzA#MJMAIN-30" x="1191" y="0"></use></g></g><g transform="translate(3543,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhDmtpW2xMjEFmULqk8o5yE1MxnzA#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhDmtpW2xMjEFmULqk8o5yE1MxnzA#MJMAIN-2212" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhDmtpW2xMjEFmULqk8o5yE1MxnzA#MJMATHI-6A" x="778" y="0"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhDmtpW2xMjEFmULqk8o5yE1MxnzA#MJMATHI-72" x="4986" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhDmtpW2xMjEFmULqk8o5yE1MxnzA#MJMAIN-28" x="5437" y="0"></use><g transform="translate(5827,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhDmtpW2xMjEFmULqk8o5yE1MxnzA#MJMATHI-61" x="0" y="0"></use><g transform="translate(529,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhDmtpW2xMjEFmULqk8o5yE1MxnzA#MJMATHI-69" x="0" y="0"></use><use transform="scale(0.5)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhDmtpW2xMjEFmULqk8o5yE1MxnzA#MJMATHI-6A" x="488" y="-213"></use></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/yandex/blog/461273/&amp;usg=ALkJrhhDmtpW2xMjEFmULqk8o5yE1MxnzA#MJMAIN-29" x="6978" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mtext>&nbsp;</mtext><mi>s</mi><mi>u</mi><msubsup><mi>m</mi><mrow class="MJX-TeXAtom-ORD"><mi>j</mi><mo>=</mo><mn>0</mn></mrow><mrow class="MJX-TeXAtom-ORD"><mi>k</mi><mo>−</mo><mn>1</mn></mrow></msubsup><msub><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mo>−</mo><mi>j</mi></mrow></msub><mi>r</mi><mo stretchy="false">(</mo><msub><mi>a</mi><mrow class="MJX-TeXAtom-ORD"><msub><mi>i</mi><mi>j</mi></msub></mrow></msub><mo stretchy="false">)</mo></math></span></span><script type="math/tex" id="MathJax-Element-1"> \ sum_ {j = 0} ^ {k-1} 2 _ {- j} r (a_ {i_j}) </script>  .  Anda perlu menemukan daftar relevansi maksimum di antara semua yang valid. <br><br><div class="spoiler">  <b class="spoiler_title">Format dan Contoh I / O</b> <div class="spoiler_text"><h4>  Format input </h4><br>  Pada baris pertama, angka n dan m ditulis dengan spasi (1 ≤ n ≤ 100000, 1 ≤ m ≤ n).  Baris n berikutnya berisi angka b <sub>i</sub> untuk i = 0, ..., n - 1 (0 ≤ b <sub>i</sub> ≤ m - 1). <br><br><h4>  Format output </h4><br>  Tulis, dengan spasi, jumlah objek dalam daftar akhir: i <sub>0</sub> , i <sub>1</sub> , ..., i <sub>k - 1</sub> . <br><br><h4>  Contoh 1 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Masuk</b> </td><td>  <b>Kesimpulan</b> </td></tr><tr><td> <code>1 1 <br> 0</code> </td> <td> <code>0</code> </td> </tr></tbody></table></div><h4>  Contoh 2 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Masuk</b> </td><td>  <b>Kesimpulan</b> </td></tr><tr><td> <code>2 2 <br> 1 <br> 1</code> </td> <td> <code>0</code> </td> </tr></tbody></table></div><h4>  Contoh 3 </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Masuk</b> </td><td>  <b>Kesimpulan</b> </td></tr><tr><td> <code>10 2 <br> 1 <br> 1 <br> 1 <br> 0 <br> 0 <br> 1 <br> 0 <br> 1 <br> 1 <br> 1</code> </td> <td> <code>0 3 1 4 2 6 5</code> </td> </tr></tbody></table></div></div></div><br><h4>  Solusi </h4><br>  Dengan menggunakan perhitungan matematis sederhana, dapat ditunjukkan bahwa masalahnya dapat diselesaikan dengan pendekatan "serakah", yaitu, dalam daftar rekomendasi yang optimal, setiap item memiliki objek paling relevan dari semua yang valid pada awal daftar yang sama.  Implementasi dari pendekatan ini sederhana: kita mengambil objek dalam satu baris dan menambahkannya ke jawabannya, jika memungkinkan.  Ketika objek yang tidak valid ditemukan (jenis yang bertepatan dengan jenis yang sebelumnya), kami mengesampingkannya dalam antrian terpisah, dari mana kami memasukkannya ke dalam respons sesegera mungkin.  Perhatikan bahwa pada setiap saat, semua objek dalam antrian ini akan memiliki jenis yang cocok.  Pada akhirnya, beberapa objek mungkin tetap dalam antrian, mereka tidak akan lagi dimasukkan dalam respons. <br><br><pre> <code class="cpp hljs"> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; blend(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> m, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt;&amp; types) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; result; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; repeated; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; n; ++i) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result.empty() || types[result.back()] != types[i]) { result.push_back(i); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!repeated.empty() &amp;&amp; types[repeated.front()] != types[result.back()]) { result.push_back(repeated.front()); repeated.pop(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { repeated.push(i); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; }</code> </pre> <br><h2>  D. Klasterisasi urutan karakter </h2><div class="scrollable-table"><table><tbody><tr><td></td><td>  <b>Semua bahasa</b> </td><td>  <b>python2.7 + numpy</b> </td><td>  <b>python3.5 + numpy</b> </td></tr><tr><td>  Batas waktu </td><td>  1 s </td><td>  6 s </td><td>  6 s </td></tr><tr><td>  Batas memori </td><td>  64 MB </td><td>  64 MB </td><td>  64 MB </td></tr><tr><td>  Masuk </td><td colspan="3">  input standar atau input.txt </td></tr><tr><td>  Kesimpulan </td><td colspan="3">  output standar atau output.txt </td></tr></tbody></table></div>  Ada alfabet terbatas A = {a <sub>1</sub> , a <sub>2</sub> , ..., a <sub>K - 1</sub> , a <sub>K</sub> = S}, a <sub>i</sub> ∈ {a, b, ..., z}, S adalah akhir dari baris. <br><br>  Pertimbangkan metode berikut untuk menghasilkan string acak di atas alfabet A: <br><br>  1. Karakter pertama x <sub>1</sub> adalah variabel acak dengan distribusi P (x <sub>1</sub> = a <sub>i</sub> ) = q <sub>i</sub> (diketahui bahwa q <sub>K</sub> = 0). <br>  2. Setiap karakter berikutnya dihasilkan berdasarkan yang sebelumnya sesuai dengan distribusi kondisional P (x <sub>i</sub> = a <sub>j</sub> | | x <sub>i - 1</sub> = a <sub>l</sub> ) = p <sub>jl</sub> . <br>  3. Jika x <sub>i</sub> = S, generasi berhenti dan hasilnya x <sub>1</sub> x <sub>2</sub> ... x <sub>i - 1</sub> . <br><br>  Himpunan garis yang dihasilkan dari campuran dua model yang dijelaskan dengan parameter yang berbeda diberikan.  Adalah perlu untuk setiap baris untuk memberikan indeks rantai dari mana ia dihasilkan. <br><br><div class="spoiler">  <b class="spoiler_title">Format, Contoh, dan Catatan I / O</b> <div class="spoiler_text"><h4>  Format input </h4><br>  Baris pertama berisi dua angka 1000 ≤ N ≤ 2000 dan 3 ≤ K ≤ 27 - jumlah garis dan ukuran alfabet, masing-masing. <br><br>  Baris kedua berisi baris yang terdiri dari K - 1 huruf kecil berbeda dari alfabet Latin, yang menunjukkan elemen K - 1 pertama dari alfabet. <br><br>  Setiap baris N berikut dihasilkan sesuai dengan algoritma yang dijelaskan dalam kondisi. <br><br><h4>  Format output </h4><br>  N baris, baris ke-i berisi nomor cluster (0/1) untuk urutan pada baris ke-1 dari file input.  Kebetulan dengan jawaban yang benar minimal harus 80%. <br><br><h4>  Contoh </h4><div class="scrollable-table"><table><tbody><tr><td>  <b>Masuk</b> </td><td>  <b>Kesimpulan</b> </td></tr><tr><td> <code>100 3 <br> a <br> a <br> aa <br> a <br> aaa <br> a <br> aaaaaa <br> aa <br> a <br> a <br> a <br> aaa <br> a <br> a <br> aaa <br> aa <br> aaaa <br> aaa <br> a <br> aaaaa <br> aa <br> a <br> aaaa <br> a <br> a <br> a <br> a <br> a <br> a <br> aa <br> aaaa <br> aaa <br> a <br> aa <br> aaaa <br> a <br> a <br> a <br> a <br> a <br> a <br> a <br> a <br> a <br> a <br> aa <br> aaa <br> aaa <br> a <br> a <br> bbb <br> bb <br> bb <br> bbbbbbb <br> bb <br> bbb <br> b <br> bbbbbbb <br> bbbb <br> bbb <br> bb <br> bbb <br> bb <br> bb <br> bbb <br> bbbbbb <br> bbb <br> b <br> bbbbbb <br> b <br> bbbbb <br> b <br> b <br> bb <br> b <br> bb <br> bb <br> b <br> b <br> b <br> b <br> bb <br> bb <br> bb <br> b <br> b <br> b <br> bb <br> b <br> bbb <br> bb <br> b <br> bbbbbb <br> b <br> bb <br> bb <br> bb <br> b <br> bb <br> bbb</code> </td> <td> <code>0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 0 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1 <br> 1</code> </td> </tr></tbody></table></div><h4>  Catatan </h4><br>  Catatan untuk pengujian dari kondisi: di dalamnya 50 baris pertama dihasilkan dari distribusi <br>  P (x <sub>i</sub> = a | x <sub>i - 1</sub> = a) = 0,5, P (x <sub>i</sub> = S | x <sub>i - 1</sub> = a) = 0,5, P (x <sub>1</sub> = a) = 1;  50 detik - dari distribusi <br>  P (x <sub>i</sub> = b | x <sub>i - 1</sub> = b) = 0,5, P (x <sub>i</sub> = S | x <sub>i - 1</sub> = b) = 0,5, P (x <sub>1</sub> = b) = 1. </div></div><br><h4>  Solusi </h4><br>  Masalah diselesaikan dengan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma EM</a> : diasumsikan bahwa sampel yang disajikan dihasilkan dari campuran dua rantai Markov yang parameternya dipulihkan selama iterasi.  Pembatasan 80% dari jawaban yang benar dibuat sehingga kebenaran solusi tidak terpengaruh oleh contoh-contoh yang memiliki probabilitas tinggi di kedua rantai.  Contoh-contoh ini, oleh karena itu, ketika dipulihkan dengan benar, dapat ditugaskan ke rantai yang tidak benar dalam hal respons yang dihasilkan. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> math EPS = <span class="hljs-number"><span class="hljs-number">1e-9</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty_row</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(size)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [<span class="hljs-number"><span class="hljs-number">0</span></span>] * size <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty_matrix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rows, cols)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [empty_row(cols) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(rows)] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">normalized_row</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(row)</span></span></span><span class="hljs-function">:</span></span> row_sum = sum(row) + EPS <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [x / row_sum <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> row] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">normalized_matrix</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mtx)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [normalized_row(r) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> r <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> mtx] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">restore_params</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(alphabet, string_samples)</span></span></span><span class="hljs-function">:</span></span> n_tokens = len(alphabet) n_samples = len(string_samples) samples = [tuple([alphabet.index(token) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> token <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> s] + [n_tokens - <span class="hljs-number"><span class="hljs-number">1</span></span>, n_tokens - <span class="hljs-number"><span class="hljs-number">1</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> s <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> string_samples] probs = [random.random() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(n_samples)] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">200</span></span>): old_probs = [x <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> probs] <span class="hljs-comment"><span class="hljs-comment"># probs fixed p0, A = empty_row(n_tokens), empty_matrix(n_tokens, n_tokens) q0, B = empty_row(n_tokens), empty_matrix(n_tokens, n_tokens) for prob, sample in zip(probs, samples): p0[sample[0]] += prob q0[sample[0]] += 1 - prob for t1, t2 in zip(sample[:-1], sample[1:]): A[t1][t2] += prob B[t1][t2] += 1 - prob A, p0 = normalized_matrix(A), normalized_row(p0) B, q0 = normalized_matrix(B), normalized_row(q0) trans_log_diff = [ [math.log(b + EPS) - math.log(a + EPS) for b, a in zip(B_r, A_r)] for B_r, A_r in zip(B, A) ] # A, p0, B, q0 fixed probs = empty_row(n_samples) for i, sample in enumerate(samples): value = math.log(q0[sample[0]] + EPS) - math.log(p0[sample[0]] + EPS) for t1, t2 in zip(sample[:-1], sample[1:]): value += trans_log_diff[t1][t2] probs[i] = 1.0 / (1.0 + math.exp(value)) if max(abs(x - y) for x, y in zip(probs, old_probs)) &lt; 1e-9: break return [int(x &gt; 0.5) for x in probs] def main(): N, K = list(map(int, input().split())) string_samples = [] alphabet = list(input().strip()) + [''] for _ in range(N): string_samples.append(input().rstrip()) result = restore_params(alphabet, string_samples) for r in result: print(r) if __name__ == '__main__': main()</span></span></code> </pre> <br><hr><br>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461273/">https://habr.com/ru/post/id461273/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461261/index.html">Daftar periksa webinar RRC yang bermanfaat untuk produk RRC</a></li>
<li><a href="../id461265/index.html">Tentang penyalahgunaan penggunaan sistem operasi dalam proyek untuk mikrokontroler</a></li>
<li><a href="../id461267/index.html">Teknologi Intel Baru untuk Kemasan Chip</a></li>
<li><a href="../id461269/index.html">Solusi pekerjaan dengan pwnable.kr 08 adalah leg dan 10 adalah shellshock. Assembler ARM. Kerentanan Bash</a></li>
<li><a href="../id461271/index.html">Cara mempromosikan aplikasi seluler pada 2019: 4 cara praktis + alat yang bermanfaat</a></li>
<li><a href="../id461277/index.html">Ikhtisar alat SQLIndexManager gratis</a></li>
<li><a href="../id461279/index.html">Cara membuat microservice sederhana di Golang dan gRPC dan kemas menggunakan Docker</a></li>
<li><a href="../id461281/index.html">Panduan untuk menyiapkan server BIND DNS di lingkungan chroot untuk Red Hat (RHEL / CentOS) 7</a></li>
<li><a href="../id461283/index.html">Arsitektur Perangkat Lunak dan Desain Sistem: Gambaran Besar dan Panduan Sumber Daya</a></li>
<li><a href="../id461285/index.html">5 algoritma pengambilan sampel utama</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>