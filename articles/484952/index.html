<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😪 🌈 🚹 Sustitución de Redux con observables y ganchos de reacción 💼 🌘 📼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La gestión del estado es una de las tareas más importantes resueltas en el desarrollo de React. Se han creado muchas herramientas para ayudar a los de...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sustitución de Redux con observables y ganchos de reacción</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484952/"><p><img align="right" src="https://habrastorage.org/webt/fo/2d/t7/fo2dt7_8xrgtb3goulj7cwpxrpg.png">  La gestión del estado es una de las tareas más importantes resueltas en el desarrollo de React.  Se han creado muchas herramientas para ayudar a los desarrolladores a resolver este problema.  La herramienta más popular es Redux, una pequeña biblioteca creada por Dan Abramov para ayudar a los desarrolladores a usar el patrón de diseño Flux en sus aplicaciones.  En este artículo, analizaremos si realmente necesitamos Redux y veremos cómo podemos reemplazarlo con un enfoque más simple basado en Ganchos Observables y React. </p><a name="habracut"></a><br><h1 id="zachem-nam-voobsche-nuzhen-redux">  ¿Por qué necesitamos Redux? </h1><br><p> Redux se asocia tan a menudo con React que muchos desarrolladores lo usan sin pensar por qué necesitan Redux.  React facilita la sincronización de un componente y su estado con <code>setState()</code> / <code>useState()</code> .  Pero todo se vuelve más complicado tan pronto como el estado comienza a ser utilizado por varios componentes a la vez.  La solución más obvia para compartir un estado común entre varios componentes es moverlo (estado) a su padre común.  Pero tal solución "frontal" puede conducir rápidamente a dificultades: si los componentes están lejos unos de otros en la jerarquía de componentes, la actualización del estado general requerirá mucho desplazamiento a través de las propiedades de los componentes.  Reaccionar contexto puede ayudar a reducir la cantidad de derrames, pero declarar un nuevo contexto cada vez que un estado comienza a usarse junto con otro componente requerirá más esfuerzo y, en última instancia, puede conducir a errores. </p><br><p>  Redux resuelve estos problemas al introducir un objeto <code>Store</code> que contiene todo el estado de la aplicación.  En los componentes que requieren acceso al estado, esta <code>Store</code> se implementa mediante la función de <code>connect</code> .  Esta función también asegura que cuando un estado cambia, todos los componentes que dependen de él serán redibujados.  Finalmente, para cambiar el estado, los componentes deben enviar acciones que activen el reductor para calcular el nuevo estado modificado. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/b6f/531/9dc/b6f5319dc6eb751b9a18482cb7863f8d.gif"><br><p>  <em>Cuando entendí por primera vez los conceptos de Redux</em> </p><br><h1 id="chto-ne-tak-s-redux">  ¿Qué le pasa a Redux? </h1><br><p>  La primera vez que leí el <a href="https://redux.js.org/basics/basic-tutorial/" rel="nofollow">tutorial</a> oficial de <a href="https://redux.js.org/basics/basic-tutorial/" rel="nofollow">Redux</a> , me sorprendió la gran cantidad de código que tenía que escribir para cambiar de estado.  Cambiar el estado requiere declarar una nueva acción, implementar el reductor correspondiente y finalmente enviar la acción.  Redux también alienta la <a href="https://redux.js.org/basics/actions/" rel="nofollow">escritura de un creador de acciones</a> para facilitar la creación de una acción cada vez que desee enviarla. </p><br><p>  Con todos estos pasos, Redux complica la comprensión del código, la refactorización y la depuración.  Al leer el código escrito por otra persona, a menudo es difícil darse cuenta de lo que sucede cuando se presenta la acción.  Primero, tendremos que sumergirnos en el código del creador de la acción para encontrar el tipo de acción apropiado, y luego encontrar los reductores que manejan este tipo de acción.  Las cosas pueden volverse aún más complicadas si se usan algunos middlewares, como redux-saga, que hace que el contexto de la solución sea aún más implícito. </p><br><p>  Y finalmente, cuando se usa TypeScript, Redux puede ser decepcionante.  Por diseño, las acciones son simplemente cadenas asociadas con parámetros adicionales.  Hay formas de escribir código Redux bien tipeado usando TypeScript, pero puede ser muy tedioso y nuevamente puede conducir a un aumento en la cantidad de código que tenemos que escribir. </p><br><img src="https://habrastorage.org/getpro/habr/post_images/b0e/9ff/261/b0e9ff26168370d91b5433ad8b1ae4fe.gif"><br><p>  <em>La emoción de aprender código escrito con Redux</em> </p><br><h1 id="observable-i-hook-prostoy-podhod-k-upravleniyu-sostoyaniem">  Observable y hook: un enfoque simple para administrar el estado. </h1><br><h3 id="zamenyaem-store-c-pomoschyu-observable">  Reemplazar tienda con observable </h3><br><p>  Para resolver el problema de compartir el estado de una manera más simple, primero necesitamos encontrar una manera de notificar a los componentes cuando otros componentes cambian su estado general.  Para hacer esto, <code>Observable</code> una clase <code>Observable</code> que contenga un solo valor y que permita a los componentes suscribirse a los cambios en este valor.  El método de suscripción devolverá la función que debe llamarse para darse de baja del <code>Observable</code> . </p><br><p>  En TypeScript, implementar tal clase es bastante simple: </p><br><pre> <code class="javascript hljs">type Listener&lt;T&gt; = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val: T</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; type Unsubscriber = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Observable</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ private _listeners: Listener&lt;T&gt;[]; <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(private _val: T) {} get(): T { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val; } set(val: T) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val !== val) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._val = val; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._listeners.forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">l</span></span></span><span class="hljs-function"> =&gt;</span></span> l(val)); } } subscribe(listener: Listener&lt;T&gt;): Unsubscriber { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._listeners.push(listener); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._listeners = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._listeners.filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">l</span></span></span><span class="hljs-function"> =&gt;</span></span> l !== listener); }; } }</code> </pre> <br><p>  Si compara esta clase con Redux <code>Store</code> , verá que son bastante similares: <code>get()</code> corresponde a <code>getState()</code> , y <code>subscribe()</code> es lo mismo.  La principal diferencia es el método <code>dispatch()</code> , que ha sido reemplazado por el método <code>set()</code> más simple, que le permite cambiar el valor contenido en él sin tener que depender del reductor.  Otra diferencia significativa es que, en contraste con Redux, usaremos muchos <code>Observable</code> lugar de una sola <code>Store</code> contenga todo el estado. </p><br><h3 id="zamenyaem-reducer-servisami">  Reemplazar servicios reductores </h3><br><p>  Ahora <code>Observable</code> se puede usar para almacenar el estado general, pero aún necesitamos mover la lógica contenida en el reductor.  Para esto utilizamos el concepto de servicios.  Los servicios son clases que implementan toda la lógica de negocios de nuestras aplicaciones.  Intentemos reescribir el reductor <code>Todo</code> del tutorial de Redux al servicio <code>Todo</code> usando <code>Observable</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Observable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./observable"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> interface Todo { readonly text: string; readonly completed: boolean; } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> enum VisibilityFilter { SHOW_ALL, SHOW_COMPLETED, SHOW_ACTIVE, } <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TodoService</span></span></span><span class="hljs-class"> </span></span>{ readonly todos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Observable&lt;Todo[]&gt;<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[]</span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">readonly</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">visibilityFilter</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">new</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Observable</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">VisibilityFilter.SHOW_ALL</span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">addTodo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text: string</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">this</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">todos</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">set</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">[...</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.todos.get(</span></span></span><span class="hljs-function">), { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">text</span></span></span><span class="hljs-function">, </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">completed</span></span></span><span class="hljs-function">: </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">false</span></span></span><span class="hljs-function"> }]); } </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">toggleTodo</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">index: number</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">this</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">todos</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">set</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.todos.get(</span></span></span><span class="hljs-function">).</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">map</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> (todo, i</span></span></span><span class="hljs-function">) =&gt;</span></span> (i === index ? { <span class="hljs-attr"><span class="hljs-attr">text</span></span>: todo.text, <span class="hljs-attr"><span class="hljs-attr">completed</span></span>: !todo.completed } : todo) )); } setVisibilityFilter(filter: VisibilityFilter) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.visibilityFilter.set(filter); } }</code> </pre> <br><p>  Comparando esto con el reductor <code>Todo</code> , podemos notar las siguientes diferencias: </p><br><ul><li>  Las acciones fueron reemplazadas por métodos, eliminando la necesidad de declarar un tipo de acción, la acción misma y el creador de la acción. </li><li>  Ya no necesita escribir un interruptor grande para enrutar entre el tipo de acción.  El despacho dinámico de Javascript (es decir, llamadas a métodos) se encarga de esto. </li><li>  Y lo más importante, el servicio contiene y cambia el estado que administra.  Esta es una gran diferencia conceptual de los reductores, que son funciones puras. </li></ul><br><h2 id="dostup-k-servisam-i-observable-iz-komponentov">  Acceso a servicios y observable desde componentes. </h2><br><p>  Ahora que hemos reemplazado "tienda y reductor de Redux" por "Observable y servicios", necesitamos que los servicios estén disponibles en todos los componentes de React.  Hay varias formas de hacer esto: podríamos usar el marco de IoC, por ejemplo, Inversify;  use el contexto React o use el mismo enfoque que en <code>Store</code> Redux: una instancia global para cada servicio.  En este artículo, consideraremos el último enfoque: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { TodoService } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./todoService"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> todoService = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TodoService();</code> </pre> <br><p>  Ahora podemos acceder al estado compartido y cambiarlo desde todos nuestros componentes React importando una instancia de <code>todoService</code> .  Pero aún necesitamos encontrar una manera de volver a dibujar nuestros componentes cuando otro estado cambia el estado general.  Para hacer esto, escribiremos un enlace simple que agregue una variable de estado al componente, se suscriba al <code>Observable</code> y actualice la variable de estado cuando cambie el valor del <code>Observable</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { useEffect, useState } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Observable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./observable"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">useObservable</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">observable: Observable&lt;T&gt;</span></span></span><span class="hljs-function">): </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [val, setVal] = useState(observable.get()); useEffect(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { setVal(observable.get()); <span class="hljs-comment"><span class="hljs-comment">//   @mayorovp return observable.subscribe(setVal); }, [observable]); return val; }</span></span></code> </pre> <br><h1 id="sobiraem-vse-vmeste">  Poniendo todo junto </h1><br><p>  Nuestro kit de herramientas está listo.  Podemos usar <code>Observable</code> para almacenar el estado general en los servicios y usar <code>useObservable</code> para asegurar que los componentes siempre estén sincronizados con este estado. </p><br><p>  Reescribamos el componente TodoList del tutorial de Redux usando el nuevo gancho: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"react"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { useObservable } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./observableHook"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { todoService } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./services"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Todo, VisibilityFilter } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"./todoService"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> TodoList = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> todos = useObservable(todoService.todos); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> filter = useObservable(todoService.visibilityFilter); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> visibleTodos = getVisibleTodos(todos, filter); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;div&gt; &lt;ul&gt; {visibleTodos.map((todo, index</span></span></span><span class="hljs-function">) =&gt;</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">TodoItem</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">key</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{index}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">todo</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{todo}</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">index</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{index}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> ))} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;p&gt; Show: <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">FilterLink</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">filter</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{VisibilityFilter.SHOW_ALL}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">All</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">FilterLink</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>, &lt;FilterLink filter={VisibilityFilter.SHOW_ACTIVE}&gt;Active&lt;<span class="hljs-regexp"><span class="hljs-regexp">/FilterLink&gt;, &lt;FilterLink filter={VisibilityFilter.SHOW_ALL}&gt;Completed&lt;/</span></span>FilterLink&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;<span class="hljs-regexp"><span class="hljs-regexp">/div&gt; ); }; const TodoItem = ({ todo: { text, completed }, index }: { todo: Todo; index: number }) =&gt; { return ( &lt;li style={{ textDecoration: completed ? "line-through" : "none", }} onClick={() =&gt; todoService.toggleTodo(index)} &gt; {text} &lt;/</span></span>li&gt; ); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> FilterLink = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ filter, children }: { filter: VisibilityFilter; children: React.ReactNode }</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> activeFilter = useObservable(todoService.visibilityFilter); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> active = filter === activeFilter; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> active ? <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;span&gt;{children}&lt;</span></span><span class="hljs-regexp"><span class="hljs-function"><span class="hljs-params"><span class="hljs-regexp">/span&gt; ) : ( &lt;a href="" onClick={() =&gt; todoService.setVisibilityFilter(filter)}&gt; {children} &lt;/</span></span></span></span><span class="hljs-function"><span class="hljs-params">a&gt; </span></span></span><span class="hljs-function">); }; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">getVisibleTodos</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">todos: Todo[], filter: VisibilityFilter</span></span></span><span class="hljs-function">): </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Todo</span></span></span><span class="hljs-function">[] { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">switch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">filter</span></span></span><span class="hljs-function">) { </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">case</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">VisibilityFilter</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SHOW_ALL</span></span></span><span class="hljs-function">: </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">return</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">todos</span></span></span><span class="hljs-function">; </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">case</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">VisibilityFilter</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SHOW_COMPLETED</span></span></span><span class="hljs-function">: </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">return</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">todos</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">filter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">t =&gt; t.completed</span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">case</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">VisibilityFilter</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SHOW_ACTIVE</span></span></span><span class="hljs-function">: </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">return</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">todos</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">filter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">t =&gt; !t.completed</span></span></span><span class="hljs-function">); } }</span></span></code> </pre> <br><p>  Como podemos ver, hemos escrito varios componentes que se refieren a valores de estado generales ( <code>todos</code> y <code>visibilityFilter</code> ).  Estos valores simplemente se cambian llamando a métodos desde <code>todoService</code> .  Gracias al hook useObservable, que se suscribe a los cambios de valor, estos componentes se vuelven a dibujar automáticamente cuando cambia el estado general. </p><br><h1 id="vyvod">  Conclusión </h1><br><p>  Si comparamos este código con el enfoque de Redux, veremos varias ventajas: </p><br><ul><li>  <strong>Concisión: lo</strong> único que teníamos que hacer era ajustar los valores de estado en el <code>Observable</code> y usar hook <code>useObservable</code> al acceder a estos valores desde los componentes.  No es necesario declarar acción, creador de acción, escribir o combinar reductor, o conectar nuestros componentes al repositorio con los <code>mapDispatchToProps</code> <code>mapStateToProps</code> y <code>mapDispatchToProps</code> . </li><li>  <strong>Simplicidad:</strong> ahora es mucho más fácil rastrear la ejecución del código.  Comprender qué sucede realmente cuando se presiona un botón es solo cuestión de cambiar a la implementación del método llamado.  La ejecución paso a paso utilizando el depurador también se mejora significativamente, ya que no hay un nivel intermedio entre nuestros componentes y nuestros servicios. </li><li>  <strong>Tipo de seguridad fuera de la caja: los</strong> desarrolladores de TypeScript no necesitarán trabajo adicional para tener el código escrito correctamente.  No es necesario declarar tipos para el estado y para cada acción. </li><li>  <strong>Soporte para async / await:</strong> aunque esto no se ha demostrado aquí, esta solución funciona muy bien con funciones asincrónicas, lo que simplifica enormemente la programación asincrónica.  No es necesario confiar en el middleware, como redux-thunk, que requiere un profundo conocimiento de la programación funcional para comprender. </li></ul><br><p>  Redux, por supuesto, todavía tiene algunas ventajas serias, especialmente Redux DevTools, que permiten a los desarrolladores monitorear los cambios de estado durante el desarrollo y pasar a tiempo a estados de aplicaciones anteriores, lo que puede ser una gran herramienta para la depuración.  Pero en mi experiencia, rara vez usé esto, y el precio a pagar parece demasiado alto para una pequeña ganancia. </p><br><p>  En todas nuestras aplicaciones React y React Native, hemos utilizado con éxito un enfoque similar al descrito en este artículo.  De hecho, nunca sentimos la necesidad de un sistema de gestión estatal más complejo que este. </p><br><h1 id="primechaniya">  Notas </h1><br><p>  La clase <code>Observable</code> presentada en esta publicación es bastante simple.  Se puede reemplazar con implementaciones más avanzadas como micro-observables (nuestra propia biblioteca) o RxJS. </p><br><p>  La solución presentada aquí es muy similar a lo que se puede lograr con MobX.  La principal diferencia es que MobX admite una profunda mutabilidad del estado de los objetos.  También se basa en los proxies ES6 para notificar los cambios, volver a representarlos de forma implícita y complicar la depuración cuando las cosas no funcionan como se esperaba.  Además, MobX no funciona bien con funciones asincrónicas. </p><br><blockquote>  De un traductor: esta publicación, que puede verse como una introducción a la gestión del estado utilizando Observable, es una continuación del tema cubierto en el artículo <a href="https://habr.com/ru/post/483526/">Gestión del estado de la aplicación con RxJS / Immer como una alternativa simple a Redux / MobX</a> , que describe cómo simplificar el uso de este enfoque. </blockquote></div></div><p>Source: <a href="https://habr.com/ru/post/484952/">https://habr.com/ru/post/484952/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../484934/index.html">Desde el desarrollo personal hasta Agile en una escala XXXL en dos días en TeamLead Conf</a></li>
<li><a href="../484936/index.html">Conocimientos y competencias en el equipo: encontrar, ver, bombear</a></li>
<li><a href="../484944/index.html">¿Qué estoy en ACID o no nos conviene?</a></li>
<li><a href="../484946/index.html">Modelado GPR</a></li>
<li><a href="../484948/index.html">NEC lanzó un cable submarino con un récord de 20 pares de fibras ópticas</a></li>
<li><a href="../484954/index.html">Guía visual de solución de problemas para Kubernetes</a></li>
<li><a href="../484964/index.html">Configurar el equilibrio de carga en InfoWatch Traffic Monitor</a></li>
<li><a href="../484966/index.html">Plantilla lista para usar con Spring</a></li>
<li><a href="../484968/index.html">WPF DataGrid. Lucha por la plantilla</a></li>
<li><a href="../484972/index.html">Wine 5.0 lanzado</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>