<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🛀 🥌 👥 Mise en cache Laravel: les bases plus les trucs et astuces 😎 🥩 🏉</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La technique de mise en cache vous permet de créer des applications plus évolutives, en stockant les résultats de certaines requêtes dans un stockage ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Mise en cache Laravel: les bases plus les trucs et astuces</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/463495/"><p>  La technique de mise en cache vous permet de créer des applications plus évolutives, en stockant les résultats de certaines requêtes dans un stockage rapide en mémoire.  Cependant, une mise en cache incorrectement implémentée peut dégrader considérablement l'impression de l'utilisateur sur votre application.  Cet article contient quelques concepts de base sur la mise en cache, diverses règles et tabous que j'ai appris de plusieurs projets antérieurs. </p><br><h2 id="ne-ispolzuyte-keshirovanie">  N'utilisez pas la mise en cache. </h2><br><p>  Votre projet est-il rapide et n'a-t-il aucun problème de performances? <br>  Oubliez la mise en cache.  Sérieusement :) </p><br><p>  Cela compliquera considérablement les opérations de lecture à partir de la base de données sans aucun avantage. </p><br><p>  Certes, Mohamed Said au début de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">cet article</a> fait quelques calculs et prouve que dans certains cas, l'optimisation de l'application en millisecondes peut économiser une tonne d'argent sur votre compte AWS.  Donc, si les économies prévues sur votre projet dépassent 1,86 $, la mise en cache est peut-être une bonne idée. </p><a name="habracut"></a><br><h2 id="kak-eto-rabotaet">  Comment ça marche? </h2><br><p> Lorsqu'une application souhaite obtenir des données de la base de données, par exemple, l'entité Post par son identifiant, elle génère une clé de mise en cache unique pour ce cas ( <code>'post_' . $id</code> est tout à fait appropriée) et essaie de trouver la valeur par cette clé dans le stockage de valeur-clé rapide (memcache, redis, ou autre).  Si la valeur est là, l'application l'utilise.  Sinon, il le prend dans la base de données et le stocke dans le cache par cette clé pour une utilisation future. </p><br><p><img src="https://habrastorage.org/webt/vd/9i/kj/vd9ikjg-gji5lauz1atmq9bkdpq.png"></p><br><p>  Garder cette valeur dans le cache n'est pas une bonne idée pour toujours, car cette entité Post peut être mise à jour, mais l'application recevra toujours l'ancienne valeur mise en cache. <br>  Par conséquent, les fonctions de mise en cache demandent généralement à quelle heure cette valeur doit être stockée. </p><br><p>  Passé ce délai, memcache ou redis «l'oubliera» et l'application prendra une nouvelle valeur dans la base de données. </p><br><p>  Un exemple: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function"> </span></span>{ $key = <span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $id; $post = \Cache::get($key); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($post === <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { $post = Post::findOrFail($id); \Cache::put($key, $post, <span class="hljs-number"><span class="hljs-number">900</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $post; }</code> </pre> <br><p>  Ici, je mets l'entité Post dans le cache pendant 15 minutes (depuis la version 5.8, laravel utilise des secondes dans ce paramètre, avant qu'il y ait des minutes).  La façade <code>Cache</code> a également une méthode de <code>remember</code> pratique pour ce cas.  Ce code fait exactement la même chose que le précédent: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \Cache::remember(<span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $id, <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Post::findOrFail($id); }); }</code> </pre> <br><p>  Il existe un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">chapitre Cache dans la</a> documentation Laravel qui explique comment installer les pilotes nécessaires pour votre application et les fonctionnalités principales. </p><br><h2 id="dannye-v-keshe">  Données mises en cache </h2><br><p>  Tous les pilotes Laravel standard stockent les données sous forme de chaînes.  Lorsque nous vous demandons de mettre en cache une instance du modèle Eloquent, il utilise la fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">sérialiser</a> pour obtenir la chaîne de l'objet.  La fonction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">unserialize</a> restaure l'état d'un objet lorsque nous l'obtenons du cache. </p><br><p>  Presque toutes les données peuvent être mises en cache.  Nombres, chaînes, tableaux, objets (s'ils peuvent être correctement sérialisés, voir les descriptions des fonctions des liens plus tôt). </p><br><p>  Les entités et les collections éloquentes peuvent être facilement mises en cache et sont les valeurs les plus populaires dans le cache d'application Laravel.  Cependant, l'utilisation d'autres types est également pratiquée assez largement.  La méthode <code>Cache::increment</code> est populaire pour implémenter différents compteurs.  En outre, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">les verrous atomiques sont</a> très utiles lorsque les développeurs luttent contre les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">conditions de concurrence</a> . </p><br><h2 id="chto-keshirovat">  Que mettre en cache? </h2><br><p>  Les premiers candidats à la mise en cache sont les requêtes qui sont exécutées très souvent, mais leur plan d'exécution n'est pas le plus simple.  Le meilleur exemple est le top 5 des articles sur la page principale ou les dernières nouvelles.  La mise en cache de ces valeurs peut améliorer considérablement les performances de la page principale. </p><br><p>  Habituellement, la récupération d'entités par id en utilisant <code>Model::find($id)</code> est très rapide, mais si cette table est lourdement chargée avec de nombreuses requêtes de mise à jour, d'insertion et de suppression, la réduction du nombre de requêtes sélectionnées donnera un bon répit à la base de données.  Les entités avec des relations <code>hasMany</code> qui se chargeront à chaque fois sont également de bons candidats pour la mise en cache.  Lorsque j'ai travaillé sur un projet avec plus de 10 millions de visiteurs par jour, nous avons mis en cache presque toutes les demandes sélectionnées. </p><br><h2 id="invalidaciya-kesha">  Invalidation du cache </h2><br><p>  La décomposition des clés après un temps spécifié aide à mettre à jour les données dans le cache, mais cela ne se produit pas immédiatement.  L'utilisateur peut modifier les données, mais pendant un certain temps, il continuera d'en voir l'ancienne version dans l'application.  Le dialogue habituel sur l'un de mes projets passés: </p><br><pre> <code class="plaintext hljs">:   ,     ! : ,  15 ( ,  )...</code> </pre> <br><p>  Ce comportement est très gênant pour les utilisateurs, et la décision évidente de supprimer les anciennes données du cache lorsque nous les avons mises à jour vient rapidement à l'esprit.  Ce processus est appelé invalidité.  Pour des clés simples comme <code>"post_%id%"</code> , l' <code>"post_%id%"</code> pas très difficile. </p><br><p>  Des événements éloquents peuvent aider, ou si votre application génère des événements spéciaux tels que <code>PostPublished</code> ou <code>UserBanned</code> cela peut être encore plus simple.  Exemple avec des événements éloquents.  Vous devez d'abord créer des classes d'événements.  Pour plus de commodité, je vais utiliser une classe abstraite pour eux: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostEvent</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">@var</span></span></span><span class="hljs-comment"> Post */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> $post; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__construct</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Post $post)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;post = $post; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;post; } } <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostSaved</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostEvent</span></span></span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostDeleted</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PostEvent</span></span></span></span>{}</code> </pre> <br><p>  Bien sûr, selon PSR-4, chaque classe doit être dans son propre fichier.  Configurer la classe Post Eloquent (en utilisant la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">documentation</a> ): </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Post</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Model</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $dispatchesEvents = [ <span class="hljs-string"><span class="hljs-string">'saved'</span></span> =&gt; PostSaved::class, <span class="hljs-string"><span class="hljs-string">'deleted'</span></span> =&gt; PostDeleted::class, ]; }</code> </pre> <br><p>  Créez un écouteur pour ces événements: </p><br><pre> <code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">EventServiceProvider</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ServiceProvider</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> $listen = [ PostSaved::class =&gt; [ ClearPostCache::class, ], PostDeleted::class =&gt; [ ClearPostCache::class, ], ]; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ClearPostCache</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PostEvent $event)</span></span></span><span class="hljs-function"> </span></span>{ \Cache::forget(<span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $event-&gt;getPost()-&gt;id); } }</code> </pre> <br><p>  Ce code supprimera les valeurs mises en cache après chaque mise à jour ou suppression d'entités Post.  L'invalidation des listes d'entités, comme les 5 premiers articles ou les dernières nouvelles, sera un peu plus compliquée.  J'ai vu trois stratégies: </p><br><h3 id="strategiya-ne-invalidiruem">  Ne pas désactiver la stratégie </h3><br><p>  Ne touchez tout simplement pas à ces valeurs.  Habituellement, cela ne pose aucun problème.  Il est normal que les nouvelles nouvelles apparaissent dans la liste de ces dernières un peu plus tard (bien sûr, s'il ne s'agit pas d'un grand portail d'actualités).  Mais pour certains projets, il est vraiment important d'avoir de nouvelles données dans ces listes. </p><br><h3 id="strategiya-nayti-i-obezvredit">  Trouver et désamorcer la stratégie </h3><br><p>  Chaque fois que vous mettez à jour une publication, vous pouvez essayer de la trouver dans les listes mises en cache et si elle s'y trouve, supprimez cette valeur mise en cache. </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getTopPosts</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \Cache::remember(<span class="hljs-string"><span class="hljs-string">'top_posts'</span></span>, <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Post::<span class="hljs-comment"><span class="hljs-comment">/*   top-5*/</span></span>()-&gt;get(); }); } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CheckAndClearTopPostsCache</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(PostEvent $event)</span></span></span><span class="hljs-function"> </span></span>{ $updatedPost = $event-&gt;getPost(); $posts = \Cache::get(<span class="hljs-string"><span class="hljs-string">'top_posts'</span></span>, []); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($posts <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> $post) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>($updatedPost-&gt;id == $post-&gt;id) { \Cache::forget(<span class="hljs-string"><span class="hljs-string">'top_posts'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } } } }</code> </pre> <br><p>  Ça a l'air moche, mais ça marche. </p><br><h3 id="strategiya-hranit-id">  Stratégie "identifiant de magasin" </h3><br><p>  Si l'ordre des éléments de la liste est sans importance, seul l'identifiant des entrées peut être stocké dans le cache.  Après avoir reçu l'id, vous pouvez créer une liste de clés de la forme <code>'post_'.$id</code> et obtenir toutes les valeurs en utilisant la méthode <code>Cache::many</code> , qui obtient beaucoup de valeurs du cache en une seule demande (cela est aussi appelé multi get). </p><br><p>  L'invalidation du cache n'est pas en vain appelée l'une des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">deux difficultés de programmation</a> et est très difficile dans certains cas. </p><br><h2 id="keshirovanie-otnosheniy">  Mise en cache des relations </h2><br><p>  La mise en cache d'entités avec des relations nécessite une attention accrue. </p><br><pre> <code class="php hljs">$post = Post::findOrFail($id); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($post-&gt;comments...)</code> </pre> <br><p>  Ce code effectue deux requêtes <code>SELECT</code> .  Obtention de l'entité par <code>id</code> et des commentaires par <code>post_id</code> .  Nous implémentons la mise en cache: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \Cache::remember(<span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $id, <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Post::findOrFail($id); }); } $post = getPost($id); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($post-&gt;comments...)</code> </pre> <br><p>  La première demande a été mise en cache et la seconde ne l'a pas été.  Lorsque le pilote de cache écrit Post dans le cache, les <code>comments</code> ne sont pas encore chargés.  Si nous voulons aussi les mettre en cache, nous devons les charger manuellement: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPost</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \Cache::remember(<span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $id, <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function"> </span></span>{ $post = Post::findOrFail($id); $post-&gt;load(<span class="hljs-string"><span class="hljs-string">'comments'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $post; }); }</code> </pre> <br><p>  Les deux requêtes sont maintenant mises en cache, mais nous devons invalider les valeurs de <code>'post_'.$id</code> chaque fois qu'un commentaire est ajouté.  Ce n'est pas très efficace, il est donc préférable de stocker le cache de commentaires séparément: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getPostComments</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Post $post)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> \Cache::remember(<span class="hljs-string"><span class="hljs-string">'post_comments_'</span></span> . $post-&gt;id, <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($post)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $post-&gt;comments; }); } $post = getPost($id); $comments = getPostComments($post); <span class="hljs-keyword"><span class="hljs-keyword">foreach</span></span>($comments...)</code> </pre> <br><p>  Parfois, l'essence et l'attitude sont fortement liées les unes aux autres et sont toujours utilisées ensemble (ordre avec détails, publication avec traduction dans la langue souhaitée).  Dans ce cas, les stocker dans un cache est tout à fait normal. </p><br><h2 id="single-source-of-truth-dlya-klyuchey-keshirovaniya">  Source unique de vérité pour les clés de cache </h2><br><p>  Si le projet implémente l'invalidation, les clés de cache sont générées à au moins deux endroits: pour appeler <code>Cache::get</code> / <code>Cache::remember</code> et pour appeler <code>Cache::forget</code> .  J'ai déjà rencontré des situations où cette clé a été changée à un endroit, mais pas à un autre, et le handicap a éclaté.  Le conseil habituel pour de tels cas est les constantes, mais les clés de cache sont générées dynamiquement, donc j'utilise des classes spéciales qui génèrent des clés: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CacheKeys</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postById</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($postId)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'post_'</span></span> . $postId; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">postComments</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($postId)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'post_comments'</span></span> . $postId; } } \Cache::remember(CacheKeys::postById($id), <span class="hljs-number"><span class="hljs-number">900</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">use</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($id)</span></span></span><span class="hljs-function"> </span></span>{ $post = Post::findOrFail($id); }); <span class="hljs-comment"><span class="hljs-comment">// .... \Cache::forget(CacheKeys::postById($id));</span></span></code> </pre> <br><p>  Les durées de vie clés peuvent également être rendues en constantes pour une meilleure lisibilité.  Ces 900 ou 15 * 60 augmentent la charge cognitive lors de la lecture du code. </p><br><h2 id="ne-ispolzuyte-kesh-v-operaciyah-zapisi">  N'utilisez pas le cache dans les opérations d'écriture </h2><br><p>  Lors de la mise en œuvre d'opérations d'écriture, telles que la modification du titre ou du texte d'une publication, il est tentant d'utiliser la méthode <code>getPost</code> écrite précédemment: </p><br><pre> <code class="php hljs">$post = getPost($id); $post-&gt;title = $newTitle; $post-&gt;save();</code> </pre> <br><p>  Veuillez ne pas le faire.  La valeur dans le cache peut être obsolète, même si l'invalidation est effectuée correctement.  Une petite condition de concurrence critique et la publication perdront les modifications apportées par un autre utilisateur.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Les verrous optimistes</a> aideront au moins à ne pas perdre les modifications, mais le nombre de demandes erronées peut considérablement augmenter. </p><br><p>  La meilleure solution consiste à utiliser une logique de sélection d'entité complètement différente pour les opérations de lecture et d'écriture (bonjour, CQRS).  Dans les opérations d'écriture, vous devez toujours sélectionner la dernière valeur dans la base de données.  Et n'oubliez pas les verrous (optimistes ou pessimistes) pour les données importantes. </p><br><p>  Je pense que cela suffit pour un article d'introduction.  La mise en cache est un sujet très complexe et long, avec des pièges pour les développeurs, mais le gain de performances l'emporte parfois sur toutes les difficultés. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr463495/">https://habr.com/ru/post/fr463495/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr463481/index.html">Mathématiques discrètes pour WMS: algorithme de compression des marchandises dans les cellules (partie 1)</a></li>
<li><a href="../fr463483/index.html">Collaboration sur les documents, chat d'entreprise mis à jour et application mobile: Nouveautés de Zextras Suite 3.0</a></li>
<li><a href="../fr463489/index.html">Heavy metal lied: en fait, la musique heavy a un effet positif sur la santé de ses fans</a></li>
<li><a href="../fr463491/index.html">L'histoire de traduction anglaise bizarre de Metal Gear Solid</a></li>
<li><a href="../fr463493/index.html">Plus de statistiques sur le site dans votre petit référentiel</a></li>
<li><a href="../fr463497/index.html">Calculateur d'efficacité des stocks et 5 raisons pour lesquelles les choses tournent mal</a></li>
<li><a href="../fr463499/index.html">Bureau confortable - aide au travail ou interfère et distrait? Sidenis, Alternativa Games et FunBox répondront</a></li>
<li><a href="../fr463503/index.html">Pourquoi le développement web moderne est-il si compliqué? Partie 1</a></li>
<li><a href="../fr463505/index.html">Pourquoi les administrateurs système devraient devenir des ingénieurs DevOps</a></li>
<li><a href="../fr463507/index.html">Les reins sont la sortie</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>