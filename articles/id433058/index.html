<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘©ğŸ½â€ğŸ”¬ ğŸ™ŒğŸ¾ ğŸ¦ Quintet sebagai entitas dasar untuk menggambarkan area subjek ğŸ‘ŠğŸ½ ğŸš£ğŸ» â¬œï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kuintet adalah cara untuk merekam potongan atom data yang menunjukkan perannya dalam kehidupan kita. Kuintet dapat menggambarkan data apa pun, sementa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Quintet sebagai entitas dasar untuk menggambarkan area subjek</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/neoflex/blog/433058/"> Kuintet adalah cara untuk merekam potongan atom data yang menunjukkan perannya dalam kehidupan kita.  Kuintet dapat menggambarkan data apa pun, sementara masing-masing berisi informasi lengkap tentang diri Anda dan tentang hubungan dengan kuintet lain.  Ini mewakili istilah domain, terlepas dari platform yang digunakan.  Tugasnya adalah menyederhanakan penyimpanan data dan meningkatkan visibilitas presentasi. <br><br><img src="https://habrastorage.org/webt/tq/ix/qi/tqixqibywmbwflel0_eiqh6iuji.png"><br><br>  Saya akan berbicara tentang pendekatan baru untuk menyimpan dan memproses informasi dan berbagi pemikiran saya tentang menciptakan platform pengembangan dalam paradigma baru ini. <br><a name="habracut"></a><br>  Kuintet memiliki properti: tipe, nilai, orangtua, urutan antar saudara.  Dengan pengenal, hanya 5 komponen yang diperoleh.  Ini adalah bentuk perekaman informasi universal yang paling sederhana, standar baru yang berpotensi cocok untuk semua orang.  Quintet disimpan dalam sistem file dari struktur tunggal, dalam bidang informasi yang diindeks secara monoton terus menerus. <br><br>  Untuk mencatat informasi, ada sejumlah standar, pendekatan dan aturan, yang pengetahuannya diperlukan untuk bekerja dengan catatan-catatan ini.  Standar dijelaskan secara terpisah dan tidak secara langsung berhubungan dengan data.  Dalam kasus kuintet, dengan mengambil salah satu dari itu, Anda dapat memperoleh informasi yang relevan tentang sifat, sifat, dan aturan bekerja dengan bidang subjeknya.  Standarnya seragam dan tidak berubah untuk semua area.  Kuintet disembunyikan dari pengguna - metadata dan data tersedia baginya dalam bentuk yang umum bagi banyak orang. <br><br>  Kuintet bukan hanya informasi, tetapi juga perintah yang dapat dieksekusi.  Namun yang terpenting, itu adalah data yang Anda ingin simpan, rekam, dan ambil.  Karena dalam kasus kami mereka langsung ditangani, terhubung dan diindeks, kami akan menyimpannya dalam semacam database.  Untuk menguji prototipe sistem penyimpanan data kuintet, misalnya, kami menggunakan database relasional biasa. <br><br><h3>  Struktur kuintet </h3><br>  Ide utama artikel ini adalah mengganti tipe mesin dengan istilah manusia dan mengganti variabel dengan objek.  Bukan oleh objek yang memerlukan konstruktor, destruktor, antarmuka, dan pengumpul sampah, tetapi oleh unit informasi kristal murni yang dioperasikan oleh pelanggan.  Artinya, jika pelanggan mengatakan "Aplikasi", maka untuk menyimpan <b>esensi</b> informasi ini di media tidak akan membutuhkan keahlian seorang programmer. <br><br><img src="https://habrastorage.org/webt/1y/4s/dl/1y4sdlgryleh8rgcrs-zi_cgmb4.png"><br><br>  Berguna untuk memusatkan perhatian pengguna hanya pada nilai objek, dan jenisnya, induknya, urutan (di antara yang sederajat dalam subordinasi) dan pengidentifikasi harus jelas dari konteks atau hanya disembunyikan.  Ini berarti bahwa <b>pengguna sama sekali tidak tahu tentang kuintet</b> , ia hanya menetapkan tugasnya, memastikan bahwa itu diterima dengan benar, dan kemudian memulai pelaksanaannya. <br><br><h3>  Konsep dasar </h3><br>  Ada satu set tipe data yang dapat dipahami siapa saja: string, angka, file, teks, tanggal, dan sebagainya.  Set sederhana seperti itu cukup memadai untuk merumuskan masalah, dan untuk "pemrograman" itu dan jenis yang diperlukan untuk implementasinya.  Tipe dasar yang diwakili oleh kuintet mungkin terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/xy/qp/pp/xyqpppk9ygxh0wlhnfqxfziu0re.png"><br><br>  Dalam hal ini, beberapa komponen kuintet tidak digunakan, dan ia digunakan sebagai tipe dasar.  Ini membuat inti sistem lebih mudah dinavigasi saat bernavigasi di metadata. <br><br><h3>  Latar belakang </h3><br>  Karena kesenjangan analitis antara pengguna dan pemrogram, deformasi konsep yang signifikan terjadi pada tahap pengaturan masalah.  Sikap meremehkan, tidak bisa dipahami, dan inisiatif yang tidak diminta sering mengubah pemikiran pelanggan yang sederhana dan mudah dipahami menjadi campuran yang mustahil secara logis, dilihat dari sudut pandang pengguna. <br><br><img src="https://habrastorage.org/webt/z9/3e/z0/z93ez0yknc8fwiqdamwzcsfqwvg.png"><br><br>  Transfer pengetahuan harus terjadi tanpa kehilangan atau distorsi.  Selain itu, di masa depan, ketika mengatur penyimpanan pengetahuan ini, perlu untuk menyingkirkan pembatasan yang diberlakukan oleh sistem manajemen data yang dipilih. <br><br><h3>  Cara menyimpan data </h3><br>  Sebagai aturan, ada banyak database di server, masing-masing berisi deskripsi struktur entitas dengan set atribut tertentu - data yang saling berhubungan.  Mereka disimpan dalam urutan tertentu, idealnya optimal untuk pengambilan sampel. <br>  Sistem penyimpanan informasi yang diusulkan adalah kompromi antara berbagai metode terkenal: kolom, string dan NoSQL.  Ini dirancang untuk menyelesaikan tugas-tugas yang biasanya dilakukan oleh salah satu metode ini. <br><br>  Sebagai contoh, teori dasar kolom terlihat indah: kita hanya membaca kolom yang diinginkan, dan tidak semua baris catatan secara keseluruhan.  Namun, dalam praktiknya, kecil kemungkinannya bahwa data akan ditempatkan di media sehingga dapat diterapkan ke berbagai bagian analisis.  Perhatikan bahwa atribut dan metrik analitik dapat ditambahkan dan dihapus, terkadang lebih cepat daripada kita dapat membangun kembali ekonomi kolom ini.  Belum lagi fakta bahwa data dalam database dapat disesuaikan, yang juga akan melanggar keindahan rencana pengambilan sampel karena fragmentasi yang tak terhindarkan. <br><br><h3>  Metadata </h3><br>  Kami memperkenalkan konsep - istilah - untuk menggambarkan objek yang kami operasikan: entitas, properti, permintaan, file, dll.  Kami akan mendefinisikan semua istilah yang kami gunakan di area subjek kami.  Dan dengan bantuan mereka, kami akan menggambarkan semua entitas yang memiliki perincian, termasuk dalam bentuk hubungan antar entitas.  Misalnya, alat peraga - tautan ke entri direktori status.  Istilah ini ditulis dalam kuintet data. <br><br>  Seperangkat uraian istilah adalah metadata yang mendefinisikan struktur tabel dan bidang dalam database biasa.  Misalnya, ada struktur data berikut: aplikasi dari tanggal yang memiliki konten (teks aplikasi) dan Status, di mana peserta dalam proses produksi menambahkan komentar yang menunjukkan tanggal.  Dalam konstruktor database tradisional, akan terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/0x/u0/3x/0xu03xuszqkcjzjk1rzqedxrqae.png"><br><br>  Karena kami memutuskan untuk menyembunyikan dari pengguna semua detail yang tidak penting, seperti ID yang mengikat, misalnya, skema akan agak disederhanakan: menyebutkan ID dihapus dan nama entitas dan nilai-nilai kunci mereka digabungkan. <br><br>  Pengguna "menggambar" tugas: permintaan dari tanggal hari ini yang memiliki status (nilai referensi) dan Anda dapat menambahkan komentar yang menunjukkan tanggal: <br><br><img src="https://habrastorage.org/webt/3f/ct/hl/3fcthlz1taoildnzxcyqorn9lse.png"><br><br>  Sekarang kita melihat 6 bidang data yang berbeda, bukan 9, dan keseluruhan skema menawarkan kita untuk membaca dan memahami 7 kata, bukannya 13. Meskipun ini jauh dari hal utama, tentu saja. <br><br>  Berikut adalah kuintet yang dihasilkan oleh inti kontrol untuk menggambarkan struktur ini: <br><br><img src="https://habrastorage.org/webt/vu/k_/st/vuk_stt4ztzengtk4ui3tepy-hg.png"><br><br>  Penjelasan menggantikan nilai kuintet yang disorot dalam warna abu-abu disediakan untuk kejelasan.  Bidang-bidang ini tidak diisi karena semua informasi yang diperlukan ditentukan secara unik oleh komponen yang tersisa. <br><br><div class="spoiler">  <b class="spoiler_title">Lihat bagaimana kuintet terkait</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/rd/rg/n5/rdrgn5ojnjwsji9ozjgtn9aoyym.png"><br></div></div><br><h3>  Data pengguna </h3><br>  Pertimbangkan menyimpan kumpulan data seperti itu untuk tugas di atas: <br><br><img src="https://habrastorage.org/webt/xj/7i/vc/xj7ivcm_o1k29jpujj6ye-istxu.png"><br><br>  Data itu sendiri disimpan dalam kuintet sesuai dengan struktur yang mengindikasikan keanggotaan dalam istilah tertentu dalam bentuk set seperti itu: <br><br><img src="https://habrastorage.org/webt/d8/cy/u7/d8cyu7h9t0kunctmmrctgapbrhs.png"><br><br>  Kami melihat struktur hierarki yang akrab yang disimpan menggunakan metode Daftar Adjacency alias. <br><br><h3>  Performa </h3><br>  Contoh di atas sangat sederhana, tetapi apa yang akan terjadi ketika strukturnya ribuan kali lebih kompleks dan data akan menjadi gigabytes? <br><br>  Kami akan membutuhkan: <br><br><ol><li>  Struktur hierarkis yang dipertimbangkan di atas adalah 1 pc. </li><li>  B-tree untuk pencarian berdasarkan ID, induk dan tipe - 3 pcs. </li></ol><br>  Dengan demikian, semua catatan dalam basis data kami akan diindeks, termasuk data dan metadata.  Pengindeksan seperti itu diperlukan untuk menjaga properti dari basis data relasional - alat paling sederhana dan paling populer.  Indeks induk sebenarnya komposit (ID induk + tipe).  Indeks berdasarkan tipe juga komposit (tipe + nilai) untuk pencarian cepat objek dari tipe tertentu. <br><br>  Metadata memungkinkan kita untuk menyingkirkan rekursi: misalnya, untuk menemukan semua detail objek yang diberikan, kita menggunakan indeks dengan ID induk.  Jika Anda perlu mencari objek dari tipe tertentu, maka indeks dengan tipe ID digunakan.  Tipe adalah analog dari nama tabel dan bidang dalam DBMS relasional. <br><br><img src="https://habrastorage.org/webt/uv/56/2z/uv562zabrfpwvvtbbw5xbwlspns.png"><br><br>  Dalam kasus apa pun, kami tidak memindai seluruh kumpulan data, dan bahkan dengan sejumlah besar nilai jenis apa pun, nilai yang diinginkan dapat ditemukan dalam sejumlah kecil langkah. <br><br><h3>  Dasar untuk platform pengembangan </h3><br>  Dalam dirinya sendiri, basis data semacam itu tidak mencukupi untuk pemrograman aplikasi, dan tidak lengkap, seperti yang mereka katakan, menurut Turing.  Tapi kita tidak berbicara di sini hanya tentang database, tetapi mencoba untuk mencakup semua aspek: objek, antara lain, algoritma kontrol sewenang-wenang yang dapat diluncurkan, dan mereka akan bekerja <br><br>  Akibatnya, alih-alih struktur basis data yang kompleks dan kode sumber algoritma kontrol yang disimpan secara terpisah, kami mendapatkan bidang informasi yang seragam, dibatasi oleh volume medium dan ditandai dengan metadata.  Data itu sendiri disajikan kepada pengguna dengan cara yang ia mengerti - struktur area subjek dan entri yang sesuai di dalamnya.  Pengguna secara sewenang-wenang mengubah struktur dan data, termasuk membuat operasi massal dengannya. <br><br><h3>  Kami belum menemukan sesuatu yang baru: semua data sudah disimpan dalam sistem file dan pencarian di dalamnya dilakukan dengan menggunakan B-tree, dalam sistem file, dalam database.  Kami hanya mengatur ulang penyajian data untuk membuatnya lebih mudah dan lebih visual untuk bekerja dengannya. </h3><br>  Untuk bekerja dengan representasi data ini, Anda akan memerlukan inti yang sangat kompak - mesin basis data kami adalah urutan besarnya lebih kecil dari BIOS komputer, dan, oleh karena itu, dapat dibuat jika tidak di perangkat keras, maka setidaknya secepat dan secepat dijilat mungkin.  Demi alasan keamanan, ini juga hanya baca. <br><br>  Menambahkan kelas baru ke perakitan .Net tercinta saya, kita dapat mengamati hilangnya 200-300 MB RAM hanya untuk deskripsi kelas ini.  Megabita ini tidak akan masuk ke dalam cache dari level yang benar, menyebabkan sistem menjadi berantakan dengan konsekuensi selanjutnya.  Situasi serupa dengan Java.  Menggambarkan kelas yang sama dengan kuintet akan memakan waktu puluhan atau ratusan byte, karena kelas hanya menggunakan trik primitif untuk bekerja dengan data yang sudah akrab dengan kernel. <br><br><div class="spoiler">  <b class="spoiler_title">Cara menangani berbagai format: RDBMS, NoSQL, basis kolom</b> <div class="spoiler_text">  Pendekatan yang dijelaskan mencakup dua bidang utama: RDBMS dan NoSQL.  Ketika memecahkan masalah yang memanfaatkan basis data kolom, kita perlu memberi tahu kernel bahwa objek tertentu harus disimpan, dengan mempertimbangkan optimalisasi pengambilan sampel massal dari nilai-nilai dari tipe data tertentu (istilah kita).  Jadi kernel akan dapat menempatkan data pada disk dengan cara yang paling menguntungkan. <br><br>  Jadi, untuk basis kolom, kita dapat secara signifikan menghemat ruang yang ditempati oleh kuintet: gunakan hanya satu atau dua komponennya untuk menyimpan data yang bermanfaat, bukan lima, dan juga gunakan indeks hanya untuk menunjukkan awal rantai data.  Dalam banyak kasus, hanya indeks yang akan digunakan untuk sampel dari basis kolom analog kami, tanpa perlu mengakses data tabel itu sendiri. <br><br>  <b>Perlu dicatat bahwa ide tersebut tidak menetapkan tujuan untuk mengumpulkan semua perkembangan lanjutan dari ketiga jenis database ini.</b>  <b>Sebaliknya, mesin dari sistem baru akan dikurangi sebanyak mungkin, hanya mewujudkan fungsi minimum yang diperlukan - segala sesuatu yang mencakup permintaan DDL dan DML dalam konsep yang dijelaskan di sini.</b> <br><br></div></div><br><h3>  Paradigma pemrograman </h3><br>  Menggunakan pendekatan yang dideskripsikan tidak terbatas hanya pada kuintet, tetapi juga mempromosikan paradigma yang berbeda dari yang digunakan oleh para programmer.  Alih-alih bahasa imperatif, deklaratif, atau objek, bahasa query diusulkan sebagai lebih akrab bagi manusia dan memungkinkan kita untuk mengatur tugas langsung ke komputer, melewati programmer dan lapisan yang tidak bisa ditembus dari lingkungan pengembangan yang ada. <br><br>  <b>Tentu saja, penerjemah dari bahasa pengguna gratis ke bahasa persyaratan yang jelas masih diperlukan dalam banyak kasus.</b> <br><br>  Topik ini akan dijelaskan lebih rinci dalam artikel terpisah dengan contoh dan perkembangan yang ada. <br><br>  Jadi, singkatnya, ini berfungsi sebagai berikut: <br><br><ol><li>  Kami pernah menjelaskan dengan quintet tipe data primitif: string, angka, file, teks, dan lainnya, dan juga melatih kernel untuk bekerja dengannya.  Pelatihan dikurangi menjadi penyajian data yang benar dan implementasi operasi sederhana dengan mereka. </li><li>  Sekarang kami jelaskan dalam istilah pengguna kuintet (tipe data) - dalam bentuk metadata.  Deskripsi datang untuk menentukan tipe data primitif untuk setiap tipe pengguna dan menentukan subordinasi. </li><li>  Masukkan kuintet data sesuai dengan struktur yang ditentukan oleh metadata.  Setiap kuintet data berisi tautan ke tipe dan induknya, yang memungkinkan Anda untuk dengan cepat menemukannya di gudang data. </li><li>  Tugas-tugas inti turun untuk mengambil data dan melakukan operasi sederhana dengan mereka untuk menerapkan algoritma rumit yang dijelaskan oleh pengguna. </li><li>  Pengguna mengelola data dan algoritma menggunakan antarmuka visual yang secara visual menghadirkan yang pertama dan kedua. </li></ol><br>  Turing kelengkapan seluruh sistem dipastikan dengan perwujudan persyaratan dasar: kernel dapat melakukan operasi sekuensial, cabang kondisional, memproses set data dan berhenti bekerja ketika hasil tertentu tercapai. <br><br>  Bagi seseorang, manfaatnya adalah kesederhanaan persepsi, misalnya, daripada mendeklarasikan siklus yang melibatkan variabel <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i&lt;length(A); i++) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> A[i] meets a condition <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> something with A[i]</code> </pre> <br><br>  konstruksi yang lebih ramah-manusia digunakan, seperti <br><br><pre> <code class="1c hljs">with every A, that match a condition, do something</code> </pre> <br><br>  Kami bermimpi untuk abstrak dari seluk-beluk tingkat rendah menerapkan sistem informasi: loop, konstruktor, fungsi, manifes, perpustakaan - semua ini memakan terlalu banyak ruang di otak seorang programmer, menyisakan sedikit ruang untuk kerja kreatif dan pengembangan. <br><br><h3>  Scaling </h3><br>  Aplikasi modern tidak dapat dibayangkan tanpa penskalaan: diperlukan kemampuan tak terbatas untuk memperluas kapasitas pemuatan sistem informasi.  Dalam pendekatan yang dideskripsikan, mengingat kesederhanaan ekstrem dari organisasi data, penskalaan ternyata diatur tidak lebih rumit daripada dalam arsitektur yang ada. <br><br>  Dalam contoh di atas dengan aplikasi, Anda dapat memisahkan mereka, misalnya, dengan ID mereka, membuat generasi ID dengan byte tinggi tetap untuk server yang berbeda.  Artinya, ketika menggunakan 32 bit untuk penyimpanan ID, dua-tiga-empat atau lebih bit yang paling signifikan, sesuai kebutuhan, akan menunjukkan server tempat penyimpanan aplikasi ini.  Dengan demikian, setiap server akan memiliki kumpulan ID sendiri. <br><br>  Inti dari satu server dapat berfungsi secara independen dari server lain, tanpa mengetahui apa pun tentang mereka.  Saat membuat aplikasi, itu akan diberikan prioritas tinggi ke server dengan jumlah ID minimum yang digunakan, memastikan distribusi beban yang seragam. <br><br>  Dengan serangkaian kemungkinan variasi permintaan dan respons yang terbatas dengan satu organisasi data, Anda akan memerlukan operator yang cukup kompak yang mendistribusikan permintaan di seluruh server dan mengumpulkan hasilnya. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id433058/">https://habr.com/ru/post/id433058/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id433048/index.html">Bagaimana 2019 akan mengubah toko-toko Rusia</a></li>
<li><a href="../id433050/index.html">Dari perancang pesawat hingga programmer dalam satu tahun, atau bagaimana menjadi Jedi</a></li>
<li><a href="../id433052/index.html">snap & flatpack - tragedi komunitas</a></li>
<li><a href="../id433054/index.html">Jarum dalam tumpukan sesi, atau bytecode ekspresi reguler</a></li>
<li><a href="../id433056/index.html">Kementerian Komunikasi memperketat aturan untuk perangkat lunak dengan elemen yang berasal dari luar negeri</a></li>
<li><a href="../id433060/index.html">Kenapa saya tidak percaya microbenchmark</a></li>
<li><a href="../id433062/index.html">AXIS P1367 vs IDIS DC-B3303X: Bandingkan Kamera CCTV</a></li>
<li><a href="../id433064/index.html">Manajemen insiden: "Anda tidak bisa menyerah" atau seni menempatkan koma</a></li>
<li><a href="../id433066/index.html">HighLoad Cup # 2. Kejuaraan untuk pengembang backend kembali beroperasi</a></li>
<li><a href="../id433070/index.html">Bagaimana membedakan sampo dari sampanye, dan tusuk sate dari sampanye ... Elasticsearch - mencari produk di database toko</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>