<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèº ‚èπÔ∏è üòõ Erstellen und aktualisieren Sie Mailinglisten in Zimbra Collaboration OSE basierend auf Active Directory-Gruppen und -Benutzern üë®üèΩ‚Äçüíª üëâüèΩ ü§òüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1. Ein paar Worte vom Autor 
 Artikel aktualisiert. Skripte ge√§ndert. Skript zum Aktualisieren einer Mailingliste hinzugef√ºgt. 

 In den Kommentaren z...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erstellen und aktualisieren Sie Mailinglisten in Zimbra Collaboration OSE basierend auf Active Directory-Gruppen und -Benutzern</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443166/"><img src="https://habrastorage.org/webt/tl/fg/oj/tlfgoj8_4wwdpcdcj5n8ndx2pu0.png" alt="Bild"><br><br><h3>  1. Ein paar Worte vom Autor </h3><br>  <b>Artikel aktualisiert.</b>  <b>Skripte ge√§ndert.</b>  <b>Skript zum Aktualisieren einer Mailingliste hinzugef√ºgt.</b> <br><br>  In den Kommentaren zum letzten Artikel wurde mir eine interessante Frage zur automatischen Bildung von Mailinglisten basierend auf AD-Sicherheitsgruppen gestellt.  Es gibt ein Problem - es gibt eine L√∂sung.  Also lass uns gehen. <br><br><h3>  2. Die Quelldaten </h3><br>  <i>Server-Betriebssystem</i> : CentOS 7 <br><br><div class="spoiler">  <b class="spoiler_title">√úber das Betriebssystem</b> <div class="spoiler_text">  Tats√§chlich liegt der Unterschied zwischen CentOS7 und jedem anderen System ausschlie√ülich in den Befehlen an den Server zum Installieren von Paketen und m√∂glicherweise im Speicherort einiger Dateien.  Die Arbeiten werden haupts√§chlich mit Zimbra-Cmdlets ausgef√ºhrt, sodass die Konfigurationsunterschiede minimal sind. <br></div></div><br>  <i>Zimbra Domain</i> : zimbramail.home.local <br>  <i>Der Pfad zum Montieren der B√§lle auf dem Zimbra-Host</i> : / mnt / ZM / <br><br><h3>  3. Setup </h3><br><ol><li> Wir montieren den Windows-Ball auf unserem Linux-Server.  Dies soll die √úbertragung von Daten von Windows PowerShell zu Linux Bash vereinfachen und automatisieren.  Das Montageverfahren wurde in einem fr√ºheren Artikel beschrieben.  Ich werde mich nicht wiederholen. </li><li>  Wir erstellen in AD eine separate Organisationseinheit, in der wir Gruppen erstellen, auf deren Grundlage Mailinglisten in Zimbra erstellt werden.  Gruppenname = Name der Verteilerliste. </li><li>  Wir f√ºgen den in der neuen Organisationseinheit erstellten Gruppen Benutzer oder Sicherheitsgruppen hinzu, auf deren Grundlage die Mailinglisten in Zimbra ausgef√ºllt werden.  Das Skript wird rekursiv ausgef√ºhrt. Dies bedeutet, dass alle Daten zu Benutzern erfasst werden, die sich in Gruppen befinden, die Gruppen in der Ziel-Organisationseinheit hinzugef√ºgt werden.  Weitere <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Informationen</a> zur Ausgabe des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Befehls Get-ADGroupMember</a> . </li><li>  Erstellen Sie ein Skript zum Sammeln von Daten aus Active Directory. </li><li>  Wir erstellen ein Skript zum Hinzuf√ºgen von Mailinglisten und zum Ausf√ºllen durch Benutzer basierend auf den im vorherigen Skript empfangenen Daten. </li><li>  Viel Spa√ü. </li></ol><br><a name="habracut"></a><br><h4>  3.1.  √úber OU </h4><br>  Ich habe die Organisationseinheit "ZimbraDL" im Stammverzeichnis der Dom√§ne erstellt und ihr verboten, Gruppenrichtlinien zu erben, damit diese Gruppen getrennt bleiben.  Sie werden in keiner Weise am Leben der Domain teilnehmen, au√üer bei der Erstellung von Verteilerlisten in der Zimbra Collaboration OSE. <br><br><h3>  4. PowerShell-Skript zum Sammeln von Daten aus AD </h3><br><div class="spoiler">  <b class="spoiler_title">PowerShell-Skript</b> <div class="spoiler_text"><pre><code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$Path</span></span> = <span class="hljs-string"><span class="hljs-string">"C:\ZM\ZimbraDL"</span></span> <span class="hljs-variable"><span class="hljs-variable">$enc</span></span> = [system.text.encoding] <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> ReCode ( <span class="hljs-variable"><span class="hljs-variable">$f</span></span>, <span class="hljs-variable"><span class="hljs-variable">$t</span></span>, <span class="hljs-variable"><span class="hljs-variable">$line</span></span> ) { <span class="hljs-variable"><span class="hljs-variable">$cp1</span></span> = <span class="hljs-variable"><span class="hljs-variable">$enc</span></span>::getencoding( <span class="hljs-variable"><span class="hljs-variable">$f</span></span> ) <span class="hljs-variable"><span class="hljs-variable">$cp2</span></span> = <span class="hljs-variable"><span class="hljs-variable">$enc</span></span>::getencoding( <span class="hljs-variable"><span class="hljs-variable">$t</span></span> ) <span class="hljs-variable"><span class="hljs-variable">$inputbytes</span></span> = <span class="hljs-variable"><span class="hljs-variable">$enc</span></span>::convert( <span class="hljs-variable"><span class="hljs-variable">$cp1</span></span>, <span class="hljs-variable"><span class="hljs-variable">$cp2</span></span>, <span class="hljs-variable"><span class="hljs-variable">$cp2</span></span>.getbytes( <span class="hljs-variable"><span class="hljs-variable">$line</span></span> )) <span class="hljs-variable"><span class="hljs-variable">$outputstring</span></span> = <span class="hljs-variable"><span class="hljs-variable">$cp2</span></span>.getstring( <span class="hljs-variable"><span class="hljs-variable">$inputbytes</span></span> ) <span class="hljs-variable"><span class="hljs-variable">$outputstring</span></span> | add-content <span class="hljs-variable"><span class="hljs-variable">$OutputFile</span></span> } <span class="hljs-comment"><span class="hljs-comment">#  if(test-path $Path) { Remove-Item $Path -Recurse -Force } #   if(!(Test-Path $Path)) { New-Item -ItemType Directory -Force -Path $Path } if(!(Test-Path $Path\Groups)) { New-Item -ItemType Directory -Force -Path $Path\Groups } if(!(Test-Path $Path\Users)) { New-Item -ItemType Directory -Force -Path $Path\Users } if(!(Test-Path $Path\UsersTemp)) { New-Item -ItemType Directory -Force -Path $Path\UsersTemp } #   Import-Module ActiveDirectory Get-AdGroup -filter * -SearchBase "OU=ZimbraDL,DC=home,DC=local" | select samaccountname | Out-File $Path\Groups\GetGroupsAD.txt #   (Get-Content "$Path\Groups\GetGroupsAD.txt") -notmatch "samaccountname" | where {$_ -ne ""} | where {$_ -ne "--"} | Where-Object {$_ -notmatch '-'} | out-file "$Path\Groups\GetGroupsAD.txt" $File = @(Get-Content $Path\Groups\GetGroupsAD.txt) foreach ($File1 in $File) { $string=$File1.TrimStart('"') $string=$string.TrimEnd('"') $string=$string.TrimStart(' ') $string=$string.TrimEnd(' ') | Out-File $Path\Groups\GroupsListTemp.txt -Append } #   Remove-Item $Path\Groups\GetGroupsAD.txt -Force $InputFile = gc $Path\Groups\GroupsListTemp.txt $OutputFile = "$Path\Groups\GroupsList.txt" #  foreach ($line in $InputFile) { ReCode -f "windows-1251" -t "utf-8" $line } #   Remove-Item $Path\Groups\GroupsListTemp.txt -Force #        $GroupName = @(Get-Content $Path\Groups\GroupsList.txt) Foreach ($Group in $GroupName) { Get-ADGroupMember $Group -recursive | ft SamAccountName | out-file "$Path\UsersTemp\$Group.txt" -Append (get-content "$Path\UsersTemp\$Group.txt") -notmatch "Name" | where {$_ -ne ""} | where {$_ -ne "--"} | Where-Object {$_ -notmatch '-'} | out-file "$Path\UsersTemp\$Group.txt" $File=@(Get-Content $Path\UsersTemp\$Group.txt) foreach ($File1 in $File) { $string=$File1.TrimStart('"') $string=$string.TrimEnd('"') $string=$string.TrimStart(' ') $string=$String.TrimEnd(' ') | Out-File "$Path\UsersTemp\$Group" -Append } $InputFile = gc $Path\UsersTemp\$Group $OutputFile = "$Path\Users\$Group" #  foreach ($line in $InputFile) { ReCode -f "windows-1251" -t "utf-8" $line } } #    Remove-Item "$Path\UsersTemp\" -Recurse -Force Remove-Item "$Path\Groups" -Recurse -Force</span></span></code> </pre> <br></div></div><br><h4>  4.1.  Wie das Skript funktioniert </h4><br><ol><li>  Zun√§chst wird gepr√ºft, ob das Arbeitsverzeichnis vorhanden und gel√∂scht ist, sofern es vorhanden ist.  Dies ist notwendig, damit sich die Daten dabei nicht verdoppeln. </li><li>  PoSh √ºberpr√ºft die angegebene Organisationseinheit, liest die darin enthaltenen Benutzergruppen und schreibt sie in die Datei GetGroupsAD.txt </li><li>  Verwirft alles √úberfl√ºssige aus der empfangenen Datei (PoSh schreibt die gesamte Ausgabe in die Datei, sodass in der ersten Ausgabe des Befehls die erste Zeile Name ist, die zweite Zeile das Trennzeichen "----" ist und erst danach die Gruppen einzeln aufgelistet werden), √§ndert die Codierung von "windows-1251" bis utf-8, was zu einer anderen Datei GroupsList.txt f√ºhrt </li><li>  Basierend auf der empfangenen Datei werden ferner Informationen √ºber Benutzer der in der Datei enthaltenen Gruppen gelesen.  Dateien mit Benutzernamen (samAccountName) <br>  im Verzeichnis \ Users abgelegt und nach Gruppennamen aufgerufen </li></ol><br><br><h4>  4.2.  Skript zum Lesen von Informationen aus einer einzelnen Gruppe </h4><br>  Ein Skript mit der F√§higkeit, Daten von nur einer Sicherheitsgruppe zu lesen, unterscheidet sich nicht wesentlich von der vorherigen, da es einen Block enth√§lt, in dem der Benutzer aufgefordert wird, den Namen der Gruppe einzugeben, auf dessen Grundlage die Mailingliste aktualisiert werden muss. <br><br><div class="spoiler">  <b class="spoiler_title">PowerShell-Skript, das von Hand ausgef√ºhrt werden kann und Daten aus nur einer Gruppe lesen kann</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$Path</span></span> = <span class="hljs-string"><span class="hljs-string">"C:\ZM\ZimbraDL"</span></span> <span class="hljs-variable"><span class="hljs-variable">$enc</span></span> = [system.text.encoding] <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> ReCode ( <span class="hljs-variable"><span class="hljs-variable">$f</span></span>, <span class="hljs-variable"><span class="hljs-variable">$t</span></span>, <span class="hljs-variable"><span class="hljs-variable">$line</span></span> ) { <span class="hljs-variable"><span class="hljs-variable">$cp1</span></span> = <span class="hljs-variable"><span class="hljs-variable">$enc</span></span>::getencoding( <span class="hljs-variable"><span class="hljs-variable">$f</span></span> ) <span class="hljs-variable"><span class="hljs-variable">$cp2</span></span> = <span class="hljs-variable"><span class="hljs-variable">$enc</span></span>::getencoding( <span class="hljs-variable"><span class="hljs-variable">$t</span></span> ) <span class="hljs-variable"><span class="hljs-variable">$inputbytes</span></span> = <span class="hljs-variable"><span class="hljs-variable">$enc</span></span>::convert( <span class="hljs-variable"><span class="hljs-variable">$cp1</span></span>, <span class="hljs-variable"><span class="hljs-variable">$cp2</span></span>, <span class="hljs-variable"><span class="hljs-variable">$cp2</span></span>.getbytes( <span class="hljs-variable"><span class="hljs-variable">$line</span></span> )) <span class="hljs-variable"><span class="hljs-variable">$outputstring</span></span> = <span class="hljs-variable"><span class="hljs-variable">$cp2</span></span>.getstring( <span class="hljs-variable"><span class="hljs-variable">$inputbytes</span></span> ) <span class="hljs-variable"><span class="hljs-variable">$outputstring</span></span> | add-content <span class="hljs-variable"><span class="hljs-variable">$OutputFile</span></span> } <span class="hljs-comment"><span class="hljs-comment">#  if(test-path $Path) { Remove-Item $Path -Recurse -Force } #   if(!(test-path $Path)) { New-Item -ItemType Directory -Force -Path $Path } if(!(Test-Path $Path\Groups)) { New-Item -ItemType Directory -Force -Path $Path\Groups } if(!(Test-Path $Path\Users)) { New-Item -ItemType Directory -Force -Path $Path\Users } if(!(Test-Path $Path\UsersTemp)) { New-Item -ItemType Directory -Force -Path $Path\UsersTemp } #   Import-Module ActiveDirectory $Groupname = Read-Host '  ,   ,  ALL     ' If ($Groupname -eq "ALL") { Get-AdGroup -filter * -SearchBase "OU=ZimbraDL,DC=home,DC=local" | select samaccountname | Out-File $path\Groups\GetGroupsAD.txt } Else { $Groupname &gt; "$Path\Groups\GetGroupsAD.txt" } #   (Get-Content "$Path\Groups\GetGroupsAD.txt") -notmatch "samaccountname" | where {$_ -ne ""} | where {$_ -ne "--"} | Where-Object {$_ -notmatch '-'} | out-file "$Path\Groups\GetGroupsAD.txt" $File = @(Get-Content $Path\Groups\GetGroupsAD.txt) foreach ($File1 in $File) { $string=$File1.TrimStart('"') $string=$string.TrimEnd('"') $string=$string.TrimStart(' ') $string=$string.TrimEnd(' ') | Out-File $Path\Groups\GroupsListTemp.txt -Append } Remove-Item $Path\Groups\GetGroupsAD.txt -Force $InputFile = gc $Path\Groups\GroupsListTemp.txt $OutputFile = "$Path\Groups\GroupsList.txt" foreach ($line in $InputFile) { ReCode -f "windows-1251" -t "utf-8" $line } Remove-Item $Path\Groups\GroupsListTemp.txt -Force #        $GroupName = @(Get-Content $Path\Groups\GroupsList.txt) Foreach ($Group in $GroupName) { Get-ADGroupMember $Group -recursive | ft SamAccountName | out-file "$Path\UsersTemp\$Group.txt" -Append (get-content "$Path\UsersTemp\$Group.txt") -notmatch "Name" | where {$_ -ne ""} | where {$_ -ne "--"} | Where-Object {$_ -notmatch '-'} | out-file "$Path\UsersTemp\$Group.txt" $File=@(Get-Content $Path\UsersTemp\$Group.txt) foreach ($File1 in $File) { $string=$File1.TrimStart('"') $string=$string.TrimEnd('"') $string=$string.TrimStart(' ') $string=$String.TrimEnd(' ') | Out-File "$Path\UsersTemp\$Group" -Append } $InputFile = gc $Path\UsersTemp\$Group $OutputFile = "$Path\Users\$Group" foreach ($line in $InputFile) { ReCode -f "windows-1251" -t "utf-8" $line } } Remove-Item "$Path\UsersTemp\" -Recurse -Force Remove-Item "$Path\Groups" -Recurse -Force</span></span></code> </pre> <br></div></div><br><br><h3>  5. Bash-Skript zum Erstellen von Mailinglisten </h3><br><div class="spoiler">  <b class="spoiler_title">Ich werde eine Reservierung f√ºr das Kopieren von Skriptdateien vornehmen, die unter Windows erstellt wurden</b> <div class="spoiler_text">  In einem fr√ºheren Artikel haben wir eine Methode zum Formatieren von Dateien mit dem Befehl cat beschrieben, mit der beim Starten mit einem bestimmten Schl√ºssel alle unn√∂tigen unlesbaren Zeichen entfernt werden.  Link zum Artikel am Ende des Artikels. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Bash-Skript</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash #  #    Path="/mnt/ZM/ZimbraDL" #  Zimbra Domain="zimbramail.home.local" #   zmprov zmprov="/opt/zimbra/bin/zmprov" #  - log="/mnt/ZM/DLlog.txt" #       DLnames="/mnt/ZM/DLnames" #       UserNames="/mnt/ZM/Usernames" #   echo "  ..." ls $Path/Users &gt; $DLnames if [ $? -eq 0 ]; then echo -n "$(tput hpa $(tput cols))$(tput cub 6) [OK]" echo echo -en "ls directory for Groups correct $(date +%T)\n" &gt;&gt; $log else echo -n "$(tput hpa $(tput cols))$(tput cub 6) [FAIL]" echo echo -en "ls directory for Groups INcorrect $(date +%T)\n" &gt;&gt; $log fi #   echo "   " for DLname in $( cat $DLnames); do #    echo "    $DLname..." Result=$($zmprov gdl $DLname@$Domain) if [ $? -eq 0 ]; then echo -n "$(tput hpa $(tput cols))$(tput cub 6)[OK]" echo echo -en "DL $DLname exist $(date +%T)\n" &gt;&gt; $log #   echo -en "Start deleting DL for group $DLname $(date +%T)\n" &gt;&gt; $log echo "   $DLname..." $zmprov ddl $DLname@$Domain if [ $? -eq 0 ]; then echo -n "$(tput hpa $(tput cols))$(tput cub 6) [OK]" echo echo -en "DL for group $DLname is deleted in $(date +%T)\n" &gt;&gt; $log else echo -n "$(tput hpa $(tput cols))$(tput cub 6) [FAIL]" echo echo -en "DL for group $DLname is NOT deleted in $(date +%T)\n" &gt;&gt; $log fi else echo -n "$(tput hpa $(tput cols))$(tput cub 6)[FAIL]" echo echo -en "DL $DLname not exist! $(date +%T)\n" &gt;&gt; $log fi done for DLname in $( cat $DLnames); do #   echo -en "Start create DL for group $DLname $(date +%T)\n" &gt;&gt; $log echo "     AD $DLname..." $zmprov cdl $DLname@$Domain if [ $? -eq 0 ]; then echo -n "$(tput hpa $(tput cols))$(tput cub 6) [OK]" echo echo -en "DL for group $DLname is created in $(date +%T)\n" &gt;&gt; $log else echo -n "$(tput hpa $(tput cols))$(tput cub 6) [FAIL]" echo echo -en "DL for group $DLname is NOT created in $(date +%T)\n" &gt;&gt; $log fi #   echo "  " for UserName in $( cat $Path/Users/$DLname); do echo "     $UserName..." Result=$($zmprov gmi $UserName@$Domain) if [ $? -eq 0 ]; then echo -n "$(tput hpa $(tput cols))$(tput cub 6) [OK]" echo echo -en "MilBox for user $UserName exist $(date +%T)\n" &gt;&gt; $log echo "  $UserName    $DLname@$Domain..." $zmprov adlm $DLname@$Domain $UserName@$Domain if [ $? -eq 0 ]; then echo -n "$(tput hpa $(tput cols))$(tput cub 6) [OK]" echo echo -en "User $UserName added in $DLname@$Domain correctly in $(date +%T)\n" &gt;&gt; $log else echo -n "$(tput hpa $(tput cols))$(tput cub 6) [FAIL]" echo echo -en "DL for group $DLname is NOT created in $(date +%T)\n" &gt;&gt; $log fi else echo -n "$(tput hpa $(tput cols))$(tput cub 6) [FAIL]" echo echo -en "MilBox for user $UserName is NOT exist $(date +%T)\n" &gt;&gt; $log fi done done #   echo "  " echo "    ..." echo -n &gt; $DLnames if [ $? -eq 0 ]; then echo -n "$(tput hpa $(tput cols))$(tput cub 6)[OK]" echo echo -en "File $DLnames was successfull cleared in $(date +%T)\n" &gt;&gt; $log else echo -n "$(tput hpa $(tput cols))$(tput cub 6) [FAIL]" echo echo -en "File $DLnames was NOT cleared in $(date +%T)\n" &gt;&gt; $log fi # ,      echo "   $Path    ..." rm -rf $Path if [ $? -eq 0 ]; then echo -n "$(tput hpa $(tput cols))$(tput cub 6)[OK]" echo echo -en "Directory $Path was seccessfull deleted in $(date +%T)\n" &gt;&gt; $log else echo -n "$(tput hpa $(tput cols))$(tput cub 6) [FAIL]" echo echo -en "Directory $Path was NOT deleted in $(date +%T)\n" &gt;&gt; $log fi #  -      echo -en "Job complete in $(date +%T)\n" &gt;&gt; $log echo -en "____________________________________\n" &gt;&gt; $log</span></span></code> </pre><br></div></div><br><h3>  5.1.  Wie das Skript funktioniert </h3><br><ol><li>  Schreiben Sie eine Liste von Gruppen in eine Datei </li><li>  √úberpr√ºfen Sie die Existenz der Mailingliste in Zimbra. Wenn sie existiert, l√∂schen Sie sie </li><li>  Erstellen Sie Mailinglisten nacheinander basierend auf der Liste der Gruppen und f√ºllen Sie jede mit Benutzern (die ID der Verteilerliste wird auf dem Bildschirm angezeigt, dies ist die Standardausgabe des Cmdlets zmprov beim Erstellen von DL).  Dadurch wird das Vorhandensein von Benutzerpostf√§chern in Zimbra √ºberpr√ºft. Wenn das Postfach nicht vorhanden ist, wird der Benutzer nicht zur Mailingliste hinzugef√ºgt.  Sie k√∂nnen nat√ºrlich ein neues Postfach f√ºr den Benutzer erstellen und es der Mailingliste hinzuf√ºgen, aber ich gehe davon aus, dass Zimbra autoprov im Eager-Modus funktioniert. Wenn der Benutzer nicht automatisch erstellt wurde, hat er im System nichts zu tun </li><li>  Tempor√§re Dateien l√∂schen </li><li>  Arbeitsverzeichnis l√∂schen </li></ol><br><h3>  6. Fazit </h3><br>  Im Allgemeinen war die Aufgabe nicht schwierig, das Problem bestand nur darin, Daten von PowerShell nach Bash zu √ºbertragen.  Ich habe lange versucht, ein Tool zum Transkribieren von Textdateien mit PoSh-Ausgabe in eine Bash-verdauliche Form zu finden.  Das Ergebnis vieler Tage der Suche war die Funktion: <br><br><div class="spoiler">  <b class="spoiler_title">Rekodierungsfunktion</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$InputFile</span></span> = gc File1.txt <span class="hljs-variable"><span class="hljs-variable">$OutputFile</span></span> = <span class="hljs-string"><span class="hljs-string">"File2.txt"</span></span> <span class="hljs-variable"><span class="hljs-variable">$enc</span></span> = [system.text.encoding] <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> ReCode ( <span class="hljs-variable"><span class="hljs-variable">$f</span></span>, <span class="hljs-variable"><span class="hljs-variable">$t</span></span>, <span class="hljs-variable"><span class="hljs-variable">$line</span></span> ) { <span class="hljs-variable"><span class="hljs-variable">$cp1</span></span> = <span class="hljs-variable"><span class="hljs-variable">$enc</span></span>::getencoding( <span class="hljs-variable"><span class="hljs-variable">$f</span></span> ) <span class="hljs-variable"><span class="hljs-variable">$cp2</span></span> = <span class="hljs-variable"><span class="hljs-variable">$enc</span></span>::getencoding( <span class="hljs-variable"><span class="hljs-variable">$t</span></span> ) <span class="hljs-variable"><span class="hljs-variable">$inputbytes</span></span> = <span class="hljs-variable"><span class="hljs-variable">$enc</span></span>::convert( <span class="hljs-variable"><span class="hljs-variable">$cp1</span></span>, <span class="hljs-variable"><span class="hljs-variable">$cp2</span></span>, <span class="hljs-variable"><span class="hljs-variable">$cp2</span></span>.getbytes( <span class="hljs-variable"><span class="hljs-variable">$line</span></span> )) <span class="hljs-variable"><span class="hljs-variable">$outputstring</span></span> = <span class="hljs-variable"><span class="hljs-variable">$cp2</span></span>.getstring( <span class="hljs-variable"><span class="hljs-variable">$inputbytes</span></span> ) <span class="hljs-variable"><span class="hljs-variable">$outputstring</span></span> | add-content <span class="hljs-variable"><span class="hljs-variable">$OutputFile</span></span> } foreach (<span class="hljs-variable"><span class="hljs-variable">$line</span></span> <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-variable"><span class="hljs-variable">$InputFile</span></span>) { ReCode -f <span class="hljs-string"><span class="hljs-string">"windows-1251"</span></span> -t <span class="hljs-string"><span class="hljs-string">"utf-8"</span></span> <span class="hljs-variable"><span class="hljs-variable">$line</span></span> }</code> </pre> <br></div></div><br>  Vielleicht ist jemand n√ºtzlich. <br><br><h3>  7. PS: </h3><br>  Dies ist der dritte Artikel in der Reihe ‚ÄûWie ich Zimbra implementiert habe‚Äú.  Der erste befasst sich hier mit der Implementierung, der LDAP-Autorisierung und der automatischen Erstellung von Postf√§chern f√ºr AD-Benutzer.  Der zweite Abschnitt zum Einrichten der Sicherung und Wiederherstellung von Zimbra in seiner Gesamtheit und in separaten Feldern ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443166/">https://habr.com/ru/post/de443166/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443154/index.html">Hintergrundbeleuchtung der DasKeyboard-Tastatur basierend auf Blutzucker mithilfe der REST-API</a></li>
<li><a href="../de443158/index.html">Nostalgie f√ºr die Halbwertszeit - Erstellen eines Pr√§fixes f√ºr einen Radiosender, um die Stimme und den Klang des Endes im Stil von M√§hdreschern zu empfangen</a></li>
<li><a href="../de443160/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 289 (4. M√§rz - 10. M√§rz)</a></li>
<li><a href="../de443162/index.html">Anwendung von Matrix- und Kompetenzdiagrammen</a></li>
<li><a href="../de443164/index.html">Neuronales Netz Trick f√ºr Anf√§nger</a></li>
<li><a href="../de443174/index.html">hellOGL: OpenGL hallo Welt</a></li>
<li><a href="../de443176/index.html">7 Chrome-Erweiterungen zum Englischlernen</a></li>
<li><a href="../de443178/index.html">Crystal Blockchain Analytics: Untersuchung der Hacks und Diebstahlsf√§lle</a></li>
<li><a href="../de443180/index.html">Crew Dragon Landung und Asteroiden Videoaufnahme</a></li>
<li><a href="../de443182/index.html">Ziehen Sie YPbPr vom Commodore 64</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>