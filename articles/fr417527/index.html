<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👜 👲🏻 🙋🏼 Nous développons Shrimp: nous contrôlons les requêtes parallèles, nous nous connectons via spdlog et plus ... 🐧 🚞 👐🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La semaine dernière, nous avons parlé de notre petit projet de démonstration, Shrimp , qui montre clairement comment vous pouvez utiliser les biblioth...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous développons Shrimp: nous contrôlons les requêtes parallèles, nous nous connectons via spdlog et plus ...</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417527/"><img src="https://habrastorage.org/webt/6p/er/na/6pernaqwjoqg3picsc4pz2d1xba.jpeg"><br><br>  La semaine dernière, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nous avons parlé de notre petit projet de démonstration, Shrimp</a> , qui montre clairement comment vous pouvez utiliser les bibliothèques C ++ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RESTinio</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SObjectizer</a> dans des conditions plus ou moins similaires.  Shrimp est une petite application C ++ 17 qui, via RESTinio, accepte les requêtes HTTP pour la mise à l'échelle des images et sert ces requêtes en mode multi-thread via SObjectizer et ImageMagick ++. <br><br>  Le projet s'est avéré plus qu'utile pour nous.  La tirelire de Wishlist pour l'extension des fonctionnalités de RESTinio et SObjectizer s'est considérablement réapprovisionnée.  Quelque chose qui a même été incorporé dans une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">version</a> très <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">récente de RESTinio-0.4.7</a> .  Nous avons donc décidé de ne pas nous attarder sur la toute première et la plus triviale version de Shrimp, mais de faire une ou deux itérations supplémentaires autour de ce projet.  Si quelqu'un s'intéresse à quoi et comment nous avons fait pendant cette période, vous êtes le bienvenu sous cat. <br><blockquote>  En tant que spoiler: nous parlerons de la façon dont nous nous sommes débarrassés du traitement parallèle de demandes identiques, de la façon dont nous avons ajouté la journalisation à Shrimp à l'aide de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">excellente bibliothèque spdlog</a> , et également effectué une commande pour forcer la réinitialisation du cache des images transformées. </blockquote><a name="habracut"></a><h1>  v0.3: contrôle du traitement parallèle de requêtes identiques </h1><br>  La toute première version de Shrimp, décrite dans un article précédent, contenait une sérieuse simplification: il n'y avait aucun contrôle sur le fait que la même demande soit actuellement traitée ou non. <br><br>  Imaginez que pour la première fois Shrimp reçoive une demande du formulaire "/demo.jpg?op=resize&amp;max=1024".  Il n'y a pas encore une telle image dans le cache d'images transformé, donc la demande est en cours de traitement.  Le traitement peut prendre un temps considérable, disons, quelques centaines de millisecondes. <br><br>  Le traitement de la demande n'est pas encore terminé et Shrimp reçoit à nouveau la même demande "/demo.jpg?op=resize&amp;max=1024", mais d'un autre client.  Il n'y a pas encore de résultat de transformation dans le cache, donc cette demande sera également traitée. <br><br>  Ni la première ni la deuxième demande n'ont encore été traitées, et Shrimp peut à nouveau recevoir la même demande "/demo.jpg?op=resize&amp;max=1024".  Et cette demande sera également traitée.  Il s'avère que la même image est mise à l'échelle à la même taille en parallèle plusieurs fois. <br><br>  Ce n'est pas bon.  Par conséquent, la première chose que nous avons décidé chez Shrimp était de se débarrasser d'un montant aussi sérieux.  Nous l'avons fait en raison de deux conteneurs difficiles dans l'agent transform_manager.  Le premier conteneur est une file d'attente de demandes de transformateur gratuites.  Il s'agit d'un conteneur nommé m_pending_requests.  Le deuxième conteneur stocke les demandes qui ont déjà été traitées (c'est-à-dire que des transformateurs spécifiques ont été affectés à ces demandes).  Il s'agit d'un conteneur nommé m_inprogress_requests. <br><br>  Lorsque transform_manager reçoit la requête suivante, il vérifie la présence de l'image finie dans le cache d'images transformées.  S'il n'y a pas d'image convertie, les conteneurs m_inprogress_requests et m_pending_requests sont vérifiés.  Et s'il n'y a aucune demande avec de tels paramètres dans l'un de ces conteneurs, alors seulement une tentative est effectuée pour placer la demande dans la file d'attente m_pending_requests.  Cela ressemble <a href="">à ceci</a> : <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::handle_not_transformed_image( transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span> request_key, <span class="hljs-keyword"><span class="hljs-keyword">sobj_shptr_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>&gt; cmd ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> store_to = [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.insert( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(request_key), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd) ); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_inprogress_requests.has_key( request_key ) ) { <span class="hljs-comment"><span class="hljs-comment">//    . //         . store_to( m_inprogress_requests ); } else if( m_pending_requests.has_key( request_key ) ) { //      . store_to( m_pending_requests ); } else if( m_pending_requests.unique_keys() &lt; max_pending_requests ) { //           . store_to( m_pending_requests ); //    transformer-     . try_initiate_pending_requests_processing(); } else { //  ,   . do_503_response( std::move(cmd-&gt;m_http_req) ); } }</span></span></code> </pre> <br>  Il a été dit plus haut que m_inprogress_requests et m_pending_requests sont des conteneurs difficiles.  Mais quel est le truc? <br><br>  L'astuce est que ces conteneurs combinent les propriétés à la fois d'une file d'attente FIFO régulière (dans laquelle l'ordre chronologique d'ajout d'éléments est préservé) et multimap, c'est-à-dire  Conteneur associatif dans lequel plusieurs valeurs peuvent être mappées sur une seule clé. <br><br>  Il est important de conserver l'ordre chronologique, car les éléments les plus anciens de m_pending_requests doivent être vérifiés périodiquement et supprimés de m_pending_requests les demandes pour lesquelles le délai maximal est dépassé.  Un accès efficace aux éléments par clé est nécessaire à la fois pour vérifier la présence de demandes identiques dans les files d'attente et pour que toutes les demandes en double puissent être supprimées de la file d'attente à la fois. <br><br>  Chez Shrimp, nous avons utilisé <a href="">notre petit conteneur</a> à ces fins.  Cependant, si Boost était utilisé dans Shrimp, Boost.MultiIndex pourrait être utilisé.  Et, probablement, au fil du temps, une recherche efficace dans m_pending_requests devra être organisée selon d'autres critères, puis Boost.MultiIndex dans Shrimp devra être activé. <br><br><h1>  v0.4: journalisation avec spdlog </h1><br>  Nous avons essayé de laisser la première version de Shrimp aussi simple et compacte que possible.  Pour cette raison, dans la première version de Shrimp, nous n'avons pas utilisé la journalisation.  Généralement. <br><br>  D'une part, cela a permis de garder le code de la première version concis, ne contenant que la logique métier Shrimp nécessaire.  Mais, d'autre part, le manque d'exploitation complique à la fois le développement de la crevette et son fonctionnement.  Par conséquent, dès que nous avons mis la main dessus, nous avons immédiatement traîné dans Shrimp une excellente bibliothèque C ++ moderne pour la journalisation - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">spdlog</a> .  La respiration est immédiatement devenue plus facile, bien que le code de certaines méthodes ait augmenté en volume. <br><br>  Par exemple, le code ci-dessus de la méthode handle_not_transformed_image () avec journalisation commence à ressembler à <a href="">ceci</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::handle_not_transformed_image( transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span> request_key, <span class="hljs-keyword"><span class="hljs-keyword">sobj_shptr_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>&gt; cmd ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> store_to = [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.insert( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(request_key), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd) ); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_inprogress_requests.has_key( request_key ) ) { <span class="hljs-comment"><span class="hljs-comment">//    . m_logger-&gt;debug( "same request is already in progress; request_key={}", request_key ); //         . store_to( m_inprogress_requests ); } else if( m_pending_requests.has_key( request_key ) ) { //      . m_logger-&gt;debug( "same request is already pending; request_key={}", request_key ); store_to( m_pending_requests ); } else if( m_pending_requests.unique_keys() &lt; max_pending_requests ) { //           . m_logger-&gt;debug( "store request to pending requests queue; request_key={}", request_key ); store_to( m_pending_requests ); //    transformer-     . try_initiate_pending_requests_processing(); } else { //  ,   . m_logger-&gt;warn( "request is rejected because of overloading; " "request_key={}", request_key ); do_503_response( std::move(cmd-&gt;m_http_req) ); } }</span></span></code> </pre> <br><h2>  Configuration des enregistreurs spdlog </h2><br>  La connexion à Shrimp se fait sur la console (c'est-à-dire dans le flux de sortie standard).  En principe, on pourrait suivre un chemin très simple et créer dans Shrimp la seule instance du spd-logger.  C'est-à-dire  on pourrait appeler <a href="">stdout_color_mt</a> (ou <a href="">stdout_logger_mt</a> ), puis transmettre cet enregistreur à toutes les entités de Shrimp.  Mais nous sommes allés un peu plus compliqué: nous avons créé manuellement le soi-disant  récepteur (c'est-à-dire le canal où spdlog produira les messages générés), et pour les entités Shrimp, ils ont créé des enregistreurs distincts attachés à ce récepteur. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     . [[nodiscard]] spdlog::sink_ptr make_logger_sink() { auto sink = std::make_shared&lt; spdlog::sinks::ansicolor_stdout_sink_mt &gt;(); return sink; } [[nodiscard]] std::shared_ptr&lt;spdlog::logger&gt; make_logger( const std::string &amp; name, spdlog::sink_ptr sink, spdlog::level::level_enum level = spdlog::level::trace ) { auto logger = std::make_shared&lt; spdlog::logger &gt;( name, std::move(sink) ); logger-&gt;set_level( level ); logger-&gt;flush_on( level ); return logger; } //        : auto manager = coop.make_agent_with_binder&lt; a_transform_manager_t &gt;( create_one_thread_disp( "manager" )-&gt;binder(), make_logger( "manager", logger_sink ) ); ... const auto worker_name = fmt::format( "worker_{}", worker ); auto transformer = coop.make_agent_with_binder&lt; a_transformer_t &gt;( create_one_thread_disp( worker_name )-&gt;binder(), make_logger( worker_name, logger_sink ), app_params.m_storage );</span></span></code> </pre><br>  Il y a un point subtil avec la configuration des enregistreurs dans spdlog: par défaut, l'enregistreur ignore les messages avec des niveaux de gravité de trace et de débogage.  À savoir, ils s'avèrent être plus utiles lors du débogage.  Par conséquent, dans make_logger, nous activons par défaut la journalisation pour tous les niveaux, y compris le suivi / débogage. <br><br>  Étant donné que chaque entité de Shrimp a son propre enregistreur avec son propre nom, nous pouvons voir qui fait quoi dans le journal: <br><br><img src="https://habrastorage.org/webt/1o/jh/yx/1ojhyxgywovfstlfsybe19h0lb0.png"><br><br><h2>  Traçage de SObjectizer avec spdlog </h2><br>  Les temps de journalisation, qui sont effectués dans le cadre de la logique métier principale d'une application SObjectizer, ne sont pas suffisants pour déboguer l'application.  Il n'est pas clair pourquoi une action est lancée dans un agent, mais n'est pas réellement effectuée dans un autre agent.  Dans ce cas, le mécanisme msg_tracing intégré à SObjectizer aide beaucoup (dont nous avons parlé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans un article séparé</a> ).  Mais parmi les implémentations standard de msg_tracing pour SObjectizer, il n'y en a pas une qui utilise spdlog.  Nous ferons nous-mêmes cette implémentation pour Shrimp <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">spdlog_sobj_tracer_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::msg_tracing::<span class="hljs-keyword"><span class="hljs-keyword">tracer_t</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;spdlog::logger&gt; m_logger; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">spdlog_sobj_tracer_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;spdlog::logger&gt; logger ) : m_logger{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(logger) } {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; what )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> override </span></span>{ m_logger-&gt;trace( what ); } [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> so_5::msg_tracing::<span class="hljs-keyword"><span class="hljs-keyword">tracer_unique_ptr_t</span></span> make( spdlog::sink_ptr sink ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;<span class="hljs-keyword"><span class="hljs-keyword">spdlog_sobj_tracer_t</span></span>&gt;( make_logger( <span class="hljs-string"><span class="hljs-string">"sobjectizer"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(sink) ) ); } };</code> </pre> <br>  Nous voyons ici l'implémentation de l'interface spéciale SObjectizer tracer_t, dans laquelle l'essentiel est la méthode virtuelle trace ().  C'est lui qui effectue le traçage des internes de SObjectizer au moyen de spdlog. <br><br>  Ensuite, cette implémentation est installée en tant que traceur lors du démarrage de SObjectizer: <br><br><pre> <code class="cpp hljs">so_5::<span class="hljs-keyword"><span class="hljs-keyword">wrapped_env_t</span></span> sobj{ [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) {...}, [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_params_t</span></span> &amp; params ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">sobj_tracing_t</span></span>::on == sobj_tracing ) params.message_delivery_tracer( <span class="hljs-keyword"><span class="hljs-keyword">spdlog_sobj_tracer_t</span></span>::make( logger_sink ) ); } };</code> </pre> <br><h2>  RESTinio trace via spdlog </h2><br>  En plus de suivre ce qui se passe à l'intérieur du SObjectizer, il peut parfois être très utile de suivre ce qui se passe à l'intérieur de RESTinio.  Dans la version mise à jour de Shrimp, une telle trace est également ajoutée. <br><br>  Cette trace est implémentée via la définition d'une classe spéciale qui peut effectuer la journalisation dans RESTinio: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">http_server_logger_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">http_server_logger_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;spdlog::logger&gt; logger ) : m_logger{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( logger ) } {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Builder &amp;&amp; msg_builder )</span></span></span><span class="hljs-function"> </span></span>{ log_if_enabled( spdlog::level::trace, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Builder&gt;(msg_builder) ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">info</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Builder &amp;&amp; msg_builder )</span></span></span><span class="hljs-function"> </span></span>{ log_if_enabled( spdlog::level::info, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Builder&gt;(msg_builder) ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">warn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Builder &amp;&amp; msg_builder )</span></span></span><span class="hljs-function"> </span></span>{ log_if_enabled( spdlog::level::warn, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Builder&gt;(msg_builder) ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Builder &amp;&amp; msg_builder )</span></span></span><span class="hljs-function"> </span></span>{ log_if_enabled( spdlog::level::err, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Builder&gt;(msg_builder) ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log_if_enabled</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( spdlog::level::level_enum lv, Builder &amp;&amp; msg_builder )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_logger-&gt;should_log(lv) ) { m_logger-&gt;<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>( lv, msg_builder() ); } } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;spdlog::logger&gt; m_logger; };</code> </pre> <br>  Cette classe n'est héritée de rien, car le mécanisme de journalisation dans RESTinio est basé sur une programmation généralisée, et non sur l'approche orientée objet traditionnelle.  Cela vous permet de vous débarrasser complètement de toute surcharge dans les cas où la journalisation n'est pas du tout nécessaire (nous avons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traité</a> ce sujet plus en détail lorsque nous avons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">parlé d'utiliser des modèles dans RESTinio</a> ). <br><br>  Ensuite, nous devons indiquer que le serveur HTTP utilisera la classe http_server_logger_t indiquée ci-dessus comme enregistreur.  Cela se fait en clarifiant les propriétés du serveur HTTP: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">http_server_traits_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">default_traits_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">logger_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">http_server_logger_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">request_handler_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">http_req_router_t</span></span>; };</code> </pre> <br>  Eh bien, il ne reste plus rien à faire - créez une instance spécifique du spd-logger et envoyez cet enregistreur au serveur HTTP créé: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> restinio_logger = make_logger( <span class="hljs-string"><span class="hljs-string">"restinio"</span></span>, logger_sink, <span class="hljs-keyword"><span class="hljs-keyword">restinio_tracing_t</span></span>::off == restinio_tracing ? spdlog::level::off : log_level ); restinio::run( asio_io_ctx, shrimp::make_http_server_settings( thread_count.m_io_threads, params, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(restinio_logger), manager_mbox_promise.get_future().get() ) );</code> </pre> <br><h1>  v0.5: réinitialisation forcée du cache d'image transformé </h1><br>  Dans le processus de débogage de Shrimp, une petite chose a été découverte qui était un peu gênante: pour vider le contenu du cache d'image transformé, vous deviez redémarrer l'intégralité de Shrimp.  Cela semblerait insignifiant, mais désagréable. <br><br>  Si c'est désagréable, alors vous devriez vous débarrasser de cette lacune.  Heureusement, ce n'est pas du tout difficile. <br><br>  Tout d'abord, nous allons définir une autre URL dans Shrimp à laquelle vous pouvez envoyer des requêtes HTTP DELETE: "/ cache".  En conséquence, nous accrocherons notre gestionnaire sur cette URL: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">http_req_router_t</span></span> &gt; make_router( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">app_params_t</span></span> &amp; params, so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> req_handler_mbox ) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> router = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt; <span class="hljs-keyword"><span class="hljs-keyword">http_req_router_t</span></span> &gt;(); add_transform_op_handler( params, *router, req_handler_mbox ); add_delete_cache_handler( *router, req_handler_mbox ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> router; }</code> </pre> <br>  où la fonction add_delete_cache_handler () ressemble à ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_delete_cache_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">http_req_router_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; router, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req_handler_mbox )</span></span></span><span class="hljs-function"> </span></span>{ router.http_delete( <span class="hljs-string"><span class="hljs-string">"/cache"</span></span>, [req_handler_mbox]( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-comment"><span class="hljs-comment">/*params*/</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> qp = restinio::parse_query( req-&gt;header().query() ); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> token = qp.get_param( <span class="hljs-string"><span class="hljs-string">"token"</span></span>sv ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !token ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_403_response( req, <span class="hljs-string"><span class="hljs-string">"No token provided\r\n"</span></span> ); } <span class="hljs-comment"><span class="hljs-comment">// Delegate request processing to transform_manager. so_5::send&lt; so_5::mutable_msg&lt;a_transform_manager_t::delete_cache_request_t&gt; &gt;( req_handler_mbox, req, restinio::cast_to&lt;std::string&gt;(*token) ); return restinio::request_accepted(); } ); }</span></span></code> </pre> <br>  Un peu bavard, mais rien de compliqué.  La chaîne de requête de la requête doit avoir un paramètre de jeton.  Ce paramètre doit contenir une chaîne avec une valeur spéciale pour le jeton d'administration.  Vous ne pouvez réinitialiser le cache que si la valeur du jeton du paramètre token correspond à ce qui a été défini lors du lancement de Shrimp.  S'il n'y a pas de paramètre de jeton, la demande de traitement n'est pas acceptée.  S'il y a un jeton, alors l'agent transform_manager, propriétaire du cache, reçoit un message de commande spécial, en exécutant lequel l'agent transform_manager lui-même répondra à la requête HTTP. <br><br>  Deuxièmement, nous implémentons le nouveau gestionnaire de messages delete_cache_request_t dans l'agent transform_manager_t: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_delete_cache_request( <span class="hljs-keyword"><span class="hljs-keyword">mutable_mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">delete_cache_request_t</span></span>&gt; cmd ) { m_logger-&gt;warn( <span class="hljs-string"><span class="hljs-string">"delete cache request received; "</span></span> <span class="hljs-string"><span class="hljs-string">"connection_id={}, token={}"</span></span>, cmd-&gt;m_http_req-&gt;connection_id(), cmd-&gt;m_token ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> delay_response = [&amp;]( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> response_text ) { so_5::send_delayed&lt; so_5::mutable_msg&lt;<span class="hljs-keyword"><span class="hljs-keyword">negative_delete_cache_response_t</span></span>&gt; &gt;( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::seconds{<span class="hljs-number"><span class="hljs-number">7</span></span>}, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd-&gt;m_http_req), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(response_text) ); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * env_token = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::getenv( <span class="hljs-string"><span class="hljs-string">"SHRIMP_ADMIN_TOKEN"</span></span> ); <span class="hljs-comment"><span class="hljs-comment">// Token must be present and must not be empty. env_token &amp;&amp; *env_token ) { if( cmd-&gt;m_token == env_token ) { m_transformed_cache.clear(); m_logger-&gt;info( "cache deleted" ); do_200_plaintext_response( std::move(cmd-&gt;m_http_req), "Cache deleted\r\n" ); } else { m_logger-&gt;error( "invalid token value for delete cache request; " "token={}", cmd-&gt;m_token ); delay_response( "Token value mismatch\r\n" ); } } else { m_logger-&gt;warn( "delete cache can't performed because there is no " "admin token defined" ); // Operation can't be performed because admin token is not avaliable. delay_response( "No admin token defined\r\n" ); } }</span></span></code> </pre> <br>  Il y a deux points ici qui devraient être clarifiés. <br><br>  Le premier point dans l'implémentation de on_delete_cache_request () est la vérification de la valeur du jeton elle-même.  Le jeton d'administration est défini via la variable d'environnement SHRIMP_ADMIN_TOKEN.  Si cette variable est définie et que sa valeur correspond à la valeur du paramètre de jeton de la demande HTTP DELETE, le cache est effacé et une réponse positive à la demande est immédiatement générée. <br><br>  Et le deuxième point dans l'implémentation de on_delete_cache_request () est le retard forcé d'une réponse négative à HTTP DELETE.  Si la mauvaise valeur du jeton d'administration est arrivée, vous devez retarder la réponse à HTTP DELETE afin de ne pas vouloir sélectionner la valeur du jeton par force brute.  Mais comment faire ce retard?  Après tout, appeler std :: thread :: sleep_for () n'est pas une option. <br><br>  C'est là que les messages en attente de SObjectizer viennent à la rescousse.  Au lieu de générer immédiatement une réponse négative dans on_delete_cache_request (), l'agent transform_manager s'envoie simplement un message negative_delete_cache_response_t en attente.  Le temporisateur SObjectizer comptera le temps défini et remettra ce message à l'agent une fois le délai spécifié écoulé.  Et maintenant, dans le gestionnaire negative_delete_cache_response_t, vous pouvez déjà générer immédiatement une réponse à la demande HTTP DELETE: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_negative_delete_cache_response( <span class="hljs-keyword"><span class="hljs-keyword">mutable_mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">negative_delete_cache_response_t</span></span>&gt; cmd ) { m_logger-&gt;debug( <span class="hljs-string"><span class="hljs-string">"send negative response to delete cache request; "</span></span> <span class="hljs-string"><span class="hljs-string">"connection_id={}"</span></span>, cmd-&gt;m_http_req-&gt;connection_id() ); do_403_response( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd-&gt;m_http_req), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd-&gt;m_response_text) ); }</code> </pre> <br>  C'est-à-dire  il s'avère que le scénario suivant: <br><br><ul><li>  Le serveur HTTP reçoit une demande HTTP DELETE, convertit cette demande en un message delete_cache_request_t à l'agent transform_manager; </li><li>  l'agent transform_manager reçoit le message delete_cache_request_t et génère immédiatement une réponse positive à la demande ou s'envoie un message en attente negative_delete_cache_response_t; </li><li>  transform_manager reçoit un message negative_delete_cache_response_t et génère immédiatement une réponse négative à la requête HTTP DELETE correspondante. </li></ul><br><h1>  Fin de la deuxième partie </h1><br>  À la fin de la deuxième partie, il est tout à fait naturel de se poser la question: "Et ensuite?" <br><br>  De plus, il y aura probablement une autre itération et une autre mise à jour de notre projet de démonstration.  Je voudrais faire une chose telle que convertir une image d'un format à un autre.  Disons que sur le serveur, l'image est en jpg, et après la transformation, elle est envoyée au client en webp. <br><br>  Il serait également intéressant de joindre une "page" séparée avec l'affichage des statistiques actuelles sur le travail de la crevette.  Tout d'abord, c'est juste curieux.  Mais, en principe, une telle page peut également être adaptée aux besoins du suivi de la viabilité des crevettes. <br><br>  Si quelqu'un d'autre a des suggestions sur ce que j'aimerais voir dans Shrimp ou dans des articles sur Shrimp, alors nous serons heureux d'entendre des réflexions constructives. <br><br>  Par ailleurs, je tiens à souligner un aspect de la mise en œuvre de la crevette, qui nous a quelque peu surpris.  Il s'agit d'une utilisation active des messages mutables lors de la communication entre eux et avec le serveur HTTP.  Habituellement, dans notre pratique, c'est le contraire qui se produit - le plus souvent, les données sont échangées via des messages immunitaires.  Ce n'est pas le cas ici.  Cela suggère que nous avons sciemment écouté les souhaits des utilisateurs en temps voulu et ajouté des messages modifiables à SObjectizer.  Donc, si vous souhaitez voir quelque chose dans RESTinio ou SObjectizer, n'hésitez pas à partager vos idées.  Nous sommes sûrs d'écouter les bons. <br><br>  Eh bien, et en conclusion, je tiens à remercier tous ceux qui ont pris le temps de parler de la première version de Shrimp, à la fois ici sur Habré et à travers d'autres ressources.  Je vous remercie! <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">À suivre ...</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr417527/">https://habr.com/ru/post/fr417527/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr417511/index.html">Intel acquiert eASIC - Développeur structurel ASIC</a></li>
<li><a href="../fr417513/index.html">Analogues en Python et JavaScript. Deuxième partie</a></li>
<li><a href="../fr417515/index.html">Ce que j'ai appris en créant 100 jeux en 5 ans</a></li>
<li><a href="../fr417517/index.html">Pages de l'histoire d'Intel. Chronique photo et quiz</a></li>
<li><a href="../fr417521/index.html">Examiner les certificats SSL pour la révocation</a></li>
<li><a href="../fr417529/index.html">Trois tendances technologiques qui changent le commerce et le consommateur</a></li>
<li><a href="../fr417531/index.html">Comment nous avons gagné dans SmartMailHack 2</a></li>
<li><a href="../fr417533/index.html">Bloc-notes sur Windows a reçu la première mise à jour importante en deux décennies</a></li>
<li><a href="../fr417535/index.html">Le développement de CUBA est-il un grand pas loin du printemps?</a></li>
<li><a href="../fr417537/index.html">"Votre jeu est ennuyeux", ou comment augmenter la rétention déjà élevée du premier jour</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>