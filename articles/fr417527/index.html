<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëú üë≤üèª üôãüèº Nous d√©veloppons Shrimp: nous contr√¥lons les requ√™tes parall√®les, nous nous connectons via spdlog et plus ... üêß üöû üëêüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La semaine derni√®re, nous avons parl√© de notre petit projet de d√©monstration, Shrimp , qui montre clairement comment vous pouvez utiliser les biblioth...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nous d√©veloppons Shrimp: nous contr√¥lons les requ√™tes parall√®les, nous nous connectons via spdlog et plus ...</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417527/"><img src="https://habrastorage.org/webt/6p/er/na/6pernaqwjoqg3picsc4pz2d1xba.jpeg"><br><br>  La semaine derni√®re, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">nous avons parl√© de notre petit projet de d√©monstration, Shrimp</a> , qui montre clairement comment vous pouvez utiliser les biblioth√®ques C ++ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RESTinio</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SObjectizer</a> dans des conditions plus ou moins similaires.  Shrimp est une petite application C ++ 17 qui, via RESTinio, accepte les requ√™tes HTTP pour la mise √† l'√©chelle des images et sert ces requ√™tes en mode multi-thread via SObjectizer et ImageMagick ++. <br><br>  Le projet s'est av√©r√© plus qu'utile pour nous.  La tirelire de Wishlist pour l'extension des fonctionnalit√©s de RESTinio et SObjectizer s'est consid√©rablement r√©approvisionn√©e.  Quelque chose qui a m√™me √©t√© incorpor√© dans une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">version</a> tr√®s <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©cente de RESTinio-0.4.7</a> .  Nous avons donc d√©cid√© de ne pas nous attarder sur la toute premi√®re et la plus triviale version de Shrimp, mais de faire une ou deux it√©rations suppl√©mentaires autour de ce projet.  Si quelqu'un s'int√©resse √† quoi et comment nous avons fait pendant cette p√©riode, vous √™tes le bienvenu sous cat. <br><blockquote>  En tant que spoiler: nous parlerons de la fa√ßon dont nous nous sommes d√©barrass√©s du traitement parall√®le de demandes identiques, de la fa√ßon dont nous avons ajout√© la journalisation √† Shrimp √† l'aide de l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">excellente biblioth√®que spdlog</a> , et √©galement effectu√© une commande pour forcer la r√©initialisation du cache des images transform√©es. </blockquote><a name="habracut"></a><h1>  v0.3: contr√¥le du traitement parall√®le de requ√™tes identiques </h1><br>  La toute premi√®re version de Shrimp, d√©crite dans un article pr√©c√©dent, contenait une s√©rieuse simplification: il n'y avait aucun contr√¥le sur le fait que la m√™me demande soit actuellement trait√©e ou non. <br><br>  Imaginez que pour la premi√®re fois Shrimp re√ßoive une demande du formulaire "/demo.jpg?op=resize&amp;max=1024".  Il n'y a pas encore une telle image dans le cache d'images transform√©, donc la demande est en cours de traitement.  Le traitement peut prendre un temps consid√©rable, disons, quelques centaines de millisecondes. <br><br>  Le traitement de la demande n'est pas encore termin√© et Shrimp re√ßoit √† nouveau la m√™me demande "/demo.jpg?op=resize&amp;max=1024", mais d'un autre client.  Il n'y a pas encore de r√©sultat de transformation dans le cache, donc cette demande sera √©galement trait√©e. <br><br>  Ni la premi√®re ni la deuxi√®me demande n'ont encore √©t√© trait√©es, et Shrimp peut √† nouveau recevoir la m√™me demande "/demo.jpg?op=resize&amp;max=1024".  Et cette demande sera √©galement trait√©e.  Il s'av√®re que la m√™me image est mise √† l'√©chelle √† la m√™me taille en parall√®le plusieurs fois. <br><br>  Ce n'est pas bon.  Par cons√©quent, la premi√®re chose que nous avons d√©cid√© chez Shrimp √©tait de se d√©barrasser d'un montant aussi s√©rieux.  Nous l'avons fait en raison de deux conteneurs difficiles dans l'agent transform_manager.  Le premier conteneur est une file d'attente de demandes de transformateur gratuites.  Il s'agit d'un conteneur nomm√© m_pending_requests.  Le deuxi√®me conteneur stocke les demandes qui ont d√©j√† √©t√© trait√©es (c'est-√†-dire que des transformateurs sp√©cifiques ont √©t√© affect√©s √† ces demandes).  Il s'agit d'un conteneur nomm√© m_inprogress_requests. <br><br>  Lorsque transform_manager re√ßoit la requ√™te suivante, il v√©rifie la pr√©sence de l'image finie dans le cache d'images transform√©es.  S'il n'y a pas d'image convertie, les conteneurs m_inprogress_requests et m_pending_requests sont v√©rifi√©s.  Et s'il n'y a aucune demande avec de tels param√®tres dans l'un de ces conteneurs, alors seulement une tentative est effectu√©e pour placer la demande dans la file d'attente m_pending_requests.  Cela ressemble <a href="">√† ceci</a> : <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::handle_not_transformed_image( transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span> request_key, <span class="hljs-keyword"><span class="hljs-keyword">sobj_shptr_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>&gt; cmd ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> store_to = [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.insert( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(request_key), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd) ); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_inprogress_requests.has_key( request_key ) ) { <span class="hljs-comment"><span class="hljs-comment">//    . //         . store_to( m_inprogress_requests ); } else if( m_pending_requests.has_key( request_key ) ) { //      . store_to( m_pending_requests ); } else if( m_pending_requests.unique_keys() &lt; max_pending_requests ) { //           . store_to( m_pending_requests ); //    transformer-     . try_initiate_pending_requests_processing(); } else { //  ,   . do_503_response( std::move(cmd-&gt;m_http_req) ); } }</span></span></code> </pre> <br>  Il a √©t√© dit plus haut que m_inprogress_requests et m_pending_requests sont des conteneurs difficiles.  Mais quel est le truc? <br><br>  L'astuce est que ces conteneurs combinent les propri√©t√©s √† la fois d'une file d'attente FIFO r√©guli√®re (dans laquelle l'ordre chronologique d'ajout d'√©l√©ments est pr√©serv√©) et multimap, c'est-√†-dire  Conteneur associatif dans lequel plusieurs valeurs peuvent √™tre mapp√©es sur une seule cl√©. <br><br>  Il est important de conserver l'ordre chronologique, car les √©l√©ments les plus anciens de m_pending_requests doivent √™tre v√©rifi√©s p√©riodiquement et supprim√©s de m_pending_requests les demandes pour lesquelles le d√©lai maximal est d√©pass√©.  Un acc√®s efficace aux √©l√©ments par cl√© est n√©cessaire √† la fois pour v√©rifier la pr√©sence de demandes identiques dans les files d'attente et pour que toutes les demandes en double puissent √™tre supprim√©es de la file d'attente √† la fois. <br><br>  Chez Shrimp, nous avons utilis√© <a href="">notre petit conteneur</a> √† ces fins.  Cependant, si Boost √©tait utilis√© dans Shrimp, Boost.MultiIndex pourrait √™tre utilis√©.  Et, probablement, au fil du temps, une recherche efficace dans m_pending_requests devra √™tre organis√©e selon d'autres crit√®res, puis Boost.MultiIndex dans Shrimp devra √™tre activ√©. <br><br><h1>  v0.4: journalisation avec spdlog </h1><br>  Nous avons essay√© de laisser la premi√®re version de Shrimp aussi simple et compacte que possible.  Pour cette raison, dans la premi√®re version de Shrimp, nous n'avons pas utilis√© la journalisation.  G√©n√©ralement. <br><br>  D'une part, cela a permis de garder le code de la premi√®re version concis, ne contenant que la logique m√©tier Shrimp n√©cessaire.  Mais, d'autre part, le manque d'exploitation complique √† la fois le d√©veloppement de la crevette et son fonctionnement.  Par cons√©quent, d√®s que nous avons mis la main dessus, nous avons imm√©diatement tra√Æn√© dans Shrimp une excellente biblioth√®que C ++ moderne pour la journalisation - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">spdlog</a> .  La respiration est imm√©diatement devenue plus facile, bien que le code de certaines m√©thodes ait augment√© en volume. <br><br>  Par exemple, le code ci-dessus de la m√©thode handle_not_transformed_image () avec journalisation commence √† ressembler √† <a href="">ceci</a> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::handle_not_transformed_image( transform::<span class="hljs-keyword"><span class="hljs-keyword">resize_request_key_t</span></span> request_key, <span class="hljs-keyword"><span class="hljs-keyword">sobj_shptr_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">resize_request_t</span></span>&gt; cmd ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> store_to = [&amp;](<span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>.insert( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(request_key), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd) ); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_inprogress_requests.has_key( request_key ) ) { <span class="hljs-comment"><span class="hljs-comment">//    . m_logger-&gt;debug( "same request is already in progress; request_key={}", request_key ); //         . store_to( m_inprogress_requests ); } else if( m_pending_requests.has_key( request_key ) ) { //      . m_logger-&gt;debug( "same request is already pending; request_key={}", request_key ); store_to( m_pending_requests ); } else if( m_pending_requests.unique_keys() &lt; max_pending_requests ) { //           . m_logger-&gt;debug( "store request to pending requests queue; request_key={}", request_key ); store_to( m_pending_requests ); //    transformer-     . try_initiate_pending_requests_processing(); } else { //  ,   . m_logger-&gt;warn( "request is rejected because of overloading; " "request_key={}", request_key ); do_503_response( std::move(cmd-&gt;m_http_req) ); } }</span></span></code> </pre> <br><h2>  Configuration des enregistreurs spdlog </h2><br>  La connexion √† Shrimp se fait sur la console (c'est-√†-dire dans le flux de sortie standard).  En principe, on pourrait suivre un chemin tr√®s simple et cr√©er dans Shrimp la seule instance du spd-logger.  C'est-√†-dire  on pourrait appeler <a href="">stdout_color_mt</a> (ou <a href="">stdout_logger_mt</a> ), puis transmettre cet enregistreur √† toutes les entit√©s de Shrimp.  Mais nous sommes all√©s un peu plus compliqu√©: nous avons cr√©√© manuellement le soi-disant  r√©cepteur (c'est-√†-dire le canal o√π spdlog produira les messages g√©n√©r√©s), et pour les entit√©s Shrimp, ils ont cr√©√© des enregistreurs distincts attach√©s √† ce r√©cepteur. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     . [[nodiscard]] spdlog::sink_ptr make_logger_sink() { auto sink = std::make_shared&lt; spdlog::sinks::ansicolor_stdout_sink_mt &gt;(); return sink; } [[nodiscard]] std::shared_ptr&lt;spdlog::logger&gt; make_logger( const std::string &amp; name, spdlog::sink_ptr sink, spdlog::level::level_enum level = spdlog::level::trace ) { auto logger = std::make_shared&lt; spdlog::logger &gt;( name, std::move(sink) ); logger-&gt;set_level( level ); logger-&gt;flush_on( level ); return logger; } //        : auto manager = coop.make_agent_with_binder&lt; a_transform_manager_t &gt;( create_one_thread_disp( "manager" )-&gt;binder(), make_logger( "manager", logger_sink ) ); ... const auto worker_name = fmt::format( "worker_{}", worker ); auto transformer = coop.make_agent_with_binder&lt; a_transformer_t &gt;( create_one_thread_disp( worker_name )-&gt;binder(), make_logger( worker_name, logger_sink ), app_params.m_storage );</span></span></code> </pre><br>  Il y a un point subtil avec la configuration des enregistreurs dans spdlog: par d√©faut, l'enregistreur ignore les messages avec des niveaux de gravit√© de trace et de d√©bogage.  √Ä savoir, ils s'av√®rent √™tre plus utiles lors du d√©bogage.  Par cons√©quent, dans make_logger, nous activons par d√©faut la journalisation pour tous les niveaux, y compris le suivi / d√©bogage. <br><br>  √âtant donn√© que chaque entit√© de Shrimp a son propre enregistreur avec son propre nom, nous pouvons voir qui fait quoi dans le journal: <br><br><img src="https://habrastorage.org/webt/1o/jh/yx/1ojhyxgywovfstlfsybe19h0lb0.png"><br><br><h2>  Tra√ßage de SObjectizer avec spdlog </h2><br>  Les temps de journalisation, qui sont effectu√©s dans le cadre de la logique m√©tier principale d'une application SObjectizer, ne sont pas suffisants pour d√©boguer l'application.  Il n'est pas clair pourquoi une action est lanc√©e dans un agent, mais n'est pas r√©ellement effectu√©e dans un autre agent.  Dans ce cas, le m√©canisme msg_tracing int√©gr√© √† SObjectizer aide beaucoup (dont nous avons parl√© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">dans un article s√©par√©</a> ).  Mais parmi les impl√©mentations standard de msg_tracing pour SObjectizer, il n'y en a pas une qui utilise spdlog.  Nous ferons nous-m√™mes cette impl√©mentation pour Shrimp <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">spdlog_sobj_tracer_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::msg_tracing::<span class="hljs-keyword"><span class="hljs-keyword">tracer_t</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;spdlog::logger&gt; m_logger; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">spdlog_sobj_tracer_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;spdlog::logger&gt; logger ) : m_logger{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(logger) } {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; what )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> override </span></span>{ m_logger-&gt;trace( what ); } [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> so_5::msg_tracing::<span class="hljs-keyword"><span class="hljs-keyword">tracer_unique_ptr_t</span></span> make( spdlog::sink_ptr sink ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt;<span class="hljs-keyword"><span class="hljs-keyword">spdlog_sobj_tracer_t</span></span>&gt;( make_logger( <span class="hljs-string"><span class="hljs-string">"sobjectizer"</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(sink) ) ); } };</code> </pre> <br>  Nous voyons ici l'impl√©mentation de l'interface sp√©ciale SObjectizer tracer_t, dans laquelle l'essentiel est la m√©thode virtuelle trace ().  C'est lui qui effectue le tra√ßage des internes de SObjectizer au moyen de spdlog. <br><br>  Ensuite, cette impl√©mentation est install√©e en tant que traceur lors du d√©marrage de SObjectizer: <br><br><pre> <code class="cpp hljs">so_5::<span class="hljs-keyword"><span class="hljs-keyword">wrapped_env_t</span></span> sobj{ [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_t</span></span> &amp; env ) {...}, [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">environment_params_t</span></span> &amp; params ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">sobj_tracing_t</span></span>::on == sobj_tracing ) params.message_delivery_tracer( <span class="hljs-keyword"><span class="hljs-keyword">spdlog_sobj_tracer_t</span></span>::make( logger_sink ) ); } };</code> </pre> <br><h2>  RESTinio trace via spdlog </h2><br>  En plus de suivre ce qui se passe √† l'int√©rieur du SObjectizer, il peut parfois √™tre tr√®s utile de suivre ce qui se passe √† l'int√©rieur de RESTinio.  Dans la version mise √† jour de Shrimp, une telle trace est √©galement ajout√©e. <br><br>  Cette trace est impl√©ment√©e via la d√©finition d'une classe sp√©ciale qui peut effectuer la journalisation dans RESTinio: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">http_server_logger_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">http_server_logger_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;spdlog::logger&gt; logger ) : m_logger{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move( logger ) } {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">trace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Builder &amp;&amp; msg_builder )</span></span></span><span class="hljs-function"> </span></span>{ log_if_enabled( spdlog::level::trace, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Builder&gt;(msg_builder) ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">info</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Builder &amp;&amp; msg_builder )</span></span></span><span class="hljs-function"> </span></span>{ log_if_enabled( spdlog::level::info, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Builder&gt;(msg_builder) ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">warn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Builder &amp;&amp; msg_builder )</span></span></span><span class="hljs-function"> </span></span>{ log_if_enabled( spdlog::level::warn, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Builder&gt;(msg_builder) ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">error</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Builder &amp;&amp; msg_builder )</span></span></span><span class="hljs-function"> </span></span>{ log_if_enabled( spdlog::level::err, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::forward&lt;Builder&gt;(msg_builder) ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Builder &gt; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">log_if_enabled</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( spdlog::level::level_enum lv, Builder &amp;&amp; msg_builder )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_logger-&gt;should_log(lv) ) { m_logger-&gt;<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>( lv, msg_builder() ); } } <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;spdlog::logger&gt; m_logger; };</code> </pre> <br>  Cette classe n'est h√©rit√©e de rien, car le m√©canisme de journalisation dans RESTinio est bas√© sur une programmation g√©n√©ralis√©e, et non sur l'approche orient√©e objet traditionnelle.  Cela vous permet de vous d√©barrasser compl√®tement de toute surcharge dans les cas o√π la journalisation n'est pas du tout n√©cessaire (nous avons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">trait√©</a> ce sujet plus en d√©tail lorsque nous avons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">parl√© d'utiliser des mod√®les dans RESTinio</a> ). <br><br>  Ensuite, nous devons indiquer que le serveur HTTP utilisera la classe http_server_logger_t indiqu√©e ci-dessus comme enregistreur.  Cela se fait en clarifiant les propri√©t√©s du serveur HTTP: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">http_server_traits_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> restinio::<span class="hljs-keyword"><span class="hljs-keyword">default_traits_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">logger_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">http_server_logger_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">request_handler_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">http_req_router_t</span></span>; };</code> </pre> <br>  Eh bien, il ne reste plus rien √† faire - cr√©ez une instance sp√©cifique du spd-logger et envoyez cet enregistreur au serveur HTTP cr√©√©: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> restinio_logger = make_logger( <span class="hljs-string"><span class="hljs-string">"restinio"</span></span>, logger_sink, <span class="hljs-keyword"><span class="hljs-keyword">restinio_tracing_t</span></span>::off == restinio_tracing ? spdlog::level::off : log_level ); restinio::run( asio_io_ctx, shrimp::make_http_server_settings( thread_count.m_io_threads, params, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(restinio_logger), manager_mbox_promise.get_future().get() ) );</code> </pre> <br><h1>  v0.5: r√©initialisation forc√©e du cache d'image transform√© </h1><br>  Dans le processus de d√©bogage de Shrimp, une petite chose a √©t√© d√©couverte qui √©tait un peu g√™nante: pour vider le contenu du cache d'image transform√©, vous deviez red√©marrer l'int√©gralit√© de Shrimp.  Cela semblerait insignifiant, mais d√©sagr√©able. <br><br>  Si c'est d√©sagr√©able, alors vous devriez vous d√©barrasser de cette lacune.  Heureusement, ce n'est pas du tout difficile. <br><br>  Tout d'abord, nous allons d√©finir une autre URL dans Shrimp √† laquelle vous pouvez envoyer des requ√™tes HTTP DELETE: "/ cache".  En cons√©quence, nous accrocherons notre gestionnaire sur cette URL: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">unique_ptr</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">http_req_router_t</span></span> &gt; make_router( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">app_params_t</span></span> &amp; params, so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> req_handler_mbox ) { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> router = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_unique&lt; <span class="hljs-keyword"><span class="hljs-keyword">http_req_router_t</span></span> &gt;(); add_transform_op_handler( params, *router, req_handler_mbox ); add_delete_cache_handler( *router, req_handler_mbox ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> router; }</code> </pre> <br>  o√π la fonction add_delete_cache_handler () ressemble √† ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add_delete_cache_handler</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">http_req_router_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; router, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> req_handler_mbox )</span></span></span><span class="hljs-function"> </span></span>{ router.http_delete( <span class="hljs-string"><span class="hljs-string">"/cache"</span></span>, [req_handler_mbox]( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> req, <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-comment"><span class="hljs-comment">/*params*/</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> qp = restinio::parse_query( req-&gt;header().query() ); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> token = qp.get_param( <span class="hljs-string"><span class="hljs-string">"token"</span></span>sv ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !token ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> do_403_response( req, <span class="hljs-string"><span class="hljs-string">"No token provided\r\n"</span></span> ); } <span class="hljs-comment"><span class="hljs-comment">// Delegate request processing to transform_manager. so_5::send&lt; so_5::mutable_msg&lt;a_transform_manager_t::delete_cache_request_t&gt; &gt;( req_handler_mbox, req, restinio::cast_to&lt;std::string&gt;(*token) ); return restinio::request_accepted(); } ); }</span></span></code> </pre> <br>  Un peu bavard, mais rien de compliqu√©.  La cha√Æne de requ√™te de la requ√™te doit avoir un param√®tre de jeton.  Ce param√®tre doit contenir une cha√Æne avec une valeur sp√©ciale pour le jeton d'administration.  Vous ne pouvez r√©initialiser le cache que si la valeur du jeton du param√®tre token correspond √† ce qui a √©t√© d√©fini lors du lancement de Shrimp.  S'il n'y a pas de param√®tre de jeton, la demande de traitement n'est pas accept√©e.  S'il y a un jeton, alors l'agent transform_manager, propri√©taire du cache, re√ßoit un message de commande sp√©cial, en ex√©cutant lequel l'agent transform_manager lui-m√™me r√©pondra √† la requ√™te HTTP. <br><br>  Deuxi√®mement, nous impl√©mentons le nouveau gestionnaire de messages delete_cache_request_t dans l'agent transform_manager_t: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_delete_cache_request( <span class="hljs-keyword"><span class="hljs-keyword">mutable_mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">delete_cache_request_t</span></span>&gt; cmd ) { m_logger-&gt;warn( <span class="hljs-string"><span class="hljs-string">"delete cache request received; "</span></span> <span class="hljs-string"><span class="hljs-string">"connection_id={}, token={}"</span></span>, cmd-&gt;m_http_req-&gt;connection_id(), cmd-&gt;m_token ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> delay_response = [&amp;]( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> response_text ) { so_5::send_delayed&lt; so_5::mutable_msg&lt;<span class="hljs-keyword"><span class="hljs-keyword">negative_delete_cache_response_t</span></span>&gt; &gt;( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::seconds{<span class="hljs-number"><span class="hljs-number">7</span></span>}, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd-&gt;m_http_req), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(response_text) ); }; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> * env_token = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::getenv( <span class="hljs-string"><span class="hljs-string">"SHRIMP_ADMIN_TOKEN"</span></span> ); <span class="hljs-comment"><span class="hljs-comment">// Token must be present and must not be empty. env_token &amp;&amp; *env_token ) { if( cmd-&gt;m_token == env_token ) { m_transformed_cache.clear(); m_logger-&gt;info( "cache deleted" ); do_200_plaintext_response( std::move(cmd-&gt;m_http_req), "Cache deleted\r\n" ); } else { m_logger-&gt;error( "invalid token value for delete cache request; " "token={}", cmd-&gt;m_token ); delay_response( "Token value mismatch\r\n" ); } } else { m_logger-&gt;warn( "delete cache can't performed because there is no " "admin token defined" ); // Operation can't be performed because admin token is not avaliable. delay_response( "No admin token defined\r\n" ); } }</span></span></code> </pre> <br>  Il y a deux points ici qui devraient √™tre clarifi√©s. <br><br>  Le premier point dans l'impl√©mentation de on_delete_cache_request () est la v√©rification de la valeur du jeton elle-m√™me.  Le jeton d'administration est d√©fini via la variable d'environnement SHRIMP_ADMIN_TOKEN.  Si cette variable est d√©finie et que sa valeur correspond √† la valeur du param√®tre de jeton de la demande HTTP DELETE, le cache est effac√© et une r√©ponse positive √† la demande est imm√©diatement g√©n√©r√©e. <br><br>  Et le deuxi√®me point dans l'impl√©mentation de on_delete_cache_request () est le retard forc√© d'une r√©ponse n√©gative √† HTTP DELETE.  Si la mauvaise valeur du jeton d'administration est arriv√©e, vous devez retarder la r√©ponse √† HTTP DELETE afin de ne pas vouloir s√©lectionner la valeur du jeton par force brute.  Mais comment faire ce retard?  Apr√®s tout, appeler std :: thread :: sleep_for () n'est pas une option. <br><br>  C'est l√† que les messages en attente de SObjectizer viennent √† la rescousse.  Au lieu de g√©n√©rer imm√©diatement une r√©ponse n√©gative dans on_delete_cache_request (), l'agent transform_manager s'envoie simplement un message negative_delete_cache_response_t en attente.  Le temporisateur SObjectizer comptera le temps d√©fini et remettra ce message √† l'agent une fois le d√©lai sp√©cifi√© √©coul√©.  Et maintenant, dans le gestionnaire negative_delete_cache_response_t, vous pouvez d√©j√† g√©n√©rer imm√©diatement une r√©ponse √† la demande HTTP DELETE: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">a_transform_manager_t</span></span>::on_negative_delete_cache_response( <span class="hljs-keyword"><span class="hljs-keyword">mutable_mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">negative_delete_cache_response_t</span></span>&gt; cmd ) { m_logger-&gt;debug( <span class="hljs-string"><span class="hljs-string">"send negative response to delete cache request; "</span></span> <span class="hljs-string"><span class="hljs-string">"connection_id={}"</span></span>, cmd-&gt;m_http_req-&gt;connection_id() ); do_403_response( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd-&gt;m_http_req), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(cmd-&gt;m_response_text) ); }</code> </pre> <br>  C'est-√†-dire  il s'av√®re que le sc√©nario suivant: <br><br><ul><li>  Le serveur HTTP re√ßoit une demande HTTP DELETE, convertit cette demande en un message delete_cache_request_t √† l'agent transform_manager; </li><li>  l'agent transform_manager re√ßoit le message delete_cache_request_t et g√©n√®re imm√©diatement une r√©ponse positive √† la demande ou s'envoie un message en attente negative_delete_cache_response_t; </li><li>  transform_manager re√ßoit un message negative_delete_cache_response_t et g√©n√®re imm√©diatement une r√©ponse n√©gative √† la requ√™te HTTP DELETE correspondante. </li></ul><br><h1>  Fin de la deuxi√®me partie </h1><br>  √Ä la fin de la deuxi√®me partie, il est tout √† fait naturel de se poser la question: "Et ensuite?" <br><br>  De plus, il y aura probablement une autre it√©ration et une autre mise √† jour de notre projet de d√©monstration.  Je voudrais faire une chose telle que convertir une image d'un format √† un autre.  Disons que sur le serveur, l'image est en jpg, et apr√®s la transformation, elle est envoy√©e au client en webp. <br><br>  Il serait √©galement int√©ressant de joindre une "page" s√©par√©e avec l'affichage des statistiques actuelles sur le travail de la crevette.  Tout d'abord, c'est juste curieux.  Mais, en principe, une telle page peut √©galement √™tre adapt√©e aux besoins du suivi de la viabilit√© des crevettes. <br><br>  Si quelqu'un d'autre a des suggestions sur ce que j'aimerais voir dans Shrimp ou dans des articles sur Shrimp, alors nous serons heureux d'entendre des r√©flexions constructives. <br><br>  Par ailleurs, je tiens √† souligner un aspect de la mise en ≈ìuvre de la crevette, qui nous a quelque peu surpris.  Il s'agit d'une utilisation active des messages mutables lors de la communication entre eux et avec le serveur HTTP.  Habituellement, dans notre pratique, c'est le contraire qui se produit - le plus souvent, les donn√©es sont √©chang√©es via des messages immunitaires.  Ce n'est pas le cas ici.  Cela sugg√®re que nous avons sciemment √©cout√© les souhaits des utilisateurs en temps voulu et ajout√© des messages modifiables √† SObjectizer.  Donc, si vous souhaitez voir quelque chose dans RESTinio ou SObjectizer, n'h√©sitez pas √† partager vos id√©es.  Nous sommes s√ªrs d'√©couter les bons. <br><br>  Eh bien, et en conclusion, je tiens √† remercier tous ceux qui ont pris le temps de parler de la premi√®re version de Shrimp, √† la fois ici sur Habr√© et √† travers d'autres ressources.  Je vous remercie! <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√Ä suivre ...</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr417527/">https://habr.com/ru/post/fr417527/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr417511/index.html">Intel acquiert eASIC - D√©veloppeur structurel ASIC</a></li>
<li><a href="../fr417513/index.html">Analogues en Python et JavaScript. Deuxi√®me partie</a></li>
<li><a href="../fr417515/index.html">Ce que j'ai appris en cr√©ant 100 jeux en 5 ans</a></li>
<li><a href="../fr417517/index.html">Pages de l'histoire d'Intel. Chronique photo et quiz</a></li>
<li><a href="../fr417521/index.html">Examiner les certificats SSL pour la r√©vocation</a></li>
<li><a href="../fr417529/index.html">Trois tendances technologiques qui changent le commerce et le consommateur</a></li>
<li><a href="../fr417531/index.html">Comment nous avons gagn√© dans SmartMailHack 2</a></li>
<li><a href="../fr417533/index.html">Bloc-notes sur Windows a re√ßu la premi√®re mise √† jour importante en deux d√©cennies</a></li>
<li><a href="../fr417535/index.html">Le d√©veloppement de CUBA est-il un grand pas loin du printemps?</a></li>
<li><a href="../fr417537/index.html">"Votre jeu est ennuyeux", ou comment augmenter la r√©tention d√©j√† √©lev√©e du premier jour</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>