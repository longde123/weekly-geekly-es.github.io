<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍✈️ ⚰️ 👩🏿‍🌾 Dank WebAssembly können Sie Frontend on Go schreiben 👃🏾 🚆 🏴</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Originalartikel . 

 Im Februar 2017 schlug ein Mitglied des go Brad Fitzpatrick-Teams vor , WebAssembly in der Sprache zu unterstützen. Vier Monate s...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Dank WebAssembly können Sie Frontend on Go schreiben</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/417563/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Originalartikel</a> . <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ww/az/mf/wwazmfemkd6qhegdxrzeabctnxk.jpeg"></div><br>  Im Februar 2017 schlug ein Mitglied des go Brad Fitzpatrick-Teams <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vor</a> , WebAssembly in der Sprache zu unterstützen.  Vier Monate später, im November 2017, begann der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GopherJS-</a> Autor Richard Muziol, die Idee umzusetzen.  Und schließlich wurde die vollständige Implementierung in master gefunden.  Entwickler erhalten um August 2018 wasm mit <a href="">go</a> Version <a href="">1.11</a> .  Infolgedessen übernimmt die Standardbibliothek fast alle technischen Schwierigkeiten beim Importieren und Exportieren von Funktionen, die Ihnen bekannt sind, wenn Sie bereits versucht haben, C in wasm zu kompilieren.  Das klingt vielversprechend.  Mal sehen, was mit der ersten Version gemacht werden kann. <br><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/de1/415/41d/de141541d13f83b05f9e3412d1961868.png"></div><br><br>  Alle Beispiele in diesem Artikel können aus Docker-Containern gestartet werden, die sich <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Repository des Autors befinden</a> : <br><br><pre><code class="bash hljs">﻿docker container run -dP nlepage/golang_wasm:examples <span class="hljs-comment"><span class="hljs-comment"># Find out which host port is used docker container ls</span></span></code> </pre> <br>  Gehen Sie dann zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">localhost</a> : 32XXX / und wechseln Sie von einem Link zum anderen. <br><br><h3>  Hallo Wasm! </h3><br>  Die Entstehung der grundlegenden „Hallo Welt“ und das Konzept sind bereits recht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gut dokumentiert</a> (auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">auf Russisch</a> ). Kommen wir also zu den subtileren Dingen. <br><br>  Am wichtigsten ist eine frisch kompilierte Version von Go, die wasm unterstützt.  Ich werde <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">die Installation</a> nicht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Schritt für Schritt beschreiben</a> , sondern nur wissen, dass das, was benötigt wird, bereits im Master vorhanden ist. <br><br>  Wenn Sie sich darüber keine Sorgen machen möchten, ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dockerfile c go</a> im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">golub-wasm-Repository auf github verfügbar</a> , oder Sie können ein Bild von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nlepage / golang_wasm</a> noch schneller aufnehmen. <br><br>  Jetzt können Sie die traditionelle <code>helloworld.go</code> schreiben und mit dem folgenden Befehl kompilieren: <br><br><pre> <code class="bash hljs">﻿GOOS=js GOARCH=wasm go build -o test.wasm helioworld.go</code> </pre><br>  Die Umgebungsvariablen GOOS und GOARCH sind bereits im Bild <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nlepage / golang_wasm festgelegt</a> , sodass Sie eine <code>Dockerfile</code> Datei wie diese zum Kompilieren verwenden können: <br><br><pre> <code class="hljs go">FROM nlepage/golang_wasm COPY helloworld.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span> /<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>/src/hello/ RUN <span class="hljs-keyword"><span class="hljs-keyword">go</span></span> build -o test.wasm hello</code> </pre><br>  Der letzte Schritt besteht darin, die Dateien <code>wasm_exec.html</code> und <code>wasm_exec.js</code> verwenden, die im go-Repository im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code> misc/wasm</code></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">misc / wasm</a> oder im Docker-Image <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nlepage / golang_wasm</a> im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verzeichnis</a> <code>/usr/local/go/misc/wasm/</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">misc / wasm / verfügbar sind</a> , um <code>test.wasm</code> browser (wasm_exec.js erwartet die Binärdatei <code>test.wasm</code> , daher verwenden wir diesen Namen). <br>  Sie müssen nur 3 statische Dateien mit nginx angeben, dann zeigt wasm_exec.html die Schaltfläche "Ausführen" an (sie wird nur <code>test.wasm</code> wenn <code>test.wasm</code> korrekt geladen ist). <br><br>  Es ist bemerkenswert, dass <code>test.wasm</code> mit der <code>application/wasm</code> <code>test.wasm</code> vom Typ MIME <code>test.wasm</code> muss, da der Browser sonst die Ausführung verweigert.  (z. B. benötigt nginx eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aktualisierte Datei mime.types</a> ). <br><br>  Sie können das nginx-Image aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">nlepage / golang_wasm verwenden</a> , das bereits den festen MIME-Typ <code>wasm_exec.html</code> und <code>wasm_exec.js</code> im Code&gt; / usr / share / nginx / html / directory enthält. <br><br>  Klicken Sie nun auf die Schaltfläche "Ausführen", öffnen Sie Ihre Browserkonsole und Sie sehen die Begrüßung console.log ("Hallo Wasm!"). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb1/3fe/587/cb13fe587331b2426368ea541f22c61b.png"></div><br>  Ein vollständiges Beispiel finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> . <br><br><h3>  Rufen Sie JS von Go an </h3><br>  Nachdem wir die erste aus Go kompilierte WebAssembly-Binärdatei erfolgreich gestartet haben, schauen wir uns die bereitgestellten Funktionen genauer an. <br><br>  Das neue Paket syscall / js wurde der Standardbibliothek hinzugefügt. Betrachten Sie die Hauptdatei <code><a href="">js.go</a></code> <br>  Es ist ein neuer <code>js.Value</code> Typ <code>js.Value</code> , der einen JavaScript-Wert darstellt. <br><br>  Es bietet eine einfache API zum Verwalten von JavaScript-Variablen: <br><br><ul><li>  <code>js.Value.Get()</code> und <code>js.Value.Set()</code> geben die Feldwerte des Objekts zurück und legen sie fest. </li><li>  <code>js.Value.Index()</code> und <code>js.Value.SetIndex()</code> greifen über den Lese- und <code>js.Value.SetIndex()</code> auf das Objekt zu. </li><li>  <code>js.Value.Call()</code> ruft die Objektmethode als Funktion auf. </li><li>  <code>js.Value.Invoke()</code> ruft das Objekt selbst als Funktion auf. </li><li>  <code>js.Value.New()</code> ruft den neuen Operator auf und verwendet sein eigenes Wissen als Konstruktor. </li><li>  Einige weitere Methoden, um den JavaScript-Wert im entsprechenden Go-Typ <code>js.Value.Int()</code> , z. B. <code>js.Value.Int()</code> oder <code>js.Value.Bool()</code> . </li></ul><br>  Und weitere interessante Methoden: <br><br><ul><li>  <code>js.Undefined()</code> gibt js.Value das entsprechende <code>undefined</code> . </li><li>  <code>js.Null()</code> gibt <code>js.Value</code> entsprechende <code>null</code> . </li><li>  <code>js.Global()</code> gibt <code>js.Value</code> und <code>js.Value</code> Zugriff auf den globalen Bereich. </li><li>  <code>js.ValueOf()</code> akzeptiert primitive Go-Typen und gibt den korrekten <code>js.Value</code> </li></ul><br>  Anstatt die Nachricht in os.StdOut anzuzeigen, zeigen wir sie im Benachrichtigungsfenster mit <code>window.alert()</code> . <br><br>  Da wir uns im Browser befinden, ist der globale Bereich ein Fenster. Sie müssen also zuerst alert () vom globalen Bereich abrufen: <br><br><pre> <code class="go hljs">alert := js.Global().Get(<span class="hljs-string"><span class="hljs-string">"alert"</span></span>)</code> </pre><br>  Jetzt haben wir eine <code>js.Value</code> in Form von <code>js.Value</code> , die auf <code>window.alert</code> JS <code>window.alert</code> , und Sie können die Funktion verwenden, um <code>js.Value.Invoke()</code> : <br><br><pre> <code class="go hljs">alert.Invoke(<span class="hljs-string"><span class="hljs-string">"Hello wasm!"</span></span>)</code> </pre><br>  Wie Sie sehen, muss js.ValueOf () nicht aufgerufen werden, bevor die Argumente an Invoke übergeben werden. Es wird eine beliebige Menge an <code>interface{}</code> und die Werte werden über ValueOf selbst übergeben. <br><br>  Jetzt sollte unser neues Programm so aussehen: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"syscall/js"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { alert := js.Global().Get(<span class="hljs-string"><span class="hljs-string">"alert"</span></span>) alert.Invoke(<span class="hljs-string"><span class="hljs-string">"Hello Wasm!"</span></span>) }</code> </pre><br>  Wie im ersten Beispiel müssen Sie nur eine Datei mit dem Namen <code>test.wasm</code> erstellen und <code>wasm_exec.html</code> und <code>wasm_exec.js</code> lassen. <br>  Wenn wir nun auf die Schaltfläche "Ausführen" klicken, wird ein Warnfenster mit unserer Nachricht angezeigt. <br><br>  Ein funktionierendes Beispiel befindet sich im Ordner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>examples/js-call</code></a> . <br><br><h3>  Rufen Sie Go von JS an. </h3><br>  Das Aufrufen von JS von Go aus ist ziemlich einfach. Schauen wir uns das Paket <code>syscall/js</code> an. Die zweite Datei, die <code>syscall/js</code> , ist <a href=""><code>callback.go</code></a> . <br><br><ul><li>  <code>js.Callback</code> Wrapper-Typ für die Go-Funktion zur Verwendung in JS. </li><li>  <code>js.NewCallback()</code> Funktion, die eine Funktion übernimmt (ein Stück <code>js.Value</code> akzeptiert und nichts zurückgibt) und <code>js.Callback</code> . </li><li>  Einige Mechanismen zum Verwalten aktiver Rückrufe und <code>js.Callback.Release()</code> , die aufgerufen werden müssen, um den Rückruf zu zerstören. </li><li>  <code>js.NewEventCallback()</code> ähnelt <code>js.NewCallback()</code> , aber die <code>js.NewCallback()</code> Funktion akzeptiert nur 1 Argument - ein Ereignis. </li></ul><br>  Versuchen wir etwas Einfaches: Führen Sie Go <code>fmt.Println()</code> von der JS-Seite aus. <br><br>  Wir werden einige Änderungen an <code>wasm_exec.html</code> , um einen Rückruf von Go zu erhalten, um ihn aufzurufen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.clear(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> go.run(inst); inst = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> WebAssembly.instantiate(mod, go.ImportObject); <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre><br>  Dadurch wird die wasm-Binärdatei gestartet und auf ihren Abschluss gewartet. Anschließend wird sie für den nächsten Lauf neu initialisiert. <br><br>  Fügen wir eine neue Funktion hinzu, die den Go-Rückruf empfängt und speichert und den Status des <code>Promise</code> nach Abschluss ändert: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> printMessage <span class="hljs-comment"><span class="hljs-comment">// Our reference to the Go callback let printMessageReceived // Our promise let resolvePrintMessageReceived // Our promise resolver function setPrintMessage(callback) { printMessage = callback resolvePrintMessageReceived() }</span></span></code> </pre><br>  Passen wir nun die Funktion <code>run()</code> an, um den Rückruf zu verwenden: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.clear() <span class="hljs-comment"><span class="hljs-comment">// Create the Promise and store its resolve function printMessageReceived = new Promise(resolve =&gt; { resolvePrintMessageReceived = resolve }) const run = go.run(inst) // Start the wasm binary await printMessageReceived // Wait for the callback reception printMessage('Hello Wasm!') // Invoke the callback await run // Wait for the binary to terminate inst = await WebAssembly.instantiate(mod, go.importObject) // reset instance }</span></span></code> </pre><br>  Und das ist auf der Seite von JS! <br><br>  Jetzt müssen Sie im Go-Teil einen Rückruf erstellen, ihn an die JS-Seite senden und warten, bis die Funktion benötigt wird. <br><br><pre> <code class="go hljs"> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> done = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{})</code> </pre><br>  Dann sollten sie die eigentliche Funktion <code>printMessage()</code> schreiben: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args []js.Value)</span></span></span></span> { message := args[<span class="hljs-number"><span class="hljs-number">0</span></span>].Strlng() fmt.Println(message) done &lt;- <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{}{} <span class="hljs-comment"><span class="hljs-comment">// Notify printMessage has been called }</span></span></code> </pre><br>  Die Argumente werden durch das Slice <code>[]js.Value</code> , daher müssen Sie <code>js.Value.String()</code> für das erste Slice-Element aufrufen, um die Nachricht in der Go-Zeile <code>js.Value.String()</code> . <br>  Jetzt können wir diese Funktion in einen Rückruf einschließen: <br><br><pre> <code class="go hljs">callback := js.NewCallback(printMessage) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> callback.Release() <span class="hljs-comment"><span class="hljs-comment">// to defer the callback releasing is a good practice</span></span></code> </pre><br>  Rufen Sie dann die JS-Funktion <code>setPrintMessage()</code> , genau wie beim Aufrufen von <code>window.alert()</code> : <br><br><pre> <code class="go hljs">setPrintMessage := js.Global.Get(<span class="hljs-string"><span class="hljs-string">"setPrintMessage"</span></span>) setPrintMessage.Invoke(callback)</code> </pre><br>  Als letztes müssen Sie warten, bis der Rückruf in main aufgerufen wird: <br><br><pre> <code class="go hljs">&lt;-done</code> </pre><br>  Dieser letzte Teil ist wichtig, da die Rückrufe in einer dedizierten Goroutine ausgeführt werden und die Hauptgoroutine auf den Aufruf des Rückrufs warten muss, da sonst die wasm-Binärdatei vorzeitig gestoppt wird. <br><br>  Das resultierende Go-Programm sollte folgendermaßen aussehen: <br><br><pre> <code class="go hljs">﻿<span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"syscall/js"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> done = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{}) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { callback := js.NewCallback(prtntMessage) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> callback.Release() setPrintMessage := js.Global().Get(<span class="hljs-string"><span class="hljs-string">"setPrintMessage"</span></span>) setPrIntMessage.Invoke(callback) &lt;-done } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args []js.Value)</span></span></span></span> { message := args[<span class="hljs-number"><span class="hljs-number">0</span></span>].Strlng() fmt.PrintIn(message) done &lt;- <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{}{} }</code> </pre><br>  Erstellen Sie wie in den vorherigen Beispielen eine Datei mit dem Namen <code>test.wasm</code> .  Wir müssen auch <code>wasm_exec.html</code> durch unsere Version ersetzen und können <code>wasm_exec.js</code> wiederverwenden. <br><br>  Wenn Sie nun wie in unserem ersten Beispiel auf die Schaltfläche "Ausführen" klicken, wird die Nachricht in der Browserkonsole gedruckt, diesmal jedoch viel besser!  (Und schwerer.) <br><br>  Ein funktionierendes Beispiel in einem Docker-Datei-Gebot finden Sie im Ordner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>examples/go-call</code></a> . <br><br><h3>  Lange Arbeit </h3><br>  Das Aufrufen von Go von JS aus ist etwas umständlicher als das Aufrufen von JS von Go aus, insbesondere auf der JS-Seite. <br><br>  Dies liegt hauptsächlich an der Tatsache, dass Sie warten müssen, bis das Ergebnis des Go-Rückrufs an die JS-Seite übergeben wird. <br><br>  Versuchen wir etwas anderes: Warum nicht die Wasm-Binärdatei organisieren, die nicht direkt nach dem Rückruf endet, sondern weiterhin funktioniert und andere Aufrufe annimmt? <br>  Beginnen wir dieses Mal von der Go-Seite, und wie in unserem vorherigen Beispiel müssen wir einen Rückruf erstellen und an die JS-Seite senden. <br><br>  Fügen Sie einen Anrufzähler hinzu, um zu verfolgen, wie oft die Funktion aufgerufen wurde. <br><br>  Unsere neue Funktion <code>printMessage()</code> druckt die empfangene Nachricht und den <code>printMessage()</code> : <br><br><pre> <code class="go hljs">﻿<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> no <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args []js.Value)</span></span></span></span> { message := args[<span class="hljs-number"><span class="hljs-number">0</span></span>].String() no++ fmt.Printf(<span class="hljs-string"><span class="hljs-string">"Message no %d: %s\n"</span></span>, no, message) }</code> </pre><br>  Das Erstellen eines Rückrufs und das Senden an die JS-Seite erfolgt wie im vorherigen Beispiel: <br><br><pre> <code class="go hljs">﻿callback := js.NewCallback(printMessage) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> callback.Release() setPrintMessage := js.Global().Get(<span class="hljs-string"><span class="hljs-string">"setPrintMessage"</span></span>) setPrIntMessage.Invoke(callback)</code> </pre><br>  Diesmal haben wir jedoch keinen Kanal eingerichtet, um uns über die Beendigung der Hauptgoroutine zu informieren.  Eine Möglichkeit könnte darin bestehen, das Haupt-Goroutin dauerhaft mit der leeren <code>select{}</code> zu sperren: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span>{}</code> </pre><br>  Dies ist nicht zufriedenstellend. Unser Binär-Wasm bleibt nur im Speicher hängen, bis die Browser-Registerkarte geschlossen wird. <br><br>  Sie können das Ereignis vor dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>beforeunload</code></a> auf der Seite anhören. Sie benötigen einen zweiten Rückruf, um das Ereignis zu empfangen und die Haupt-Goroutine über den Kanal zu benachrichtigen: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> beforeUnloadCh = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{})</code> </pre><br>  Dieses Mal akzeptiert die neue Funktion <code>beforeUnload()</code> das Ereignis nur als einzelnes <code>js.Value</code> Argument: <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">beforeUnload</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event js.Value)</span></span></span></span> { beforeUnloadCh &lt;- <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{}{} }</code> </pre><br>  Wickeln Sie es dann mit <code>js.NewEventCallback()</code> in einen Rückruf ein und registrieren Sie es auf der JS-Seite: <br><br><pre> <code class="go hljs">beforeUnloadCb := js.NewEventCallback(<span class="hljs-number"><span class="hljs-number">0</span></span>, beforeUnload) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> beforeUnloadCb.Release() addEventLtstener := js.Global().Get(<span class="hljs-string"><span class="hljs-string">"addEventListener"</span></span>) addEventListener.Invoke(<span class="hljs-string"><span class="hljs-string">"beforeunload"</span></span>, beforeUnloadCb)</code> </pre><br>  Ersetzen Sie <code>beforeUnloadCh</code> die leere Blockierungsauswahl durch Lesen aus dem <code>beforeUnloadCh</code> Kanal: <br><br><pre> <code class="go hljs">&lt;-beforeUnloadCh fmt.Prtntln(<span class="hljs-string"><span class="hljs-string">"Bye Wasm!"</span></span>)</code> </pre><br>  Das endgültige Programm sieht folgendermaßen aus: <br><br><pre> <code class="go hljs">﻿<span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"syscall/js"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( no <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> beforeUnloadCh = <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">chan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{}) ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { callback := js.NewCallback(printMessage) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> callback.Release() setPrintMessage := js.Global().Get(<span class="hljs-string"><span class="hljs-string">"setPrintMessage"</span></span>) setPrIntMessage.Invoke(callback) beforeUnloadCb := js.NewEventCallback(<span class="hljs-number"><span class="hljs-number">0</span></span>, beforeUnload) <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> beforeUnloadCb.Release() addEventLtstener := js.Global().Get(<span class="hljs-string"><span class="hljs-string">"addEventListener"</span></span>) addEventListener.Invoke(<span class="hljs-string"><span class="hljs-string">"beforeunload"</span></span>, beforeUnloadCb) &lt;-beforeUnloadCh fmt.Prtntln(<span class="hljs-string"><span class="hljs-string">"Bye Wasm!"</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">printMessage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args []js.Value)</span></span></span></span> { message := args[<span class="hljs-number"><span class="hljs-number">0</span></span>].String() no++ fmt.Prtntf(<span class="hljs-string"><span class="hljs-string">"Message no %d: %s\n"</span></span>, no, message) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">beforeUnload</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(event js.Value)</span></span></span></span> { beforeUnloadCh &lt;- <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span>{}{} }</code> </pre><br>  Bisher sah der Download der wasm-Binärdatei auf der JS-Seite folgendermaßen aus: <br><br><pre> <code class="javascript hljs">﻿<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> go = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Go() <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> mod, inst WebAssembly .instantiateStreaming(fetch(<span class="hljs-string"><span class="hljs-string">"test.wasm"</span></span>), go.importObject) .then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { mod = result.module inst = result.Instance <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">"runButton"</span></span>).disabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span> })</code> </pre><br>  Passen wir es an, um die Binärdatei unmittelbar nach dem Laden auszuführen: <br><br><pre> <code class="javascript hljs">﻿(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> go = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Go() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { instance } = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> WebAssembly.instantiateStreaming( fetch(<span class="hljs-string"><span class="hljs-string">"test.wasm"</span></span>), go.importObject ) go.run(instance) })()</code> </pre><br>  Ersetzen Sie die Schaltfläche "Ausführen" durch ein Nachrichtenfeld und eine Schaltfläche zum Aufrufen von <code>printMessage()</code> : <br><br><pre> <code class="xml hljs">﻿<span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"messageInput"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">value</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Hello Wasm!"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"printMessage(document.querySelector('#messagelnput').value);"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"prtntMessageButton"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">disabled</span></span></span><span class="hljs-tag">&gt;</span></span> Print message <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Schließlich sollte die Funktion <code>setPrintMessage()</code> , die den Rückruf akzeptiert und speichert, einfacher sein: <br><br><pre> <code class="javascript hljs">﻿<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> printMessage; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setPrintMessage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">) </span></span>{ printMessage = callback; <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.querySelector(<span class="hljs-string"><span class="hljs-string">'#printMessageButton'</span></span>).disabled = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; }</code> </pre><br>  Wenn wir jetzt auf die Schaltfläche "Nachricht drucken" klicken, sollten Sie eine Nachricht unserer Wahl und einen Anrufzähler in der Browserkonsole sehen. <br>  Wenn wir das Kontrollkästchen "Beibehalten" der Browserkonsole aktivieren und die Seite aktualisieren, wird die Meldung "Bye Wasm!" Angezeigt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6c3/676/63d/6c367663d28d90535ccaafd1c10b5f50.png"></div><br><br>  Quellen finden Sie im Ordner <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><code>examples/long-running</code></a> auf github. <br><br><h3>  Und weiter? </h3><br>  Wie Sie sehen können, <code>syscall/js</code> die erlernte <code>syscall/js</code> API ihre Aufgabe und ermöglicht es Ihnen, komplexe Dinge mit ein bisschen Code zu schreiben.  Sie können an den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Autor</a> schreiben, wenn Sie eine einfachere Methode kennen. <br>  Es ist derzeit nicht möglich, einen Wert direkt aus dem Go-Rückruf an JS zurückzugeben. <br>  Beachten Sie, dass alle Rückrufe im selben Goroutin ausgeführt werden. Wenn Sie also einige Blockierungsvorgänge im Rückruf ausführen, vergessen Sie nicht, ein neues Goroutin zu erstellen. Andernfalls blockieren Sie die Ausführung aller anderen Rückrufe. <br>  Alle grundlegenden Sprachfunktionen sind bereits verfügbar, einschließlich der Parallelität.  Im Moment werden alle Goroutins in einem Thread funktionieren, aber dies <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wird sich in Zukunft ändern</a> . <br>  In unseren Beispielen haben wir nur das fmt-Paket aus der Standardbibliothek verwendet, aber es ist alles verfügbar, was nicht versucht, aus der Sandbox zu entkommen. <br><br>  Das Dateisystem scheint über Node.js unterstützt zu werden. <br><br>  Was ist schließlich mit der Leistung?  Es wäre interessant, einige Tests durchzuführen, um zu sehen, wie Go wasm mit äquivalentem reinem JS-Code verglichen wird.  Jemand <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hajimehoshi</a> hat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gemessen</a> , wie verschiedene Umgebungen mit ganzen Zahlen funktionieren, aber die Technik ist nicht sehr klar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae0/e5b/ab5/ae0e5bab565640331a956284e94f4859.jpg"></div><br><br>  Vergessen Sie nicht, dass Go 1.11 noch nicht offiziell veröffentlicht wurde.  Meiner Meinung nach ist es sehr gut für experimentelle Technologie.  Wer an Leistungstests interessiert ist, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kann seinen Browser quälen</a> . <br>  Die Hauptnische ist, wie der Autor feststellt, die Übertragung des vorhandenen Go-Codes vom Server zum Client.  Mit neuen Standards können Sie jedoch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vollständig Offline-Anwendungen erstellen</a> , und der Wasm-Code wird in kompilierter Form gespeichert.  Sie können viele Dienstprogramme bequem ins Internet übertragen, stimmen Sie zu? </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de417563/">https://habr.com/ru/post/de417563/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de417553/index.html">Offenes Webinar "CSS-Präprozessoren"</a></li>
<li><a href="../de417555/index.html">Frachtkult-Seminar in Moskau angekündigt: Marketing schlägt zurück</a></li>
<li><a href="../de417557/index.html">Übersicht über Laser-CNC-Maschinen LaserSolid</a></li>
<li><a href="../de417559/index.html">Wie China Apple dazu brachte, iCloud-Benutzerverschlüsselungsschlüssel auf staatlichen chinesischen Servern zu speichern</a></li>
<li><a href="../de417561/index.html">Call of the Date oder wie war der zweite Mail.Ru Mail Hackathon?</a></li>
<li><a href="../de417565/index.html">Google wird ein privates Kabel über den Atlantik verlegen</a></li>
<li><a href="../de417569/index.html">Unit-Testing-Datenbank-Skripte</a></li>
<li><a href="../de417571/index.html">Mehrarmige Banditen in Empfehlungen</a></li>
<li><a href="../de417573/index.html">Weltberühmte KI-Entwickler stimmen zu, keine intelligenten Waffen zu entwickeln</a></li>
<li><a href="../de417577/index.html">CNC-Maschinen, die es wert sind, von 3Dtool beachtet zu werden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>