<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏏 👩🏽‍🍳 👩🏿‍💻 Aspecto Dinámico Orientado ♉️ 🏏 👸🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Una historia sobre un modelo de tema específico, donde muchos valores de campo válidos dependen de los valores de otros. 

 Desafío 
 Es más fácil des...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Aspecto Dinámico Orientado</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472598/">  Una historia sobre un modelo de tema específico, donde muchos valores de campo válidos dependen de los valores de otros. <br><br><h3>  Desafío </h3><br>  Es más fácil desmontar usando un ejemplo específico: es necesario configurar sensores con muchos parámetros, pero los parámetros dependen unos de otros.  Por ejemplo, el umbral de respuesta depende del tipo de sensor, modelo y sensibilidad, y los posibles modelos dependen del tipo de sensor, etc. <br><a name="habracut"></a><br>  En nuestro ejemplo, tomamos solo el tipo de sensor y su valor (el umbral en el que debe activarse). <br><br><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Sensor</span></span> { <span class="hljs-comment"><span class="hljs-comment">// Voltage, Temperature public SensorType Type { get; internal set; } //-400..400 for Voltage, 200..600 for Temperature public decimal Value { get; internal set; } }</span></span></code> </pre> <br>  Asegúrese de que para los sensores de voltaje y temperatura los valores solo pueden estar en los rangos -400..400 y 200..600, respectivamente.  Todos los cambios pueden ser rastreados y registrados. <br><br><h3>  La solución "simple" </h3><br>  La implementación más fácil para mantener la consistencia de los datos es establecer manualmente restricciones y dependencias en los establecedores y captadores: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Sensor</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> SensorType _type; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span> _value; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SensorType Type { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _type; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { _type = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> == SensorType.Temperature) Value = <span class="hljs-number"><span class="hljs-number">273</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">value</span></span> == SensorType.Voltage) Value = <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span> Value { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> _value; } <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Type == SensorType.Temperature &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &gt;= <span class="hljs-number"><span class="hljs-number">200</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">600</span></span> || Type == SensorType.Voltage &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &gt;= <span class="hljs-number"><span class="hljs-number">-400</span></span> &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> &lt;= <span class="hljs-number"><span class="hljs-number">400</span></span>) _value = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } }</code> </pre><br>  Una dependencia genera una gran cantidad de código que es difícil de leer.  Cambiar las condiciones o agregar nuevas dependencias es difícil. <br><br><img src="https://habrastorage.org/webt/0u/sw/ba/0uswba-hojjbqtr9nes1dnfu6rw.png" alt="imagen"><br><br>  En un proyecto real, dichos objetos tenían más de 30 campos dependientes y más de 200 reglas para cada uno.  La solución descrita, aunque funciona, traería un gran dolor de cabeza en el desarrollo y soporte de dicho sistema. <br><br><h3>  "Ideal" pero irreal </h3><br>  Las reglas se describen fácilmente en formas cortas y se pueden colocar al lado de los campos con los que se relacionan.  Idealmente: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Sensor</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SensorType Type { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } [Number(Type = SensorType.Temperature, Min = <span class="hljs-number"><span class="hljs-number">200</span></span>, Max = <span class="hljs-number"><span class="hljs-number">600</span></span>, Force = <span class="hljs-number"><span class="hljs-number">273</span></span>)] [Number(Type = SensorType.Voltage, Min = <span class="hljs-number"><span class="hljs-number">-400</span></span>, Max = <span class="hljs-number"><span class="hljs-number">400</span></span>, Force = <span class="hljs-number"><span class="hljs-number">0</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span> Value { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre><br>  La fuerza es qué valor establecer si la condición cambia. <br><br>  Solo la sintaxis de C # no permitirá escribir esto en los atributos, ya que la lista de campos de los que depende la propiedad de destino no está predefinida. <br><br><h3>  Enfoque de trabajo </h3><br>  Escribiremos las reglas de la siguiente manera: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Sensor</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SensorType Type { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } [Number(<span class="hljs-string"><span class="hljs-string">"Type=Temperature"</span></span>, <span class="hljs-string"><span class="hljs-string">"200..600"</span></span>, Force = <span class="hljs-string"><span class="hljs-string">"273"</span></span>)] [Number(<span class="hljs-string"><span class="hljs-string">"Type=Voltage"</span></span>, <span class="hljs-string"><span class="hljs-string">"-400..400"</span></span>, Force = <span class="hljs-string"><span class="hljs-string">"0"</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">decimal</span></span> Value { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } }</code> </pre><br>  Queda por hacer que funcione.  Tal clase es simplemente inútil. <br><br><h3>  Despachador </h3><br>  La idea es simple: cierre los establecedores y cambie los valores de campo a través de un despachador determinado, que comprenderá todas las reglas, supervisará su ejecución, notificará sobre los cambios de campo y registrará todos los cambios. <br><br><img src="https://habrastorage.org/webt/db/gn/ac/dbgnac0xng2kq2gb0-tih_hhcqi.png" alt="imagen"><br><br>  La opción está funcionando, pero el código se verá horrible: <br><br><pre> <code class="cs hljs">someDispatcher.Set(mySensor, <span class="hljs-string"><span class="hljs-string">"Type"</span></span>, SensorType.Voltage);</code> </pre><br>  Por supuesto, puede hacer que el despachador sea una parte integral de los objetos con dependencias: <br><br><pre> <code class="cs hljs">mySensor.Set(<span class="hljs-string"><span class="hljs-string">"Type"</span></span>, SensorType.Voltage)</code> </pre><br>  Pero mis objetos serán utilizados por otros desarrolladores y, a veces, no les quedará completamente claro <s>por</s> qué es tan necesario escribir.  Después de todo, quiero escribir simplemente: <br><br><pre> <code class="cs hljs">mySensor.Type=SensorType.Voltage;</code> </pre><br><h3>  Herencia </h3><br>  Específicamente, en nuestro modelo, nosotros mismos gestionamos el ciclo de vida de los objetos con dependencias: los creamos solo en el modelo mismo y externamente solo proporcionamos su edición.  Por lo tanto, haremos que todos los campos sean virtuales, dejaremos la interfaz externa del modelo sin cambios, pero ya funcionará con clases de "envoltorios", que implementarán la lógica de las comprobaciones. <br><br><img src="https://habrastorage.org/webt/p9/dq/an/p9dqanmzswgdce8vaz9emp1eqgc.png" alt="imagen"><br><br>  Esta es una opción ideal para un usuario externo, trabajará con dicho objeto de la manera habitual <br><br><pre> <code class="cs hljs">mySensor.Type=SensorType.Voltage</code> </pre><br>  Queda por aprender cómo crear tales envoltorios <br><br><h3>  Generación de clase </h3><br>  En realidad, hay dos formas de generar: <br><br><ul><li>  Generar código completo basado en atributos </li><li>  Genere código completo que llame a la verificación de atributos </li></ul><br>  Generar código basado en atributos es definitivamente genial y funcionará rápidamente.  Pero cuánto requerirá fuerza.  Y, lo más importante, si necesita agregar nuevas restricciones / reglas, ¿cuántos cambios serán necesarios y qué complejidad? <br><br>  Generaremos código estándar para cada setter, que llamará a métodos que analizarán los atributos y realizarán verificaciones. <br><br>  Vamos a dejar getter sin cambios: <br><br><pre> <code class="cs hljs">MethodBuilder getPropMthdBldr = typeBuilder.DefineMethod(<span class="hljs-string"><span class="hljs-string">"get_"</span></span> + property.Name, MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig | MethodAttributes.Virtual, property.PropertyType, Type.EmptyTypes); ILGenerator getIl = getPropMthdBldr.GetILGenerator(); getIl.Emit(OpCodes.Ldarg_0); getIl.Emit(OpCodes.Call, property.GetMethod); getIl.Emit(OpCodes.Ret);</code> </pre><br>  Aquí, el primer parámetro que llegó a nuestro método se inserta en la pila, esto es una referencia al objeto (esto).  Luego se llama al captador de la clase base y se devuelve el resultado, que se coloca en la parte superior de la pila.  Es decir  nuestro captador simplemente reenvía la llamada a la clase base. <br><br>  Setter es un poco más complicado.  Para el análisis, crearemos un método estático, que producirá el análisis aproximadamente de la siguiente manera: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (StrongValidate(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, property, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">value</span></span> = SoftValidate(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, property, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (oldValue != <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>) { &lt;    <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>&gt;; ForceValidate(baseModel, property); Log(baseModel, property, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>, oldValue); } }</code> </pre><br>  StrongValidate: descartará valores que no se puedan convertir a aquellos que se ajusten a las reglas.  Por ejemplo, solo se permite escribir "y" y "n" en el cuadro de texto;  cuando intenta escribir "u", solo tiene que rechazar los cambios para que el modelo no se destruya. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">String(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"y, n"</span></span></span><span class="hljs-meta">)</span></span>]</code> </pre><br>  SoftValidate: convertirá valores de inapropiados a válidos.  Por ejemplo, un campo int solo puede aceptar números.  Cuando intente escribir 111, puede convertir el valor al más adecuado: "9". <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">Number(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">""</span></span></span><span class="hljs-meta">, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"0..9"</span></span></span><span class="hljs-meta">)</span></span>]</code> </pre><br>  &lt;llamar al establecedor base con valor&gt;: después de obtener un valor válido, debe llamar al establecedor de la clase base para cambiar el valor del campo. <br><br>  ForceValidate: después del cambio, podemos obtener un modelo no válido en los campos que dependen de nuestro campo.  Por ejemplo, cambiar el tipo provoca un cambio en el valor. <br><br>  El registro es solo notificación y registro. <br><br>  Para llamar a tal método, necesitamos el objeto en sí, su valor nuevo y antiguo, y el campo que está cambiando.  El código para tal setter se verá así: <br><br><pre> <code class="cs hljs">MethodBuilder setPropMthdBldr = typeBuilder.DefineMethod(<span class="hljs-string"><span class="hljs-string">"set_"</span></span> + property.Name, MethodAttributes.Public | MethodAttributes.SpecialName | MethodAttributes.HideBySig | MethodAttributes.Virtual, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { property.PropertyType }); <span class="hljs-comment"><span class="hljs-comment">//  ,    var setter = typeof(DinamicWrapper).GetMethod("Setter", BindingFlags.Static | BindingFlags.Public); ILGenerator setIl = setPropMthdBldr.GetILGenerator(); setIl.Emit(OpCodes.Ldarg_0);//     - this setIl.Emit(OpCodes.Ldarg_1);//     -  setter    (value) if (property.PropertyType.IsValueType) //  Boxing,    Value,         object { setIl.Emit(OpCodes.Box, property.PropertyType); } setIl.Emit(OpCodes.Ldstr, property.Name); //     setIl.Emit(OpCodes.Call, setter); setIl.Emit(OpCodes.Ret);</span></span></code> </pre><br>  Necesitaremos otro método que cambie directamente el valor de la clase base.  El código es similar a un getter simple, solo hay dos parámetros: esto y valor: <br><br><pre> <code class="cs hljs">MethodBuilder setPureMthdBldr = typeBuilder.DefineMethod(<span class="hljs-string"><span class="hljs-string">"set_Pure_"</span></span> + property.Name, MethodAttributes.Public, CallingConventions.Standard, <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span>[] { property.PropertyType }); ILGenerator setPureIl = setPureMthdBldr.GetILGenerator(); setPureIl.Emit(OpCodes.Ldarg_0); setPureIl.Emit(OpCodes.Ldarg_1); setPureIl.Emit(OpCodes.Call, property.GetSetMethod()); setPureIl.Emit(OpCodes.Ret);</code> </pre><br>  Todo el código con pequeñas pruebas se puede encontrar aquí: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github.com/wolf-off/DinamicAspect</a> <br><br><h3>  Validaciones </h3><br>  Los códigos de las validaciones en sí son simples: solo buscan el atributo activo actual de acuerdo con el principio de la condición más larga y le preguntan si el nuevo valor es válido.  Solo debe tener en cuenta dos cosas al elegir las reglas (analizarlas y calcular las apropiadas): <br><br><ul><li>  Caché el resultado de GetCustomAttributes.  Una función que toma atributos de los campos funciona lentamente porque los crea cada vez.  Caché su resultado.  Implementé en la clase base BaseModel </li><li>  Al calcular las reglas apropiadas, tendrá que lidiar con los tipos de campo.  Si todos los valores se reducen a cadenas y se comparan, funcionará lentamente.  Especialmente enum.  Implementado en la clase de atributo base DependencyAttribute </li></ul><br><h3>  Conclusión </h3><br>  ¿Cuál es la ventaja de este enfoque? <br><br>  Y eso después de crear el objeto: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> target = DinamicWrapper.Create&lt;Sensor&gt;();</code> </pre><br>  Se puede usar como de costumbre, pero se comportará de acuerdo con los atributos: <br><br><pre> <code class="cs hljs">target.Type = SensorType.Temperature; target.Value=<span class="hljs-number"><span class="hljs-number">300</span></span>; Assert.AreEqual(target.Value, <span class="hljs-number"><span class="hljs-number">300</span></span>); <span class="hljs-comment"><span class="hljs-comment">// true target.Value=3; Assert.AreEqual(target.Value, 200); // true - minimum target.Value=3000; Assert.AreEqual(target.Value, 600); // true - maximum target.Type = SensorType.Voltage; Assert.AreEqual(target.Value, 0); // true - minimum target.Value= 3000; Assert.AreEqual(target.Value, 400); // true - maximum</span></span></code> </pre></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/472598/">https://habr.com/ru/post/472598/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../472582/index.html">Historia de Internet: la computadora como dispositivo de comunicación</a></li>
<li><a href="../472586/index.html">Análisis de altavoz: qué hay dentro y cómo funciona</a></li>
<li><a href="../472588/index.html">Todo lo que quería saber sobre el péndulo inverso</a></li>
<li><a href="../472590/index.html">Elegir un desarrollador móvil en 5 pasos: aspecto de la empresa de TI</a></li>
<li><a href="../472596/index.html">Cómo hacer videos para juegos. Consejos prácticos y pautas útiles</a></li>
<li><a href="../472600/index.html">Introducción a Git</a></li>
<li><a href="../472602/index.html">Cómo no deshonrar en las reuniones, o el desarrollador les enseña a los desarrolladores a hablar. Entrevista con Alexander Shushunov</a></li>
<li><a href="../472604/index.html">Webinar abierto "Validación fluida como herramienta de validación de datos"</a></li>
<li><a href="../472606/index.html">Envolvemos todo el tráfico del sistema operativo en Tor</a></li>
<li><a href="../472610/index.html">Qué elementos HTML tienen más demanda: análisis de 8 millones de páginas desde una perspectiva SEO</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>