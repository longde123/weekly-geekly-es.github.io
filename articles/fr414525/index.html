<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥛 🗞️ 👧🏻 Le livre «Effective Spark. Mise à l'échelle et optimisation " 🤛🏿 ✌🏻 🧕🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dans cet article, nous examinerons l'accès à l'API Spark à partir de divers langages de programmation dans la JVM, ainsi que certains problèmes de per...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Le livre «Effective Spark. Mise à l'échelle et optimisation "</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/414525/"><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/webt/g1/uu/lu/g1uulu2edgzcixecswin9lfylnc.jpeg" align="left" alt="image"></a>  Dans cet article, nous examinerons l'accès à l'API Spark à partir de divers langages de programmation dans la JVM, ainsi que certains problèmes de performances lorsque nous allons au-delà du langage Scala.  Même si vous travaillez en dehors de la JVM, cette section peut être utile, car les langages non JVM dépendent souvent de l'API Java et non de l'API Scala. <br><br>  Travailler dans d'autres langages de programmation ne signifie pas toujours que vous devez aller au-delà de la JVM, et travailler dans la JVM présente de nombreux avantages en termes de performances - principalement en raison du fait que vous n'avez pas besoin de copier les données.  Bien qu'il ne soit pas nécessaire d'utiliser des bibliothèques de liaison ou des adaptateurs spéciaux pour accéder à Spark depuis l'extérieur du langage Scala, l'invocation de code Scala à partir d'autres langages de programmation peut être difficile.  Le framework Spark prend en charge l'utilisation de Java 8 dans les expressions lambda, et ceux qui utilisent des versions plus anciennes du JDK ont la possibilité d'implémenter l'interface appropriée à partir du package org.apache.spark.api.java.function.  Même dans les cas où vous n'avez pas besoin de copier de données, le travail dans un autre langage de programmation peut avoir des nuances petites mais importantes liées aux performances. <br><a name="habracut"></a><br>  Les difficultés d'accès à diverses API Scala sont particulièrement prononcées lors de l'appel de fonctions avec des balises de classe ou lors de l'utilisation de propriétés fournies à l'aide de conversions de types implicites (par exemple, toutes les fonctionnalités des ensembles RDD liés aux classes Double et Tuple).  Pour les mécanismes qui dépendent de conversions de types implicites, des classes concrètes équivalentes sont souvent fournies avec des conversions explicites.  Les balises de classe factices (par exemple, AnyRef) peuvent être transmises à des fonctions qui dépendent des balises de classe (souvent les adaptateurs le font automatiquement.  L'utilisation de classes spécifiques au lieu de conversions de types implicites n'entraîne généralement pas de surcharge supplémentaire, mais les balises de classe factices peuvent imposer des restrictions sur certaines optimisations du compilateur. <br><br>  L'API Java n'est pas trop différente de l'API Scala en termes de propriétés, seulement occasionnellement certaines fonctionnalités ou API de développeur manquent.  D'autres langages de programmation JVM, tels que le langage Clojure avec DSL <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Flambo</a> et la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">étincelante</a> , sont <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pris</a> en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">charge à l'</a> aide de diverses API Java au lieu d'appeler directement l'API Scala.  Étant donné que la plupart des liaisons de langage, même les langages non JVM comme Python et R, passent par l'API <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Java</a> , il sera utile de les gérer. <br><br>  Les API Java sont très similaires aux API Scala, bien qu'elles soient indépendantes des balises de classe et des conversions implicites.  L'absence de ce dernier signifie qu'au lieu de convertir automatiquement les ensembles RDD d'objets Tuple ou doubles en classes spéciales avec des fonctions supplémentaires, vous devez utiliser des fonctions de conversion de type explicite (par exemple, mapToDouble ou mapToPair).  Les fonctions spécifiées sont définies uniquement pour les ensembles RDD Java;  heureusement pour la compatibilité, ces types spéciaux ne sont que des adaptateurs pour les ensembles Scala RDD.  De plus, ces fonctions spéciales renvoient divers types de données, tels que JavaDoubleRDD et JavaPairRDD, avec des fonctionnalités fournies par des transformations implicites du langage Scala. <br><br>  Reprenons l'exemple canonique du comptage de mots à l'aide de l'API Java (exemple 7.1).  Étant donné que l'appel de l'API Scala à partir de Java peut parfois être une tâche ardue, presque toutes les API du framework Java Spark sont implémentées dans le langage Scala avec des balises de classe cachées et des conversions implicites.  Pour cette raison, les adaptateurs Java sont une couche très mince, composée en moyenne de seulement quelques lignes de code, et leur réécriture est pratiquement sans effort. <br><br>  Exemple 7.1  Comptage de mots (Java) <br><br><pre><code class="hljs actionscript"><span class="hljs-meta"><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span></span></span><span class="hljs-meta"> scala.Tuple2;</span></span>  <span class="hljs-meta"><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span></span></span><span class="hljs-meta"> org.apache.spark.api.java.JavaRDD;</span></span> <span class="hljs-meta"><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span></span></span><span class="hljs-meta"> org.apache.spark.api.java.JavaPairRDD </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span></span></span><span class="hljs-meta"> org.apache.spark.api.java.JavaSparkContext;</span></span>  <span class="hljs-meta"><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span></span></span><span class="hljs-meta"> java.util.regex.Pattern;</span></span> <span class="hljs-meta"><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">import</span></span></span><span class="hljs-meta"> java.util.Arrays;</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WordCount</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Pattern pattern = Pattern.compile(<span class="hljs-string"><span class="hljs-string">" "</span></span>);  <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> main(String[] args) throws Exception { JavaSparkContext jsc = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> JavaSparkContext(); JavaRDD&lt;String&gt; lines = jsc.textFile(args[<span class="hljs-number"><span class="hljs-number">0</span></span>]); JavaRDD&lt;String&gt; words = lines.flatMap(e -&gt; Arrays.asList(                                           pattern.split(e)).iterator()); JavaPairRDD&lt;String, Integer&gt; wordsIntial = words.mapToPair(  e -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Tuple2&lt;String, Integer&gt;(e, <span class="hljs-number"><span class="hljs-number">1</span></span>));   } }</code> </pre> <br>  Parfois, vous devrez peut-être convertir des RDD Java en RDD Scala ou vice versa.  Cela est le plus souvent nécessaire pour les bibliothèques nécessitant une entrée ou renvoyant des ensembles RDD Scala, mais parfois les propriétés de base de Spark peuvent ne pas encore être disponibles dans l'API Java.  La conversion de RDD Java en RDD Scala est le moyen le plus simple d'utiliser ces nouvelles fonctionnalités. <br><br>  Si vous devez transférer l'ensemble RDD Java vers la bibliothèque Scala, qui attend un étincelle RDD standard à l'entrée, vous pouvez accéder au Scala RDD sous-jacent à l'aide de la méthode rdd ().  Le plus souvent, cela suffit pour transférer le RDD final vers n'importe quelle bibliothèque Scala souhaitée;  Parmi les exceptions notables figurent les bibliothèques Scala, qui s'appuient sur des conversions implicites de types de jeux de types de contenu ou d'informations de balises de classe dans leur travail.  Dans ce cas, le moyen le plus simple d'accéder aux conversions implicites consiste à écrire un petit adaptateur dans Scala.  Si les shells Scala ne peuvent pas être utilisés, vous pouvez appeler la fonction correspondante de la classe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">JavaConverters</a> et former une balise de classe factice. <br><br>  Pour créer une balise de classe factice, vous pouvez utiliser la méthode scala.reflect.ClassTag $ .MODULE $ .AnyRef () ou obtenir la vraie en utilisant scala.reflect.ClassTag $ .MODULE $ .apply (CLASS), comme illustré dans les exemples 7.2 et 7.3. <br><br>  Pour convertir de Scala RDD en RDD Java, les informations de balise de classe sont souvent plus importantes que la plupart des bibliothèques Spark.  La raison en est que bien que diverses classes JavaRDD fournissent des constructeurs accessibles au public qui prennent Scala RDD comme arguments, elles sont destinées à être appelées à partir du code Scala et nécessitent donc des informations sur la balise de classe. <br><br>  Les balises de classe factices sont le plus souvent utilisées dans le code générique ou modèle, où les types exacts sont inconnus au moment de la compilation.  De telles balises suffisent souvent, bien qu'il soit possible de perdre certaines nuances du côté du code Scala;  dans de très rares cas, le code Scala nécessite des informations précises sur les balises de classe.  Dans ce cas, vous devrez utiliser une vraie balise.  Dans la plupart des cas, cela ne nécessite pas beaucoup d'efforts et améliore les performances, essayez donc d'utiliser ces balises dans la mesure du possible. <br><br>  Exemple 7.2.  Rendre Java / Scala RDD compatible avec une balise de classe factice <br><br><pre> <code class="hljs pgsql"><span class="hljs-built_in"><span class="hljs-built_in">public</span></span> static JavaPairRDD wrapPairRDDFakeCt( RDD&lt;Tuple2&lt;String, <span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>&gt;&gt; RDD) { //       AnyRef —   //        , //        , //        //    ClassTag&lt;<span class="hljs-keyword"><span class="hljs-keyword">Object</span></span>&gt; fake = ClassTag$.MODULE$.AnyRef(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> JavaPairRDD(rdd, fake, fake); }</code> </pre> <br>  Exemple 7.3.  Garantir la compatibilité RDD Java / Scala <br><br><pre> <code class="hljs ruby">public static JavaPairRDD wrapPairRDD( RDD&lt;Tuple2&lt;String, Object<span class="hljs-meta"><span class="hljs-meta">&gt;&gt; </span></span>RDD) { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    ClassTag&lt;String&gt; strCt = ClassTag$.MODULE$.apply(String.class); ClassTag&lt;Long&gt; longCt = ClassTag$.MODULE$.apply(scala.Long.class); return new JavaPairRDD(rdd, strCt, longCt); }</code> </pre> <br>  Les API Spark SQL et ML pipeline ont été pour la plupart rendues cohérentes en Java et Scala.  Cependant, il existe des fonctions d'assistance spécifiques à Java et les fonctions Scala équivalentes ne sont pas faciles à appeler.  Voici leurs exemples: diverses fonctions numériques, telles que plus, moins, etc., pour la classe Column.  Il est difficile d'appeler leurs équivalents surchargés de la langue Scala (+, -).  Au lieu d'utiliser JavaDataFrame et JavaSQLContext, les méthodes requises par Java sont disponibles dans SQLContext et les ensembles DataFrame standard.  Cela peut vous dérouter, car certaines des méthodes mentionnées dans la documentation Java ne peuvent pas être utilisées à partir du code Java, mais dans de tels cas, des fonctions portant les mêmes noms sont fournies pour appeler à partir de Java. <br><br>  Les fonctions définies par l'utilisateur (UDF) dans le langage Java, et d'ailleurs, dans la plupart des autres langages à l'exception de Scala, elles nécessitent de spécifier le type de la valeur renvoyée par la fonction, car elle ne peut pas être déduite de manière logique, semblable à la façon dont elle est effectuée dans Scala (exemple 7.4) . <br><br>  Exemple 7.4.  Exemple UDF pour Java <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">sqlContext</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.udf</span></span>() <span class="hljs-selector-class"><span class="hljs-selector-class">.register</span></span>("<span class="hljs-selector-tag"><span class="hljs-selector-tag">strlen</span></span>", (<span class="hljs-selector-tag"><span class="hljs-selector-tag">String</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">s</span></span>) <span class="hljs-selector-tag"><span class="hljs-selector-tag">-</span></span>&gt; <span class="hljs-selector-tag"><span class="hljs-selector-tag">s</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.length</span></span>(), <span class="hljs-selector-tag"><span class="hljs-selector-tag">DataTypes</span></span><span class="hljs-selector-class"><span class="hljs-selector-class">.StringType</span></span>);</code> </pre> <br>  Bien que les types requis par les API Scala et Java soient différents, l'encapsulation des types de collection Java ne nécessite pas de copie supplémentaire.  Dans le cas des itérateurs, la conversion de type requise pour l'adaptateur est effectuée de manière retardée lors de l'accès aux éléments, ce qui permet au framework Spark de vider les données si nécessaire (comme expliqué dans la section "Effectuer des transformations itérateur-itérateur à l'aide de la fonction mapPartitions" à la page 125).  Ceci est très important car pour de nombreuses opérations simples, le coût de la copie des données peut être supérieur au coût du calcul lui-même. <br><br><h3>  Au-delà de Scala et JVM </h3><br>  Si vous ne vous limitez pas à la JVM, le nombre de langages de programmation disponibles pour le travail augmente considérablement.  Cependant, avec l'architecture Spark actuelle, travailler en dehors de la JVM - en particulier sur les nœuds de travail - peut entraîner des augmentations de coûts importantes en raison de la copie des données dans les nœuds de travail entre la JVM et le code de langue cible.  Dans les opérations complexes, la part du coût de copie des données est relativement faible, mais dans les opérations simples, elle peut facilement conduire à un doublement du coût de calcul total. <br><br>  Le premier langage de programmation non JVM directement pris en charge en dehors de Spark est Python, son API et son interface sont devenues le modèle sur lequel les implémentations pour d'autres langages de programmation non JVM sont basées. <br><br><h3>  Comment PySpark fonctionne </h3><br>  PySpark se connecte à JVM Spark en utilisant un mélange de canaux sur les travailleurs et Py4J, une bibliothèque spécialisée qui fournit une interaction Python / Java, sur le pilote.  Sous cela, à première vue, une architecture simple cache beaucoup de nuances complexes, grâce auxquelles PySpark fonctionne, comme le montre la Fig.  7.1.  L'un des principaux problèmes: même lorsque les données sont copiées d'un travailleur Python vers la JVM, ce n'est pas sous la forme qu'une machine virtuelle peut facilement analyser.  Des efforts particuliers sont requis de la part du travailleur Python et Java pour garantir que la machine virtuelle Java dispose de suffisamment d'informations pour des opérations telles que le partitionnement. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/10/ez/wf/10ezwfv-1jvl1gxwsansnexwvj4.png" alt="image"></div><br><h3>  Kits RDD PySpark </h3><br>  Le coût des ressources pour le transfert de données vers et depuis la JVM, ainsi que pour l'exécution de l'exécuteur Python, est important.  Vous pouvez éviter de nombreux problèmes de performances avec les API PySpark RDD Suite à l'aide des API DataFrame / Dataset, car les données restent dans la JVM aussi longtemps que possible. <br><br>  La copie des données de la JVM vers Python se fait à l'aide de sockets et d'octets sérialisés.  Une version plus générale pour interagir avec des programmes dans d'autres langues est disponible via l'interface PipedRDD, dont l'application est présentée dans la sous-section «Utilisation de pipe». <br><br>  L'organisation de canaux d'échange de données (dans les deux sens) pour chaque transformation serait trop coûteuse.  Par conséquent, PySpark organise (si possible) le pipeline de transformation Python à l'intérieur de l'interpréteur Python, enchaînant l'opération de filtrage, puis la carte, sur l'itérateur d'objet Python à l'aide de la classe spécialisée PipelinedRDD.  Même lorsque vous devez mélanger des données et que PySpark n'est pas en mesure de chaîner les conversions dans la machine virtuelle d'un travailleur individuel, vous pouvez réutiliser l'interpréteur Python, de sorte que le coût de démarrage de l'interpréteur ne ralentira pas davantage. <br><br>  Ce n'est qu'une partie du puzzle.  Les PipedRDD classiques fonctionnent avec le type String, qui n'est pas si facile à mélanger en raison de l'absence d'une clé naturelle.  Dans PySpark, et dans son image et sa similitude dans les bibliothèques se liant à de nombreux autres langages de programmation, un type spécial de PairwiseRDD est utilisé, où la clé est un entier long, et sa désérialisation est effectuée par le code utilisateur dans le langage Scala, destiné à l'analyse des valeurs Python.  Le coût de cette désérialisation n'est pas trop élevé, mais cela démontre que Scala dans le framework Spark considère essentiellement les résultats du code Python comme des tableaux d'octets «opaques». <br><br>  Pour toute sa simplicité, cette approche d'intégration fonctionne étonnamment bien, et la plupart des opérations sur les ensembles Scala RDD sont disponibles en Python.  Dans certains des endroits les plus difficiles du code, les bibliothèques sont accessibles, par exemple, MLlib, ainsi que le chargement / enregistrement des données à partir de diverses sources. <br><br>  Travailler avec différents formats de données impose également ses limites, car une partie importante du code de chargement / enregistrement des données à partir du framework Spark est basée sur les interfaces Java Hadoop.  Cela signifie que toutes les données chargées sont d'abord chargées dans la JVM, puis déplacées vers Python. <br><br>  Deux approches sont généralement utilisées pour interagir avec MLlib: soit PySpark utilise un type de données spécialisé avec des conversions de type Scala, soit l'algorithme est réimplémenté en Python.  Ces problèmes peuvent être évités avec le package Spark ML, qui utilise l'interface DataFrame / Dataset, qui stocke généralement les données dans la JVM. <br><br><h3>  Kits PySpark DataFrame et Dataset </h3><br>  Les ensembles DataFrame et Dataset n'ont pas beaucoup de problèmes de performances avec les API d'ensemble Python RDD car ils stockent les données dans la JVM aussi longtemps que possible.  Le même test de performances que nous avons effectué pour illustrer la supériorité des ensembles DataFrame sur les ensembles RDD (voir figure 3.1) montre des différences significatives lors de l'exécution en Python (figure 7.2). <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d9/mk/tl/d9mktl7qhe3hg8z2e9lnyanlgde.png" alt="image"></div><br>  Pour de nombreuses opérations avec des ensembles DataFrame et Dataset, vous n'aurez peut-être pas besoin de déplacer les données de la JVM, bien que l'utilisation de diverses expressions lambda UDF, UDAF et Python nécessite naturellement de déplacer certaines données dans la JVM.  Cela conduit au schéma simplifié suivant pour de nombreuses opérations, qui ressemble à celui illustré sur la Fig.  7.3. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4e/3q/el/4e3qel6hamrvb5ipzycqh9sftcg.png" alt="image"></div><br><h3>  Accès aux objets Java sous-jacents et au code mixte dans Scala </h3><br>  Une conséquence importante de l'architecture PySpark est que de nombreuses classes de framework Spark Python sont en fait des adaptateurs pour traduire les appels du code Python en une forme JVM compréhensible. <br><br>  Si vous travaillez avec des développeurs Scala / Java et que vous souhaitez interagir avec leur code, à l'avance, il n'y aura pas d'adaptateurs pour accéder à votre code, mais vous pouvez enregistrer votre UDF Java / Scala et les utiliser à partir du code Python.  À partir de Spark 2.1, cela peut être fait à l'aide de la méthode registerJavaFunction de l'objet sqlContext. <br><br>  Parfois, ces adaptateurs ne disposent pas de tous les mécanismes nécessaires, et comme Python ne dispose pas d'une solide protection contre les appels de méthodes privées, vous pouvez immédiatement vous tourner vers la JVM.  La même technique vous permettra d'accéder à votre propre code dans la JVM et, avec peu d'effort, de reconvertir les résultats en objets Python. <br><br>  Dans la sous-section "Grands plans de requête et algorithmes itératifs" à la p.  91 nous avons noté l'importance d'utiliser la version JVM des ensembles DataFrame et RDD pour réduire le plan de requête.  Il s'agit d'une solution de contournement, car lorsque les plans de requête deviennent trop volumineux pour être traités par l'optimiseur Spark SQL, l'optimiseur SQL, en raison du placement de l'ensemble RDD au milieu, perd la possibilité de regarder au-delà du moment où les données apparaissent dans RDD.  La même chose peut être obtenue à l'aide des API Python publiques, cependant, de nombreux avantages des ensembles DataFrame seront perdus, car toutes les données devront aller et venir via les nœuds de travail de Python.  Au lieu de cela, vous pouvez réduire le graphique d'origine en continuant à stocker des données dans la JVM (comme illustré dans l'exemple 7.5). <br><br>  Exemple 7.5  Découpage d'un plan de requête volumineux pour un DataFrame à l'aide de Python <br><br><pre> <code class="hljs python"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cutLineage</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(df)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""    DataFrame —     .. :              &gt;&gt;&gt; df = RDD.toDF() &gt;&gt;&gt; cutDf = cutLineage(df) &gt;&gt;&gt; cutDf.count() 3 """</span></span> jRDD = df._jdf.toJavaRDD() jSchema = df._jdf.schema() jRDD.cache() sqlCtx = df.sql_ctx <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: javaSqlCtx = sqlCtx._jsqlContext <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: javaSqlCtx = sqlCtx._ssql_ctx newJavaDF = javaSqlCtx.createDataFrame(jRDD, jSchema) newDF = DataFrame(newJavaDF, sqlCtx) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newDF</code> </pre> <br>  De manière générale, par convention, la syntaxe _j [nom_abrégé] est utilisée pour accéder aux versions Java internes de la plupart des objets Python.  Ainsi, par exemple, l'objet SparkContext a _jsc, ce qui vous permet d'obtenir l'objet Java interne SparkContext.  Cela n'est possible que dans le programme du pilote, donc lorsque vous envoyez des objets PySpark aux nœuds de travail, vous ne pourrez pas accéder au composant Java interne et la plupart de l'API ne fonctionnera pas. <br><br>  Pour accéder à la classe Spark dans la JVM, qui ne possède pas d'adaptateur Python, vous pouvez utiliser la passerelle Py4J sur le pilote.  L'objet SparkContext contient un lien vers la passerelle dans la propriété _gateway.  La syntaxe sc._gateway.jvm. [Full_class_name_in_JVM] permettra d'accéder à n'importe quel objet Java. <br><br>  Une technique similaire fonctionnera pour vos propres classes Scala si elles sont organisées selon le chemin de classe.  Vous pouvez ajouter des fichiers JAR au chemin de classe à l'aide de la commande spark-submit avec le paramètre --jars ou en définissant les propriétés de configuration spark.driver.extraClassPath.  Exemple 7.6, qui a aidé à générer du riz.  7.2, est intentionnellement conçu pour générer des données pour les tests de performances en utilisant le code Scala existant. <br><br>  Exemple 7.6  Appel de classes non Spark-JVM à l'aide de Py4J <br><br><pre> <code class="hljs pgsql">sc = sqlCtx._sc #  <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span> Context,   <span class="hljs-number"><span class="hljs-number">2.1</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>   , #  <span class="hljs-number"><span class="hljs-number">2.0</span></span>, —  ,   :p try: try: javaSqlCtx = sqlCtx._jsqlContext <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: javaSqlCtx = sqlCtx._ssql_ctx <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: javaSqlCtx = sqlCtx._jwrapped jsc = sc._jsc scalasc = jsc.sc() gateway = sc._gateway #  java-,   RDD JVM- # <span class="hljs-keyword"><span class="hljs-keyword">Row</span></span> (<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">Double</span></span>).   RDD  Python   #  RDD  Java (   <span class="hljs-keyword"><span class="hljs-keyword">Row</span></span>),   # ,      . #   Java-RDD  <span class="hljs-keyword"><span class="hljs-keyword">Row</span></span> —     #    DataFrame,     #    RDD  <span class="hljs-keyword"><span class="hljs-keyword">Row</span></span>. java_rdd = (gateway.jvm.com.highperformancespark.examples. tools.GenerateScalingData. generateMiniScaleRows(scalasc, <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>, numCols)) #     <span class="hljs-type"><span class="hljs-type">JSON</span></span>     . #  Python-     Java-. schema = StructType([ StructField("zip", IntegerType()), StructField("fuzzyness", DoubleType())]) #   <span class="hljs-number"><span class="hljs-number">2.1</span></span> /  <span class="hljs-number"><span class="hljs-number">2.1</span></span> try: jschema = javaSqlCtx.parseDataType(<span class="hljs-keyword"><span class="hljs-keyword">schema</span></span>.json()) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span>: jschema = sqlCtx._jsparkSession.parseDataType(<span class="hljs-keyword"><span class="hljs-keyword">schema</span></span>.json()) #  RDD (Java)  DataFrame (Java) java_dataframe = javaSqlCtx.createDataFrame(java_rdd, jschema) #  DataFrame (Java)  DataFrame (Python) python_dataframe = DataFrame(java_dataframe, sqlCtx) #  DataFrame (Python)   RDD pairRDD = python_dataframe.rdd.map(lambda <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>: (<span class="hljs-keyword"><span class="hljs-keyword">row</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>], <span class="hljs-keyword"><span class="hljs-keyword">row</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>])) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (python_dataframe, pairRDD)</code> </pre> <br><br>  Bien que de nombreuses classes Python soient simplement des adaptateurs d'objets Java, tous les objets Java ne peuvent pas être encapsulés dans des objets Python, puis utilisés dans Spark.  Par exemple, les objets des ensembles RDD PySpark sont représentés comme des chaînes sérialisées, qui ne peuvent être analysées facilement qu'en code Python.  Heureusement, les objets DataFrame sont standardisés entre différents langages de programmation, donc si vous pouvez convertir vos données en ensembles DataFrame, vous pouvez ensuite les encapsuler dans des objets Python et les utiliser directement comme Python DataFrame, ou convertir un Python DataFrame en RDD de cette même langue. <br><br>  »Plus d'informations sur le livre sont disponibles sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le site Web de l'éditeur</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Contenu</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Extrait</a> <br><br>  20% de réduction sur les coupons pour pulvérisateurs - <b>Spark</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr414525/">https://habr.com/ru/post/fr414525/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr414513/index.html">27 excellents outils de développement Web open source</a></li>
<li><a href="../fr414515/index.html">Leçon d'optimisation du serveur d'applications Web</a></li>
<li><a href="../fr414517/index.html">Scientifiques d'Oxford: la probabilité que nous soyons seuls dans la partie prévisible de l'univers est bien supérieure à zéro</a></li>
<li><a href="../fr414519/index.html">Comment transformer 15 minutes de réunions Scrum en salle comble?</a></li>
<li><a href="../fr414523/index.html">Comparaison des quadcoptères DJI Mavic Pro et Mavic Air</a></li>
<li><a href="../fr414527/index.html">Ce qui nous attend sur Highload ++ Siberia, à l'exception des ours peints</a></li>
<li><a href="../fr414531/index.html">Personne ne sait ce qu'il adviendra des achats en ligne à partir du 1er juillet</a></li>
<li><a href="../fr414535/index.html">Manchester: berceau du découragement, du post-punk et de deux célèbres clubs de football</a></li>
<li><a href="../fr414537/index.html">Comment nous avons créé l'un des meilleurs jeux AR au monde sans trafic payant</a></li>
<li><a href="../fr414539/index.html">Les cybercriminels volent de plus en plus les données personnelles des Russes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>