<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>◼️ 🤲🏾 ☘️ Di kerajaan tertentu, tidak dalam kondisi "melonjak". Laporan Yandex 💔 🔈 ⛲️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Spring adalah framework Java open source yang kuat. Saya memutuskan untuk memberi tahu Anda tugas apa yang digunakan oleh backend Spring dan untuk apa...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Di kerajaan tertentu, tidak dalam kondisi "melonjak". Laporan Yandex</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/478788/">  Spring adalah framework Java open source yang kuat.  Saya memutuskan untuk memberi tahu Anda tugas apa yang digunakan oleh backend Spring dan untuk apa pro dan kontra dibandingkan dengan perpustakaan lain: Guice and Dagger 2. Pertimbangkan injeksi dependensi dan inversi kontrol - Anda akan belajar cara mulai mempelajari prinsip-prinsip ini. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/RrmrfoWDu5M" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  - Halo semuanya, nama saya Cyril.  Hari ini saya akan berbicara tentang Injeksi Ketergantungan. <br><a name="habracut"></a><br>  Kami akan mulai dengan apa yang disebut laporan saya.  "Di kerajaan tertentu, bukan di" musim semi "."  Kami akan berbicara, tentu saja, tentang Spring, tetapi saya juga ingin melihat semua yang ada di sampingnya.  Khususnya apa yang akan kita bicarakan? <br><br><img src="https://habrastorage.org/webt/cq/li/gv/cqligvmc0hnuu56z8mgqjjnoebo.jpeg"><br><br>  Saya akan melakukan penyimpangan kecil - memberi tahu Anda apa yang saya kerjakan, apa proyek saya, mengapa kami menggunakan Dependency Injection.  Maka saya akan memberi tahu Anda tentang semua ini, membandingkan Pembalikan Kontrol dan Ketergantungan Injeksi, dan berbicara tentang penerapannya di tiga perpustakaan paling terkenal. <br><br>  Saya bekerja di tim Yandex.Tracker.  Kami membuat analog kelontong Jira atau Trello.  [...] Kami memutuskan untuk membuat produk kami sendiri, yang merupakan internal pertama.  Sekarang kami menjualnya.  Anda masing-masing dapat masuk, membuat Pelacak Anda sendiri dan melakukan tugas - misalnya, pendidikan atau bisnis. <br><br>  Mari kita lihat antarmuka.  Dalam contoh, saya akan menggunakan beberapa istilah dari daerah saya.  Kami akan mencoba membuat tiket dan melihat komentar yang akan ditinggalkan oleh rekan kerja lain di dalamnya. <br><br>  Untuk mulai dengan, apa Dependency Injection secara umum?  Ini adalah pola pemrograman yang memenuhi pepatah Amerika kuno, prinsip Hollywood: "Jangan panggil kami, kami akan memanggil Anda sendiri."  Ketergantungan datang kepada kita.  Ini terutama sebuah pola, bukan perpustakaan.  Oleh karena itu, pada prinsipnya, pola seperti itu biasa terjadi di hampir semua tempat.  Anda bahkan bisa mengatakan bahwa semua aplikasi menggunakan Injeksi Ketergantungan dalam satu atau lain cara. <br><br><img src="https://habrastorage.org/webt/wz/cj/8h/wzcj8hmirm_url9gghidooms19y.jpeg"><br><br>  Mari kita lihat sendiri bagaimana Anda bisa menggunakan Dependency Injection jika kita mulai dari awal.  Misalkan saya memutuskan untuk mengembangkan kelas sekecil itu di mana saya akan membuat tiket melalui API kami.  Misalnya, buat turunan dari kelas TrackerApi.  Ini memiliki metode createTicket di mana kami akan mengirim email saya.  Kami akan membuat tiket dari bawah akun saya dengan nama: "Siapkan laporan untuk Java Meetup". <br><br><img src="https://habrastorage.org/webt/sp/dn/md/spdnmdmw57qzfgfdfjtwqwijtiq.jpeg"><br><br>  Mari kita lihat implementasi TrackerApi.  Di sini, misalnya, kita dapat melakukan ini: membuat contoh httpClient.  Dalam istilah sederhana, kita akan membuat objek yang akan kita gunakan menuju API.  Melalui objek ini kita akan memanggil metode eksekusi di atasnya. <br><br><img src="https://habrastorage.org/webt/x4/2a/iy/x42aiy9l2baljluoanesiq04gay.jpeg"><br><br>  Misalnya, yang khusus.  Saya menulis kode eksternal dari kelas-kelas ini, dan akan menggunakannya seperti ini.  Saya membuat TicketCreator baru dan memanggil metode createTicket di atasnya. <br><br><img src="https://habrastorage.org/webt/g8/al/li/g8allib-7c35r0iulwej8fjgmzu.jpeg"><br><br>  Ada masalah di sini - setiap kali kami membuat tiket, kami akan membuat ulang dan membuat kembali httpClient, meskipun secara umum, tidak perlu untuk ini.  httpClients sangat serius untuk dibuat. <br><br><img src="https://habrastorage.org/webt/eh/pc/o3/ehpco32zfcarfgwgabxumx6deuo.jpeg"><br><br>  Mari kita coba membuatnya.  Di sini Anda dapat melihat contoh pertama Dependency Injection dalam kode kami.  Perhatikan apa yang telah kita lakukan.  Kami mengambil variabel kami di lapangan dan mengisinya di konstruktor.  Fakta bahwa kita mengisinya dalam konstruktor berarti bahwa ketergantungan datang kepada kita.  Ini adalah Injeksi Ketergantungan pertama. <br><br><img src="https://habrastorage.org/webt/x0/qw/2r/x0qw2rjibtfionm8och8p4fgxsm.jpeg"><br><br>  Kami mengalihkan tanggung jawab kepada pengguna kode, jadi sekarang kami harus membuat httpClient, meneruskannya, misalnya, ke TicketCreator. <br><br><img src="https://habrastorage.org/webt/x0/qw/2r/x0qw2rjibtfionm8och8p4fgxsm.jpeg"><br><br>  Ini juga tidak terlalu bagus di sini, karena sekarang, dengan memanggil metode ini, kita akan kembali membuat httpClient setiap waktu. <br><br><img src="https://habrastorage.org/webt/tk/ib/zn/tkibznrpcl80hnoqg7qccgvl0em.jpeg"><br><br>  Karena itu, kami bawa lagi ke lapangan.  Dan di sini, omong-omong, ada contoh Ketergantungan Injeksi yang tidak jelas.  Kami dapat mengatakan bahwa kami selalu membuat tiket dari bawah saya (atau dari bawah orang lain).  Kami akan membuat setiap objek TicketCreator terpisah dari pengguna yang berbeda. <br><br>  Misalnya, ini akan dibuat dari bawah saya ketika kita membuatnya.  Dan garis yang kita lewati ke konstruktor juga merupakan Dependency Injection. <br><br><img src="https://habrastorage.org/webt/jl/uq/nb/jluqnb4_2lburqy9jwo3u2hsrg8.jpeg"><br><br>  Bagaimana yang akan kita lakukan sekarang?  Buat instance baru TrackerTicketCreator dan panggil metode tersebut.  Sekarang kita bahkan dapat membuat semacam metode khusus yang akan membuat tiket dengan teks khusus untuk kita.  Misalnya, buat tiket "Sewa peserta pelatihan baru". <br><br><img src="https://habrastorage.org/webt/zr/un/hp/zrunhp6rgmmvg55w5djkz9z1clo.jpeg"><br><br>  Sekarang mari kita coba untuk melihat seperti apa kode kita jika kita ingin membaca komentar di tiket ini dengan cara yang sama, dari bawah saya.  Ini tentang kode yang sama.  Kami akan memanggil metode getComments pada tiket ini. <br><br><img src="https://habrastorage.org/webt/qs/hs/ek/qshsek9l2xmb9xskiryj-m6rtzm.jpeg"><br><br>  Akan seperti apa dia?  Jika kami mengambil dan menduplikasi fungsi ini dalam pembaca komentar, kami menduplikasi pembuatan httpClient.  Ini tidak cocok untuk kita.  Kami ingin menyingkirkannya. <br><br><img src="https://habrastorage.org/webt/tb/cq/ot/tbcqotqdzrcfxgzfzsba-e9us54.jpeg"><br><br>  Bagus  Sekarang mari kita meneruskan semua parameter ini sebagai Injeksi Ketergantungan, sebagai parameter konstruktor. <br><br><img src="https://habrastorage.org/webt/qu/po/9k/qupo9kqigu94hoyo5tpcssyoxzg.jpeg"><br><br>  Apa masalahnya di sini?  Kami melewatkan semuanya, tetapi dalam kode pengguna kami sekarang menulis "boilerplate".  Ini adalah semacam kode yang tidak perlu yang biasanya perlu ditulis pengguna untuk melakukan tindakan yang relatif kecil dalam hal logika.  Di sini kita harus terus-menerus membuat httpClient, API untuknya dan memilih email pengguna.  Setiap pengguna TicketCreator harus melakukan ini sendiri.  Ini tidak baik.  Kami sekarang akan mencoba untuk melihat tampilannya di perpustakaan ketika kami mencoba menghindarinya. <br><br>  Sekarang, mari kita sedikit menyimpang dan melihat apa itu Inversion of Control, karena banyak yang mengaitkan Injeksi Ketergantungan dengannya. <br><br><img src="https://habrastorage.org/webt/h9/kj/xc/h9kjxcwtgvzwilwyikkiydksznm.jpeg"><br><br>  Inversion of Control adalah prinsip pemrograman di mana objek yang kita gunakan tidak dibuat oleh kami.  Kami tidak mempengaruhi siklus hidup mereka sama sekali.  Biasanya, entitas yang membuat objek-objek ini disebut wadah IoC.  Banyak dari Anda telah mendengar tentang Spring di sini.  Dokumentasi Spring mengatakan bahwa IoC juga dikenal sebagai Injeksi Ketergantungan.  Mereka percaya bahwa ini adalah satu dan sama. <br><br><img src="https://habrastorage.org/webt/fb/ue/oi/fbueoiomwpuhzlrkq3j9acynvcy.jpeg"><br><br>  Apa prinsip dasarnya?  Objek dibuat bukan oleh kode aplikasi, tetapi oleh beberapa wadah IoC.  Kami, sebagai pengguna perpustakaan, tidak melakukan apa-apa, semuanya datang kepada kami sendiri.  Tentu saja, IoC adalah relatif.  Kontainer IoC sendiri menciptakan objek-objek ini, dan ini tidak lagi berlaku untuknya.  Anda mungkin berpikir bahwa IoC tidak hanya mengimplementasikan perpustakaan DI.  Perpustakaan Java yang terkenal Servlets dan Akka Actors, yang sekarang digunakan dalam Scala dan dalam kode Java. <br><br><img src="https://habrastorage.org/webt/mg/cj/qu/mgcjqu4qucgjz1w27guicfvgji8.jpeg"><br><br>  Mari kita bicara tentang perpustakaan.  Secara umum, cukup banyak perpustakaan yang telah ditulis untuk Jawa dan Kotlin.  Saya akan daftar yang utama: <br><br>  - Spring, kerangka kerja yang bagus.  Bagian utamanya adalah Injeksi Ketergantungan atau, seperti kata mereka, Inversion of Control. <br>  - Guice adalah perpustakaan yang ditulis kira-kira antara Spring kedua dan ketiga ketika Spring dipindahkan dari XML ke deskripsi kode.  Begitulah, ketika Musim Semi masih belum begitu indah. <br>  - Belati adalah apa yang biasanya digunakan orang di Android. <br><br>  Mari kita coba menulis ulang contoh kita di Spring. <br><br><img src="https://habrastorage.org/webt/n-/tq/bl/n-tqblihbupgiumevmkyjad7wnc.jpeg"><br><br>  Kami memiliki TrackerApi kami.  Saya tidak memasukkan pengguna ke sini secara singkat.  Misalkan kita coba di Dependency Injection untuk melakukan httpClient.  Untuk melakukan ini, kita perlu mendeklarasikannya dengan anotasi.  <a href="https://habr.com/ru/users/component/" class="user_link">Komponen</a> , seluruh kelas, dan khususnya konstruktor, dideklarasikan dengan anotasi <a href="https://habr.com/ru/users/autowired/" class="user_link">Autowired</a> .  Apa artinya ini untuk Spring? <br><br><img src="https://habrastorage.org/webt/qj/ef/i8/qjefi88q9vtuab9n16-rchaphzw.jpeg"><br><br>  Kami memiliki konfigurasi seperti itu dalam kode, ini ditunjukkan oleh anotasi Pemindaian <a href="https://habr.com/ru/users/component/" class="user_link">Komponen</a> .  Ini berarti bahwa kita akan mencoba untuk menelusuri seluruh pohon kelas kita dalam paket yang berisinya.  Dan lebih jauh ke pedalaman kita akan mencoba untuk menemukan semua kelas yang ditandai dalam anotasi <a href="https://habr.com/ru/users/component/" class="user_link">Komponen</a> . <br><br><img src="https://habrastorage.org/webt/n-/tq/bl/n-tqblihbupgiumevmkyjad7wnc.jpeg"><br><br>  Komponen-komponen ini akan jatuh ke wadah IoC.  Penting bagi kita bahwa semuanya jatuh cinta pada kita.  Kami hanya menandai apa yang ingin kami umumkan.  Agar sesuatu datang kepada kami, kami harus mendeklarasikannya menggunakan anotasi <a href="https://habr.com/ru/users/autowired/" class="user_link">Autowired</a> di konstruktor. <br><br><img src="https://habrastorage.org/webt/ym/hq/le/ymhqlevva5gqgnoieckrw6ymm2k.jpeg"><br><br>  TicketCreator kami lakukan dengan cara yang persis sama. <br><br><img src="https://habrastorage.org/webt/xk/fa/i_/xkfai_wibiwgnp1lpuzfi9fhbcs.jpeg"><br><br>  Dan CommentReader juga. <br><br><img src="https://habrastorage.org/webt/qj/ef/i8/qjefi88q9vtuab9n16-rchaphzw.jpeg"><br><br>  Sekarang mari kita lihat kembali konfigurasi.  Seperti yang kami katakan, Pemindaian Komponen akan meletakkan semuanya dalam wadah IoC.  Tetapi ada satu titik, yang disebut metode pabrik.  Kami memiliki metode httpClient, yang tidak kami buat sebagai kelas, karena httpClient datang kepada kami dari pustaka.  Dia tidak mengerti apa itu Spring, dan sebagainya. Kami akan membuatnya langsung di konfigurasi.  Untuk melakukan ini, kita menulis metode yang biasanya membangunnya sekali, dan menandainya dengan anotasi Bean. <br><br><img src="https://habrastorage.org/webt/br/ba/rf/brbarflmwiprwpmlknhdqpl5muc.jpeg"><br><br>  Apa pro dan kontra?  Plus utama - Musim semi sangat umum di dunia.  Plus dan minus berikutnya adalah autoscanning.  Kita tidak boleh secara eksplisit menyatakan di mana saja bahwa kita ingin menambahkan wadah ke IoC selain penjelasan atas kelas itu sendiri.  Penjelasan yang cukup.  Dan minusnya persis sama: jika, sebaliknya, kami ingin kontrol atas ini, maka Spring tidak memberi kami ini.  Kecuali kita dapat mengatakan di tim kami: “Tidak, kami tidak akan melakukan itu.  Kita harus dengan jelas meresepkan sesuatu di suatu tempat.  Hanya dalam konfigurasi, seperti yang kita lakukan dengan kacang. <br><br>  Juga, karena ini, awal yang lambat terjadi.  Ketika aplikasi dimulai, Spring harus melalui semua kelas ini dan mencari tahu apa yang harus dimasukkan ke dalam wadah IoC.  Ini memperlambatnya.  Kelemahan terbesar Spring, menurut saya, adalah pohon ketergantungan.  Itu tidak diperiksa pada tahap kompilasi.  Ketika Spring mulai pada suatu titik, perlu dipahami jika saya memiliki ketergantungan di dalamnya.  Jika nanti ternyata tidak ada di pohon dependensi, maka Anda akan mendapatkan kesalahan dalam runtime.  Dan kami di Jawa tidak ingin kesalahan runtime.  Kami ingin kode tersebut dikompilasi untuk kami.  Ini berarti berhasil. <br><br><img src="https://habrastorage.org/webt/nk/2l/6x/nk2l6x7k1fc6-undofdq53ppj8i.jpeg"><br><br>  Mari kita lihat Guice.  Ini adalah perpustakaan yang, seperti yang saya katakan, dibuat antara musim semi kedua dan ketiga.  Keindahan yang kami lihat bukan.  Ada XML.  Untuk memperbaiki masalah ini, dan ditulis oleh Guice.  Dan di sini Anda dapat melihat bahwa, tidak seperti konfigurasi, kami menulis modul.  Di dalamnya, kami secara eksplisit mendeklarasikan kelas mana yang ingin kami masukkan dalam modul ini: TrackerAPI, TrackerTicketCreator dan semua nampan lainnya.  Sebuah analog dengan anotasi Bean di sini adalah <a href="https://habr.com/ru/users/provides/" class="user_link">Provides</a> , yang membuat httpClient dengan cara yang sama. <br><br><img src="https://habrastorage.org/webt/tf/wc/hn/tfwchnamip5ovyhno-7j_9twrae.jpeg"><br><br>  Kita perlu mendeklarasikan masing-masing kacang ini.  Kami akan memberi contoh <a href="https://habr.com/ru/users/singleton/" class="user_link">Singleton</a> .  Tetapi secara khusus, <a href="https://habr.com/ru/users/singleton/" class="user_link">Singleton</a> akan mengatakan bahwa kacang seperti itu akan dibuat tepat satu kali.  Kami tidak akan terus-menerus membuatnya kembali.  Dan <a href="https://habr.com/ru/users/inject/" class="user_link">Suntikan</a> , masing-masing, adalah analog dari <a href="https://habr.com/ru/users/autowired/" class="user_link">Autowired</a> . <br><br><img src="https://habrastorage.org/webt/32/i9/-5/32i9-5iuc58qvzmpiahf_3odv6k.jpeg"><br><br>  Tablet kecil dengan apa yang menjadi miliknya. <br><br><img src="https://habrastorage.org/webt/ny/5o/i4/ny5oi43in62gaprwj4ym5tvuxh8.jpeg"><br><br>  Apa pro dan kontra?  Pro: itu lebih sederhana, menurut saya, dan dapat dimengerti daripada versi XML Spring.  Startup lebih cepat.  Dan inilah kontra: membutuhkan deklarasi eksplisit dari kacang yang digunakan.  Kita seharusnya menulis Bean.  Tetapi di sisi lain, ini merupakan nilai tambah, seperti yang telah kita katakan.  Ini adalah bayangan cermin dari apa yang dimiliki Spring.  Tentu saja, itu kurang umum daripada Spring.  Ini adalah minus alaminya.  Dan ada masalah yang sama persis - pohon ketergantungan tidak diperiksa pada tahap kompilasi. <br><br>  Ketika mereka mulai menggunakan Guice untuk Android, mereka menyadari bahwa mereka masih kekurangan kecepatan peluncuran.  Oleh karena itu, mereka memutuskan untuk menulis kerangka kerja Ketergantungan Injeksi yang lebih sederhana dan lebih primitif yang akan memungkinkan mereka untuk memulai aplikasi dengan cepat, karena untuk Android sangat penting. <br><br><img src="https://habrastorage.org/webt/5x/sp/l7/5xspl7f9z-2xoy22flag9sgrdzy.jpeg"><br><br>  Di sini terminologinya sama.  Belati memiliki modul yang persis sama dengan Guice.  Tetapi mereka sudah ditandai dengan anotasi, tidak seperti dalam kasus warisan dari kelas.  Karena itu, prinsipnya dipertahankan. <br><br>  Satu-satunya minus adalah bahwa kita harus selalu secara eksplisit menunjukkan dalam modul bagaimana kacang dibuat.  Di Guice, kita bisa memberikan kreasi kacang di dalam kacang itu sendiri.  Kami tidak harus mengatakan dependensi seperti apa yang perlu kami teruskan.  Dan di sini kita perlu secara eksplisit mengatakan ini. <br><br><img src="https://habrastorage.org/webt/tu/q7/f8/tuq7f8jjaj-ouvsw1faz8e_8wgm.jpeg"><br><br>  Di Dagger, karena Anda tidak ingin melakukan input manual terlalu, ada konsep komponen.  Komponen adalah sesuatu yang mengikat modul ketika kita ingin mendeklarasikan satu bin dari satu modul sehingga dapat diambil di modul lain.  Ini adalah konsep yang berbeda.  Kacang dari satu modul dapat "menyuntikkan" kacang dari modul lain menggunakan komponen. <br><br><img src="https://habrastorage.org/webt/16/sn/41/16sn412k1exgnqbuil1mogbtpom.jpeg"><br><br>  Berikut ini tentang pelat ringkasan yang sama - apa yang telah berubah atau belum berubah dalam kasus Suntikan atau modul. <br><br><img src="https://habrastorage.org/webt/pm/v1/ur/pmv1urcl1djm48azfby8ux6uqbs.jpeg"><br><br>  Apa kelebihannya?  Itu bahkan lebih sederhana dari Guice.  Peluncuran bahkan lebih cepat dari Guice.  Dan itu mungkin tidak akan menjadi lebih cepat lagi, karena belati benar-benar meninggalkan pantulan.  Ini persis bagian dari perpustakaan di Jawa yang bertanggung jawab untuk melihat keadaan objek, kelas dan metodenya.  Artinya, dapatkan status dalam runtime.  Karena itu, tidak menggunakan refleksi.  Dia tidak pergi dan tidak memindai dependensi apa yang dimiliki seseorang.  Tetapi karena ini, ia memulai dengan sangat cepat. <br><br>  Bagaimana dia melakukannya?  Menggunakan pembuatan kode. <br><br><img src="https://habrastorage.org/webt/tu/q7/f8/tuq7f8jjaj-ouvsw1faz8e_8wgm.jpeg"><br><br>  Jika kita melihat ke belakang, kita akan melihat komponen antarmuka.  Kami tidak mengimplementasikan implementasi antarmuka ini, Dagger melakukannya untuk kami.  Dan dimungkinkan untuk lebih jauh menggunakan antarmuka dalam aplikasi. <br><br><img src="https://habrastorage.org/webt/pm/v1/ur/pmv1urcl1djm48azfby8ux6uqbs.jpeg"><br><br>  Secara alami, ini sangat umum di dunia Android karena kecepatan ini.  Pohon dependensi diperiksa segera pada kompilasi, karena tidak ada yang akan kami tunda saat runtime. <br><br>  Apa kerugiannya?  Dia memiliki lebih sedikit peluang.  Ini lebih bertele-tele daripada Guice dan Spring. <br><br><img src="https://habrastorage.org/webt/cx/m8/ng/cxm8ngienchgjtm4yc1m7uo26bo.jpeg"><br><br>  Di dalam perpustakaan-perpustakaan ini, sebuah inisiatif muncul di Jawa - yang disebut JSR-330.  JSR adalah permintaan untuk membuat perubahan dalam spesifikasi bahasa atau menambahnya dengan beberapa perpustakaan tambahan.  Standar semacam itu diusulkan berdasarkan Guice, dan anotasi <a href="https://habr.com/ru/users/inject/" class="user_link">Suntikan</a> ditambahkan ke perpustakaan ini.  Dengan demikian, Spring and Guice mendukungnya. <br><br>  Kesimpulan apa yang bisa ditarik?  Java memiliki banyak pustaka yang berbeda untuk DI.  Dan Anda perlu memahami mengapa kami mengambil salah satu dari mereka.  Jika kami menggunakan Android, maka sudah tidak ada pilihan, kami menggunakan Belati.  Jika kita pergi ke dunia backend, maka kita sudah melihat apa yang paling cocok untuk kita.  Dan untuk studi pertama Ketergantungan Injeksi, menurut saya bahwa Guice lebih baik daripada Musim Semi.  Tidak ada yang berlebihan di dalamnya.  Anda dapat melihat cara kerjanya, rasakan. <br><br>  Untuk studi lebih lanjut, saya sarankan agar Anda membiasakan diri dengan dokumentasi semua perpustakaan ini dan komposisi JSR: <br>  - <a href="https://spring.io/">Musim semi</a> <br>  - <a href="https://github.com/google/guice/">Guice</a> <br>  - <a href="https://github.com/google/dagger">Belati 2</a> <br>  - <a href="https://github.com/javax-inject/javax-inject">JSR-330</a> <br><br>  Terima kasih </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id478788/">https://habr.com/ru/post/id478788/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id478760/index.html">"Nol" neraka dan bagaimana keluar dari situ</a></li>
<li><a href="../id478764/index.html">Kesalahan JavaScript: memperbaiki, memproses, memperbaiki</a></li>
<li><a href="../id478766/index.html">Kustomisasi pemetaan pengendali Spring MVC</a></li>
<li><a href="../id478772/index.html">Tekstur konvolusional</a></li>
<li><a href="../id478774/index.html">Suasana Tahun Baru dari Arduino dan tongkat</a></li>
<li><a href="../id478790/index.html">Julia dan semantik distribusi</a></li>
<li><a href="../id478796/index.html">Sarjana di AS: Cara Tidak Konvensional ke Sekolah Menengah Atas</a></li>
<li><a href="../id478798/index.html">Graphene, yang masih belum bisa</a></li>
<li><a href="../id478802/index.html">Bereaksi-admin dan kerangka istirahat Django</a></li>
<li><a href="../id478804/index.html">Antiquities: semakin buruk, semakin baik atau fitur Sound Blaster Pro 2</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>