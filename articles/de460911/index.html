<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥩 👵🏾 🎈 Gutes tun, Schlechtes tun: Mit Go bösen Code schreiben, Teil 2 👉🏼 🐃 🔩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Schlechte Tipps für einen Go-Programmierer 



 Im ersten Teil der Veröffentlichung erklärte ich, wie man ein "bösartiger" Go-Programmierer wird. Das ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gutes tun, Schlechtes tun: Mit Go bösen Code schreiben, Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460911/">  <i><b>Schlechte Tipps für einen Go-Programmierer</b></i> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8cc/265/872/8cc265872daa29a415c830378896ad61.png" alt="Bild"><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Im ersten Teil der Veröffentlichung erklärte</a> ich, wie man ein "bösartiger" Go-Programmierer wird.  Das Böse gibt es in vielen Formen, aber bei der Programmierung liegt es in der absichtlichen Schwierigkeit, den Code zu verstehen und zu pflegen.  Böse Programme ignorieren die grundlegenden Sprachmittel zugunsten von Techniken, die kurzfristige Vorteile im Austausch für langfristige Probleme bieten.  Zur kurzen Erinnerung gehören zu Go's bösen "Praktiken": <br><br><ul><li>  Schlecht benannte und organisierte Pakete </li><li>  Falsch organisierte Schnittstellen </li><li>  Übergeben von Zeigern auf Variablen in Funktionen, um deren Werte zu füllen </li><li>  Panik statt Fehler </li><li>  Verwenden von Init-Funktionen und leeren Importen zum Konfigurieren von Abhängigkeiten </li><li>  Laden Sie Konfigurationsdateien mit den Init-Funktionen herunter </li><li>  Verwenden von Frameworks anstelle von Bibliotheken </li></ul><br><h3>  Großer Ball des Bösen </h3><br>  Was passiert, wenn wir alle unsere bösen Praktiken zusammenfügen?  Wir hätten ein Framework, das viele Konfigurationsdateien verwendet, die Strukturfelder mit Zeigern ausfüllt, Schnittstellen zur Beschreibung veröffentlichter Typen definiert, sich auf „magischen“ Code verlässt und bei jedem Problem in Panik gerät. <br><br>  Und ich habe es geschafft.  Wenn Sie zu <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">https://github.com/evil-go</a> gehen, sehen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Fall</a> , ein DI-Framework, mit dem Sie alle gewünschten „bösen“ Praktiken implementieren können.  Ich habe Fall mit einem winzigen Outboy-Webframework gelötet, das denselben Prinzipien folgt. <br><br>  Sie fragen sich vielleicht, wie bösartig sie sind?  Mal sehen.  Ich empfehle ein einfaches Go-Programm (geschrieben mit Best Practices), das den http-Endpunkt bereitstellt.  Und dann schreiben Sie es mit Fall und Outboy neu. <br><a name="habracut"></a><br><h3>  Best Practices </h3><br>  Unser Programm besteht aus einem einzigen Paket namens greet, das alle Grundfunktionen zur Implementierung unseres Endpunkts verwendet.  Da dies ein Beispiel ist, verwenden wir ein im Speicher arbeitendes DAO mit drei Feldern für die Werte, die wir zurückgeben werden.  Wir werden auch eine Methode haben, die abhängig von der Eingabe den Aufruf unserer Datenbank ersetzt und die gewünschte Begrüßung zurückgibt. <br><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> greet <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Dao <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { DefaultMessage <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> BobMessage <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> JuliaMessage <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(sdi Dao)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GreetingForName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> name { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"Bob"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sdi.BobMessage, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"Julia"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sdi.JuliaMessage, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sdi.DefaultMessage, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> } }</code> </pre> <br>  Als nächstes kommt die Geschäftslogik.  Um dies zu implementieren, definieren wir eine Struktur zum Speichern von Ausgabedaten, eine GreetingFinder-Schnittstelle zum Beschreiben, wonach Geschäftslogik auf der Datensuchebene sucht, und eine Struktur zum Speichern von Geschäftslogik selbst mit einem Feld für GreetingFinder.  Die eigentliche Logik ist einfach: Sie ruft lediglich GreetingFinder auf und behandelt eventuell auftretende Fehler. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Response <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Message <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GreetingFinder <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { GreetingForName(name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) (<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>, error) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Service <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { GreetingFinder GreetingFinder } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ssi Service)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Greeting</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Response, error)</span></span></span></span> { msg, err := ssi.GreetingFinder.GreetingForName(name) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Response{}, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Response{Message: msg}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre> <br>  Dann kommt die Webebene, und für diesen Teil definieren wir die Greeter-Schnittstelle, die die gesamte Geschäftslogik enthält, die wir benötigen, sowie die Struktur, die den mit Greeter konfigurierten http-Handler enthält.  Anschließend erstellen wir eine Methode zum Implementieren der http.Handler-Schnittstelle, die die http-Anforderung aufteilt, greeter-a (Begrüßung) aufruft, Fehler verarbeitet und die Ergebnisse zurückgibt. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Greeter <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Greeting(name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) (Response, error) } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Controller <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Greeter Greeter } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mc Controller)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ServeHTTP</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rw http.ResponseWriter, req *http.Request)</span></span></span></span> { result, err := mc.Greeter.Greeting( req.URL.Query().Get(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { rw.WriteHeader(http.StatusInternalServerError) rw.Write([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(err.Error())) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } rw.Write([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(result.Message)) }</code> </pre> <br>  Dies ist das Ende des Grußpakets.  Als nächstes werden wir sehen, wie ein "guter" Go-Entwickler main schreiben würde, um dieses Paket zu verwenden.  Im Hauptpaket definieren wir eine Struktur namens Config, die die Eigenschaften enthält, die wir ausführen müssen.  Die Hauptfunktion macht dann 3 Dinge. <br><br><ul><li>  Zunächst wird die Funktion loadProperties aufgerufen, die eine einfache Bibliothek ( <a href="">https://github.com/evil-go/good-sample/blob/master/config/config.go</a> ) verwendet, um die Eigenschaften aus der Konfigurationsdatei zu laden und zu platzieren in unserer Kopie einer Konfiguration.  Wenn der Konfigurationsdownload fehlgeschlagen ist, meldet die Hauptfunktion einen Fehler und wird beendet. </li><li>  Zweitens bindet die Hauptfunktion die Komponenten im Greet-Paket, weist ihnen explizit Werte aus der Konfiguration zu und richtet die Abhängigkeiten ein. </li><li>  Drittens ruft es eine kleine Serverbibliothek ( <a href="">https://github.com/evil-go/good-sample/blob/master/server/server.go</a> ) auf und übergibt die Adresse, die HTTP-Methode und http.Handler an den Endpunkt für Anforderungsverarbeitung.  Ein Bibliotheksaufruf startet einen Webdienst.  Und das ist unsere gesamte Anwendung. </li></ul><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Config <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { DefaultMessage <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> BobMessage <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> JuliaMessage <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { c, err := loadProperties() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Println(err) os.Exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) } dao := greet.Dao{ DefaultMessage: c.DefaultMessage, BobMessage: c.BobMessage, JuliaMessage: c.JuliaMessage, } svc := greet.Service{GreetingFinder: dao} controller := greet.Controller{Greeter: svc} err = server.Start(server.Endpoint{c.Path, http.MethodGet, controller}) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { fmt.Println(err) os.Exit(<span class="hljs-number"><span class="hljs-number">1</span></span>) } }</code> </pre> <br>  Das Beispiel ist ziemlich kurz, aber es zeigt, wie cool Go geschrieben ist.  Einige Dinge sind nicht eindeutig, aber im Allgemeinen ist klar, was passiert.  Wir kleben kleine Bibliotheken, die speziell für die Zusammenarbeit eingerichtet wurden.  Nichts ist verborgen;  Jeder kann diesen Code nehmen, verstehen, wie seine Teile miteinander verbunden sind, und sie gegebenenfalls zu neuen wiederholen. <br><br><h3>  Schwarzer Fleck </h3><br>  Jetzt werden wir die Version von Fall und Outboy betrachten.  Als erstes teilen wir das Greet-Paket in mehrere Pakete auf, von denen jedes eine Anwendungsschicht enthält.  Hier ist das DAO-Paket.  Es importiert Fall, unser DI-Framework, und da wir "böse" sind und im Gegenteil Beziehungen zu Schnittstellen definieren, werden wir eine Schnittstelle namens GreetDao definieren.  Bitte beachten Sie, dass wir alle Links zu Fehlern entfernt haben.  Wenn etwas nicht stimmt, geraten wir in Panik.  Zu diesem Zeitpunkt haben wir bereits schlechte Verpackungen, schlechte Schnittstellen und schlechte Fehler.  Toller Start! <br><br>  Wir haben unsere Struktur anhand eines guten Beispiels leicht umbenannt.  Felder haben jetzt Struktur-Tags.  Sie werden verwendet, um Fall dazu zu bringen, den registrierten Wert im Feld festzulegen.  Wir haben auch eine Init-Funktion für unser Paket, mit der wir „böse Kraft“ ansammeln.  In der Paketinitialfunktion rufen wir Fall zweimal auf: <br><br><ul><li>  Einmal, um eine Konfigurationsdatei zu registrieren, die Werte für Struktur-Tags bereitstellt. </li><li>  Und eine andere, um einen Zeiger auf eine Instanz der Struktur zu registrieren.  Fall kann diese Felder für uns ausfüllen und das DAO für andere Codes zur Verfügung stellen. </li></ul><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> dao <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/fall"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GreetDao <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { GreetingForName(name <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> greetDaoImpl <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { DefaultMessage <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`value:"message.default"`</span></span> BobMessage <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`value:"message.bob"`</span></span> JuliaMessage <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`value:"message.julia"`</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(gdi greetDaoImpl)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GreetingForName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">string</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> name { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"Bob"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gdi.BobMessage <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"Julia"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gdi.JuliaMessage <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gdi.DefaultMessage } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fall.RegisterPropertiesFile(<span class="hljs-string"><span class="hljs-string">"dao.properties"</span></span>) fall.Register(&amp;greetDaoImpl{}) }</code> </pre> <br>  Sehen wir uns das Servicepaket an.  Es importiert das DAO-Paket, da es Zugriff auf die dort definierte Schnittstelle benötigt.  Das Servicepaket importiert auch das Modellpaket, das wir noch nicht berücksichtigt haben - wir speichern dort unsere Datentypen.  Und wir importieren den Herbst, weil er wie alle "guten" Frameworks überall durchdringt.  Wir definieren auch eine Schnittstelle für den Service, um den Zugriff auf die Webebene zu ermöglichen.  Wieder ohne Fehlerbehandlung. <br><br>  Die Implementierung unseres Service hat jetzt ein strukturelles Tag mit Draht.  Der feldmarkierte Draht verbindet automatisch seine Abhängigkeit, wenn die Struktur im Herbst registriert wird.  In unserem winzigen Beispiel ist klar, was diesem Feld zugewiesen wird.  In einem größeren Programm wissen Sie jedoch nur, dass diese GreetDao-Schnittstelle irgendwo implementiert und im Herbst registriert ist.  Sie können das Abhängigkeitsverhalten nicht steuern. <br><br>  Als nächstes folgt die Methode unseres Dienstes, die geringfügig geändert wurde, um die GreetResponse-Struktur aus dem Modellpaket zu erhalten, und die jegliche Fehlerbehandlung beseitigt.  Schließlich haben wir eine Init-Funktion im Paket, die eine Dienstinstanz im Herbst registriert. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> service <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/fall"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/evil-sample/dao"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/evil-sample/model"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GreetService <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Greeting(<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>) model.GreetResponse } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> greetServiceImpl <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Dao dao.GreetDao <span class="hljs-string"><span class="hljs-string">`wire:""`</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ssi greetServiceImpl)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Greeting</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">model</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GreetResponse</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.GreetResponse{Message: ssi.Dao.GreetingForName(name)} } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fall.Register(&amp;greetServiceImpl{}) }</code> </pre> <br>  Schauen wir uns nun das Modellpaket an.  Es gibt vor allem nichts zu sehen.  Es ist ersichtlich, dass das Modell von dem Code, der es erstellt, getrennt wird, nur um den Code in Ebenen zu unterteilen. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> model <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GreetResponse <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Message <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> }</code> </pre> <br>  Im Webpaket haben wir eine Webschnittstelle.  Hier importieren wir sowohl Fall als auch Outboy und importieren auch das Servicepaket, von dem das Webpaket abhängt.  Da Frameworks nur dann gut zusammenarbeiten, wenn sie hinter den Kulissen integriert sind, verfügt Fall über einen speziellen Code, um sicherzustellen, dass es und Outboy zusammenarbeiten.  Wir ändern auch die Struktur, damit sie zum Controller für unsere Webanwendung wird.  Sie hat zwei Felder: <br><br><ul><li>  Die erste ist über Fall mit der Implementierung der GreetService-Schnittstelle aus dem Servicepaket verbunden. </li><li>  Der zweite ist der Pfad für unseren einzigen Webendpunkt.  Es wird der Wert aus der Konfigurationsdatei zugewiesen, die in der Init-Funktion dieses Pakets registriert ist. </li></ul><br>  Unser http-Handler wurde in GetHello umbenannt und ist jetzt frei von Fehlerbehandlung.  Wir haben auch die Init-Methode (mit einem Großbuchstaben), die nicht mit der Init-Funktion verwechselt werden sollte.  Init ist eine magische Methode, die für Strukturen aufgerufen wird, die im Herbst registriert wurden, nachdem alle Felder ausgefüllt wurden.  In Init rufen wir Outboy auf, um unseren Controller und seinen Endpunkt in dem Pfad zu registrieren, der mit Fall festgelegt wurde.  Wenn Sie sich den Code ansehen, sehen Sie den Pfad und den Handler, aber die HTTP-Methode ist nicht angegeben.  In Outboy wird anhand des Methodennamens bestimmt, auf welche HTTP-Methode der Handler reagiert.  Da unsere Methode GetHello heißt, reagiert sie auf GET-Anfragen.  Wenn Sie diese Regeln nicht kennen, können Sie nicht verstehen, welche Anfragen er beantwortet.  Stimmt, das ist sehr bösartig? <br><br>  Schließlich rufen wir die Init-Funktion auf, um die Konfigurationsdatei und den Controller im Herbst zu registrieren. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> web <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/fall"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/outboy"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/evil-sample/service"</span></span> <span class="hljs-string"><span class="hljs-string">"net/http"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> GreetController <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Service service.GreetService <span class="hljs-string"><span class="hljs-string">`wire:""`</span></span> Path <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> <span class="hljs-string"><span class="hljs-string">`value:"controller.path.hello"`</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mc GreetController)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rw http.ResponseWriter, req *http.Request)</span></span></span></span> { result := mc.Service.Greeting(req.URL.Query().Get(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)) rw.Write([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(result.Message)) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(mc GreetController)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { outboy.Register(mc, <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>]<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>{ <span class="hljs-string"><span class="hljs-string">"GetHello"</span></span>: mc.Path, }) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fall.RegisterPropertiesFile(<span class="hljs-string"><span class="hljs-string">"web.properties"</span></span>) fall.Register(&amp;GreetController{}) }</code> </pre> <br>  Es bleibt nur zu zeigen, wie wir das Programm ausführen.  Im Hauptpaket verwenden wir leere Importe, um Outboy und das Webpaket zu registrieren.  Und die Hauptfunktion ruft fall.Start () auf, um die gesamte Anwendung zu starten. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( _ <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/evil-sample/web"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/fall"</span></span> _ <span class="hljs-string"><span class="hljs-string">"github.com/evil-go/outboy"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { fall.Start() }</code> </pre> <br><h3>  Störung des Integuments </h3><br>  Und hier ist es, ein komplettes Programm, das mit all unseren bösen Go-Werkzeugen geschrieben wurde.  Das ist ein Albtraum.  Sie verbirgt auf magische Weise, wie Teile des Programms zusammenpassen, und macht es fürchterlich schwierig, ihre Arbeit zu verstehen. <br><br>  Und doch müssen Sie zugeben, dass das Schreiben von Code mit Fall und Outboy etwas Attraktives hat.  Für ein winziges Programm könnte man sogar sagen, dass dies eine Verbesserung ist.  Sehen Sie, wie einfach die Konfiguration ist!  Ich kann Abhängigkeiten fast ohne Code verbinden!  Ich habe einen Handler für die Methode registriert, nur mit ihrem Namen!  Und ohne Fehlerbehandlung sieht alles so sauber aus! <br><br>  So funktioniert das Böse.  Auf den ersten Blick ist es wirklich attraktiv.  Aber wenn sich Ihr Programm ändert und wächst, beginnt all diese Magie nur zu stören, was das Verständnis dessen, was passiert, erschwert.  Nur wenn Sie völlig vom Bösen besessen sind, blicken Sie zurück und stellen fest, dass Sie gefangen sind. <br><br>  Für Java-Entwickler mag dies vertraut erscheinen.  Diese Techniken finden sich in vielen gängigen Java-Frameworks.  Wie bereits erwähnt, arbeite ich seit über 20 Jahren mit Java, beginnend mit 1.0.2 im Jahr 1996.  In vielen Fällen waren Java-Entwickler die ersten, die im Internetzeitalter Probleme beim Schreiben umfangreicher Unternehmenssoftware hatten.  Ich erinnere mich an die Zeiten, als Servlets, EJB, Spring und Hibernate gerade erschienen sind.  Die Entscheidungen, die Java-Entwickler damals getroffen haben, waren sinnvoll.  Aber im Laufe der Jahre zeigen diese Techniken ihr Alter.  Neuere Sprachen wie Go sollen die bei älteren Techniken auftretenden Schwachstellen beseitigen.  Wenn Java-Entwickler jedoch anfangen, Go zu lernen und Code damit zu schreiben, sollten sie sich daran erinnern, dass der Versuch, Muster aus Java zu reproduzieren, zu schlechten Ergebnissen führt. <br><br>  Go wurde für seriöse Programmierung entwickelt - für Projekte, die Hunderte von Entwicklern und Dutzende von Teams umfassen.  Damit Go dies tun kann, müssen Sie es so verwenden, wie es am besten funktioniert.  Wir können wählen, ob wir böse oder gut sind.  Wenn wir uns für das Böse entscheiden, können wir junge Go-Entwickler ermutigen, ihren Stil und ihre Techniken zu ändern, bevor sie Go verstehen.  Oder wir können gut wählen.  Ein Teil unserer Arbeit als Go-Entwickler besteht darin, junge Gophers (Gophers) auszubilden, um ihnen zu helfen, die Prinzipien zu verstehen, die unseren Best Practices zugrunde liegen. <br><br>  Der einzige Nachteil, wenn man dem Weg des Guten folgt, ist, dass man nach einem anderen Weg suchen muss, um sein inneres Übel auszudrücken.  <i>Versuchen Sie vielleicht, auf der Bundesstraße mit einer Geschwindigkeit von 30 km / h zu fahren?</i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de460911/">https://habr.com/ru/post/de460911/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de460899/index.html">26. Juli, Deworkacy - DocOps von Rostelecom</a></li>
<li><a href="../de460901/index.html">Warum ältere Entwickler keinen Job bekommen können</a></li>
<li><a href="../de460905/index.html">Minimale SEO-Kenntnisse für Unternehmer</a></li>
<li><a href="../de460907/index.html">Verwenden von Liquibase zum Verwalten der Datenbankstruktur in einer Spring Boot-Anwendung. Teil 2</a></li>
<li><a href="../de460909/index.html">Was werden wir 2050 essen?</a></li>
<li><a href="../de460913/index.html">Fototour durch das Museum des Physik- und Energieinstituts in Obninsk</a></li>
<li><a href="../de460915/index.html">Praktisches Datenbankverwaltungssystem</a></li>
<li><a href="../de460923/index.html">Yandex-Testaufgabe</a></li>
<li><a href="../de460925/index.html">Online-Spiel mit echten RC-Robotern in Tschernobyl. Teil 2</a></li>
<li><a href="../de460929/index.html">Atlassian Confluence: erweiterbar in Python</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>