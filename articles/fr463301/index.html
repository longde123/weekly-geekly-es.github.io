<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§Æ üöæ üôãüèø Gonkey - Outil de test de microservices üëêüèæ üë®üèΩ‚Äçüéì üöò</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Gonkey teste nos microservices √† Lamoda, et nous pensions qu'il pourrait tester le v√¥tre, nous l'avons donc mis en open source . Si la fonctionnalit√© ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gonkey - Outil de test de microservices</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lamoda/blog/463301/"><p>  Gonkey teste nos microservices √† Lamoda, et nous pensions qu'il pourrait tester le v√¥tre, nous l'avons donc mis en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">open source</a> .  Si la fonctionnalit√© de vos services est principalement mise en ≈ìuvre via l'API et que JSON est utilis√© pour l'√©change de donn√©es, alors Gonkey vous convient presque certainement. </p><br><p><img src="https://habrastorage.org/webt/dz/ie/4z/dzie4z9vcjyrtf_n3mhfdistusm.jpeg" alt="image"></p><br><p>  Ci-dessous, j'en parlerai plus en d√©tail et montrerai avec des exemples sp√©cifiques comment l'utiliser. </p><a name="habracut"></a><br><h3 id="kak-rodilsya-gonkey">  Comment Gonkey est n√© </h3><br><p>  Nous avons plus d'une centaine de microservices, dont chacun r√©sout une t√¢che sp√©cifique.  Tous les services ont une API.  Bien s√ªr, certains d'entre eux sont √©galement une interface utilisateur, mais, n√©anmoins, leur r√¥le principal est d'√™tre une source de donn√©es pour un site, des applications mobiles ou d'autres services internes, et donc de fournir une <em>interface logicielle</em> . </p><br><p>  Lorsque nous avons r√©alis√© qu'il y avait beaucoup de services, et qu'il y en aurait encore plus, nous avons d√©velopp√© un document interne d√©crivant l'approche standard de la conception d'API et pris Swagger comme outil de description (et m√™me √©crit des utilitaires pour g√©n√©rer du code bas√© sur la sp√©cification de swagger).  Si vous souhaitez en savoir plus √† ce sujet, consultez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la discussion d'Andrew avec Highload ++.</a> </p><br><p>  L'approche standard de la conception d'API a naturellement conduit √† l'id√©e d'une approche standard des tests.  Voici ce que je voulais r√©aliser: </p><br><ol><li>  <em>Testez les services via l'API</em> , car presque toutes les fonctionnalit√©s du service sont impl√©ment√©es via celle-ci </li><li>  <em>La possibilit√© d'automatiser le lancement de tests</em> pour l'int√©grer dans notre processus CI / CD, comme on dit, "run by button" </li><li>  <em>L'√©criture de tests doit √™tre ali√©nable</em> , c'est-√†-dire que non seulement un programmeur peut √©crire des tests, id√©alement une personne qui n'est pas famili√®re avec la programmation. </li></ol><br><p>  Gonkey est donc n√©. </p><br><h3 id="itak-chto-zhe-eto">  Alors qu'est-ce que c'est? </h3><br><p> Gonkey est une <em>biblioth√®que</em> (pour les projets sur Golang) et un <em>utilitaire de console</em> (pour les projets dans toutes les langues et technologies), avec lesquels vous pouvez effectuer des <em>tests fonctionnels et de r√©gression des services</em> en acc√©dant √† leur API selon un script pr√©d√©fini.  Les scripts de test sont d√©crits dans les fichiers YAML. </p><br><p>  Autrement dit, Gonkey peut: </p><br><ul><li>  bombardez votre service avec des requ√™tes HTTP et assurez-vous que ses r√©ponses sont comme pr√©vu.  Il suppose que JSON est utilis√© dans les demandes et les r√©ponses, mais, tr√®s probablement, il fonctionnera sur des cas simples avec des r√©ponses dans un format diff√©rent; </li><li>  pr√©parer la base de donn√©es pour le test en la remplissant avec les donn√©es des appareils (√©galement sp√©cifi√©es dans les fichiers YAML); </li><li>  imiter les r√©ponses des services externes √† l'aide de simulateurs (cette fonctionnalit√© n'est disponible que si vous connectez Gonkey en tant que biblioth√®que); </li><li>  donner des r√©sultats de test √† la console ou g√©n√©rer un rapport Allure. </li></ul><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">D√©p√¥t de projets</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Image Docker</a> </p><br><h3 id="primer-testirovaniya-servisa-s-gonkey">  Exemple de test de service avec Gonkey </h3><br><p>  Afin de ne pas vous encombrer de texte, je veux passer des mots aux actes et ici tester une API et dire et montrer comment les scripts de test sont √©crits en cours de route. </p><br><p>  Esquissons un petit service sur Go qui simulera le travail d'un feu de circulation.  Il stocke la couleur du signal actuel: rouge, jaune ou vert.  Vous pouvez obtenir la couleur de signal actuelle ou en d√©finir une nouvelle via l'API. </p><br><pre><code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//    const ( lightRed = "red" lightYellow = "yellow" lightGreen = "green" ) //      type trafficLights struct { currentLight string `json:"currentLight"` mutex sync.RWMutex `json:"-"` } //   var lights = trafficLights{ currentLight: lightRed, } func main() { //       http.HandleFunc("/light/get", func(w http.ResponseWriter, r *http.Request) { lights.mutex.RLock() defer lights.mutex.RUnlock() resp, err := json.Marshal(lights) if err != nil { log.Fatal(err) } w.Write(resp) }) //       http.HandleFunc("/light/set", func(w http.ResponseWriter, r *http.Request) { lights.mutex.Lock() defer lights.mutex.Unlock() request, err := ioutil.ReadAll(r.Body) if err != nil { log.Fatal(err) } var newTrafficLights trafficLights if err := json.Unmarshal(request, &amp;newTrafficLights); err != nil { http.Error(w, err.Error(), http.StatusBadRequest) return } if err := validateRequest(&amp;newTrafficLights); err != nil { http.Error(w, err.Error(), http.StatusBadRequest) return } lights = newTrafficLights }) //   () log.Fatal(http.ListenAndServe(":8080", nil)) } func validateRequest(lights *trafficLights) error { if lights.currentLight != lightRed &amp;&amp; lights.currentLight != lightYellow &amp;&amp; lights.currentLight != lightGreen { return fmt.Errorf("incorrect current light: %s", lights.currentLight) } return nil }</span></span></code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le code source complet de main.go est ici</a> . </p><br><p>  Ex√©cutez le programme: </p><br><pre> <code class="plaintext hljs">go run .</code> </pre> <br><p>  Esquiss√© tr√®s rapidement en 15 minutes!  Il s'est s√ªrement tromp√© quelque part, alors nous allons √©crire un test et v√©rifier. </p><br><p>  T√©l√©chargez et ex√©cutez Gonkey: </p><br><pre> <code class="plaintext hljs">mkdir -p tests/cases docker run -it -v $(pwd)/tests:/tests lamoda/gonkey -tests tests/cases -host host.docker.internal:8080</code> </pre> <br><p>  Cette commande d√©marre l'image avec gonkey via le docker, monte le r√©pertoire tests / cases √† l'int√©rieur du conteneur et d√©marre gonkey avec les param√®tres -tests tests / cases / -host. </p><br><p>  Si vous n'aimez pas l'approche docker, alors une alternative √† une telle commande serait d'√©crire: </p><br><pre> <code class="plaintext hljs">go get github.com/lamoda/gonkey go run github.com/lamoda/gonkey -tests tests/cases -host localhost:8080</code> </pre> <br><p>  Lanc√© et obtenu le r√©sultat: </p><br><pre> <code class="plaintext hljs">Failed tests: 0/0</code> </pre> <br><p>  Aucun test - rien √† v√©rifier.  √âcrivons le premier test.  Cr√©ez un fichier tests / cases / light_get.yaml avec le contenu minimum: </p><br><pre> <code class="plaintext hljs">- name: WHEN currentLight is requested MUST return red method: GET path: /light/get response: 200: &gt; { "currentLight": "red" }</code> </pre> <br><p>  Au premier niveau se trouve une liste.  Cela signifie que nous avons d√©crit un cas de test, mais il peut y en avoir plusieurs dans le fichier.  Ensemble, ils constituent le sc√©nario de test.  Ainsi, un fichier - un script.  Vous pouvez cr√©er n'importe quel nombre de fichiers avec des scripts de test, si vous le souhaitez, les organiser en sous-r√©pertoires - gonkey lit tous les fichiers yaml et yml du r√©pertoire transf√©r√© et est plus r√©cursif. </p><br><p>  Le fichier ci-dessous d√©crit les d√©tails de la requ√™te qui sera envoy√©e au serveur: m√©thode, chemin.  Le code de r√©ponse (200) et le corps de r√©ponse que nous attendons du serveur sont encore plus bas. </p><br><p>  Le format de fichier complet est d√©crit <a href="">dans le fichier README</a> . </p><br><p>  Ex√©cutez √† nouveau: </p><br><pre> <code class="plaintext hljs">docker run -it -v $(pwd)/tests:/tests lamoda/gonkey -tests tests/cases -host host.docker.internal:8080</code> </pre> <br><p>  R√©sultat: </p><br><pre> <code class="plaintext hljs"> Name: WHEN currentlight is requested MUST return red Request: Method: GET Path: /light/get Query: Body: &lt;no body&gt; Response: Status: 200 OK Body: {} Result: ERRORS! Errors: 1) at path $ values do not match: expected: { "currentLight": "red" } actual: {} Failed tests: 1/1</code> </pre> <br><p>  Erreur!  Une structure avec le champ currentLight √©tait attendue et une structure vide est retourn√©e.  C'est mauvais.  Le premier probl√®me est que le r√©sultat a √©t√© interpr√©t√© comme une cha√Æne, cela est indiqu√© par le fait que, en tant que lieu de probl√®me, gonkey a mis en √©vidence la r√©ponse enti√®re sans aucun d√©tail: </p><br><pre> <code class="plaintext hljs"> expected: { "currentLight": "red" }</code> </pre> <br><p>  La raison est simple: j'ai oubli√© d'√©crire pour que le service dans la r√©ponse indique le type de contenu application / json.  Nous r√©parons: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//       http.HandleFunc("/light/get", func(w http.ResponseWriter, r *http.Request) { lights.mutex.RLock() defer lights.mutex.RUnlock() resp, err := json.Marshal(lights) if err != nil { log.Fatal(err) } w.Header().Add("Content-Type", "application/json") // &lt;--  w.Write(resp) })</span></span></code> </pre> <br><p>  Nous red√©marrons le service et ex√©cutons √† nouveau les tests: </p><br><pre> <code class="plaintext hljs"> Name: WHEN currentlight is requested MUST return red Request: Method: GET Path: /light/get Query: Body: &lt;no body&gt; Response: Status: 200 OK Body: {} Result: ERRORS! Errors: 1) at path $ key is missing: expected: currentLight actual: &lt;missing&gt;</code> </pre> <br><p>  G√©nial, il y a du progr√®s.  Gonkey reconna√Æt maintenant la structure, mais elle est toujours incorrecte: la r√©ponse est vide.  La raison en est que j'ai utilis√© un champ currentLight non exportable dans la d√©finition de type: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//      type trafficLights struct { currentLight string `json:"currentLight"` mutex sync.RWMutex `json:"-"` }</span></span></code> </pre> <br><p>  Dans Go, un champ de structure nomm√© avec une lettre minuscule est consid√©r√© comme non exportable, c'est-√†-dire inaccessible √† partir d'autres packages.  Le s√©rialiseur JSON ne le voit pas et ne peut pas l'inclure dans la r√©ponse.  Nous corrigeons: nous faisons le champ avec une majuscule, ce qui signifie qu'il est export√©: </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//      type trafficLights struct { urrentLight string `json:"currentLight"` // &lt;--   mutex sync.RWMutex `json:"-"` }</span></span></code> </pre> <br><p>  Red√©marrez le service.  Ex√©cutez √† nouveau les tests. </p><br><pre> <code class="plaintext hljs">Failed tests: 0/1</code> </pre> <br><p>  Les tests ont r√©ussi! </p><br><p>  Nous allons √©crire un autre script qui testera la m√©thode set.  Remplissez le fichier tests / cases / light_set.yaml avec le contenu suivant: </p><br><pre> <code class="plaintext hljs">- name: WHEN set is requested MUST return no response method: POST path: /light/set request: &gt; { "currentLight": "green" } response: 200: '' - name: WHEN get is requested MUST return green method: GET path: /light/get response: 200: &gt; { "currentLight": "green" }</code> </pre> <br><p>  Le premier test d√©finit une nouvelle valeur pour le feu de circulation, et le second v√©rifie l'√©tat pour s'assurer qu'il a chang√©. </p><br><p>  Ex√©cutez les tests avec la m√™me commande: </p><br><pre> <code class="plaintext hljs">docker run -it -v $(pwd)/tests:/tests lamoda/gonkey -tests tests/cases -host host.docker.internal:8080</code> </pre> <br><p>  R√©sultat: </p><br><pre> <code class="plaintext hljs">Failed tests: 0/3</code> </pre> <br><p>  Un r√©sultat r√©ussi, mais nous avons eu la chance que les scripts aient √©t√© ex√©cut√©s dans l'ordre dont nous avions besoin: d'abord light_get, puis light_set.  Que se passerait-il s'ils faisaient le contraire?  Renommons: </p><br><pre> <code class="plaintext hljs">mv tests/cases/light_set.yaml tests/cases/_light_set.yaml</code> </pre> <br><p>  Et ex√©cutez √† nouveau: </p><br><pre> <code class="plaintext hljs">Errors: 1) at path $.currentLight values do not match: expected: red actual: green Failed tests: 1/3</code> </pre> <br><p>  Tout d'abord, le jeu a √©t√© ex√©cut√© et le feu de signalisation a √©t√© laiss√© dans l'√©tat vert, donc le test de d√©marrage a ensuite trouv√© une erreur - il attendait le rouge. </p><br><p>  Une fa√ßon de se d√©barrasser du fait que le test d√©pend du contexte est d'initialiser le service au d√©but du script (c'est-√†-dire au d√©but du fichier), ce que nous faisons g√©n√©ralement dans l'ensemble de test - nous d√©finissons d'abord une valeur connue qui devrait produire un effet connu, puis v√©rifiez que l'effet a eu un effet. </p><br><p>  Une autre fa√ßon de pr√©parer le contexte d'ex√©cution si le service utilise la base de donn√©es consiste √† utiliser des appareils avec des donn√©es qui sont charg√©es dans la base de donn√©es au d√©but du script, formant ainsi un √©tat pr√©visible du service qui peut √™tre v√©rifi√©.  La description et les exemples de travail avec des appareils dans gonkey que je veux mettre dans un article s√©par√©. </p><br><p>  En attendant, je propose la solution suivante.  √âtant donn√© que dans le script set, nous testons √† la fois la m√©thode light / set et la m√©thode light / get, nous n'avons tout simplement pas besoin du script light_get, qui est sensible au contexte.  Je le supprime et renomme le script restant afin que le nom refl√®te l'essence. </p><br><pre> <code class="plaintext hljs">rm tests/cases/light_get.yaml mv tests/cases/_light_set.yaml tests/cases/light_set_get.yaml</code> </pre> <br><p>  √Ä l'√©tape suivante, je voudrais v√©rifier certains sc√©narios n√©gatifs de collaboration avec notre service, par exemple, cela fonctionnera-t-il correctement si j'envoie une couleur de signal incorrecte?  Ou ne pas envoyer de couleur du tout? </p><br><p>  Cr√©ez un nouveau script tests / cases / light_set_get_negative.yaml: </p><br><pre> <code class="plaintext hljs">- name: WHEN set is requested MUST return no response method: POST path: /light/set request: &gt; { "currentLight": "green" } response: 200: '' - name: WHEN incorrect color is passed MUST return error method: POST path: /light/set request: &gt; { "currentLight": "blue" } response: 400: &gt; incorrect current light: blue - name: WHEN color is missing MUST return error method: POST path: /light/set request: &gt; {} response: 400: &gt; incorrect current light: - name: WHEN get is requested MUST have color untouched method: GET path: /light/get response: 200: &gt; { "currentLight": "green" }</code> </pre> <br><p>  Il v√©rifie que: </p><br><ul><li>  lorsque la mauvaise couleur est transmise, une erreur se produit; </li><li>  lorsque la couleur n'est pas transmise, une erreur se produit; </li><li>  une transmission incorrecte des couleurs ne modifie pas l'√©tat interne du feu de circulation. </li></ul><br><p>  Ex√©cuter: </p><br><pre> <code class="plaintext hljs">Failed tests: 0/6</code> </pre> <br><p>  Tout va bien :) </p><br><h3 id="podklyuchaem-gonkey-kak-biblioteku">  Connecter Gonkey en tant que biblioth√®que </h3><br><p>  Comme vous l'avez remarqu√©, nous testons l'API de service, en faisant compl√®tement abstraction du langage et des technologies dans lesquels elle est √©crite.  De la m√™me mani√®re, nous pourrions tester n'importe quelle API publique pour laquelle nous n'avons pas acc√®s aux codes sources - il suffit d'envoyer des demandes et de recevoir des r√©ponses. </p><br><p>  Mais pour nos propres applications √©crites en go, il existe un moyen plus pratique d'ex√©cuter gonkey - pour le connecter au projet en tant que biblioth√®que.  Cela permettra, sans rien compiler √† l'avance - ni gonkey, ni le projet lui-m√™me - d'ex√©cuter le test en ex√©cutant simplement <code>go test</code> . </p><br><p>  Avec cette approche, nous semblons commencer √† √©crire un test unitaire, et dans le corps du test, nous faisons ce qui suit: </p><br><ul><li>  initialiser le serveur Web de la m√™me mani√®re qu'au d√©marrage du service; </li><li>  ex√©cutez le serveur d'applications de test sur l'h√¥te local et le port al√©atoire; </li><li>  nous appelons la fonction √† partir de la biblioth√®que gonkey, en lui passant l'adresse du serveur de test et d'autres param√®tres.  Ci-dessous, je vais illustrer cela. </li></ul><br><p>  Pour ce faire, notre application aura besoin d'un petit refactoring.  Son point cl√© est de faire de la cr√©ation du serveur une fonction distincte, car nous avons maintenant besoin de cette fonction √† deux endroits: lorsque le service d√©marre et m√™me lorsque les tests gonkey sont ex√©cut√©s. </p><br><p>  J'ai mis le code suivant dans une fonction distincte: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">initServer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">//       http.HandleFunc("/light/get", func(w http.ResponseWriter, r *http.Request) { //   }) //       http.HandleFunc("/light/set", func(w http.ResponseWriter, r *http.Request) { //   }) }</span></span></code> </pre> <br><p>  La fonction principale sera alors la suivante: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { initServer() <span class="hljs-comment"><span class="hljs-comment">//   () log.Fatal(http.ListenAndServe(":8080", nil)) }</span></span></code> </pre> <br><p>  <a href="">Le fichier go principal modifi√© compl√®tement</a> . </p><br><p>  Cela a lib√©r√© nos mains, alors commen√ßons √† √©crire un test.  Je cr√©e un fichier func_test.go: </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Test_API</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span></span> { initServer() srv := httptest.NewServer(<span class="hljs-literal"><span class="hljs-literal">nil</span></span>) runner.RunWithTesting(t, &amp;runner.RunWithTestingParams{ Server: srv, TestsDir: <span class="hljs-string"><span class="hljs-string">"tests/cases"</span></span>, }) }</code> </pre> <br><p>  <a href="">Voici le fichier func_test.go complet</a> . </p><br><p>  C'est tout!  Nous v√©rifions: </p><br><pre> <code class="plaintext hljs">go test ./...</code> </pre> <br><p>  R√©sultat: </p><br><pre> <code class="plaintext hljs">ok github.com/lamoda/gonkey/examples/traffic-lights-demo 0.018s</code> </pre> <br><p>  Les tests ont r√©ussi.  Si j'ai √† la fois des tests unitaires et des tests de gonkey, ils fonctionneront tous ensemble - tr√®s facilement. </p><br><h3 id="formiruem-otchet-allure">  G√©n√©rer un rapport Allure </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Allure</a> est un format de rapport de test pour afficher les r√©sultats d'une mani√®re claire et belle.  Gonkey peut enregistrer les r√©sultats des tests dans ce format.  L'activation d'Allure est tr√®s simple: </p><br><pre> <code class="plaintext hljs">docker run -it -v $(pwd)/tests:/tests -w /tests lamoda/gonkey -tests cases/ -host host.docker.internal:8080 -allure</code> </pre> <br><p>  Le rapport sera plac√© dans le sous-r√©pertoire allure-results du r√©pertoire de travail actuel (c'est pourquoi j'ai sp√©cifi√© -w / tests). </p><br><p>  Lors de la connexion de gonkey en tant que biblioth√®que, le rapport Allure est activ√© en d√©finissant une variable d'environnement suppl√©mentaire GONKEY_ALLURE_DIR: </p><br><pre> <code class="plaintext hljs">GONKEY_ALLURE_DIR="tests/allure-results" go test ./‚Ä¶</code> </pre> <br><p>  Les r√©sultats des tests enregistr√©s dans des fichiers sont convertis en un rapport interactif par les commandes: </p><br><pre> <code class="plaintext hljs">allure generate allure serve</code> </pre> <br><p>  √Ä quoi ressemble le rapport: <br><img src="https://habrastorage.org/webt/bq/z-/ds/bqz-dsu89nodwlzi_im5nxr0t-k.png" alt="image"></p><br><h3 id="zaklyuchenie">  Conclusion </h3><br><p>  Dans les articles suivants, je m'attarderai sur l'utilisation de fixtures chez gonkey et sur l'imitation des r√©ponses d'autres services utilisant des simulacres. </p><br><p>  Je vous invite <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√† essayer gonkey</a> dans vos projets, √† participer √† son d√©veloppement (les demandes de pool sont les bienvenues!) Ou √† le marquer d'un ast√©risque sur le github si ce projet peut vous √™tre utile dans le futur. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr463301/">https://habr.com/ru/post/fr463301/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr463291/index.html">D√©s ou os</a></li>
<li><a href="../fr463293/index.html">Collecteur d'ordures. Cours complet + transfert de BOTR</a></li>
<li><a href="../fr463295/index.html">C ++ et CMake - Brothers Forever, Partie II</a></li>
<li><a href="../fr463297/index.html">Fid√©lit√© √† votre go√ªt</a></li>
<li><a href="../fr463299/index.html">Trucs et astuces Kubernetes: comment augmenter la productivit√©</a></li>
<li><a href="../fr463303/index.html">Facebook arr√™te enfin de cibler les annonces pour les num√©ros de t√©l√©phone que les gens saisissent pour 2FA</a></li>
<li><a href="../fr463305/index.html">Outils d'analyse et de d√©bogage des applications .NET</a></li>
<li><a href="../fr463307/index.html">√âtude de cas sur la communication avec un client ¬´lourd¬ª</a></li>
<li><a href="../fr463311/index.html">CTT dans les solutions serveur. La deuxi√®me version + l'annonce de la troisi√®me, avec la possibilit√© de toucher</a></li>
<li><a href="../fr463313/index.html">Une approche alternative pour vous abonner √† des √©v√©nements, ou EventObject est-il vraiment n√©cessaire?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>