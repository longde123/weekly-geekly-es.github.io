<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙍 👩🏽‍🤝‍👨🏼 🔎 使用Python从超级马里奥兄弟中获取关卡 ⏏️ 🤩 🚗</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="引言 
 对于一个新项目，我需要从1985年经典的视频游戏《 超级马里奥兄弟》（SMB）中提取关卡数据。 更具体地说，我想在没有界面，移动精灵等的情况下提取游戏各个级别的背景图形。 

 当然，我只是可以粘贴游戏中的图像，并可能使用机器视觉技术使过程自动化。 但是在我看来，以下描述的方法更有趣，该方...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用Python从超级马里奥兄弟中获取关卡</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416241/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/707/a7a/80a/707a7a80afb88c419beb17be9e108272.png"></div><br><h2> 引言 </h2><br> 对于一个新项目，我需要从1985年经典的视频游戏《 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">超级马里奥兄弟》（SMB）中</a>提取关卡数据。 更具体地说，我想在没有界面，移动精灵等的情况下提取游戏各个级别的背景图形。 <br><br> 当然，我只是可以粘贴游戏中的图像，并可能使用机器视觉技术使过程自动化。 但是在我看来，以下描述的方法更有趣，该方法使您可以探索无法使用屏幕截图获得的那些关卡元素。 <br><br> 在项目的第一阶段，我们将学习6502汇编语言和用Python编写的仿真器。 完整的源代码<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在这里</a> 。 <br><a name="habracut"></a><br><h2> 源代码分析 </h2><br> 如果您有程序的源代码，则对任何程序进行逆向工程都非常简单，并且我们有SMB源代码，形式是doppelganger发布的17,000 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">行汇编代码6502（NES处理器）</a> 。 由于Nintendo从未发布过正式的源代码发布，因此该代码是通过分解SMB机器代码，痛苦地解密每个部分的含义，添加注释和有意义的符号名称来创建的。 <br><br> 对文件执行快速搜索后，我发现了一些与我们所需的级别数据类似的东西： <br><br> <code>;level 1-1 <br> L_GroundArea6: <br> .db $50, $21 <br> .db $07, $81, $47, $24, $57, $00, $63, $01, $77, $01 <br> .db $c9, $71, $68, $f2, $e7, $73, $97, $fb, $06, $83 <br> .db $5c, $01, $d7, $22, $e7, $00, $03, $a7, $6c, $02 <br> .db $b3, $22, $e3, $01, $e7, $07, $47, $a0, $57, $06 <br> .db $a7, $01, $d3, $00, $d7, $01, $07, $81, $67, $20 <br> .db $93, $22, $03, $a3, $1c, $61, $17, $21, $6f, $33 <br> .db $c7, $63, $d8, $62, $e9, $61, $fa, $60, $4f, $b3 <br> .db $87, $63, $9c, $01, $b7, $63, $c8, $62, $d9, $61 <br> .db $ea, $60, $39, $f1, $87, $21, $a7, $01, $b7, $20 <br> .db $39, $f1, $5f, $38, $6d, $c1, $af, $26 <br> .db $fd</code> <br> <br> 如果您不熟悉汇编程序，那么我将进行解释：所有这一切仅意味着“将这样的字节集插入已编译的程序，然后允许程序的其他部分使用<code>L_GroundArea6</code>符号来引用它”。 您可以将此片段作为一个数组，其中每个元素都是一个字节。 <br><br> 您可以注意到的第一件事是数据量非常小（大约100个字节）。 因此，我们排除了所有类型的编码，使您可以随意在该级别放置块。 经过一番搜索，我发现在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AreaParserCore中</a>读取了此数据（经过几次间接寻址操作）。 该子过程继而调用许多其他子过程，最终为场景中允许的每种对象类型调用特定的子过程（例如<code>StaircaseObject</code> ， <code>VerticalPipe</code> ， <code>RowOfBricks</code> ）： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4e5/385/954/4e538595409be651da11d5166c97b130.png"></div><br>  <i><code>AreaParserCore</code>调用图</i> <br><br> 该过程将写入<code>MetatileBuffer</code> ：一个13字节的内存部分，它是级别中块的一列，每个字节代表一个单独的块。 一个metatile是一个16x16的块，用于构成SMB游戏的背景： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c27/d0b/bd9/c27d0bbd9fdce9bf86b56ce181b2747d.png"></div><br>  <i>围绕在分位数周围的矩形水平</i> <br><br> 它们被称为元文件，因为每个文件都由四个8x8像素的图块组成，但在下面进行了介绍。 <br><br> 解码器可与预定义对象一起工作的事实说明了级别的小规模：级别数据应仅指对象的类型及其位置，例如，“将管道放置在点（20，16），将多个块放置在点（10，5），... ”。 但是，这意味着需要大量代码才能将原始级别的数据转换为元文件。 <br><br> 移植大量代码以创建自己的级别解包器将花费太多时间，因此让我们尝试另一种方法。 <br><br><h2>  py65emu </h2><br> 如果我们在Python和6502汇编语言之间建立了接口， <code>AreaParserCore</code>以为每个级别列调用<code>AreaParserCore</code>子过程，然后使用更易理解的Python将块信息转换为所需的图像。 <br><br> 然后<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">py65emu</a>出现在场景中-具有Python界面的简洁6502仿真器。 这是在py65emu中配置与NES中相同的内存配置的方式： <br><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> py65emu.cpu <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CPU <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> py65emu.mmu <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> MMU <span class="hljs-comment"><span class="hljs-comment">#  ROM  (..  ) with open("program.bin", "rb") as f: prg_rom = f.read() #   . mmu = MMU([ #  2K ,    0x0. (0x0, 2048, False, []), #  ROM   0x8000. (0x8000, len(prg_rom), True, list(prg_rom)) ]) #     ,       0x8000 cpu = CPU(mmu, 0x8000)</span></span></code> </pre> <br> 之后，我们可以使用<code>cpu.step()</code>方法执行个别指令，使用<code>cpu.step()</code>检查内存，使用<code>cpu.ra</code> ， <code>cpu.r.pc</code>等研究机器寄存器。 另外，我们可以使用<code>mmu.write()</code>写入内存。 <br><br> 值得注意的是，这只是一个NES处理器仿真器：它不仿真其他硬件，例如PPU（图片处理单元），因此不能用于仿真整个游戏。 但是，调用解析子过程应该足够了，因为它不使用CPU和内存以外的任何其他硬件设备。 <br><br> 计划是如上所述配置CPU，然后对于每个级别列，使用<code>AreaParserCore</code>所需的输入值初始化内存分区，调用<code>AreaParserCore</code> ，然后读回列数据。 完成这些操作后，我们使用Python将结果组合成一个完整的图像。 <br><br> 但是在此之前，我们需要将汇编语言中的清单编译为机器代码。 <br><br><h2>  x816 </h2><br> 如源代码中所示，汇编程序是使用x816编译的。  x816是Homebrew社区用于NES和ROM黑客的MS-DOS汇编程序6502。 它在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">DOSBox上</a>很好用。 <br><br>  x816汇编程序连同py65emu必需的程序ROM一起创建了一个字符文件，该文件将字符映射到其在CPU地址空间中的内存位置。 这是该文件的一个片段： <br><br> <code>AREAPARSERCORE = $0093FC ; &lt;&gt; 37884, statement #3154 <br> AREAPARSERTASKCONTROL = $0086E6 ; &lt;&gt; 34534, statement #1570 <br> AREAPARSERTASKHANDLER = $0092B0 ; &lt;&gt; 37552, statement #3035 <br> AREAPARSERTASKNUM = $00071F ; &lt;&gt; 1823, statement #141 <br> AREAPARSERTASKS = $0092C8 ; &lt;&gt; 37576, statement #3048</code> <br> <br> 在这里我们看到源代码中的<code>AreaParserCore</code>函数可以在<code>0x93fc</code>处<code>0x93fc</code> 。 <br><br> 为了方便起见，我编写了一个符号文件解析器来匹配符号名称和地址： <br><br><pre> <code class="python hljs">sym_file = SymbolFile(<span class="hljs-string"><span class="hljs-string">'SMBDIS.SYM'</span></span>) print(<span class="hljs-string"><span class="hljs-string">"0x{:x}"</span></span>.format(sym_file[<span class="hljs-string"><span class="hljs-string">'AREAPARSERCORE'</span></span>])) <span class="hljs-comment"><span class="hljs-comment">#  0x93fc print(sym_file.lookup_address(0x93fc)) #  "AREAPARSERCORE"</span></span></code> </pre> <br><h2> 子程序 </h2><br> 如上面的计划所述，我们想学习如何从Python调用<code>AreaParserCore</code>子过程。 <br><br> 为了了解子过程的机制，让我们研究一个简短的子过程及其相应的挑战： <br><br><pre> <code class="python hljs">WritePPUReg1: sta PPU_CTRL_REG1 ;  A   <span class="hljs-number"><span class="hljs-number">1</span></span> PPU sta Mirror_PPU_CTRL_REG1 ;    rts ... jsr WritePPUReg1</code> </pre> <br>  <code>jsr</code> （跳转到子例程，“跳转到子例程”）指令<code>jsr</code> PC寄存器压入堆栈，并为其分配<code>WritePPUReg1</code>引用的地址值。  PC寄存器告诉处理器要加载的下一条指令的地址，以便在<code>jsr</code>指令之后执行的下一条指令是<code>WritePPUReg1</code>的第一行。 <br><br> 在子例程的末尾，将执行<code>rts</code>语句（从子例程返回，“从子例程返回”）。 该命令从堆栈中删除存储的值，并将其存储在PC寄存器中，这将强制CPU在<code>jsr</code>调用之后执行指令。 <br><br> 子过程的一个重要功能是您可以创建内联调用，即子过程中的子过程调用。 返回地址将被推入堆栈并以正确的顺序弹出，其方式与高级语言中的函数调用相同。 <br><br> 这是从Python执行子程序的代码： <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">execute_subroutine</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(cpu, addr)</span></span></span><span class="hljs-function">:</span></span> s_before = cpu.rs cpu.JSR(addr) <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> cpu.rs != s_before: cpu.step() execute_subroutine(cpu, sym_file[<span class="hljs-string"><span class="hljs-string">'AREAPARSERCORE'</span></span>])</code> </pre> <br> 该代码保存堆栈指针寄存器（ <code>s</code> ）的当前值，模拟<code>jsr</code>调用，然后执行指令，直到堆栈返回其原始高度（仅在返回第一个子过程之后才发生）。 这将很有用，因为现在我们有了一种从Python直接调用6502子例程的方法。 <br><br> 但是，我们忘记了一些事情：如何为该子过程传递输入值？ 我们需要告诉该过程我们要呈现的级别以及需要解析的列。 <br><br> 与高级语言中的函数不同，汇编语言6502的子例程无法接收明确指定的输入数据。 而是通过在调用之前的某个位置指定存储位置来传输输入，然后在子过程调用内部读取这些存储位置。 给定<code>AreaParserCore</code>的大小，只需查看源代码即可对所需输入进行反向工程，这将非常复杂且容易出错。 <br><br><h2>  Valgrind是否适合NES？ </h2><br> 为了找到确定<code>AreaParserCore</code>输入值的<code>AreaParserCore</code> ，我以Valgrind的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">memcheck</a>工具为例。  Memcheck通过与实际分配的内存的每个片段并行存储影子内存来识别对未初始化内存的访问操作。 影子存储器记录是否对相应的实际存储器进行了记录。 如果程序读取到从未写入的地址，则输出未初始化的存储器错误。 我们可以使用一个工具来运行<code>AreaParserCore</code> ，该工具告诉我们在调用子过程之前需要设置哪些输入。 <br><br> 实际上，为py65emu编写一个简单的memcheck版本非常容易： <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">format_addr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: symbol_name = sym_file.lookup_address(addr) s = <span class="hljs-string"><span class="hljs-string">"0x{:04x} ({}):"</span></span>.format(addr, symbol_name) <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyError: s = <span class="hljs-string"><span class="hljs-string">"0x{:04x}:"</span></span>.format(addr) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MemCheckMMU</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(MMU)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super().__init__(*args, **kwargs) self._uninitialized = array.array(<span class="hljs-string"><span class="hljs-string">'B'</span></span>, [<span class="hljs-number"><span class="hljs-number">1</span></span>] * <span class="hljs-number"><span class="hljs-number">2048</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, addr)</span></span></span><span class="hljs-function">:</span></span> val = super().read(addr) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> addr &lt; <span class="hljs-number"><span class="hljs-number">2048</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> self._uninitialized[addr]: print(<span class="hljs-string"><span class="hljs-string">"Uninitialized read! {}"</span></span>.format(format_addr(addr))) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, addr, val)</span></span></span><span class="hljs-function">:</span></span> super().write(addr, val) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> addr &lt; <span class="hljs-number"><span class="hljs-number">2048</span></span>: self._uninitialized[addr] = <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre> <br> 在这里，我们包装了py65emu的内存管理单元（MMU）。 此类包含一个<code>_uninitialized</code>数组，该数组的元素告诉我们是否曾经将其写入模拟RAM的相应字节。 如果未初始化读取，则会显示无效读取操作的地址和相应字符的名称。 <br><br> 这是调用<code>execute_subroutine(sym_file['AREAPARSERCORE'])</code>时<code>execute_subroutine(sym_file['AREAPARSERCORE'])</code> MMU的结果： <br><br> <code>Uninitialized read! 0x0728 (BACKLOADINGFLAG): <br> Uninitialized read! 0x0742 (BACKGROUNDSCENERY): <br> Uninitialized read! 0x0741 (FOREGROUNDSCENERY): <br> Uninitialized read! 0x074e (AREATYPE): <br> Uninitialized read! 0x075f (WORLDNUMBER): <br> Uninitialized read! 0x0743 (CLOUDTYPEOVERRIDE): <br> Uninitialized read! 0x0727 (TERRAINCONTROL): <br> Uninitialized read! 0x0743 (CLOUDTYPEOVERRIDE): <br> Uninitialized read! 0x074e (AREATYPE): <br> ...</code> <br> <br> 通过查看代码，您可以看到许多这些值是由<code>InitializeArea</code>子过程设置的，因此让我们再次运行脚本，首先调用此函数。 重复此过程，我们进行以下呼叫顺序，该呼叫顺序仅需要世界号码和区域号码： <br><br><pre> <code class="python hljs">mmu.write(sym_file[<span class="hljs-string"><span class="hljs-string">'WORLDNUMBER'</span></span>], <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">#    1 mmu.write(sym_file['AREANUMBER'], 0) #    1 execute_subroutine(sym_file['LOADAREAPOINTER']) execute_subroutine(sym_file['INITIALIZEAREA']) metatile_data = [] for column_pos in range(48): execute_subroutine(sym_file['AREAPARSERCORE']) metatile_data.append([mmu.read_no_debug(sym_file['METATILEBUFFER'] + i) for i in range(13)]) execute_subroutine(sym_file['INCREMENTCOLUMNPOS'])</span></span></code> </pre> <br> 该代码使用<code>IncrementColumnPos</code>子过程来增加World 1-1级别的前48列到<code>metatile_data</code> ，以增加跟踪当前列所需的内部变量。 <br><br> 这是<code>metatile_data</code>的内容，叠加在游戏的屏幕截图上（未显示值为0的字节）： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/707/a7a/80a/707a7a80afb88c419beb17be9e108272.png"></div><br> 显然， <code>metatile_data</code>显然与背景信息匹配。 <br><br><h2> 元图形 </h2><br>  （要查看最终结果，您可以立即进入“将所有内容连接在一起”部分。） <br><br> 现在让我们弄清楚如何将接收到的许多元文件转换为真实图像。 下面描述的步骤是通过分析源代码以及使用令人惊叹的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nesdev Wiki</a>阅读文档而发明的。 <br><br> 要了解如何渲染每个元数据，我们首先需要讨论NES调色板。  NES控制台PPU通常可以渲染64种不同的颜色，但是黑色会重复多次（有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">详细信息，</a>请参阅<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nesdev</a> ）： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cdf/997/328/cdf9973289e05f09899c36ca04cb6a4d.png"></div><br> 每个Mario级别只能使用这64种颜色中的10种作为背景，分为4个四色调色板；每个色阶都可以使用。 第一种颜色总是相同的。 这是World 1-1的四个调色板： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/699/15d/821/69915d821a10f3e7c668abe2894bc7a3.png"></div><br> 现在，让我们看一个元文件编号的二进制示例。 这是破裂的石瓦的分位数，是世界1-1级的土地： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/85f/1a1/9ae/85f1a19aea1e39a511dc2bfe31e72d05.png"></div><br> 调色板索引告诉我们在渲染metatile时要使用哪个调色板（在我们的示例中为调色板1）。 调色板索引也是以下两个数组的索引： <br><br> <code>MetatileGraphics_Low: <br> .db &lt;Palette0_MTiles, &lt;Palette1_MTiles, &lt;Palette2_MTiles, &lt;Palette3_MTiles <br> <br> MetatileGraphics_High: <br> .db &gt;Palette0_MTiles, &gt;Palette1_MTiles, &gt;Palette2_MTiles, &gt;Palette3_MTiles</code> <br> <br> 这两个数组的组合为我们提供了一个16位地址，在我们的示例中，该地址指向<code>Palette1_Mtiles</code> ： <br><br> <code>Palette1_MTiles: <br> .db $a2, $a2, $a3, $a3 ;vertical rope <br> .db $99, $24, $99, $24 ;horizontal rope <br> .db $24, $a2, $3e, $3f ;left pulley <br> .db $5b, $5c, $24, $a3 ;right pulley <br> .db $24, $24, $24, $24 ;blank used for balance rope <br> .db $9d, $47, $9e, $47 ;castle top <br> .db $47, $47, $27, $27 ;castle window left <br> .db $47, $47, $47, $47 ;castle brick wall <br> .db $27, $27, $47, $47 ;castle window right <br> .db $a9, $47, $aa, $47 ;castle top w/ brick <br> .db $9b, $27, $9c, $27 ;entrance top <br> .db $27, $27, $27, $27 ;entrance bottom <br> .db $52, $52, $52, $52 ;green ledge stump <br> .db $80, $a0, $81, $a1 ;fence <br> .db $be, $be, $bf, $bf ;tree trunk <br> .db $75, $ba, $76, $bb ;mushroom stump top <br> .db $ba, $ba, $bb, $bb ;mushroom stump bottom <br> .db $45, $47, $45, $47 ;breakable brick w/ line <br> .db $47, $47, $47, $47 ;breakable brick <br> .db $45, $47, $45, $47 ;breakable brick (not used) <br> .db $b4, $b6, $b5, $b7 ;cracked rock terrain &lt;--- This is the 20th line <br> .db $45, $47, $45, $47 ;brick with line (power-up) <br> .db $45, $47, $45, $47 ;brick with line (vine) <br> .db $45, $47, $45, $47 ;brick with line (star) <br> .db $45, $47, $45, $47 ;brick with line (coins) <br> ...</code> <br> <br> 当您将元位数索引乘以4时，它将成为此数组的索引。 数据的格式为每行4条记录，因此我们的示例metatile引用了第二十行，并标有<code>cracked rock terrain</code>注释。 <br><br> 该行的四个条目实际上是图块标识符：每个metatile由四个8x8像素图块组成，这些图块按以下顺序排列-左上，左下，右上和右下。 这些标识符直接传递到NES PPU控制台。 标识符引用CHR-ROM控制台中的16个字节的数据，并且每个记录<code>0x1000 + 16 * &lt; &gt;</code>地址<code>0x1000 + 16 * &lt; &gt;</code>开头： <br><br> <code>0x1000 + 16 * 0xb4: 0b01111111 0x1000 + 16 * 0xb5: 0b11011110 <br> 0x1001 + 16 * 0xb4: 0b10000000 0x1001 + 16 * 0xb5: 0b01100001 <br> 0x1002 + 16 * 0xb4: 0b10000000 0x1002 + 16 * 0xb5: 0b01100001 <br> 0x1003 + 16 * 0xb4: 0b10000000 0x1003 + 16 * 0xb5: 0b01100001 <br> 0x1004 + 16 * 0xb4: 0b10000000 0x1004 + 16 * 0xb5: 0b01110001 <br> 0x1005 + 16 * 0xb4: 0b10000000 0x1005 + 16 * 0xb5: 0b01011110 <br> 0x1006 + 16 * 0xb4: 0b10000000 0x1006 + 16 * 0xb5: 0b01111111 <br> 0x1007 + 16 * 0xb4: 0b10000000 0x1007 + 16 * 0xb5: 0b01100001 <br> 0x1008 + 16 * 0xb4: 0b10000000 0x1008 + 16 * 0xb5: 0b01100001 <br> 0x1009 + 16 * 0xb4: 0b01111111 0x1009 + 16 * 0xb5: 0b11011111 <br> 0x100a + 16 * 0xb4: 0b01111111 0x100a + 16 * 0xb5: 0b11011111 <br> 0x100b + 16 * 0xb4: 0b01111111 0x100b + 16 * 0xb5: 0b11011111 <br> 0x100c + 16 * 0xb4: 0b01111111 0x100c + 16 * 0xb5: 0b11011111 <br> 0x100d + 16 * 0xb4: 0b01111111 0x100d + 16 * 0xb5: 0b11111111 <br> 0x100e + 16 * 0xb4: 0b01111111 0x100e + 16 * 0xb5: 0b11000001 <br> 0x100f + 16 * 0xb4: 0b01111111 0x100f + 16 * 0xb5: 0b11011111 <br> <br> 0x1000 + 16 * 0xb6: 0b10000000 0x1000 + 16 * 0xb7: 0b01100001 <br> 0x1001 + 16 * 0xb6: 0b10000000 0x1001 + 16 * 0xb7: 0b01100001 <br> 0x1002 + 16 * 0xb6: 0b11000000 0x1002 + 16 * 0xb7: 0b11000001 <br> 0x1003 + 16 * 0xb6: 0b11110000 0x1003 + 16 * 0xb7: 0b11000001 <br> 0x1004 + 16 * 0xb6: 0b10111111 0x1004 + 16 * 0xb7: 0b10000001 <br> 0x1005 + 16 * 0xb6: 0b10001111 0x1005 + 16 * 0xb7: 0b10000001 <br> 0x1006 + 16 * 0xb6: 0b10000001 0x1006 + 16 * 0xb7: 0b10000011 <br> 0x1007 + 16 * 0xb6: 0b01111110 0x1007 + 16 * 0xb7: 0b11111110 <br> 0x1008 + 16 * 0xb6: 0b01111111 0x1008 + 16 * 0xb7: 0b11011111 <br> 0x1009 + 16 * 0xb6: 0b01111111 0x1009 + 16 * 0xb7: 0b11011111 <br> 0x100a + 16 * 0xb6: 0b11111111 0x100a + 16 * 0xb7: 0b10111111 <br> 0x100b + 16 * 0xb6: 0b00111111 0x100b + 16 * 0xb7: 0b10111111 <br> 0x100c + 16 * 0xb6: 0b01001111 0x100c + 16 * 0xb7: 0b01111111 <br> 0x100d + 16 * 0xb6: 0b01110001 0x100d + 16 * 0xb7: 0b01111111 <br> 0x100e + 16 * 0xb6: 0b01111111 0x100e + 16 * 0xb7: 0b01111111 <br> 0x100f + 16 * 0xb6: 0b11111111 0x100f + 16 * 0xb7: 0b01111111</code> <br> <br>  CHR-ROM是只读存储器，只有PPU可以访问。 它与存储程序代码的PRG-ROM分开。 因此，以上数据在源代码中不可用，必须从游戏ROM的转储中获取。 <br><br> 每个图块16字节组成一个2位8x8图块：第一位是前8个字节，第二个是后8个字节： <br><br> <code>21111111 13211112 <br> 12222222 23122223 <br> 12222222 23122223 <br> 12222222 23122223 <br> 12222222 23132223 <br> 12222222 23233332 <br> 12222222 23111113 <br> 12222222 23122223 <br> <br> 12222222 23122223 <br> 12222222 23122223 <br> 33222222 31222223 <br> 11332222 31222223 <br> 12113333 12222223 <br> 12221113 12222223 <br> 12222223 12222233 <br> 23333332 13333332</code> <br> <br> 将此数据绑定到选项板1： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02e/32a/ad5/02e32aad5717393bd296dd35983e294b.png"></div><br>  ...并结合各个部分： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/950/86a/103/95086a103b16d361c72c0250781ebfd5.png"></div><br> 最后，我们得到了一个渲染图块。 <br><br><h2> 全部放在一起 </h2><br> 对每个图元文件重复此过程，我们将获得一个完全渲染的级别。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/322/45d/a3b/32245da3b8b4707764cef5231e040474.png"></div><br> 多亏了这一点，我们能够使用Python提取SMB级图形！ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN416241/">https://habr.com/ru/post/zh-CN416241/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN416229/index.html">设计师应阅读的10本有关营销和相关主题的书</a></li>
<li><a href="../zh-CN416231/index.html">监控Zadarma Zabbix房间</a></li>
<li><a href="../zh-CN416235/index.html">为Bootstrap 4创建自定义组件</a></li>
<li><a href="../zh-CN416237/index.html">成为设计师：从旅馆的自由职业者到与顶尖公司合作并推出您的产品</a></li>
<li><a href="../zh-CN416239/index.html">PMO在设计公司中的角色和功能</a></li>
<li><a href="../zh-CN416243/index.html">钴的替代品，电池中的这种血腥钻石</a></li>
<li><a href="../zh-CN416245/index.html">我们在Aimylogic上创建了一个机器人来自动化在线商店</a></li>
<li><a href="../zh-CN416247/index.html">如何为商务旅行做准备？ ISPsystem bizdedev的提示</a></li>
<li><a href="../zh-CN416251/index.html">T恤上的3D打印</a></li>
<li><a href="../zh-CN416253/index.html">Sketchfab，Unity，Blend4Web，PlayCanvas和现在的Verge3D</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>