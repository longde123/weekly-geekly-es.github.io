<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï∫üèæ üë®üèª üññüèº Utilisation des rappels dans React üâë üëå üë©üèø‚Äçü§ù‚Äçüë©üèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Au cours de mon travail, je suis p√©riodiquement tomb√© sur le fait que les d√©veloppeurs ne comprennent pas toujours clairement comment le m√©canisme de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Utilisation des rappels dans React</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/hh/blog/439138/"><p>  Au cours de mon travail, je suis p√©riodiquement tomb√© sur le fait que les d√©veloppeurs ne comprennent pas toujours clairement comment le m√©canisme de transmission des donn√©es via les accessoires, en particulier les rappels, et pourquoi leurs PureComponents sont mis √† jour si souvent. </p><br><p>  Par cons√©quent, dans cet article, nous comprendrons comment les rappels sont pass√©s √† React et discuterons √©galement des fonctionnalit√©s des gestionnaires d'√©v√©nements. <a name="habracut"></a></p><br><h3 id="tldr">  TL; DR </h3><br><ol><li>  N'interf√©rez pas avec JSX et la logique m√©tier - cela compliquera la perception du code. </li><li>  Pour les petites optimisations, les fonctions du gestionnaire de cache sous la forme de classProperties pour les classes ou en utilisant useCallback pour les fonctions - alors les composants purs ne seront pas constamment rendus.  En particulier, la mise en cache des rappels peut √™tre utile afin que lorsqu'ils sont transmis au PureComponent, des cycles de mise √† jour inutiles ne se produisent pas. </li><li>  N'oubliez pas que vous n'obtenez pas un √©v√©nement r√©el dans le rappel, mais un √©v√©nement Syntetic.  Si vous quittez la fonction actuelle, vous ne pourrez pas acc√©der aux champs de cet √©v√©nement.  Mettez en cache les champs dont vous avez besoin si vous avez des fermetures asynchrones. </li></ol><br><h3 id="chast-1-event-handlers-keshirovanie-i-vospriyatie-koda">  Partie 1. Gestionnaires d'√©v√©nements, mise en cache et perception du code </h3><br><p>  React fournit un moyen assez pratique d'ajouter des gestionnaires d'√©v√©nements pour les √©l√©ments html. </p><br><p>  C'est l'une des choses fondamentales que tout d√©veloppeur apprend lorsqu'il commence √† √©crire dans React: </p><br><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{()</span></span></span></span><span class="xml"><span class="hljs-tag"> =&gt;</span></span></span><span class="xml"> console.log('Hello world!')}&gt;Click me</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } }</code> </pre> <br><p>  Assez simple?  √Ä partir de ce code, il devient imm√©diatement clair ce qui se passera lorsque l'utilisateur cliquera sur le bouton. </p><br><p>  Mais que se passe-t-il si le code dans le gestionnaire devient de plus en plus? </p><br><p>  Supposons que par un bouton, nous devons charger et filtrer tous ceux qui ne font pas partie d'une √©quipe particuli√®re ( <code>user.team === 'search-team'</code> ), puis les trier par √¢ge. </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(props) { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state = { <span class="hljs-attr"><span class="hljs-attr">users</span></span>: [] }; } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;div&gt; &lt;ul&gt; {</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params">.state.users.map(user =&gt; ( &lt;li&gt;{user.name}&lt;</span></span><span class="hljs-regexp"><span class="hljs-function"><span class="hljs-params"><span class="hljs-regexp">/li&gt; ))} &lt;/u</span></span></span></span><span class="hljs-function"><span class="hljs-params">l&gt; &lt;button onClick={(</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Hello world!'</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">window</span></span> .fetch(<span class="hljs-string"><span class="hljs-string">'/usersList'</span></span>) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function"> =&gt;</span></span> result.json()) .then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">data</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> users = data .filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function"> =&gt;</span></span> user.team === <span class="hljs-string"><span class="hljs-string">'search-team'</span></span>) .sort(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a.age &gt; b.age) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a.age &lt; b.age) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({ <span class="hljs-attr"><span class="hljs-attr">users</span></span>: users, }); }); }} &gt; Load users &lt;<span class="hljs-regexp"><span class="hljs-regexp">/button&gt; &lt;/</span></span>div&gt; ); } }</code> </pre> <br><p>  Ce code est assez difficile √† comprendre.  Le code de logique m√©tier est m√©lang√© avec la mise en page que l'utilisateur voit. </p><br><p>  Le moyen le plus simple de s'en d√©barrasser est de prendre la fonction au niveau des m√©thodes de classe: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ fetchUsers() { <span class="hljs-comment"><span class="hljs-comment">//    } render() { return ( &lt;div&gt; &lt;ul&gt; {this.state.users.map(user =&gt; ( &lt;li&gt;{user.name}&lt;/li&gt; ))} &lt;/ul&gt; &lt;button onClick={() =&gt; this.fetchUsers()}&gt;Load users&lt;/button&gt; &lt;/div&gt; ); } }</span></span></code> </pre> <br><p>  Ici, nous avons d√©plac√© la logique m√©tier du code JSX vers un champ distinct de notre classe.  Pour rendre cela accessible √† l'int√©rieur de la fonction, nous avons d√©fini le rappel de cette fa√ßon: <code>onClick={() =&gt; this.fetchUsers()}</code> </p><br><p>  De plus, lors de la description d'une classe, nous pouvons d√©clarer un champ comme une fonction de fl√®che: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ fetchUsers = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//    }; render() { return ( &lt;div&gt; &lt;ul&gt; {this.state.users.map(user =&gt; ( &lt;li&gt;{user.name}&lt;/li&gt; ))} &lt;/ul&gt; &lt;button onClick={this.fetchUsers}&gt;Load users&lt;/button&gt; &lt;/div&gt; ); } }</span></span></code> </pre> <br><p>  Cela nous permettra de d√©clarer le rappel comme <code>onClick={this.fetchUsers}</code> </p><br><p>  <strong>Quelle est la diff√©rence entre ces deux m√©thodes?</strong> </p><br><p>  <code>onClick={this.fetchUsers}</code> - Ici, √† chaque appel √† la fonction de rendu dans les accessoires, le <code>button</code> recevra toujours le m√™me lien. </p><br><p>  Dans le cas de <code>onClick={() =&gt; this.fetchUsers()}</code> , chaque fois que la fonction de rendu est appel√©e, JavaScript initialise une nouvelle fonction <code>() =&gt; this.fetchUsers()</code> et la d√©finit sur prop <code>onClick</code> .  Cela signifie que <code>nextProp.onClick</code> et <code>prop.onClick</code> sur le <code>button</code> dans ce cas ne seront toujours pas √©gaux, et m√™me si le composant est marqu√© comme propre, il sera rendu. </p><br><p>  <strong>Qu'est-ce que cela menace pour le d√©veloppement?</strong> </p><br><p>  Dans la plupart des cas, vous ne remarquerez pas de baisse des performances visuellement, car le DOM virtuel qui sera g√©n√©r√© par le composant ne diff√©rera pas du pr√©c√©dent et il n'y aura aucun changement dans votre DOM. </p><br><p>  Cependant, si vous affichez de grandes listes de composants ou de tableaux, vous remarquerez des "freins" sur une grande quantit√© de donn√©es. </p><br><p>  <strong>Pourquoi est-il important de comprendre comment une fonction est transf√©r√©e vers le rappel?</strong> </p><br><p>  Souvent sur Twitter ou sur stackoverflow, vous pouvez trouver de tels conseils: </p><br><p>  "Si vous rencontrez des probl√®mes de performances avec les applications React, essayez de remplacer l'h√©ritage de Component par PureComponent. De plus, n'oubliez pas que pour Component, vous pouvez toujours d√©finir shouldComponentUpdate pour √©liminer les boucles de mise √† jour inutiles." </p><br><p>  Si nous d√©finissons un composant comme Pure, cela signifie qu'il a d√©j√† une fonction <code>shouldComponentUpdate</code> qui fait shallowEqual entre les accessoires et les nextProps. </p><br><p>  En passant √† chaque fois une nouvelle fonction de rappel √† un tel composant, nous perdons tous les avantages et optimisations de <code>PureComponent</code> . </p><br><p>  Regardons un exemple. <br>  Cr√©ez un composant d'entr√©e qui affichera √©galement des informations sur le nombre de fois qu'il a √©t√© mis √† jour: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Input</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PureComponent</span></span></span><span class="hljs-class"> </span></span>{ renderedCount = <span class="hljs-number"><span class="hljs-number">0</span></span>; render() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.renderedCount++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">input</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onChange</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.props.onChange}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Input component was rerendered {this.renderedCount} times</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); } }</span></span></code> </pre> <br><p>  Cr√©ons deux composants qui rendront l'entr√©e en interne: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ state = { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; onChange = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({ <span class="hljs-attr"><span class="hljs-attr">value</span></span>: e.target.value }); }; render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Input</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onChange</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.onChange}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">The value is: {this.state.value} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); } }</span></span></code> </pre> <br><p>  Et le second: </p><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ state = { <span class="hljs-attr"><span class="hljs-attr">value</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span> }; onChange(e) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setState({ <span class="hljs-attr"><span class="hljs-attr">value</span></span>: e.target.value }); } render() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Input</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onChange</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{e</span></span></span></span><span class="xml"><span class="hljs-tag"> =&gt;</span></span></span><span class="xml"> this.onChange(e)} /&gt; </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">The value is: {this.state.value} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); } }</span></span></code> </pre> <br><p>  Vous pouvez essayer l'exemple avec vos mains ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://codesandbox.io/s/2vwz6kjjkr</a> <br>  Cet exemple montre comment vous pouvez perdre tous les avantages de PureComponent si vous passez une nouvelle fonction de rappel au PureComponent √† chaque fois. </p><br><h3 id="chast-2-ispolzovanie-event-handlers-v-komponentah-funkciyah">  Partie 2. Utilisation de gestionnaires d'√©v√©nements dans les composants de fonction </h3><br><p>  Dans la nouvelle version de React (16.8), le m√©canisme des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">crochets React a</a> √©t√© annonc√©, vous permettant d'√©crire des composants fonctionnels √† part enti√®re, avec un cycle de vie clair qui peut couvrir presque tous les cas d'utilisateurs qui jusqu'√† pr√©sent ne couvraient que les classes. </p><br><p>  Nous modifions l'exemple avec le composant Input afin que tous les composants soient repr√©sent√©s par une fonction et travaillons avec React-hooks. </p><br><p>  L'entr√©e doit stocker en elle-m√™me des informations sur le nombre de fois o√π elle a √©t√© modifi√©e.  Si dans le cas des classes, nous avons utilis√© un champ dans notre instance, dont l'acc√®s a √©t√© impl√©ment√© par ce biais, alors dans le cas d'une fonction, nous ne serons pas en mesure de d√©clarer une variable par ce biais. <br>  React fournit un hook useRef qui peut √™tre utilis√© pour enregistrer une r√©f√©rence √† l'√©l√©ment HtmlElement dans l'arborescence DOM, mais il est √©galement int√©ressant car il peut √™tre utilis√© pour les donn√©es r√©guli√®res dont notre composant a besoin: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, { useRef } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Input</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ onChange }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> componentRerenderedTimes = useRef(<span class="hljs-number"><span class="hljs-number">0</span></span>); componentRerenderedTimes.current++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;&gt; &lt;input onChange={onChange} /&gt; &lt;p&gt;Input component was rerendered {componentRerenderedTimes.current} times&lt;/p&gt; &lt;/&gt; ); }</code> </pre> <br><p>  Nous avons √©galement besoin que le composant soit "propre", c'est-√†-dire qu'il n'est mis √† jour que si les accessoires qui ont √©t√© transmis au composant ont chang√©. <br>  Pour cela, il existe diff√©rentes biblioth√®ques qui fournissent HOC, mais il est pr√©f√©rable d'utiliser la fonction m√©mo, qui est d√©j√† int√©gr√©e √† React, car elle fonctionne plus rapidement et plus efficacement: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, { useRef, memo } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> memo(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Input</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ onChange }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> componentRerenderedTimes = useRef(<span class="hljs-number"><span class="hljs-number">0</span></span>); componentRerenderedTimes.current++; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;&gt; &lt;input onChange={onChange} /&gt; &lt;p&gt;Input component was rerendered {componentRerenderedTimes.current} times&lt;/p&gt; &lt;/&gt; ); });</code> </pre> <br><p>  Le composant Input est pr√™t, maintenant nous r√©√©crivons les composants A et B. <br>  Dans le cas du composant B, cela est facile √† faire: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, { useState } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">B</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [value, setValue] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Input</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onChange</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{e</span></span></span></span><span class="xml"><span class="hljs-tag"> =&gt;</span></span></span><span class="xml"> setValue(e.target.value)} /&gt; </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">The value is: {value} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); }</span></span></code> </pre> <br><p>  Ici, nous avons utilis√© le hook <code>useState</code> , qui vous permet d'enregistrer et de travailler avec l'√©tat du composant, au cas o√π le composant est repr√©sent√© par une fonction. </p><br><p>  Comment pouvons-nous mettre en cache la fonction de rappel?  Nous ne pouvons pas le supprimer du composant, car dans ce cas, il sera commun √† diff√©rentes instances du composant. <br>  Pour de telles t√¢ches, React dispose d'un ensemble de crochets de mise en cache et de m√©morisation, dont <code>useCallback</code> est le plus appropri√© pour <code>useCallback</code> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://reactjs.org/docs/hooks-reference.html</a> </p><br><p>  Ajoutez ce crochet au composant <code>A</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, { useState, useCallback } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">A</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [value, setValue] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onChange = useCallback(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> setValue(e.target.value), []); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Input</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onChange</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{onChange}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">The value is: {value} </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">p</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">div</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> ); }</span></span></code> </pre> <br><p>  Nous avons mis en cache la fonction, ce qui signifie que le composant Input ne sera pas mis √† jour √† chaque fois. </p><br><p>  <strong>Comment fonctionne le crochet <code>useCallback</code> ?</strong> </p><br><p>  Ce hook renvoie une fonction mise en cache (c'est-√†-dire que le lien ne change pas de rendu en rendu). <br>  En plus de la fonction √† mettre en cache, un deuxi√®me argument lui est transmis - un tableau vide. <br>  Ce tableau vous permet de transf√©rer une liste de champs, lors du changement dont vous avez besoin pour changer la fonction, c'est-√†-dire  retourner un nouveau lien. </p><br><p>  <code>useCallback</code> pouvez voir la diff√©rence entre la m√©thode habituelle de transfert d'une fonction vers un rappel et <code>useCallback</code> ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://codesandbox.io/s/0y7wm3pp1w</a> </p><br><p>  <strong>Pourquoi avons-nous besoin d'un tableau?</strong> </p><br><p>  Supposons que nous devons mettre en cache une fonction qui d√©pend d'une certaine valeur via une fermeture: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React, { useCallback } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ReactDOM <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-dom'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> <span class="hljs-string"><span class="hljs-string">'./styles.css'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">App</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ a, text }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onClick = useCallback(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function"> =&gt;</span></span> alert(a), [ <span class="hljs-comment"><span class="hljs-comment">/*a*/</span></span> ]); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{onClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">{text}</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> rootElement = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'root'</span></span>); ReactDOM.render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">text</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{</span></span></span></span><span class="xml"><span class="hljs-tag">'</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Click</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">me</span></span></span></span><span class="xml"><span class="hljs-tag">'} </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">a</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{1}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">, rootElement);</span></span></code> </pre> <br><p>  Ici, le composant App d√©pend de prop <code>a</code> .  Si vous ex√©cutez l'exemple, alors tout fonctionnera correctement jusqu'au moment o√π nous ajouterons √† la fin: </p><br><pre> <code class="javascript hljs">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ReactDOM.render(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">App</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">text</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{</span></span></span></span><span class="xml"><span class="hljs-tag">'</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">Next</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">A</span></span></span></span><span class="xml"><span class="hljs-tag">'} </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">a</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{2}</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">, rootElement), 5000);</span></span></code> </pre> <br><p>  Une fois le d√©lai d'attente d√©clench√©, lorsque vous cliquez sur le bouton en alerte, <code>1</code> s'affiche.  Cela se produit car nous avons enregistr√© la fonction pr√©c√©dente, qui a ferm√© <code>a</code> variable.  Et comme <code>a</code> est une variable, qui dans notre cas est un type de valeur, et que le type de valeur est immuable, nous avons eu cette erreur.  Si nous supprimons le commentaire <code>/*a*/</code> , le code fonctionnera correctement.  R√©agir sur le deuxi√®me rendu v√©rifiera que les donn√©es pass√©es dans le tableau sont diff√©rentes et renverra une nouvelle fonction. </p><br><p>  Vous pouvez essayer cet exemple vous-m√™me ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://codesandbox.io/s/6vo8jny1ln</a> </p><br><p>  React fournit de nombreuses fonctions qui vous permettent de m√©moriser des donn√©es, telles que <code>useRef</code> , <code>useCallback</code> et <code>useMemo</code> . <br>  Si ce dernier est n√©cessaire pour m√©moriser la valeur de la fonction, et qu'ils <code>useCallback</code> assez similaires √† <code>useRef</code> , alors <code>useRef</code> vous permet de mettre en cache non seulement les r√©f√©rences aux √©l√©ments DOM, mais aussi d'agir comme un champ d'instance. </p><br><p>  √Ä premi√®re vue, il peut √™tre utilis√© pour mettre en cache des fonctions, car <code>useRef</code> met √©galement en cache des donn√©es entre des mises √† jour de composants distinctes. <br>  Cependant, l'utilisation de <code>useRef</code> pour mettre en cache les fonctions n'est pas souhaitable.  Si notre fonction utilise la fermeture, alors dans n'importe quel rendu, la valeur ferm√©e peut changer et notre fonction mise en cache fonctionnera avec l'ancienne valeur.  Cela signifie que nous devrons √©crire la logique de mise √† jour de la fonction ou simplement utiliser <code>useCallback</code> , dans laquelle elle est impl√©ment√©e en raison du m√©canisme de d√©pendance. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://codesandbox.io/s/p70pprpvvx</a> ici vous pouvez voir la m√©morisation des fonctions avec le bon <code>useCallback</code> , avec le mauvais et avec <code>useRef</code> . </p><br><h3 id="chast-3-syntetic-events">  Partie 3. √âv√©nements synt√©tiques </h3><br><p>  Nous avons d√©j√† compris comment utiliser les gestionnaires d'√©v√©nements et comment fonctionner correctement avec les fermetures dans les rappels, mais dans React, il y a une autre diff√©rence tr√®s importante lorsque vous travaillez avec eux: </p><br><p>  Remarque: maintenant <code>Input</code> , avec lequel nous avons travaill√© ci-dessus, est absolument synchrone, mais dans certains cas, il peut √™tre n√©cessaire que le rappel se produise avec un retard, selon le mod√®le de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rebond</a> ou de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">limitation</a> .  Ainsi, debounce, par exemple, est tr√®s pratique √† utiliser pour la saisie de cha√Æne de recherche - la recherche ne se produit que lorsque l'utilisateur arr√™te de saisir des caract√®res. </p><br><p>  Cr√©ez un composant qui provoque en interne un changement d'√©tat: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SearchInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [value, setValue] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timerHandler = useRef(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;&gt; &lt;input defaultValue={value} onChange={e =&gt; { clearTimeout(timerHandler.current</span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">timerHandler</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">current</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">setTimeout</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) =&gt;</span></span> { setValue(e.target.value); }, <span class="hljs-number"><span class="hljs-number">300</span></span>); <span class="hljs-comment"><span class="hljs-comment">// wait, if user is still writing his query }} /&gt; &lt;p&gt;Search value is {value}&lt;/p&gt; &lt;/&gt; ); }</span></span></code> </pre> <br><p>  Ce code ne fonctionnera pas.  Le fait est que React proxie les √©v√©nements √† l'int√©rieur de lui-m√™me, et le soi-disant √©v√©nement synt√©tique entre dans notre rappel onChange, qui apr√®s notre fonction sera "effac√©" (les champs seront nuls).  Pour des raisons de performances, React fait cela pour utiliser un seul objet, plut√¥t que d'en cr√©er un nouveau √† chaque fois. </p><br><p>  Si nous devons prendre de la valeur, comme dans cet exemple, alors il suffit de mettre en cache les champs n√©cessaires AVANT de quitter la fonction: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SearchInput</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [value, setValue] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> timerHandler = useRef(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;&gt; &lt;input defaultValue={value} onChange={e =&gt; { clearTimeout(timerHandler.current</span></span></span><span class="hljs-function">); </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">const</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">pendingValue</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">target</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">; // </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cached</span></span></span><span class="hljs-function">! </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">timerHandler</span></span></span><span class="hljs-function">.</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">current</span></span></span><span class="hljs-function"> = </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">setTimeout</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) =&gt;</span></span> { setValue(pendingValue); }, <span class="hljs-number"><span class="hljs-number">300</span></span>); <span class="hljs-comment"><span class="hljs-comment">// wait, if user is still writing his query }} /&gt; &lt;p&gt;Search value is {value}&lt;/p&gt; &lt;/&gt; ); }</span></span></code> </pre> <br><p>  Vous pouvez voir un exemple ici: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://codesandbox.io/s/oj6p8opq0z</a> </p><br><p>  Dans de tr√®s rares cas, il devient n√©cessaire de maintenir l'instance enti√®re de l'√©v√©nement.  Pour ce faire, vous pouvez appeler <code>event.persist()</code> , ce qui supprime <br>  cette instance de l'√©v√©nement Syntetic √† partir du pool d'√©v√©nements d'√©v√©nements de r√©action. </p><br><h3 id="zaklyuchenie">  Conclusion: </h3><br><p>  Les gestionnaires d'√©v√©nements React sont tr√®s pratiques car ils: </p><br><ol><li>  Automatisez l'abonnement et le d√©sabonnement (avec le composant de d√©montage); </li><li>  Simplifiez la perception du code, la plupart des abonnements sont faciles √† suivre en code JSX. </li></ol><br><p>  Mais en m√™me temps, lors du d√©veloppement d'applications, vous pouvez rencontrer des difficult√©s: </p><br><ol><li>  Remplacer les rappels dans les accessoires; </li><li>  Ev√©nements syntaxiques effac√©s apr√®s l'ex√©cution de la fonction actuelle. </li></ol><br><p>  Remplacer les rappels n'est g√©n√©ralement pas perceptible, car vDOM ne change pas, mais il convient de se rappeler que si vous introduisez des optimisations, en rempla√ßant les composants par Pure via l'h√©ritage de <code>PureComponent</code> ou en utilisant <code>memo</code> , vous devez prendre soin de les mettre en cache, sinon les avantages de l'introduction de PureComponents ou memo ne seront pas perceptibles.  Pour la mise en cache, vous pouvez utiliser classProperties (lorsque vous travaillez avec une classe) ou <code>useCallback</code> hook <code>useCallback</code> (lorsque vous travaillez avec des fonctions). </p><br><p>  Pour un fonctionnement asynchrone correct, si vous avez besoin de donn√©es d'un √©v√©nement, mettez √©galement en cache les champs dont vous avez besoin. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr439138/">https://habr.com/ru/post/fr439138/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr439126/index.html">Demandes des utilisateurs et exigences des produits</a></li>
<li><a href="../fr439128/index.html">Comment organiser le travail d'AQ. Une fa√ßon pratique</a></li>
<li><a href="../fr439130/index.html">13 Tendances du march√© de la cybers√©curit√© et de la s√©curit√© de l'information 2019-2020</a></li>
<li><a href="../fr439132/index.html">Une vieillesse inoubliable</a></li>
<li><a href="../fr439136/index.html">Quelle est la diff√©rence entre la 4G et la 5G?</a></li>
<li><a href="../fr439140/index.html">Message important sur les invitations de profil</a></li>
<li><a href="../fr439142/index.html">Mod√®les de maturit√© de conception</a></li>
<li><a href="../fr439148/index.html">Travailler avec nRF51822 en utilisant ST-Link et Clion + OpenOCD</a></li>
<li><a href="../fr439150/index.html">Qui devrait payer les frais de transaction</a></li>
<li><a href="../fr439152/index.html">Salaires en informatique au second semestre 2018: selon le calculateur de salaire "My Circle"</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>