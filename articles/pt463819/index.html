<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêì üë©üèΩ‚Äçüè≠ üòÅ Bloqueios do PostgreSQL: 2. Bloqueios de string üëàüèæ ü•§ üë®üèª‚Äçüé§</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Na √∫ltima vez, falamos sobre bloqueios no n√≠vel de objeto , em particular, sobre bloqueios nos relacionamentos. Hoje veremos como os bloqueios de linh...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bloqueios do PostgreSQL: 2. Bloqueios de string</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/463819/">  Na √∫ltima vez, falamos sobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bloqueios</a> no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">n√≠vel de objeto</a> , em particular, sobre bloqueios nos relacionamentos.  Hoje veremos como os bloqueios de linha s√£o organizados no PostgreSQL e como eles s√£o usados ‚Äã‚Äãem conjunto com os bloqueios de objetos. Vamos falar sobre as filas de espera e quem sai fora da curva. <br><br><img src="https://habrastorage.org/webt/6x/u5/jj/6xu5jj3edymfhel21v9obwhsxai.png"><br><br><h1>  Bloqueios de linha </h1><br><h2>  Dispositivo </h2><br>  Deixe-me lembr√°-lo de v√°rias conclus√µes importantes do √∫ltimo artigo. <br><br><ul><li>  Um bloqueio deve existir em algum lugar da mem√≥ria compartilhada do servidor. </li><li>  Quanto maior a granularidade de bloqueios, menor a concorr√™ncia (conten√ß√£o) entre os processos em execu√ß√£o simultaneamente. </li><li>  Por outro lado, quanto maior a granularidade, mais espa√ßo de mem√≥ria √© ocupado por bloqueios. </li></ul><br>  Certamente, queremos que a altera√ß√£o de uma linha n√£o bloqueie outras linhas da mesma tabela.  Mas n√£o podemos dar ao luxo de iniciar cada linha com nosso pr√≥prio bloqueio. <br><br>  Existem diferentes maneiras de resolver esse problema.  Em alguns DBMSs, h√° um aumento no n√≠vel de bloqueio: se houver muitos bloqueios no n√≠vel da linha, eles ser√£o substitu√≠dos por mais um bloqueio geral (por exemplo, no n√≠vel da p√°gina ou na tabela inteira). <br><br>  Como veremos mais adiante, o PostgreSQL tamb√©m usa esse mecanismo, mas apenas para bloqueios de predicado.  Bloqueios de linha s√£o diferentes. <br><a name="habracut"></a><br>  No PostgreSQL, as informa√ß√µes de que uma linha est√° bloqueada s√£o armazenadas √∫nica e exclusivamente na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">vers√£o da linha</a> dentro da p√°gina de dados (e n√£o na RAM).  Ou seja, este n√£o √© um bloco no sentido usual, mas apenas um sinal.  Este sinal √© realmente o n√∫mero da transa√ß√£o xmax em combina√ß√£o com bits de informa√ß√µes adicionais;  um pouco mais tarde, veremos em detalhes como isso funciona. <br><br>  <strong>A vantagem</strong> √© que podemos bloquear quantas linhas quisermos sem consumir nenhum recurso. <br><br>  Mas h√° um <strong>sinal de menos</strong> : como as informa√ß√µes sobre o bloqueio n√£o s√£o apresentadas na RAM, outros processos n√£o podem ficar na fila.  E n√£o h√° possibilidade de monitoramento (para calcular os bloqueios, √© necess√°rio ler a tabela inteira). <br><br>  Bem, o monitoramento √© bom, mas algo precisa ser feito com a fila.  Para fazer isso, voc√™ ainda precisa usar bloqueios "regulares".  Se precisarmos esperar at√© que a linha seja liberada, de fato, devemos esperar at√© o final da transa√ß√£o de bloqueio - todos os bloqueios ser√£o liberados ao confirmar ou retroceder.  E para isso, voc√™ pode solicitar um n√∫mero de bloqueio de uma transa√ß√£o de bloqueio (que, lembro-me, √© mantida pela pr√≥pria transa√ß√£o em modo excepcional).  Portanto, o n√∫mero de bloqueios usados ‚Äã‚Äã√© proporcional ao n√∫mero de processos em execu√ß√£o simultaneamente e n√£o ao n√∫mero de linhas que est√£o sendo alteradas. <br><br><h2>  Modos Excepcionais </h2><br>  No total, existem 4 modos em que voc√™ pode bloquear a linha.  Desses, dois modos representam bloqueios <em>exclusivos</em> que apenas uma transa√ß√£o pode reter por vez. <br><br><ul><li>  O modo FOR UPDATE implica uma altera√ß√£o completa (ou exclus√£o) de uma linha. </li><li>  Modo PARA N√ÉO ATUALIZAR CHAVE - alterando apenas os campos que n√£o est√£o inclu√≠dos em √≠ndices exclusivos (em outras palavras, com essa altera√ß√£o, todas as chaves estrangeiras permanecem inalteradas). </li></ul><br>  O pr√≥prio comando UPDATE seleciona o modo de bloqueio m√≠nimo apropriado;  geralmente as linhas s√£o bloqueadas no modo FOR NO KEY UPDATE. <br><br>  Como voc√™ se <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">lembra</a> , ao excluir ou alterar uma linha, o n√∫mero da vers√£o da transa√ß√£o atual √© gravado no campo xmax da vers√£o atual atual.  Isso mostra que a vers√£o da linha foi exclu√≠da por esta transa√ß√£o.  Portanto, o mesmo n√∫mero xmax √© usado como sinal de bloqueio.  De fato, se xmax na vers√£o da linha corresponde a uma transa√ß√£o ativa (ainda n√£o conclu√≠da) e queremos atualizar essa linha espec√≠fica, precisamos aguardar a conclus√£o da transa√ß√£o, para que n√£o seja necess√°rio um sinal adicional. <br><br>  Vamos ver  Crie um quadro de contas, o mesmo que no artigo anterior. <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts( acc_no <span class="hljs-type"><span class="hljs-type">integer</span></span> <span class="hljs-keyword"><span class="hljs-keyword">PRIMARY KEY</span></span>, amount <span class="hljs-type"><span class="hljs-type">numeric</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">100.00</span></span>), (<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">200.00</span></span>), (<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">300.00</span></span>);</code> </pre> <br>  Para ver as p√°ginas, √© claro, precisamos da j√° familiar extens√£o pageinspect. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pageinspect;</code> </pre><br>  Por conveni√™ncia, crie uma exibi√ß√£o mostrando apenas as informa√ß√µes em que estamos interessados: xmax e alguns bits de informa√ß√µes. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> accounts_v <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'(0,'</span></span>||lp||<span class="hljs-string"><span class="hljs-string">')'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ctid, t_xmax <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> xmax, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">128</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'t'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> lock_only, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">4096</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'t'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> is_multi, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> (t_infomask2 &amp; <span class="hljs-number"><span class="hljs-number">8192</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'t'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> keys_upd, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">16</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'t'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> keyshr_lock, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">16</span></span>+<span class="hljs-number"><span class="hljs-number">64</span></span>) = <span class="hljs-number"><span class="hljs-number">16</span></span>+<span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'t'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> shr_lock <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> lp;</code> </pre><br>  Portanto, iniciamos a transa√ß√£o e atualizamos o valor da primeira conta (a chave n√£o muda) e o n√∫mero da segunda conta (a chave muda): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">20</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><br>  Analisamos a vis√£o: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts_v <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs"> ctid | xmax | lock_only | is_multi | keys_upd | keyshr_lock | shr_lock -------+--------+-----------+----------+----------+-------------+---------- (0,1) | 530492 | | | | | (0,2) | 530492 | | | t | | (2 rows)</code> </pre><br>  O modo de bloqueio √© determinado pelo bit de informa√ß√£o keys_updated. <br><br>  O mesmo campo xmax tamb√©m √© usado ao bloquear uma linha com o comando SELECT FOR UPDATE, mas nesse caso um bit de informa√ß√µes adicionais (xmax_lock_only) √© colocado, o que indica que a vers√£o da linha est√° bloqueada apenas, mas n√£o exclu√≠da, e ainda √© relevante. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR NO KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts_v <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs"> ctid | xmax | lock_only | is_multi | keys_upd | keyshr_lock | shr_lock -------+--------+-----------+----------+----------+-------------+---------- (0,1) | 530493 | t | | | | (0,2) | 530493 | t | | t | | (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br><br><h2>  Modos compartilhados </h2><br>  Mais dois modos representam bloqueios compartilhados que podem ser mantidos por v√°rias transa√ß√µes. <br><br><ul><li>  O modo FOR SHARE √© usado quando voc√™ precisa ler uma sequ√™ncia, mas n√£o deve permitir que ela seja alterada por qualquer outra transa√ß√£o. </li><li>  O modo FOR KEY SHARE permite alterar a string, mas apenas campos que n√£o s√£o da chave.  Este modo, em particular, √© usado automaticamente pelo PostgreSQL ao verificar chaves estrangeiras. </li></ul><br>  Vamos ver <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR KEY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SHARE</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SHARE</span></span>;</code> </pre><br>  Nas vers√µes de linha, vemos: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts_v <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs"> ctid | xmax | lock_only | is_multi | keys_upd | keyshr_lock | shr_lock -------+--------+-----------+----------+----------+-------------+---------- (0,1) | 530494 | t | | | t | (0,2) | 530494 | t | | | t | t (2 rows)</code> </pre><br>  Em ambos os casos, o bit keyshr_lock est√° definido e o modo SHARE pode ser reconhecido observando mais um bit de informa√ß√£o. <br><br>  Veja como √© a matriz de compatibilidade do modo geral. <br><br><div class="scrollable-table"><table><tbody><tr><th>  modo </th><th>  PARA COMPARTILHAR CHAVE </th><th>  PARA COMPARTILHAR </th><th>  PARA ATUALIZA√á√ÉO CHAVE </th><th>  PARA ATUALIZA√á√ÉO </th></tr><tr><td>  PARA COMPARTILHAR CHAVE </td><td></td><td></td><td></td><td>  X </td></tr><tr><td>  PARA COMPARTILHAR </td><td></td><td></td><td>  X </td><td>  X </td></tr><tr><td>  PARA ATUALIZA√á√ÉO CHAVE </td><td></td><td>  X </td><td>  X </td><td>  X </td></tr><tr><td>  PARA ATUALIZA√á√ÉO </td><td>  X </td><td>  X </td><td>  X </td><td>  X </td></tr></tbody></table></div><br>  Isso mostra que: <br><br><ul><li>  modos excepcionais entram em conflito entre si; </li><li>  modos compartilhados s√£o compat√≠veis entre si; </li><li>  o modo compartilhado FOR KEY SHARE √© compat√≠vel com o modo exclusivo FOR NO KEY UPDATE (ou seja, voc√™ pode atualizar os campos sem chave ao mesmo tempo e garantir que a chave n√£o seja alterada). </li></ul><br><h2>  Multi-transa√ß√£o </h2><br>  At√© agora, pens√°vamos que o bloqueio fosse representado pelo n√∫mero da transa√ß√£o de bloqueio no campo xmax.  Mas os bloqueios compartilhados podem ser mantidos por v√°rias transa√ß√µes e v√°rios n√∫meros n√£o podem ser gravados no mesmo campo xmax.  Como ser <br><br>  Para bloqueios compartilhados, s√£o utilizadas as chamadas <em>multi-</em> transa√ß√µes (MultiXact).  Este √© um grupo de transa√ß√µes que recebe um n√∫mero separado.  Esse n√∫mero tem a mesma dimens√£o que um n√∫mero de transa√ß√£o normal, mas os n√∫meros s√£o alocados de forma independente (ou seja, o sistema pode ter os mesmos n√∫meros de transa√ß√£o e de v√°rias transa√ß√µes).  Para distinguir um do outro, outro bit de informa√ß√£o (xmax_is_multi) √© usado e informa√ß√µes detalhadas sobre os membros desse grupo e os modos de bloqueio est√£o localizadas nos arquivos no diret√≥rio $ PGDATA / pg_multixact /.  Naturalmente, os √∫ltimos dados usados ‚Äã‚Äãs√£o armazenados em buffers na mem√≥ria compartilhada do servidor para um acesso mais r√°pido. <br><br>  Adicione aos bloqueios existentes outro excepcional executado por outra transa√ß√£o (podemos fazer isso, porque os modos FOR KEY SHARE e FOR NO KEY UPDATE s√£o compat√≠veis entre si): <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts_v <span class="hljs-keyword"><span class="hljs-keyword">LIMIT</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>;</code> </pre><pre> <code class="plaintext hljs"> ctid | xmax | lock_only | is_multi | keys_upd | keyshr_lock | shr_lock -------+--------+-----------+----------+----------+-------------+---------- (0,1) | 61 | | t | | | (0,2) | 530494 | t | | | t | t (2 rows)</code> </pre><br>  Na primeira linha, vemos que o n√∫mero usual foi substitu√≠do por um n√∫mero de multitransa√ß√£o - isso √© evidenciado pelo bit xmax_is_multi. <br><br>  Para n√£o se aprofundar nos aspectos internos da implementa√ß√£o de multitransa√ß√µes, voc√™ pode usar outra extens√£o que permita ver todas as informa√ß√µes sobre todos os tipos de bloqueios de linhas de maneira conveniente. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pgrowlocks; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgrowlocks(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]----------------------------- locked_row | (0,1) locker | 61 multi | t xids | {530494,530495} modes | {"Key Share","No Key Update"} pids | {5892,5928} -[ RECORD 2 ]----------------------------- locked_row | (0,2) locker | 530494 multi | f xids | {530494} modes | {"For Share"} pids | {5892}</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br><h2>  Configura√ß√£o de congelamento </h2><br>  Como n√∫meros separados s√£o alocados para multitransa√ß√µes, escritas no campo xmax das vers√µes de linha, devido ao limite da capacidade de bits do contador, eles enfrentam o mesmo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">problema de</a> abrang√™ncia xid que um n√∫mero regular. <br><br>  Portanto, para n√∫meros de transa√ß√µes m√∫ltiplas, tamb√©m √© necess√°rio executar um an√°logo de congelamento - substituir os n√∫meros antigos por novos (ou por um n√∫mero de transa√ß√£o regular, se no momento do congelamento o bloqueio for mantido por apenas uma transa√ß√£o). <br><br>  Observe que o congelamento de n√∫meros de transa√ß√£o comuns √© realizado apenas para o campo xmin (pois se a vers√£o da linha tiver um campo xmax n√£o vazio, ser√° uma vers√£o irrelevante e ser√° limpa ou a transa√ß√£o xmax ser√° cancelada e seu n√∫mero n√£o nos interessa).  Mas para transa√ß√µes m√∫ltiplas, estamos falando do campo xmax da vers√£o atual da linha, que pode permanecer relevante, mas √© constantemente bloqueado por transa√ß√µes diferentes em um modo compartilhado. <br><br>  Para o congelamento de <em>transa√ß√µes</em> m√∫ltiplas, s√£o <em>respons√°veis</em> par√¢metros semelhantes aos par√¢metros do congelamento usual: <em>vacuum_multixact_freeze_min_age</em> , <em>vacuum_multixact_freeze_table_age</em> , <em>autovacuum_multixact_freeze_max_age</em> . <br><br><h1>  Quem √© o extremo? </h1><br>  Gradualmente, aproxime-se do doce.  Vamos ver qual √© a imagem dos bloqueios quando v√°rias transa√ß√µes atualizar√£o a mesma linha. <br><br>  Vamos come√ßar criando uma vis√£o sobre pg_locks.  Primeiro, tornaremos a conclus√£o um pouco mais compacta e, em segundo lugar, nos restringiremos a bloqueios interessantes (na verdade, descartamos os bloqueios dos n√∫meros de transa√ß√µes virtuais, o √≠ndice na tabela de contas, pg_locks e a pr√≥pria visualiza√ß√£o - em geral, tudo o que √© irrelevante e apenas distrair). <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">VIEW</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pid, locktype, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> locktype <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'relation'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'transactionid'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> transactionid::<span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'tuple'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> relation::<span class="hljs-type"><span class="hljs-type">regclass</span></span>::<span class="hljs-type"><span class="hljs-type">text</span></span>||<span class="hljs-string"><span class="hljs-string">':'</span></span>||tuple::<span class="hljs-type"><span class="hljs-type">text</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> lockid, mode, granted <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_locks <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> locktype <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (<span class="hljs-string"><span class="hljs-string">'relation'</span></span>,<span class="hljs-string"><span class="hljs-string">'transactionid'</span></span>,<span class="hljs-string"><span class="hljs-string">'tuple'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> (locktype != <span class="hljs-string"><span class="hljs-string">'relation'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> relation = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span>);</code> </pre><br>  Agora inicie a primeira transa√ß√£o e atualize a linha. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> txid_current | pg_backend_pid --------------+---------------- 530497 | 5892 (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><pre> <code class="plaintext hljs">UPDATE 1</code> </pre><br>  E as fechaduras? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5892</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+----------+------------------+--------- 5892 | relation | accounts | RowExclusiveLock | t 5892 | transactionid | 530497 | ExclusiveLock | t (2 rows)</code> </pre><br>  A transa√ß√£o mant√©m a tabela e bloqueios de n√∫mero pr√≥prios.  At√© agora, tudo √© esperado. <br><br>  Iniciamos a segunda transa√ß√£o e tentamos atualizar a mesma linha. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| txid_current | pg_backend_pid | --------------+---------------- | 530498 | 5928 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  E quanto aos bloqueios de segunda transa√ß√£o? <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5928</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+------------+------------------+--------- 5928 | relation | accounts | RowExclusiveLock | t 5928 | transactionid | 530498 | ExclusiveLock | t 5928 | transactionid | 530497 | ShareLock | f 5928 | tuple | accounts:1 | ExclusiveLock | t (4 rows)</code> </pre><br>  E aqui √© mais interessante.  Al√©m de bloquear a tabela e o n√∫mero pr√≥prio, vemos mais dois bloqueios.  A segunda transa√ß√£o constatou que a linha estava bloqueada primeiro e "travou" aguardando seu n√∫mero (concedido = f).  Mas de onde e por que o bloqueio de vers√£o de linha (locktype = tuple) veio? <br><br><blockquote>  N√£o confunda bloqueio de vers√£o de linha (bloqueio de tupla) e bloqueio de linha (bloqueio de linha).  O primeiro √© um bloqueio comum do tipo tupla, vis√≠vel em pg_locks.  A segunda √© uma marca na p√°gina de dados: xmax e bits de informa√ß√£o. <br></blockquote><br>  Quando uma transa√ß√£o est√° prestes a alterar uma linha, ela executa a seguinte sequ√™ncia de a√ß√µes: <br><br><ol><li>  Captura um bloqueio exclusivo em uma vers√£o mut√°vel de uma string (tupla). </li><li>  Se xmax e bits de informa√ß√£o indicarem que a linha est√° bloqueada, ele solicitar√° o bloqueio do n√∫mero da transa√ß√£o xmax. </li><li>  Prescreve seu xmax e os bits de informa√ß√£o necess√°rios. </li><li>  Libera o bloqueio da vers√£o da linha. </li></ol><br>  Quando a linha foi atualizada pela primeira transa√ß√£o, ela tamb√©m pegou o bloqueio da vers√£o da linha (etapa 1), mas a liberou imediatamente (etapa 4). <br><br>  Quando a segunda transa√ß√£o chegou, ela capturou o bloqueio da vers√£o da linha (item 1), mas foi for√ßada a solicitar o bloqueio do primeiro n√∫mero da transa√ß√£o (item 2) e ficou presa nele. <br><br>  O que acontece se uma terceira transa√ß√£o semelhante aparecer?  Ela tentar√° capturar o bloqueio da vers√£o da linha (item 1) e travar√° j√° nesta etapa.  Confira. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; || =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">|| txid_current | pg_backend_pid || --------------+---------------- || 530499 | 5964 || (1 row)</code> </pre><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5964</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+------------+------------------+--------- 5964 | relation | accounts | RowExclusiveLock | t 5964 | tuple | accounts:1 | ExclusiveLock | f 5964 | transactionid | 530499 | ExclusiveLock | t (3 rows)</code> </pre><br>  As quarta, quinta, etc. transa√ß√µes que desejam atualizar a mesma linha n√£o ser√£o diferentes da transa√ß√£o 3 - todas elas ser√£o "travadas" no mesmo bloqueio de vers√£o de linha. <br><br>  Adicione outra transa√ß√£o ao heap. <br><br><pre> <code class="pgsql hljs">||| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; ||| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">||| txid_current | pg_backend_pid ||| --------------+---------------- ||| 530500 | 6000 ||| (1 row)</code> </pre><pre> <code class="pgsql hljs">||| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">6000</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+------------+------------------+--------- 6000 | relation | accounts | RowExclusiveLock | t 6000 | transactionid | 530500 | ExclusiveLock | t 6000 | tuple | accounts:1 | ExclusiveLock | f (3 rows)</code> </pre><br>  Uma vis√£o geral das expectativas atuais pode ser vista na visualiza√ß√£o pg_stat_activity, adicionando informa√ß√µes sobre os processos de bloqueio: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pid, wait_event_type, wait_event, pg_blocking_pids(pid) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> backend_type = <span class="hljs-string"><span class="hljs-string">'client backend'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | wait_event_type | wait_event | pg_blocking_pids ------+-----------------+---------------+------------------ 5892 | | | {} 5928 | Lock | transactionid | {5892} 5964 | Lock | tuple | {5928} 6000 | Lock | tuple | {5928,5964} (4 rows)</code> </pre><br>  Acontece uma esp√©cie de ‚Äúfila‚Äù, na qual existe a primeira (aquela que mant√©m a vers√£o de bloqueio da corda) e todas as outras que se alinham atr√°s da primeira. <br><br>  Por que precisamos de um design t√£o sofisticado?  Suponha que n√£o ter√≠amos um bloqueio de vers√£o para a string.  Em seguida, a segunda e a terceira (e assim por diante) transa√ß√µes aguardariam o bloqueio do n√∫mero da primeira transa√ß√£o.  No momento da conclus√£o da primeira transa√ß√£o, o recurso bloqueado desaparece ( <em>e o que voc√™ est√° fazendo aqui, eh? A transa√ß√£o foi encerrada</em> ) e agora tudo depende de qual dos processos em espera ser√° ativado pela primeira vez pelo sistema operacional e, portanto, ter√° tempo para bloquear a linha.  Todos os outros processos tamb√©m ser√£o despertados, mas eles ter√£o que fazer fila novamente - agora ap√≥s outro processo. <br><br>  Isso √© preocupante com o fato de que algumas das transa√ß√µes podem esperar indefinidamente por sua vez, se, devido a uma infeliz coincid√™ncia de circunst√¢ncias, ela sempre "repassar√°" outras transa√ß√µes.  Em ingl√™s, essa situa√ß√£o √© chamada de priva√ß√£o de bloqueio. <br><br>  No nosso caso, acontece o mesmo, mas ainda um pouco melhor: a transa√ß√£o que veio no segundo √© garantida que ter√° acesso ao pr√≥ximo recurso.  Mas o que acontece com o seguinte (terceiro e quarto)? <br><br>  Se a primeira transa√ß√£o for conclu√≠da com uma revers√£o, tudo ficar√° bem: as transa√ß√µes recebidas ser√£o executadas na ordem em que foram alinhadas. <br><br>  Mas - isso √© azar - se a primeira transa√ß√£o for conclu√≠da com uma confirma√ß√£o, n√£o apenas o n√∫mero da transa√ß√£o desaparecer√°, mas tamb√©m a vers√£o da linha!  Ou seja, a vers√£o, √© claro, permanece, mas deixa de ser relevante, e ser√° necess√°rio atualizar uma vers√£o mais recente e completamente diferente (da mesma linha).  O recurso, que foi a vez, desaparece e todos organizam uma corrida pela posse de um novo recurso. <br><br>  Deixe a primeira transa√ß√£o ser conclu√≠da com confirma√ß√£o. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  A segunda transa√ß√£o ser√° acordada e executar√° par√°grafos.  3 e 4. <br><br><pre> <code class="plaintext hljs">| UPDATE 1</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5928</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+----------+------------------+--------- 5928 | relation | accounts | RowExclusiveLock | t 5928 | transactionid | 530498 | ExclusiveLock | t (2 rows)</code> </pre><br>  E a terceira transa√ß√£o?  Ela pula a etapa 1 (porque o recurso desapareceu) e fica presa na etapa 2: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5964</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+----------+------------------+--------- 5964 | relation | accounts | RowExclusiveLock | t 5964 | transactionid | 530498 | ShareLock | f 5964 | transactionid | 530499 | ExclusiveLock | t (3 rows)</code> </pre><br>  E o mesmo acontece com a quarta transa√ß√£o: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">6000</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+----------+------------------+--------- 6000 | relation | accounts | RowExclusiveLock | t 6000 | transactionid | 530498 | ShareLock | f 6000 | transactionid | 530500 | ExclusiveLock | t (3 rows)</code> </pre><br>  Ou seja, a terceira e a quarta transa√ß√µes aguardam a conclus√£o da segunda.  A fila se transformou em uma multid√£o de <strike>ab√≥boras</strike> . <br><br>  Conclu√≠mos todas as transa√ß√µes iniciadas. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">|| UPDATE 1</code> </pre><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">||| UPDATE 1</code> </pre><pre> <code class="pgsql hljs">||| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><blockquote>  Mais detalhes sobre o bloqueio de strings podem ser encontrados em <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">README.tuplock</a> . <br></blockquote><br><h1>  Voc√™ n√£o estava parado aqui </h1><br>  Portanto, a id√©ia de um esquema de bloqueio em dois n√≠veis √© reduzir a probabilidade de uma espera eterna por uma transa√ß√£o de "m√° sorte".  No entanto, como j√° vimos, tal situa√ß√£o √© bem poss√≠vel.  E se o aplicativo usar bloqueios compartilhados, tudo poder√° ficar ainda mais triste. <br><br>  Deixe a primeira transa√ß√£o bloquear a linha no modo compartilhado. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs"> txid_current | pg_backend_pid --------------+---------------- 530501 | 5892 (1 row)</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SHARE</span></span>;</code> </pre><pre> <code class="plaintext hljs"> acc_no | amount --------+-------- 1 | 100.00 (1 row)</code> </pre><br>  A segunda transa√ß√£o tenta atualizar a mesma linha, mas n√£o pode - os modos SHARE e NO KEY UPDATE s√£o incompat√≠veis. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">| txid_current | pg_backend_pid | --------------+---------------- | 530502 | 5928 | (1 row)</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br>  A segunda transa√ß√£o aguarda a conclus√£o da primeira e ret√©m o bloqueio da vers√£o da linha - por enquanto, tudo √© como da √∫ltima vez. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5928</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+-------------+------------------+--------- 5928 | relation | accounts | RowExclusiveLock | t 5928 | tuple | accounts:10 | ExclusiveLock | t 5928 | transactionid | 530501 | ShareLock | f 5928 | transactionid | 530502 | ExclusiveLock | t (4 rows)</code> </pre><br>  E ent√£o aparece uma terceira transa√ß√£o que deseja um bloqueio compartilhado.  O problema √© que ele n√£o tenta capturar o bloqueio na vers√£o da linha (uma vez que n√£o vai mudar a linha), mas simplesmente rasteja fora da vez - √© compat√≠vel com a primeira transa√ß√£o. <br><br><pre> <code class="pgsql hljs">|| <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> || =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current(), pg_backend_pid();</code> </pre><pre> <code class="plaintext hljs">|| txid_current | pg_backend_pid || --------------+---------------- || 530503 | 5964 || (1 row)</code> </pre><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SHARE</span></span>;</code> </pre><pre> <code class="plaintext hljs">|| acc_no | amount || --------+-------- || 1 | 100.00 || (1 row)</code> </pre><br>  E agora duas transa√ß√µes est√£o bloqueando a linha: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pgrowlocks(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]--------------- locked_row | (0,10) locker | 62 multi | t xids | {530501,530503} modes | {Share,Share} pids | {5892,5964}</code> </pre><br>  O que acontece agora quando a primeira transa√ß√£o √© conclu√≠da?  A segunda transa√ß√£o ser√° acordada, mas ver√° que o bloqueio da linha n√£o desapareceu em nenhum lugar e permanecer√° novamente na ‚Äúfila‚Äù - desta vez para a terceira transa√ß√£o: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> locks_v <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> pid = <span class="hljs-number"><span class="hljs-number">5928</span></span>;</code> </pre><pre> <code class="plaintext hljs"> pid | locktype | lockid | mode | granted ------+---------------+-------------+------------------+--------- 5928 | relation | accounts | RowExclusiveLock | t 5928 | tuple | accounts:10 | ExclusiveLock | t 5928 | transactionid | 530503 | ShareLock | f 5928 | transactionid | 530502 | ExclusiveLock | t (4 rows)</code> </pre><br>  E somente quando a terceira transa√ß√£o for conclu√≠da (e se nenhum outro bloqueio compartilhado aparecer durante esse per√≠odo), o segundo poder√° executar a atualiza√ß√£o. <br><br><pre> <code class="pgsql hljs">|| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><pre> <code class="plaintext hljs">| UPDATE 1</code> </pre><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><br>  Talvez seja hora de tirar algumas conclus√µes pr√°ticas. <br><br><ul><li>  Atualizar a mesma linha em uma tabela ao mesmo tempo em muitos processos paralelos n√£o √© uma boa ideia. </li><li>  Se voc√™ usar bloqueios compartilhados do tipo SHARE no aplicativo, discretamente. </li><li>  A verifica√ß√£o de chaves estrangeiras n√£o deve interferir, pois os campos das chaves geralmente n√£o s√£o alterados e os modos KEY SHARE e NO KEY UPDATE s√£o compat√≠veis. </li></ul><br><br><h1>  Pediu para n√£o pedir emprestado </h1><br>  Normalmente, os comandos SQL esperam liberar os recursos necess√°rios.  Mas, √†s vezes, voc√™ deseja se recusar a executar o comando se o bloqueio n√£o puder ser obtido imediatamente.  Para fazer isso, comandos como SELECT, LOCK, ALTER permitem que voc√™ use a frase NOWAIT. <br><br>  Por exemplo: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount + <span class="hljs-number"><span class="hljs-number">100.00</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> acc_no = <span class="hljs-number"><span class="hljs-number">1</span></span>;</code> </pre><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOWAIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">| ERROR: could not obtain lock on row in relation "accounts"</code> </pre><br>  O comando falha imediatamente se o recurso estiver ocupado.  No c√≥digo do aplicativo, esse erro pode ser interceptado e processado. <br><br>  Voc√™ n√£o pode especificar a frase NOWAIT para os comandos UPDATE e DELETE, mas pode primeiro executar SELECT FOR UPDATE NOWAIT e, se poss√≠vel, atualizar ou excluir a linha. <br><br>  H√° outra op√ß√£o para n√£o esperar - use o comando SELECT FOR com a frase SKIP LOCKED.  Esse comando pular√° as linhas bloqueadas, mas processar√° as livres. <br><br><pre> <code class="pgsql hljs">| =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c <span class="hljs-keyword"><span class="hljs-keyword">CURSOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> | <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> acc_no <span class="hljs-keyword"><span class="hljs-keyword">FOR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SKIP LOCKED</span></span>; | =&gt; <span class="hljs-keyword"><span class="hljs-keyword">FETCH</span></span> c;</code> </pre><pre> <code class="plaintext hljs">| acc_no | amount | --------+-------- | 2 | 200.00 | (1 row)</code> </pre><br>  Neste exemplo, a primeira linha bloqueada foi pulada e imediatamente recebemos (e bloqueamos) a segunda. <br><br>  Na pr√°tica, isso permite organizar o processamento de filas multithread.  Voc√™ n√£o deve criar outro aplicativo para esse comando - se voc√™ quiser us√°-lo, provavelmente perder√° de vista uma solu√ß√£o mais simples. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>;</code> </pre><pre> <code class="plaintext hljs">| =&gt; ROLLBACK;</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Para ser continuado</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt463819/">https://habr.com/ru/post/pt463819/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt463805/index.html">Sete livros para quem quer se tornar um designer de jogos</a></li>
<li><a href="../pt463811/index.html">Preparando o aplicativo para Android Q. Parte 1</a></li>
<li><a href="../pt463813/index.html">Multivan e roteamento no Mikrotik RouterOS</a></li>
<li><a href="../pt463815/index.html">Por que um banco estrangeiro est√° interessado na fonte de seus fundos?</a></li>
<li><a href="../pt463817/index.html">20 gerentes de produto e a estrutura matricial mais multidimensional de todos. Conversa com Skyeng</a></li>
<li><a href="../pt463821/index.html">AMO, Bitrix, 1C e outros: como escolher por onde come√ßar?</a></li>
<li><a href="../pt463823/index.html">Vers√£o Rust 1.37.0: Otimiza√ß√£o guiada por perfil, constantes sem nome e fornecedor de carga</a></li>
<li><a href="../pt463825/index.html">Ferramenta de gerenciamento de projetos do Planilhas Google</a></li>
<li><a href="../pt463829/index.html">FreePBX Configurando o Asterisk para notifica√ß√µes por email de chamadas perdidas na fila</a></li>
<li><a href="../pt463831/index.html">O que h√° de errado com a educa√ß√£o em TI na R√∫ssia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>