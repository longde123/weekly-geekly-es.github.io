<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔛 🛌🏾 👩‍💻 Wir besiegen das GPRS-Modul von Amperka ✌🏿 🧘🏾 🎌</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bevor wir den CAN-Bus besiegen konnten, mussten wir die nächste Hardware, nämlich das GPRS-Modul, besiegen. Dies ist ihr Leben als Entwicklerin - die ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir besiegen das GPRS-Modul von Amperka</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/401721/"><img src="https://habrastorage.org/files/f8d/d05/ce9/f8dd05ce94d24dc283d1abcbffdb5906.jpg" alt="Bild"><br>  Bevor wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den CAN-Bus</a> besiegen konnten, mussten wir die nächste Hardware, nämlich das GPRS-Modul, besiegen.  Dies ist ihr Leben als Entwicklerin - die ganze Zeit muss sie jemanden gewinnen (es sollte ein verbotenes Lächeln geben). <br><br>  Für eines der benutzerdefinierten Projekte musste ich die Möglichkeit hinzufügen, Telemetrie über GSM per SMS zu steuern und zu empfangen.  Ich habe mir die Liste der verfügbaren Optionen angesehen und mich für das GPRS Shield von Amperka entschieden.  Warum nicht?  Es sieht anständig aus, wird von einem bekannten Unternehmen hergestellt, hat technischen Support, der Preis unterscheidet sich nicht sehr von den Mitbewerbern und macht im Allgemeinen einen sehr guten Eindruck. <br><br>  Aber da war es.  Sie können mehr über diese Suche und die unglaublichen Weiterbildungskurse erfahren, die ich durchlaufen musste, indem Sie dieses GPRS-Modul in den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arduino Mega Server integrieren,</a> indem Sie auf die Schaltfläche unten klicken. <br><a name="habracut"></a><br><h2>  Modul selbst </h2><br>  Wie gesagt, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">das Modul selbst</a> macht mit seiner Genauigkeit der Ausführung und der Beziehung zu einem bekannten Unternehmen einen sehr guten Eindruck.  Auch hier enthält die Website des Herstellers Verwendungsbeispiele und eine native Bibliothek.  Da das Modul mit einem Branding versehen ist, besteht die Hoffnung auf eine angemessene Unterstützung bei Problemen damit. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/332/bf2/2b2/332bf22b21a64277b46f78d65e580b13.jpg" alt="Bild"></div><br>  Mit Blick auf die Zukunft werde ich sagen, dass der technische Support meine Fragen zwei Wochen lang richtig beantwortet, nach Fehlern in meiner Bibliothek gesucht und sogar eine neue Version veröffentlicht hat, die auf dem Grund für die Kommunikation mit mir basiert.  Aber ... ich musste das Modul immer noch alleine arbeiten lassen. <br><br><h2>  Projekt </h2><br>  Ein paar Worte zum <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GSM Coop-Projekt, für</a> das ein GPRS-Modul erforderlich war.  Es war notwendig, eine Automatisierung für die Verwaltung des Hühnerstalles zu entwickeln.  In einer erstaunlichen Zeit, in der wir leben, muss der Hühnerstall jetzt über einen Webbrowser, drahtlose Smart-Sensoren und GSM-Telemetrie gesteuert werden.  Es ist ein strategisches Objekt, kein Hühnerstall. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/a91/e3a/6a4/a91e3a6a4cd94a2cabc35ca7ebb381b1.png" alt="Bild"></div><br>  Aber wenn es notwendig ist, dann ist es notwendig.  Wir kaufen Komponenten, darunter das GPRS-Modul, und fahren fort. <br><br><h2>  Achillesferse </h2><br>  Nun zu den Funktionen des Moduls.  Grundsätzlich funktioniert es.  Er arbeitet mit Beispielen, die auf der Website des Herstellers vorgestellt werden, und auf deren Grundlage Sie sogar eine einfache Skizze erstellen können.  Aber es gibt drei "Aber". <br><br>  <i><strong>Hinweis</strong></i>  <i>In dem Projekt wurden zwei Motherboards verwendet: <strong>Arduino Mega 2560</strong> und <strong>Arduino Due,</strong> und alle folgenden Punkte gelten speziell für sie und nur für sie.</i> <br><br>  <strong>Das erste "aber", Hardware.</strong>  Das Modul funktioniert nicht mit Arduino Due.  Auf keinen Fall.  Selbst mehrtägige Korrespondenz mit dem technischen Support von Amperka half nichts.  Weder ich noch die Spezialisten des Unternehmens haben es geschafft, GPRS Shield dazu zu bringen, mit Arduino Due zusammenzuarbeiten.  Und das ist sehr enttäuschend, da Due ein ausgezeichneter Controller mit großartigen Funktionen ist und ihn gerne mit GPRS Shield verwenden würde. <br><br>  <strong>Das zweite "aber" ist systemisch.</strong>  Für das Modul muss die SoftwareSerial-Bibliothek funktionieren.  Als ich mein Gespräch mit GPRS Shield und dem technischen Support von Amperka begann, war dies keine alternative Lösung.  Nach unserem Verfahren wurde eine überarbeitete Version der Bibliothek mit Unterstützung für die Arbeit an der Eisen-Serie veröffentlicht, aber ... sie hat weder Due noch Mega verdient.  Was ist im Allgemeinen schwer zu erklären - wenn ein Modul mit SoftSerial funktioniert, was hindert es dann daran, mit Iron Serial zu arbeiten? <br><br>  <strong>Das dritte "aber", konzeptionell.</strong>  Das ist noch nicht alles.  Der Hauptüberfall liegt im Prinzip der Modulbibliothek.  Es arbeitet im geschlossenen Modus, dh es blockiert den Betrieb des Controllers, während es auf das Eintreffen von SMS wartet (was 99% der Zeit ist) und während aller anderen Vorgänge des Moduls.  Was bedeutet das?  Dies bedeutet, dass Sie in der Standardbibliothek des Herstellers nur eine Testskizze erstellen können.  Der strategische Hühnerstall glänzt nicht für Sie, da Tausende cooler Anwendungen wie Sicherheitssysteme, Gewächshausmanagement, Smart-Home-Steuerung über GSM usw. usw. nicht glänzen. <br><br><h2>  Weitere Informationen zu SoftwareSerial </h2><br>  Das Modul funktioniert nicht mit Arduino Due, daher werden wir über Arduino Mega sprechen.  Das Pikante an der Situation ist, dass Mega mit drei freien Hardware-Ports Serial1, Serial2 und Seria3 gezwungen ist, eine Verbindung herzustellen und die SoftwareSerial-Bibliothek zu verwenden.  Auf keine vorstellbare und unvorstellbare Weise, einschließlich der Neuanordnung von Jumpern auf dem Modul und der Befragung mit der Sucht nach technischem Support von Amperka, war es nicht möglich, GPRS Shield dazu zu bringen, mit Hardware-Ports auf Arduino Mega zu arbeiten. <br><br>  Okay ... Wir verwenden SoftwareSerial, aber hier warten wir auf einen Hinterhalt.  SoftwareSerial kann mit vielen Arduino Mega-Pins arbeiten, aber aus irgendeinem Grund funktioniert es nur mit den 62. und 63. Pins.  Warum nur auf ihnen?  Dieses Rätsel ist großartig.  Anscheinend werden wir die Antwort auf diese Frage nie erfahren. <br><br><h2>  Mehl der Wahl </h2><br>  Und jetzt stellen wir wie üblich fest, dass die Standardbibliothek für den praktischen Gebrauch ungeeignet ist.  Durch Blockieren des Controllers, während er auf eine Antwort vom GPRS-Modul wartet, blockiert die Bibliothek auch alle anderen Prozesse.  Der Controller fällt 99% der Zeit einfach aus der Realität heraus und wartet, bis eine Anfrage oder Antwort eintrifft oder das Timeout endet. <br><br>  Dies beendet jede Anwendung von GPRS Shield, mit Ausnahme der Testanwendung: Es wurde eine Anforderung zum Einschalten des Sockets gesendet - es wurde aktiviert, eine Anforderung zum Ausschalten gesendet - es wurde deaktiviert.  Es kann keine Rede von irgendeiner Arbeit des Webservers sein, von der Arbeit mit Sensoren, der Steuerung von Aktuatoren und anderen Dingen, nichts davon wird einfach funktionieren. <br><br>  Es stellte sich die Frage: Entweder verlassen wir die Bibliothek des Herstellers und schreiben unseren GPRS Shield-Steuercode (leicht zu sagen), oder wir verlassen das Modul selbst und suchen nach einer alternativen Lösung.  Da das Modul jedoch bereits vorhanden ist, wurde beschlossen, die Bibliothek zu verlassen und Ihren Modulsteuercode zu schreiben. <br><br><h2>  Die Eroberung des Everest </h2><br>  Ich überspringe den gesamten Prozess der Erstellung des Codes, der die Standardbibliothek von Amperka ersetzt. Ich stelle nur fest, dass dies sehr, sehr schwierig war und erhebliche Forschungsarbeiten, die Kompilierung eines ausgeklügelten Algorithmus und erhebliche Anstrengungen zum Testen der resultierenden Lösung erforderte. <br><br>  Alles wird für Sie einfach sein - ein wenig Magie und der vorgefertigte Arbeitscode des AMS-Moduls zur Unterstützung von GPRS Shield ist fertig. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/557/a58/157/557a58157e7b45589395e0a9d867ee52.jpg" alt="Bild"></div><br><div class="spoiler">  <b class="spoiler_title">Vollständiger AMS-Modulcode, der die Standardbibliothek ersetzt</b> <div class="spoiler_text"><pre><code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">/* Modul GPRS part of Arduino Mega Server project */</span></span> #ifdef GPRS_FEATURE #include &lt;SoftwareSerial.h&gt; #define ALWAYS <span class="hljs-number"><span class="hljs-number">1</span></span> #define GPRS_ON_PIN <span class="hljs-number"><span class="hljs-number">2</span></span> #define GPRS_STATE_PIN <span class="hljs-number"><span class="hljs-number">3</span></span> #define GPRS_RX_PIN <span class="hljs-number"><span class="hljs-number">62</span></span> #define GPRS_TX_PIN <span class="hljs-number"><span class="hljs-number">63</span></span> #define MASTER <span class="hljs-string"><span class="hljs-string">"+7yyyxxxxxxx"</span></span> #define MESSAGE <span class="hljs-string"><span class="hljs-string">"Hello"</span></span> #define CHECK_ERROR <span class="hljs-number"><span class="hljs-number">0</span></span> #define CHECK_MARKER <span class="hljs-number"><span class="hljs-number">1</span></span> #define CHECK_OK <span class="hljs-number"><span class="hljs-number">2</span></span> #define NO_CHECK <span class="hljs-number"><span class="hljs-number">3</span></span> #define MARKER_OK <span class="hljs-string"><span class="hljs-string">"OK"</span></span> #define MARKER_NO_CHECK <span class="hljs-string"><span class="hljs-string">"-"</span></span> <span class="hljs-comment"><span class="hljs-comment">// GPRS commands #define DATA_TEMP1 "temp1" #define DATA_CONT1 "cont1" #define DATA_LEAK1 "leak1" #define DATA_SMOKE1 "smoke1" #define DATA_ALL "all" #define DATA_RELAY1 "relay1" #define DATA_SERVO1 "servo1" #define DATA_PERIOD "period" #define CMD_RELAY1 "relay1=" #define CMD_SERVO1 "servo1=" #define CMD_PERIOD "period=" byte gprsPeriod = 24; SoftwareSerial GPRS(GPRS_RX_PIN, GPRS_TX_PIN); #define MAX_SOFT_SERIAL 128 char bufferGprs[MAX_SOFT_SERIAL]; int curBuf = 0; #define MESSAGE_LENGTH 20 char message[MESSAGE_LENGTH]; char phone[16]; char datetime[24]; void gprsInit() { initStart("GPRS", true); GPRS.begin(9600); gprsOnOff(); gprsStart(); sendGprs("AT+CFUN=1", "OK"); sendGprs("AT+CNMI=2,1", "OK"); sendGprs("AT+CMGF=1", "OK"); sendGprs("AT+CLIP=1", "OK"); modulGprs = MODUL_ENABLE; initDone(true); } void clearBufferGprs() { for (int i = 0; i &lt; curBuf; i++) { bufferGprs[i] = 0; } } void gprsStart() { while (ALWAYS) { delay(1000); curBuf = 0; GPRS.println("AT"); if (GPRS.available() &gt; 0) { while (GPRS.available() &gt; 0) { bufferGprs[curBuf++] = GPRS.read(); } bufferGprs[curBuf] = '\0'; if (strcmp(bufferGprs, "AT\r\n\r\nOK\r\n") == 0) { timeStamp(); Serial.println(" GPRS ON"); break; } else { Serial.print("."); } } clearBufferGprs(); } } // gprsStart() void gprsOnOff() { pinMode(GPRS_ON_PIN, OUTPUT); if (digitalRead(GPRS_STATE_PIN) != HIGH) { digitalWrite(GPRS_ON_PIN, HIGH); delay(3000); } digitalWrite(GPRS_ON_PIN, LOW); } bool clearSoftwareSerial() { if (GPRS.available() &gt; 0) { while (GPRS.available() &gt; 0) { char c = GPRS.read(); } } } #define DELAY_GPRS_COMMAND 2000 byte sendGprs(String command, char marker[]) { unsigned long timer = millis(); bool success = false; clearSoftwareSerial(); clearBufferGprs(); Serial.print(F("Send command: ")); //Serial.println(command); while (ALWAYS) { if (millis() - timer &gt; DELAY_GPRS_COMMAND) { Serial.print(F("Send error: ")); Serial.println(command); //clearBufferGprs(); return CHECK_ERROR; } curBuf = 0; GPRS.println(command); delay(280); if (GPRS.available() &gt; 0) { while (GPRS.available() &gt; 0) { char c = GPRS.read(); if (curBuf &gt; MAX_SOFT_SERIAL - 2) {break;} bufferGprs[curBuf++] = c; Serial.print(c); } Serial.println(); bufferGprs[curBuf] = '\0'; if (marker == MARKER_NO_CHECK) { Serial.print(F("Send no check, ")); Serial.println(millis() - timer); return NO_CHECK; } else if (StrContains(bufferGprs, marker)) { Serial.print(F("Send success, ")); Serial.println(millis() - timer); return CHECK_MARKER; } else if (StrContains(bufferGprs, MARKER_OK)) { Serial.print(F("Send success, ")); Serial.println(millis() - timer); return CHECK_OK; } else { Serial.println("."); } } // if (GPRS.available() &gt; 0) delay(500); } // while (ALWAYS) } // sendGprs( ) // +CMGR: "REC READ", "XXXXXXXXXXX", "", "16/10/01,10:00:00+12" // SMS text void parseSms(char *message, char *phone, char *datetime) { int i = 0; int j = 0; while (bufferGprs[i] != '\"') {i++;} i++; while (bufferGprs[i] != '\"') {i++;} i++; while (bufferGprs[i] != '\"') {i++;} i++; while (bufferGprs[i] != '\"') {phone[j++] = bufferGprs[i++];} phone[j] = '\0'; i++; while (bufferGprs[i] != '\"') {i++;} i++; while (bufferGprs[i] != '\"') {i++;} i++; while (bufferGprs[i] != '\"') {i++;} i++; j = 0; while (bufferGprs[i] != '\"') {datetime[j++] = bufferGprs[i++];} datetime[j] = '\0'; i++; while (bufferGprs[i] != '\n') {i++;} i++; j = 0; //Serial.print(F("strlen(bufferGprs): ")); Serial.println(strlen(bufferGprs)); while (i &lt; strlen(bufferGprs) - 1) { if (j &gt; MESSAGE_LENGTH - 1) {break;} if ((byte)bufferGprs[i] == 13) {break;} message[j++] = bufferGprs[i++]; } Serial.print(F("strlen(message1): ")); Serial.println(strlen(message)); message[j] = '\0'; Serial.print(F("strlen(message2): ")); Serial.println(strlen(message)); for (int z = 0; z &lt; strlen(message); z++) { Serial.print((byte)message[z]); Serial.print(F(" ")); } Serial.println(); } void deleteSms() { if (sendGprs("AT+CMGDA=\"DEL ALL\"", "OK")) { Serial.println(F("All SMS deleted")); } else { Serial.println(F("Error delete all SMS")); } } String stringSens(byte v) { String s = ""; switch (v) { case 0: s = (F("OFF")); break; case 1: s = (F("ON")); break; default: s = (F("?")); } return s; } String stringLeak(byte v) { String s = ""; switch (v) { case 0: s = (F("LEAK!")); break; case 1: s = (F("OK")); break; default: s = (F("?")); } return s; } String stringSmoke(byte v) { String s = ""; switch (v) { case 0: s = (F("OK")); break; case 1: s = (F("SMOKE!")); break; default: s = (F("?")); } return s; } String mkTemp1() {String s = DATA_TEMP1; s += '='; s += String(lpTempTemp); s += '\n'; return s;} String mkCont1() {String s = DATA_CONT1; s += '='; s += stringSens(lpContCont1); s += '\n'; return s;} String mkLeak1() {String s = DATA_LEAK1; s += '='; s += stringLeak(lpLeakLeak1); s += '\n'; return s;} String mkSmoke1() {String s = DATA_SMOKE1; s += '='; s += stringSmoke(smokeSmoke); s += '\n'; return s;} String mkRelay1() {String s = DATA_RELAY1; s += '='; s += stringSens(relayRelay); s += '\n'; return s;} String mkServo1() {String s = DATA_SERVO1; s += '='; s += stringSens(servoState); s += '\n'; return s;} String mkPeriod() {String s = DATA_PERIOD; s += '='; s += String(gprsPeriod); s += '\n'; return s;} String mkAll() { String s = ""; s += mkTemp1(); s += mkCont1(); s += mkLeak1(); s += mkSmoke1(); s += mkRelay1(); s += mkServo1(); s += mkPeriod(); return s; } void gprsSetRelay(byte v) { switch (v) { case 0: if (relayRelay) { relayRelay = STATE_OFF; } break; case 1: if (!relayRelay) { relayRelay = STATE_ON; } break; } } void gprsSetServo(byte v) { switch (v) { case 0: servoState = STATE_OFF; break; case 1: servoState = STATE_ON; break; } } void gprsAnswer() { String s = ""; String mess = String(message); String data = ""; if (mess == DATA_TEMP1) {s += mkTemp1();} else if (mess == DATA_CONT1) {s += mkCont1();} else if (mess == DATA_LEAK1) {s += mkLeak1();} else if (mess == DATA_SMOKE1) {s += mkSmoke1();} else if (mess == DATA_RELAY1) {s += mkRelay1();} else if (mess == DATA_SERVO1) {s += mkServo1();} else if (mess == DATA_PERIOD) {s += mkPeriod();} else if (mess == DATA_ALL) {s += mkAll();} else if (mess.indexOf(F("=")) &gt;= 0) { byte p = mess.indexOf(F("=")); if (mess.indexOf(CMD_RELAY1) &gt;= 0) {data = mess.substring(p + 1); gprsSetRelay(data.toInt()); s += DATA_RELAY1; s += '='; s += stringSens(relayRelay);} else if (mess.indexOf(CMD_SERVO1) &gt;= 0) {data = mess.substring(p + 1); gprsSetServo(data.toInt()); s += DATA_SERVO1; s += '='; s += stringSens(servoState);} else if (mess.indexOf(CMD_PERIOD) &gt;= 0) {data = mess.substring(p + 1); gprsPeriod = data.toInt(); s += DATA_PERIOD; s += '='; s += String(gprsPeriod);} } else { Serial.println(F("Not command!")); } //Serial.print(F("mess: ")); Serial.println(mess); //Serial.print(F("answ: ")); Serial.println(s); if (s == "") {s = "Error";} Serial.println(F("Send answer... ")); if (sendSms(MASTER, s)) { Serial.println(F("success")); } else { Serial.println(F("error")); } } void readSms() { byte result = sendGprs("AT+CMGR=1,1", "+CMGR:"); if (result == CHECK_MARKER) { parseSms(message, phone, datetime); Serial.print(F("Number: ")); Serial.println(phone); Serial.print(F("Datetime: ")); Serial.println(datetime); Serial.print(F("Message: ")); Serial.println(message); deleteSms(); if (String(phone) == String(MASTER)) { Serial.println(F("Message from MASTER!")); gprsAnswer(); } } else if (result == CHECK_OK) { Serial.println(F("No SMS")); } else { Serial.println(F("Error read SMS")); } } bool sendSms(char *number, String data) { String numstr = "AT+CMGS=\"" + String(number) + "\""; String messtr = data + String((char)26); if (sendGprs(numstr, "&gt;")) { if (sendGprs(messtr, MARKER_NO_CHECK)) { return true; } } return false; } void sendPeriod() { Serial.println(F("Send period SMS... ")); if (sendSms(MASTER, mkAll())) { Serial.println(F("success")); } else { Serial.println(F("error")); } } void gprsWorks() { if (cycle20s) { readSms(); } switch (gprsPeriod) { case 1: if (cycle1h) {sendPeriod();} break; case 6: if (cycle6h) {sendPeriod();} break; case 12: if (cycle12h) {sendPeriod();} break; default: if (cycle24h) {sendPeriod();} break; } } #endif // GPRS_FEATURE</span></span></code> </pre> <br></div></div><br>  Das Modul wurde auf AMS Version 0.16 für Arduino Mega entwickelt und getestet.  Tests zeigten einen absolut stabilen und zuverlässigen Betrieb von GPRS Shield unter der Kontrolle dieses Moduls. <br><br><h2>  Stellen Sie eine Verbindung zum AMS GPRS Shield Support Module her </h2><br>  Um das GPRS Shield-Modul mit dem Arduino Mega Server zu verbinden, müssen Sie einige einfache Schritte ausführen.  Fügen Sie zunächst die folgenden Zeilen zur AMS-Hauptdatei hinzu <br><br><pre> <code class="java hljs">#define GPRS_FEATURE</code> </pre><br>  und <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> modulGprs = MODUL_NOT_COMPILLED;</code> </pre><br>  in den entsprechenden Abschnitten.  Dort müssen Sie Testvariablen hinzufügen, die in Ihrem realen Projekt für die gesteuerten Parameter (Temperatur, Kontaktstatus usw.) verantwortlich sind. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> lpTempTemp; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> lpContCont1; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> lpLeakLeak1; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> smokeSmoke; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> relayRelay; <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> servoState;</code> </pre><br><h2>  Erläuterung der unterstützten Funktionen </h2><br>  Das Modul enthält einen grundlegenden Satz von Abfragen und Befehlen. Sie können diese Befehle jedoch durch andere ersetzen und / oder den grundlegenden Satz von Befehlen und Abfragen erweitern, die Sie benötigen. <br><br><h3>  Anfragen </h3><br>  Anfragen werden per SMS gesendet, das System sendet Antworten (auch per SMS) mit Informationen zum angeforderten Parameter.  Ganz einfach: Wir senden die Anfrage „temp1“ vom Telefon, das System sendet daraufhin den aktuellen Temperaturwert <code>temp1=20.50</code> . <br><br><blockquote>  <strong>temp1</strong> - Temperaturanforderung <br>  <strong>cont1</strong> - Kontaktstatus anfordern <br>  <strong>Leck1</strong> - <strong>Fordern Sie</strong> den Status des <strong>Lecksensors an</strong> <br>  <strong>Rauch1</strong> - Rauchmelderstatus abfragen <br>  <strong>Relais1</strong> - Status des Relais anfordern (Schlüssel) <br>  <strong>servo1</strong> - fordert den Status des Servo-Feeders an <br>  <strong>Zeitraum</strong> - Anfrage für den Zeitraum der automatischen Telemetriepakete <br>  <strong>all</strong> - fordert alle Systemparameter an </blockquote><br>  Als Antwort auf die Anforderung "Alle" sendet das System eine Liste aller Parameter.  Wenn ein nicht registrierter Befehl gesendet wird, sendet das System eine Fehlerantwort.  Wenn die überwachten Parameter außerhalb des normalen Bereichs liegen, kann das System selbst Alarmmeldungen an das Smartphone des Bedieners senden. <br><br>  Um das System nur von einem registrierten Bediener verwalten zu können, ist das System vor unbefugtem Zugriff geschützt. Es reagiert nur auf Befehle einer bestimmten Telefonnummer. <br><br><h3>  Teams </h3><br>  Befehle werden per SMS gesendet, nachdem der Befehl akzeptiert wurde, ändert das System seinen Status und sendet Antworten mit Informationen über den neuen Status seiner Aktuatoren oder Einstellungen. <br><br><blockquote>  <strong>Relais1 =</strong> - Relaissteuerbefehl (Taste) <br>  <strong>servo1 =</strong> - Feeder-Steuerbefehl <br>  <strong>period =</strong> - Befehl zum Ändern der automatischen Sendeperiode für die Telemetrie </blockquote><br>  Ein Beispiel.  <code>relay1=1</code> , Antwortrelais1 <code>relay1=ON</code> .  <code>relay1=0</code> , Antwortrelais1 <code>relay1=OFF</code> . <br><br><h2>  Code-Erklärungen </h2><br>  Initialisierung des GPRS-Moduls.  Standardinitialisierung des AMS-Moduls, Start von SoftwareSerial und ein wenig Magie von GSM AT-Befehlen.  Der Zweck dieses Blocks besteht darin, das GPRS-Modul zum Leben zu erwecken und es aus dem Nirvana zurückzugeben, wenn es zu diesem Zeitpunkt aus irgendeinem Grund außerhalb unserer Kontrolle liegt. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gprsInit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ initStart(<span class="hljs-string"><span class="hljs-string">"GPRS"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); GPRS.begin(<span class="hljs-number"><span class="hljs-number">9600</span></span>); gprsOnOff(); gprsStart(); sendGprs(<span class="hljs-string"><span class="hljs-string">"AT+CFUN=1"</span></span>, <span class="hljs-string"><span class="hljs-string">"OK"</span></span>); sendGprs(<span class="hljs-string"><span class="hljs-string">"AT+CNMI=2,1"</span></span>, <span class="hljs-string"><span class="hljs-string">"OK"</span></span>); sendGprs(<span class="hljs-string"><span class="hljs-string">"AT+CMGF=1"</span></span>, <span class="hljs-string"><span class="hljs-string">"OK"</span></span>); sendGprs(<span class="hljs-string"><span class="hljs-string">"AT+CLIP=1"</span></span>, <span class="hljs-string"><span class="hljs-string">"OK"</span></span>); modulGprs = MODUL_ENABLE; initDone(<span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); }</code> </pre><br>  Die Hauptarbeitsfunktion des Moduls.  Alle 20 Sekunden sucht der Arduino Mega Server nach eingehenden SMS und führt diese bei Anfragen oder Befehlen aus.  Infolgedessen beträgt die durchschnittliche Verzögerung bei der Ausführung des Befehls 10 Sekunden (mit Ausnahme der Verzögerung beim Senden von SMS-Nachrichten durch den Telekommunikationsbetreiber).  Dieses Intervall kann konfiguriert werden. 20 Sekunden werden als Kompromiss zwischen der Reaktionsgeschwindigkeit auf SMS-Befehle und dem Systemstart ausgewählt. <br><br>  In diesen 20 Sekunden kann AMS alles tun, was es benötigt, und die in diesem Zeitraum eintreffende SMS geht nicht verloren.  Bei Verwendung der Standardbibliothek kann das System nur auf das Eintreffen der SMS warten, andernfalls verliert es sie nur (und der Controller kann derzeit auch nichts tun). <br><br>  Es gibt auch einen Telemetrie-Sendecode mit einem festgelegten Intervall von 1 Stunde, 6 Stunden, 12 Stunden oder 24 Stunden.  Dieses Intervall kann durch Senden des entsprechenden Befehls per SMS geändert werden. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gprsWorks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cycle20s) { readSms(); } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (gprsPeriod) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cycle1h) {sendPeriod();} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cycle6h) {sendPeriod();} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cycle12h) {sendPeriod();} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cycle24h) {sendPeriod();} <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre><br>  Die Interaktion des GPRS-Moduls und der Steuerung erfolgt mit speziellen AT-Befehlen, und die folgenden Funktionen bilden die GPRS-Modulbefehle in für sie verständlichen Codes. <br><br>  SMS-Sendefunktion.  In den Parametern der Funktion werden die Zieltelefonnummer und der Befehl oder die Anforderung in Textform übertragen. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">bool </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sendSms</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *number, String data)</span></span></span><span class="hljs-function"> </span></span>{ String numstr = <span class="hljs-string"><span class="hljs-string">"AT+CMGS=\""</span></span> + String(number) + <span class="hljs-string"><span class="hljs-string">"\""</span></span>; String messtr = data + String((<span class="hljs-keyword"><span class="hljs-keyword">char</span></span>)<span class="hljs-number"><span class="hljs-number">26</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sendGprs(numstr, <span class="hljs-string"><span class="hljs-string">"&gt;"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (sendGprs(messtr, MARKER_NO_CHECK)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; }</code> </pre><br>  SMS-Lesefunktion.  Die akzeptierten Werte werden in die Variablen message, phone und datetime eingefügt, die jeweils den empfangenen Befehl, die Telefonnummer und die Sendezeit enthalten. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">readSms</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> result = sendGprs(<span class="hljs-string"><span class="hljs-string">"AT+CMGR=1,1"</span></span>, <span class="hljs-string"><span class="hljs-string">"+CMGR:"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == CHECK_MARKER) { parseSms(message, phone, datetime); Serial.print(F(<span class="hljs-string"><span class="hljs-string">"Number: "</span></span>)); Serial.println(phone); Serial.print(F(<span class="hljs-string"><span class="hljs-string">"Datetime: "</span></span>)); Serial.println(datetime); Serial.print(F(<span class="hljs-string"><span class="hljs-string">"Message: "</span></span>)); Serial.println(message); deleteSms(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (String(phone) == String(MASTER)) { Serial.println(F(<span class="hljs-string"><span class="hljs-string">"Message from MASTER!"</span></span>)); gprsAnswer(); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (result == CHECK_OK) { Serial.println(F(<span class="hljs-string"><span class="hljs-string">"No SMS"</span></span>)); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Serial.println(F(<span class="hljs-string"><span class="hljs-string">"Error read SMS"</span></span>)); } }</code> </pre><br>  Die Funktion zum Bilden einer Antwort auf SMS-Anfragen und -Befehle.  Diese Funktion ist für jedes Projekt spezifisch und kann in Ihren Projekten entsprechend der Logik Ihres Systems geändert werden. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gprsAnswer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ String s = <span class="hljs-string"><span class="hljs-string">""</span></span>; String mess = String(message); String data = <span class="hljs-string"><span class="hljs-string">""</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mess == DATA_TEMP1) {s += mkTemp1();} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mess == DATA_CONT1) {s += mkCont1();} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mess == DATA_LEAK1) {s += mkLeak1();} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mess == DATA_SMOKE1) {s += mkSmoke1();} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mess == DATA_RELAY1) {s += mkRelay1();} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mess == DATA_SERVO1) {s += mkServo1();} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mess == DATA_PERIOD) {s += mkPeriod();} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mess == DATA_ALL) {s += mkAll();} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mess.indexOf(F(<span class="hljs-string"><span class="hljs-string">"="</span></span>)) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">byte</span></span> p = mess.indexOf(F(<span class="hljs-string"><span class="hljs-string">"="</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mess.indexOf(CMD_RELAY1) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) {data = mess.substring(p + <span class="hljs-number"><span class="hljs-number">1</span></span>); gprsSetRelay(data.toInt()); s += DATA_RELAY1; s += <span class="hljs-string"><span class="hljs-string">'='</span></span>; s += stringSens(relayRelay);} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mess.indexOf(CMD_SERVO1) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) {data = mess.substring(p + <span class="hljs-number"><span class="hljs-number">1</span></span>); gprsSetServo(data.toInt()); s += DATA_SERVO1; s += <span class="hljs-string"><span class="hljs-string">'='</span></span>; s += stringSens(servoState);} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mess.indexOf(CMD_PERIOD) &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) {data = mess.substring(p + <span class="hljs-number"><span class="hljs-number">1</span></span>); gprsPeriod = data.toInt(); s += DATA_PERIOD; s += <span class="hljs-string"><span class="hljs-string">'='</span></span>; s += String(gprsPeriod);} } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Serial.println(F(<span class="hljs-string"><span class="hljs-string">"Not command!"</span></span>)); } <span class="hljs-comment"><span class="hljs-comment">//Serial.print(F("mess: ")); Serial.println(mess); //Serial.print(F("answ: ")); Serial.println(s); if (s == "") {s = "Error";} Serial.println(F("Send answer... ")); if (sendSms(MASTER, s)) { Serial.println(F("success")); } else { Serial.println(F("error")); } }</span></span></code> </pre><br>  Funktionen zur Bildung von Antworten.  Hierbei handelt es sich um Funktionen, die die Antworten bilden, die das System gemäß dem festgelegten Programm als Antwort auf eine Anfrage oder nach eigenem Ermessen per SMS an das Smartphone des Benutzers sendet. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stringSens</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stringLeak</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stringSmoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mkTemp1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mkCont1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mkLeak1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mkSmoke1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mkRelay1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mkServo1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mkPeriod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mkAll</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span></code> </pre><br>  Und die Funktionen der Befehlsausführung.  Dies sind Funktionen, die von SMS-Befehlen ausgeführt werden und den Zustand des Systems ändern, d. H. Seine Einstellungen ändern oder Aktuatoren aktivieren oder deaktivieren. <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gprsSetRelay</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gprsSetServo</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params"> v)</span></span></span></span></code> </pre><br>  Die übrigen Funktionen sind rein technischer Natur und erledigen die grobe Arbeit der Wartung der Interaktion zwischen dem GPRS Shield und dem Mikrocontroller. <br><br><h2>  Ein bisschen mehr über SoftwareSerial </h2><br>  All dies reicht nicht aus, damit GPRS Shield in einem transparenten Modus arbeitet und andere auf dem Mikrocontroller ausgeführte Prozesse nicht mehr blockiert.  Es ist auch erforderlich, den Code der SoftwareSerial-Bibliothek zu ändern.  Tatsache ist, dass sein Standard-64-Byte-Puffer nicht ausreicht, um die meisten AT-GSM-Befehle zu verarbeiten und eine dynamische Interaktion zwischen dem Modul und der Steuerung aufrechtzuerhalten. <br><br>  Sie müssen diesen Puffer auf mindestens 128 Byte erhöhen. Erst danach funktioniert die Magie und das GPRS-Schild arbeitet im transparenten Modus normal.  Dies erfolgt in der Datei <code>SoftwareSerial.h</code> .  Linie <br><br><pre> <code class="java hljs">#define _SS_MAX_RX_BUFF <span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-comment"><span class="hljs-comment">// RX buffer size</span></span></code> </pre><br>  müssen zu ändern <br><br><pre> <code class="java hljs">#define _SS_MAX_RX_BUFF <span class="hljs-number"><span class="hljs-number">128</span></span> <span class="hljs-comment"><span class="hljs-comment">// RX buffer size</span></span></code> </pre><br><h2>  Fazit </h2><br>  Sie sehen den Austausch von Bedienerbefehlen und Systemantworten auf dem Smartphone-Bildschirm.  Und während das System Dutzende von Prozessen im Pseudo-Multitasking-Modus ausführt.  Und GPRS Shield beanspruchte weniger als 1% der Prozessorzeit anstatt 99% wie zuvor, wodurch der Rest der Zeit für den Webserver und andere Aufgaben für die Verwaltung des Hühnerstalles frei wurde. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/files/2e1/615/a08/2e1615a08e2a4a29802805066509d3e4.png" alt="Bild"></div><br>  Das ist alles, wir haben GPRS Shield in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AMS integriert</a> , alle Hindernisse überwunden, es in einem transparenten Modus arbeiten lassen, ohne andere Prozesse wie einen Webserver, den Betrieb von drahtlosen Sensoren und Aktoren zu blockieren, und dies eröffnet attraktive Perspektiven für den Aufbau einer großen Anzahl von Systemen mit GSM-SMS-Steuerung und Steuerung basierend auf AMS - Gewächshäuser, Sicherheits- und Heizungssysteme, verschiedene Optionen für ein intelligentes Zuhause usw. usw. nahezu unendlich. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de401721/">https://habr.com/ru/post/de401721/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de401709/index.html">Lin Industrial gibt nicht auf</a></li>
<li><a href="../de401711/index.html">Valve trainiert AI, um Betrüger in CS: GO zu erkennen</a></li>
<li><a href="../de401713/index.html">Was tun, wenn Sie sich im Flugzeug langweilen? Führen Sie Google Chrome auf der Stuhllehne aus</a></li>
<li><a href="../de401715/index.html">Weltraumfischen von Robert Winglee (NASA)</a></li>
<li><a href="../de401719/index.html">Cyclone 10 - Intel-FPGA</a></li>
<li><a href="../de401723/index.html">Kunstrenovierung alter Computerausrüstung</a></li>
<li><a href="../de401725/index.html">Die Geschichte der implantierbaren Technologie. Zahnersatz</a></li>
<li><a href="../de401727/index.html">Ein Geek-Geschenk für den 23. Februar auswählen: Madrobots Guide</a></li>
<li><a href="../de401729/index.html">Was ist nützlicher (und gefährlicher) "Lärm", der uns umgibt?</a></li>
<li><a href="../de401735/index.html">Lernen Sie die Innenseiten der mobilen PartyFon Max-Vibro-Lautsprecher kennen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>