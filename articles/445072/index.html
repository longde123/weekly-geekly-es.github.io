<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙍🏼 🐫 🛀🏼 Telegraff: Kotlin DSL para Telegram 🐓 🚵🏾 🙍🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En Habré, miles de artículos sobre cómo hacer un bot de Telegram para diferentes lenguajes y plataformas de programación. El tema está lejos de ser nu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Telegraff: Kotlin DSL para Telegram</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445072/"><p><img src="https://habrastorage.org/webt/3v/da/0z/3vda0ztz83mtq8efycve_gfyrqa.png" alt="Logotipo"></p><br><p>  En Habré, miles de artículos sobre cómo hacer un bot de Telegram para diferentes lenguajes y plataformas de programación.  El tema está lejos de ser nuevo. </p><br><p>  Pero Telegraff es el mejor marco para implementar bots de Telegram, y lo probaré por debajo. </p><a name="habracut"></a><br><h2 id="preambula">  Preámbulo </h2><br><p>  En 2015, el rublo ruso tenía fiebre.  Tenía ahorros en dólares y revisé la tasa literalmente cada cinco minutos para vender la moneda a la tasa que necesitaba.  La fiebre se prolongó, me cansé y escribí un bot de Telegram ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@TinkoffRatesBot</a> ), que le notifica si el tipo de cambio alcanza el valor umbral (esperado). <br>  Me conmovió mucho esta tarea.  Botha escribió bastante rápido, pero no recibió satisfacción. </p><br><p>  La integración con Telegram no es y no hubo problemas.  Este problema se resuelve en un par de horas.  Incluso me sorprende que haya bibliotecas enteras en Java (subjetivamente, con un código de calidad repugnante) para la integración con Telegrams, que han ganado más de mil estrellas en Github. </p><br><p>  El principal desafío para mí fue el sistema de secuencias de comandos: el usuario llama a un comando, por ejemplo, "/ taxi", el bot le hace una serie de preguntas, cada respuesta se valida y puede afectar el orden de las preguntas posteriores, se forma el "formulario" habitual, dado el método de procesamiento final para la formación respuesta <br>  Hice esto, pero la estructura de las clases, los niveles de abstracción, todo era tan heterogéneo que era amargo verlo.  Me atormentó la pregunta: ¿cómo se puede transferir de manera sucinta y orgánica a un modelo orientado a objetos? </p><br><p>  Quería tener algo simple, conveniente y lo más importante: poder describir el script completo en un archivo aislado para no tener que ver la mitad del proyecto para comprender la cadena de interacción del usuario. </p><br><p>  No quiere decir que el problema fuera muy agudo, porque la tarea ya está resuelta.  Más bien, a veces pensaba en él.  La idea era Groovy DSL, pero cuando llegó Kotlin, la elección se hizo evidente.  Entonces apareció Telegraff. </p><br><p>  Sí, por supuesto, no había competencia que ganaría Telegraff.  Y la afirmación de que Telegraff es el mejor no debe tomarse literalmente.  Pero Telegraff es un enfoque nuevo y único para este desafío.  Es fácil ser el mejor, ser el único. </p><br><h2 id="kak-etim-polzovatsya">  ¿Cómo usarlo? </h2><br><h3 id="zavisimosti">  Dependencias </h3><br><p>  El primer paso es especificar un repositorio adicional para las dependencias.  Quizás en algún momento publique Telegraff en Maven Central o en JCenter, pero por ahora. </p><br><div class="spoiler">  <b class="spoiler_title">Gradle</b> <div class="spoiler_text"><pre><code class="kotlin hljs">repositories { maven { url <span class="hljs-string"><span class="hljs-string">"https://dl.bintray.com/ruslanys/maven"</span></span> } }</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Maven</b> <div class="spoiler_text"><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">repositories</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">repository</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">snapshots</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">enabled</span></span></span><span class="hljs-tag">&gt;</span></span>false<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">enabled</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">snapshots</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">id</span></span></span><span class="hljs-tag">&gt;</span></span>bintray-ruslanys-maven<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">id</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span>bintray<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">name</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">url</span></span></span><span class="hljs-tag">&gt;</span></span>https://dl.bintray.com/ruslanys/maven<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">url</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">repository</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">repositories</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> </div></div><br><p>  Sigue siendo el caso para los pequeños.  Para usar Telegraff, debe especificar solo una dependencia de arranque por arranque de resorte: </p><br><div class="spoiler">  <b class="spoiler_title">Gradle</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">compile("me.ruslanys.telegraff:telegraff-starter:1.0.0")</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Maven</b> <div class="spoiler_text"><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span>me.ruslanys.telegraff<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">groupId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span>telegraff-starter<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">artifactId</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span>1.0.0<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">version</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">dependency</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> </div></div><br><h3 id="konfiguraciya">  Configuracion </h3><br><p>  La configuración del proyecto es simple y puede limitarse a los primeros dos o tres parámetros: </p><br><div class="spoiler">  <b class="spoiler_title">application.properties</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">telegram.access-key=123 # ① telegram.mode=webhook # ② telegram.webhook-base-url=https://ruslanys.me # ③ telegram.webhook-endpoint-url=/telegram # ④ telegram.handlers-path=handlers # ⑤ telegram.unresolved-filter.enabled=false # ⑥</code> </pre> </div></div><br><ol><li>  Tu clave para la API de Telegram. </li><li>  El modo de recibir mensajes (actualizaciones) de Telegram.  Puede ser sondeo o webhook. </li><li>  Si el método para recibir actualizaciones se indica mediante "webhook", debe especificar la ruta a su aplicación. </li><li>  Si lo desea, puede especificar su propia ruta al punto final.  Si este parámetro no se redefine, se generará una ruta de la siguiente forma: <code>/telegram/${UUID}</code> .  Antes de iniciar la aplicación, la dirección especificada se establece como la dirección de enlace web.  Al final del trabajo, la dirección de enlace web se sobrescribe para poder cambiar a sondeo la próxima vez que comience. </li><li>  Si lo desea, puede cambiar la carpeta en la que se ubicarán los scripts de los controladores.  Por defecto, esta es la carpeta de <code>handlers</code> . </li><li>  <code>UnresolvedFilter</code> está incluido en la "entrega" y está habilitado de forma predeterminada.  En el caso de que no se encuentre ningún controlador en el mensaje del usuario, <code>UnresolvedFilter</code> responde con algo como "Lo siento, no te entiendo :(". </li></ol><br><p>  ¡Es hora de escribir guiones! </p><br><h3 id="obrabotchiki">  Manipuladores </h3><br><p>  Los controladores (scripts) son una parte clave de Telegraff.  Aquí es donde se establece la cadena de interacción del usuario.  La conclusión es que cada comando, como "/ start", "/ taxi", "/ help", es un script / script / handler / handler separado. </p><br><p>  Un script puede contener un conjunto de pasos (preguntas) que un usuario debe seguir para ejecutar un comando.  En otras palabras, el usuario debe completar el formulario.  Y dado que el messenger es de la interfaz, debe hablar y preguntarle al usuario. </p><br><p>  ¿Debo explicar que las respuestas de los usuarios deben validarse?  Lo primero que hará el usuario es que responderá de manera diferente a lo que usted espera. </p><br><p>  Bueno, al final, el script puede ramificarse, es decir  Cada respuesta a una pregunta puede afectar el orden de las siguientes. </p><br><p>  Por ejemplo! </p><br><p>  Para comenzar, coloque el archivo con la extensión <code>.kts</code> en la carpeta con <code>handlers</code> recursos: <code>src/main/resources/handlers/ExampleHandler.kts</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Escenario de llamada de taxi</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PaymentMethod</span></span></span><span class="hljs-class"> </span></span>{ CARD, CASH } handler(<span class="hljs-string"><span class="hljs-string">"/taxi"</span></span>, <span class="hljs-string"><span class="hljs-string">""</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// ① step&lt;String&gt;("locationFrom") { // ② question { // ③ MarkdownMessage(" ?") } } step&lt;String&gt;("locationTo") { question { MarkdownMessage(" ?") } } step&lt;PaymentMethod&gt;("paymentMethod") { question { state -&gt; MarkdownMessage("   ?", "", "") // ④ } validation { // ⑤ when (it.toLowerCase()) { "" -&gt; PaymentMethod.CARD "" -&gt; PaymentMethod.CASH else -&gt; throw ValidationException(",    ") // ⑥ } } next { state -&gt; null // ⑦ } } process { state, answers -&gt; // ⑧ val from = answers["locationFrom"] as String val to = answers["locationTo"] as String val paymentMethod = answers["paymentMethod"] as PaymentMethod // ⑨ // Business logic MarkdownMessage("""     #${state.chat.id}.   $from  $to.  $paymentMethod. """.trimIndent()) // ⑩ } }</span></span></code> </pre> </div></div><br><p>  Las llaves de las estepas no fueron deliberadamente tomadas en constantes.  En producción, por supuesto, es mejor evitarlo. </p><br><p>  Vamos a resolverlo: </p><br><ol><li>  Declaramos el guión.  Se requiere al menos un nombre de equipo.  En este caso, hay dos equipos: "/ taxi", "taxi".  Si el mensaje del usuario comienza con estas palabras, se llamará al controlador correspondiente. </li><li>  Determinamos los pasos (preguntas).  Se requiere un nombre de paso único porque  posteriormente, se puede acceder a la respuesta del usuario precisamente por esta clave ("locationFrom"). </li><li>  Cada paso contiene tres secciones, la primera de las cuales es la pregunta en sí.  La pregunta es una sección obligatoria que debe estar presente en cada paso.  No tiene sentido en un paso sin una pregunta. </li><li>  Puede completar la pregunta como desee.  En este caso, se le pedirá al usuario a través del teclado que seleccione una de las opciones: "Tarjeta" o "Efectivo".  Como resultado de llamar a este bloque, debe haber un objeto de tipo <code>TelegramSendRequest</code> .  Lo sentimos, no se me ocurrió nada mejor que el sufijo <code>SendRequest</code> , que describe la estructura como una solicitud saliente en Telegram. <br><img src="https://habrastorage.org/webt/zc/fg/u0/zcfgu08yo--cn3bhnrnhawcfad0.png" alt="Estructura de clase"></li><li>  El segundo paso más importante es verificar la respuesta del usuario.  El tipo de cada paso está parametrizado (genérico) y, por lo tanto, el bloque de validación debe devolver exactamente el tipo por el cual se parametriza su paso. </li><li>  Si la respuesta del usuario no es satisfactoria, puede lanzar una <code>ValidationException</code> con texto aclaratorio, pero el mismo teclado, si se indicó en la pregunta. </li><li>  La sección del paso final es un bloque que indica el siguiente paso.  Por defecto, los pasos se ejecutarán en el orden de su declaración, de arriba a abajo.  Pero este proceso puede verse influenciado al anular el bloque correspondiente.  La clave del siguiente paso ( <code>String</code> ) o "nulo" se puede devolver como resultado de la ejecución de este bloque, lo que indica que no hay más pasos y que es hora de proceder a la ejecución del comando. </li><li>  Cuando se genera una solicitud de usuario, se requiere su procesamiento.  Los argumentos en el lambda son State (esto es algo así como una sesión) y las respuestas del usuario. </li><li>  Tenga en cuenta que la respuesta fallida ya no es la cadena de respuesta del usuario, sino un objeto ya procesado del tipo deseado. </li><li>  La respuesta al comando puede ser cualquiera, similar al párrafo 4. Si no se requiere la respuesta al comando, puede devolver "nulo". </li></ol><br><p>  Un controlador puede no tener pasos en absoluto.  En este caso, solo necesita determinar el comportamiento del controlador para invocar el comando. </p><br><div class="spoiler">  <b class="spoiler_title">Guión de bienvenida</b> <div class="spoiler_text"><pre> <code class="kotlin hljs">handler(<span class="hljs-string"><span class="hljs-string">"/start"</span></span>) { process { _, _ -&gt; MarkdownMessage(<span class="hljs-string"><span class="hljs-string">"!"</span></span>) } }</code> </pre> </div></div><br><h3 id="probuem">  Prueba </h3><br><p>  Para intentarlo, bifurca el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">repositorio</a> , clónalo en la máquina local y ve a la carpeta de <code>telegraff-sample</code> .  Configurar, iniciar, tocar! </p><br><p>  En general, <code>telegraff-sample</code> es un proyecto deliberadamente independiente que no está relacionado con el padre e incluso tiene su propio Gradle Wrapper.  Solo puede dejar esta carpeta.  Este es un tipo de arquetipo. </p><br><h2 id="kak-eto-ustroeno">  Como funciona </h2><br><h3 id="telegram">  Telegrama </h3><br><p>  La integración con Telegram es muy simple e implementada en <a href=""><code>TelegramApi</code></a> . </p><br><p>  Cada método se implementó deliberadamente individualmente debido a una serie de circunstancias: comenzando por el uso de Spring's RestTemplate (y las pruebas para ello), hasta la especificidad de la API de Telegram. </p><br><p>  Como puede ver en la configuración, hay dos tipos de clientes de esta API en Telegraff: <a href="">PollingClient</a> , <a href="">WebhookClient</a> .  Dependiendo de la configuración, se declarará un bin particular. </p><br><p>  Y aunque los métodos para recibir actualizaciones (mensajes nuevos) difieren de Telegram, la esencia no cambia y se reduce a una sola cosa: publicar un evento ( <a href=""><code>TelegramUpdateEvent</code></a> ) sobre mensajes nuevos a través de <code>EventPublisher</code> de Spring (patrón "Observador").  Si lo desea, puede implementar su propio oyente suscribiéndose a este tipo de evento.  Una lógica, como me parece, una capa de abstracción, porque no importa en absoluto cómo se recibió el mensaje. </p><br><h3 id="filtry">  Filtros </h3><br><p>  Tan pronto como se reciba un nuevo mensaje, es necesario procesarlo y responder al usuario.  Para hacer esto, el mensaje debe pasar por la cadena de filtros. </p><br><p>  Esto es similar a los filtros Java EE familiares para los programadores Java.  La única diferencia es que los llamados controladores (si dibujamos un paralelo con Java EE, estos son Servlets) no son independientes de los filtros, sino que son parte de ellos. </p><br><p><img src="https://habrastorage.org/webt/uo/ok/y8/uooky82zpiurpncn-szq4bdejni.png" alt="Cadena de filtro"></p><br><p>  Entonces, los filtros están optimizados y pueden permitir que los mensajes vayan más abajo en la cadena, tal vez no. </p><br><p>  <code>LoggingFilter</code> es obviamente el filtro de prioridad más alta (primero) que se llamará como parte del procesamiento de un nuevo mensaje.  Registra información en un mensaje entrante y lo envía más abajo en la cadena.  A propósito agregué <code>LoggingFilter</code> como ejemplo.  De hecho, puede no tener sentido, porque  Los mensajes entrantes se registran a nivel del cliente. </p><br><p>  El siguiente filtro es <code>CancelFilter</code> .  Básicamente funciona en conjunto con <code>HandlersFilter</code> y es un complemento para él.  Su tarea es simple: si el usuario desea abandonar la secuencia de comandos actual, puede escribir "/ cancelar" o "cancelar" y su estado (sesión) debe borrarse.  Puede comenzar cualquier nuevo escenario sin completar el anterior.  Por esta razón, <code>CancelFilter</code> "mayor" (prioridad) <code>HandlersFilter</code> . </p><br><p>  <code>HandlersFilter</code> es el filtro principal en el proceso actual.  Es este filtro el que almacena el estado de los chats del usuario, encuentra y llama al controlador (script) deseado, aplica bloques de validación, determina el orden de los pasos y responde al usuario. </p><br><p>  Si <code>HandlersFilter</code> no encontró ningún controlador adecuado para el mensaje del usuario, ya sea en la sesión o en el contenido, el mensaje se envía más abajo en la cadena.  El filtro extremo es <code>UnresolvedFilter</code> .  Este es un filtro que sabe que es el último, por lo tanto, su funcionalidad es simple: si me contactaron, la forma de responder a un mensaje no está clara, diré que no entendí nada.  Me parece que es mejor recibir al menos algunos mensajes del bot si no sabe cómo responder, que no recibir nada en absoluto. </p><br><p>  Para agregar su filtro, debe declarar un Bean de la clase <code>TelegramFilter</code> y especificar la anotación <code>@TelegramFilterOrder(ORDER_NUMBER)</code> . </p><br><div class="spoiler">  <b class="spoiler_title">Ejemplo de filtro</b> <div class="spoiler_text"><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Component</span></span> <span class="hljs-meta"><span class="hljs-meta">@TelegramFilterOrder(Integer.MIN_VALUE)</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">LoggingFilter</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">TelegramFilter { override fun handleMessage</span></span></span></span>(message: TelegramMessage, chain: TelegramFilterChain) { log.info(<span class="hljs-string"><span class="hljs-string">"New message from #{}: {}"</span></span>, message.chat.id, message.text) chain.doFilter(message) } <span class="hljs-keyword"><span class="hljs-keyword">companion</span></span> <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> log = LoggerFactory.getLogger(LoggingFilter::<span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">java</span></span></span><span class="hljs-class">) } }</span></span></code> </pre> </div></div><br><p>  Así es como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">@TinkoffRatesBot</a> implementa una "calculadora".  Sin llamar a ningún script y comando, puede enviar un número, por ejemplo, "1000", o incluso una expresión completa, por ejemplo, "4500 * 3 - 12000".  El bot calculará el resultado de la expresión, aplicará los tipos de cambio actuales al resultado y mostrará información al respecto.  De hecho, el resultado de tales acciones es la ejecución de <code>CalculationFilter</code> , que se encuentra en la cadena debajo de <code>HandlersFilter</code> , pero por encima de <code>UnresolvedFilter</code> . </p><br><h3 id="obrabotchiki-1">  Manipuladores </h3><br><p>  El sistema de secuencias de comandos de Telegraff (controladores) se basa en el DSL de Kotlin.  En resumen, se trata de lambdas y de constructores. </p><br><p>  No veo el punto de ver por separado el DSL Kotlin, porque  Esta es una conversación completamente diferente.  Hay una gran <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentación</a> de JetBrains y un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">informe</a> completo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">i_osipov</a> . </p><br><h3 id="nyuansy">  Matices </h3><br><p>  Esta sección está dedicada a las características actuales.  Todos ellos, en mi opinión, no son críticos, algunos pueden ser reparados, otros no.  Pero necesitas saber sobre estos aspectos. </p><br><p>  Si desea participar o sabe cómo corregir uno u otro punto de esta sección, se lo agradeceré. </p><br><h4 id="telegram-1">  Telegrama </h4><br><p>  La capa de integración con Telegram probablemente no se describe completamente.  Solo se implementaron los métodos que necesitaba.  Si hay algo que personalmente le falta, corrija <a href=""><code>TelegramApi</code></a> y envíe PR. </p><br><p>  Una de las partes importantes en este momento es la falta de soporte de teclado en línea (esto es cuando el teclado está directamente debajo del mensaje en la cinta de opciones).  La tarea se ve agravada por el hecho de que los teclados en línea deben ser "ingresados" correctamente en la estructura existente para que siga siendo simple, conveniente, aislada.  Ya existe una buena idea para implementar esta funcionalidad, pero aún no se ha implementado y probado de ninguna forma. </p><br><h4 id="fat-jar">  Tarro de grasa </h4><br><p>  Desafortunadamente, algunas bibliotecas, como <code>JRuby</code> y probablemente el <code>Kotlin Embedded Compiler</code> (necesario para compilar scripts) pueden tener problemas como parte del <code>Fat JAR</code> .  <code>Fat JAR</code> es cuando su código y todas sus dependencias se empaquetan en un archivo ( <code>*.jar</code> ). </p><br><p>  Para resolver este problema, puede desempaquetar dependencias en tiempo de ejecución.  Es decir, cuando se inicia la aplicación, el JAR de dependencia del paquete principal se implementa en algún lugar del disco y la ruta de clase se indica antes.  Esto es bastante fácil de hacer a través de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la configuración de</a> <code>bootJar</code> : </p><br><div class="spoiler">  <b class="spoiler_title">Configuración del complemento</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">bootJar { requiresUnpack "**/**kotlin**.jar" requiresUnpack "**/**telegraff**.jar" }</code> </pre> </div></div><br><p>  Sin embargo, para referirse de los controladores (scripts) a sus beans (servicios, por ejemplo), también deben estar desempaquetados.  Lo cual, en principio, elimina el beneficio de este enfoque. </p><br><p>  Tal como lo veo, el uso del complemento de <code>application</code> Gradle sigue siendo el método más confiable, simple y conveniente.  Además, si está conteniendo su aplicación en contenedores, no hay diferencia por el resultado. </p><br><p>  Sobre todo esto escribí en detalle <a href="">aquí</a> . </p><br><h4 id="poryadok-inicializacii">  Orden de inicialización </h4><br><p>  Aquí me gustaría señalar dos circunstancias. </p><br><p>  En primer lugar, si observa el escenario de la llamada de taxi, puede ver que la clase de <code>enum</code> se define sobre la llamada al <code>handler(...)</code> .  Esta necesidad se impone por el hecho de que, de hecho, el <code>handler</code> es una llamada a la función.  Una llamada a función, cuyo resultado debería ser alguna estructura, que Telegraff usará más adelante.  Si, de acuerdo con el resultado de la ejecución de su script, la fábrica no puede llevar el resultado al tipo deseado, se producirá un error en la etapa de inicialización. </p><br><p>  En segundo lugar, debe recordar que sus scripts se pueden inicializar antes que toda su aplicación y beans.  Si, por ejemplo, coloca un enlace a un contexto en una variable estática e intenta obtener algún servicio en la primera línea del archivo de script, puede resultar que el contexto no lo tenga, porque  aún no se ha inicializado.  Para evitar tales problemas, use <a href="">este</a> método de Telegraff.  Asegura que el contexto se inicialice y que todos los beans necesarios estén disponibles.  Un ejemplo se puede ver <a href="">aquí</a> . </p><br><h2 id="zaklyuchenie">  Conclusión </h2><br><p>  Quería probar - tenedor, <br>  Quería arreglarlo: enviar relaciones públicas, <br>  Quería agradecer: ¡pon un asterisco en Github, como la publicación y cuéntaselo a tus amigos! </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Repositorio de proyectos</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/445072/">https://habr.com/ru/post/445072/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../445060/index.html">Organizar búsquedas de datos utilizando los repositorios clave-valor de Spring Data</a></li>
<li><a href="../445062/index.html">Formato de presentación moderno?</a></li>
<li><a href="../445064/index.html">La batalla por la neutralidad de la red: una oportunidad de regresar</a></li>
<li><a href="../445066/index.html">Cómo escribo notas matemáticas en LaTeX en Vim</a></li>
<li><a href="../445070/index.html">El resumen de materiales interesantes para el desarrollador móvil # 291 (18 de marzo - 24 de marzo)</a></li>
<li><a href="../445074/index.html">Programación LibreOffice Base. Parte 1</a></li>
<li><a href="../445076/index.html">El gigante de TI introdujo el firewall definido por el servicio</a></li>
<li><a href="../445078/index.html">Es probable que la física cuántica proteja las redes eléctricas de EE. UU. De los piratas informáticos</a></li>
<li><a href="../445080/index.html">En Rusia, creará un "ferrocarril digital"</a></li>
<li><a href="../445082/index.html">El mes pasado llamamos a Zuckerberg un bobo; corregido: de hecho, él y su Facebook son una pena</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>