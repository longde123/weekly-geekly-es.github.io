<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥚 🛌🏿 🍒 在2019中进行代码拆分 ⚓️ 👳🏿 🏳️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="是2019年！ 每个人都认为他们知道代码拆分。 所以-让我们仔细检查！ 



 代码拆分代表什么？ 


 简而言之-代码拆分几乎不会加载整个东西。 然后，您正在阅读此页面，而不必加载整个网站。 当您从数据库中选择一行时-您不必全部使用。 
 明显吗？ 代码拆分也很明显，不仅涉及数据，还涉及代码。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在2019中进行代码拆分</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444402/"><p> 是2019年！ 每个人都认为他们知道代码拆分。 所以-让我们仔细检查！ </p><br><p><img src="https://habrastorage.org/webt/da/lx/0b/dalx0bnbenxiqebdymmcrp8in68.png"></p><br><h2 id="what-does-code-splitting-stand-for"> 代码拆分代表什么？ </h2><br><p> 简而言之-代码拆分几乎不会加载整个东西。 然后，您正在阅读此页面，而不必加载整个网站。 当您从数据库中选择一行时-您不必全部使用。 <br> 明显吗？ 代码拆分也很明显，不仅涉及数据，还涉及代码。 </p><a name="habracut"></a><br><h2 id="whowhat-is-making-code-splitting"> 谁（什么？）正在拆分代码？ </h2><br><p> <code>React.lazy</code>吗？ 不-它只使用它。 代码拆分是在捆绑程序级别上完成的-Webpack，宗地，或者只是您的文件系统，以防使用“本地” esm模块。 代码拆分只是文件，可以在“后期”加载的文件。 所以-对于“ <strong>什么是增强代码拆分能力？</strong> ”的问题-答案是-“捆绑程序”。 </p><br><h2 id="whowhat-is-using-code-splitting"> 谁在使用代码拆分？ </h2><br><p>  <code>React.lazy</code>正在使用。 仅使用捆绑程序的代码拆分。 渲染时只调用import。 仅此而已。 </p><br><h2 id="whats-about-react-loadable"> 什么是React-loadable？ </h2><br><p>  <code>React.lazy</code>取代了它。 并提供了更多功能，例如<code>Suspense</code>来控制加载状态。 所以-使用<code>React.Lazy</code>代替。 </p><br><blockquote> 是的，仅此而已。 感谢您的阅读，并祝您愉快。 </blockquote><br><h2 id="why-article-is-not-finished"> 为什么文章没有完成？ </h2><br><p> 好吧 我忘了提到关于<code>React.lazy</code>和代码拆分的一些灰色区域。 </p><br><h3 id="grey-zone-1--testing"> 灰色区域1-测试 </h3><br><p> 由于<code>React.lazy</code>的<em>异步性，</em>要测试它并不容易。 只要尚未加载（即使已加载），它就是“空”- <code>Promises</code>和<code>import</code>返回，并且懒惰地接受， <strong>保证</strong> ，总是<strong>在下一个tick中</strong>执行。 </p><br><p> 建议的解决方案？ 您不会相信，但是建议的解决方案是使用同步<em>容器</em> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">请参阅pull request</a> 。 所以-让我们的<code>imports</code>同步！  <em>（以解决测试或其他服务器端情况的延迟问题）</em> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> LazyText = lazy(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> ({ then(cb) { cb({<span class="hljs-attr"><span class="hljs-attr">default</span></span>: Text}); <span class="hljs-comment"><span class="hljs-comment">// this is "sync" thenable }, })); const root = ReactTestRenderer.create( &lt;Suspense fallback={&lt;Text text="Loading..." /&gt;}&gt; &lt;LazyText text="Hi" /&gt; // this lazy is not very lazy &lt;/Suspense&gt;, );</span></span></code> </pre> <br><p> 将导入函数转换为记忆同步同步并不难。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> syncImport = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">importFn</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> preloaded = <span class="hljs-literal"><span class="hljs-literal">undefined</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promise = importFn().then(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">module</span></span></span><span class="hljs-function"> =&gt;</span></span> preloaded = <span class="hljs-built_in"><span class="hljs-built_in">module</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ^ "auto" import and "cache" promise return () =&gt; preloaded ? { then: () =&gt; preloaded } : promise; // ^ return sync thenable then possible } const lazyImport = isNode ? syncImport : a =&gt; a; // ^ sync for node, async for browser const LazyComponent = React.lazy(lazyImport(() =&gt; import('./file'));</span></span></code> </pre> <br><h3 id="grey-zone-2--ssr"> 灰色区域2-SSR </h3><br><blockquote> 如果您不需要SSR，请继续阅读本文！ </blockquote><p>  <code>React.lazy</code>是SSR友好的。 但这需要<code>Suspense</code>起作用，并且Suspense <strong>不是服务器端友好的</strong> 。 </p><br><p> 有两种解决方案： </p><br><ul><li> 例如，通过嘲讽将Suspense替换为Fragment。 然后，将更改后的<code>import</code>版本与<code>import</code>一起使用， <code>then</code>使lazy也同步运行。 <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> realLazy = React.lazy; React.lazy = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">importer</span></span></span><span class="hljs-function"> =&gt;</span></span> realLazy(syncImport(importer)); React.Suspense = React.Fragment; <span class="hljs-comment"><span class="hljs-comment">// :P // ^ React SSR just got fixed :D</span></span></code> </pre> </li></ul><br><p> 这是一个不错的选择，但它对客户端不十分友好。 怎么了 让我们定义第二种可能的解决方案： </p><br><ul><li> 在React水合之前，使用<strong>专门的库</strong>来跟踪使用的脚本，块和样式，并将它们加载到客户端（尤其是样式！）上。 否则-您将呈现空洞而不是代码拆分的组件。 再说一遍-您没有加载刚刚拆分的代码，因此您无法渲染任何内容。 </li></ul><br><h3 id="behold-code-splitting-libraries"> 看代码拆分库 </h3><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">通用组件</a> -最古老且仍可维护的库。 它从“教导” Webpack到代码拆分方面“发明”了代码拆分。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">React-loadable-</a>非常流行，但是没有维护。 使代码随处可见。 问题已经关闭，因此周围没有社区。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">可加载组件</a> -功能齐全的库，很高兴与周围最活跃的社区一起使用。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">导入的组件</a> -不绑定到Webpack的单个库，即能够处理包裹或esm。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">React-async-component-</a>已经死了的库（至今很流行），它对代码拆分，自定义React树遍历和SSR周围的一切都产生了重大影响。 </li><li>  <em>另一个库-有很多库，其中许多库都无法在Webpack演进或React 16中生存-我没有在这里列出它们，但是如果您知道一个不错的候选人-DM我。</em> </li></ul><br><h3 id="which-library-to-pick"> 选择哪个图书馆？ </h3><br><p> 它很容易- <strong>不可加载</strong> -它笨重且<strong>无法</strong>维护，即使它仍然非常流行也是如此。  （再次感谢您推广代码拆分） </p><br><p>  <em>可加载组件</em> -可能是一个很好的选择。 它编写得很好，积极维护并支持所有现成的东西。 支持“完全动态导入”，允许您根据给定的道具导入文件，但无法键入。 支持Suspense，因此可以替换React.lazy。 </p><br><p>  <em>通用组件</em> -实际上是完全动态导入的“发明人”-他们在Webpack中实现了它。 还有许多其他低级别的东西-他们做到了。 我会说-这个库有点硬核，对用户的友好程度也不高。 可加载组件文档无与伦比。 如果不使用该库，那么值得阅读文档，这是值得的-您应该知道很多细节... </p><br><p>  <em>React-imported-component-</em>有点奇怪。 它是独立于捆绑器的，因此它永不中断（没有中断），可以与Webpack 5和55一起使用，但这需要付出一定的代价。 虽然在SSR期间以前的库会将所有使用的脚本添加到页面正文中，但是您将能够并行加载所有脚本-导入的文件名不知道，并且将调用原始的“导入”（这就是为什么捆绑独立的）加载已使用的块，但只能从主捆绑包内部进行调用-因此，所有其他脚本只有在下载并执行主脚本后才能加载。 不支持像React.lazy这样的完全动态导入，因此不支持输入。 还支持暂挂。 在SSR上使用同步<em>对象</em> 。 对于CSS，它也有完全不同的方法，并提供完善的流呈现支持。 </p><br><p> 列出的库之间在质量或受欢迎程度上没有区别，我们都是好朋友-因此，请放心选择。 </p><br><h2 id="grey-zone-3--hybrid-render"> 灰色区域3-混合渲染 </h2><br><p>  SSR是一件好事，但是，很难。 小型项目可能希望拥有SSR-有很多理由拥有它-但他们可能不想设置和维护它。 </p><br><blockquote>  SSR可能真的非常困难。 如果想快速获胜，请尝试razzle或使用Next.js。 </blockquote><p> 因此，我最简单的SSR解决方案（尤其是简单SPA的解决方案）是预渲染。 就像在浏览器中打开SPA并点击“保存”按钮。 像： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">React-snap-</a>使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">puppeteer</a> （又名无头Chrome）在“浏览器”中呈现页面并将结果保存为静态HTML页面。 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Rendertron-</a>执行相同的操作，但以不同的方式（ <em>云</em> ）进行。 </li></ul><br><p> 没有“服务器”的预渲染是“ SSR”。 它是使用客户端的SSR。 魔术！ 开箱即用……但不是为了代码随地吐痰。 <br> 因此，您只是在浏览器中呈现了页面，保存了HTML，并要求加载相同的内容。 但是没有使用服务器端特定代码（收集所有使用的块），因为<strong>没有服务器</strong> ！ </p><br><p><img src="https://habrastorage.org/webt/tr/sz/9i/trsz9i4ct8jc7cnwxtm-ljnepuq.png"></p><br><p> 在上一部分中，我已经指出了与Webpack绑定的库，这些库在收集有关已用块的信息方面完全无法处理混合渲染。 </p><br><blockquote>  react-snap部分支持可加载组件的版本2（与当前版本5不兼容）。 支持已经消失了。 </blockquote><p> 只要没有绑定到bundler /端，react-imported-component就可以处理这种情况，因此对于SSR或Hybrid，只要支持“状态水合作用”，就没有区别，仅对于react-snap，而rendertron则没有。 </p><br><blockquote> 在撰写本文期间发现了react-imported-component的这种功能，以前未知，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">示例</a> 。 这很容易。 </blockquote><p> 在这里，您必须使用另一种解决方案，该解决方案垂直于所有其他库。 </p><br><h3 id="react-prerendered-component">  React组件 </h3><br><p> 该库是为部分水合而创建的，可以对应用程序进行部分水合，其余部分仍保持脱水状态。 它适用于SSR和Hybrid渲染器，没有任何区别。 <br> 这个想法很简单： </p><br><ul><li>  SSR期间-渲染组件，并用&lt;div /&gt;包裹 </li><li> 在客户端上-找到该div，并使用innerHTML，直到Component准备好替换无效的HTML。 </li><li> 您不必加载，并等待一个带有拆分组件的块，然后<code>hydrate</code>以<em>不呈现白洞而不是呈现它</em> -只需使用预渲染的HTML，该HTML绝对等于<em>一个真实组件</em>可以渲染的HTML，并且已经存在-它带有服务器（或液压）响应。 </li></ul><br><blockquote> 这就是为什么我们必须等待所有块加载后才能水化- <strong>匹配</strong>服务器渲染的HTML。 这就是为什么我们可以使用服务器渲染的HTML片段，直到客户端未准备好-它等于我们将要生产的片段。 </blockquote><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> {PrerenderedComponent} <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-prerendered-component'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> importer = memoizeOne(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span>(<span class="hljs-string"><span class="hljs-string">'./Component'</span></span>)); <span class="hljs-comment"><span class="hljs-comment">// ^ it's very important to keep the "one" promise const Component = React.lazy(importer); // or use any other library with ".prefetch" support // all libraries has it (more or less) const App = () =&gt; ( &lt;PrerenderedComponent live={importer()}&gt; {/* ^ shall return the same promise */ } &lt;Component /&gt; {/* ^ would be rendered when a component goes "live" */ } &lt;/PrerenderedComponent&gt; );</span></span></code> </pre> <br><p> 您可以阅读<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">有关该技术的另一篇文章</a> 。 但主要是这里-它以另一种方式解决了“卸载内容的闪烁”，这不是<em>代码拆分库</em>的常见方式。 公开寻求新的解决方案。 </p><br><h3 id="tldr">  TLDR？ </h3><br><ul><li> 不要使用react-loadable，它不会增加任何有价值的价值 </li><li>  React.lazy很好，但是太简单了。 </li><li>  SSR很难，您应该知道 </li><li> 混合木偶驱动的渲染是一回事。 有时甚至更难的事情。 </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN444402/">https://habr.com/ru/post/zh-CN444402/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN444392/index.html">辐射：风险，安全，防护</a></li>
<li><a href="../zh-CN444394/index.html">Linux Foundation与Jenkins和Spinnaker一起启动了新的DevOps项目</a></li>
<li><a href="../zh-CN444396/index.html">爱普生在ISE 2019上的展位-展览已经过去，印象依然</a></li>
<li><a href="../zh-CN444398/index.html">为什么非食品商店需要自助服务组织？</a></li>
<li><a href="../zh-CN444400/index.html">我如何将航班搜索引擎从PHP重写为NodeJS</a></li>
<li><a href="../zh-CN444404/index.html">为什么我们害怕机器人？</a></li>
<li><a href="../zh-CN444406/index.html">数字意大利。 什么以及如何运作</a></li>
<li><a href="../zh-CN444408/index.html">苹果昨天发布了新的iPad，并有疑问。</a></li>
<li><a href="../zh-CN444410/index.html">网络地图。 用于构建网络地图的软件的简要概述</a></li>
<li><a href="../zh-CN444414/index.html">Snapdragon 8cx：7nm PC平台</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>