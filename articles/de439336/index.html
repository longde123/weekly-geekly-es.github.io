<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§±üèª üõåüèº üë©üèº‚Äçüç≥ Wir suchen nach einer Nadel in einem Stapel, ohne bekannte Algorithmen zu verwenden ‚õ©Ô∏è üëµüèº ‚ô®Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Welche Methode zum Auffinden einer Nadel ist schneller? Durch einen Strohhalm sortieren oder versehentlich danach suchen? 

 Ich denke, der beste Weg ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir suchen nach einer Nadel in einem Stapel, ohne bekannte Algorithmen zu verwenden</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439336/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/re/x9/nq/rex9nqzmrtcwxfesouowufue66q.jpeg"></div><br>  Welche Methode zum Auffinden einer <em>Nadel ist</em> schneller?  Durch einen Strohhalm sortieren oder versehentlich danach suchen? <br><br>  Ich denke, der beste Weg ist das Experimentieren. Leider habe ich keinen Heuhaufen, aber ich habe grundlegende Programmierkenntnisse, einen Arduino-Mikrocontroller und eine praktische Umgebung zum Schreiben von Code, sodass jeder ihn wiederholen kann. <br><a name="habracut"></a><br><h4>  Erster Schritt ‚ÄûVerstehen‚Äú </h4><br>  Welche Daten m√∂chte ich erhalten?  Zeitaufwand f√ºr die Suche nach der richtigen L√∂sung.  Die einzige Ausf√ºhrung ist aufgrund der Besonderheiten des Experiments nicht geeignet. Sie m√ºssen die Methode mehrmals √ºberpr√ºfen. Dann ist die Zeit, an der ich interessiert bin, durchschnittlich.  Ich habe mich daf√ºr entschieden.  Der n√§chste Schritt ist, wie viele und welche Variablen deklariert werden sollen.  Wir ben√∂tigen f√ºr jede Methode eine separate Variable, um die Summe der Zeiten zu speichern. Nennen wir sie: <br><br>  "Time_poslMetod" und "Time_randMetod". <br><br>  Ben√∂tigen Sie eine Konstante f√ºr die Anzahl der Iterationen: <br><br>  #define Iter 1000. <br><br>  Der Ausgabewert wird erhalten, indem der erste durch die Anzahl der Iterationen geteilt wird. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Iter 10000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> cell 100 uint8_t potenArr[cell]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  uint8_t needle = 0; //  uint32_t startTime = 0; //    uint32_t endTime = 0; //    uint32_t calculationStartTime = 0; uint32_t calculationEndTime = 0; uint32_t Time_poslMetod = 0; uint32_t Time_randMetod = 0;</span></span></span></span></code> </pre> <br><h4>  Schritt zwei "Code schreiben" </h4><br>  Die For-Schleife verwaltet die Anzahl der Iterationen. In ihr wird die <em>Nadel</em> in den Heuhaufen ‚Äûgeworfen‚Äú, gesucht, die Zeit f√ºr jede Methode separat gemessen und die Zeit in einer ‚Äûglobalen‚Äú Variablen (Time_poslMetod / Time_randMetod) (f√ºr die Zukunft) gespeichert. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//   Iter  for(uint32_t j = 0; j &lt;= Iter; j++){ //      cleanArr(); //     needle = random(cell + 1); potenArr[needle] = 1; //          poslMetod(); randMetod(); }</span></span></code> </pre><br>  So sehen meine Methoden aus. <br><br>  Sequentielle Methode: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poslMetod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ startTime = millis(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cell; i++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(potenArr[i] == <span class="hljs-number"><span class="hljs-number">1</span></span>){ endTime = millis() - startTime; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } Time_poslMetod += endTime; }</code> </pre><br>  Vor dem Beginn merken wir uns die Zeit und subtrahieren sie dann von der Zeit, zu der die Suche endete.  Wir durchlaufen das Array (Stapel) vom ersten bis zum letzten Element.  Wenn wir die <em>Nadel gefunden haben,</em> schreiben Sie die Zeit, schlie√üen Sie die Suche ab, f√ºgen Sie die Zeit der Variablen ‚Äûglobal‚Äú (Time_poslMetod) hinzu und beenden Sie die Methode. <br><br>  Zuf√§llige Methode: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randMetod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ startTime = millis(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;){ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r = random(cell + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(potenArr[r] == <span class="hljs-number"><span class="hljs-number">1</span></span>){ endTime = millis() - startTime; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } Time_randMetod += endTime; }</code> </pre><br>  Der Unterschied besteht darin, dass wir ein zuf√§lliges Element des Arrays (eine Stelle im Stapel) √ºberpr√ºfen, uns auf das Gl√ºck verlassen, bis wir Gl√ºck haben und eine <em>Nadel</em> finden. <em>Daher verwenden</em> wir eine Endlosschleife. Hauptsache, wir haben eine Ausgangsbedingung, sodass wir uns keine Sorgen machen.  Wenn wir die <em>Nadel gefunden haben</em> , notieren Sie die Zeit, schlie√üen Sie die Suche ab, f√ºgen Sie die Zeit der Variablen ‚Äûglobal‚Äú (Time_randMetod) hinzu und beenden Sie die Methode. <br><br>  M√∂glicherweise stellen Sie fest, dass die Methode uns keine Garantie daf√ºr gibt, dass sie schneller ist. Auf diese Weise sieht sie sogar noch langsamer aus. Wenn das Gl√ºck nicht auf unserer Seite ist, k√∂nnen wir m√∂glicherweise mehr als 100 √úberpr√ºfungen der Stapelpl√§tze durchf√ºhren und zu diesem Zeitpunkt fehlschlagen Wie bei einer sequentiellen Methode mit 100 √úberpr√ºfungen w√ºrde dies bedeuten, dass wir den gesamten Stapel √ºberpr√ºft haben und definitiv eine Nadel gefunden h√§tten, die die maximale Zeit f√ºr diese Methode verbringt.  Trotzdem bin ich f√ºr das Experiment, also lasst uns fortfahren. <br><br>  Alles zusammenf√ºgen, den Code polieren und die Ausgabe verst√§ndlich machen: <br><br><div class="spoiler">  <b class="spoiler_title">Gesamter Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Iter 10000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> cell 100 uint8_t potenArr[cell]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  uint8_t needle = 0; // ,         uint32_t startTime = 0; //    uint32_t endTime = 0; //    uint32_t calculationStartTime = 0; uint32_t calculationEndTime = 0; uint32_t Time_poslMetod = 0; uint32_t Time_randMetod = 0; void poslMetod(); void randMetod(); void cleanArr(); void DataOutPrint(); void setup() { randomSeed(analogRead(A0)); Serial.begin(115200); } void loop() { Time_poslMetod = 0; Time_randMetod = 0; Serial.println(" "); Serial.println("Start"); calculationStartTime = millis(); //   Iter  for(uint32_t j = 0; j &lt;= Iter; j++){ //      cleanArr(); //        needle = random(cell + 1); potenArr[needle] = 1; //           poslMetod(); randMetod(); } //       DataOutPrint(); delay(2000); } void poslMetod(){ startTime = millis(); for(uint16_t i = 0; i &lt; cell; i++){ if(potenArr[i] == 1){ endTime = millis() - startTime; break; } } Time_poslMetod += endTime; } void randMetod(){ startTime = millis(); for(;;){ uint16_t r = random(cell + 1); if(potenArr[r] == 1){ endTime = millis() - startTime; break; } } Time_randMetod += endTime; } void cleanArr(){ for(uint16_t i = 0; i &lt; cell; i++){ potenArr[i] = 0; } } void DataOutPrint(){ calculationEndTime = (millis() - calculationStartTime)/1000; float OUTposl = (float)Time_poslMetod/Iter; float OUTrand = (float)Time_randMetod/Iter; Serial.println(" "); Serial.print("Number of iterations = "); Serial.println(Iter); Serial.print("Time for calculate (sec) = "); Serial.println(calculationEndTime); Serial.print("Posledovatelniy metod - AverageTime (ms) = "); Serial.println(OUTposl,3); Serial.print("Randomniy metod - AverageTime (ms) = "); Serial.println(OUTrand,3); }</span></span></span></span></code> </pre><br></div></div><br><h4>  Schritt drei "Ergebnisanalyse" </h4><br>  Wir bekommen: <br><br><img src="https://habrastorage.org/webt/4q/at/vb/4qatvb61ehgttrqdq4qp0q28lxe.jpeg"><br><br>  Ehrlich gesagt bin ich √ºber die Ergebnisse √ºberrascht.  Wenn ich das Geld gewettet h√§tte, dass die Zeiten nahe sein werden, w√ºrde ich verlieren. <br><br>  Genau das, wovor ich Angst hatte, geschah, das Gl√ºck wandte sich von mir (uns) ab.  Das w√§re zu √ºberpr√ºfen, wie es gewesen w√§re, wenn wir, wenn wir jede n√§chste Zelle im Stapel ausgew√§hlt h√§tten, nicht bereits gepr√ºfte ausgew√§hlt h√§tten.  In der Zwischenzeit werden wir bedenken, dass das Studium von Programmierung, Mathematik und exakten Wissenschaften n√ºtzlich ist, um die Zeit f√ºr langweilige Routineoperationen zu verk√ºrzen und Zeit f√ºr etwas Spa√ü zu lassen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439336/">https://habr.com/ru/post/de439336/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439326/index.html">Elektrischer Pickup Ford F-150 EV - im Prototyp und unterwegs getestet</a></li>
<li><a href="../de439328/index.html">Ok Google! Bist du gut oder b√∂se?</a></li>
<li><a href="../de439330/index.html">Erkennung von Zahlen. Wie wir eine Genauigkeit von 97% f√ºr ukrainische Zahlen erhalten haben. Teil 2</a></li>
<li><a href="../de439332/index.html">Funktionsweise von PageRank: Implementierung in R √ºber lineare Algebra und die Potenzmethode</a></li>
<li><a href="../de439334/index.html">Etwa 2 Milliarden Rubel wurden f√ºr die Umsetzung des Gesetzes √ºber nachhaltige Runen bereitgestellt</a></li>
<li><a href="../de439338/index.html">Vergessen Sie die Privatsph√§re: Sie haben immer noch schreckliche Ziele</a></li>
<li><a href="../de439340/index.html">GDPR Backup - Wie das neue Tool hilft</a></li>
<li><a href="../de439342/index.html">DIYorDIE Winter Meetup 17. Februar</a></li>
<li><a href="../de439344/index.html">Wie ein Troll: Wie Monopolisten Patente regieren</a></li>
<li><a href="../de439346/index.html">Laravel + Docker: unsere erfolgreiche Erfahrung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>