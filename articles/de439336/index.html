<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤱🏻 🛌🏼 👩🏼‍🍳 Wir suchen nach einer Nadel in einem Stapel, ohne bekannte Algorithmen zu verwenden ⛩️ 👵🏼 ♨️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Welche Methode zum Auffinden einer Nadel ist schneller? Durch einen Strohhalm sortieren oder versehentlich danach suchen? 

 Ich denke, der beste Weg ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Wir suchen nach einer Nadel in einem Stapel, ohne bekannte Algorithmen zu verwenden</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/439336/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/re/x9/nq/rex9nqzmrtcwxfesouowufue66q.jpeg"></div><br>  Welche Methode zum Auffinden einer <em>Nadel ist</em> schneller?  Durch einen Strohhalm sortieren oder versehentlich danach suchen? <br><br>  Ich denke, der beste Weg ist das Experimentieren. Leider habe ich keinen Heuhaufen, aber ich habe grundlegende Programmierkenntnisse, einen Arduino-Mikrocontroller und eine praktische Umgebung zum Schreiben von Code, sodass jeder ihn wiederholen kann. <br><a name="habracut"></a><br><h4>  Erster Schritt „Verstehen“ </h4><br>  Welche Daten möchte ich erhalten?  Zeitaufwand für die Suche nach der richtigen Lösung.  Die einzige Ausführung ist aufgrund der Besonderheiten des Experiments nicht geeignet. Sie müssen die Methode mehrmals überprüfen. Dann ist die Zeit, an der ich interessiert bin, durchschnittlich.  Ich habe mich dafür entschieden.  Der nächste Schritt ist, wie viele und welche Variablen deklariert werden sollen.  Wir benötigen für jede Methode eine separate Variable, um die Summe der Zeiten zu speichern. Nennen wir sie: <br><br>  "Time_poslMetod" und "Time_randMetod". <br><br>  Benötigen Sie eine Konstante für die Anzahl der Iterationen: <br><br>  #define Iter 1000. <br><br>  Der Ausgabewert wird erhalten, indem der erste durch die Anzahl der Iterationen geteilt wird. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Iter 10000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> cell 100 uint8_t potenArr[cell]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  uint8_t needle = 0; //  uint32_t startTime = 0; //    uint32_t endTime = 0; //    uint32_t calculationStartTime = 0; uint32_t calculationEndTime = 0; uint32_t Time_poslMetod = 0; uint32_t Time_randMetod = 0;</span></span></span></span></code> </pre> <br><h4>  Schritt zwei "Code schreiben" </h4><br>  Die For-Schleife verwaltet die Anzahl der Iterationen. In ihr wird die <em>Nadel</em> in den Heuhaufen „geworfen“, gesucht, die Zeit für jede Methode separat gemessen und die Zeit in einer „globalen“ Variablen (Time_poslMetod / Time_randMetod) (für die Zukunft) gespeichert. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">//   Iter  for(uint32_t j = 0; j &lt;= Iter; j++){ //      cleanArr(); //     needle = random(cell + 1); potenArr[needle] = 1; //          poslMetod(); randMetod(); }</span></span></code> </pre><br>  So sehen meine Methoden aus. <br><br>  Sequentielle Methode: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">poslMetod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ startTime = millis(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; cell; i++){ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(potenArr[i] == <span class="hljs-number"><span class="hljs-number">1</span></span>){ endTime = millis() - startTime; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } Time_poslMetod += endTime; }</code> </pre><br>  Vor dem Beginn merken wir uns die Zeit und subtrahieren sie dann von der Zeit, zu der die Suche endete.  Wir durchlaufen das Array (Stapel) vom ersten bis zum letzten Element.  Wenn wir die <em>Nadel gefunden haben,</em> schreiben Sie die Zeit, schließen Sie die Suche ab, fügen Sie die Zeit der Variablen „global“ (Time_poslMetod) hinzu und beenden Sie die Methode. <br><br>  Zufällige Methode: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randMetod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ startTime = millis(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(;;){ <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> r = random(cell + <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(potenArr[r] == <span class="hljs-number"><span class="hljs-number">1</span></span>){ endTime = millis() - startTime; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } Time_randMetod += endTime; }</code> </pre><br>  Der Unterschied besteht darin, dass wir ein zufälliges Element des Arrays (eine Stelle im Stapel) überprüfen, uns auf das Glück verlassen, bis wir Glück haben und eine <em>Nadel</em> finden. <em>Daher verwenden</em> wir eine Endlosschleife. Hauptsache, wir haben eine Ausgangsbedingung, sodass wir uns keine Sorgen machen.  Wenn wir die <em>Nadel gefunden haben</em> , notieren Sie die Zeit, schließen Sie die Suche ab, fügen Sie die Zeit der Variablen „global“ (Time_randMetod) hinzu und beenden Sie die Methode. <br><br>  Möglicherweise stellen Sie fest, dass die Methode uns keine Garantie dafür gibt, dass sie schneller ist. Auf diese Weise sieht sie sogar noch langsamer aus. Wenn das Glück nicht auf unserer Seite ist, können wir möglicherweise mehr als 100 Überprüfungen der Stapelplätze durchführen und zu diesem Zeitpunkt fehlschlagen Wie bei einer sequentiellen Methode mit 100 Überprüfungen würde dies bedeuten, dass wir den gesamten Stapel überprüft haben und definitiv eine Nadel gefunden hätten, die die maximale Zeit für diese Methode verbringt.  Trotzdem bin ich für das Experiment, also lasst uns fortfahren. <br><br>  Alles zusammenfügen, den Code polieren und die Ausgabe verständlich machen: <br><br><div class="spoiler">  <b class="spoiler_title">Gesamter Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> Iter 10000 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> cell 100 uint8_t potenArr[cell]; </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//  uint8_t needle = 0; // ,         uint32_t startTime = 0; //    uint32_t endTime = 0; //    uint32_t calculationStartTime = 0; uint32_t calculationEndTime = 0; uint32_t Time_poslMetod = 0; uint32_t Time_randMetod = 0; void poslMetod(); void randMetod(); void cleanArr(); void DataOutPrint(); void setup() { randomSeed(analogRead(A0)); Serial.begin(115200); } void loop() { Time_poslMetod = 0; Time_randMetod = 0; Serial.println(" "); Serial.println("Start"); calculationStartTime = millis(); //   Iter  for(uint32_t j = 0; j &lt;= Iter; j++){ //      cleanArr(); //        needle = random(cell + 1); potenArr[needle] = 1; //           poslMetod(); randMetod(); } //       DataOutPrint(); delay(2000); } void poslMetod(){ startTime = millis(); for(uint16_t i = 0; i &lt; cell; i++){ if(potenArr[i] == 1){ endTime = millis() - startTime; break; } } Time_poslMetod += endTime; } void randMetod(){ startTime = millis(); for(;;){ uint16_t r = random(cell + 1); if(potenArr[r] == 1){ endTime = millis() - startTime; break; } } Time_randMetod += endTime; } void cleanArr(){ for(uint16_t i = 0; i &lt; cell; i++){ potenArr[i] = 0; } } void DataOutPrint(){ calculationEndTime = (millis() - calculationStartTime)/1000; float OUTposl = (float)Time_poslMetod/Iter; float OUTrand = (float)Time_randMetod/Iter; Serial.println(" "); Serial.print("Number of iterations = "); Serial.println(Iter); Serial.print("Time for calculate (sec) = "); Serial.println(calculationEndTime); Serial.print("Posledovatelniy metod - AverageTime (ms) = "); Serial.println(OUTposl,3); Serial.print("Randomniy metod - AverageTime (ms) = "); Serial.println(OUTrand,3); }</span></span></span></span></code> </pre><br></div></div><br><h4>  Schritt drei "Ergebnisanalyse" </h4><br>  Wir bekommen: <br><br><img src="https://habrastorage.org/webt/4q/at/vb/4qatvb61ehgttrqdq4qp0q28lxe.jpeg"><br><br>  Ehrlich gesagt bin ich über die Ergebnisse überrascht.  Wenn ich das Geld gewettet hätte, dass die Zeiten nahe sein werden, würde ich verlieren. <br><br>  Genau das, wovor ich Angst hatte, geschah, das Glück wandte sich von mir (uns) ab.  Das wäre zu überprüfen, wie es gewesen wäre, wenn wir, wenn wir jede nächste Zelle im Stapel ausgewählt hätten, nicht bereits geprüfte ausgewählt hätten.  In der Zwischenzeit werden wir bedenken, dass das Studium von Programmierung, Mathematik und exakten Wissenschaften nützlich ist, um die Zeit für langweilige Routineoperationen zu verkürzen und Zeit für etwas Spaß zu lassen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de439336/">https://habr.com/ru/post/de439336/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de439326/index.html">Elektrischer Pickup Ford F-150 EV - im Prototyp und unterwegs getestet</a></li>
<li><a href="../de439328/index.html">Ok Google! Bist du gut oder böse?</a></li>
<li><a href="../de439330/index.html">Erkennung von Zahlen. Wie wir eine Genauigkeit von 97% für ukrainische Zahlen erhalten haben. Teil 2</a></li>
<li><a href="../de439332/index.html">Funktionsweise von PageRank: Implementierung in R über lineare Algebra und die Potenzmethode</a></li>
<li><a href="../de439334/index.html">Etwa 2 Milliarden Rubel wurden für die Umsetzung des Gesetzes über nachhaltige Runen bereitgestellt</a></li>
<li><a href="../de439338/index.html">Vergessen Sie die Privatsphäre: Sie haben immer noch schreckliche Ziele</a></li>
<li><a href="../de439340/index.html">GDPR Backup - Wie das neue Tool hilft</a></li>
<li><a href="../de439342/index.html">DIYorDIE Winter Meetup 17. Februar</a></li>
<li><a href="../de439344/index.html">Wie ein Troll: Wie Monopolisten Patente regieren</a></li>
<li><a href="../de439346/index.html">Laravel + Docker: unsere erfolgreiche Erfahrung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>