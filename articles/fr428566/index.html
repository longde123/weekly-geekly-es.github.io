<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçüöí üêì üßòüèæ Fonctions fl√®ches JavaScript: pourquoi elles sont n√©cessaires, comment les g√©rer, quand les utiliser et quand elles ne le sont pas ü§õüèª üç± üëÜ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'une des innovations les plus notables du JavaScript moderne est l'apparition de fonctions fl√©ch√©es, parfois appel√©es fonctions fl√©ch√©es ¬´grasses¬ª. L...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Fonctions fl√®ches JavaScript: pourquoi elles sont n√©cessaires, comment les g√©rer, quand les utiliser et quand elles ne le sont pas</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/428566/"> L'une des innovations les plus notables du JavaScript moderne est l'apparition de fonctions fl√©ch√©es, parfois appel√©es fonctions fl√©ch√©es ¬´grasses¬ª.  Lors de la d√©claration de telles fonctions, ils utilisent une combinaison sp√©ciale de caract√®res - <code>=&gt;</code> . <br><br>  Les fonctions fl√©ch√©es ont deux avantages principaux par rapport aux fonctions traditionnelles.  Le premier est une syntaxe tr√®s pratique et compacte.  La seconde est que l'approche √† utiliser avec <code>this</code> dans les fonctions fl√©ch√©es semble plus intuitive que dans les fonctions ordinaires. <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/b1a/09a/721/b1a09a721fe985d3700f4f74305e68d6.jpg" alt="image"></a> </div><br>  Parfois, ces avantages et d'autres conduisent au fait que la syntaxe des fl√®ches a une pr√©f√©rence inconditionnelle par rapport √† d'autres fa√ßons de d√©clarer des fonctions.  Par exemple, la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">configuration eslint</a> populaire d'Airbnb oblige chaque fois qu'une fonction anonyme est cr√©√©e, une telle fonction serait en forme de fl√®che. <br><br>  Cependant, comme d'autres concepts et m√©canismes utilis√©s dans la programmation, les fonctions fl√©ch√©es ont leurs avantages et leurs inconv√©nients.  Leur utilisation peut provoquer des effets secondaires n√©gatifs.  Pour utiliser correctement les fonctions fl√©ch√©es, vous devez conna√Ætre les √©ventuels probl√®mes qui leur sont associ√©s. <br><br>  Le mat√©riel, dont nous publions la traduction aujourd'hui, se concentrera sur le fonctionnement des fonctions fl√©ch√©es.  Nous consid√©rerons ici les situations dans lesquelles leur utilisation peut am√©liorer le code et les situations dans lesquelles elles ne devraient pas √™tre utilis√©es. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Comprend des fonctions fl√©ch√©es en JavaScript</font> </h2><br>  Les fonctions fl√©ch√©es en JavaScript sont quelque chose comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les fonctions lambda</a> en Python et les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">blocs</a> en Ruby. <br><br>  Ce sont des fonctions anonymes avec une syntaxe sp√©ciale qui prennent un nombre fixe d'arguments et fonctionnent dans le contexte de la port√©e qui les inclut, c'est-√†-dire dans le contexte de la fonction ou d'un autre code dans lequel elles sont d√©clar√©es. <br><br>  Parlons de cela plus en d√©tail. <br><br><h3>  <font color="#3AC1EF">‚ñç Fonctions fl√®ches de syntaxe</font> </h3><br>  Les fonctions fl√©ch√©es sont construites selon un sch√©ma unique, tandis que la structure des fonctions peut √™tre, dans des cas particuliers, simplifi√©e.  La structure de base de la fonction fl√®che ressemble √† ceci: <br><br><pre> <code class="hljs php">(argument1, argument2, ... argumentN) =&gt; { <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre> <br>  La liste des arguments de la fonction est entre parenth√®ses, suivie d'une fl√®che compos√©e de caract√®res <code>=</code> et <code>&gt;</code> , puis vient le corps de la fonction entre accolades. <br><br>  Ceci est tr√®s similaire au fonctionnement des fonctions ordinaires, les principales diff√©rences sont que le mot-cl√© <code>function</code> est omis ici et une fl√®che est ajout√©e apr√®s la liste des arguments. <br><br>  Dans certains cas, cependant, les fonctions fl√®ches simples peuvent √™tre d√©clar√©es en utilisant des constructions beaucoup plus compactes. <br><br>  Consid√©rez la syntaxe utilis√©e si le corps de la fonction est repr√©sent√© par une seule expression.  Il vous permet de vous passer de crochets qui encadrent le corps de la fonction et √©limine la n√©cessit√© de renvoyer explicitement les r√©sultats de l'√©valuation d'une expression, car ce r√©sultat sera renvoy√© automatiquement.  Par exemple, cela pourrait ressembler √† ceci: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> add = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">a, b</span></span></span><span class="hljs-function">) =&gt;</span></span> a + b;</code> </pre> <br>  Voici une autre variante de la notation abr√©g√©e de la fonction, utilis√©e lorsque la fonction n'a qu'un seul argument. <br><br><pre> <code class="hljs php"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getFirst = <span class="hljs-keyword"><span class="hljs-keyword">array</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">array</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>];</code> </pre> <br>  Comme vous pouvez le voir, les parenth√®ses entourant la liste d'arguments sont omises ici.  De plus, le corps de la fonction, qui dans cet exemple est repr√©sent√© par une seule commande, est √©galement √©crit sans crochets.  Plus tard, nous parlerons davantage des avantages de ces conceptions. <br><br><h3>  <font color="#3AC1EF">‚ñçRetourner les objets et les fonctions de fl√®che d'enregistrement court</font> </h3><br>  Lorsque vous travaillez avec des fonctions fl√©ch√©es, certaines constructions de syntaxe plus complexes sont √©galement utilis√©es, qui sont utiles √† conna√Ætre. <br><br>  Par exemple, essayez d'utiliser une expression sur une seule ligne pour revenir d'une fonction litt√©rale d'objet.  Il peut sembler, √©tant donn√© ce que nous savons d√©j√† sur les fonctions fl√©ch√©es, qu'une d√©claration de fonction ressemblera √† ceci: <br><br><pre> <code class="hljs pgsql">(<span class="hljs-type"><span class="hljs-type">name</span></span>, description) =&gt; {<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-type"><span class="hljs-type">name</span></span>, description: description};</code> </pre> <br>  Le probl√®me avec ce code est son ambigu√Øt√©.  √Ä savoir, les accolades que nous voulons utiliser pour d√©crire le litt√©ral de l'objet ressemblent √† ce que nous essayons d'y enfermer le corps d'une fonction. <br><br>  Afin d'indiquer au syst√®me que nous entendons l'objet litt√©ral, nous devons le mettre entre parenth√®ses: <br><br><pre> <code class="hljs pgsql">(<span class="hljs-type"><span class="hljs-type">name</span></span>, description) =&gt; ({<span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-type"><span class="hljs-type">name</span></span>, description: description});</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Fonctions fl√©ch√©es et leur contexte d'ex√©cution</font> </h3><br>  Contrairement aux autres fonctions, les fonctions fl√©ch√©es n'ont pas leur propre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">contexte d'ex√©cution</a> . <br><br>  En pratique, cela signifie qu'ils h√©ritent des entit√©s <code>this</code> et des <code>arguments</code> de la fonction parent. <br><br>  Par exemple, comparez les deux fonctions pr√©sent√©es dans le code suivant.  L'un d'eux est ordinaire, le second est une fl√®che. <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> test = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'test object'</span></span>, <span class="hljs-attr"><span class="hljs-attr">createAnonFunction</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name);     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>);   }; }, <span class="hljs-attr"><span class="hljs-attr">createArrowFunction</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name);     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>);   }; } };</code> </pre> <br>  Il existe un objet de <code>test</code> avec deux m√©thodes.  Chacun d'eux est une fonction qui cr√©e et renvoie une fonction anonyme.  La diff√©rence entre ces m√©thodes est seulement que dans la premi√®re d'entre elles, l'expression fonctionnelle traditionnelle est utilis√©e et dans la fonction de la deuxi√®me fl√®che. <br><br>  Si nous exp√©rimentons ce code dans la console, en passant les m√™mes arguments aux m√©thodes de l'objet, alors bien que les m√©thodes semblent tr√®s similaires, nous obtiendrons des r√©sultats diff√©rents: <br><br><pre> <code class="hljs cs">&gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anon = test.createAnonFunction(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>, <span class="hljs-string"><span class="hljs-string">'world'</span></span>); &gt; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> arrow = test.createArrowFunction(<span class="hljs-string"><span class="hljs-string">'hello'</span></span>, <span class="hljs-string"><span class="hljs-string">'world'</span></span>); &gt; anon(); undefined {} &gt; arrow(); test <span class="hljs-keyword"><span class="hljs-keyword">object</span></span> { <span class="hljs-string"><span class="hljs-string">'0'</span></span>: <span class="hljs-string"><span class="hljs-string">'hello'</span></span>, <span class="hljs-string"><span class="hljs-string">'1'</span></span>: <span class="hljs-string"><span class="hljs-string">'world'</span></span> }</code> </pre> <br>  Une fonction anonyme a son propre contexte, donc lorsqu'elle est appel√©e, lorsque vous appelez <code>test.name</code> , la valeur de la propri√©t√© <code>name</code> de l'objet ne sera pas <code>test.name</code> , et lorsque vous appelez des <code>arguments</code> , la liste des arguments de la fonction qui a √©t√© utilis√©e pour cr√©er et renvoyer la fonction sous enqu√™te ne sera pas affich√©e. <br><br>  Dans le cas d'une fonction fl√®che, il s'av√®re que son contexte co√Øncide avec le contexte de la fonction qui l'a cr√©√©e, ce qui lui donne acc√®s √† la fois √† la liste des arguments pass√©s par cette fonction et √† la propri√©t√© <code>name</code> de l'objet dont la m√©thode est cette fonction. <br><br><h2>  <font color="#3AC1EF">Situations dans lesquelles les fonctions fl√©ch√©es am√©liorent le code</font> </h2><br><h3>  <font color="#3AC1EF">‚ñçTraitement des listes de valeurs</font> </h3><br>  Les fonctions lambda traditionnelles, ainsi que les fonctions fl√©ch√©es, apr√®s leur apparition en JavaScript, sont g√©n√©ralement utilis√©es dans les situations o√π une certaine fonction est appliqu√©e √† chaque √©l√©ment d'une certaine liste. <br><br>  Par exemple, s'il existe un tableau de valeurs qui doit √™tre converti √† l'aide de la m√©thode des tableaux de <code>map</code> , une fonction de fl√®che est id√©ale pour d√©crire une telle conversion: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> words = [<span class="hljs-string"><span class="hljs-string">'hello'</span></span>, <span class="hljs-string"><span class="hljs-string">'WORLD'</span></span>, <span class="hljs-string"><span class="hljs-string">'Whatever'</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> downcasedWords = words.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">word</span></span></span><span class="hljs-function"> =&gt;</span></span> word.toLowerCase());</code> </pre> <br>  Voici un exemple extr√™mement courant d'utilisation similaire des fonctions fl√©ch√©es, qui consiste √† travailler avec les propri√©t√©s des objets: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> names = objects.map(<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">object</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">name</span></span>);</code> </pre> <br>  De m√™me, si au lieu des boucles <code>for</code> traditionnelles, ils utilisent des boucles <code>forEach</code> modernes bas√©es sur un <code>forEach</code> , alors les fonctions fl√©ch√©es utilisent <code>this</code> entit√© parent, rend leur utilisation intuitive: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.examples.forEach(example =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.runExample(example); });</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Promesses et cha√Ænes de promesses</font> </h3><br>  Une autre situation o√π les fonctions fl√©ch√©es vous permettent d'√©crire du code plus propre et plus compr√©hensible est repr√©sent√©e par des constructions logicielles asynchrones. <br><br>  Ainsi, les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">promesses</a> simplifient consid√©rablement le travail avec du code asynchrone.  Dans le m√™me temps, m√™me si vous pr√©f√©rez utiliser la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">construction</a> async / wait <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">,</a> vous ne pouvez pas vous passer de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">comprendre les promesses</a> , car cette construction est bas√©e sur elles. <br><br>  Cependant, lorsque vous utilisez des promesses, vous devez d√©clarer des fonctions qui sont appel√©es apr√®s la fin du code asynchrone ou la fin de l'appel asynchrone √† une API. <br><br>  C'est un endroit id√©al pour utiliser les fonctions fl√©ch√©es, surtout si la fonction r√©sultante a un certain √©tat, se r√©f√®re √† quelque chose dans l'objet.  Par exemple, cela pourrait ressembler √† ceci: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.doSomethingAsync().<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(result)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.storeResult(result); });</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Transformation d'objet</font> </h3><br>  Un autre cas d'utilisation courant pour les fonctions fl√©ch√©es consiste √† encapsuler des transformations d'objets. <br><br>  Par exemple, dans Vue.js, il existe un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mod√®le</a> commun <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pour</a> inclure des fragments de stockage Vuex directement dans un composant Vue √† l'aide de <code>mapState</code> . <br><br>  Cette op√©ration comprend les d√©clarations d'un ensemble de ¬´convertisseurs¬ª qui s√©lectionnent exactement ce qui est n√©cessaire pour un composant particulier √† partir de l'√©tat complet initial. <br><br>  Ces transformations simples sont l'endroit id√©al pour utiliser les fonctions fl√©ch√©es.  Par exemple: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">export</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">default</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">computed</span></span>: {   ...<span class="hljs-built_in"><span class="hljs-built_in">mapState</span></span>({     results: state =&gt; state.results,     users: state =&gt; state.users,   }); } }</code> </pre> <br><h2>  <font color="#3AC1EF">Situations dans lesquelles les fonctions fl√©ch√©es ne doivent pas √™tre utilis√©es</font> </h2><br><h3>  <font color="#3AC1EF">‚ñç M√©thodes d'objet</font> </h3><br>  Il existe un certain nombre de situations dans lesquelles l'utilisation des fonctions fl√©ch√©es n'est pas une bonne id√©e.  Les fonctions fl√©ch√©es, si elles sont utilis√©es √† la l√©g√®re, non seulement n'aident pas les programmeurs, mais deviennent √©galement une source de probl√®mes. <br><br>  La premi√®re de ces situations consiste √† utiliser les fonctions fl√©ch√©es comme m√©thodes d'objet.  Le contexte d'ex√©cution et le <code>this</code> , sp√©cifique aux fonctions traditionnelles, sont ici importants. <br><br>  √Ä une certaine √©poque, il √©tait courant d'utiliser une combinaison de propri√©t√©s de classe et de fonctions fl√©ch√©es pour cr√©er des m√©thodes avec ¬´liaison automatique¬ª, c'est-√†-dire celles qui peuvent √™tre utilis√©es par les gestionnaires d'√©v√©nements, mais qui restent li√©es √† la classe.  Cela ressemblait √† ceci: <br><br><pre> <code class="hljs javascript"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Counter</span></span></span><span class="hljs-class"> </span></span>{ counter = <span class="hljs-number"><span class="hljs-number">0</span></span>; handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.counter++; } }</code> </pre> <br>  En utilisant une construction similaire, m√™me si la fonction <code>handleClick</code> appel√©e par le gestionnaire d'√©v√©nements, et non dans le contexte d'une instance de la classe <code>Counter</code> , cette fonction avait acc√®s aux donn√©es de cette instance. <br><br>  Cependant, cette approche pr√©sente de nombreux inconv√©nients auxquels <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce mat√©riel est</a> consacr√©. <br><br>  Bien que l'utilisation d'une fonction fl√®che ici, bien s√ªr, soit un moyen pratique de lier une fonction, le comportement de cette fonction est loin d'√™tre intuitif √† bien des √©gards, g√™nant les tests et cr√©ant des probl√®mes dans des situations o√π, par exemple, ils essaient d'utiliser l'objet correspondant comme prototype. <br><br>  Dans de tels cas, au lieu des fonctions fl√©ch√©es, utilisez des fonctions ordinaires et, si n√©cessaire, liez-leur une instance de l'objet dans le constructeur: <br><br><pre> <code class="hljs delphi"><span class="hljs-keyword"><span class="hljs-keyword">class</span></span> Counter <span class="hljs-comment"><span class="hljs-comment">{ counter = 0; handleClick() {   this.counter++; }</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">constructor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">{   this.handleClick = this.handleClick.bind(this); }</span></span></span><span class="hljs-function"> }</span></span></code> </pre> <br><h3>  <font color="#3AC1EF">Chains Longues cha√Ænes d'appel</font> </h3><br>  Les fonctions fl√©ch√©es peuvent devenir une source de probl√®mes si elles sont pr√©vues pour √™tre utilis√©es dans de nombreuses combinaisons diff√©rentes, en particulier, dans de longues cha√Ænes d'appels de fonctions. <br><br>  La principale raison de ces probl√®mes, comme lors de l'utilisation de fonctions anonymes, est qu'ils donnent des r√©sultats extr√™mement peu informatifs de la trace de la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pile d'appels</a> . <br><br>  Ce n'est pas si mal si, par exemple, il n'y a qu'un seul niveau d'imbrication des appels de fonction, disons, si nous parlons de la fonction utilis√©e dans l'it√©rateur.  Cependant, si toutes les fonctions utilis√©es sont d√©clar√©es comme des fonctions fl√©ch√©es et que ces fonctions s'appellent les unes les autres, alors si une erreur se produit, il ne sera pas facile de comprendre ce qui se passe.  Les messages d'erreur ressembleront √† ceci: <br><br><pre> <code class="hljs">{anonymous}() {anonymous}() {anonymous}() {anonymous}() {anonymous}()</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Fonctions avec contexte dynamique</font> </h3><br>  La derni√®re des situations dont nous discutons dans lesquelles les fonctions fl√©ch√©es peuvent devenir une source de probl√®mes est de les utiliser l√† o√π vous avez besoin d'une dynamique de <code>this</code> liaison. <br><br>  Si des fonctions fl√©ch√©es sont utilis√©es dans de telles situations, la dynamique de <code>this</code> liaison ne fonctionnera pas.  Cette surprise d√©sagr√©able peut amener √† r√©fl√©chir aux raisons de ce qui arrive √† ceux qui doivent travailler avec du code dans lequel les fonctions fl√©ch√©es sont utilis√©es de mani√®re incorrecte. <br><br>  Voici quelques √©l√©ments √† garder √† l'esprit lorsque vous envisagez d'utiliser les fonctions fl√©ch√©es: <br><br><ul><li>  Les gestionnaires d'√©v√©nements sont appel√©s avec <code>this</code> li√© √† l' <code>currentTarget</code> √©v√©nement <code>currentTarget</code> . </li><li>  Si vous utilisez toujours jQuery, consid√©rez que la plupart des m√©thodes jQuery le lient √† l'√©l√©ment DOM s√©lectionn√©. </li><li>  Si vous utilisez Vue.js, les m√©thodes et les fonctions calcul√©es le lient g√©n√©ralement au composant Vue. </li></ul><br>  Bien entendu, les fonctions fl√©ch√©es peuvent √™tre utilis√©es intentionnellement afin de modifier le comportement standard des m√©canismes logiciels.  Mais, en particulier dans les cas avec jQuery et Vue, cela entre souvent en conflit avec le fonctionnement normal du syst√®me, ce qui conduit au fait que le programmeur ne peut pas comprendre pourquoi un code qui semble compl√®tement normal refuse soudainement de fonctionner. <br><br><h2>  <font color="#3AC1EF">R√©sum√©</font> </h2><br>  Les fonctions fl√©ch√©es sont une merveilleuse nouvelle fonctionnalit√© JavaScript.  Ils permettent, dans de nombreuses situations, d'√©crire du code plus pratique qu'auparavant.  Mais, comme c'est le cas avec d'autres fonctionnalit√©s, elles pr√©sentent √† la fois des avantages et des inconv√©nients.  Par cons√©quent, vous devez utiliser les fonctions fl√©ch√©es l√† o√π elles peuvent √™tre utiles, sans les consid√©rer comme un remplacement complet des fonctions ordinaires. <br><br>  <b>Chers lecteurs!</b>  Avez-vous rencontr√© des situations dans lesquelles l'utilisation des fonctions fl√©ch√©es entra√Æne des erreurs, des d√©sagr√©ments ou un comportement inattendu des programmes? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr428566/">https://habr.com/ru/post/fr428566/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr428556/index.html">¬´L'environnement de production est hors de votre contr√¥le¬ª: Rian Lewis sur les tests de projets de blockchain</a></li>
<li><a href="../fr428558/index.html">Comment j'ai cr√©√© un assistant pour WordPress √† partir de ma profonde paresse</a></li>
<li><a href="../fr428560/index.html">Annonce impr√©vue de vendredi</a></li>
<li><a href="../fr428562/index.html">Droidcon Londres. Comment c'√©tait</a></li>
<li><a href="../fr428564/index.html">Recherche MapKit: Trucs et astuces</a></li>
<li><a href="../fr428568/index.html">Guide de d√©veloppement d'applications Web natives React</a></li>
<li><a href="../fr428570/index.html">Fonctions d'ordre sup√©rieur en JavaScript</a></li>
<li><a href="../fr428572/index.html">Composants d'ordre sup√©rieur dans React</a></li>
<li><a href="../fr428574/index.html">Faites passer la communication d'entreprise au niveau sup√©rieur avec Zextras Chat</a></li>
<li><a href="../fr428576/index.html">[signet] Version PDF du tutoriel Node.js et nouveau guide JavaScript</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>