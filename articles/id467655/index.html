<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§“ğŸ¾ ğŸ‘°ğŸ¾ ğŸ‘Š Bagaimana saya menghabiskan musim panas dengan C # 8 ğŸ–ğŸ¿ ğŸš ğŸ•ºğŸ¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dalam rilis terbaru podcast DotNet & More Blazor, NetCore 3.0 Preview, C # 8 dan tidak hanya kami hanya dengan santai menyebutkan topik yang membakar ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana saya menghabiskan musim panas dengan C # 8</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467655/"><p>  Dalam rilis terbaru <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">podcast</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">DotNet &amp; More</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Blazor, NetCore 3.0 Preview, C # 8 dan tidak hanya</a> kami hanya dengan santai menyebutkan topik yang membakar seperti C # 8.  Kisah tentang pengalaman dengan C # 8 tidak cukup besar untuk mencurahkan masalah terpisah untuk itu, jadi diputuskan untuk berbagi cara genre epistolary dengannya. </p><br><p>  Pada artikel ini, saya ingin berbicara tentang pengalaman saya menggunakan C # 8 pada produksi selama 4 bulan.  Di bawah ini Anda dapat menemukan jawaban untuk pertanyaan-pertanyaan berikut: </p><br><ul><li>  Cara "mengeja" di C # baru </li><li>  Fitur apa yang benar-benar bermanfaat </li><li>  Sangat kecewa </li></ul><a name="habracut"></a><br><p>  Daftar lengkap fitur C # 8 dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi resmi dari Microsoft</a> .  Dalam artikel ini, saya akan menghilangkan peluang yang tidak bisa saya coba karena satu dan lain alasan, yaitu: </p><br><ul><li>  Anggota yang hanya baca </li><li>  Anggota antarmuka default </li><li>  Struct ref sekali pakai </li><li>  Aliran asinkron </li><li>  Indeks dan rentang </li></ul><br><p>  Saya mengusulkan untuk memulai dengan salah satu kemungkinan yang paling lezat, seperti yang tampak bagi saya sebelumnya. </p><br><h3 id="switch-expressions">  Alihkan ekspresi </h3><br><p> Dalam mimpi kami, kami menyajikan fungsi ini dengan sangat cerah: </p><br><pre><code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Exec</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Operation operation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> =&gt; operation <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> { Operation.Summ =&gt; x + y, Operation.Diff =&gt; x - y, Operation.Mult =&gt; x * y, Operation.Div =&gt; x / y, _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotSupportedException() };</code> </pre> <br><p>  Namun, sayangnya, kenyataan membuat penyesuaiannya sendiri. <br>  Pertama, tidak ada kemungkinan menggabungkan kondisi: </p><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TrafficLights</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Signal signal</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (signal) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Signal.Red: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Signal.Yellow: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"stop"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Signal.Green: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"go"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotSupportedException(); } }</code> </pre> <br><p>  Dalam praktiknya, ini berarti bahwa dalam setengah kasus, ekspresi sakelar harus diubah menjadi sakelar biasa untuk menghindari copy-paste. </p><br><p>  Kedua, sintaks baru tidak mendukung pernyataan, mis.  kode yang tidak mengembalikan nilai.  Tampaknya, well, dan itu tidak perlu, tetapi saya sendiri terkejut ketika saya menyadari betapa seringnya saklar digunakan (dalam hubungannya dengan pencocokan pola) untuk hal seperti pernyataan dalam tes. </p><br><p>  Ketiga, beralih ekspresi, yang mengikuti dari paragraf terakhir, tidak mendukung penangan multi-line.  Betapa menakutkannya kami memahami pada saat menambahkan log: </p><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ExecFull</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Operation operation, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> x, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> y</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (operation) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Operation.Summ: logger.LogTrace(<span class="hljs-string"><span class="hljs-string">"{x} + {y}"</span></span>, x, y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Operation.Diff: logger.LogTrace(<span class="hljs-string"><span class="hljs-string">"{x} - {y}"</span></span>, x, y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x - y; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Operation.Mult: logger.LogTrace(<span class="hljs-string"><span class="hljs-string">"{x} * {y}"</span></span>, x, y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x * y; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> Operation.Div: logger.LogTrace(<span class="hljs-string"><span class="hljs-string">"{x} / {y}"</span></span>, x, y); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x / y; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotSupportedException(); } }</code> </pre> <br><p>  Saya tidak ingin mengatakan bahwa saklar baru itu buruk.  Tidak, dia baik, hanya saja tidak cukup baik. </p><br><h3 id="property--positional-patterns">  Pola Properti &amp; Posisi </h3><br><p>  Setahun yang lalu, bagi saya mereka tampak sebagai kandidat utama untuk gelar "peluang yang mengubah pembangunan."  Dan, seperti yang diharapkan, untuk menggunakan kekuatan penuh dari pola posisi dan properti, Anda perlu mengubah pendekatan Anda terhadap pengembangan.  Yaitu, perlu untuk meniru tipe data aljabar. <br>  Tampaknya, apa masalahnya: ambil antarmuka penanda dan pergi.  Sayangnya, metode ini memiliki kelemahan serius dalam proyek besar: tidak ada yang menjamin pelacakan dalam waktu desain perluasan tipe aljabar Anda.  Jadi, sangat mungkin bahwa seiring waktu, perubahan kode akan menyebabkan banyak "kegagalan secara default" di tempat-tempat yang paling tidak terduga. </p><br><h3 id="tuple-patterns">  Pola Tuple </h3><br><p>  Tetapi "adik laki-laki" dari kemungkinan perbandingan yang baru dengan sampel terbukti benar-benar dilakukan dengan baik.  Masalahnya adalah bahwa pola tuple tidak memerlukan perubahan apa pun dalam arsitektur kode kita yang sudah dikenal, itu hanya menyederhanakan beberapa kasus: </p><br><pre> <code class="cs hljs"> Player? Play(Gesture left, Gesture right) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (left, right) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Rock, Gesture.Rock): <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Paper, Gesture.Paper): <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Scissors, Gesture.Scissors): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Rock, Gesture.Scissors): <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Scissors, Gesture.Paper): <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Paper, Gesture.Rock): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Player.Left; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Paper, Gesture.Scissors): <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Rock, Gesture.Paper): <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> (Gesture.Scissors, Gesture.Rock): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Player.Right; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> NotSupportedException(); } }</code> </pre> <br><p>  Tetapi bagian terbaiknya adalah bahwa fitur ini, yang cukup dapat diprediksi, berfungsi baik dengan metode Dekonstruksi.  Cukup lewati kelas dengan Deconstruct yang diimplementasikan untuk beralih dan menggunakan kemampuan pola tuple. </p><br><h3 id="using-declarations">  Menggunakan deklarasi </h3><br><p>  Tampaknya ini peluang kecil, tetapi membawa banyak kegembiraan.  Dalam semua promo, Microsoft berbicara tentang aspek seperti mengurangi bersarang.  Tapi mari kita jujur, tidak terlalu penting.  Tetapi yang benar-benar serius adalah efek samping dari mengecualikan satu blok kode: </p><br><ul><li>  Seringkali, ketika menambahkan menggunakan, kita harus menarik kode "di dalam" blok menggunakan metode salin-tempel.  Sekarang kita tidak memikirkannya </li><li>  Variabel yang dideklarasikan di dalam menggunakan dan digunakan setelah Buang objek menggunakan adalah sakit kepala nyata.  Satu masalah lebih sedikit </li><li>  Di kelas yang membutuhkan Panggilan sering, masing-masing metode akan 2 baris lebih lama.  Ini akan tampak sepele, tetapi dalam kondisi banyak metode kecil, sepele ini tidak memungkinkan untuk menampilkan cukup banyak metode ini pada satu layar </li></ul><br><p>  Akibatnya, hal sederhana seperti menggunakan deklarasi mengubah perasaan pengkodean sehingga Anda tidak ingin kembali ke c # 7.3. </p><br><h3 id="static-local-functions">  Fungsi lokal statis </h3><br><p>  Sejujurnya, jika bukan karena bantuan analisis kode, saya bahkan tidak akan melihat kemungkinan ini.  Namun demikian, itu benar-benar menetap dalam kode saya: setelah semua, fungsi lokal statis sangat cocok dengan peran fungsi murni kecil, karena mereka tidak dapat mendukung penutupan variabel metode.  Alhasil, itu lebih mudah di hati, karena Anda mengerti bahwa ada satu kesalahan kurang potensial dalam kode Anda. </p><br><h3 id="nullable-reference-types">  Jenis referensi tidak dapat dibatalkan </h3><br><p>  Dan untuk hidangan penutup, saya ingin menyebutkan fitur paling penting dari C # 8.  Sebenarnya, mem-parsing tipe referensi yang tidak dapat dibatalkan layak mendapatkan artikel terpisah.  Saya hanya ingin menggambarkan sensasi. </p><br><ul><li>  Pertama, ini luar biasa.  Sebelumnya saya bisa menggambarkan maksud eksplisit saya untuk mendeklarasikan bidang atau properti dapat dibatalkan, tetapi sekarang fungsi ini dibangun ke dalam bahasa. </li><li>  Kedua, itu tidak menyimpan sama sekali dari NullReferenceException.  Dan saya tidak berbicara tentang "penyumbatan" yang terkenal karena peringatan.  Hanya saja pada saat runtime tidak ada yang menghasilkan argumen argumen kosong untuk Anda, jadi jangan buru-buru melempar kode seperti melempar ArgumentNullException baru () </li><li>  Ketiga, ada masalah serius dengan DTO.  Misalnya, Anda membubuhi keterangan properti dengan atribut yang diperlukan.  Karenanya, objek dengan properti 100% bukan nol akan masuk ke pengontrol WebAPI Anda.  Namun, tidak mungkin untuk mengaitkan atribut ini dan semua atribut serupa dengan pemeriksaan jenis referensi yang dapat dibatalkan.  Masalahnya adalah jika Anda mendeklarasikan standar <em>MyProperty {get;</em>  <em>set;}</em> properti dengan tipe NotNull, Anda akan mendapatkan peringatan: <em>"[CS8618] Properti yang tidak dapat dibatalkan 'MyProperty' tidak diinisialisasi. Pertimbangkan mendeklarasikan properti tersebut sebagai nullable"</em> .  Yang cukup adil, karena Anda tidak dapat menjamin tidak nol semantik selama proses inisialisasi.  Satu-satunya hasil dari fitur ini adalah ketidakmampuan untuk menggunakan bukan properti nol dalam DTO apa pun.  Tetapi ada kabar baik, ada solusi sederhana - cukup inisialisasi bidang Anda dengan nilai default: <br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> MyProperty { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } = <span class="hljs-string"><span class="hljs-string">""</span></span>;</code> </pre> </li><li>  Keempat, atribut yang menangani kasus kompleks, seperti TryGetValue, cukup kompleks.  Akibatnya, sangat mungkin bahwa pengembang tidak sangat sadar akan menyalahgunakan operator (!), Dengan demikian meratakan kemampuan tipe referensi yang dapat dibatalkan.  Satu harapan untuk analisa. </li><li>  Kelima, dan yang paling penting, secara pribadi kesempatan ini telah menyelamatkan saya berkali-kali dari kesalahan NullReferenceException.  Ternyata penghematan waktu dangkal - banyak kesalahan ditangkap pada tahap kompilasi, dan bukan tes atau debugging.  Ini terutama benar tidak hanya dalam proses mengembangkan logika bisnis yang kompleks, tetapi juga dalam kasus pekerjaan sepele dengan perpustakaan eksternal, DTO, dan dependensi lainnya, mungkin mengandung null. </li></ul><br><h2 id="rezyume">  Ringkasan </h2><br><p>  Tentu saja, peluang yang disajikan tidak mencapai revolusi penuh, tetapi ada semakin sedikit kesenjangan antara C # dan F # / Scala.  Apakah itu baik atau buruk, waktu akan memberi tahu. </p><br><p>  Pada saat rilis artikel ini, C # 8 mungkin sudah menetap di proyek Anda, jadi saya akan bertanya-tanya, apa perasaan Anda tentang versi baru bahasa favorit kami? </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467655/">https://habr.com/ru/post/id467655/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467633/index.html">Petisi: Pelaporan otomatis dan pembayaran pajak atas pendapatan FLP (Ukraina)</a></li>
<li><a href="../id467639/index.html">Minggu Keamanan 38: pelacakan perangkat seluler melalui kartu SIM</a></li>
<li><a href="../id467645/index.html">Mengikuti Pertemuan Sudut # 15</a></li>
<li><a href="../id467647/index.html">Jangan memuat - jangan menguji: bagaimana kami mengidentifikasi masalah dengan sistem manajemen dokumen VTB</a></li>
<li><a href="../id467653/index.html">Habrastatistics: menganalisis komentar pembaca</a></li>
<li><a href="../id467657/index.html">Inventarisasi dari I hingga Z. Kami menghitung lisensi perangkat lunak</a></li>
<li><a href="../id467659/index.html">Secara signifikan mempercepat pelaksanaan tugas dengan contoh konfigurasi tambahan memori HyperX FURY DDR4 yang diperbarui</a></li>
<li><a href="../id467661/index.html">Dosimeter untuk Seryozha. Bagian I. Polimaster - Pemburu Nuclide</a></li>
<li><a href="../id467663/index.html">Dukungan untuk instruksi khusus peranti keras di .NET Core (sekarang bukan hanya SIMD)</a></li>
<li><a href="../id467665/index.html">Troli truk ROS. Bagian 5. Bekerja di rviz dan gazebo: xacro, sensor baru</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>