<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>   Toda la verdad sobre RTOS. Art铆culo # 25. Canales de datos: introducci贸n y servicios b谩sicos  ㄢ ｐ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Despu茅s de un breve descanso, continuamos publicando traducciones de The Whole Truth About RTOS por Colin Walls. Esta vez hablaremos sobre los canales...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toda la verdad sobre RTOS. Art铆culo # 25. Canales de datos: introducci贸n y servicios b谩sicos</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433046/"><img src="https://habrastorage.org/webt/kk/zy/_j/kkzy_j5jujof9pkubwwgfiapg3o.jpeg"><br><br>  Despu茅s de un breve descanso, continuamos publicando traducciones de The Whole Truth About RTOS por Colin Walls.  Esta vez hablaremos sobre los canales de datos (en adelante denominados canales), que ya se mencionaron en uno de los art铆culos anteriores, es decir, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">en el n</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">掳 5</a> .  Los canales, en comparaci贸n con los buzones ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="># 21</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="># 22</a> ) o las colas ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="># 23</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="># 24</a> ), proporcionan una forma m谩s flexible de transferir mensajes simples entre tareas. <br><a name="habracut"></a><br>  Art铆culos anteriores de la serie: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art铆culo # 24.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Colas: servicios auxiliares y estructuras de datos.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art铆culo 23.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Colas: introducci贸n y servicios b谩sicos.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art铆culo # 22.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Buzones: servicios auxiliares y estructuras de datos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art铆culo # 21.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Buzones: Introducci贸n y servicios b谩sicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art铆culo # 20.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sem谩foros: servicios auxiliares y estructuras de datos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art铆culo # 19.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Sem谩foros: introducci贸n y servicios b谩sicos.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art铆culo # 18.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Grupos de banderas de eventos: servicios auxiliares y estructuras de datos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art铆culo # 17.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Grupos de banderas de eventos: Introducci贸n y servicios b谩sicos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art铆culo # 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Se帽ales</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art铆culo # 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Particiones de memoria: servicios y estructuras de datos</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art铆culo # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Secciones de memoria: introducci贸n y servicios b谩sicos.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art铆culo 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Estructuras de datos de tareas y llamadas de API no compatibles</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art铆culo # 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Servicios para trabajar con tareas.</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art铆culo # 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tareas: configuraci贸n e introducci贸n a la API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art铆culo # 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Programador: funciones avanzadas y preservaci贸n del contexto</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art铆culo # 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Programador: implementaci贸n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art铆culo # 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nucleus SE: dise帽o interno y despliegue</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art铆culo # 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">N煤cleo SE: Introducci贸n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art铆culo # 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Otros servicios RTOS</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art铆culo # 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Interacci贸n de tareas y sincronizaci贸n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art铆culo # 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tareas, cambio de contexto e interrupciones</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art铆culo # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Tareas y planificaci贸n</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art铆culo # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RTOS: estructura y modo en tiempo real</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Art铆culo # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">RTOS: introducci贸n.</a> <br><br><h2>  Usando canales </h2><br>  En Nucleus SE, los canales se identifican durante la fase de ensamblaje.  Cada aplicaci贸n puede tener hasta 16 canales.  Si no hay canales configurados en la aplicaci贸n, ni las estructuras de datos ni los c贸digos de llamadas de servicio relacionados con los canales se incluir谩n en la aplicaci贸n. <br><br>  Canal de transmisi贸n de datos: un conjunto de almacenamientos, el tama帽o de cada uno de los cuales le permite colocar un elemento de datos de una longitud especificada por el usuario en bytes.  El acceso a los datos se controla de tal manera que varias tareas pueden usarlos de manera segura.  Las tareas pueden escribir datos en el canal hasta que todas las 谩reas est茅n llenas.  Las tareas pueden leer datos del canal y los datos se reciben de acuerdo con el principio FIFO.  Intentar escribir en un canal lleno o leer desde un canal vac铆o puede provocar un error o una suspensi贸n de la tarea, dependiendo de la configuraci贸n de llamada API seleccionada y la configuraci贸n de Nucleus SE. <br><br><h2>  Canales y colas </h2><br>  Nucleus SE tambi茅n admite colas que se han discutido en detalle en art铆culos anteriores (# 23 y # 24).  La principal diferencia entre canales y colas es el tama帽o del mensaje.  Las colas contienen mensajes que consisten en una sola variable de tipo ADDR, generalmente punteros.  El canal contiene mensajes de tama帽o arbitrario, individuales para cada canal en la aplicaci贸n y asignados durante la configuraci贸n de par谩metros. <br><br><h2>  Configuraci贸n del canal </h2><br><h3>  Numero de canales </h3><br>  Como con la mayor铆a de los objetos de Nucleus SE, la personalizaci贸n del canal est谩 controlada por las directivas <b>#define</b> en <b>nuse_config.h</b> .  El par谩metro principal es <b>NUSE_PIPE_NUMBER</b> , que determina el n煤mero de canales configurados en la aplicaci贸n.  De forma predeterminada, este valor es cero (es decir, no hay canales en la aplicaci贸n) y puede tomar valores hasta 16. Un valor incorrecto generar谩 un error de compilaci贸n, que se generar谩 al registrar el archivo <b>nuse_config_check.h</b> (este archivo se incluye en <b>nuse_config.c</b> y compila junto con 茅l), que activar谩 la directiva <b>#error</b> . <br><br>  Seleccionar un valor distinto de cero sirve como activador principal de los canales.  Este par谩metro se usa para determinar las estructuras de datos y su tama帽o depende de su valor (m谩s sobre esto en el pr贸ximo art铆culo).  Adem谩s, un valor distinto de cero activa la configuraci贸n de la API. <br><br><h3>  Activar llamadas API </h3><br>  Cada funci贸n API (llamada de utilidad) en Nucleus SE tiene la directiva de habilitaci贸n <b>#define</b> en <b>nuse_config.h</b> .  Para los canales, estos s铆mbolos son: <br><br>  <b>NUSE_PIPE_SEND</b> <br>  <b>NUSE_PIPE_RECEIVE</b> <br>  <b>NUSE_PIPE_JAM</b> <br>  <b>NUSE_PIPE_RESET</b> <br>  <b>NUSE_PIPE_INFORMATION</b> <br>  <b>NUSE_PIPE_COUNT</b> <br><br>  Por defecto, est谩n configurados en <b>FALSO</b> , por lo que todas las llamadas de servicio est谩n deshabilitadas, lo que bloquea la inclusi贸n de c贸digo que las implementa.  Para configurar canales en la aplicaci贸n, debe seleccionar las llamadas de servicio API necesarias y establecerlas en <b>VERDADERO</b> . <br><br>  El siguiente es un fragmento de c贸digo del archivo predeterminado <b>nuse_config.h</b> . <br><br><pre><code class="plaintext hljs">#define NUSE_PIPE_NUMBER 0 /* Number of pipes in the system - 0-16 */ /* Service call enablers */ #define NUSE_PIPE_SEND FALSE #define NUSE_PIPE_RECEIVE FALSE #define NUSE_PIPE_JAM FALSE #define NUSE_PIPE_RESET FALSE #define NUSE_PIPE_INFORMATION FALSE #define NUSE_PIPE_COUNT FALSE</code> </pre> <br>  Si las funciones de API est谩n activadas, pero no hay canales en la aplicaci贸n (excepto <b>NUSE_Pipe_Count ()</b> , que siempre est谩 habilitado), se producir谩 un error de compilaci贸n.  Si su c贸digo usa una llamada API que no ha sido activada, se producir谩 un error de dise帽o porque el c贸digo de implementaci贸n no se incluy贸 en la aplicaci贸n. <br><br><h2>  Llamadas de canal de arriba </h2><br>  Nucleus RTOS admite diez canales generales que proporcionan la siguiente funcionalidad: <br><br><ul><li>  Enviando un mensaje al canal.  Nucleus SE se implementa en la funci贸n <b>NUSE_Pipe_Send ()</b> . </li><li>  Recibe mensajes del canal.  Nucleus SE se implementa en la funci贸n <b>NUSE_Pipe_Receive ()</b> . </li><li>  Env铆a un mensaje a la parte superior del canal.  Nucleus SE se implementa en <b>NUSE_Pipe_Jam ()</b> . </li><li>  Restaurar el canal a un estado no utilizado con la liberaci贸n de todas las tareas suspendidas (restablecer).  En Nucleus SE, implementado en <b>NUSE_Pipe_Reset ()</b> . </li><li>  Obteniendo informaci贸n sobre un canal espec铆fico.  Nucleus SE se implementa utilizando <b>NUSE_Pipe_Information ()</b> . </li><li>  Devuelve el contador de canales configurados actualmente en la aplicaci贸n.  Nucleus SE se implementa usando <b>NUSE_Pipe_Count ()</b> . </li><li>  Agregar un nuevo canal a la aplicaci贸n (creaci贸n).  No implementado en Nucleus SE. </li><li>  Eliminar un canal de una aplicaci贸n.  No implementado en Nucleus SE. </li><li>  Devuelve punteros a todos los canales de la aplicaci贸n.  No implementado en Nucleus SE. </li><li>  Enviar un mensaje a todas las tareas suspendidas en el canal (difusi贸n).  No implementado en Nucleus SE. </li></ul><br>  Considere la implementaci贸n de cada una de estas llamadas de servicio con m谩s detalle. <br><br><h2>  Llamadas de servicio para escribir y leer desde canales </h2><br>  Las operaciones b谩sicas que se realizan en los canales son la grabaci贸n (tambi茅n llamada env铆o) y la lectura (tambi茅n conocida como recepci贸n de mensajes).  Adem谩s, es posible grabar datos al comienzo del canal (interferencia).  Nucleus RTOS y Nucleus SE proporcionan tres llamadas API principales para estas operaciones, que se analizar谩n a continuaci贸n. <br><br><h3>  Grabaci贸n de canales </h3><br>  La llamada de la utilidad Nucleus RTOS API para escribir en el canal es muy flexible, lo que le permite suspender tareas impl铆citamente o con un tiempo de espera si la operaci贸n no puede completarse de inmediato (por ejemplo, cuando intenta escribir en un canal lleno).  Nucleus SE tiene un desaf铆o similar, pero la pausa de tareas es opcional y no se implementa un tiempo de espera. <br><br>  Nucleus RTOS tambi茅n proporciona un servicio de transmisi贸n de canales, pero no es compatible con Nucleus SE.  Se describir谩 en la secci贸n Llamadas de API no realizadas del siguiente art铆culo. <br><br>  <b><i>Llamar para enviar mensajes a un canal en Nucleus RTOS</i></b> <br><br>  Prototipo de llamada de servicio: <br><br>  <b>ESTADO NU_Send_To_Pipe (NU_PIPE * pipe, VOID * message, UNSIGNED size, UNSIGNED suspend));</b> <br><br>  Par谩metros: <br><br>  <b>pipe</b> : un puntero al bloque de control de canal proporcionado por el usuario; <br>  <b>mensaje</b> - puntero al mensaje a enviar; <br>  <b>tama帽o</b> : el n煤mero de bytes en el mensaje.  Si el canal admite mensajes de longitud variable, este par谩metro debe ser igual o menor que la longitud del mensaje admitida por el canal.  Si el canal admite mensajes de una longitud fija, este par谩metro debe ser igual al tama帽o del mensaje admitido por el canal; <br>  <b>suspender</b> : la especificaci贸n de la suspensi贸n de la tarea puede tomar los valores <b>NU_NO_SUSPEND</b> , <b>NU_SUSPEND</b> o el valor de tiempo de espera. <br><br>  Valor de retorno: <br><br>  <b>NUSE_SUCCESS</b> : la llamada se complet贸 correctamente; <br>  <b>NU_INVALID_PIPE</b> : puntero no v谩lido al canal; <br>  <b>NU_INVALID_POINTER</b> : puntero nulo a un mensaje ( <b>NULL</b> ); <br>  <b>NU_INVALID_SIZE</b> : el tama帽o del mensaje no es compatible con el tama帽o del mensaje admitido por el canal; <br>  <b>NU_INVALID_SUSPEND</b> : intento de suspender un hilo no relacionado con la tarea; <br>  <b>NU_PIPE_FULL</b> : el canal est谩 lleno y no se especific贸 el tipo de suspensi贸n de la tarea; <br>  <b>NU_TIMEOUT</b> : el canal est谩 lleno incluso despu茅s de que la tarea se suspende por un per铆odo de tiempo espec铆fico; <br>  <b>NU_PIPE_DELETED</b> : el canal se elimin贸 mientras se suspendi贸 la tarea; <br>  <b>NU_PIPE_RESET</b> : el canal se restableci贸 mientras se suspend铆a la tarea. <br><br>  <b><i>Llamar para enviar mensajes a un canal en Nucleus SE</i></b> <br><br>  Esta llamada de servicio API admite la funcionalidad principal de la API Nucleus RTOS. <br><br>  Prototipo de llamada de servicio: <br><br>  <b>ESTADO NUSE_Pipe_Send (canalizaci贸n NUSE_PIPE, mensaje U8 *, suspensi贸n U8);</b> <br><br>  Par谩metros: <br><br>  <b>tuber铆a</b> - 铆ndice (ID) del canal utilizado; <br>  <b>mensaje</b> - un puntero al mensaje a enviar (una secuencia de bytes de longitud permitida para un canal dado); <br>  <b>suspender</b> : especificaci贸n de suspensi贸n de tareas, puede tomar los valores <b>NUSE_NO_SUSPEND</b> y <b>NUSE_SUSPEND</b> . <br><br>  Valor de retorno: <br><br>  <b>NUSE_SUCCESS</b> : la llamada se complet贸 correctamente; <br>  <b>NUSE_INVALID_PIPE</b> : 铆ndice de canal no v谩lido; <br>  <b>NUSE_INVALID_POINTER</b> : puntero nulo a un mensaje ( <b>NULL</b> ); <br>  <b>NUSE_INVALID_SUSPEND</b> : intenta suspenderlo de un hilo no relacionado con la tarea o cuando el bloqueo de la tarea est谩 desactivado; <br>  <b>NUSE_PIPE_FULL</b> : el canal est谩 lleno y no se especific贸 el tipo de suspensi贸n de la tarea; <br>  <b>NUSE_PIPE_WAS_RESET</b> : el canal se restableci贸 mientras se suspendi贸 la tarea. <br><br>  <b><i>Implementaci贸n de la publicaci贸n de canales en Nucleus SE</i></b> <br><br>  La versi贸n del c贸digo de funci贸n API <b>NUSE_Pipe_Send ()</b> (despu茅s de verificar los par谩metros) se selecciona mediante compilaci贸n condicional dependiendo de si el soporte para llamadas API est谩 activado para bloquear (pausar) tareas o no.  A continuaci贸n consideramos ambas opciones. <br><br>  Si el bloqueo est谩 desactivado, el c贸digo para esta llamada a la API es bastante simple: <br><br><pre> <code class="plaintext hljs">if (NUSE_Pipe_Items[pipe] == NUSE_Pipe_Size[pipe]) /* pipe full */ { return_value = NUSE_PIPE_FULL; } else /* pipe element available */ { data = &amp;NUSE_Pipe_Data[pipe][NUSE_Pipe_Head[pipe]]; for (i=0; i&lt;msgsize; i++) { *data++ = *message++; } NUSE_Pipe_Head[pipe] += msgsize; if (NUSE_Pipe_Head[pipe] == (NUSE_Pipe_Size[pipe] * msgsize)) { NUSE_Pipe_Head[pipe] = 0; } NUSE_Pipe_Items[pipe]++; return_value = NUSE_SUCCESS; }</code> </pre><br>  La funci贸n verifica si hay espacio libre en el canal y usa el 铆ndice <b>NUSE_Pipe_Head []</b> para colocar el mensaje en el 谩rea de datos del canal. <br><br>  Si se activa el bloqueo de tareas, el c贸digo se vuelve m谩s complejo: <br><br><pre> <code class="plaintext hljs">do { if (NUSE_Pipe_Items[pipe] == NUSE_Pipe_Size[pipe]) /* pipe full */ { if (suspend == NUSE_NO_SUSPEND) { return_value = NUSE_PIPE_FULL; } else { /* block task */ NUSE_Pipe_Blocking_Count[pipe]++; NUSE_Suspend_Task(NUSE_Task_Active, (pipe &lt;&lt; 4) | NUSE_PIPE_SUSPEND); return_value = NUSE_Task_Blocking_Return[NUSE_Task_Active]; if (return_value != NUSE_SUCCESS) { suspend = NUSE_NO_SUSPEND; } } } else /* pipe element available */ { data = &amp;NUSE_Pipe_Data[pipe][NUSE_Pipe_Head[pipe]]; for (i=0; i&lt;msgsize; i++) { *data++ = *message++; } NUSE_Pipe_Head[pipe] += msgsize; if (NUSE_Pipe_Head[pipe] == (NUSE_Pipe_Size[pipe] * msgsize)) { NUSE_Pipe_Head[pipe] = 0; } NUSE_Pipe_Items[pipe]++; if (NUSE_Pipe_Blocking_Count[pipe] != 0) { U8 index; /* check whether a task is blocked on this pipe */ NUSE_Pipe_Blocking_Count[pipe]--; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_PIPE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == pipe)) { NUSE_Task_Blocking_Return[index] = NUSE_SUCCESS; NUSE_Wake_Task(index); break; } } } return_value = NUSE_SUCCESS; suspend = NUSE_NO_SUSPEND; } } while (suspend == NUSE_SUSPEND);</code> </pre><br>  Algunas aclaraciones pueden ser 煤tiles. <br><br>  El c贸digo est谩 encerrado en un <b>bucle do ... while</b> , que se ejecuta mientras el par谩metro de pausa de la tarea es <b>NUSE_SUSPEND</b> . <br><br>  Si el canal est谩 lleno y el par谩metro de suspensi贸n es <b>NUSE_NO_SUSPEND</b> , la llamada a la API finaliza con el valor <b>NUSE_PIPE_FULL</b> .  Si el par谩metro de <b>suspensi贸n</b> es <b>NUSE_SUSPEND</b> , la tarea se detiene.  Al finalizar (es decir, cuando se reanuda la tarea), si el valor de retorno es <b>NUSE_SUCCESS</b> , es decir, la tarea se reanud贸 porque se ley贸 el mensaje (y no porque se reinici贸 el canal), el c贸digo vuelve al comienzo del bucle. <br><br>  Si el canal no est谩 lleno, el mensaje proporcionado se guarda utilizando el 铆ndice <b>NUSE_Pipe_Head []</b> en el 谩rea de datos del canal.  Comprueba si el canal ha pausado tareas (mensajes pendientes).  Si hay tales tareas, se reanuda la primera de ellas.  La variable de <b>suspensi贸n</b> se establece en <b>NUSE_NO_SUSPEND</b> , y la llamada a la API se completa con el valor <b>NUSE_SUCCESS</b> . <br><br><h3>  Leyendo desde el canal </h3><br>  La llamada a la utilidad Nucleus RTOS API para leer desde el canal es muy flexible, lo que le permite pausar tareas impl铆citamente o con un tiempo de espera si la operaci贸n no se puede completar de inmediato (por ejemplo, cuando intenta leer un canal vac铆o).  Nucleus SE tiene una llamada de utilidad similar, pero la pausa de tareas es opcional y no se implementa un tiempo de espera. <br><br>  <b><i>Desaf铆o de lectura de canales en Nucleus RTOS</i></b> <br><br>  Prototipo de llamada de servicio: <br><br>  <b>ESTADO NU_Receive_From_Pipe (NU_PIPE * pipe, VOID * message, UNSIGNED size, UNSIGNED * actual_size, UNSIGNED suspend);</b> <br><br>  Par谩metros: <br><br>  <b>pipe</b> : un puntero al bloque de control de canal proporcionado por el usuario; <br>  <b>mensaje</b> : un puntero al almacenamiento del mensaje recibido; <br>  <b>tama帽o</b> : el n煤mero de bytes en el mensaje.  Debe coincidir con el tama帽o del mensaje especificado al crear el canal; <br>  <b>suspender</b> : especificaci贸n de suspensi贸n de tareas, puede tomar <b>NU_NO_SUSPEND</b> , <b>NU_SUSPEND</b> o valores de tiempo de espera. <br><br>  Valor de retorno: <br><br>  <b>NU_SUCCESS</b> : la llamada se complet贸 correctamente; <br>  <b>NU_INVALID_PIPE</b> : puntero no v谩lido al canal; <br>  <b>NU_INVALID_POINTER</b> : puntero nulo a un mensaje ( <b>NULL</b> ); <br>  <b>NU_INVALID_SUSPEND</b> : intenta pausar una tarea desde un hilo no asociado con la tarea; <br>  <b>NU_PIPE_EMPTY</b> : el canal est谩 vac铆o y no se especific贸 el tipo de suspensi贸n de la tarea; <br>  <b>NU_TIMEOUT</b> : el canal est谩 vac铆o incluso despu茅s de suspender la tarea por el valor de tiempo de espera especificado; <br>  <b>NU_PIPE_DELETED</b> : el canal se elimin贸 mientras se suspendi贸 la tarea; <br>  <b>NU_PIPE_RESET</b> : el canal se elimin贸 mientras se suspendi贸 la tarea. <br><br>  <b><i>Desaf铆o de lectura de canal en Nucleus SE</i></b> <br><br>  Esta llamada de servicio API admite la funcionalidad principal de la API Nucleus RTOS. <br><br>  Prototipo de llamada de servicio: <br><br>  <b>ESTADO NUSE_Pipe_Receive (canalizaci贸n NUSE_PIPE, mensaje U8 *, suspensi贸n U8);</b> <br><br>  Par谩metros: <br><br>  <b>tuber铆a</b> - 铆ndice (ID) del canal utilizado; <br>  <b>mensaje</b> : puntero al almacenamiento del mensaje recibido (una secuencia de bytes, cuya longitud coincide con el tama帽o del mensaje del canal); <br>  <b>suspender</b> : especificaci贸n de suspensi贸n de tareas, puede tomar los valores <b>NUSE_NO_SUSPEND</b> y <b>NU_SUSPEND</b> . <br><br>  Valor de retorno: <br><br>  <b>NUSE_SUCCESS</b> : la llamada se complet贸 correctamente; <br>  <b>NUSE_INVALID_PIPE</b> : 铆ndice de canal no v谩lido; <br>  <b>NUSE_INVALID_POINTER</b> : puntero nulo a un mensaje ( <b>NULL</b> ); <br>  <b>NUSE_INVALID_SUSPEND</b> : un intento de suspender una tarea de un hilo no asociado con la tarea o con el soporte para la suspensi贸n de tareas deshabilitado; <br>  <b>NUSE_PIPE_EMPTY</b> : el canal est谩 vac铆o y no se especific贸 el tipo de suspensi贸n de la tarea; <br>  <b>NUSE_PIPE_WAS_RESET</b> : el canal se restableci贸 mientras se suspendi贸 la tarea. <br><br>  <b><i>Implementaci贸n de lector de feeds en Nucleus SE</i></b> <br><br>  La versi贸n del c贸digo de funci贸n API <b>NUSE_Pipe_Receive ()</b> (despu茅s de verificar los par谩metros) se selecciona mediante compilaci贸n condicional, dependiendo de si el soporte API para llamadas de bloqueo (suspensi贸n de tareas) est谩 activado o no.  Consideraremos ambas opciones a continuaci贸n. <br><br>  Si el bloqueo est谩 desactivado, el c贸digo para esta llamada a la API es bastante simple: <br><br><pre> <code class="plaintext hljs">if (NUSE_Pipe_Items[pipe] == 0) /* pipe empty */ { return_value = NUSE_PIPE_EMPTY; } else { /* message available */ data = &amp;NUSE_Pipe_Data[pipe][NUSE_Pipe_Tail[pipe]]; for (i=0; i&lt;msgsize; i++) { *message++ = *data++; } NUSE_Pipe_Tail[pipe] += msgsize; if (NUSE_Pipe_Tail[pipe] == (NUSE_Pipe_Size[pipe] * msgsize)) { NUSE_Pipe_Tail[pipe] = 0; } NUSE_Pipe_Items[pipe]--; *actual_size = msgsize; return_value = NUSE_SUCCESS; }</code> </pre><br>  La funci贸n verifica la presencia de un mensaje en el canal y utiliza el 铆ndice <b>NUSE_Pipe_Tail []</b> para obtener el mensaje del 谩rea de datos del canal, y devuelve datos a trav茅s del puntero del mensaje. <br><br>  Si se activa el bloqueo de tareas, el c贸digo se vuelve m谩s complejo: <br><br><pre> <code class="plaintext hljs">do { if (NUSE_Pipe_Items[pipe] == 0) /* pipe empty */ { if (suspend == NUSE_NO_SUSPEND) { return_value = NUSE_PIPE_EMPTY; } else { /* block task */ NUSE_Pipe_Blocking_Count[pipe]++; NUSE_Suspend_Task(NUSE_Task_Active, (pipe &lt;&lt; 4) | NUSE_PIPE_SUSPEND); return_value = NUSE_Task_Blocking_Return[NUSE_Task_Active]; if (return_value != NUSE_SUCCESS) { suspend = NUSE_NO_SUSPEND; } } } else { /* message available */ data = &amp;NUSE_Pipe_Data[pipe][NUSE_Pipe_Tail[pipe]]; for (i=0; i&lt;msgsize; i++) { *message++ = *data++; } NUSE_Pipe_Tail[pipe] += msgsize; if (NUSE_Pipe_Tail[pipe] == (NUSE_Pipe_Size[pipe] * msgsize)) { NUSE_Pipe_Tail[pipe] = 0; } NUSE_Pipe_Items[pipe]--; if (NUSE_Pipe_Blocking_Count[pipe] != 0) { U8 index; /* check whether a task is blocked */ /* on this pipe */ NUSE_Pipe_Blocking_Count[pipe]--; for (index=0; index&lt;NUSE_TASK_NUMBER; index++) { if ((LONIB(NUSE_Task_Status[index]) == NUSE_PIPE_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == pipe)) { NUSE_Task_Blocking_Return[index] = NUSE_SUCCESS; NUSE_Wake_Task(index); break; } } } *actual_size = msgsize; return_value = NUSE_SUCCESS; suspend = NUSE_NO_SUSPEND; } } while (suspend == NUSE_SUSPEND);</code> </pre><br>  Algunas aclaraciones pueden ser 煤tiles. <br><br>  El c贸digo est谩 encerrado en un <b>bucle do ... while</b> , que se ejecuta mientras el par谩metro de pausa de la tarea es <b>NUSE_SUSPEND</b> . <br><br>  Si el canal est谩 vac铆o y el par谩metro de suspensi贸n es <b>NUSE_NO_SUSPEND</b> , la llamada a la API finaliza con el valor <b>NUSE_PIPE_EMPTY</b> .  Si el par谩metro de suspensi贸n es <b>NUSE_SUSPEND</b> , la tarea se detiene.  Al finalizar (es decir, cuando se reanuda la tarea), si el valor de retorno es <b>NUSE_SUCCESS</b> , es decir, la tarea se reanud贸 porque se envi贸 el mensaje (y no porque se restableci贸 el canal), el c贸digo vuelve al comienzo del bucle. <br><br>  Si el canal contiene mensajes, el mensaje almacenado se devuelve utilizando el 铆ndice <b>NUSE_Pipe_Tail []</b> .  Comprueba si hay tareas pausadas (en espera de ser enviadas) en este canal.  Si hay tales tareas, se reanuda la primera de ellas.  La variable de suspensi贸n se establece en <b>NUSE_NO_SUSPEND</b> , y la llamada a la API termina con el c贸digo <b>NUSE_SUCCESS</b> . <br><br><h3>  Grabar al inicio del canal </h3><br>  La llamada a la utilidad de la API Nucleus RTOS para escribir al comienzo del canal es muy flexible, lo que le permite pausar tareas impl铆citamente o con un tiempo de espera si la operaci贸n no se puede completar de inmediato (por ejemplo, al intentar escribir en un canal completo).  Nucleus SE tiene una llamada de utilidad similar, pero la pausa de tareas es opcional y no se implementa un tiempo de espera. <br><br>  <b><i>Llamada para escribir al comienzo del canal en Nucleus RTOS</i></b> <br><br>  Prototipo de llamada de servicio: <br><br>  <b>ESTADO NU_Send_To_Front_Of_Pipe (tuber铆a NU_PIPE *, mensaje VOID *, tama帽o SIN FIRMAR, suspensi贸n SIN FIRMAR);</b> <br><br>  Par谩metros: <br><br>  <b>pipe</b> : un puntero al bloque de control de canal proporcionado por el usuario; <br>  <b>mensaje</b> - puntero al mensaje a enviar; <br>  <b>tama帽o</b> : el n煤mero de bytes en el mensaje.  Si el canal admite mensajes de longitud variable, este par谩metro debe ser igual o menor que el tama帽o del mensaje admitido por el canal.  Si el canal admite mensajes de longitud fija, este par谩metro debe coincidir con el tama帽o de mensaje admitido por el canal; <br>  <b>suspender</b> : especificaci贸n de suspensi贸n de tareas, puede tomar <b>NU_NO_SUSPEND</b> , <b>NU_SUSPEND</b> o valores de tiempo de espera. <br><br>  Valor de retorno: <br><br>  <b>NU_SUCCESS</b> : la llamada se complet贸 correctamente; <br>  <b>NU_INVALID_PIPE</b> : puntero no v谩lido al canal; <br>  <b>NU_INVALID_POINTER</b> : puntero nulo a un mensaje ( <b>NULL</b> ); <br>  <b>NU_INVALID_SIZE</b> : el tama帽o del mensaje es incompatible con el tama帽o del mensaje admitido por el canal; <br>  <b>NU_INVALID_SUSPEND</b> : intento de suspender un hilo no relacionado con la tarea; <br>  <b>NU_PIPE_FULL</b> : el canal est谩 lleno y no se especific贸 el tipo de suspensi贸n de la tarea; <br>  <b>NU_TIMEOUT</b> : el canal est谩 lleno incluso despu茅s de que la tarea se suspende por un per铆odo de tiempo espec铆fico; <br>  <b>NU_PIPE_DELETED</b> : el canal se elimin贸 mientras se suspendi贸 la tarea; <br>  <b>NU_PIPE_RESET</b> : el canal se restableci贸 mientras se suspend铆a la tarea. <br><br>  <b><i>Llame para escribir al comienzo del canal en Nucleus SE</i></b> <br><br>  Esta llamada de utilidad admite la funcionalidad principal de la API Nucleus RTOS. <br><br>  Prototipo de llamada de servicio: <br><br>  <b>ESTADO NUSE_Pipe_Jam (canalizaci贸n NUSE_PIPE, mensaje ADDR *, suspensi贸n U8);</b> <br><br>  Par谩metros: <br><br>  <b>tuber铆a</b> - 铆ndice (ID) del canal utilizado; <br>  <b>mensaje</b> : un puntero al mensaje a enviar, que es una secuencia de bytes igual al tama帽o del mensaje configurado en el canal; <br>  suspender: especificaci贸n de suspensi贸n de tareas, puede ser <b>NUSE_NO_SUSPEND</b> o <b>NUSE_SUSPEND</b> . <br><br>  Valor de retorno: <br><br>  <b>NUSE_SUCCESS</b> : la llamada se complet贸 correctamente; <br>  <b>NUSE_INVALID_PIPE</b> : 铆ndice de canal no v谩lido; <br>  <b>NUSE_INVALID_POINTER</b> : puntero nulo a un mensaje ( <b>NULL</b> ); <br>  <b>NUSE_INVALID_SUSPEND</b> : un intento de suspender una tarea de un hilo no asociado con la tarea o cuando el bloqueo de la tarea est谩 desactivado; <br>  <b>NUSE_PIPE_FULL</b> : el canal est谩 lleno y no se especific贸 el tipo de suspensi贸n de la tarea; <br>  <b>NUSE_PIPE_WAS_RESET</b> : el canal se restableci贸 mientras se suspendi贸 la tarea. <br><br>  <b><i>Implementaci贸n de grabaci贸n de entrada de canal en Nucleus SE</i></b> <br><br>  El c贸digo de variante de la funci贸n <b>NUSE_Pipe_Jam ()</b> es muy similar a <b>NUSE_Pipe_Send ()</b> , excepto que el 铆ndice <b>NUSE_Pipe_Tail []</b> se usa para almacenar datos en 茅l, por lo tanto: <br><br><pre> <code class="plaintext hljs">if (NUSE_Pipe_Items[pipe] == NUSE_Pipe_Size[pipe]) /* pipe full */ { return_value = NUSE_PIPE_FULL; } else /* pipe element available */ { if (NUSE_Pipe_Tail[pipe] == 0) { NUSE_Pipe_Tail[pipe] = (NUSE_Pipe_Size[pipe] - 1) * msgsize; } else { NUSE_Pipe_Tail[pipe] -= msgsize; } data = &amp;NUSE_Pipe_Data[pipe][NUSE_Pipe_Tail[pipe]]; for (i=0; i&lt;msgsize; i++) { *data++ = *message++; } NUSE_Pipe_Items[pipe]++; return_value = NUSE_SUCCESS; }</code> </pre><br>  En el pr贸ximo art铆culo, consideraremos llamadas de servicio adicionales relacionadas con los canales, as铆 como las estructuras de datos correspondientes. <br><br>  <b>Sobre el autor:</b> Colin Walls ha trabajado en la industria electr贸nica durante m谩s de treinta a帽os, dedicando la mayor parte de su tiempo al firmware.  Ahora es ingeniero de firmware en Mentor Embedded (una divisi贸n de Mentor Graphics).  Colin Walls a menudo habla en conferencias y seminarios, autor de numerosos art铆culos t茅cnicos y dos libros sobre firmware.  Vive en el Reino Unido.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Blog</a> profesional <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">de Colin</a> , correo electr贸nico: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es433046/">https://habr.com/ru/post/es433046/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es433034/index.html">Inyecci贸n de hechizo</a></li>
<li><a href="../es433036/index.html">Consejos para organizar TI en una peque帽a empresa</a></li>
<li><a href="../es433038/index.html">驴Por qu茅 los especialistas en marketing aprenden programaci贸n?</a></li>
<li><a href="../es433042/index.html">Intel lanzar谩 el procesador con arquitectura tridimensional Foveros en 2019</a></li>
<li><a href="../es433044/index.html">El c贸digo fuente de OpenJDK contiene demasiadas palabras malas</a></li>
<li><a href="../es433048/index.html">C贸mo 2019 cambiar谩 las tiendas rusas</a></li>
<li><a href="../es433050/index.html">De un dise帽ador de aviones a un programador en un a帽o, o c贸mo convertirse en un Jedi</a></li>
<li><a href="../es433052/index.html">snap & flatpack - tragedia de comunidades</a></li>
<li><a href="../es433054/index.html">Una aguja en una pila de sesiones, o un bytecode de expresi贸n regular</a></li>
<li><a href="../es433056/index.html">El Ministerio de Comunicaciones endurece las reglas para el software con elementos de origen extranjero</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>