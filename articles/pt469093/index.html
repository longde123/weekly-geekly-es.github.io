<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⁉️ 👩‍👩‍👦 👂🏾 Comparação de bibliotecas menos populares e não muito CLI: cliff, plac, plumbum e outras (parte 2) 👼🏽 🍜 🧑🏽‍🤝‍🧑🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="No ecossistema Python, existem muitos pacotes para aplicativos CLI, ambos populares, como Click, e não muito. Os mais comuns foram considerados em um ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comparação de bibliotecas menos populares e não muito CLI: cliff, plac, plumbum e outras (parte 2)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469093/">  No ecossistema Python, existem muitos pacotes para aplicativos CLI, ambos populares, como Click, e não muito.  Os mais comuns foram considerados em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo anterior</a> , mas pouco conhecidos, mas não menos interessantes, serão mostrados aqui. <br><br><img src="https://habrastorage.org/webt/ab/ah/vg/abahvganodu2saybc-pqmdls4ea.png"><br><a name="habracut"></a><br>  Como na primeira parte, um script de console para a biblioteca todolib será gravado para cada biblioteca no Python 3.7.  Além disso, um teste trivial com esses equipamentos será escrito para cada implementação: <br><br><pre><code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@pytest.fixture(autouse=True) def db(monkeypatch): """ monkeypatch         ,         """ value = {"tasks": []} monkeypatch.setattr(todolib.TodoApp, "save", lambda _: ...) monkeypatch.setattr(todolib.TodoApp, "get_db", lambda _: value) return value @pytest.yield_fixture(autouse=True) def check(db): """      """ yield assert db["tasks"] and db["tasks"][0]["title"] == "test" # ,      EXPECTED = "Task 'test' created with number 1.\n"</span></span></code> </pre> <br>  Todo o código-fonte está disponível <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">neste repositório</a> . <br><br><h2>  penhasco </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Github</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A documentação</a> <br>  Muitos já ouviram falar do OpenStack, uma plataforma de código aberto para IaaS.  A maior parte é escrita em Python, incluindo utilitários de console que repetem a funcionalidade da CLI há muito tempo.  Isso continuou até que o penhasco, ou a Estrutura de Formulação da Interface da Linha de Comando, apareceu como uma estrutura comum.  Com ele, os desenvolvedores do Openstack combinaram pacotes como python-novaclient, python-swiftclient e python-keystoneclient em um programa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">openstack</a> . <br><br>  <b>Equipas</b> <br>  A abordagem para declarar comandos se assemelha a cement e cleo: argparse como um analisador de parâmetros, e os próprios comandos são criados por meio da herança da classe Command.  Ao mesmo tempo, existem pequenas extensões para a classe Command, como Lister, que formata os dados independentemente. <br><br><div class="spoiler">  <b class="spoiler_title">código fonte</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cliff <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> command <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cliff.lister <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Lister <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Command</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(command.Command)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Command with a parser shortcut."""</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_parser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, prog_name)</span></span></span><span class="hljs-function">:</span></span> parser = super().get_parser(prog_name) self.extend_parser(parser) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> parser <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extend_parser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, parser)</span></span></span><span class="hljs-function">:</span></span> ... <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Add</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Command)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Add new task."""</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extend_parser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, parser)</span></span></span><span class="hljs-function">:</span></span> parser.add_argument(<span class="hljs-string"><span class="hljs-string">"title"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Task title"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">take_action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, parsed_args)</span></span></span><span class="hljs-function">:</span></span> task = self.app.todoapp.add_task(parsed_args.title) print(task, <span class="hljs-string"><span class="hljs-string">"created with number"</span></span>, task.number, end=<span class="hljs-string"><span class="hljs-string">".\n"</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Show</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(Lister, Command)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Show current tasks."""</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extend_parser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, parser)</span></span></span><span class="hljs-function">:</span></span> parser.add_argument( <span class="hljs-string"><span class="hljs-string">"--show-done"</span></span>, action=<span class="hljs-string"><span class="hljs-string">"store_true"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Include done tasks"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">take_action</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, parsed_args)</span></span></span><span class="hljs-function">:</span></span> tasks = self.app.todoapp.list_tasks(show_done=parsed_args.show_done) <span class="hljs-comment"><span class="hljs-comment">#     'there is no todos'   #      return ( ("Number", "Title", "Status"), [[task.number, task.title, "" if task.done else "✘"] for task in tasks], ) class Done(Command): """Mark task as done.""" def extend_parser(self, parser): parser.add_argument("number", type=int, help="Task number") def take_action(self, parsed_args): task = self.app.todoapp.task_done(number=parsed_args.number) print(task, "marked as done.") #   Done    class Remove(Done): """Remove task from the list.""" def take_action(self, parsed_args): task = self.app.todoapp.remove_task(number=parsed_args.number) print(task, "removed from the list.")</span></span></code> </pre><br></div></div><br>  <b>Aplicação e principal</b> <br><br>  A classe do aplicativo possui os <i>métodos</i> <i>initialize_app</i> e <i>clean_up</i> ; no nosso caso, eles inicializam o aplicativo e salvam os dados. <br><br><div class="spoiler">  <b class="spoiler_title">código fonte</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cliff <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> app <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> cliff.commandmanager <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> CommandManager <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> todolib <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> TodoApp, __version__ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(app.App)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment">#   add_command, CommandManager  #    setuptools entrypoint manager = CommandManager("todo_cliff") manager.add_command("add", Add) manager.add_command("show", Show) manager.add_command("done", Done) manager.add_command("remove", Remove) super().__init__( description="Todo notes on cliff", version=__version__, command_manager=manager, deferred_help=True, ) self.todoapp = None def initialize_app(self, argv): self.todoapp = TodoApp.fromenv() def clean_up(self, cmd, result, err): self.todoapp.save() def main(args=sys.argv[1:]) -&gt; int: app = App() return app.run(argv=args)</span></span></code> </pre><br></div></div><br>  <b>Exemplos de trabalho</b> <br><br><pre> <code class="bash hljs">igor$ ./todo_cliff.py add <span class="hljs-string"><span class="hljs-string">"sell the old laptop"</span></span> Using database file /home/igor/.<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/share/todoapp/db.json Task <span class="hljs-string"><span class="hljs-string">'sell the old laptop'</span></span> created with number 0. Saving database to a file /home/igor/.<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/share/todoapp/db.json</code> </pre><br>  Sair da caixa!  E se você olhar por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">baixo do capô</a> , poderá ver que isso foi feito de uma maneira inteligente: informações no stdout e aviso / erro no stderr e, se necessário, são desativadas pelo sinalizador <i>--quiet</i> . <br><br><pre> <code class="bash hljs">igor$ ./todo_cliff.py -q show +--------+----------------------+--------+ | Number | Title | Status | +--------+----------------------+--------+ | 1 | sell the old laptop | ✘ | +--------+----------------------+--------+</code> </pre><br>  Como já mencionado, o Lister formata os dados, mas a tabela não se limita a: <br><br><pre> <code class="bash hljs">igor$ ./todo_cliff.py -q show -f json --noindent [{<span class="hljs-string"><span class="hljs-string">"Number"</span></span>: 0, <span class="hljs-string"><span class="hljs-string">"Title"</span></span>: <span class="hljs-string"><span class="hljs-string">"sell old laptop"</span></span>, <span class="hljs-string"><span class="hljs-string">"Status"</span></span>: <span class="hljs-string"><span class="hljs-string">"\u2718"</span></span>}]</code> </pre><br>  Além de json e table, yaml e csv estão disponíveis. <br><br>  Há também um rastreamento oculto padrão: <br><br><pre> <code class="bash hljs">igor$ ./todo_cliff.py -q remove 3 No such task.</code> </pre><br>  Outra REPL disponível e pesquisa <i>difusa,</i> também conhecida como <i>pesquisa difusa</i> : <br><br><pre> <code class="bash hljs">igor$ ./todo_cliff.py -q (todo_cliff) <span class="hljs-built_in"><span class="hljs-built_in">help</span></span> Shell commands (<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> <span class="hljs-built_in"><span class="hljs-built_in">help</span></span> %topic%): =================================== <span class="hljs-built_in"><span class="hljs-built_in">alias</span></span> <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span> <span class="hljs-built_in"><span class="hljs-built_in">history</span></span> py quit shell <span class="hljs-built_in"><span class="hljs-built_in">unalias</span></span> edit <span class="hljs-built_in"><span class="hljs-built_in">help</span></span> load pyscript <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> shortcuts Application commands (<span class="hljs-built_in"><span class="hljs-built_in">type</span></span> <span class="hljs-built_in"><span class="hljs-built_in">help</span></span> %topic%): ========================================= add complete <span class="hljs-keyword"><span class="hljs-keyword">done</span></span> <span class="hljs-built_in"><span class="hljs-built_in">help</span></span> remove show (todo_cliff) whow todo_cliff: <span class="hljs-string"><span class="hljs-string">'whow'</span></span> is not a todo_cliff <span class="hljs-built_in"><span class="hljs-built_in">command</span></span>. See <span class="hljs-string"><span class="hljs-string">'todo_cliff --help'</span></span>. Did you mean one of these? show</code> </pre><br>  <b>Teste</b> <br><br>  É simples: um objeto App é criado e run () também é chamado, que retorna um código de saída. <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_cliff</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(capsys)</span></span></span><span class="hljs-function">:</span></span> app = todo_cliff.App() code = app.run([<span class="hljs-string"><span class="hljs-string">"add"</span></span>, <span class="hljs-string"><span class="hljs-string">"test"</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> code == <span class="hljs-number"><span class="hljs-number">0</span></span> out, _ = capsys.readouterr() <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> out == EXPECTED</code> </pre><br>  <b>Os prós e contras</b> <br><br>  Prós: <br><br><ul><li>  Várias comodidades prontas para uso; </li><li>  Desenvolvido por OpenStack; </li><li>  Modo interativo; </li><li>  Extensibilidade através do ponto de entrada <i>setuptools</i> e CommandHook; </li><li>  Plugin Sphinx para documentação automática para CLI; </li><li>  Conclusão de comandos (somente bash); </li></ul><br>  Contras: <br><br><ul><li>  Uma pequena documentação, que consiste basicamente em um exemplo detalhado, mas único; </li></ul><br>  Outro bug foi notado: no caso de um erro ao ocultar o rastreamento da pilha, o código de saída é sempre zero. <br><br><h2>  Plac </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Github</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A documentação</a> <br><br>  À primeira vista, Plac parece algo como Fogo, mas <i>na realidade</i> é como Fogo, que esconde o mesmo argumento e muito mais sob o capô. <br><br>  Plac segue, citando a documentação, "o antigo princípio do mundo da computação: os <i>programas devem resolver casos comuns e o simples deve permanecer simples, e o complexo ao mesmo tempo possível</i> ".  O autor do framework usa o Python há mais de nove anos e o escreveu com a expectativa de resolver "99,9% das tarefas". <br><br>  <b>Comandos e principais</b> <br><br>  Atenção às anotações nos métodos show e done: é assim que o Plac analisa os parâmetros e a ajuda do argumento, respectivamente. <br><br><div class="spoiler">  <b class="spoiler_title">código fonte</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> plac <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> todolib <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TodoInterface</span></span></span><span class="hljs-class">:</span></span> commands = <span class="hljs-string"><span class="hljs-string">"add"</span></span>, <span class="hljs-string"><span class="hljs-string">"show"</span></span>, <span class="hljs-string"><span class="hljs-string">"done"</span></span>, <span class="hljs-string"><span class="hljs-string">"remove"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.app = todolib.TodoApp.fromenv() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__enter__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__exit__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, exc_type, exc_val, exc_tb)</span></span></span><span class="hljs-function">:</span></span> self.app.save() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, task)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Add new task. """</span></span> task = self.app.add_task(title=task) print(task, <span class="hljs-string"><span class="hljs-string">"created with number"</span></span>, task.number, end=<span class="hljs-string"><span class="hljs-string">".\n"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, show_done: plac.Annotation</span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">(</span></span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-string">"Include done tasks"</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">, kind=</span></span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-params"><span class="hljs-string">"flag"</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-params">)</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Show current tasks. """</span></span> self.app.print_tasks(show_done=show_done) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">done</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, number: </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"Task number"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Mark task as done. """</span></span> task = self.app.task_done(number=int(number)) print(task, <span class="hljs-string"><span class="hljs-string">"marked as done."</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, number: </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"Task number"</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">""" Remove task from the list. """</span></span> task = self.app.remove_task(number=int(number)) print(task, <span class="hljs-string"><span class="hljs-string">"removed from the list."</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: plac.Interpreter.call(TodoInterface)</code> </pre><br></div></div><br>  <b>Teste</b> <br><br>  Infelizmente, o teste do código de saída Plac não permite.  Mas o teste em si é real: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_plac</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(capsys)</span></span></span><span class="hljs-function">:</span></span> plac.Interpreter.call(todo_plac.TodoInterface, arglist=[<span class="hljs-string"><span class="hljs-string">"add"</span></span>, <span class="hljs-string"><span class="hljs-string">"test"</span></span>]) out, _ = capsys.readouterr() <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> out == EXPECTED</code> </pre><br>  <b>Os prós e contras</b> <br><br>  Prós: <br><br><ul><li>  Uso simples; </li><li>  Modo interativo com suporte a linha de leitura; </li><li>  API estável </li><li>  Excelente documentação; </li></ul><br>  Mas a coisa mais interessante sobre o Plac está oculta no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">uso avançado</a> : <br><br><ul><li>  Execução de vários comandos em threads e subprocessos; </li><li>  Computação paralela; </li><li>  servidor de telnet; </li></ul><br>  Contras: <br><br><ul><li>  Você não pode testar o código de saída; </li><li>  Vida de projeto ruim. </li></ul><br><h2>  Plumbum </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Github</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A documentação</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Documentação CLI</a> <br>  O Plumbum, de fato, não é uma estrutura tão pouco conhecida - quase 2000 estrelas, e há algo a amar por isso, porque, grosso modo, implementa a sintaxe do UNIX Shell.  Bem, com aditivos: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> plumbum <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> local &gt;&gt;&gt; output = local[<span class="hljs-string"><span class="hljs-string">"ls"</span></span>]() &gt;&gt;&gt; output.split(<span class="hljs-string"><span class="hljs-string">"\n"</span></span>)[:<span class="hljs-number"><span class="hljs-number">3</span></span>] [<span class="hljs-string"><span class="hljs-string">'console_examples.egg-info'</span></span>, <span class="hljs-string"><span class="hljs-string">'__pycache__'</span></span>, <span class="hljs-string"><span class="hljs-string">'readme.md'</span></span>] <span class="hljs-comment"><span class="hljs-comment">#  plumbum     cmd,      &gt;&gt;&gt; from plumbum.cmd import rm, ls, grep, wc &gt;&gt;&gt; rm["-r", "console_examples.egg-info"]() '' &gt;&gt;&gt; chain = ls["-a"] | grep["-v", "\\.py"] | wc["-l"] &gt;&gt;&gt; chain() '11\n'</span></span></code> </pre><br>  <b>Comandos e principais</b> <br><br>  O Plumbum também possui ferramentas para a CLI, para não dizer que são apenas uma adição: existem nargs, comandos e cores: <br><br><div class="spoiler">  <b class="spoiler_title">código fonte</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> plumbum <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cli, colors <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(cli.Application)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Todo notes on plumbum."""</span></span> VERSION = todolib.__version__ verbosity = cli.CountOf(<span class="hljs-string"><span class="hljs-string">"-v"</span></span>, help=<span class="hljs-string"><span class="hljs-string">"Increase verbosity"</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> args: print(colors.red | <span class="hljs-string"><span class="hljs-string">f"Unknown command: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{args[</span></span><span class="hljs-number"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-number">0</span></span></span></span><span class="hljs-string"><span class="hljs-subst">]!r}</span></span></span><span class="hljs-string">."</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> self.nested_command: <span class="hljs-comment"><span class="hljs-comment"># will be ``None`` if no sub-command follows print(colors.red | "No command given.") return 1 class Command(cli.Application): """Command with todoapp object""" def __init__(self, executable): super().__init__(executable) self.todoapp = todolib.TodoApp.fromenv() atexit.register(self.todoapp.save) def log_task(self, task, msg): print("Task", colors.green | task.title, msg, end=".\n") @App.subcommand("add") class Add(Command): """Add new task""" def main(self, task): task = self.todoapp.add_task(title=task) self.log_task(task, "added to the list") @App.subcommand("show") class Show(Command): """Show current tasks""" show_done = cli.Flag("--show-done", help="Include done tasks") def main(self): self.todoapp.print_tasks(self.show_done) @App.subcommand("done") class Done(Command): """Mark task as done""" def main(self, number: int): task = self.todoapp.task_done(number) self.log_task(task, "marked as done") @App.subcommand("remove") class Remove(Command): """Remove task from the list""" def main(self, number: int): task = self.todoapp.remove_task(number) self.log_task(task, "removed from the list.") if __name__ == '__main__': App.run()</span></span></code> </pre><br></div></div><br>  <b>Teste</b> <br><br>  Os aplicativos de teste no Plumbum diferem dos outros, exceto que a necessidade de passar também o nome do aplicativo, ou seja,  primeiro argumento: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_plumbum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(capsys)</span></span></span><span class="hljs-function">:</span></span> _, code = todo_plumbum.App.run([<span class="hljs-string"><span class="hljs-string">"todo_plumbum"</span></span>, <span class="hljs-string"><span class="hljs-string">"add"</span></span>, <span class="hljs-string"><span class="hljs-string">"test"</span></span>], exit=<span class="hljs-keyword"><span class="hljs-keyword">False</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> code == <span class="hljs-number"><span class="hljs-number">0</span></span> out, _ = capsys.readouterr() <span class="hljs-keyword"><span class="hljs-keyword">assert</span></span> out == <span class="hljs-string"><span class="hljs-string">"Task test created with number 0.\n"</span></span></code> </pre><br>  <b>Os prós e contras</b> <br><br>  Prós: <br><br><ul><li>  Excelente kit de ferramentas para trabalhar com equipes externas; </li><li>  Suporte para estilos e cores; </li><li>  API estável </li><li>  Vida ativa do projeto; </li></ul><br>  Nenhuma falha foi notada. <br><br><h2>  cmd2 </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Github</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A documentação</a> <br><br>  Primeiro, o cmd2 é uma extensão sobre o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cmd</a> da biblioteca padrão, <br>  isto é  Destina-se a aplicativos interativos.  No entanto, ele está incluído na revisão, pois também pode ser configurado para o modo CLI normal. <br><br>  <b>Comandos e principais</b> <br><br>  O cmd2 requer conformidade com uma certa regra: os comandos devem começar com o prefixo <i>do_</i> , mas, caso contrário, tudo <i>ficará</i> claro: <br><br><div class="spoiler">  <b class="spoiler_title">modo interativo</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cmd2 <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> todolib <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(cmd2.Cmd)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super().__init__(**kwargs) self.todoapp = todolib.TodoApp.fromenv() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__enter__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__exit__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, exc_type, exc_val, exc_tb)</span></span></span><span class="hljs-function">:</span></span> self.todoapp.save() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, title)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Add new task."""</span></span> task = self.todoapp.add_task(str(title)) self.poutput(<span class="hljs-string"><span class="hljs-string">f"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{task}</span></span></span><span class="hljs-string"> created with number </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{task.number}</span></span></span><span class="hljs-string">."</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, show_done)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Show current tasks."""</span></span> self.todoapp.print_tasks(bool(show_done)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_done</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, number)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Mark task as done."""</span></span> task = self.todoapp.task_done(int(number)) self.poutput(<span class="hljs-string"><span class="hljs-string">f"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{task}</span></span></span><span class="hljs-string"> marked as done."</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, number)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Remove task from the list."""</span></span> task = self.todoapp.remove_task(int(number)) self.poutput(<span class="hljs-string"><span class="hljs-string">f"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{task}</span></span></span><span class="hljs-string"> removed from the list."</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(**kwargs)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> App(**kwargs) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> app: app.cmdloop() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: main()</code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">modo não interativo</b> <div class="spoiler_text">  O modo normal requer um pouco de movimento extra. <br><br>  Por exemplo, você deve retornar ao argparse e escrever a lógica do caso quando o script for chamado sem parâmetros.  E agora os comandos obtêm <i>argparse.Namespace</i> . <br><br>  O analisador é retirado do exemplo argparse com pequenas adições - agora os sub-analisadores são atributos do <i>ArgumentParser</i> principal. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cmd2 <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> todo_argparse <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> get_parser parser = get_parser(progname=<span class="hljs-string"><span class="hljs-string">"todo_cmd2_cli"</span></span>) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(cmd2.Cmd)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, **kwargs)</span></span></span><span class="hljs-function">:</span></span> super().__init__(**kwargs) self.todoapp = todolib.TodoApp.fromenv() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__enter__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> self <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__exit__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, exc_type, exc_val, exc_tb)</span></span></span><span class="hljs-function">:</span></span> self.todoapp.save() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, args)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Add new task."""</span></span> task = self.todoapp.add_task(args.title) self.poutput(<span class="hljs-string"><span class="hljs-string">f"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{task}</span></span></span><span class="hljs-string"> created with number </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{task.number}</span></span></span><span class="hljs-string">."</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_show</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, args)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Show current tasks."""</span></span> self.todoapp.print_tasks(args.show_done) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_done</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, args)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Mark task as done."""</span></span> task = self.todoapp.task_done(args.number) self.poutput(<span class="hljs-string"><span class="hljs-string">f"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{task}</span></span></span><span class="hljs-string"> marked as done."</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_remove</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, args)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""Remove task from the list."""</span></span> task = self.todoapp.remove_task(args.number) self.poutput(<span class="hljs-string"><span class="hljs-string">f"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{task}</span></span></span><span class="hljs-string"> removed from the list."</span></span>) parser.add.set_defaults(func=do_add) parser.show.set_defaults(func=do_show) parser.done.set_defaults(func=do_done) parser.remove.set_defaults(func=do_remove) @cmd2.with_argparser(parser) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">do_base</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, args)</span></span></span><span class="hljs-function">:</span></span> func = getattr(args, <span class="hljs-string"><span class="hljs-string">"func"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> func: func(self, args) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: print(<span class="hljs-string"><span class="hljs-string">"No command provided."</span></span>) print(<span class="hljs-string"><span class="hljs-string">"Call with --help to get available commands."</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(argv=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> App() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> app: app.do_base(argv <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> sys.argv[<span class="hljs-number"><span class="hljs-number">1</span></span>:]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">'__main__'</span></span>: main()</code> </pre><br></div></div><br>  <b>Teste</b> <br><br>  <i>Somente um script interativo será testado.</i> <br><br>  Como o teste de aplicativos interativos requer um grande número de recursos humanos e de tempo, os desenvolvedores do cmd2 tentaram resolver esse problema com a ajuda de <i>transcrições</i> - arquivos de texto com exemplos de entrada e saída esperada.  Por exemplo: <br><br><pre> <code class="plaintext hljs">(Cmd) add test Task 'test' created with number 0.</code> </pre><br>  Assim, tudo o que é necessário é transferir a lista de arquivos com transcrições para o <i>aplicativo</i> : <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">test_cmd2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> todo_cmd2.main(transcript_files=[<span class="hljs-string"><span class="hljs-string">"tests/transcript.txt"</span></span>])</code> </pre><br>  <b>Os prós e contras</b> <br><br>  Prós: <br><br><ul><li>  Boa API para aplicativos interativos; </li><li>  Desenvolvendo ativamente nos últimos anos; </li><li>  Uma abordagem original para testes; </li><li>  Boa documentação. </li></ul><br>  Contras: <br><br><ul><li>  Requer código adicional e argparse ao escrever aplicativos não interativos; </li><li>  API instável; </li><li>  Em alguns lugares, a documentação está vazia. </li></ul><br><h2>  Bônus: Urwid </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Github</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">A documentação</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tutorial</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Exemplos de programas</a> <br><br>  Urwid é uma estrutura de um mundo um pouco diferente - de maldições e npyscreen, ou seja, da interface do usuário do console / terminal.  No entanto, está incluído na revisão como um bônus, pois, na minha opinião, merece atenção. <br><br>  <b>Aplicativo e equipes</b> <br><br>  O Urwid possui um grande número de widgets, mas não possui conceitos como uma janela ou ferramentas simples para acessar widgets vizinhos.  Portanto, se você deseja obter um resultado bonito, precisará de um design cuidadoso e / ou de outros pacotes, caso contrário, precisará transferir dados nos atributos dos botões, como aqui: <br><br><div class="spoiler">  <b class="spoiler_title">código fonte</b> <div class="spoiler_text"><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> urwid <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> urwid <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Button <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> todolib <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">App</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(urwid.WidgetPlaceholder)</span></span></span><span class="hljs-class">:</span></span> max_box_levels = <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> super().__init__(urwid.SolidFill()) self.todoapp = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> self.box_level = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__enter__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self)</span></span></span><span class="hljs-function">:</span></span> self.todoapp = todolib.TodoApp.fromenv() self.new_menu( <span class="hljs-string"><span class="hljs-string">"Todo notes on urwid"</span></span>, <span class="hljs-comment"><span class="hljs-comment">#       ,  #      Button("New task", on_press=add), Button("List tasks", on_press=list_tasks), ) return self def __exit__(self, exc_type, exc_val, exc_tb): self.todoapp.save() def new_menu(self, title, *items): self.new_box(menu(title, *items)) def new_box(self, widget): self.box_level += 1 # overlay      , #     LineBox    self.original_widget = urwid.Overlay( # LineBox  unicode-    self.original_widget, align="center", width=30, valign="middle", height=10, ) def popup(self, text): self.new_menu(text, Button("To menu", on_press=lambda _: self.pop(levels=2))) def keypress(self, size, key): if key != "esc": super().keypress(size, key=key) elif self.box_level &gt; 0: self.pop() def pop(self, levels=1): for _ in range(levels): self.original_widget = self.original_widget[0] self.box_level -= levels if self.box_level == 0: raise urwid.ExitMainLoop()</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">equipes</b> <div class="spoiler_text"><pre> <code class="python hljs">app = App() <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">menu</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(title, *items)</span></span></span><span class="hljs-function"> -&gt; urwid.ListBox:</span></span> body = [urwid.Text(title), urwid.Divider()] body.extend(items) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> urwid.ListBox(urwid.SimpleFocusListWalker(body)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(button)</span></span></span><span class="hljs-function">:</span></span> edit = urwid.Edit(<span class="hljs-string"><span class="hljs-string">"Title: "</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(button)</span></span></span><span class="hljs-function">:</span></span> text = edit.edit_text app.todoapp.add_task(text) app.popup(<span class="hljs-string"><span class="hljs-string">"Task added"</span></span>) app.new_menu(<span class="hljs-string"><span class="hljs-string">"New task"</span></span>, edit, Button(<span class="hljs-string"><span class="hljs-string">"Add"</span></span>, on_press=handle)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">list_tasks</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(button)</span></span></span><span class="hljs-function">:</span></span> tasks = app.todoapp.list_tasks(show_done=<span class="hljs-keyword"><span class="hljs-keyword">True</span></span>) buttons = [] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> task <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> tasks: status = <span class="hljs-string"><span class="hljs-string">"done"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> task.done <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-string"><span class="hljs-string">"not done"</span></span> text = <span class="hljs-string"><span class="hljs-string">f"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{task.title}</span></span></span><span class="hljs-string"> [</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">{status}</span></span></span><span class="hljs-string">]"</span></span> <span class="hljs-comment"><span class="hljs-comment">#         button = Button(text, on_press=task_actions, user_data=task.number) buttons.append(button) app.new_menu("Task list", *buttons) def task_actions(button, number): def done(button, number): app.todoapp.task_done(number) app.popup("Task marked as done.") def remove(button, number): app.todoapp.remove_task(number) app.popup("Task removed from the list.") btn_done = Button("Mark as done", on_press=done, user_data=number) btn_remove = Button("Remove from the list", on_press=remove, user_data=number) app.new_menu("Actions", btn_done, btn_remove)</span></span></code> </pre><br></div></div><br>  <b>principal</b> <br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">try</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> app: urwid.MainLoop(app).run() <span class="hljs-keyword"><span class="hljs-keyword">except</span></span> KeyboardInterrupt: <span class="hljs-keyword"><span class="hljs-keyword">pass</span></span></code> </pre><br>  <b>Os prós e contras</b> <br><br>  Prós: <br><br><ul><li>  Ótima API para escrever diferentes aplicativos TUI; </li><li>  Longa história de desenvolvimento (desde 2010) e API estável; </li><li>  Arquitetura competente; </li><li>  Boa documentação, existem exemplos. </li></ul><br>  Contras: <br><br><ul><li>  Como testar não é claro.  Somente as <i>chaves de envio tmux</i> vêm à mente; </li><li>  Erros não informativos quando os widgets não estão organizados corretamente. </li></ul><br><h2>  * * * </h2><br>  Cliff é muito parecido com Cleo e Cement e geralmente é bom para grandes projetos. <br><br>  Pessoalmente, não ousaria usar o Plac, mas recomendo a leitura do código fonte. <br><br>  O Plumbum possui um conveniente kit de ferramentas CLI e uma API brilhante para executar outros comandos; portanto, se você estiver reescrevendo scripts de shell no Python, é isso que você precisa. <br>  O cmd2 é adequado como base para aplicativos interativos e para aqueles que desejam migrar do cmd padrão. <br><br>  O Urwid apresenta aplicativos de console bonitos e fáceis de usar. <br><br>  Os seguintes pacotes não foram incluídos na revisão: <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aioconsole</a> - sem modo não interativo; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pyCLI</a> - sem suporte para subcomandos; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Clint</a> - sem suporte para subcomandos, repositório no arquivo morto; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">linha de comando</a> - é muito antiga (última versão em 2009) e desinteressante; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CLIArgs</a> - antigo (última versão em 2010) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">opterator</a> - relativamente antigo (última versão em 2015) </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt469093/">https://habr.com/ru/post/pt469093/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt469075/index.html">Grokay DLR</a></li>
<li><a href="../pt469077/index.html">Novo curso de Python da Microsoft [em inglês]</a></li>
<li><a href="../pt469079/index.html">Python no código do Visual Studio: atualização de extensão de setembro</a></li>
<li><a href="../pt469085/index.html">Retiramos o software do microcontrolador protegido por senha Renesas M16C</a></li>
<li><a href="../pt469087/index.html">MVCC no PostgreSQL-2. Garfos, arquivos, páginas</a></li>
<li><a href="../pt469095/index.html">Lançadas atualizações do ML.NET e do Model Builder: O que há de novo</a></li>
<li><a href="../pt469097/index.html">Servidor web CentOS 8 com php7, node.js e redis</a></li>
<li><a href="../pt469099/index.html">Tarefas de teste na entrevista do desenvolvedor - isso faz sentido?</a></li>
<li><a href="../pt469101/index.html">Aprendendo inglês: como aprender a falar como falante nativo</a></li>
<li><a href="../pt469109/index.html">Brinquedos de madeira, parte três - 1989</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>