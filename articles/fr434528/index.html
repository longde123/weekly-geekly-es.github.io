<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úçüèø üé≤ üèí D√©cryptage de Ray Tracer au format carte postale üí§ ‚úÖ üë®‚Äçüë©‚Äçüë¶‚Äçüë¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content=""Il l'a encore fait!" - c'est ce que la premi√®re chose m'est venue quand j'ai regard√© l'arri√®re du flyer Pixar [1] , qui √©tait compl√®tement rempli de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>D√©cryptage de Ray Tracer au format carte postale</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/434528/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/cr/xz/vj/crxzvjqqbw5gl4mv3wxxx2zw6wa.png"></div><br>  "Il l'a encore fait!" - c'est ce que la premi√®re chose m'est venue quand j'ai regard√© l'arri√®re du flyer Pixar <sup>[1]</sup> , qui √©tait compl√®tement rempli de code.  Un groupe de constructions et d'expressions a √©t√© sign√© dans le coin inf√©rieur droit par nul autre que Andrew Kensler.  Pour ceux qui ne le connaissent pas, je dirai: Andrew est un programmeur qui a invent√© un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traceur de rayons de la taille d'une carte de visite de</a> 1337 octets en 2009. <br><br>  Cette fois, Andrew a propos√© quelque chose de plus volumineux, mais avec un r√©sultat visuel beaucoup plus int√©ressant.  Depuis que j'ai fini d'√©crire mes Black Books Game Engine sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Wolf3D</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">DOOM</a> , j'ai eu le temps d'apprendre l'int√©rieur de son code cryptique.  Et presque imm√©diatement, j'ai √©t√© litt√©ralement fascin√© par les techniques d√©couvertes en lui.  Ils √©taient tr√®s diff√©rents des travaux pr√©c√©dents d'Andrew, bas√©s sur un traceur de rayons "standard".  J'√©tais int√©ress√© √† en apprendre davantage sur la marche des rayons, les caract√©ristiques de la g√©om√©trie volum√©trique constructive, le rendu Monte Carlo / tra√ßage de chemin, ainsi que de nombreuses autres astuces qu'il a utilis√©es pour compresser le code dans un si petit morceau de papier. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yc/z4/nt/ycz4ntg3qh91i6m2wymfccaekvk.png"></div><a name="habracut"></a><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lf/2o/qv/lf2oqvd5d39pyfwxyixvjnrmlqq.png"></div><br><h2>  Code source </h2><br><hr><br>  Le recto du d√©pliant est une publicit√© pour le service de recrutement Pixar.  Au verso, 2 037 octets de code C ++ sont imprim√©s, obscurcis pour couvrir le moins de surface possible. <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;stdlib.h&gt; // card &gt; pixar.ppm #include &lt;stdio.h&gt; #include &lt;math.h&gt; #define R return #define O operator typedef float F;typedef int I;struct V{F x,y,z;V(F v=0){x=y=z=v;}V(F a,F b,F c=0){x=a;y=b;z=c;}V O+(V r){RV(x+rx,y+ry,z+rz);}VO*(V r){RV(x*rx,y*r. y,z*rz);}FO%(V r){R x*r.x+y*r.y+z*rz;}VO!(){R*this*(1/sqrtf(*this%*this) );}};FL(F l,F r){R l&lt;r?l:r;}FU(){R(F)rand()/RAND_MAX;}FB(V p,V l,V h){l=p +l*-1;h=h+p*-1;RL(L(L(lx,hx),L(ly,hy)),L(lz,hz));}FS(V p,I&amp;m){F d=1\ e9;V f=p;fz=0;char l[]="5O5_5W9W5_9_COC_AOEOA_E_IOQ_I_QOUOY_Y_]OWW[WaOa_aW\ eWa_e_cWiO";for(I i=0;i&lt;60;i+=4){V b=V(l[i]-79,l[i+1]-79)*.5,e=V(l[i+2]-79,l [i+3]-79)*.5+b*-1,o=f+(b+e*L(-L((b+f*-1)%e/(e%e),0),1))*-1;d=L(d,o%o);}d=sq\ rtf(d);V a[]={V(-11,6),V(11,6)};for(I i=2;i--;){V o=f+a[i]*-1;d=L(d,ox&gt;0?f\ absf(sqrtf(o%o)-2):(o.y+=oy&gt;0?-2:2,sqrtf(o%o)));}d=powf(powf(d,8)+powf(pz, 8),.125)-.5;m=1;F r=L(-L(B(p,V(-30,-.5,-30),V(30,18,30)),B(p,V(-25,17,-25),V (25,20,25))),B(V(fmodf(fabsf(px),8),py,pz),V(1.5,18.5,-25),V(6.5,20,25))) ;if(r&lt;d)d=r,m=2;F s=19.9-py;if(s&lt;d)d=s,m=3;R d;}IM(V o,V d,V&amp;h,V&amp;n){I m,s= 0;F t=0,c;for(;t&lt;100;t+=c)if((c=S(h=o+d*t,m))&lt;.01||++s&gt;99)R n=!V(S(h+V(.01,0 ),s)-c,S(h+V(0,.01),s)-c,S(h+V(0,0,.01),s)-c),m;R 0;}VT(V o,V d){V h,n,r,t= 1,l(!V(.6,.6,1));for(I b=3;b--;){I m=M(o,d,h,n);if(!m)break;if(m==1){d=d+n*( n%d*-2);o=h+d*.1;t=t*.2;}if(m==2){F i=n%l,p=6.283185*U(),c=U(),s=sqrtf(1-c), g=nz&lt;0?-1:1,u=-1/(g+nz),v=nx*ny*u;d=V(v,g+ny*ny*u,-ny)*(cosf(p)*s)+V( 1+g*nx*nx*u,g*v,-g*nx)*(sinf(p)*s)+n*sqrtf(c);o=h+d*.1;t=t*.2;if(i&gt;0&amp;&amp;M(h +n*.1,l,h,n)==3)r=r+t*V(500,400,100)*i;}if(m==3){r=r+t*V(50,80,100);break;}} R r;}I main(){I w=960,h=540,s=16;V e(-22,5,25),g=!(V(-3,4,0)+e*-1),l=!V(gz, 0,-gx)*(1./w),u(gy*lz-gz*ly,gz*lx-gx*lz,gx*ly-gy*lx);printf("P\ 6 %d %d 255 ",w,h);for(I y=h;y--;)for(I x=w;x--;){V c;for(I p=s;p--;)c=c+T(e ,!(g+l*(xw/2+U())+u*(yh/2+U())));c=c*(1./s)+14./241;V o=c+1;c=V(cx/ox,c. y/oy,cz/oz)*255;printf("%c%c%c",(I)cx,(I)cy,(I)cz);}}// Andrew Kensler</span></span></span></span></code> </pre> <br><h2>  Travaille-t-il m√™me? </h2><br><hr><br>  Avec le code, il y a une instruction pour son lancement.  L'id√©e est de rediriger la sortie standard vers un fichier.  Par extension, nous pouvons supposer que le format de sortie est un format d'image texte appel√© NetPBM <sup>[2]</sup> . <br><br><pre>  $ clang -o card2 -O3 raytracer.cpp
 $ time ./card&gt; pixar.ppm<font></font>
<font></font>
 r√©el 2m58.524s
 utilisateur 2m57.567s
 sys 0m0.415s </pre><br>  Apr√®s deux minutes et cinquante-huit secondes <sup>[3]</sup> , l'image suivante est g√©n√©r√©e.  C'est incroyable le peu de code n√©cessaire pour cela. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cae/b34/b5c/caeb34b5c6c57c4598adc8f6b3f28f38.webp"></div><br>  Vous pouvez extraire beaucoup de l'image ci-dessus.  Le grain est un signe √©vident d'un ¬´traceur de chemin¬ª.  Ce type de rendu diff√®re du lancer de rayons en ce que les rayons ne sont pas retrac√©s jusqu'aux sources de lumi√®re.  Dans cette m√©thode, des milliers de rayons par pixel sont √©mis par les sources et le programme les surveille, en esp√©rant qu'ils trouveront la source de lumi√®re.  Il s'agit d'une technique int√©ressante qui, bien mieux que le lancer de rayons, peut g√©rer le rendu de l'occlusion ambiante, des ombres douces, des caustiques et de la radiosit√©. <br><br><h2>  Nous allons diviser le code en plusieurs parties </h2><br><hr><br>  Passer l'entr√©e √† CLion formate le code (voir la sortie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> ) et le divise en parties / t√¢ches plus petites. <br><br><pre>  <font color="grey">#include &lt;stdlib.h&gt; // card&gt; pixar.ppm</font> <font color="grey">
</font>  <font color="grey">#include &lt;stdio.h&gt;</font> <font color="grey">
</font>  <font color="grey">#include &lt;math.h&gt;</font> </pre><br><pre>  <font color="fuchsia">#define R return</font> <font color="fuchsia">
</font>  <font color="fuchsia">#define O operator</font> <font color="fuchsia">
</font>  <font color="fuchsia">typedef float F; typedef int I;</font> </pre><pre>  <font color="blue">struct V {F x, y, z; V (F v = 0) {x = y = z = v;} V (F a, F b, F</font> <font color="blue">
</font>  <font color="blue">c = 0) {x = a; y = b; z = c;} V O + (V r) {RV (x + rx, y + ry, z + rz);} VO * (V r) {RV ( x * rx, y * r.</font> <font color="blue">
</font>  <font color="blue">y, z * rz);} FO% (V r) {R x * r.x + y * r.y + z * rz;} VO! () {R * this * (1 / sqrtf (* this% * ceci)</font> <font color="blue">
</font>  <font color="blue">);}};</font> </pre><pre>  <font color="orange">FL (F l, F r) {R l &lt;r? L: r;} FU () {R (F) rand () / RAND_MAX;} FB (V p, V l, V h) {l = p</font> <font color="orange">
</font>  <font color="orange">+ l * -1; h = h + p * -1; RL (L (L (L (L (lx, hx), L (ly, hy)), L (lz, hz));}</font> </pre><pre>  <font color="LimeGreen">FS (V p, I &amp; m) {F d = 1 \</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">e9; V f = p; fz = 0; char l [] = "5O5_5W9W5_9_COC_AOEOA_E_IOQ_I_QOUOY_Y_] OWW [WaOa_aW \</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">eWa_e_cWiO "; pour (I i = 0; i &lt;60; i + = 4) {V b = V (l [i] -79, l [i + 1] -79) *. 5, e = V (l [ i + 2] -79, l</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">[i + 3] -79) *. 5 + b * -1, o = f + (b + e * L (-L ((b + f * -1)% e / (e% e), 0), 1)) * - 1; d = L (d, o% o);} d = sq \</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">rtf (d); V a [] = {V (-11,6), V (11,6)}; pour (I i = 2; i -;) {V o = f + a [i] * -1; d = L (d, ox&gt; 0? F \</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">absf (sqrtf (o% o) -2) :( o.y + = oy&gt; 0? -2: 2, sqrtf (o% o)));} d = powf (powf (d, 8) + powf (pz ,</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">8), 125) -. 5; m = 1; F r = L (-L (B (p, V (-30, -. 5, -30), V (30,18,30)), B (p, V (-25,17, -25), V</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">(25,20,25))), B (V (fmodf (fabsf (px), 8), py, pz), V (1.5,18.5, -25), V (6.5,20,25)))</font> <font color="LimeGreen">
</font>  <font color="LimeGreen">; si (r &lt;d) d = r, m = 2; F s = 19,9-py; si (s &lt;d) d = s, m = 3; R d;}</font> </pre><pre>  <font color="black">IM (V o, V d, V &amp; h, V &amp; n) {I m, s =</font> <font color="black">
</font>  <font color="black">0; F t = 0, c; pour (; t &lt;100; t + = c) si ((c = S (h = o + d * t, m)) &lt;. 01 || ++ s&gt; 99) R n =! V (S (h + V (.01,0</font> <font color="black">
</font>  <font color="black">), s) -c, S (h + V (0, .01), s) -c, S (h + V (0,0, .01), s) -c), m; R 0;}</font> </pre><pre>  <font color="SkyBlue">VT (V o, V d) {V h, n, r, t =</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">1, l (! V (.6, .6,1)); pour (I b = 3; b -;) {I m = M (o, d, h, n); si (! M) casse ; si (m == 1) {d = d + n * (</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">n% d * -2); o = h + d * .1; t = t * .2;} si (m == 2) {F i = n% l, p = 6,283185 * U (), c = U (), s = sqrtf (1-c),</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">g = nz &lt;0? -1: 1, u = -1 / (g + nz), v = nx * ny * u; d = V (v, g + ny * ny * u, -ny) * (cosf (p) * s) + V (</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">1 + g * nx * nx * u, g * v, -g * nx) * (sinf (p) * s) + n * sqrtf (c); o = h + d * .1; t = t *. 2; si (i&gt; 0 &amp;&amp; M (h</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">+ n * .1, l, h, n) == 3) r = r + t * V (500,400,100) * i;} si (m == 3) {r = r + t * V (50,80,100) ; break;}}</font> <font color="SkyBlue">
</font>  <font color="SkyBlue">R r;}</font> </pre><pre>  <font color="red">I main () {I w = 960, h = 540, s = 16; V e (-22,5,25), g =! (V (-3,4,0) + e * -1), l =! V (gz,</font> <font color="red">
</font>  <font color="red">0, -gx) * (1./w), u (gy * lz-gz * ly, gz * lx-gx * lz, gx * ly-gy * lx); printf ("P \</font> <font color="red">
</font>  <font color="red">6% d% d 255 ", w, h); pour (I y = h; y -;) pour (I x = w; x -;) {V c; pour (I p = s; p- -;) c = c + T (e</font> <font color="red">
</font>  <font color="red">,! (g + l * (xw / 2 + U ()) + u * (yh / 2 + U ()))); c = c * (1./s) + 14. / 241; V o = c + 1; c = V (cx / ox, c.</font> <font color="red">
</font>  <font color="red">y / oy, cz / oz) * 255; printf ("% c% c% c", (I) cx, (I) cy, (I) cz);}}</font> </pre><pre>  <font color="LightGray">// Andrew Kensler</font> </pre><br>  Chacune des sections est d√©crite en d√©tail dans la suite de l'article: <br>  <font color="fuchsia">‚ñ†</font> - astuces ordinaires, <font color="blue">‚ñ†</font> - classe Vector, <font color="orange">‚ñ†</font> - code auxiliaire, <font color="LimeGreen">‚ñ†</font> - base de donn√©es, <font color="black">‚ñ†</font> - marche de rayons, <font color="SkyBlue">‚ñ†</font> - √©chantillonnage, <font color="red">‚ñ†</font> - code principal. <br><br><h2>  Astuces courantes avec #define et typedef </h2><br><hr><br>  Les astuces courantes utilisent #define et typedef pour r√©duire consid√©rablement la quantit√© de code.  Ici, nous d√©signons F = float, I = int, R = return et O = operator.  L'ing√©nierie inverse est triviale. <br><br><h2>  Classe v </h2><br><hr><br>  Vient ensuite la classe V, que j'ai renomm√©e Vec (m√™me si, comme nous le verrons ci-dessous, elle est √©galement utilis√©e pour stocker des canaux RVB au format flottant). <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vec</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> x, y, z; Vec(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> v = <span class="hljs-number"><span class="hljs-number">0</span></span>) { x = y = z = v; } Vec(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> a, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> b, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> c = <span class="hljs-number"><span class="hljs-number">0</span></span>) { x = a; y = b; z = c;} Vec <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>+(Vec r) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec(x + rx, y + ry, z + rz); } Vec <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>*(Vec r) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Vec(x * rx, y * ry, z * rz); } <span class="hljs-comment"><span class="hljs-comment">// dot product float operator%(Vec r) { return x * rx + y * ry + z * rz; } // inverse square root Vec operator!() {return *this * (1 / sqrtf(*this % *this) );} };</span></span></code> </pre> <br>  Notez qu'il n'y a pas d'op√©rateur de soustraction (-), donc au lieu d'√©crire "X = A - B", "X = A + B * -1" est utilis√©.  La racine carr√©e inverse est utile plus tard pour normaliser les vecteurs. <br><br><h2>  Fonction principale </h2><br><hr><br>  main () est le seul caract√®re qui ne peut pas √™tre obscurci car il est appel√© par la fonction _start de la biblioth√®que libc.  Cela vaut g√©n√©ralement la peine de commencer, car il sera plus facile de travailler de cette fa√ßon.  Il m'a fallu un certain temps pour comprendre la signification des premi√®res lettres, mais j'ai quand m√™me r√©ussi √† cr√©er quelque chose de lisible. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> w = <span class="hljs-number"><span class="hljs-number">960</span></span>, h = <span class="hljs-number"><span class="hljs-number">540</span></span>, samplesCount = <span class="hljs-number"><span class="hljs-number">16</span></span>; <span class="hljs-function"><span class="hljs-function">Vec </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">position</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">-22</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">25</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; Vec goal = !(Vec(<span class="hljs-number"><span class="hljs-number">-3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>) + position * <span class="hljs-number"><span class="hljs-number">-1</span></span>); Vec left = !Vec(goal.z, <span class="hljs-number"><span class="hljs-number">0</span></span>, -goal.x) * (<span class="hljs-number"><span class="hljs-number">1.</span></span> / w); <span class="hljs-comment"><span class="hljs-comment">// Cross-product to get the up vector Vec up(goal.y * left.z - goal.z * left.y, goal.z * left.x - goal.x * left.z, goal.x * left.y - goal.y * left.x); printf("P6 %d %d 255 ", w, h); for (int y = h; y--;) for (int x = w; x--;) { Vec color; for (int p = samplesCount; p--;) color = color + Trace(position, !(goal + left * (x - w / 2 + randomVal())+ up * (y - h / 2 + randomVal()))); // Reinhard tone mapping color = color * (1. / samplesCount) + 14. / 241; Vec o = color + 1; color = Vec(color.x / ox, color.y / oy, color.z / oz) * 255; printf("%c%c%c", (int) color.x, (int) color.y, (int) color.z); } }</span></span></code> </pre> <br>  Notez que les litt√©raux flottants ne contiennent pas la lettre ¬´f¬ª et la partie fractionnaire est supprim√©e pour √©conomiser de l'espace.  La m√™me astuce est utilis√©e ci-dessous, o√π la partie enti√®re est supprim√©e (float x = .5).  La construction "for" avec une expression d'it√©ration ins√©r√©e √† l'int√©rieur de la condition de rupture est √©galement inhabituelle. <br><br>  Il s'agit d'une fonction principale assez standard pour un traceur de rayon / chemin.  Les vecteurs de cam√©ra sont d√©finis ici et des rayons sont √©mis pour chaque pixel.  La diff√©rence entre le traceur de rayons et le traceur de trajet est que plusieurs rayons sont √©mis par pixel dans le TP, qui sont l√©g√®rement d√©cal√©s de mani√®re al√©atoire.  Ensuite, la couleur obtenue pour chaque rayon d'un pixel est accumul√©e dans trois canaux flottants R, B, G.  √Ä la fin, une correction tonale du r√©sultat de la m√©thode Reinhardt est effectu√©e. <br><br>  La partie la plus importante est sampleCount, qui peut th√©oriquement √™tre d√©fini sur 1 pour acc√©l√©rer le rendu et l'it√©ration.  Voici des exemples de rendus avec des exemples de valeurs de 1 √† 2048. <br><br><div class="spoiler">  <b class="spoiler_title">En-t√™te de spoiler</b> <div class="spoiler_text"><img src="https://habrastorage.org/getpro/habr/post_images/550/e66/b2b/550e66b2b1347f8cafdf18c50d89e40d.png"><br><br>  1 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f49/724/1f0/f497241f0e3bb43fcc9913d8a2745419.png"><br><br>  2 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f71/3f3/35c/f713f335c2842b995936db1499e307e5.png"><br><br>  4 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b4f/6d4/f56/b4f6d4f56198a64b8e569a62f7159e8a.png"><br><br>  8 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a70/200/3c6/a702003c61d4080c2f92fe84844238cd.png"><br><br>  16 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bcf/0d6/43c/bcf0d643c501839c2506c7c026bc445c.png"><br><br>  32 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/8f0/5cf/569/8f05cf5690fa3265a1a4fa6f60a35749.png"><br><br>  64 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ebd/c87/660/ebdc87660263ff14eb6bf03a95865f34.png"><br><br>  128 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d17/0d3/1ae/d170d31aed20aeafc54d877ed447a1cc.png"><br><br>  256 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/fb9/52c/4df/fb952c4dfd0a4cb14245cedd060dcf05.png"><br><br>  512 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/460/50f/715/46050f71582834ddebbeb29dd86940fc.png"><br><br>  1024 <br><br><img src="https://habrastorage.org/getpro/habr/post_images/947/ea8/88b/947ea888b63c32f0892cc1e25b187bf8.png"><br><br>  2048 </div></div><br><h2>  Code d'assistance </h2><br><hr><br>  Un autre morceau de code simple est les fonctions d'aide.  Dans ce cas, nous avons une fonction triviale min (), un g√©n√©rateur de valeurs al√©atoires dans l'intervalle [0,1] et un boxTest () beaucoup plus int√©ressant, qui fait partie du syst√®me Constructive Solid Geometry (CSG) utilis√© pour d√©couper le monde.  Le CSG est discut√© dans la section suivante. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">min</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> l, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> r)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> l &lt; r ? l : r; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randomVal</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>) rand() / RAND_MAX; } <span class="hljs-comment"><span class="hljs-comment">// Rectangle CSG equation. Returns minimum signed distance from // space carved by lowerLeft vertex and opposite rectangle // vertex upperRight. float BoxTest(Vec position, Vec lowerLeft, Vec upperRight) { lowerLeft = position + lowerLeft * -1; upperRight = upperRight + position * -1; return -min( min( min(lowerLeft.x, upperRight.x), min(lowerLeft.y, upperRight.y) ), min(lowerLeft.z, upperRight.z)); }</span></span></code> </pre> <br><h2>  Fonctions de la g√©om√©trie volum√©trique constructive </h2><br><hr><br>  Il n'y a pas de sommets dans le code.  Tout se fait √† l'aide des fonctions CSG.  Si vous ne les connaissez pas, dites simplement que ce sont des fonctions qui d√©crivent si la coordonn√©e est √† l'int√©rieur ou √† l'ext√©rieur de l'objet.  Si la fonction renvoie une distance positive, le point se trouve √† l'int√©rieur de l'objet.  Une distance n√©gative indique que le point est en dehors de l'objet.  Il existe de nombreuses fonctions pour d√©crire diff√©rents objets, mais par souci de simplification, prenons par exemple une sph√®re et deux points, A et B. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56f/424/13a/56f42413a77c51a3d06e12fd4b4b385e.svg" alt="image"></div><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Signed distance point(p) to sphere(c,r) float testSphere(Vec p, Vec c, float r) { Vec delta = c - p; float distance = sqrtf(delta%delta); return radius - distance; } Vec A {4, 6}; Vec B {3, 2}; Vec C {4, 2}; float r = 2.; testSphere(A, C, r); // == -1 (outside) testSphere(B, C, r); // == 1 (inside)</span></span></code> </pre> <br>  La fonction testSphere () renvoie -1 pour le point A (c'est-√†-dire qu'il est √† l'ext√©rieur) et 1 pour B (c'est-√†-dire qu'il est √† l'int√©rieur).  Les signes √† distance ne sont qu'une astuce, vous permettant d'obtenir deux informations au lieu d'une dans le cas d'une valeur.  Un type de fonction similaire peut √©galement √™tre √©crit pour d√©crire un parall√©logramme (c'est exactement ce qui est effectu√© dans la fonction BoxTest). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/757/1cd/25b/7571cd25baa7d2f9cfbd01f62e84aef1.svg"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Signed distance point(p) to Box(c1,c2) float testRectangle(Vec p, Vec c1, Vec c2) { c1 = p + c1 * -1; c2 = c2 + position * -1; return min( min( min(c1.x, c2.x), min(c1.y, c2.y)), min(c1.z, c2.z)); } Vec A {3, 3}; Vec B {4, 6}; Vec C1 {2, 2}; Vec C2 {5, 4}; testRectangle(A, C1, C2); // 1.41 (inside) testRectangle(B, C1, C2); // -2.23 (outside)</span></span></code> </pre> <br>  Voyons maintenant ce qui se passe si vous retournez le signe de la valeur de retour. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dcd/017/bd8/dcd017bd89a9e9d3955c94be3645aa20.svg"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Signed distance point(p) to carved box(c1,c2) float testCarveBox(Vec p, Vec c1, Vec c2) { c1 = p + c1 * -1; c2 = c2 + position * -1; return -min( min( min(c1.x, c2.x), min(c1.y, c2.y)), min(c1.z, c2.z)); } Vec A {3, 3}; Vec B {4, 6}; Vec C1 {2, 2}; Vec C2 {5, 4}; testCarveBox(A, C1, C2); // == -1.41 (outside) testCarveBox(B, C1, C2); // == 2.23 (inside)</span></span></code> </pre> <br>  Maintenant, nous ne d√©crivons pas un objet solide, mais d√©clarons le monde entier solide et y d√©coupons un espace vide.  Les fonctions peuvent √™tre utilis√©es comme briques de construction qui, lorsqu'elles sont combin√©es, peuvent d√©crire des formes plus complexes.  En utilisant l'op√©rateur d'addition logique (fonction min), nous pouvons d√©couper une paire de rectangles l'un au-dessus de l'autre et le r√©sultat ressemblera √† ceci. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48b/f78/615/48bf786150f9d37af1f51fd12987162e.svg"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// Signed distance point to room float testRoom(Vec p) { Vec C1 {2, 4}; Vec C2 {5, 2}; // Lower room Vec C3 {3, 5}; Vec C4 {4, 4}; // Upper room // min() is the union of the two carved volumes. return min(testCarvedBox(p, C1, C2), testCarvedBox(p, C3, C4)); } Vec A {3, 3}; Vec B {4, 6}; testRoom(A, C1, C2); // == -1.41 (outside) testRoom(B, C1, C2); // == 1.00 (inside)</span></span></code> </pre> <br>  Si vous y r√©fl√©chissez, cela ressemble √† la pi√®ce que nous √©tudions, car la pi√®ce inf√©rieure s'exprime exactement de cette fa√ßon - √† l'aide de deux parall√©logrammes coup√©s. <br><br>  Maintenant, apr√®s avoir ma√Ætris√© la puissante connaissance de CSG, nous pouvons revenir au code et consid√©rer la fonction de base de donn√©es, qui est la plus difficile √† g√©rer. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HIT_NONE 0 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HIT_LETTER 1 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HIT_WALL 2 #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> HIT_SUN 3 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Sample the world using Signed Distance Fields. float QueryDatabase(Vec position, int &amp;hitType) { float distance = 1e9; Vec f = position; // Flattened position (z=0) fz = 0; char letters[15*4+1] = // 15 two points lines "5O5_" "5W9W" "5_9_" // P (without curve) "AOEO" "COC_" "A_E_" // I "IOQ_" "I_QO" // X "UOY_" "Y_]O" "WW[W" // A "aOa_" "aWeW" "a_e_" "cWiO"; // R (without curve) for (int i = 0; i &lt; sizeof(letters); i += 4) { Vec begin = Vec(letters[i] - 79, letters[i + 1] - 79) * .5; Vec e = Vec(letters[i + 2] - 79, letters[i + 3] - 79) * .5 + begin * -1; Vec o = f + (begin + e * min(-min((begin + f * -1) % e / (e % e), 0), 1) ) * -1; distance = min(distance, o % o); // compare squared distance. } distance = sqrtf(distance); // Get real distance, not square distance. // Two curves (for P and R in PixaR) with hard-coded locations. Vec curves[] = {Vec(-11, 6), Vec(11, 6)}; for (int i = 2; i--;) { Vec o = f + curves[i] * -1; distance = min(distance, ox &gt; 0 ? fabsf(sqrtf(o % o) - 2) : (oy += oy &gt; 0 ? -2 : 2, sqrtf(o % o)) ); } distance = powf(powf(distance, 8) + powf(position.z, 8), .125) - .5; hitType = HIT_LETTER; float roomDist ; roomDist = min(// min(A,B) = Union with Constructive solid geometry //-min carves an empty space -min(// Lower room BoxTest(position, Vec(-30, -.5, -30), Vec(30, 18, 30)), // Upper room BoxTest(position, Vec(-25, 17, -25), Vec(25, 20, 25)) ), BoxTest( // Ceiling "planks" spaced 8 units apart. Vec(fmodf(fabsf(position.x), 8), position.y, position.z), Vec(1.5, 18.5, -25), Vec(6.5, 20, 25) ) ); if (roomDist &lt; distance) distance = roomDist, hitType = HIT_WALL; float sun = 19.9 - position.y ; // Everything above 19.9 is light source. if (sun &lt; distance)distance = sun, hitType = HIT_SUN; return distance; }</span></span></span></span></code> </pre> <br>  Vous pouvez voir ici la fonction de "d√©couper" le parall√©logramme, dans lequel seuls deux rectangles sont utilis√©s pour construire toute la pi√®ce (notre cerveau fait le reste, il repr√©sente les murs).  L'√©chelle horizontale est une fonction CSG l√©g√®rement plus complexe utilisant la division du reste.  Et enfin, les lettres du mot PIXAR sont compos√©es de 15 lignes avec une paire ¬´origine / delta¬ª et deux cas particuliers pour les courbes dans les lettres P et R. <br><br><h2>  Ray marchant </h2><br><hr><br>  Ayant une base de donn√©es des fonctions CSG d√©crivant le monde, il nous suffit de sauter tous les rayons √©mis dans la fonction main ().  La marche des rayons utilise la fonction de distance.  Cela signifie que la position d'√©chantillonnage se d√©place d'une distance vers l'obstacle le plus proche. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Perform signed sphere marching // Returns hitType 0, 1, 2, or 3 and update hit position/normal int RayMarching(Vec origin, Vec direction, Vec &amp;hitPos, Vec &amp;hitNorm) { int hitType = HIT_NONE; int noHitCount = 0; float d; // distance from closest object in world. // Signed distance marching for (float total_d=0; total_d &lt; 100; total_d += d) if ((d = QueryDatabase(hitPos = origin + direction * total_d, hitType)) &lt; .01 || ++noHitCount &gt; 99) return hitNorm = !Vec(QueryDatabase(hitPos + Vec(.01, 0), noHitCount) - d, QueryDatabase(hitPos + Vec(0, .01), noHitCount) - d, QueryDatabase(hitPos + Vec(0, 0, .01), noHitCount) - d) , hitType; // Weird return statement where a variable is also updated. return 0; }</span></span></code> </pre> <br>  L'id√©e de la marche des rayons bas√©e sur la distance est d'avancer d'une distance vers l'objet le plus proche.  En fin de compte, le faisceau s'approche tellement de la surface qu'il peut √™tre consid√©r√© comme un point d'incidence. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e99/774/398/e997743989aa1cb22fb65e6d5d8e93f2.svg"></div><br>  Notez que la marche des rayons ne renvoie pas une v√©ritable intersection avec la surface, mais une approximation.  C'est pourquoi la marche s'arr√™te dans le code lorsque d &lt;0,01f. <br><br><h2>  Tout mettre ensemble: √©chantillonnage </h2><br><hr><br>  L'enqu√™te sur le traceur est presque termin√©e.  Il nous manque un pont qui relie la fonction main () au rayon marcher.  Cette derni√®re partie, que j'ai renomm√©e ¬´Trace¬ª, est le ¬´cerveau¬ª dans lequel les rayons rebondissent ou s'arr√™tent, selon ce qu'ils rencontrent. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Vec </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Trace</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Vec origin, Vec direction)</span></span></span><span class="hljs-function"> </span></span>{ Vec sampledPosition, normal, color, attenuation = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-function"><span class="hljs-function">Vec </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lightDirection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(!Vec(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">.6</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">.6</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params">))</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// Directional light for (int bounceCount = 3; bounceCount--;) { int hitType = RayMarching(origin, direction, sampledPosition, normal); if (hitType == HIT_NONE) break; // No hit. This is over, return color. if (hitType == HIT_LETTER) { // Specular bounce on a letter. No color acc. direction = direction + normal * ( normal % direction * -2); origin = sampledPosition + direction * 0.1; attenuation = attenuation * 0.2; // Attenuation via distance traveled. } if (hitType == HIT_WALL) { // Wall hit uses color yellow? float incidence = normal % lightDirection; float p = 6.283185 * randomVal(); float c = randomVal(); float s = sqrtf(1 - c); float g = normal.z &lt; 0 ? -1 : 1; float u = -1 / (g + normal.z); float v = normal.x * normal.y * u; direction = Vec(v, g + normal.y * normal.y * u, -normal.y) * (cosf(p) * s) + Vec(1 + g * normal.x * normal.x * u, g * v, -g * normal.x) * (sinf(p) * s) + normal * sqrtf(c); origin = sampledPosition + direction * .1; attenuation = attenuation * 0.2; if (incidence &gt; 0 &amp;&amp; RayMarching(sampledPosition + normal * .1, lightDirection, sampledPosition, normal) == HIT_SUN) color = color + attenuation * Vec(500, 400, 100) * incidence; } if (hitType == HIT_SUN) { // color = color + attenuation * Vec(50, 80, 100); break; // Sun Color } } return color; }</span></span></code> </pre> <br>  J'ai exp√©riment√© un peu avec cette fonction pour changer le nombre maximum de r√©flexions de faisceau autoris√©es.  La valeur "2" donne aux lettres une couleur Vantablack laqu√©e d'une beaut√© surprenante <sup>[4]</sup> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d10/940/a3e/d10940a3ed7efab3271097904ce50d77.png"></div><br>  <i>1</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0c/8b2/c3b/e0c8b2c3b249057b1f5fd0d166e12014.png"></div><br>  <i>2</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fb9/52c/4df/fb952c4dfd0a4cb14245cedd060dcf05.png"></div><br>  <i>3</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65c/2f5/716/65c2f5716578caaa2fcc454a49376578.png"></div><br>  <i>4</i> <br><br><h2>  Code source compl√®tement nettoy√© </h2><br><hr><br>  Pour tout assembler, j'ai cr√©√© un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">code source</a> compl√®tement propre. <br><br><h2>  Les r√©f√©rences </h2><br><hr><br>  [1] Source: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">publication Twitter de lexfrench du 8 octobre 2018.</a> <br><br>  [2] Source: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Wikipedia: format d'image NetPBM</a> <br><br>  [3] Source: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Visualisation effectu√©e sur le MacBook Pro le plus puissant, 2017</a> <br><br>  [4] Source: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Wikipedia: Vantablack</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr434528/">https://habr.com/ru/post/fr434528/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr434514/index.html">"Secrets" DPAPI ou DPAPI pour Pentesters</a></li>
<li><a href="../fr434516/index.html">Un moyen simple de r√©pondre √† vos aspirations professionnelles.</a></li>
<li><a href="../fr434518/index.html">Applaudissements et acclamations: drame soigneusement contr√¥l√© dans les magasins Apple</a></li>
<li><a href="../fr434522/index.html">Mod√®les de justification des t√¢ches et antipatterns</a></li>
<li><a href="../fr434524/index.html">Kubernetes Ingress √† travers les yeux d'un d√©butant</a></li>
<li><a href="../fr434530/index.html">Calendrier par d√©faut, correctifs dans LDAP et autres innovations dans Zimbra 8.8.11</a></li>
<li><a href="../fr434532/index.html">L'histoire d'un projet: lorsqu'une √©quipe n'a pas de d√©veloppeur senior</a></li>
<li><a href="../fr434534/index.html">ONYX BOOX ¬´Mon premier livre¬ª: une lecture inoffensive pour maman et b√©b√©</a></li>
<li><a href="../fr434538/index.html">La lutte pour l'espace: ce qui se passe sur le march√© de l'Internet par satellite</a></li>
<li><a href="../fr434540/index.html">Que faire des gens qui seront remplac√©s par des robots?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>