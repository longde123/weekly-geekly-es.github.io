<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤œğŸ¿ ğŸ‘©ğŸ¿â€ğŸ³ ğŸ¦ Unit testing di Laravel ğŸ‘¨ğŸ¾â€ğŸš’ ğŸ’… ğŸ‘´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di antara diskusi di masyarakat, saya sering mendengar pendapat bahwa pengujian unit di Laravel salah, rumit, dan tes itu sendiri panjang dan tidak me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unit testing di Laravel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457866/"><p>  Di antara diskusi di masyarakat, saya sering mendengar pendapat bahwa pengujian unit di Laravel salah, rumit, dan tes itu sendiri panjang dan tidak memberikan manfaat apa pun.  Karena itu, beberapa menulis tes ini, membatasi diri mereka hanya untuk tes fitur, dan tes unit manfaat menuju 0. <br>  Saya juga pernah berpikir begitu, tetapi begitu saya memikirkannya dan bertanya pada diri sendiri - mungkin saya tidak tahu cara memasaknya? </p><br><p>  Untuk beberapa waktu saya mengerti dan di pintu keluar saya memiliki pemahaman baru tentang tes unit, dan tes menjadi jelas, ramah, cepat dan mulai membantu saya. <br>  Saya ingin berbagi pemahaman saya dengan komunitas, dan bahkan lebih memahami topik ini, membuat tes saya lebih baik. </p><a name="habracut"></a><br><h2 id="nemnogo-filosofii-i-ogranicheniy">  Sedikit filosofi dan batasan </h2><br><p>  Laravel adalah semacam kerangka kerja di beberapa tempat.  Terutama dari segi fasad dan Eloquent.  Saya tidak akan menyentuh pada diskusi atau kecaman dari poin-poin ini, tetapi saya akan menunjukkan bagaimana saya menggabungkannya dengan unit test. <br>  Saya menulis tes setelah (atau pada saat yang sama) menulis kode utama.  Mungkin pendekatan saya tidak akan kompatibel dengan pendekatan TDD atau memerlukan penyesuaian parsial. </p><br><p> Pertanyaan paling penting yang saya tanyakan pada diri sendiri sebelum menulis tes adalah "apa sebenarnya yang ingin saya uji?".  Ini adalah masalah penting.  Gagasan inilah yang memungkinkan saya untuk mempertimbangkan kembali pandangan saya tentang penulisan tes unit dan kode proyek itu sendiri. </p><br><p>  Tes harus stabil dan minimal tergantung pada lingkungan.  Jika, ketika Anda membuat mutasi, tes Anda gagal, kemungkinan besar itu bagus.  Sebaliknya, jika mereka tidak jatuh, mereka mungkin tidak terlalu baik. </p><br><p>  Di luar kotak, Laravel mendukung 3 jenis tes: </p><br><ul><li>  Browser </li><li>  Fitur </li><li>  Unit </li></ul><br><p>  Saya terutama akan berbicara tentang tes Unit. </p><br><p>  Saya tidak menguji semua kode melalui unit test (mungkin ini tidak benar).  Saya tidak menguji beberapa kode sama sekali (lebih lanjut tentang ini di bawah). </p><br><p>  Jika moque digunakan dalam tes, jangan lupa untuk melakukan Mockery :: close () pada tearDown. </p><br><p>  Beberapa contoh tes "diambil dari Internet." </p><br><h2 id="kak-ya-testiruyu">  Bagaimana saya menguji </h2><br><p>  Di bawah ini saya akan mengelompokkan contoh uji menurut kelompok kelas dan mencoba memberikan contoh uji untuk setiap kelompok kelas.  Bagi sebagian besar kelompok kelas, saya tidak akan memberikan contoh kode itu sendiri. </p><br><h3 id="middleware">  Middleware </h3><br><p>  Untuk pengujian unit middleware, saya membuat objek dari kelas Permintaan, sebuah objek dari Middleware yang diinginkan, kemudian saya memanggil metode pegangan dan menjalankan pernyataan yang diperlukan.  Middleware sesuai dengan tindakan yang dilakukan dapat dibagi menjadi 3 kelompok: </p><br><ul><li>  mengubah objek permintaan (mengubah permintaan tubuh, atau sesi) </li><li>  pengarahan ulang (mengubah status respons) </li><li>  tidak melakukan apa-apa dengan objek permintaan <br>  Mari kita coba memberikan contoh tes untuk setiap kelompok: </li></ul><br><p>  Misalkan kita memiliki Middleware berikut, yang tugasnya memodifikasi bidang judul: </p><br><pre><code class="php hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">TitlecaseMiddleware</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($request, Closure $next)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ($request-&gt;title) { $request-&gt;merge([ <span class="hljs-string"><span class="hljs-string">'title'</span></span> =&gt; title_case($request-&gt;title) ]); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> $next($request); } }</code> </pre> <br><p>  Tes untuk Middleware serupa mungkin terlihat seperti ini: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testChangeTitleToTitlecase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $request = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Request; $request-&gt;merge([ <span class="hljs-string"><span class="hljs-string">'title'</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">'Title is in mixed CASE'</span></span> ]); $middleware = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TitlecaseMiddleware; $middleware-&gt;handle($request, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">($req)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertEquals(<span class="hljs-string"><span class="hljs-string">'Title Is In Mixed Case'</span></span>, $req-&gt;title); }); }</code> </pre> <br><p>  Tes untuk kelompok 2 dan 3 terdiri dari rencana semacam itu, masing-masing: </p><br><pre> <code class="php hljs">$response = $middleware-&gt;handle($request, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{}); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertEquals($response-&gt;getStatusCode(), <span class="hljs-number"><span class="hljs-number">302</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   $this-&gt;assertEquals($response, null); //      request</span></span></code> </pre> <br><h3 id="request-class">  Minta kelas </h3><br><p>  Tugas utama grup kelas ini adalah otorisasi dan validasi permintaan. </p><br><p>  Saya tidak menguji kelas-kelas ini melalui tes unit (saya akui bahwa ini mungkin tidak benar), hanya melalui tes fitur.  Menurut pendapat saya, tes unit berlebihan untuk kelas-kelas ini, tetapi saya menemukan beberapa contoh menarik tentang bagaimana hal ini dapat dilakukan.  Mungkin mereka akan membantu Anda jika Anda memutuskan untuk menguji kelas unit permintaan Anda dengan tes: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://medium.com/@daaaan/a-guide-to-unit-testing-laravel-form-requests-in-a-different-way-f1bdb6d86053</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://stackoverflow.com/questions/36978147/unit-test-laravels-formrequest</a> </li></ul><br><h3 id="controller">  Pengendali </h3><br><p>  Saya juga tidak menguji pengontrol melalui unit test.  Tetapi ketika mengujinya, saya menggunakan satu fitur yang ingin saya bicarakan. </p><br><p>  Pengendali, menurut saya, harus ringan.  Tugas mereka adalah mendapatkan permintaan yang benar, memanggil layanan dan repositori yang diperlukan (karena kedua istilah ini "asing" bagi Laravel, saya akan menjelaskan terminologi saya di bawah), mengembalikan jawabannya.  Terkadang memicu suatu peristiwa, Pekerjaan, dll. <br>  Dengan demikian, ketika menguji melalui pengujian fitur, kita tidak hanya perlu memanggil controller dengan parameter yang diperlukan dan memeriksa jawabannya, tetapi juga mengunci layanan yang diperlukan dan memverifikasi bahwa mereka benar-benar dipanggil (atau tidak dipanggil).  Terkadang - membuat catatan dalam database. </p><br><p>  Contoh uji pengontrol dengan tiruan kelas layanan: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testProductCategorySync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $service = Mockery::mock(\App\Services\Product::class); app()-&gt;instance(\App\Services\Product::class, $service); $service-&gt;shouldReceive(<span class="hljs-string"><span class="hljs-string">'sync'</span></span>)-&gt;once(); $response = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;post(<span class="hljs-string"><span class="hljs-string">'/api/v1/sync/eventsCallback'</span></span>, [ <span class="hljs-string"><span class="hljs-string">"eventType"</span></span> =&gt; <span class="hljs-string"><span class="hljs-string">"PRODUCT_SYNC"</span></span> ]); $response-&gt;assertStatus(<span class="hljs-number"><span class="hljs-number">200</span></span>); }</code> </pre> <br><p>  Contoh uji pengontrol dengan tiruan fasad (dalam kasus kami, peristiwa, tetapi dengan analogi dilakukan untuk fasad Laravel lainnya): </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testChangeCart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Event::fake(); $user = factory(User::class)-&gt;create(); Passport::actingAs( $user ); $response = <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;post(<span class="hljs-string"><span class="hljs-string">'/api/v1/cart/update'</span></span>, [ <span class="hljs-string"><span class="hljs-string">'products'</span></span> =&gt; [ [ <span class="hljs-comment"><span class="hljs-comment">// our changed data ] ], ]); $data = json_decode($response-&gt;getContent()); $response-&gt;assertStatus(200); $this-&gt;assertEquals($user-&gt;id, $data-&gt;data-&gt;userId); // and assert other data from response Event::assertDispatched(CartChanged::class); }</span></span></code> </pre> <br><h3 id="service-i-repositories">  Layanan dan Repositori </h3><br><p>  Jenis kelas ini di luar kotak.  Saya mencoba untuk menjaga pengendali tetap tipis, jadi saya menempatkan semua pekerjaan ekstra ke dalam salah satu dari kelompok kelas ini. </p><br><p>  Saya menentukan perbedaan di antara mereka sebagai berikut: </p><br><ul><li>  Jika saya perlu menerapkan beberapa logika bisnis, maka saya meletakkan ini di lapisan layanan yang sesuai (kelas). </li><li>  Dalam semua kasus lain, saya meletakkan ini di grup kelas repositori.  Sebagai aturan, fungsional dengan Eloquent pergi ke sana.  Saya mengerti bahwa ini bukan definisi yang tepat untuk level repositori.  Saya juga mendengar bahwa beberapa orang menanggung segala hal yang berkaitan dengan Eloquent dalam model.  Pendekatan saya adalah semacam kompromi, menurut saya, meskipun "secara akademis" tidak sepenuhnya benar. </li></ul><br><p>  Untuk kelas-kelas Repositori, saya hampir tidak menulis tes. </p><br><p>  Contoh uji kelas layanan di bawah ini: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testUpdateCart</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Event::fake(); $cartService = resolve(CartService::class); $cartRepo = resolve(CartRepository::class); $user = factory(User::class)-&gt;make(); $cart = $cartRepo-&gt;getCart($user); <span class="hljs-comment"><span class="hljs-comment">// set data $data = [ ]; $newCart = $cartService-&gt;updateForUser($user, $data); $this-&gt;assertEquals($data, $newCart-&gt;toArray()); Event::assertDispatched(CartChanged::class, 1); }</span></span></code> </pre> <br><h3 id="event-listener-jobs">  Event-Listener, Jobs </h3><br><p>  Kelas-kelas ini diuji hampir oleh prinsip umum - kami menyiapkan data yang diperlukan untuk pengujian;  Kami memanggil kelas yang diinginkan dari framework dan memeriksa hasilnya. <br>  Contoh untuk Pendengar: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testHandle</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $user = factory(User::class)-&gt;create(); $cart = Cart::create([ <span class="hljs-string"><span class="hljs-string">'userId'</span></span> =&gt; $user-&gt;id, <span class="hljs-comment"><span class="hljs-comment">// other needed data ]); $listener = new CreateTaskForSyncCart(); $listener-&gt;handle(new CartChanged($cart)); $job = // get our job $this-&gt;assertSame(json_encode($cart-&gt;products), $job-&gt;payload); $this-&gt;assertSame($user-&gt;id, $job-&gt;user_id); // some additional asserts. Work with this data simplest for example $this-&gt;assertTrue($updatedAt-&gt;equalTo($job-&gt;last_updated_at)); }</span></span></code> </pre> <br><h3 id="console-commands">  Konsol konsol </h3><br><p>  Saya menganggap perintah konsol sebagai beberapa jenis pengontrol yang dapat menghasilkan (dan melakukan manipulasi yang lebih kompleks dengan input-output konsol yang dijelaskan dalam dokumentasi) data.  Dengan demikian, tes diperoleh mirip dengan controller: kami memeriksa bahwa metode layanan yang diperlukan dipanggil, peristiwa dipicu (atau tidak), dan kami juga memeriksa interaksi dengan konsol (output atau permintaan data). </p><br><p>  Contoh tes serupa: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testSendCartSyncDataEmptyJobs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $service = m::mock(CartJobsRepository::class); app()-&gt;instance(CartJobsRepository::class, $service); $service-&gt;shouldReceive(<span class="hljs-string"><span class="hljs-string">'getAll'</span></span>) -&gt;once()-&gt;andReturn(collect([])); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;artisan(<span class="hljs-string"><span class="hljs-string">'sync:cart'</span></span>) -&gt;expectsOutput(<span class="hljs-string"><span class="hljs-string">'Get all jobs for sending...'</span></span>) -&gt;expectsOutput(<span class="hljs-string"><span class="hljs-string">'All count for sending: 0'</span></span>) -&gt;expectsOutput(<span class="hljs-string"><span class="hljs-string">'Empty jobs'</span></span>) -&gt;assertExitCode(<span class="hljs-number"><span class="hljs-number">0</span></span>); }</code> </pre> <br><h3 id="otdelnye-vneshnie-biblioteki">  Pisahkan perpustakaan eksternal </h3><br><p>  Sebagai aturan, jika pustaka terpisah memiliki fitur untuk pengujian unit, maka pustaka tersebut dijelaskan dalam dokumentasi.  Dalam kasus lain, bekerja dengan kode ini diuji mirip dengan lapisan layanan.  Tidak masuk akal untuk menutupi perpustakaan sendiri dengan tes (hanya jika Anda ingin mengirim PR ke perpustakaan ini) dan Anda harus menganggapnya sebagai semacam kotak hitam. </p><br><p>  Pada banyak proyek, saya harus berinteraksi melalui API dengan layanan lain.  Laravel sering menggunakan perpustakaan Guzzle untuk tujuan ini.  Bagiku nyaman untuk menempatkan semua pekerjaan dengan layanan lain ke dalam kelas terpisah dari layanan NetworkService.  Ini membuatnya lebih mudah bagi saya untuk menulis dan menguji kode utama, dan membantu untuk membakukan jawaban dan penanganan kesalahan. </p><br><p>  Saya memberikan contoh beberapa tes untuk kelas NetworkService saya: </p><br><pre> <code class="php hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testSuccessfulSendNetworkService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $mockHandler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MockHandler([ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Response(<span class="hljs-number"><span class="hljs-number">200</span></span>), ]); $handler = HandlerStack::create($mockHandler); $client = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Client([<span class="hljs-string"><span class="hljs-string">'handler'</span></span> =&gt; $handler]); app()-&gt;instance(\GuzzleHttp\Client::class, $client); $networkService = resolve(NetworkService::class); $response = $networkService-&gt;sendRequestToSite(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;assertEquals(<span class="hljs-string"><span class="hljs-string">'200'</span></span>, $response-&gt;getStatusCode()); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testUnsupportedMethodSendNetworkService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $networkService = resolve(NetworkService::class); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;expectException(<span class="hljs-string"><span class="hljs-string">'\InvalidArgumentException'</span></span>); $networkService-&gt;sendRequestToSite(<span class="hljs-string"><span class="hljs-string">'PUT'</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">testUnsetConfigUrlNetworkService</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ $networkService = resolve(NetworkService::class); Config::shouldReceive(<span class="hljs-string"><span class="hljs-string">'get'</span></span>) -&gt;once() -&gt;with(<span class="hljs-string"><span class="hljs-string">'app.api_url'</span></span>) -&gt;andReturn(<span class="hljs-string"><span class="hljs-string">''</span></span>); Config::shouldReceive(<span class="hljs-string"><span class="hljs-string">'get'</span></span>) -&gt;once() -&gt;with(<span class="hljs-string"><span class="hljs-string">'app.api_token'</span></span>) -&gt;andReturn(<span class="hljs-string"><span class="hljs-string">'token'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">$this</span></span>-&gt;expectException(<span class="hljs-string"><span class="hljs-string">'\InvalidArgumentException'</span></span>); $networkService-&gt;sendRequestToApi(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'/'</span></span>); }</code> </pre> <br><h2 id="vyvody">  Kesimpulan </h2><br><p>  Pendekatan ini memungkinkan saya untuk menulis kode yang lebih baik dan lebih mudah dipahami, untuk mengambil keuntungan dari pendekatan SOLID dan SRP saat menulis kode.  Tes saya menjadi lebih cepat, dan yang paling penting - mereka mulai menguntungkan saya. </p><br><p>  Dengan refactoring aktif ketika memperluas atau mengubah fungsionalitas, kami segera melihat apa yang sebenarnya jatuh dan kami dapat dengan cepat dan akurat memperbaiki kesalahan tanpa melepaskannya dari lingkungan lokal.  Ini membuat koreksi kesalahan semurah mungkin. </p><br><p>  Saya berharap bahwa prinsip dan pendekatan yang saya jelaskan akan membantu Anda menangani pengujian unit di Laravel dan menjadikan unit test asisten Anda dalam pengembangan kode. </p><br><p>  Tuliskan tambahan dan komentar Anda. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id457866/">https://habr.com/ru/post/id457866/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id457852/index.html">Analisis: bagaimana masalah dengan otoritas AS akan mempengaruhi Huawei dan bisnis TI</a></li>
<li><a href="../id457854/index.html">Halo dari para programmer tahun 80-an</a></li>
<li><a href="../id457860/index.html">Mengembangkan aplikasi untuk streaming menggunakan Node.js dan Bereaksi</a></li>
<li><a href="../id457862/index.html">iOS Digest No. 8 (14 Juni - 27 Juni)</a></li>
<li><a href="../id457864/index.html">Mitos dan legenda analisis sistem atau apa yang dilakukan analis di bank</a></li>
<li><a href="../id457870/index.html">Proyek membangun infrastruktur dengan buruh pelabuhan</a></li>
<li><a href="../id457872/index.html">Bagaimana cara mengatur waktu dan berhenti menunda-nunda?</a></li>
<li><a href="../id457874/index.html">Mengapa karyawan kembali? Kisah tentang berangkat dan kembali</a></li>
<li><a href="../id457876/index.html">Terjemahan: IEEE 802.15.4z Standar. Apa yang menanti kita di masa depan?</a></li>
<li><a href="../id457884/index.html">Sovereign Internet - klarifikasi pesanan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>