<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ô üòó üßëüèª‚Äçü§ù‚Äçüßëüèª JavaScript-Objektdetails üëàüèº üé§ ‚ôüÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Autor des Materials, dessen √úbersetzung wir heute ver√∂ffentlichen, sagt, dass JavaScript-Objekte viele Dinge enthalten, deren Existenz Sie nicht e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript-Objektdetails</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/438794/">  Der Autor des Materials, dessen √úbersetzung wir heute ver√∂ffentlichen, sagt, dass JavaScript-Objekte viele Dinge enthalten, deren Existenz Sie nicht einmal vermuten k√∂nnen, und die sie in der t√§glichen Arbeit verwenden.  Objekte in JavaScript sind sehr einfach zu erstellen, bequem zu bearbeiten, sie scheinen verst√§ndlich und flexibel zu sein, und viele Programmierer denken einfach nicht daran, dass die Objekte tats√§chlich nicht so einfach sind. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/o8/ga/z0/o8gaz0tewtkdqmryqsar9vdswfc.png"></a> <br><blockquote>  <b>NB:</b> Informationen aus der Ver√∂ffentlichung in der Praxis sollten sehr sorgf√§ltig und unter Aufsicht erfahrener Kollegen angewendet werden. </blockquote><a name="habracut"></a><br>  Hier sprechen wir dar√ºber, was in den Tiefen von Objekten verborgen ist, und diskutieren die Feinheiten der Arbeit mit ihnen. <br>  Nachdem Sie dieses Material beherrschen, kennen Sie die Antworten auf die folgenden Fragen: <br><br><ul><li>  Wie kann eine Eigenschaft eines Objekts nicht gel√∂scht werden? </li><li>  Was sind Eigenschaften mit Zugriffsmethoden und welche Funktionen haben sie? </li><li>  Wie macht man eine Immobilie unver√§nderlich oder versteckt? </li><li> Warum sind einige Eigenschaften in <code>for-in</code> Schleifen oder in den Ergebnissen der <code>Object.keys()</code> -Methode nicht sichtbar, und einige sind sichtbar? </li><li>  Wie kann man ein Objekt vor √Ñnderungen sch√ºtzen? </li><li>  So verstehen Sie einen Code, der dem folgenden √§hnelt: </li></ul><br><pre> <code class="javascript hljs">obj.id = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj.id) <span class="hljs-comment"><span class="hljs-comment">// =&gt; '101' (5    )</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Arten von Objekteigenschaften</font> </h2><br><h3>  <font color="#3AC1EF">‚ñç Datenspeichereigenschaften</font> </h3><br>  Sie haben wahrscheinlich unz√§hlige √§hnliche Objekte erstellt: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Arfat'</span></span>, <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span> } obj.name <span class="hljs-comment"><span class="hljs-comment">// =&gt; 'Arfat'</span></span></code> </pre> <br>  Die <code>name</code> und <code>id</code> Eigenschaften des <code>obj</code> Objekts werden als <code>obj</code> oder ‚Äû <code>obj</code> ‚Äú bezeichnet.  Dies sind bekannte Eigenschaften, die st√§ndig im JavaScript-Code enthalten sind.  Welche anderen Arten von Eigenschaften k√∂nnen Objekte haben? <br><br><h3>  <font color="#3AC1EF">‚ñç Eigenschaften mit Zugriffsmethoden</font> </h3><br>  Diese Eigenschaften werden auch als Getter und Setter bezeichnet und sind auch in anderen Programmiersprachen wie C # oder Python zu finden.  Eine Eigenschaft mit Accessor-Eigenschaft ist eine Kombination aus zwei Funktionen - <code>get</code> und <code>set</code> . <br><br>  Wenn Sie solche Eigenschaften deklarieren, wird anstelle des herk√∂mmlichen Konstrukts vom <code>: </code> die folgende Syntax verwendet: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> accessorObj = { get name() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Arfat'</span></span>; } }; accessorObj.name; <span class="hljs-comment"><span class="hljs-comment">// =&gt; 'Arfat' const dataObj = { name: 'Arfat', }; dataObj.name; // =&gt; 'Arfat'</span></span></code> </pre> <br>  Schauen Sie sich das <code>accesorObj</code> Objekt an und vergleichen Sie es mit dem <code>dataObj</code> Objekt.  Anscheinend zeigen sie jetzt das gleiche Verhalten.  Bei der Beschreibung des ersten Objekts haben wir das Schl√ºsselwort <code>get</code> , gefolgt von der Deklaration der Funktion.  Um auf eine √§hnliche Eigenschaft zuzugreifen, obwohl sie durch eine Funktion dargestellt wird, m√ºssen Sie keine Klammern nach dem Eigenschaftsnamen setzen, um diese Funktion aufzurufen.  Das hei√üt, ein Design wie <code>accessorObj.name();</code>  falsch. <br><br>  Beim Versuch, auf die Eigenschaft <code>accessorObj.name</code> zuzugreifen, <code>accessorObj.name</code> beim Versuch, sie zu lesen, wird die entsprechende Funktion ausgef√ºhrt und der zur√ºckgegebene Wert wird zum Wert der Eigenschaft <code>name</code> . <br><br>  Die <code>get</code> Funktionen werden als Getter bezeichnet und sind f√ºr das Abrufen der Werte verantwortlich.  Wenn wir unser Beispiel fortsetzen und versuchen, den Wert der <code>name</code> Eigenschaft des <code>accessorObj</code> Objekts zu √§ndern, indem wir beispielsweise den Befehl <code>accessorObj.name = 'New Person';</code>  dann stellt sich heraus, dass nichts passieren wird.  Der Punkt hier ist, dass die Setter-Funktion nicht mit der <code>name</code> verkn√ºpft ist.  Mit solchen Funktionen k√∂nnen Sie die Reihenfolge anpassen, in der den Eigenschaften von Objekten, deren Zugriff mithilfe von Gettern organisiert wird, neue Werte zugewiesen werden. <br><br>  So sieht eine Objektdeklaration mit einem Getter und einem Setter aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> accessorObj = { <span class="hljs-attr"><span class="hljs-attr">_name</span></span>: <span class="hljs-string"><span class="hljs-string">'Arfat'</span></span>, get name() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._name; }, set name(value) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._name = value; } };</code> </pre> <br>  Die Setter-Funktion empf√§ngt, was sie versucht, der Eigenschaft des Objekts als Parameter zuzuweisen.  Jetzt k√∂nnen Sie etwas in der Eigenschaft des Objekts speichern.  In diesem Fall erstellen wir eine "private" Eigenschaft des <code>_name</code> Objekts.  Das erste Zeichen des Namens einer solchen Eigenschaft ist ein Unterstrich, der nichts weiter als ein Hinweis f√ºr den Programmierer ist und angibt, dass diese Eigenschaft f√ºr die internen Anforderungen des Objekts bestimmt ist.  Au√üerdem arbeiten wir damit, wenn wir auf die Eigenschaft des Namensobjekts zugreifen, auf die der Zugriff vom Getter und Setter geregelt wird. <br><br>  Gleichzeitig k√∂nnen wir in der Getter-Funktion den Wert der Eigenschaft <code>_name</code> √§ndern, bevor wir ihn zur√ºckgeben. <br><br>  So k√∂nnte es aussehen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { get name() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._name.toUpperCase(); }, set name(value) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._name = value; }, get id() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._id.toString(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">//        }, set id(value) {   this._id = value; } } obj.name = 'Arfat'; obj.name; // =&gt; 'ARFAT' obj.id = 5; obj.id; // =&gt; '101</span></span></code> </pre> <br>  Dieses Programm enth√§lt √ºbrigens die Antwort auf eine der am Anfang des Artikels gestellten Fragen, die die Analyse von auf den ersten Blick unverst√§ndlichem Code betrifft. <br><br>  Warum sollte jemand Eigenschaften mit Zugriffsmethoden ben√∂tigen, wenn Sie sicher mit normalen Eigenschaften arbeiten k√∂nnen?  Sie k√∂nnen beispielsweise erforderlich sein, um Informationen zu Eigenschaftslesevorg√§ngen zu protokollieren oder einen Verlauf von √Ñnderungen an Eigenschaftswerten zu speichern.  Eigenschaften mit Zugriffsmethoden bieten uns alle M√∂glichkeiten, Daten mithilfe von Funktionen zu verarbeiten, und die Einfachheit, mit gew√∂hnlichen Eigenschaften zu arbeiten.  Lesen Sie hier mehr √ºber die Verwendung solcher Eigenschaften. <br><br>  Wie unterscheidet JavaScript zwischen gew√∂hnlichen Eigenschaften, in denen Daten gespeichert werden, von Eigenschaften mit Zugriffsmethoden?  Finde das heraus. <br><br><h2>  <font color="#3AC1EF">Objekteigenschaftsbeschreibungen</font> </h2><br>  Auf den ersten Blick scheint es eine direkte Entsprechung zwischen den Schl√ºsseln und den in Objekten gespeicherten Werten zu geben.  Dies ist jedoch nicht ganz richtig. <br><br><h3>  <font color="#3AC1EF">‚ñç Eigenschaftsattribute</font> </h3><br>  Jeder Schl√ºssel des Objekts ist einer Reihe von Attributen zugeordnet, die die Eigenschaften des diesem Schl√ºssel zugeordneten Werts bestimmen.  Diese Attribute k√∂nnen auch als Metadaten betrachtet werden, die ein <code>: </code> Paar beschreiben. <br><br>  Attribute werden verwendet, um den Status der Eigenschaften von Objekten festzulegen und zu beschreiben.  Die Menge der Eigenschaftsattribute wird als Deskriptor bezeichnet.  Es gibt sechs Eigenschaftsattribute: <br><br><ul><li> <code>[[Value]]</code> </li> <li> <code>[[Get]]</code> </li> <li> <code>[[Set]]</code> </li> <li> <code>[[Writable]]</code> </li> <li> <code>[[Enumerable]]</code> </li> <li> <code>[[Configurable]]</code> </li> </ul><br>  Warum sind Eigenschaftsattributnamen in dieser Liste im Konstrukt <code>[[]]</code> ?  Doppelte Klammern zeigen an, dass dies Entit√§ten sind, die von den internen Mechanismen der Sprache verwendet werden.  Ein JS-Programmierer kann nicht direkt auf diese Eigenschaften zugreifen.  Um sie zu beeinflussen, werden geeignete Methoden angewendet. <br><br>  Betrachten Sie das folgende Bild <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von hier</a> , auf dem Sie das Objekt und die Attribute seiner Eigenschaften sehen k√∂nnen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/613/e59/d25/613e59d25aa164d3fb5dc1acbe49e25f.png"></div><br>  <i><font color="#999999">Objekt und Attribute seiner Eigenschaften</font></i> <br><br>  Unser Objekt hat 2 Schl√ºssel - <code>x</code> und <code>y</code> .  Dar√ºber hinaus ist jedem von ihnen eine Reihe von Attributen zugeordnet. <br><br>  Wie k√∂nnen Sie mithilfe von JavaScript Informationen √ºber das Objekt abrufen, √§hnlich wie in der vorherigen Abbildung?  <code>Object.getOwnPropertyDescriptor()</code> k√∂nnen Sie die Funktion <code>Object.getOwnPropertyDescriptor()</code> verwenden.  Es nimmt ein Objekt und den Namen seiner Eigenschaft und gibt dann ein Objekt zur√ºck, das die Attribute dieser Eigenschaft enth√§lt.  Hier ist ein Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptor(object, <span class="hljs-string"><span class="hljs-string">'x'</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* { value: 5, writable: true, enumerable: true, configurable: true } */</span></span></code> </pre> <br>  Es ist zu beachten, dass die Zusammensetzung der Attribute einer bestimmten Eigenschaft von ihrem Typ abh√§ngt.  Alle sechs Attribute derselben Eigenschaft werden nicht gefunden. <br><br><ul><li>  Wenn es sich um Eigenschaften mit Daten handelt, haben sie nur die Attribute <code>[[Value]]</code> , <code>[[Writable]]</code> , <code>[[Enumerable]]</code> und <code>[[Configurable]]</code> . </li><li>  Eigenschaften mit Zugriffsmethoden haben anstelle der Attribute <code>[[Value]]</code> und <code>[[Writable]]</code> Attribute <code>[[Get]]</code> und <code>[[Set]]</code> . </li></ul><br><h3>  <font color="#3AC1EF">‚ñç [[Wert]]</font> </h3><br>  Dieses Attribut speichert, was zur√ºckgegeben wird, wenn versucht wird, den Eigenschaftswert eines Objekts abzurufen.  Das hei√üt, wenn wir im vorherigen Beispiel eine Konstruktion des Formulars <code>object.x</code> , erhalten wir, was im Attribut <code>[[Value]]</code> gespeichert ist.  Das gleiche passiert, wenn Sie versuchen, die Eigenschaften eines Objekts in eckigen Klammern zu lesen. <br><br><h3>  <font color="#3AC1EF">‚ñç [[Get]]</font> </h3><br>  Dieses Attribut speichert einen Verweis auf eine Funktion, die eine Getter-Eigenschaft ist.  Diese Funktion wird ohne Argumente aufgerufen, wenn versucht wird, den Wert einer Eigenschaft zu lesen. <br><br><h3>  <font color="#3AC1EF">‚ñç [[Einstellen]]</font> </h3><br>  Hier wird der Link zu der Funktion gespeichert, die beim Erstellen der Setter-Eigenschaft deklariert wurde.  Es wird mit einem Argument aufgerufen, das den Wert darstellt, den sie der Eigenschaft zuweisen wollten, dh es wird bei jeder Operation zum Zuweisen eines neuen Werts zu einer Eigenschaft aufgerufen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { set x(val) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(val)   <span class="hljs-comment"><span class="hljs-comment">// =&gt; 23 } } obj.x = 23;</span></span></code> </pre> <br>  In diesem Beispiel wird die rechte Seite des Ausdrucks als <code>val</code> Argument an die Setter-Funktion √ºbergeben.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist der</a> Code, der die Verwendung von Setzern und Gettern demonstriert. <br><br><h3>  <font color="#3AC1EF">‚ñç [[Beschreibbar]]</font> </h3><br>  Dieses Attribut enth√§lt einen booleschen Wert.  Es gibt an, ob der Eigenschaftswert √ºberschrieben werden kann oder nicht.  Wenn hier <code>false</code> gespeichert ist, schlagen Versuche, den Wert der Eigenschaft zu √§ndern, fehl. <br><br><h3>  <font color="#3AC1EF">‚ñç [[Aufz√§hlbar]]</font> </h3><br>  Hier wird auch ein logischer Wert gespeichert.  Dieses Attribut steuert die Ausgabe der Eigenschaft in <code>for-in</code> Schleifen.  Wenn es auf <code>true</code> , ist es m√∂glich, mit der Eigenschaft unter Verwendung solcher Zyklen zu arbeiten. <br><br><h3>  <font color="#3AC1EF">‚ñç [[Konfigurierbar]]</font> </h3><br>  Dieses Attribut wird auch durch einen booleschen Wert dargestellt.  Dies passiert, wenn <code>false</code> darin gespeichert ist: <br><br><ul><li>  Die Eigenschaft kann nicht gel√∂scht werden. </li><li>  Sie k√∂nnen keine Eigenschaften, die Daten speichern, mit Zugriffsmethoden in Eigenschaften konvertieren und umgekehrt.  Versuche, solche Transformationen durchzuf√ºhren, f√ºhren zu nichts. </li><li>  Es ist nicht zul√§ssig, Eigenschaftsattributwerte zu √§ndern.  Das hei√üt, die aktuellen Werte der Attribute <code>[[Enumerable]]</code> , <code>[[Configurable]]</code> , <code>[[Get]]</code> und <code>[[Set]]</code> bleiben unver√§ndert. </li></ul><br>  Die Auswirkung der Einstellung dieses Attributs auf <code>false</code> h√§ngt auch von der Art der Eigenschaft ab.  Dieses Attribut wirkt sich zus√§tzlich zu den oben genannten Auswirkungen auf Eigenschaften auf diese aus und so: <br><br><ul><li>  Wenn dies eine Eigenschaft ist, in der Daten gespeichert werden, kann das Attribut <code>[[Writable]]</code> nur von <code>true</code> in <code>false</code> ge√§ndert werden. </li><li>  Bis das Attribut <code>[[Writable]]</code> auf <code>false</code> , kann das Attribut <code>[[Value]]</code> ge√§ndert werden.  Nachdem die Attribute <code>[[Writable]]</code> und <code>[[Configurable]]</code> auf " <code>false</code> , stellt sich heraus, dass die Eigenschaft nicht beschreibbar, nicht l√∂schbar und unver√§nderlich ist. </li></ul><br><h2>  <font color="#3AC1EF">Arbeiten Sie mit Deskriptoren</font> </h2><br>  Nachdem wir uns mit Attributen vertraut gemacht haben, werden wir uns fragen, wie wir sie beeinflussen k√∂nnen.  JavaScript verf√ºgt √ºber spezielle Funktionen zum Arbeiten mit Eigenschaftsbeschreibungen.  Reden wir √ºber sie. <br><br><h3>  <font color="#3AC1EF">‚ñç Methode Object.getOwnPropertyDescriptor ()</font> </h3><br>  Wir haben diese Methode bereits getroffen.  Es nimmt ein Objekt und den Namen seiner Eigenschaft und gibt entweder <code>undefined</code> oder ein Objekt mit einem Eigenschaftsdeskriptor zur√ºck. <br><br><h3>  <font color="#3AC1EF">‚ñç Methode Object.defineProperty ()</font> </h3><br>  Dies ist eine statische <code>Object</code> , mit der Sie Objekten Eigenschaften hinzuf√ºgen oder vorhandene Eigenschaften √§ndern k√∂nnen.  Es werden drei Argumente ben√∂tigt - ein Objekt, ein Eigenschaftsname und ein Objekt mit einem Deskriptor.  Diese Methode gibt ein ge√§ndertes Objekt zur√ºck.  Betrachten Sie ein Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {}; <span class="hljs-comment"><span class="hljs-comment">// #1 Object.defineProperty(obj, 'id', { value: 42 }); // #2 console.log(obj); // =&gt; { } // #3 console.log(obj.id); // =&gt; 42 // #4 Object.defineProperty(obj, 'name', { value: 'Arfat', writable: false, enumerable: true, configurable: true }); // #5 console.log(obj.name); // =&gt; 'Arfat' // #6 obj.name = 'Arfat Salman' // #7 console.log(obj.name); // =&gt; 'Arfat' // (  'Arfat Salman') Object.defineProperty(obj, 'lastName', { value: 'Salman', enumerable: false, }); console.log(Object.keys(obj)); // =&gt; [ 'name' ] // #8 delete obj.id; // #9 console.log(obj.id); // =&gt; 42 //#10 Object.defineProperties(obj, { property1: {   value: 42,   writable: true }, property2: {} }); console.log(obj.property1) // =&gt; 42</span></span></code> </pre> <br>  Es kann in Node.js ausgef√ºhrt werden.  Der Code stellte sich als ziemlich gro√ü heraus, aber tats√§chlich ist er ziemlich einfach.  Wir werden es analysieren und uns auf Kommentare der Form <code>// #n</code> . <br><br>  In Fragment <code>#1</code> wir die Funktion <code>defineProperty</code> und √ºbergeben ihr das Objekt <code>obj</code> , den Namen der <code>id</code> Eigenschaft und ein Deskriptorobjekt, das nur die Eigenschaft <code>value</code> enth√§lt. <code>obj</code> , dass <code>42</code> in das Attribut <code>[[Value]]</code> wird.  Denken Sie daran, dass Werte f√ºr Attribute wie <code>[[Enumerable]]</code> oder <code>[[Configurable]]</code> in diesem Objekt standardm√§√üig auf <code>false</code> werden.  In diesem Fall werden die Attribute <code>[[Writable]]</code> , <code>[[Enumerable]]</code> und <code>[[Configurable]]</code> Eigenschaft <code>id</code> auf <code>false</code> . <br><br>  An der als <code>#2</code> gekennzeichneten Stelle versuchen wir, eine Zeichenfolgendarstellung des Objekts in der Konsole anzuzeigen.  Da die <code>id</code> Eigenschaft nicht aufz√§hlbar ist, wird sie nicht angezeigt.  Dar√ºber hinaus existiert die Eigenschaft, was ihren erfolgreichen Abschluss durch Befehl <code>#3</code> beweist. <br><br>  Beim Erstellen eines Objekts (Fragment <code>#4</code> ) definieren wir eine vollst√§ndige Liste der Attribute.  Setzen Sie insbesondere <code>[[Writable]]</code> auf <code>false</code> . <br><br>  Mit den Befehlen <code>#5</code> und <code>#7</code> zeigen wir den Wert der Namenseigenschaft an.  Aber zwischen ihnen (Fragment <code>#6</code> ) haben wir versucht, diesen Wert zu √§ndern.  Diese Operation hat den Wert der Eigenschaft nicht ge√§ndert, da das Attribut <code>[[Writable]]</code> auf <code>false</code> .  Infolgedessen geben beide Befehle dasselbe an die Konsole aus. <br><br>  Befehl <code>#8</code> ist ein Versuch, die Eigenschaft <code>id</code> zu entfernen.  Denken Sie daran, dass das Attribut <code>[[Configurable]]</code> auf <code>false</code> , was bedeutet, dass es nicht gel√∂scht werden kann.  Dies wird von Team <code>#9</code> bewiesen. <br><br>  Fragment <code>#10</code> zeigt die Verwendung der Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Object.defineProperties ()</a> .  Es funktioniert genauso wie die Funktion <code>defineProperty()</code> , erm√∂glicht jedoch in einem Aufruf, mehrere Eigenschaften des Objekts zu beeinflussen, w√§hrend <code>defineProperty()</code> nur mit einer Eigenschaft des Objekts arbeitet. <br><br><h2>  <font color="#3AC1EF">Objektschutz</font> </h2><br>  Von Zeit zu Zeit muss der Entwickler Objekte vor St√∂rungen von au√üen sch√ºtzen.  Angesichts der Flexibilit√§t von JavaScript ist es beispielsweise sehr leicht, die Eigenschaften eines Objekts, das sich nicht √§ndern sollte, f√§lschlicherweise zu √§ndern.  Es gibt drei Hauptmethoden zum Schutz von Objekten. <br><br><h3>  <font color="#3AC1EF">‚ñç Methode Object.preventExtensions ()</font> </h3><br>  Die <code>Object.preventExtensions()</code> -Methode verhindert, dass das Objekt erweitert wird, dh neue Eigenschaften hinzugef√ºgt werden.  Es nimmt ein Objekt und macht es nicht erweiterbar.  Beachten Sie, dass Sie Eigenschaften aus einem solchen Objekt entfernen k√∂nnen.  Betrachten Sie ein Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.preventExtensions(obj); obj.name = <span class="hljs-string"><span class="hljs-string">'Arfat'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj); <span class="hljs-comment"><span class="hljs-comment">// =&gt; { id: 42 }</span></span></code> </pre> <br>  Um herauszufinden, ob ein Objekt nicht erweiterbar ist, k√∂nnen Sie die <code>Object.isExtensible()</code> -Methode verwenden.  Wenn <code>true</code> , k√∂nnen Sie dem Objekt neue Eigenschaften hinzuf√ºgen. <br><br><h3>  <font color="#3AC1EF">‚ñç Methode Object.seal ()</font> </h3><br>  Die Methode <code>seal()</code> scheint Objekte zu ‚Äûversiegeln‚Äú.  Hier ist, wor√ºber wir sprechen: <br><br><ul><li>  Seine Verwendung verhindert, dass dem Objekt neue Eigenschaften hinzugef√ºgt werden (in diesem <code>Object.preventExtensions()</code> √§hnelt es <code>Object.preventExtensions()</code> ). </li><li>  Alle vorhandenen Eigenschaften eines Objekts k√∂nnen nicht konfiguriert werden. </li><li>  Werte vorhandener Eigenschaften k√∂nnen ge√§ndert werden, wenn ihr Attribut <code>[[Writable]]</code> nicht auf <code>false</code> ist. </li></ul><br>  Infolgedessen stellt sich heraus, dass diese Methode das Hinzuf√ºgen neuer Eigenschaften zum Objekt und das Entfernen der darin vorhandenen Eigenschaften verhindert. <br><br>  Betrachten Sie ein Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.seal(obj); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> obj.id <span class="hljs-comment"><span class="hljs-comment">// ( ) obj.name = 'Arfat'; // ( ) console.log(obj); // =&gt; { id: 42 } Object.isExtensible(obj); // =&gt; false Object.isSealed(obj); //=&gt; true</span></span></code> </pre> <br>  Um zu √ºberpr√ºfen, ob das Objekt "versiegelt" ist oder nicht, k√∂nnen Sie die <code>Object.isSealed()</code> -Methode verwenden. <br><br><h3>  <font color="#3AC1EF">‚ñç Methode Object.freeze ()</font> </h3><br>  Mit der Methode <code>freeze()</code> k√∂nnen Sie Objekte ‚Äûeinfrieren‚Äú und sie mit dem h√∂chstm√∂glichen Schutzniveau in JavaScript ausstatten.  So funktioniert es: <br><br><ul><li>  Versiegelt ein Objekt mit <code>Object.seal()</code> . </li><li>  Verbietet die √Ñnderung vorhandener Eigenschaften des Objekts vollst√§ndig. </li><li>  Verbietet das √Ñndern von Eigenschaftsbeschreibungen. </li></ul><br>  Hier ist ein Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.freeze(obj); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> obj.id <span class="hljs-comment"><span class="hljs-comment">// ( ) obj.name = 'Arfat'; // ( ) console.log(obj); // =&gt; { id: 42 } Object.isExtensible(obj); // =&gt; false Object.isSealed(obj); //=&gt; true Object.isFrozen(obj); // =&gt; true</span></span></code> </pre> <br>  Sie k√∂nnen das Objekt mithilfe der <code>Object.isFrozen()</code> -Methode √ºberpr√ºfen, ob es "eingefroren" ist. <br><br><h3>  <font color="#3AC1EF">‚ñç √úbersicht √ºber die Methoden zum Schutz von Objekten</font> </h3><br>  Es ist wichtig zu beachten, dass die oben beschriebenen Methoden zum Schutz von Objekten nur deren Eigenschaften betreffen, die keine Objekte sind. <br><br>  Hier ist eine √úbersichtstabelle zu den betrachteten Methoden zum Schutz von Objekten, die hier entnommen wird. <br><table><tbody><tr><td></td><td>  Eigenschaftserstellung <br></td><td>  Eigenschaftslesung <br></td><td>  Eigenschaft √ºberschreiben <br></td><td>  Eigentumsentfernung <br></td></tr><tr><td> <code>Object.freeze()</code> <br> </td><td>  - - </td><td>  + <br></td><td>  - - </td><td>  - - </td></tr><tr><td> <code>Object.seal()</code> <br> </td><td>  - - </td><td>  + <br></td><td>  + <br></td><td>  - - </td></tr><tr><td> <code>Object.preventExtensions()</code> <br> </td><td>  - - </td><td>  + <br></td><td>  + <br></td><td>  + <br></td></tr></tbody></table><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Angesichts der H√§ufigkeit, mit der Objekte in JavaScript-Code verwendet werden, ist es f√ºr jeden Entwickler wichtig zu wissen, wie sie angeordnet sind.  Wir hoffen, dass das, was Sie durch das Lesen dieses Materials gelernt haben, f√ºr Sie n√ºtzlich ist.  Au√üerdem kennen Sie jetzt die Antworten auf die am Anfang des Artikels aufgef√ºhrten Fragen. <br><br>  <b>Liebe Leser!</b>  Wie sch√ºtzen Sie JavaScript-Objekte? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438794/">https://habr.com/ru/post/de438794/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438782/index.html">Der FSB hat die Freigabe russischer SIM-Karten vorgeschlagen und die heimische Kryptographie f√ºr 5G verwendet</a></li>
<li><a href="../de438784/index.html">Probleme bei der Verwendung des Yandex.Metrica-Dienstes</a></li>
<li><a href="../de438788/index.html">Umgebungs√ºberwachung im Serverraum (Bolid + Zabbix)</a></li>
<li><a href="../de438790/index.html">Der QuadrigaCX-Kryptow√§hrungsaustausch wird keine 137 Millionen US-Dollar verschenken. Nur der Direktor kannte das Passwort aus dem Gesch√§ft und starb</a></li>
<li><a href="../de438792/index.html">Verwenden von AccelStor Alle Flash-Arrays in VDI-Projekten</a></li>
<li><a href="../de438796/index.html">Docker lernen Teil 1: Die Grundlagen</a></li>
<li><a href="../de438798/index.html">Umgang mit Cyber-Intelligence-Daten: Wir lernen, Indikatoren f√ºr Systemkompromisse zu sammeln und zu identifizieren</a></li>
<li><a href="../de438800/index.html">PHP Pear gehackt und nicht verf√ºgbar</a></li>
<li><a href="../de438802/index.html">Sommerprogramme f√ºr 2019 f√ºr das Unterrichten von Teenagern, die im Ausland programmieren</a></li>
<li><a href="../de438804/index.html">Warten auf alle beim n√§chsten CocoaHeads Meetup</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>