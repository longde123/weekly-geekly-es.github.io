<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤙 😗 🧑🏻‍🤝‍🧑🏻 JavaScript-Objektdetails 👈🏼 🎤 ♟️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Autor des Materials, dessen Übersetzung wir heute veröffentlichen, sagt, dass JavaScript-Objekte viele Dinge enthalten, deren Existenz Sie nicht e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript-Objektdetails</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/438794/">  Der Autor des Materials, dessen Übersetzung wir heute veröffentlichen, sagt, dass JavaScript-Objekte viele Dinge enthalten, deren Existenz Sie nicht einmal vermuten können, und die sie in der täglichen Arbeit verwenden.  Objekte in JavaScript sind sehr einfach zu erstellen, bequem zu bearbeiten, sie scheinen verständlich und flexibel zu sein, und viele Programmierer denken einfach nicht daran, dass die Objekte tatsächlich nicht so einfach sind. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/o8/ga/z0/o8gaz0tewtkdqmryqsar9vdswfc.png"></a> <br><blockquote>  <b>NB:</b> Informationen aus der Veröffentlichung in der Praxis sollten sehr sorgfältig und unter Aufsicht erfahrener Kollegen angewendet werden. </blockquote><a name="habracut"></a><br>  Hier sprechen wir darüber, was in den Tiefen von Objekten verborgen ist, und diskutieren die Feinheiten der Arbeit mit ihnen. <br>  Nachdem Sie dieses Material beherrschen, kennen Sie die Antworten auf die folgenden Fragen: <br><br><ul><li>  Wie kann eine Eigenschaft eines Objekts nicht gelöscht werden? </li><li>  Was sind Eigenschaften mit Zugriffsmethoden und welche Funktionen haben sie? </li><li>  Wie macht man eine Immobilie unveränderlich oder versteckt? </li><li> Warum sind einige Eigenschaften in <code>for-in</code> Schleifen oder in den Ergebnissen der <code>Object.keys()</code> -Methode nicht sichtbar, und einige sind sichtbar? </li><li>  Wie kann man ein Objekt vor Änderungen schützen? </li><li>  So verstehen Sie einen Code, der dem folgenden ähnelt: </li></ul><br><pre> <code class="javascript hljs">obj.id = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj.id) <span class="hljs-comment"><span class="hljs-comment">// =&gt; '101' (5    )</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">Arten von Objekteigenschaften</font> </h2><br><h3>  <font color="#3AC1EF">▍ Datenspeichereigenschaften</font> </h3><br>  Sie haben wahrscheinlich unzählige ähnliche Objekte erstellt: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">'Arfat'</span></span>, <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span> } obj.name <span class="hljs-comment"><span class="hljs-comment">// =&gt; 'Arfat'</span></span></code> </pre> <br>  Die <code>name</code> und <code>id</code> Eigenschaften des <code>obj</code> Objekts werden als <code>obj</code> oder „ <code>obj</code> “ bezeichnet.  Dies sind bekannte Eigenschaften, die ständig im JavaScript-Code enthalten sind.  Welche anderen Arten von Eigenschaften können Objekte haben? <br><br><h3>  <font color="#3AC1EF">▍ Eigenschaften mit Zugriffsmethoden</font> </h3><br>  Diese Eigenschaften werden auch als Getter und Setter bezeichnet und sind auch in anderen Programmiersprachen wie C # oder Python zu finden.  Eine Eigenschaft mit Accessor-Eigenschaft ist eine Kombination aus zwei Funktionen - <code>get</code> und <code>set</code> . <br><br>  Wenn Sie solche Eigenschaften deklarieren, wird anstelle des herkömmlichen Konstrukts vom <code>: </code> die folgende Syntax verwendet: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> accessorObj = { get name() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'Arfat'</span></span>; } }; accessorObj.name; <span class="hljs-comment"><span class="hljs-comment">// =&gt; 'Arfat' const dataObj = { name: 'Arfat', }; dataObj.name; // =&gt; 'Arfat'</span></span></code> </pre> <br>  Schauen Sie sich das <code>accesorObj</code> Objekt an und vergleichen Sie es mit dem <code>dataObj</code> Objekt.  Anscheinend zeigen sie jetzt das gleiche Verhalten.  Bei der Beschreibung des ersten Objekts haben wir das Schlüsselwort <code>get</code> , gefolgt von der Deklaration der Funktion.  Um auf eine ähnliche Eigenschaft zuzugreifen, obwohl sie durch eine Funktion dargestellt wird, müssen Sie keine Klammern nach dem Eigenschaftsnamen setzen, um diese Funktion aufzurufen.  Das heißt, ein Design wie <code>accessorObj.name();</code>  falsch. <br><br>  Beim Versuch, auf die Eigenschaft <code>accessorObj.name</code> zuzugreifen, <code>accessorObj.name</code> beim Versuch, sie zu lesen, wird die entsprechende Funktion ausgeführt und der zurückgegebene Wert wird zum Wert der Eigenschaft <code>name</code> . <br><br>  Die <code>get</code> Funktionen werden als Getter bezeichnet und sind für das Abrufen der Werte verantwortlich.  Wenn wir unser Beispiel fortsetzen und versuchen, den Wert der <code>name</code> Eigenschaft des <code>accessorObj</code> Objekts zu ändern, indem wir beispielsweise den Befehl <code>accessorObj.name = 'New Person';</code>  dann stellt sich heraus, dass nichts passieren wird.  Der Punkt hier ist, dass die Setter-Funktion nicht mit der <code>name</code> verknüpft ist.  Mit solchen Funktionen können Sie die Reihenfolge anpassen, in der den Eigenschaften von Objekten, deren Zugriff mithilfe von Gettern organisiert wird, neue Werte zugewiesen werden. <br><br>  So sieht eine Objektdeklaration mit einem Getter und einem Setter aus: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> accessorObj = { <span class="hljs-attr"><span class="hljs-attr">_name</span></span>: <span class="hljs-string"><span class="hljs-string">'Arfat'</span></span>, get name() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._name; }, set name(value) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._name = value; } };</code> </pre> <br>  Die Setter-Funktion empfängt, was sie versucht, der Eigenschaft des Objekts als Parameter zuzuweisen.  Jetzt können Sie etwas in der Eigenschaft des Objekts speichern.  In diesem Fall erstellen wir eine "private" Eigenschaft des <code>_name</code> Objekts.  Das erste Zeichen des Namens einer solchen Eigenschaft ist ein Unterstrich, der nichts weiter als ein Hinweis für den Programmierer ist und angibt, dass diese Eigenschaft für die internen Anforderungen des Objekts bestimmt ist.  Außerdem arbeiten wir damit, wenn wir auf die Eigenschaft des Namensobjekts zugreifen, auf die der Zugriff vom Getter und Setter geregelt wird. <br><br>  Gleichzeitig können wir in der Getter-Funktion den Wert der Eigenschaft <code>_name</code> ändern, bevor wir ihn zurückgeben. <br><br>  So könnte es aussehen: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { get name() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._name.toUpperCase(); }, set name(value) {   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._name = value; }, get id() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._id.toString(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-comment"><span class="hljs-comment">//        }, set id(value) {   this._id = value; } } obj.name = 'Arfat'; obj.name; // =&gt; 'ARFAT' obj.id = 5; obj.id; // =&gt; '101</span></span></code> </pre> <br>  Dieses Programm enthält übrigens die Antwort auf eine der am Anfang des Artikels gestellten Fragen, die die Analyse von auf den ersten Blick unverständlichem Code betrifft. <br><br>  Warum sollte jemand Eigenschaften mit Zugriffsmethoden benötigen, wenn Sie sicher mit normalen Eigenschaften arbeiten können?  Sie können beispielsweise erforderlich sein, um Informationen zu Eigenschaftslesevorgängen zu protokollieren oder einen Verlauf von Änderungen an Eigenschaftswerten zu speichern.  Eigenschaften mit Zugriffsmethoden bieten uns alle Möglichkeiten, Daten mithilfe von Funktionen zu verarbeiten, und die Einfachheit, mit gewöhnlichen Eigenschaften zu arbeiten.  Lesen Sie hier mehr über die Verwendung solcher Eigenschaften. <br><br>  Wie unterscheidet JavaScript zwischen gewöhnlichen Eigenschaften, in denen Daten gespeichert werden, von Eigenschaften mit Zugriffsmethoden?  Finde das heraus. <br><br><h2>  <font color="#3AC1EF">Objekteigenschaftsbeschreibungen</font> </h2><br>  Auf den ersten Blick scheint es eine direkte Entsprechung zwischen den Schlüsseln und den in Objekten gespeicherten Werten zu geben.  Dies ist jedoch nicht ganz richtig. <br><br><h3>  <font color="#3AC1EF">▍ Eigenschaftsattribute</font> </h3><br>  Jeder Schlüssel des Objekts ist einer Reihe von Attributen zugeordnet, die die Eigenschaften des diesem Schlüssel zugeordneten Werts bestimmen.  Diese Attribute können auch als Metadaten betrachtet werden, die ein <code>: </code> Paar beschreiben. <br><br>  Attribute werden verwendet, um den Status der Eigenschaften von Objekten festzulegen und zu beschreiben.  Die Menge der Eigenschaftsattribute wird als Deskriptor bezeichnet.  Es gibt sechs Eigenschaftsattribute: <br><br><ul><li> <code>[[Value]]</code> </li> <li> <code>[[Get]]</code> </li> <li> <code>[[Set]]</code> </li> <li> <code>[[Writable]]</code> </li> <li> <code>[[Enumerable]]</code> </li> <li> <code>[[Configurable]]</code> </li> </ul><br>  Warum sind Eigenschaftsattributnamen in dieser Liste im Konstrukt <code>[[]]</code> ?  Doppelte Klammern zeigen an, dass dies Entitäten sind, die von den internen Mechanismen der Sprache verwendet werden.  Ein JS-Programmierer kann nicht direkt auf diese Eigenschaften zugreifen.  Um sie zu beeinflussen, werden geeignete Methoden angewendet. <br><br>  Betrachten Sie das folgende Bild <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">von hier</a> , auf dem Sie das Objekt und die Attribute seiner Eigenschaften sehen können. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/613/e59/d25/613e59d25aa164d3fb5dc1acbe49e25f.png"></div><br>  <i><font color="#999999">Objekt und Attribute seiner Eigenschaften</font></i> <br><br>  Unser Objekt hat 2 Schlüssel - <code>x</code> und <code>y</code> .  Darüber hinaus ist jedem von ihnen eine Reihe von Attributen zugeordnet. <br><br>  Wie können Sie mithilfe von JavaScript Informationen über das Objekt abrufen, ähnlich wie in der vorherigen Abbildung?  <code>Object.getOwnPropertyDescriptor()</code> können Sie die Funktion <code>Object.getOwnPropertyDescriptor()</code> verwenden.  Es nimmt ein Objekt und den Namen seiner Eigenschaft und gibt dann ein Objekt zurück, das die Attribute dieser Eigenschaft enthält.  Hier ist ein Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> object = { <span class="hljs-attr"><span class="hljs-attr">x</span></span>: <span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-attr"><span class="hljs-attr">y</span></span>: <span class="hljs-number"><span class="hljs-number">6</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyDescriptor(object, <span class="hljs-string"><span class="hljs-string">'x'</span></span>); <span class="hljs-comment"><span class="hljs-comment">/* { value: 5, writable: true, enumerable: true, configurable: true } */</span></span></code> </pre> <br>  Es ist zu beachten, dass die Zusammensetzung der Attribute einer bestimmten Eigenschaft von ihrem Typ abhängt.  Alle sechs Attribute derselben Eigenschaft werden nicht gefunden. <br><br><ul><li>  Wenn es sich um Eigenschaften mit Daten handelt, haben sie nur die Attribute <code>[[Value]]</code> , <code>[[Writable]]</code> , <code>[[Enumerable]]</code> und <code>[[Configurable]]</code> . </li><li>  Eigenschaften mit Zugriffsmethoden haben anstelle der Attribute <code>[[Value]]</code> und <code>[[Writable]]</code> Attribute <code>[[Get]]</code> und <code>[[Set]]</code> . </li></ul><br><h3>  <font color="#3AC1EF">▍ [[Wert]]</font> </h3><br>  Dieses Attribut speichert, was zurückgegeben wird, wenn versucht wird, den Eigenschaftswert eines Objekts abzurufen.  Das heißt, wenn wir im vorherigen Beispiel eine Konstruktion des Formulars <code>object.x</code> , erhalten wir, was im Attribut <code>[[Value]]</code> gespeichert ist.  Das gleiche passiert, wenn Sie versuchen, die Eigenschaften eines Objekts in eckigen Klammern zu lesen. <br><br><h3>  <font color="#3AC1EF">▍ [[Get]]</font> </h3><br>  Dieses Attribut speichert einen Verweis auf eine Funktion, die eine Getter-Eigenschaft ist.  Diese Funktion wird ohne Argumente aufgerufen, wenn versucht wird, den Wert einer Eigenschaft zu lesen. <br><br><h3>  <font color="#3AC1EF">▍ [[Einstellen]]</font> </h3><br>  Hier wird der Link zu der Funktion gespeichert, die beim Erstellen der Setter-Eigenschaft deklariert wurde.  Es wird mit einem Argument aufgerufen, das den Wert darstellt, den sie der Eigenschaft zuweisen wollten, dh es wird bei jeder Operation zum Zuweisen eines neuen Werts zu einer Eigenschaft aufgerufen. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { set x(val) {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(val)   <span class="hljs-comment"><span class="hljs-comment">// =&gt; 23 } } obj.x = 23;</span></span></code> </pre> <br>  In diesem Beispiel wird die rechte Seite des Ausdrucks als <code>val</code> Argument an die Setter-Funktion übergeben.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Hier ist der</a> Code, der die Verwendung von Setzern und Gettern demonstriert. <br><br><h3>  <font color="#3AC1EF">▍ [[Beschreibbar]]</font> </h3><br>  Dieses Attribut enthält einen booleschen Wert.  Es gibt an, ob der Eigenschaftswert überschrieben werden kann oder nicht.  Wenn hier <code>false</code> gespeichert ist, schlagen Versuche, den Wert der Eigenschaft zu ändern, fehl. <br><br><h3>  <font color="#3AC1EF">▍ [[Aufzählbar]]</font> </h3><br>  Hier wird auch ein logischer Wert gespeichert.  Dieses Attribut steuert die Ausgabe der Eigenschaft in <code>for-in</code> Schleifen.  Wenn es auf <code>true</code> , ist es möglich, mit der Eigenschaft unter Verwendung solcher Zyklen zu arbeiten. <br><br><h3>  <font color="#3AC1EF">▍ [[Konfigurierbar]]</font> </h3><br>  Dieses Attribut wird auch durch einen booleschen Wert dargestellt.  Dies passiert, wenn <code>false</code> darin gespeichert ist: <br><br><ul><li>  Die Eigenschaft kann nicht gelöscht werden. </li><li>  Sie können keine Eigenschaften, die Daten speichern, mit Zugriffsmethoden in Eigenschaften konvertieren und umgekehrt.  Versuche, solche Transformationen durchzuführen, führen zu nichts. </li><li>  Es ist nicht zulässig, Eigenschaftsattributwerte zu ändern.  Das heißt, die aktuellen Werte der Attribute <code>[[Enumerable]]</code> , <code>[[Configurable]]</code> , <code>[[Get]]</code> und <code>[[Set]]</code> bleiben unverändert. </li></ul><br>  Die Auswirkung der Einstellung dieses Attributs auf <code>false</code> hängt auch von der Art der Eigenschaft ab.  Dieses Attribut wirkt sich zusätzlich zu den oben genannten Auswirkungen auf Eigenschaften auf diese aus und so: <br><br><ul><li>  Wenn dies eine Eigenschaft ist, in der Daten gespeichert werden, kann das Attribut <code>[[Writable]]</code> nur von <code>true</code> in <code>false</code> geändert werden. </li><li>  Bis das Attribut <code>[[Writable]]</code> auf <code>false</code> , kann das Attribut <code>[[Value]]</code> geändert werden.  Nachdem die Attribute <code>[[Writable]]</code> und <code>[[Configurable]]</code> auf " <code>false</code> , stellt sich heraus, dass die Eigenschaft nicht beschreibbar, nicht löschbar und unveränderlich ist. </li></ul><br><h2>  <font color="#3AC1EF">Arbeiten Sie mit Deskriptoren</font> </h2><br>  Nachdem wir uns mit Attributen vertraut gemacht haben, werden wir uns fragen, wie wir sie beeinflussen können.  JavaScript verfügt über spezielle Funktionen zum Arbeiten mit Eigenschaftsbeschreibungen.  Reden wir über sie. <br><br><h3>  <font color="#3AC1EF">▍ Methode Object.getOwnPropertyDescriptor ()</font> </h3><br>  Wir haben diese Methode bereits getroffen.  Es nimmt ein Objekt und den Namen seiner Eigenschaft und gibt entweder <code>undefined</code> oder ein Objekt mit einem Eigenschaftsdeskriptor zurück. <br><br><h3>  <font color="#3AC1EF">▍ Methode Object.defineProperty ()</font> </h3><br>  Dies ist eine statische <code>Object</code> , mit der Sie Objekten Eigenschaften hinzufügen oder vorhandene Eigenschaften ändern können.  Es werden drei Argumente benötigt - ein Objekt, ein Eigenschaftsname und ein Objekt mit einem Deskriptor.  Diese Methode gibt ein geändertes Objekt zurück.  Betrachten Sie ein Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = {}; <span class="hljs-comment"><span class="hljs-comment">// #1 Object.defineProperty(obj, 'id', { value: 42 }); // #2 console.log(obj); // =&gt; { } // #3 console.log(obj.id); // =&gt; 42 // #4 Object.defineProperty(obj, 'name', { value: 'Arfat', writable: false, enumerable: true, configurable: true }); // #5 console.log(obj.name); // =&gt; 'Arfat' // #6 obj.name = 'Arfat Salman' // #7 console.log(obj.name); // =&gt; 'Arfat' // (  'Arfat Salman') Object.defineProperty(obj, 'lastName', { value: 'Salman', enumerable: false, }); console.log(Object.keys(obj)); // =&gt; [ 'name' ] // #8 delete obj.id; // #9 console.log(obj.id); // =&gt; 42 //#10 Object.defineProperties(obj, { property1: {   value: 42,   writable: true }, property2: {} }); console.log(obj.property1) // =&gt; 42</span></span></code> </pre> <br>  Es kann in Node.js ausgeführt werden.  Der Code stellte sich als ziemlich groß heraus, aber tatsächlich ist er ziemlich einfach.  Wir werden es analysieren und uns auf Kommentare der Form <code>// #n</code> . <br><br>  In Fragment <code>#1</code> wir die Funktion <code>defineProperty</code> und übergeben ihr das Objekt <code>obj</code> , den Namen der <code>id</code> Eigenschaft und ein Deskriptorobjekt, das nur die Eigenschaft <code>value</code> enthält. <code>obj</code> , dass <code>42</code> in das Attribut <code>[[Value]]</code> wird.  Denken Sie daran, dass Werte für Attribute wie <code>[[Enumerable]]</code> oder <code>[[Configurable]]</code> in diesem Objekt standardmäßig auf <code>false</code> werden.  In diesem Fall werden die Attribute <code>[[Writable]]</code> , <code>[[Enumerable]]</code> und <code>[[Configurable]]</code> Eigenschaft <code>id</code> auf <code>false</code> . <br><br>  An der als <code>#2</code> gekennzeichneten Stelle versuchen wir, eine Zeichenfolgendarstellung des Objekts in der Konsole anzuzeigen.  Da die <code>id</code> Eigenschaft nicht aufzählbar ist, wird sie nicht angezeigt.  Darüber hinaus existiert die Eigenschaft, was ihren erfolgreichen Abschluss durch Befehl <code>#3</code> beweist. <br><br>  Beim Erstellen eines Objekts (Fragment <code>#4</code> ) definieren wir eine vollständige Liste der Attribute.  Setzen Sie insbesondere <code>[[Writable]]</code> auf <code>false</code> . <br><br>  Mit den Befehlen <code>#5</code> und <code>#7</code> zeigen wir den Wert der Namenseigenschaft an.  Aber zwischen ihnen (Fragment <code>#6</code> ) haben wir versucht, diesen Wert zu ändern.  Diese Operation hat den Wert der Eigenschaft nicht geändert, da das Attribut <code>[[Writable]]</code> auf <code>false</code> .  Infolgedessen geben beide Befehle dasselbe an die Konsole aus. <br><br>  Befehl <code>#8</code> ist ein Versuch, die Eigenschaft <code>id</code> zu entfernen.  Denken Sie daran, dass das Attribut <code>[[Configurable]]</code> auf <code>false</code> , was bedeutet, dass es nicht gelöscht werden kann.  Dies wird von Team <code>#9</code> bewiesen. <br><br>  Fragment <code>#10</code> zeigt die Verwendung der Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Object.defineProperties ()</a> .  Es funktioniert genauso wie die Funktion <code>defineProperty()</code> , ermöglicht jedoch in einem Aufruf, mehrere Eigenschaften des Objekts zu beeinflussen, während <code>defineProperty()</code> nur mit einer Eigenschaft des Objekts arbeitet. <br><br><h2>  <font color="#3AC1EF">Objektschutz</font> </h2><br>  Von Zeit zu Zeit muss der Entwickler Objekte vor Störungen von außen schützen.  Angesichts der Flexibilität von JavaScript ist es beispielsweise sehr leicht, die Eigenschaften eines Objekts, das sich nicht ändern sollte, fälschlicherweise zu ändern.  Es gibt drei Hauptmethoden zum Schutz von Objekten. <br><br><h3>  <font color="#3AC1EF">▍ Methode Object.preventExtensions ()</font> </h3><br>  Die <code>Object.preventExtensions()</code> -Methode verhindert, dass das Objekt erweitert wird, dh neue Eigenschaften hinzugefügt werden.  Es nimmt ein Objekt und macht es nicht erweiterbar.  Beachten Sie, dass Sie Eigenschaften aus einem solchen Objekt entfernen können.  Betrachten Sie ein Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.preventExtensions(obj); obj.name = <span class="hljs-string"><span class="hljs-string">'Arfat'</span></span>; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(obj); <span class="hljs-comment"><span class="hljs-comment">// =&gt; { id: 42 }</span></span></code> </pre> <br>  Um herauszufinden, ob ein Objekt nicht erweiterbar ist, können Sie die <code>Object.isExtensible()</code> -Methode verwenden.  Wenn <code>true</code> , können Sie dem Objekt neue Eigenschaften hinzufügen. <br><br><h3>  <font color="#3AC1EF">▍ Methode Object.seal ()</font> </h3><br>  Die Methode <code>seal()</code> scheint Objekte zu „versiegeln“.  Hier ist, worüber wir sprechen: <br><br><ul><li>  Seine Verwendung verhindert, dass dem Objekt neue Eigenschaften hinzugefügt werden (in diesem <code>Object.preventExtensions()</code> ähnelt es <code>Object.preventExtensions()</code> ). </li><li>  Alle vorhandenen Eigenschaften eines Objekts können nicht konfiguriert werden. </li><li>  Werte vorhandener Eigenschaften können geändert werden, wenn ihr Attribut <code>[[Writable]]</code> nicht auf <code>false</code> ist. </li></ul><br>  Infolgedessen stellt sich heraus, dass diese Methode das Hinzufügen neuer Eigenschaften zum Objekt und das Entfernen der darin vorhandenen Eigenschaften verhindert. <br><br>  Betrachten Sie ein Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.seal(obj); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> obj.id <span class="hljs-comment"><span class="hljs-comment">// ( ) obj.name = 'Arfat'; // ( ) console.log(obj); // =&gt; { id: 42 } Object.isExtensible(obj); // =&gt; false Object.isSealed(obj); //=&gt; true</span></span></code> </pre> <br>  Um zu überprüfen, ob das Objekt "versiegelt" ist oder nicht, können Sie die <code>Object.isSealed()</code> -Methode verwenden. <br><br><h3>  <font color="#3AC1EF">▍ Methode Object.freeze ()</font> </h3><br>  Mit der Methode <code>freeze()</code> können Sie Objekte „einfrieren“ und sie mit dem höchstmöglichen Schutzniveau in JavaScript ausstatten.  So funktioniert es: <br><br><ul><li>  Versiegelt ein Objekt mit <code>Object.seal()</code> . </li><li>  Verbietet die Änderung vorhandener Eigenschaften des Objekts vollständig. </li><li>  Verbietet das Ändern von Eigenschaftsbeschreibungen. </li></ul><br>  Hier ist ein Beispiel: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> obj = { <span class="hljs-attr"><span class="hljs-attr">id</span></span>: <span class="hljs-number"><span class="hljs-number">42</span></span> }; <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.freeze(obj); <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span> obj.id <span class="hljs-comment"><span class="hljs-comment">// ( ) obj.name = 'Arfat'; // ( ) console.log(obj); // =&gt; { id: 42 } Object.isExtensible(obj); // =&gt; false Object.isSealed(obj); //=&gt; true Object.isFrozen(obj); // =&gt; true</span></span></code> </pre> <br>  Sie können das Objekt mithilfe der <code>Object.isFrozen()</code> -Methode überprüfen, ob es "eingefroren" ist. <br><br><h3>  <font color="#3AC1EF">▍ Übersicht über die Methoden zum Schutz von Objekten</font> </h3><br>  Es ist wichtig zu beachten, dass die oben beschriebenen Methoden zum Schutz von Objekten nur deren Eigenschaften betreffen, die keine Objekte sind. <br><br>  Hier ist eine Übersichtstabelle zu den betrachteten Methoden zum Schutz von Objekten, die hier entnommen wird. <br><table><tbody><tr><td></td><td>  Eigenschaftserstellung <br></td><td>  Eigenschaftslesung <br></td><td>  Eigenschaft überschreiben <br></td><td>  Eigentumsentfernung <br></td></tr><tr><td> <code>Object.freeze()</code> <br> </td><td>  - - </td><td>  + <br></td><td>  - - </td><td>  - - </td></tr><tr><td> <code>Object.seal()</code> <br> </td><td>  - - </td><td>  + <br></td><td>  + <br></td><td>  - - </td></tr><tr><td> <code>Object.preventExtensions()</code> <br> </td><td>  - - </td><td>  + <br></td><td>  + <br></td><td>  + <br></td></tr></tbody></table><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Angesichts der Häufigkeit, mit der Objekte in JavaScript-Code verwendet werden, ist es für jeden Entwickler wichtig zu wissen, wie sie angeordnet sind.  Wir hoffen, dass das, was Sie durch das Lesen dieses Materials gelernt haben, für Sie nützlich ist.  Außerdem kennen Sie jetzt die Antworten auf die am Anfang des Artikels aufgeführten Fragen. <br><br>  <b>Liebe Leser!</b>  Wie schützen Sie JavaScript-Objekte? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438794/">https://habr.com/ru/post/de438794/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438782/index.html">Der FSB hat die Freigabe russischer SIM-Karten vorgeschlagen und die heimische Kryptographie für 5G verwendet</a></li>
<li><a href="../de438784/index.html">Probleme bei der Verwendung des Yandex.Metrica-Dienstes</a></li>
<li><a href="../de438788/index.html">Umgebungsüberwachung im Serverraum (Bolid + Zabbix)</a></li>
<li><a href="../de438790/index.html">Der QuadrigaCX-Kryptowährungsaustausch wird keine 137 Millionen US-Dollar verschenken. Nur der Direktor kannte das Passwort aus dem Geschäft und starb</a></li>
<li><a href="../de438792/index.html">Verwenden von AccelStor Alle Flash-Arrays in VDI-Projekten</a></li>
<li><a href="../de438796/index.html">Docker lernen Teil 1: Die Grundlagen</a></li>
<li><a href="../de438798/index.html">Umgang mit Cyber-Intelligence-Daten: Wir lernen, Indikatoren für Systemkompromisse zu sammeln und zu identifizieren</a></li>
<li><a href="../de438800/index.html">PHP Pear gehackt und nicht verfügbar</a></li>
<li><a href="../de438802/index.html">Sommerprogramme für 2019 für das Unterrichten von Teenagern, die im Ausland programmieren</a></li>
<li><a href="../de438804/index.html">Warten auf alle beim nächsten CocoaHeads Meetup</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>