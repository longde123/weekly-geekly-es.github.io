<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ•” ğŸ˜‹ ğŸ‘²ğŸ¼ Algoritme Fortune, detail implementasi ğŸ‚ğŸ¼ ğŸŒ ğŸŒ¬ï¸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Selama beberapa minggu terakhir, saya telah berupaya mengimplementasikan algoritma Fortune di C ++. Algoritma ini mengambil banyak poin 2D dan membang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Algoritme Fortune, detail implementasi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430628/"> Selama beberapa minggu terakhir, saya telah berupaya mengimplementasikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma Fortune</a> di C ++.  Algoritma ini mengambil banyak poin 2D dan membangun <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diagram Voronoi</a> darinya.  Jika Anda tidak tahu apa itu diagram Voronoi, maka lihatlah gambar: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50c/df1/56c/50cdf156cb6f5ce5e73ad6308be52dfb.png"></div><br>  Untuk setiap titik masuk, yang disebut "situs," kita perlu menemukan banyak titik yang lebih dekat ke tempat ini daripada orang lain.  Set titik-titik tersebut membentuk sel-sel yang ditunjukkan pada gambar di atas. <br><br>  Sangat luar biasa dalam algoritme Fortune bahwa ia membuat diagram seperti itu pada waktunya <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2">O</span><span class="MJXp-mo" id="MJXp-Span-3" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4">n</span><span class="MJXp-mtext" id="MJXp-Span-5">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-7">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-8">g</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-9">n</span><span class="MJXp-mo" id="MJXp-Span-10" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.89ex" height="2.66ex" viewBox="0 -832 4258 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj4mEbl8sCB9ZWfzfgVuGAF5NPiAw#MJMATHI-4F" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj4mEbl8sCB9ZWfzfgVuGAF5NPiAw#MJMAIN-28" x="763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj4mEbl8sCB9ZWfzfgVuGAF5NPiAw#MJMATHI-6E" x="1153" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj4mEbl8sCB9ZWfzfgVuGAF5NPiAw#MJMATHI-6C" x="2003" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj4mEbl8sCB9ZWfzfgVuGAF5NPiAw#MJMATHI-6F" x="2302" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj4mEbl8sCB9ZWfzfgVuGAF5NPiAw#MJMATHI-67" x="2787" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj4mEbl8sCB9ZWfzfgVuGAF5NPiAw#MJMATHI-6E" x="3268" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj4mEbl8sCB9ZWfzfgVuGAF5NPiAw#MJMAIN-29" x="3868" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> O (n \ log n) </script>  (yang optimal untuk algoritma perbandingan), di mana <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-11"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-12">n</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.395ex" height="1.455ex" viewBox="0 -520.7 600.5 626.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj4mEbl8sCB9ZWfzfgVuGAF5NPiAw#MJMATHI-6E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> n </script>  Apakah jumlah tempat. <br><br>  Saya menulis artikel ini karena saya menganggap implementasi algoritma ini tugas yang sangat sulit.  Saat ini, ini adalah algoritma paling rumit yang harus saya implementasikan.  Karena itu, saya ingin berbagi masalah yang saya temui, dan bagaimana menyelesaikannya. <br><br>  Seperti biasa, kode diposting di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github</a> , dan semua bahan referensi yang saya gunakan tercantum di akhir artikel. <br><a name="habracut"></a><br><h1>  Deskripsi algoritma keberuntungan </h1><br>  Saya tidak akan menjelaskan bagaimana algoritma bekerja, karena orang lain telah melakukannya dengan baik.  Saya dapat merekomendasikan mempelajari dua artikel ini: di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Yang kedua sangat menarik - penulis menulis demo interaktif dalam Javascript, yang berguna untuk memahami operasi algoritma.  Jika Anda memerlukan pendekatan yang lebih formal dengan semua bukti, saya sarankan membaca Bab 7 dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>Computational Geometry, edisi ke-3</em></a> . <br><br>  Selain itu, saya lebih suka berurusan dengan detail implementasi yang tidak terdokumentasi dengan baik.  Dan merekalah yang membuat implementasi algoritma begitu rumit.  Secara khusus, saya akan fokus pada struktur data yang digunakan. <br><br>  Saya baru saja menulis pseudo-code dari algoritma sehingga Anda mendapatkan gambaran tentang struktur globalnya: <br><br><blockquote><pre>  tambahkan acara tempat ke antrian acara untuk setiap tempat
 hingga antrian acara kosong
     ambil kembali acara teratas
     jika acara tersebut adalah acara tempat
         masukkan busur baru ke garis pantai
         periksa acara lingkaran baru
     jika tidak
         buat simpul dalam diagram
         kami menghapus dari garis pantai busur yang dikencangkan
         hapus acara yang tidak valid
         periksa acara lingkaran baru </pre></blockquote><br><h1>  Bagan struktur data </h1><br>  Masalah pertama yang saya temui adalah memilih cara untuk menyimpan diagram Voronoi. <br><br>  Saya memutuskan untuk menggunakan struktur data yang banyak digunakan dalam geometri komputasi yang disebut daftar tepi terhubung ganda (DCEL). <br><br>  Kelas <code>VoronoiDiagram</code> saya menggunakan empat kontainer sebagai bidang: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">VoronoiDiagram</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-comment"><span class="hljs-comment">// ... private: std::vector&lt;Site&gt; mSites; std::vector&lt;Face&gt; mFaces; std::list&lt;Vertex&gt; mVertices; std::list&lt;HalfEdge&gt; mHalfEdges; }</span></span></code> </pre> <br>  Saya akan berbicara secara rinci tentang masing-masing dari mereka. <br><br>  Kelas <code>Site</code> menjelaskan titik masuk.  Setiap tempat memiliki indeks, yang berguna untuk meletakkannya dalam antrian, koordinat, dan penunjuk ke sel ( <code>face</code> ): <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Site</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> index; Vector2 point; Face* face; };</code> </pre> <br>  Verteks sel diwakili oleh kelas <code>Vertex</code> , mereka hanya memiliki bidang koordinat: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Vertex</span></span></span><span class="hljs-class"> {</span></span> Vector2 point; };</code> </pre> <br>  Berikut ini adalah implementasi dari setengah sisi: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HalfEdge</span></span></span><span class="hljs-class"> {</span></span> Vertex* origin; Vertex* destination; HalfEdge* twin; Face* incidentFace; HalfEdge* prev; HalfEdge* next; };</code> </pre> <br>  Anda mungkin bertanya-tanya, apa itu iga?  Tepi dalam diagram Voronoi adalah umum untuk dua sel tetangga.  Dalam struktur data DCEL, kami membagi tepi ini menjadi dua sisi setengah, satu untuk setiap sel, dan mereka dihubungkan oleh pointer <code>twin</code> .  Selain itu, setengah-tepi memiliki titik awal dan akhir.  Bidang <code>incidentFace</code> menunjukkan wajah yang dimiliki setengah-tepi.  Sel-sel dalam DCEL diimplementasikan sebagai daftar setengah sisi siklik ganda, di mana setengah sisi yang berdekatan dihubungkan bersama.  Oleh karena itu, bidang <code>prev</code> dan <code>next</code> menunjukkan setengah-tepi sebelumnya dan berikutnya dalam sel. <br><br>  Gambar di bawah ini menunjukkan semua bidang ini untuk setengah sisi merah: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/459/a46/ac3/459a46ac330ea630a58cb69d083a2a61.svg"></div><br>  Akhirnya, kelas <code>Face</code> mendefinisikan sel.  Ini hanya berisi pointer ke tempatnya dan yang lain ke salah satu tulang rusuknya.  Tidak masalah bagian tepi mana yang dipilih, karena sel adalah poligon tertutup.  Dengan demikian, kami mendapatkan akses ke semua sisi-setengah saat melintasi daftar terkait siklik. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Face</span></span></span><span class="hljs-class"> {</span></span> Site* site; HalfEdge* outerComponent; };</code> </pre> <br><h1>  Antrian acara </h1><br>  Cara standar untuk mengimplementasikan antrian acara adalah dengan antrian prioritas.  Dalam proses memproses acara tempat dan lingkaran, kami mungkin perlu menghapus acara lingkaran dari antrian karena tidak lagi valid.  Tetapi sebagian besar implementasi antrian prioritas standar tidak memungkinkan Anda untuk menghapus item yang tidak di atas.  Ini berlaku khususnya untuk <code>std::priority_queue</code> . <br><br>  Ada dua cara untuk mengatasi masalah ini.  Yang pertama, lebih sederhana adalah menambahkan bendera yang <code>valid</code> ke acara.  <code>valid</code> awalnya disetel ke <code>true</code> .  Kemudian, alih-alih menghapus acara lingkaran dari antrian, kita dapat dengan mudah mengatur benderanya menjadi <code>false</code> .  Akhirnya, saat memproses semua peristiwa dalam loop utama, kami memeriksa untuk melihat apakah nilai flag yang <code>valid</code> dari acara tersebut <code>false</code> , dan jika demikian, maka lewati saja dan proses yang berikutnya. <br><br>  Metode kedua yang saya terapkan adalah tidak menggunakan <code>std::priority_queue</code> .  Sebaliknya, saya menerapkan antrian prioritas saya sendiri, yang mendukung penghapusan elemen apa pun yang terkandung di dalamnya.  Implementasi antrian semacam itu cukup sederhana.  Saya memilih metode ini karena membuat kode algoritma lebih bersih. <br><br><h1>  Garis pantai </h1><br>  Struktur data garis pantai adalah bagian kompleks dari algoritma.  Dalam hal implementasi yang salah, tidak ada jaminan bahwa algoritma akan dieksekusi di <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-13"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-14">O</span><span class="MJXp-mo" id="MJXp-Span-15" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-16">n</span><span class="MJXp-mtext" id="MJXp-Span-17">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-18">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-19">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-20">g</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-21">n</span><span class="MJXp-mo" id="MJXp-Span-22" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.89ex" height="2.66ex" viewBox="0 -832 4258 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj4mEbl8sCB9ZWfzfgVuGAF5NPiAw#MJMATHI-4F" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj4mEbl8sCB9ZWfzfgVuGAF5NPiAw#MJMAIN-28" x="763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj4mEbl8sCB9ZWfzfgVuGAF5NPiAw#MJMATHI-6E" x="1153" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj4mEbl8sCB9ZWfzfgVuGAF5NPiAw#MJMATHI-6C" x="2003" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj4mEbl8sCB9ZWfzfgVuGAF5NPiAw#MJMATHI-6F" x="2302" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj4mEbl8sCB9ZWfzfgVuGAF5NPiAw#MJMATHI-67" x="2787" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj4mEbl8sCB9ZWfzfgVuGAF5NPiAw#MJMATHI-6E" x="3268" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj4mEbl8sCB9ZWfzfgVuGAF5NPiAw#MJMAIN-29" x="3868" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3"> O (n \ log n) </script>  .  Kunci untuk mendapatkan kompleksitas waktu ini adalah menggunakan pohon penyeimbang sendiri.  Tapi itu lebih mudah diucapkan daripada dilakukan! <br><br>  Sebagian besar sumber daya yang telah saya pelajari (dua artikel yang disebutkan di atas dan buku <em>Geometri Komputasi</em> ) disarankan untuk menerapkan garis pantai sebagai pohon di mana node internal menunjukkan titik istirahat dan daun menunjukkan busur.  Tetapi mereka tidak mengatakan apa-apa tentang bagaimana menyeimbangkan pohon.  Saya pikir model seperti itu bukan yang terbaik, dan inilah alasannya: <br><br><ul><li>  ada informasi yang berlebihan di dalamnya: kita tahu bahwa ada titik istirahat antara dua busur yang berdekatan, sehingga tidak perlu untuk mewakili titik-titik ini sebagai simpul </li><li>  itu tidak memadai untuk menyeimbangkan diri sendiri: hanya subtree yang dibentuk oleh break point yang bisa diseimbangkan.  Kami benar-benar tidak dapat menyeimbangkan seluruh pohon, karena jika tidak, busur dapat menjadi simpul internal dan daun break point.  Menulis algoritma untuk menyeimbangkan hanya subtree yang dibentuk oleh node internal seperti mimpi buruk bagi saya. </li></ul><br>  Karena itu, saya memutuskan untuk menyajikan garis pantai secara berbeda.  Dalam implementasi saya, garis pantai juga merupakan pohon, tetapi semua node adalah busur.  Model seperti itu tidak memiliki kelemahan apa pun yang terdaftar. <br><br>  Berikut adalah definisi <code>Arc</code> arc dalam implementasi saya: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Arc</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Color</span></span></span><span class="hljs-class">{</span></span>RED, BLACK}; <span class="hljs-comment"><span class="hljs-comment">// Hierarchy Arc* parent; Arc* left; Arc* right; // Diagram VoronoiDiagram::Site* site; VoronoiDiagram::HalfEdge* leftHalfEdge; VoronoiDiagram::HalfEdge* rightHalfEdge; Event* event; // Optimizations Arc* prev; Arc* next; // Only for balancing Color color; };</span></span></code> </pre> <br>  Tiga bidang pertama digunakan untuk struktur pohon.  Bidang <code>leftHalfEdge</code> menunjukkan setengah sisi yang ditarik oleh titik paling kiri dari busur.  Dan <code>rightHalfEdge</code> berada di setengah sisi yang ditarik oleh titik kanan ekstrem.  Dua pointer, <code>prev</code> dan <code>next</code> digunakan untuk mendapatkan akses langsung ke busur garis pantai sebelumnya dan berikutnya.  Selain itu, mereka juga memungkinkan Anda untuk memotong garis pantai sebagai daftar tertaut ganda.  Akhirnya, setiap busur memiliki warna yang digunakan untuk menyeimbangkan garis pantai. <br><br>  Untuk menyeimbangkan garis pantai, saya memutuskan untuk menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">skema merah-hitam</a> .  Saat menulis kode, saya terinspirasi oleh buku <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Introduction to Algorithms</a> .  Bab 13 menjelaskan dua algoritma yang menarik, <code>insertFixup</code> dan <code>deleteFixup</code> , yang menyeimbangkan pohon setelah penyisipan atau penghapusan. <br><br>  Namun, saya tidak bisa menggunakan metode <code>insert</code> yang diperlihatkan dalam buku ini, karena tombolnya digunakan untuk menemukan titik penyisipan simpul.  Tidak ada kunci dalam algoritme Fortune, kita hanya tahu bahwa kita perlu memasukkan busur sebelum atau sesudah yang lain di garis pantai.  Untuk mengimplementasikan ini, saya membuat metode <code>insertBefore</code> dan <code>insertAfter</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Beachline::insertBefore(Arc* x, Arc* y) { <span class="hljs-comment"><span class="hljs-comment">// Find the right place if (isNil(x-&gt;left)) { x-&gt;left = y; y-&gt;parent = x; } else { x-&gt;prev-&gt;right = y; y-&gt;parent = x-&gt;prev; } // Set the pointers y-&gt;prev = x-&gt;prev; if (!isNil(y-&gt;prev)) y-&gt;prev-&gt;next = y; y-&gt;next = x; x-&gt;prev = y; // Balance the tree insertFixup(y); }</span></span></code> </pre> <br>  Memasukkan <code>y</code> sebelum <code>x</code> dilakukan dalam tiga langkah: <br><br><ol><li>  Temukan tempat untuk menyisipkan simpul baru.  Untuk melakukan ini, saya menggunakan pengamatan berikut: anak kiri <code>x</code> atau anak kanan <code>x-&gt;prev</code> adalah <code>Nil</code> , dan yang adalah <code>Nil</code> adalah sebelum <code>x</code> dan setelah <code>x-&gt;prev</code> . </li><li>  Di dalam garis pantai, kita menjaga struktur daftar yang ditautkan ganda, jadi kita harus memperbarui petunjuk <code>prev</code> dan <code>next</code> dari elemen <code>x-&gt;prev</code> , <code>y</code> dan <code>x</code> . </li><li>  Akhirnya, kita cukup memanggil metode <code>insertFixup</code> yang dijelaskan dalam buku untuk menyeimbangkan pohon. </li></ol><br>  <code>insertAfter</code> diimplementasikan dengan cara yang sama. <br><br>  Metode penghapusan yang diambil dari buku dapat diterapkan tanpa perubahan. <br><br><h1>  Batas grafik </h1><br>  Berikut ini adalah output dari algoritma Fortune yang dijelaskan di atas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ed5/c3f/443/ed5c3f4438b59de6c99e1645effe0be6.png"></div><br>  Ada masalah kecil dengan beberapa tepi sel di perbatasan gambar: mereka tidak ditarik karena tidak terbatas. <br><br>  Lebih buruk lagi, sel mungkin bukan fragmen tunggal.  Sebagai contoh, jika kita mengambil tiga titik yang berada di garis yang sama, maka titik tengahnya akan memiliki dua sisi setengah tak terbatas yang tidak terhubung bersama.  Ini tidak sesuai dengan kita, karena kita tidak akan dapat mengakses salah satu dari setengah tepi, karena sel adalah daftar tepi yang terhubung. <br><br>  Untuk mengatasi masalah ini, kami akan membatasi diagram.  Maksud saya, kita akan membatasi setiap sel diagram sehingga tidak lagi memiliki tepi yang tidak terbatas dan setiap sel adalah poligon tertutup. <br><br>  Untungnya, algoritme Fortune memungkinkan kita menemukan tepi tanpa ujung dengan cepat: mereka bersesuaian dengan setengah sisi yang masih di garis pantai di akhir algoritme. <br><br>  Algoritme pembatasan saya menerima kotak sebagai input dan terdiri dari tiga langkah: <br><br><ol><li>  Ini menyediakan penempatan setiap simpul diagram di dalam persegi panjang. </li><li>  Potong setiap tepi yang tak terbatas. </li><li>  Menutup sel. </li></ol><br>  Tahap 1 sepele - kita hanya perlu memperluas persegi panjang jika tidak mengandung simpul. <br><br>  Tahap 2 juga cukup sederhana - ini terdiri dari menghitung persimpangan antara sinar dan persegi panjang. <br><br>  Tahap 3 juga tidak terlalu rumit, hanya membutuhkan perhatian.  Saya melakukannya dalam dua tahap.  Pertama, saya menambahkan titik sudut persegi panjang ke sel-sel di simpul yang seharusnya.  Lalu saya memastikan bahwa semua simpul sel terhubung oleh setengah-tepi. <br><br>  Saya sarankan Anda mempelajari kode dan mengajukan pertanyaan jika Anda memerlukan detail tentang bagian ini. <br><br>  Berikut adalah diagram output dari algoritma pembatas: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/33f/910/a79/33f910a79c155bd8a395fca1fd590a72.png"></div><br>  Sekarang kita melihat bahwa semua tepian digambar.  Dan jika Anda memperkecil, Anda dapat memastikan bahwa semua sel ditutup: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f08/402/6a6/f084026a6afbf57b142a60e5cbc49edc.png"></div><br><h1>  Persimpangan dengan persegi panjang </h1><br>  Hebat!  Tetapi gambar pertama dari awal artikel lebih baik, bukan? <br><br>  Dalam banyak aplikasi, penting untuk memiliki persimpangan antara diagram Voronoi dan persegi panjang, seperti yang ditunjukkan pada gambar pertama. <br><br>  Hal yang baik adalah bahwa setelah membatasi grafik, itu jauh lebih mudah dilakukan.  Berita buruknya adalah meskipun algoritmanya tidak terlalu rumit, kita harus berhati-hati. <br><br>  Idenya adalah ini: kita memutar setengah sisi setiap sel dan memeriksa persimpangan antara setengah sisi dan persegi panjang.  Ada lima kasus yang mungkin: <br><br><ol><li>  Setengah rusuk benar-benar di dalam persegi panjang: kita menyimpan setengah rusuk seperti itu </li><li>  Setengah rusuk benar-benar di luar persegi panjang: kita membuang setengah rusuk seperti itu </li><li>  Setengah tulang rusuk keluar dari persegi panjang: kita memotong setengah tulang rusuk dan menyimpannya sebagai <em>setengah tulang rusuk terakhir yang keluar</em> . </li><li>  Setengah rusuk masuk ke dalam persegi panjang: kita memotong setengah rusuk untuk menghubungkannya dengan <em>setengah rusuk terakhir yang keluar</em> (kita simpan dalam kasus 3 atau 5) </li><li>  Setengah rusuk melintasi kotak dua kali: kita memotong setengah rusuk dan menambahkan setengah rusuk untuk mengaitkannya dengan <em>setengah rusuk terakhir yang keluar</em> , dan kemudian menyimpannya sebagai <em>setengah rusuk terakhir</em> baru <em>yang keluar</em> . </li></ol><br>  Ya, sudah banyak kasus.  Saya membuat gambar untuk menunjukkan semuanya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/412/368/3f1/4123683f10d59989d879315f2f83ae17.svg"></div><br>  Poligon oranye adalah sel asli, dan merah adalah sel terpotong.  Setengah rusuk yang terpotong ditandai dengan warna merah.  Iga hijau telah ditambahkan untuk menghubungkan setengah iga memasuki persegi panjang dengan setengah iga keluar. <br><br>  Menerapkan algoritma ini ke diagram terikat, kami mendapatkan hasil yang diharapkan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/50c/df1/56c/50cdf156cb6f5ce5e73ad6308be52dfb.png"></div><br><h1>  Kesimpulan </h1><br>  Artikel itu ternyata cukup panjang.  Dan saya yakin banyak aspek yang masih belum jelas bagi Anda.  Meskipun demikian, saya berharap ini akan bermanfaat bagi Anda.  Periksa kode untuk detailnya. <br><br>  Untuk meringkas dan memastikan bahwa kami tidak membuang waktu dengan sia-sia, saya mengukur pada laptop saya (murah) waktu untuk menghitung diagram Voronoi untuk sejumlah tempat yang berbeda: <br><br><ul><li><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-23"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-24">n</span><span class="MJXp-mo" id="MJXp-Span-25" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-26">1000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="9.143ex" height="1.937ex" viewBox="0 -728.2 3936.6 834" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj4mEbl8sCB9ZWfzfgVuGAF5NPiAw#MJMATHI-6E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj4mEbl8sCB9ZWfzfgVuGAF5NPiAw#MJMAIN-3D" x="878" y="0"></use><g transform="translate(1934,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj4mEbl8sCB9ZWfzfgVuGAF5NPiAw#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj4mEbl8sCB9ZWfzfgVuGAF5NPiAw#MJMAIN-30" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj4mEbl8sCB9ZWfzfgVuGAF5NPiAw#MJMAIN-30" x="1001" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/430628/&amp;usg=ALkJrhj4mEbl8sCB9ZWfzfgVuGAF5NPiAw#MJMAIN-30" x="1501" y="0"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-4"> n = 1000 </script>  : 2 ms </li><li><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-27"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-28">n</span><span class="MJXp-mo" id="MJXp-Span-29" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mrow" id="MJXp-Span-30"><span class="MJXp-mo" id="MJXp-Span-31" style="margin-left: 0em; margin-right: 0em;">$</span></span><span class="MJXp-mn" id="MJXp-Span-32">10.00</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-5"> n = $ 10.00</script>  : 33 ms </li><li><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-33"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-34">n</span><span class="MJXp-mo" id="MJXp-Span-35" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mrow" id="MJXp-Span-36"><span class="MJXp-mo" id="MJXp-Span-37" style="margin-left: 0em; margin-right: 0em;">$</span></span><span class="MJXp-mn" id="MJXp-Span-38">100.00</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-6"> n = $ 100.00</script>  : 450 ms </li><li><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-39"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-40">n</span><span class="MJXp-mo" id="MJXp-Span-41" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mrow" id="MJXp-Span-42"><span class="MJXp-mo" id="MJXp-Span-43" style="margin-left: 0em; margin-right: 0em;">$</span></span><span class="MJXp-mn" id="MJXp-Span-44">1.000.00</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-7"> n = $ 1.000.00</script>  : 6600 ms </li></ul><br>  Saya tidak memiliki apa pun untuk membandingkan indikator-indikator ini, tetapi tampaknya ini sangat cepat! <br><br><h1>  Referensi </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel asli oleh Stephen Fortune</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>Geometri Komputasi, edisi ke-3</em></a> oleh Mark de Berg, Otfried Cheong, Marc van Kreveld dan Mark Overmars </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Algoritma Fortunes: Penjelasan intuitif</a> di jacquesheunis.com </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Algoritma dan implementasi</a> Fortune di blog.ivank.net </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><em>Pengantar Algoritma, edisi ke-3</em></a> oleh Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest dan Clifford Stein </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430628/">https://habr.com/ru/post/id430628/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430614/index.html">Black Friday 2018 di Madrobots.</a></li>
<li><a href="../id430616/index.html">Seminar "Pengujian dan Pemantauan", 27 November, Moskow</a></li>
<li><a href="../id430618/index.html">Vue.js SSR & Mobile Safari: Masalah Yang Tidak Terlihat Dengan Perangkat Lunak Terlalu Cerdas</a></li>
<li><a href="../id430622/index.html">Pemikiran fungsional. Bagian 5</a></li>
<li><a href="../id430626/index.html">Pengumuman Pertemuan GraphQL Moskow</a></li>
<li><a href="../id430632/index.html">Layanan dalam bisnis: Bagaimana pengecer asing membuka toko turnkey di Rusia</a></li>
<li><a href="../id430634/index.html">Membuat modul perangkat lunak untuk programmer XELTEK SuperPro 6100</a></li>
<li><a href="../id430636/index.html">Cerebellum dan inti basal bukan bola kristal: bagaimana otak memprediksi masa depan</a></li>
<li><a href="../id430640/index.html">Laut Merah: mengapa saham Apple dan perusahaan teknologi lainnya jatuh</a></li>
<li><a href="../id430642/index.html">Arahan "Photonics" di Olimpiade "I am a Professional", atau cara mendaftar di magistracy tanpa ujian</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>