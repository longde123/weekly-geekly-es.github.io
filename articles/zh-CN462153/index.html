<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎢 😑 🧑🏿‍🤝‍🧑🏾 Unity交互式地图着色器 🙅🏿 👅 🛀🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="本教程介绍了交互式地图以及如何使用着色器在Unity中创建它们。 

 这种效果可以作为更复杂技术的基础，例如全息投影或电影《黑豹》中的沙盘。 

 本教程的灵感来自Baran Kahyaoglu发布的推文，显示了他为Mapbox创建的示例 。 



 该场景（不包括地图）取自Unity Visu...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Unity交互式地图着色器</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462153/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/511/6a1/e02/5116a1e02debfaa58afe0cddf3b4c6c9.png" alt="图片"></div><br> 本教程介绍了<strong>交互式地图</strong>以及如何使用着色器在Unity中创建它们。 <br><br> 这种效果可以作为更复杂技术的基础，例如全息投影或电影《黑豹》中的沙盘。 <br><br> 本教程的灵感来自<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener">Baran Kahyaoglu</a>发布的推文，显示了他为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener">Mapbox</a>创建的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener">示例</a> 。 <br><a name="habracut"></a><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-0" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1118609807844442112"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br><div class="oembed"><twitter-widget class="twitter-tweet twitter-tweet-rendered" id="twitter-widget-1" style="position: static; visibility: visible; display: block; transform: rotate(0deg); max-width: 100%; width: 500px; min-width: 220px; margin-top: 10px; margin-bottom: 10px;" data-tweet-id="1118610439049494540"></twitter-widget><script async="" src="https://platform.twitter.com/widgets.js" charset="utf-8"></script></div><br> 该场景（不包括地图）取自Unity Visual Effect Graph Spaceship演示（请参见下文），可在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener">此处</a>下载。 <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/rqMcPZoEc3U" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2> 第1部分。顶点偏移 </h2><br><h2> 效果剖析 </h2><br> 您会立即注意到的第一件事是地理地图是<em>平坦的</em> ：如果将它们用作纹理，则它们将缺少对应地图区域的真实3D模型所具有的三维。 <br><br> 您可以应用此解决方案：创建游戏中所需区域的3D模型，然后将地图中的纹理应用于该模型。 这将有助于解决问题，但是需要花费很多时间，并且无法实现视频Baran Kahyaoglu中“滚动”的效果。 <br><br> 显然，最好使用技术含量更高的方法。 幸运的是，可以使用着色器来更改3D模型的几何形状。 在他们的帮助下，您可以将任何飞机变成我们需要的该地区的山谷和山脉。 <br><br> 在本教程中，我们使用智利<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener">的Quillota</a>地图<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener">，</a>该地图以其独特的丘陵而闻名。 下图显示了绘制在圆形网格上的区域的纹理。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a7/b64/0a6/5a7b640a60ca2ce42c9d4ee3f5c95150.png" width="797" height="346"></div><br> 尽管我们看到了丘陵和山脉，但它们仍然完全平坦。 这破坏了现实主义的幻想。 <br><br><h2> 拉伸法线 </h2><br> 使用着色器更改几何形状的第一步是称为<strong>法线拉伸</strong>的技术。 她需要<strong>一个顶点修改器</strong> ：可以操纵3D模型各个顶点的功能。 <br><br> 使用顶点修改器的方式取决于所使用着色器的类型。 在本教程中，我们将更改<strong>Surface标准着色器</strong> -您可以在Unity中创建的着色器类型之一。 <br><br> 有很多方法可以操纵3D模型的顶点。 大多数顶点着色器教程中介绍的最早的方法之一就是<strong>拉伸法线</strong> 。 它包括将每个顶点“推出”（ <em>拉伸</em> ），这使3D模型看起来更肿胀。  “外部”是指每个顶点沿法线方向移动。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/275/3e4/fe3/2753e4fe3502d77d46d7205e1ec81809.png"></div><br> 对于光滑的表面，此方法效果很好，但是在顶点连接不良的模型中，此方法会产生奇怪的伪像。 在我的第一个教程之一《 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener">着色器的温和介绍》中</a>很好地解释了这种效果，在该教程中，我展示了如何<strong>拉伸</strong>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener">引入</a> 3D模型。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a8/668/0e5/5a86680e5ab92b536d4999e693aed8cb.gif" width="485" height="278"></div><br> 将拉伸的法线添加到曲面着色器非常容易。 每个表面着色器都有一个<code>#pragma</code> ，该<code>#pragma</code>用于传输其他信息和命令。 一个这样的命令是<code>vert</code> ，这意味着<code>vert</code>函数将用于处理3D模型的每个顶点。 <br><br> 编辑的着色器如下： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf Standard fullforwardshadows addshadow vertex:vert ... float _Amount; ... void vert(inout appdata_base v) { v.vertex.xyz += v.normal * _Amount; }</span></span></code> </pre> <br> 由于我们要更改顶点的位置，因此，如果我们希望模型正确在自身上投射阴影，则还需要使用<code>addshadow</code> 。 <br><br><div class="spoiler">  <b class="spoiler_title">什么是appdata_base？</b> <div class="spoiler_text"> 如您所见，我们添加了一个vertices修饰符（ <code>vert</code> ）函数，该函数将名为<code>appdata_base</code>的<em>结构</em>作为参数。 此结构存储有关3D模型的每个单独顶点的信息。 它不仅包含<em>顶点位置</em> （ <code>v.vertex</code> ），还包含其他字段，例如<em>法线方向</em> （ <code>v.normal</code> ）和与该顶点关联的<em>纹理信息</em> （ <code>v.texcoord</code> ）。 <br><br> 在某些情况下，这还不够，我们可能需要其他属性，例如<em>顶点颜色</em> （ <code>v.color</code> ）和<em>切线方向</em> （ <code>v.tangent</code> ）。 可以使用多种其他<code>appdata_tan</code>结构（包括<code>appdata_tan</code>和<code>appdata_full</code>指定顶点修饰符，这些<code>appdata_tan</code>结构以较低的性能<code>appdata_full</code>为代价提供了更多信息。 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener">Unity3D Wiki中</a>阅读有关<code>appdata</code> （及其变体）的更多信息。 </div></div><br><div class="spoiler">  <b class="spoiler_title">vert如何返回值？</b> <div class="spoiler_text">  top函数没有返回值。 如果您熟悉C＃语言，则应该知道结构是通过值传递的，也就是说，当<code>v.vertex</code>更改时<code>v.vertex</code>这仅影响<code>v</code>的副本，其范围受函数主体的限制。 <br><br> 但是， <code>v</code>也被声明为<code>inout</code> ，这意味着它既用于输入又用于输出。 您所做的任何更改都会更改变量本身，该变量将传递给<code>vert</code> 。 关键字<code>inout</code>和<code>out</code>在计算机图形学中经常使用，它们可以与C＃中的<code>ref</code>和<code>out</code>大致相关。 </div></div><br><h2> 使用纹理拉伸法线 </h2><br> 我们上面使用的代码可以正常工作，但远没有我们想要达到的效果。 原因是我们不想将所有顶点拉伸相同的数量。 我们希望3D模型的表面与相应地理区域的山谷和山脉相匹配。 首先，我们需要以某种方式存储和检索有关地图上每个点升高了多少的信息。 我们希望拉伸受纹理的影响，在纹理中对风景的高度进行编码。 这样的纹理通常称为<strong>高度图</strong> ，但根据上下文，通常也称为<strong>深度图</strong> 。 收到有关高度的信息后，我们将能够基于高度图修改平面的拉伸。 如图所示，这将使我们能够控制区域的上升和下降。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0f3/223/118/0f32231186763ee73f27bde4a1d2c5bf.png"></div><br> 查找您感兴趣的地理区域的卫星图像和相关的海拔图非常简单。 以下是本教程中使用的火星卫星图（上方）和高度图（下方）： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b80/468/176/b804681769208dfc72ec69441d9f0986.jpg"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/266/f0c/b59/266f0cb59bb01a7f875d3323d526372a.png"></div><br> 我在另一系列教程<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener">“内部的Facebook 3D照片：视差着色器”</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">翻译</a>为Habré）中详细讨论了深度图的概念。 <br><br> 在本教程中，我们将假定高度图以灰度图像形式存储，其中黑白分别对应于较低和较高的高度。 我们还需要这些值<em>线性</em>缩放，即色差，例如<code>0.1</code>对应于<code>0</code>到<code>0.1</code>之间或<code>0.9</code>到<code>1.0</code>之间的高度差。 对于深度图，这并不总是正确的，因为许多深度图以<em>对数刻度</em>存储深度信息。 <br><br> 要对纹理进行采样，需要两个信息元素：纹理本身和我们要采样<strong>的</strong>点的<strong>UV坐标</strong> 。 后者可以通过存储在<code>appdata_base</code>结构中的<code>texcoord</code>字段进行访问。 这是与当前正在处理的顶点关联的UV坐标。  <em>表面函数中的</em>纹理采样是使用<code>tex2D</code>完成的，但是当我们处于<code> </code> ，则需要<code>tex2Dlod</code> 。 <br><br> 在下面的代码段中，称为<code>_HeightMap</code>的纹理用于修改对每个顶点执行的拉伸值： <br><br><pre> <code class="cpp hljs">sampler2D _HeightMap; ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ fixed height = tex2Dlod(_HeightMap, float4(v.texcoord.xy, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)).r; vertex.xyz += v.normal * height * _Amount; }</code> </pre> <br> 为什么不能将tex2D用作顶点函数？ <br> 如果查看Unity为Standard Surface Shader生成的代码，您会注意到它已经包含了如何对纹理进行采样的示例。 特别是，它使用内置的<code>tex2D</code>函数在<em>表面函数</em> （称为<code>surf</code> ）中采样<em>主要纹理</em> （称为<code>_MainTex</code> ）。 <br><br> 实际上， <code>tex2D</code>用于从纹理中采样像素，而不管纹理中存储的内容，颜色或高度如何。 但是，您可能会注意到<code>tex2D</code>不能在顶点函数中使用。 <br><br> 原因是<code>tex2D</code> <em>不仅</em>从纹理读取像素。 她还根据与相机的距离来决定使用哪个版本的纹理。 该技术称为<strong>mipmapping</strong> ：它使您可以使用较小版本的单个纹理，并可以在不同距离自动使用该纹理。 <br><br> 在表面功能中，着色器已经知道<strong>要</strong>使用哪个<strong>MIP纹理</strong> 。 该信息可能在顶点功能中尚不可用，因此无法完全放心使用<code>tex2D</code> 。 与此相反，可以向<code>tex2Dlod</code>函数传递两个附加参数，在本教程中，该参数可以为零。 <br><br> 结果在以下图像中清晰可见。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5a7/b64/0a6/5a7b640a60ca2ce42c9d4ee3f5c95150.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0b/dbf/dad/c0bdbfdadf38764dd3d75ffb69d07dea.png"></div><br> 在这种情况下，可以略微简化。 我们之前回顾的代码可以适用于任何几何体。 但是，我们可以假定表面绝对平坦。 实际上，我们确实希望将此效果应用于飞机。 <br><br> 因此，您可以删除<code>v.normal</code>并将其替换为<code>float3(0, 1, 0)</code> ： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ float3 normal = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); fixed height = tex2Dlod(_HeightMap, float4(v.texcoord.xy, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)).r; vertex.xyz += normal * height * _Amount; }</code> </pre> <br> 我们之所以可以这样做，是因为<code>appdata_base</code>中的所有坐标都存储在<strong>模型空间中</strong> ，也就是说，它们是相对于3D模型的中心和方向设置的。  Unity中的带有<em>变换的</em>过渡，旋转和缩放可更改对象的位置，旋转和缩放，但不影响原始3D模型。 <br><br><h2> 第2部分。滚动效果 </h2><br> 我们上面所做的一切都运行良好。 在继续之前，我们将提取新顶点高度所需的代码提取到单独的<code>getVertex</code>函数中： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getVertex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float4 vertex, float2 texcoord)</span></span></span><span class="hljs-function"> </span></span>{ float3 normal = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); fixed height = tex2Dlod(_HeightMap, float4(texcoord, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)).r; vertex.xyz += normal * height * _Amount; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vertex; }</code> </pre> <br> 然后整个函数<code>vert</code>将具有以下形式： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ vertex = getVertex(v.vertex, v.texcoord.xy); }</code> </pre> <br> 我们这样做是因为在下面，我们需要计算几个点的高度。 由于此功能将是其自己的单独功能，因此代码将变得更加简单。 <br><br><h2> 紫外线坐标计算 </h2><br> 但是，这导致了另一个问题。  <code>getVertex</code>函数不仅取决于当前顶点的位置（v.vertex），还取决于其UV坐标（ <code>v.texcoord</code> ）。 <br><br> 当我们要计算<code>vert</code>函数当前正在处理的顶点高度偏移时，两个数据元素在<code>appdata_base</code>结构中均可用。 但是，如果我们需要对相邻点的位置进行采样会怎样？ 在这种情况下，我们可以知道xyz在<strong>模型空间中的</strong>位置，但是我们无法访问其UV坐标。 <br><br> 这意味着现有系统仅能为当前顶点计算高度偏移。 这样的限制将使我们无法继续前进，因此我们需要找到解决方案。 <br><br> 最简单的方法是找到一种方法，在知道其顶点位置的情况下计算3D对象的UV坐标。 这是一项非常艰巨的任务，有多种解决方法（最流行的一种是<strong>三边形投影</strong> ）。 但是在这种特殊情况下，我们不需要将UV与几何形状匹配。 如果我们假定将始终将着色器应用于平面网格，那么任务就变得微不足道了。 <br><br> 我们可以根据<em>顶点</em> （上图）的<em>位置</em>计算<em>UV坐标</em> （下图），这是因为它们都线性地叠加在一个平面网格上。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/147/614/a7a/147614a7a05ba08700aef85be89f3a53.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/02f/ff8/c42/02fff8c42dae9fa7de4f7e9598843afe.png" width="359" height="210"></div><br> 这意味着为了解决我们的问题，我们需要<em>将顶点位置</em>的<em>分量XZ</em>转换为相应的<em>UV坐标</em> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48a/607/6b0/48a6076b06650e1074dd5b0f2f7ed023.png" width="363" height="393"></div><br> 此过程称为<strong>线性插值</strong> 。 我的网站上对此进行了详细讨论（例如： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener">颜色插值的秘密</a> ）。 <br><br> 在大多数情况下，UV值在 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>0</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMAIN-30" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>0</mn></math></span></span><script type="math/tex" id="MathJax-Element-1"> 0 </script> 之前 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMAIN-31" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-2"> 1 </script>  ; 相反，每个顶点的坐标可能是无限的。 从数学的角度来看，从XZ转换为UV，我们只需要它们的极限值： <br><br><ul><li><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>X</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.153ex" height="2.419ex" viewBox="0 -780.1 2218.6 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-58" x="0" y="0"></use><g transform="translate(828,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-69" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-6E" x="1224" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>X</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-3"> X_ {min} </script>  ， <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>X</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.409ex" height="2.419ex" viewBox="0 -780.1 2328.9 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-58" x="0" y="0"></use><g transform="translate(828,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-61" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-78" x="1408" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>X</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-4"> X_ {max} </script></li><li><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>Z</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.816ex" height="2.419ex" viewBox="0 -780.1 2073.6 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-5A" x="0" y="0"></use><g transform="translate(683,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-69" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-6E" x="1224" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>Z</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-5"> Z_ {min} </script>  ， <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>Z</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.072ex" height="2.419ex" viewBox="0 -780.1 2183.9 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-5A" x="0" y="0"></use><g transform="translate(683,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-61" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-78" x="1408" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>Z</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-6"> Z_ {max} </script></li><li><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>U</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.816ex" height="2.419ex" viewBox="0 -780.1 2073.6 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-55" x="0" y="0"></use><g transform="translate(683,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-69" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-6E" x="1224" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>U</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-7"> U_ {min} </script>  ， <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>U</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.072ex" height="2.419ex" viewBox="0 -780.1 2183.9 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-55" x="0" y="0"></use><g transform="translate(683,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-61" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-78" x="1408" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>U</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-8"> U_ {max} </script></li><li><math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>V</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.584ex" height="2.419ex" viewBox="0 -780.1 1973.6 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-56" x="0" y="0"></use><g transform="translate(583,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-69" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-6E" x="1224" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>V</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-9"> V_ {min} </script>  ， <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>V</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.84ex" height="2.419ex" viewBox="0 -780.1 2083.9 1041.5" role="img" focusable="false" style="vertical-align: -0.607ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-56" x="0" y="0"></use><g transform="translate(583,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-61" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-78" x="1408" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>V</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-10"> V_ {max} </script></li></ul><br> 如下所示： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/87a/520/05c/87a52005ccc02b02403068fd3e075864.png" width="359" height="210"></div><br> 这些值取决于所使用的网格。 在Unity平面上， <em>UV坐标</em>的范围为 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>0</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMAIN-30" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>0</mn></math></span></span><script type="math/tex" id="MathJax-Element-11"> 0 </script> 之前 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mn>1</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMAIN-31" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mn>1</mn></math></span></span><script type="math/tex" id="MathJax-Element-12"> 1 </script>  ，并且<em>顶点</em>的<em>坐标</em>在的范围内 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo>&amp;#x2212;</mo><mn>5</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.971ex" height="2.057ex" viewBox="0 -728.2 1279 885.9" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMAIN-2212" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMAIN-35" x="778" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo>−</mo><mn>5</mn></math></span></span><script type="math/tex" id="MathJax-Element-13"> -5 </script> 之前 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mo>+</mo><mn>5</mn></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.971ex" height="2.057ex" viewBox="0 -728.2 1279 885.9" role="img" focusable="false" style="vertical-align: -0.366ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMAIN-2B" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMAIN-35" x="778" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mo>+</mo><mn>5</mn></math></span></span><script type="math/tex" id="MathJax-Element-14"> + 5 </script>  。 <br><br> 将XZ转换为UV的公式为： <br><br>  （1） <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d2/e5c/a22/7d2e5ca229d8fc1c135aaa42e863fc9c.svg" alt="图片"></div><br><br><div class="spoiler">  <b class="spoiler_title">如何显示？</b> <div class="spoiler_text"> 如果您不熟悉线性插值的概念，那么这些方程式可能看起来很吓人。 <br><br> 但是，它们的显示非常简单。 让我们看一个例子。 <math></math><img src="https://habrastorage.org/getpro/habr/formulas/d07/cc5/b26/d07cc5b26db621faab45e0e0b54ede62.svg" alt="ü" data-tex="inline">  。 我们有两个间隔：一个间隔的值来自 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-15-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>X</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.153ex" height="2.349ex" viewBox="0 -772.3 2218.6 1011.3" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.555ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-58" x="0" y="0"></use><g transform="translate(828,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-69" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-6E" x="1224" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>X</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-15"> X_ {min} </script> 之前 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-16-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>X</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.409ex" height="2.349ex" viewBox="0 -772.3 2328.9 1011.3" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.555ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-58" x="0" y="0"></use><g transform="translate(828,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-61" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-78" x="1408" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>X</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-16"> X_ {max} </script> 来自另一个 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-17-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>U</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.816ex" height="2.349ex" viewBox="0 -772.3 2073.6 1011.3" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.555ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-55" x="0" y="0"></use><g transform="translate(683,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-69" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-6E" x="1224" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>U</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>i</mi><mi>n</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-17"> U_ {min} </script> 之前 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-18-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msub><mi>U</mi><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.072ex" height="2.349ex" viewBox="0 -772.3 2183.9 1011.3" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.555ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-55" x="0" y="0"></use><g transform="translate(683,-150)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-61" x="878" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-78" x="1408" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msub><mi>U</mi><mrow class="MJX-TeXAtom-ORD"><mi>m</mi><mi>a</mi><mi>x</mi></mrow></msub></math></span></span><script type="math/tex" id="MathJax-Element-18"> U_ {max} </script>  。 坐标输入数据 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-19-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>X</mi></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.98ex" height="2.074ex" viewBox="0 -772.3 852.5 892.8" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-58" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>X</mi></math></span></span><script type="math/tex" id="MathJax-Element-19"> X </script> 是正在处理的当前顶点的坐标，而输出将是坐标 <math></math><img src="https://habrastorage.org/getpro/habr/formulas/d07/cc5/b26/d07cc5b26db621faab45e0e0b54ede62.svg" alt="ü" data-tex="inline"> 用于采样纹理。 <br><br> 我们需要保持之间的比例属性 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-20-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>X</mi></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.98ex" height="2.074ex" viewBox="0 -772.3 852.5 892.8" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-58" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>X</mi></math></span></span><script type="math/tex" id="MathJax-Element-20"> X </script> 及其间隔，以及 <math></math><img src="https://habrastorage.org/getpro/habr/formulas/d07/cc5/b26/d07cc5b26db621faab45e0e0b54ede62.svg" alt="ü" data-tex="inline"> 及其间隔。 例如，如果 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-21-Frame" tabindex="0" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>X</mi></math>" role="presentation" style="font-size: 100%; display: inline-block; position: relative;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.98ex" height="2.074ex" viewBox="0 -772.3 852.5 892.8" role="img" focusable="false" aria-hidden="true" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-58" x="0" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>X</mi></math></span></span><script type="math/tex" id="MathJax-Element-21"> X </script> 那么重要的是其间隔的25％ <math></math><img src="https://habrastorage.org/getpro/habr/formulas/d07/cc5/b26/d07cc5b26db621faab45e0e0b54ede62.svg" alt="ü" data-tex="inline"> 也将影响其间隔的25％。 <br><br> 下图显示了所有这些： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/22a/784/da1/22a784da18e327b20b872699a901f0ec.png" width="292" height="202"></div><br> 由此，我们可以推断出红色部分相对于粉红色的比例应与蓝色部分和蓝色之间的比例相同： <br><br>  （2） <div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bcc/9e1/49e/bcc9e149ea65e83dd70345dd92784788.png" height="39" width="232"></div><br> 现在我们可以将上面显示的方程式转换为 <math></math><img src="https://habrastorage.org/getpro/habr/formulas/d07/cc5/b26/d07cc5b26db621faab45e0e0b54ede62.svg" alt="ü" data-tex="inline">  ： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/737/266/0fe/7372660fe877b0780e4cebc97a6f22f2.png" height="85" width="388"></div><br> 并且该方程式具有与上式（1）完全相同的形式。 </div></div><br> 这些等式可以用以下代码实现： <br><br><pre> <code class="cpp hljs">float2 _VertexMin; float2 _VertexMax; float2 _UVMin; float2 _UVMax; <span class="hljs-function"><span class="hljs-function">float2 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vertexToUV</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float4 vertex)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (vertex.xz - _VertexMin) / (_VertexMax - _VertexMin) * (_UVMax - _UVMin) + _UVMin; }</code> </pre> <br> 现在我们可以调用<code>getVertex</code>函数，而不必将<code>v.texcoord</code>传递<code>v.texcoord</code> ： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getVertex</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float4 vertex)</span></span></span><span class="hljs-function"> </span></span>{ float3 normal = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); float2 texcoord = vertexToUV(vertex); fixed height = tex2Dlod(_HeightMap, float4(texcoord, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)).r; vertex.xyz += normal * height * _Amount; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vertex; }</code> </pre> <br> 然后整个函数<code>vert</code>采用以下形式： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ v.vertex = getVertex(v.vertex); }</code> </pre> <br><h3> 滚动效果 </h3><br> 多亏了我们编写的代码，整个地图都显示在网格上。 如果要改善显示效果，则需要进行更改。 <br><br> 让我们再规范一些代码。 首先，我们可能需要放大地图的单独部分，而不是整体查看。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b5/1c3/bcd/0b51c3bcd59365527d3659564768b01b.png" width="530" height="309"></div><br> 该区域可以由两个值定义：其大小（ <code>_CropSize</code> ）和在地图上的位置（ <code>_CropOffset</code> ），以<em>顶点空间</em> （从<code>_VertexMin</code>到<code>_VertexMax</code> ） <code>_VertexMax</code> 。 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Cropping float2 _CropSize; float2 _CropOffset;</span></span></code> </pre> <br> 接收到这两个值后，我们可以再次使用线性插值，这样<code>getVertex</code>不会为3D模型顶部的当前位置调用<code>getVertex</code> ，而是为缩放和转移点调用<code>getVertex</code> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0c/620/418/c0c620418088c383addcaa54328fe0fc.png" width="529" height="589"></div><br> 相关代码： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ float2 croppedMin = _CropOffset; float2 croppedMax = croppedMin + _CropSize; <span class="hljs-comment"><span class="hljs-comment">// v.vertex.xz: [_VertexMin, _VertexMax] // cropped.xz : [croppedMin, croppedMax] float4 cropped = v.vertex; cropped.xz = (v.vertex.xz - _VertexMin) / (_VertexMax - _VertexMin) * (croppedMax - croppedMin) + croppedMin; v.vertex.y = getVertex(cropped); }</span></span></code> </pre> <br> 如果我们要滚动，那么通过脚本更新<code>_CropOffset</code>就足够了。 因此，截断区域将移动，实际上在整个景观中滚动。 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MoveMap</span></span></span><span class="hljs-class"> :</span></span> MonoBehaviour { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Material Material; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 Speed; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector2 Offset; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> CropOffsetID; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ CropOffsetID = Shader.PropertyToID(<span class="hljs-string"><span class="hljs-string">"_CropOffset"</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Material.SetVector(CropOffsetID, Speed * Time.time + Offset); } }</code> </pre> <br> 为此， <strong>将</strong>所有纹理的“ <strong>环绕模式”</strong>设置为“ <strong>重复”</strong>非常重要。 如果不这样做，那么我们将无法循环纹理。 <br><br> 对于缩放/缩放效果，只需更改<code>_CropSize</code> 。 <br><br><h2> 第3部分。地形阴影 </h2><br><h2> 平面阴影 </h2><br> 我们编写的所有代码都可以运行，但是存在严重问题。 对模型进行着色有点奇怪。 该表面是适当弯曲的，但是对光的反应就像是平坦的。 <br><br> 在下面的图片中可以很清楚地看到这一点。 顶部图像显示了现有的着色器； 底部显示了它的实际工作方式。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c0b/dbf/dad/c0bdbfdadf38764dd3d75ffb69d07dea.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/511/6a1/e02/5116a1e02debfaa58afe0cddf3b4c6c9.png"></div><br> 解决这个问题可能是一个很大的挑战。 但是首先，我们需要找出错误所在。 <br><br> 正常的挤出操作更改了我们最初使用的平面的总体几何形状。 但是，Unity仅更改了顶点的位置，而不更改了它们的法线方向。 顾名思义，顶点<strong>法线的方向</strong>是指示垂直于表面的单位长度矢量（ <em>方向</em> ）。  <em>法线是</em>必需的，因为<em>法线</em>在3D模型着色中起着重要作用。 所有曲面着色器都使用它们来计算应如何从3D模型的每个三角形反射光。 通常，这对于改善模型的三维度是必要的，例如，它使光从平面反射，就像它从曲面反射一样。 此技巧通常用于使低多边形表面看起来比实际表面更平滑（请参见下文）。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6b/d7c/443/f6bd7c443381c1f0e133ee7b7bce05e1.png"></div><br> 但是，在我们的情况下，情况恰恰相反。 几何形状是弯曲且平滑的，但是由于所有法线都指向上方，因此从模型反射的光就像是平坦的（请参见下文）： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/323/241/cde/323241cdef1b3a41604c579f4fdb509b.png"></div><br> 您可以在法线<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener">贴图（凹凸贴图）</a>上的文章中了解有关法线在对象着色中的作用的更多信息，该文章中，尽管使用相同的3D模型，但由于计算顶点法线的方法不同，相同的圆柱体看起来也非常不同（请参见下文）。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1b7/4fc/15f/1b74fc15f90516cc80b283953ef12373.png" width="315" height="243"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f93/544/d9c/f93544d9c95a70da71848897f0913676.png" width="347" height="254"></div><br> 不幸的是，Unity和用于创建着色器的语言都没有内置的解决方案来自动重新计算法线。 这意味着您必须根据3D模型的局部几何形状手动更改它们。 <br><br><h2> 正常计算 </h2><br> 解决阴影问题的唯一方法是根据表面几何形状手动计算法线。 在“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener">顶点位移-融合着色器”第1部分</a>的帖子中讨论了类似的任务，该任务用于模拟“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener">圆锥大战”</a>中3D模型的融合。 <br><br> 尽管完成的代码将必须在3D坐标中工作，但是现在让我们将任务限制为仅二维。 想象一下，您需要计算与2D曲线上的点相对应<strong>的法线方向</strong> （下图中的蓝色大箭头）。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5a/405/6be/e5a4056be62b920d9721a84d7c050ee6.png" width="316" height="346"></div><br> 从几何角度来看， <em>法线</em> （蓝色大箭头）的方向是垂直于<strong>切线</strong>的矢量，该<strong>切线</strong>通过感兴趣点到达我们（一条细蓝线）。  <em>切线</em>可以表示为位于模型曲率上的线。  <strong>切向量</strong>是位于切线上的<em>单位向量</em> 。 <br><br> 这意味着要计算法线，您需要执行两个步骤：首先，找到与所需点<em>相切</em>的线； 然后计算与其垂直的向量（这将是<em>法线</em>的必要<em>方向</em> ）。 <br><br><h3> 切线计算 </h3><br> 为了得到<em>法线，</em>我们首先需要计算<em>切线</em> 。 可以通过在附近采样一个点并使用它在顶点附近建立一条线来近似。 线越小，值越准确。 <br><br> 需要三个步骤： <br><br><ul><li> 阶段1.在平面上移动少量 </li><li> 步骤2.计算新点的高度。 </li><li> 步骤3.使用当前点的高度计算切线 </li></ul><br> 所有这些都可以在下图中看到： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/46f/bd3/7e8/46fbd37e868d16ff7ec6f1a164377018.png"></div><br> 为此，我们需要计算两个点而不是一个点的高度。 幸运的是，我们已经知道如何做到这一点。 在本教程的上一部分中，我们创建了一个函数，该函数根据网格点对景观的高度进行采样。 我们称它为<code>getVertex</code> 。 <br><br> 我们可以在当前点取新的顶点值，然后在其他两个点取。 一种是切线，另一种是切线的两点。 在他们的帮助下，我们得到了正常。 如果用于创建效果的原始网格是平坦的（在我们的情况下是平坦的），那么我们就不需要访问<code>v.normal</code> ，我们可以只使用<code>float3(0, 0, 1)</code>表示切线和切线到两个点<code>float3(0, 0, 1)</code>和<code>float3(1, 0, 0)</code> 。 如果我们想做同样的事情，例如对于一个球体，那么要找到两个合适的点来计算切线和切到两个点的切线将要困难得多。 <br><br><h3> 矢量图稿 </h3><br> 获得合适的切线和切线向量到两点后，我们可以使用称为<strong>向量积</strong>的运算来计算法线。 向量工作及其作用的定义和解释很多。 <br><br> 向量乘积接收两个向量并返回一个新的向量。 如果两个初始向量是单位（它们的长度等于1），并且它们的夹角为90度，则所得向量将相对于两个向量成90度角。 <br><br> 首先，这可能会造成混淆，但是可以用图形表示如下：两个轴的向量积创建第三个轴。 那是 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-22-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>X</mi><mtext mathcolor=&quot;red&quot;>\&amp;#x4E58;</mtext><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x4EE5;</mo></mrow><mi>Y</mi><mo>=</mo><mi>Z</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="13.55ex" height="2.66ex" viewBox="0 -832 5834 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-58" x="0" y="0"></use><g fill="red" stroke="red" transform="translate(852,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMAIN-5C"></use><g transform="translate(500,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">乘</text></g></g><g transform="translate(2182,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">以</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-59" x="3012" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMAIN-3D" x="4054" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-5A" x="5110" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>X</mi><mtext mathcolor="red">\乘</mtext><mrow class="MJX-TeXAtom-ORD"><mo>以</mo></mrow><mi>Y</mi><mo>=</mo><mi>Z</mi></math></span></span><script type="math/tex" id="MathJax-Element-22"> X \乘以Y = Z </script> 而且 <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-23-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><mi>X</mi><mtext mathcolor=&quot;red&quot;>\&amp;#x4E58;</mtext><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mo>&amp;#x4EE5;</mo></mrow><mi>Z</mi><mo>=</mo><mi>Y</mi></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="13.55ex" height="2.66ex" viewBox="0 -832 5834 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-58" x="0" y="0"></use><g fill="red" stroke="red" transform="translate(852,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMAIN-5C"></use><g transform="translate(500,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">乘</text></g></g><g transform="translate(2182,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">以</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-5A" x="3012" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMAIN-3D" x="4014" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/462153/&amp;usg=ALkJrhjB9SQO5wMJddZWkvoij_XxHlE7tw#MJMATHI-59" x="5070" y="0"></use></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><mi>X</mi><mtext mathcolor="red">\乘</mtext><mrow class="MJX-TeXAtom-ORD"><mo>以</mo></mrow><mi>Z</mi><mo>=</mo><mi>Y</mi></math></span></span><script type="math/tex" id="MathJax-Element-23"> X \乘以Z = Y </script> 等等。 <br><br> 如果我们采取足够小的步长（在代码中为<code>offset</code> ），则切线和切线与两个点的向量将成90度角。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">它们与法线向量一起形成了沿模型表面定向的三个垂直轴。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">知道了这一点，我们可以编写所有必要的代码来计算和更新法线向量。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ float3 bitangent = float3(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); float3 tangent = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> offset = <span class="hljs-number"><span class="hljs-number">0.01</span></span>; float4 vertexBitangent = getVertex(v.vertex + float4(bitangent * offset, <span class="hljs-number"><span class="hljs-number">0</span></span>) ); float4 vertex = getVertex(v.vertex); float4 vertexTangent = getVertex(v.vertex + float4(tangent * offset, <span class="hljs-number"><span class="hljs-number">0</span></span>) ); float3 newBitangent = (vertexBitangent - vertex).xyz; float3 newTangent = (vertexTangent - vertex).xyz; v.normal = cross(newTangent, newBitangent); v.vertex.y = vertex.y; }</code> </pre> <br><h3> 全部放在一起 </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 现在一切正常，我们可以返回滚动效果。 </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">vert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(inout appdata_base v)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// v.vertex.xz: [_VertexMin, _VertexMax] // cropped.xz : [croppedMin, croppedMax] float2 croppedMin = _CropOffset; float2 croppedMax = croppedMin + _CropSize; float4 cropped = v.vertex; cropped.xz = (v.vertex.xz - _VertexMin) / (_VertexMax - _VertexMin) * (croppedMax - croppedMin) + croppedMin; float3 bitangent = float3(1, 0, 0); float3 normal = float3(0, 1, 0); float3 tangent = float3(0, 0, 1); float offset = 0.01; float4 vertexBitangent = getVertex(cropped + float4(bitangent * offset, 0) ); float4 vertex = getVertex(cropped); float4 vertexTangent = getVertex(cropped + float4(tangent * offset, 0) ); float3 newBitangent = (vertexBitangent - vertex).xyz; float3 newTangent = (vertexTangent - vertex).xyz; v.normal = cross(newTangent, newBitangent); v.vertex.y = vertex.y; v.texcoord = float4(vertexToUV(cropped), 0,0); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 至此，我们的效果终于完成了。 </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d9/b07/680/0d9b0768068b2329d53e22a71ff27dfb.gif" width="700" height="272"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 接下来要去哪里 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">本教程可以成为更复杂效果的基础，例如全息投影或什</font><font style="vertical-align: inherit;">至是电影《黑豹》</font><font style="vertical-align: inherit;">中的</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">沙盘</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">副本</font><font style="vertical-align: inherit;">。</font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/ecS1_-Y_uP8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unity包 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patreon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上下载本教程的完整软件包</font><font style="vertical-align: inherit;">，其中包含发挥上述效果所需的所有资产。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN462153/">https://habr.com/ru/post/zh-CN462153/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN462141/index.html">数据中心购物车</a></li>
<li><a href="../zh-CN462145/index.html">为什么要花几天的时间取消订阅？</a></li>
<li><a href="../zh-CN462147/index.html">在React Native中重构项目旧版时使用导航</a></li>
<li><a href="../zh-CN462149/index.html">iOS设备上配件的访问限制模式及其旁路方法</a></li>
<li><a href="../zh-CN462151/index.html">5个顶级Kubernetes发行版</a></li>
<li><a href="../zh-CN462155/index.html">与工人合作，如您所愿，而不是“尽可能地”</a></li>
<li><a href="../zh-CN462159/index.html">建立基于Golang和OpenCV的人脸识别系统</a></li>
<li><a href="../zh-CN462161/index.html">体验在Windows 10上安装Apache Airflow的经验</a></li>
<li><a href="../zh-CN462163/index.html">2020年将流行的技术</a></li>
<li><a href="../zh-CN462165/index.html">如何欺骗25个人为一家不存在的游戏公司工作</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>