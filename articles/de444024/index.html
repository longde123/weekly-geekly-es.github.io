<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤚🏾 🅿️ 👛 So implementieren Sie eine Programmiersprache in JavaScript. Teil 3: CPS-Dolmetscher ✌🏽 🤘🏿 💇🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo! Ich präsentiere Ihnen den dritten Teil meiner Übersetzung des Handbuchs zur Implementierung meiner JavaScript-Programmiersprache - PL Tutorial ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>So implementieren Sie eine Programmiersprache in JavaScript. Teil 3: CPS-Dolmetscher</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444024/"><p>  Hallo!  Ich präsentiere Ihnen den dritten Teil meiner Übersetzung des Handbuchs zur Implementierung meiner JavaScript-Programmiersprache - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">PL Tutorial</a> . </p><br><h1 id="ot-perevodchika">  Vom Übersetzer </h1><br><p>  Wir werden unsere eigene Programmiersprache erstellen - <strong>λ-Sprache</strong> (im Original - λanguage).  Während des Erstellungsprozesses werden wir viele interessante Techniken verwenden, wie z. B. rekursiven Abstieg, Kontrollübertragungsstil und grundlegende Optimierungstechniken.  Es werden zwei Versionen des Interpreters erstellt - der reguläre und der CPS-Interpreter, der Transcompiler in JavaScript. </p><br><p>  Der Autor des Originals ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mihai Bazon</a> , der Autor der berühmten UglifyJS-Bibliothek (ein Tool zum Minimieren und Formatieren von JS-Code). </p><a name="habracut"></a><br><div class="spoiler">  <b class="spoiler_title">Inhalt</b> <div class="spoiler_text"><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">So implementieren Sie eine Programmiersprache in JavaScript.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1: Parser</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">So implementieren Sie eine Programmiersprache in JavaScript.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2: Dolmetscher</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">So implementieren Sie eine Programmiersprache in JavaScript.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3: CPS-Dolmetscher</a> </li><li>  So implementieren Sie eine Programmiersprache in JavaScript.  Teil 4: Trans-Kompilierung in JS </li></ol></div></div><br><p> PS Es gibt einen Fehler im Interpreter und Compiler: in Ausdrücken wie <code>a() &amp;&amp; b()</code> oder <code>a() || b()</code>  <code>a() || b()</code> beide Teile werden immer ausgeführt.  Dies ist natürlich falsch, da <code>a()</code> für den Operator <code>&amp;&amp;</code> falsch oder für <code>||</code> nicht falsch ist  dann spielt der Wert von <code>b()</code> keine Rolle.  Dies ist nicht schwer zu beheben. </p><br><h1 id="cps-interpretator">  CPS-Dolmetscher </h1><br><p>  Unsere λ-Sprache hat zwei Nachteile: </p><br><ul><li>  Die Rekursion ist auf den JS-Stack beschränkt, daher haben wir keine normale Möglichkeit, Schleifen zu erstellen. </li><li>  Der Interpreter ist langsam, daher ist die Rekursion sehr langsam. </li></ul><br><p>  Jetzt werden wir den ersten Fehler korrigieren, ohne darauf zu achten, dass der Interpreter noch langsamer wird.  Wir werden den Interpreter im CPS-Stil (Continuation-Passing Style) umschreiben. </p><br><h2 id="chto-takoe-peredacha-prodolzheniya">  Was ist eine "Fortsetzungstransfer"? </h2><br><p>  Sie tun dies die ganze Zeit in NodeJS: </p><br><pre> <code class="javascript hljs">fs.readFile(<span class="hljs-string"><span class="hljs-string">"file.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"utf8"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CC</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">error, data</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   - "" //     'return', // 'readFile'  ,  . });</span></span></code> </pre> <br><p>  Bei jedem Schritt gibt es einen Rückruf, der aufgerufen wird, wenn Sie fortfahren müssen.  Der Fortsetzungsübertragungsstil macht die Steuerelementübertragung „explizit“ - Sie verwenden weder <code>return</code> , <code>throw</code> , <code>break</code> noch <code>continue</code> .  Es gibt keine impliziten Sprünge im Code.  Sie können nicht einmal for- oder <code>while</code> Schleifen mit asynchronen Funktionen verwenden.  Warum brauchen wir sie in diesem Fall in der Programmiersprache? </p><br><p>  Das Schreiben von Code im Stil der Übertragung einer Fortsetzung ist schwierig und leicht zu machen, aber wir schreiben den Interpreter nur in diesem Stil neu. </p><br><h2 id="funkciya-evaluate">  Funktion <code>evaluate</code> </h2><br><p>  Die <code>evaluate</code> erhält drei Argumente: Ausdruck (AST), Kontext (Umgebung) und die Funktion, die aufgerufen wird, wenn das Ergebnis vorliegt.  Hier ist der Code, für jedes Fragment gibt es eine Erklärung: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">exp, env, callback</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (exp.type) {</code> </pre> <br><p>  Für Konstanten geben wir nur ihren Wert zurück.  Denken Sie jedoch daran, dass wir keine <code>return</code> haben. Stattdessen rufen wir einfach den Rückruf auf und übergeben den Wert. </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"num"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"str"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"bool"</span></span>: callback(exp.value); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> <br><p>  Der <code>var</code> Knoten ist ebenfalls einfach: Holen Sie sich die Variable aus dem Kontext und übergeben Sie sie an die Funktion: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"var"</span></span>: callback(env.get(exp.value)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> <br><p>  Für das <code>assign</code> Knoten müssen wir den Wert des linken Ausdrucks ( <code>right</code> ) erhalten.  Dazu rufen wir <code>evaluate</code> und übergeben eine Funktion, die das Ergebnis erhält (für die rechte Seite des Ausdrucks).  Und dann rufen wir einfach den <code>callback</code> mit dem Variablenwert auf und setzen die Variable in den aktuellen Kontext: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"assign"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exp.left.type != <span class="hljs-string"><span class="hljs-string">"var"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Cannot assign to "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(exp.left)); evaluate(exp.right, env, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">right</span></span></span><span class="hljs-function">)</span></span>{ callback(env.set(exp.left.value, right)); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> <br><p>  Fast das gleiche für Knoten vom Typ <code>binary</code> , aber hier müssen wir zuerst den Wert des <code>left</code> Feldes und erst dann den Wert des <code>right</code> Feldes erhalten.  Dann rufen wir einfach den Rückruf auf und übergeben das Ergebnis der Operation: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"binary"</span></span>: evaluate(exp.left, env, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">left</span></span></span><span class="hljs-function">)</span></span>{ evaluate(exp.right, env, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">right</span></span></span><span class="hljs-function">)</span></span>{ callback(apply_op(exp.operator, left, right)); }); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> <br><p>  Der <code>let</code> Knoten sieht komplizierter aus, ist aber in der Tat einfach.  Wir haben einige Variablen.  Ihr <code>def</code> Feld (Anfangswert) kann leer sein. In diesem Fall setzen wir es auf <code>false</code> .  Wenn es jedoch einen Wert gibt, müssen wir <code>evaluate</code> rekursiv aufrufen, um ihn zu erhalten. </p><br><p>  Wenn Sie schon einmal mit NodeJS gearbeitet haben, haben Sie dies schon oft getan.  Aufgrund der Rückrufe, die wir nicht verwenden können, müssen wir diese Ausdrücke einzeln interpretieren (stellen Sie sich die <code>evaluate</code> als asynchron vor).  Die folgende <code>loop</code> (sofort aufgerufen) ruft den Kontext und die Nummer der Definition ab, die verarbeitet werden muss: </p><br><ul><li>  Wenn diese Anzahl gleich der Anzahl der Variablen ( <code>vars.length</code> ) ist, bedeutet dies, dass wir bereits alle Ausdrücke definiert haben, damit wir den Hauptteil des Ausdrucks ausführen können.  Bitte beachten Sie, dass wir diesmal keinen <code>callback</code> aufrufen, sondern ihn zur <code>evaluate</code> , der ihn dann aufruft. </li><li>  Wenn diese Zahl kleiner ist, müssen Sie die aktuelle Definition berechnen und eine Funktion übergeben, die die <code>loop(scope, i + 1)</code> aufruft, bevor Sie den Kontext kopieren. <br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"let"</span></span>: (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">env, i</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; exp.vars.length) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = exp.vars[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v.def) evaluate(v.def, env, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = env.extend(); scope.def(v.name, value); loop(scope, i + <span class="hljs-number"><span class="hljs-number">1</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = env.extend(); scope.def(v.name, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); loop(scope, i + <span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { evaluate(exp.body, env, callback); } })(env, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> </li></ul><br><p>  Der <code>lambda</code> Knoten wird wie zuvor in einer separaten Funktion verarbeitet: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"lambda"</span></span>: callback(make_lambda(env, exp)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> <br><p>  Um zu interpretieren, <code>if</code> , interpretieren wir zuerst die Bedingung.  Wenn es nicht falsch ist, interpretieren wir den Ausdruck <code>then</code> , in einem anderen Fall interpretieren wir <code>else</code> wenn es einen gibt, oder geben <code>false</code> wenn nicht.  Nach wie vor und <code>then</code> wir den <code>callback</code> einfach als "Aktion nach Ausführung" des Ausdrucks: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"if"</span></span>: evaluate(exp.cond, env, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cond</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cond !== <span class="hljs-literal"><span class="hljs-literal">false</span></span>) evaluate(exp.then, env, callback); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exp.else) evaluate(exp.else, env, callback); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> callback(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> <br><p>  Der <code>prog</code> Knoten wird ähnlich wie der <code>let</code> Knoten interpretiert, jedoch mit dem Unterschied, dass wir den Kontext nicht kopieren oder Variablen definieren müssen.  Und wieder haben wir eine <code>loop</code> , die eine Ausdrucksnummer akzeptiert.  Wenn es gleich <code>prog.length</code> , haben wir alle Ausdrücke vervollständigt und geben einfach das Ergebnis des letzten Ausdrucks zurück (mit dem Wort "return" meine ich, wir rufen damit <code>callback</code> auf).  Beachten Sie, dass wir uns den letzten Wert merken, indem wir ihn als Argument an die <code>loop</code> (am Anfang ist er <code>false</code> für den Fall, dass der Körper leer ist): </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"prog"</span></span>: (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">last, i</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; exp.prog.length) evaluate(exp.prog[i], env, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">)</span></span>{ loop(val, i + <span class="hljs-number"><span class="hljs-number">1</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { callback(last); } })(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> <br><p>  Für einen Knoten vom Typ <code>call</code> wir <code>func</code> interpretieren und dann sind alle Argumente in Ordnung.  Und wieder gibt es eine <code>loop</code> , die nach dem gleichen Prinzip wie <code>let</code> oder <code>prog</code> , mit dem Unterschied, dass sie jetzt ein Array erstellt: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"call"</span></span>: evaluate(exp.func, env, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">)</span></span>{ (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">args, i</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; exp.args.length) evaluate(exp.args[i], env, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arg</span></span></span><span class="hljs-function">)</span></span>{ args[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] = arg; loop(args, i + <span class="hljs-number"><span class="hljs-number">1</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { func.apply(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, args); } })([ callback ], <span class="hljs-number"><span class="hljs-number">0</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>;</code> </pre> <br><p>  Nun, das Standardende: Wenn wir nicht wissen, was wir tun sollen, werfen Sie eine Ausnahme: </p><br><pre> <code class="javascript hljs"> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"I don't know how to evaluate "</span></span> + exp.type); } }</code> </pre> <br><p>  Möglicherweise stellen Sie fest, dass jeder der oben genannten <code>case</code> mit dem Schlüsselwort <code>return</code> endet.  Es gibt jedoch keinen Rückgabewert - das Ergebnis wird immer an die <code>callback</code> . </p><br><h3 id="novaya-funkciya-make_lambda">  Neue Funktion <code>make_lambda</code> </h3><br><p>  In diesem Interpreter erhalten alle Funktionen als erstes Argument eine „Fortsetzung“ - die Funktion, die wir aufrufen müssen, um das Ergebnis zu übergeben.  Danach folgen die üblichen Funktionsargumente.  Hier ist der neue Code für die Funktion <code>make_lambda</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">env, exp</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exp.name) { env = env.extend(); env.def(exp.name, lambda); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> names = exp.vars; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = env.extend(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; names.length; ++i) scope.def(names[i], i + <span class="hljs-number"><span class="hljs-number">1</span></span> &lt; <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>.length ? <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] : <span class="hljs-literal"><span class="hljs-literal">false</span></span>); evaluate(exp.body, scope, callback); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> lambda; }</code> </pre> <br><p>  Er ist nicht viel anders.  Es fügt einem neuen Kontext neue Variablen hinzu.  Wir müssen auch berücksichtigen, dass das erste Argument <code>callback</code> .  Schließlich wird die <code>evaluate</code> verwendet, um den Funktionscode in einem neuen Kontext auszuführen, aber wie zuvor übergeben wir einen <code>callback</code> . </p><br><p>  Dies ist übrigens der einzige Ort, an dem ich die <code>for</code> Schleife verwendet habe.  Dies liegt daran, dass die Argumentwerte bereits berechnet wurden, als der Aufrufknoten verarbeitet wurde. </p><br><h2 id="nativnye-funkcii">  Native Funktionen </h2><br><p>  In diesem Interpreter erhalten native Funktionen als erstes Argument einen <code>callback</code> .  Wir müssen uns daran erinnern, wenn wir native Funktionen definieren.  Hier ist der Beispielcode für den neuen Interpreter: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> code = <span class="hljs-string"><span class="hljs-string">"sum = lambda(x, y) x + y; print(sum(2, 3));"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ast = parse(TokenStream(InputStream(code))); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> globalEnv = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Environment(); <span class="hljs-comment"><span class="hljs-comment">// define the "print" primitive function globalEnv.def("print", function(callback, txt){ console.log(txt); callback(false); // call the continuation with some return value // if we don't call it, the program would stop // abruptly after a print! }); // run the evaluator evaluate(ast, globalEnv, function(result){ // the result of the entire program is now in "result" });</span></span></code> </pre> <br><h2 id="malenkiy-test">  Kleiner Test </h2><br><p>  Versuchen wir noch einmal, die Fibonacci-Zahlen zu berechnen: </p><br><pre> <code class="javascript hljs">fib = λ(n) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> then n <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> fib(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) + fib(n - <span class="hljs-number"><span class="hljs-number">2</span></span>); time( λ() println(fib(<span class="hljs-number"><span class="hljs-number">10</span></span>)) );</code> </pre> <br><p>  Wenn wir jedoch versuchen, die 27. Zahl zu finden, erhalten wir einen Stapelüberlauf.  Im Allgemeinen wächst der Stapel jetzt viel schneller, so dass sich herausstellte, dass wir die Fibonacci-Zahl jetzt nur bis zum 12. zählen können (zumindest in meinem Browser).  Das ist nicht sehr gut, also musst du es irgendwie reparieren. </p><br><h1 id="zaschischaem-stek">  Wir schützen den Stapel </h1><br><p>  In einem CPS-Interpreter wächst der Stapel viel schneller, da der Interpreter Funktionen immer rekursiv aufruft und niemals ein Ergebnis zurückgibt.  Obwohl wir im Dolmetscher zurückgekehrt sind, brauchen wir sie, aber im Falle einer sehr tiefen Rekursion erreichen wir sie nie. </p><br><p>  Stellen wir uns vor, wie unser Stack nach einem sehr einfachen Programm aussieht.  Ich werde den Pseudocode zeigen und <code>env</code> nicht hinzugefügt, da er hier keine Rolle spielt: </p><br><pre> <code class="python hljs">print(<span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span> * <span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-comment"><span class="hljs-comment">## : evaluate( print(1 + 2 * 3), K0 ) evaluate( print, K1 ) K1(print) #  'var',      evaluate( 1 + 2 * 3, K2 ) evaluate( 2 * 3, K3 ) evaluate( 2, K4 ) K4(2) # 2  ,      evaluate( 3, K5 ) #    3,      K5(3) K3(6) #  2*3 evaluate( 1, K6 ) #  ,  K6(1) K2(7) #  1+2*3 print(K0, 7) # ,     'print' K0(false) #  . 'print'  'false'.</span></span></code> </pre> <br><p>  Erst nach dem letzten Aufruf reduziert eine lange Folge nutzloser <code>return</code> den Stapel.  Wenn wir so viel Stapelspeicher für ein einfaches Programm verwenden, ist es schwer vorstellbar, was für <code>fib(13)</code> passieren wird. </p><br><h2 id="zaschita-steka">  Stapelschutz </h2><br><p>  In unserem neuen Interpreter wird der Stapel einfach nicht benötigt.  Alles, was getan werden muss, nachdem ein Ausdruck in einem <code>callback</code> , der als Argument übergeben wird.  Hier haben wir also eine Frage: Was wäre, wenn JavaScript es ermöglichen würde, den Stapel zu "sichern"?  Dann können wir den Stapel fallen lassen und eine unendlich tiefe Rekursion wird funktionieren. </p><br><p>  Stellen wir uns vor, wir haben eine <code>GUARD</code> Funktion, die dies kann.  Es erhält zwei Werte: die aufzurufende Funktion und die Argumente, die übergeben werden müssen.  Es wird überprüft: Wenn der Stapel zu tief ist, wird der Stapel gelöscht und die übergebene Funktion aufgerufen.  In einem anderen Fall tut sie nichts. </p><br><p>  Mit der neuen Funktion schreiben wir den Interpreter wie unten gezeigt neu.  Ich werde nicht auf jeden Einzelfall <code>GUARD</code> , es gibt den Code, der zuvor beschrieben wurde, sondern mit der <code>GUARD</code> Funktion: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">evaluate</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">exp, env, callback</span></span></span><span class="hljs-function">) </span></span>{ GUARD(evaluate, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (exp.type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"num"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"str"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"bool"</span></span>: callback(exp.value); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"var"</span></span>: callback(env.get(exp.value)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"assign"</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exp.left.type != <span class="hljs-string"><span class="hljs-string">"var"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"Cannot assign to "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">JSON</span></span>.stringify(exp.left)); evaluate(exp.right, env, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CC</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">right</span></span></span><span class="hljs-function">)</span></span>{ GUARD(CC, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); callback(env.set(exp.left.value, right)); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"binary"</span></span>: evaluate(exp.left, env, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CC</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">left</span></span></span><span class="hljs-function">)</span></span>{ GUARD(CC, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); evaluate(exp.right, env, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CC</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">right</span></span></span><span class="hljs-function">)</span></span>{ GUARD(CC, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); callback(apply_op(exp.operator, left, right)); }); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"let"</span></span>: (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">env, i</span></span></span><span class="hljs-function">)</span></span>{ GUARD(loop, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; exp.vars.length) { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = exp.vars[i]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (v.def) evaluate(v.def, env, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CC</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">value</span></span></span><span class="hljs-function">)</span></span>{ GUARD(CC, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = env.extend(); scope.def(v.name, value); loop(scope, i + <span class="hljs-number"><span class="hljs-number">1</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> scope = env.extend(); scope.def(v.name, <span class="hljs-literal"><span class="hljs-literal">false</span></span>); loop(scope, i + <span class="hljs-number"><span class="hljs-number">1</span></span>); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { evaluate(exp.body, env, callback); } })(env, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"lambda"</span></span>: callback(make_lambda(env, exp)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"if"</span></span>: evaluate(exp.cond, env, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CC</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">cond</span></span></span><span class="hljs-function">)</span></span>{ GUARD(CC, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (cond !== <span class="hljs-literal"><span class="hljs-literal">false</span></span>) evaluate(exp.then, env, callback); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exp.else) evaluate(exp.else, env, callback); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> callback(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"prog"</span></span>: (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">last, i</span></span></span><span class="hljs-function">)</span></span>{ GUARD(loop, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; exp.prog.length) evaluate(exp.prog[i], env, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CC</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">)</span></span>{ GUARD(CC, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); loop(val, i + <span class="hljs-number"><span class="hljs-number">1</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { callback(last); } })(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">"call"</span></span>: evaluate(exp.func, env, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CC</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function">)</span></span>{ GUARD(CC, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">args, i</span></span></span><span class="hljs-function">)</span></span>{ GUARD(loop, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (i &lt; exp.args.length) evaluate(exp.args[i], env, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CC</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">arg</span></span></span><span class="hljs-function">)</span></span>{ GUARD(CC, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); args[i + <span class="hljs-number"><span class="hljs-number">1</span></span>] = arg; loop(args, i + <span class="hljs-number"><span class="hljs-number">1</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { func.apply(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, args); } })([ callback ], <span class="hljs-number"><span class="hljs-number">0</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Error</span></span>(<span class="hljs-string"><span class="hljs-string">"I don't know how to evaluate "</span></span> + exp.type); } }</code> </pre> <br><p>  Für anonyme Funktionen mussten wir einen Namen hinzufügen, damit wir sie an die <code>GUARD</code> Funktion übergeben konnten.  Ich habe den Namen <code>CC</code> ( <code>current continuation</code> ) verwendet.  Sie könnten <code>arguments.callee</code> , dies ist jedoch eine veraltete API. </p><br><p>  Auch die gleiche Änderung in <code>make_lambda</code> : </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make_lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">env, exp</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (exp.name) { env = env.extend(); env.def(exp.name, lambda); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">lambda</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">callback</span></span></span><span class="hljs-function">) </span></span>{ GUARD(lambda, <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>); <span class="hljs-comment"><span class="hljs-comment">// &lt;--  var names = exp.vars; var scope = env.extend(); for (var i = 0; i &lt; names.length; ++i) scope.def(names[i], i + 1 &lt; arguments.length ? arguments[i + 1] : false); evaluate(exp.body, scope, callback); } return lambda; }</span></span></code> </pre> <br><p>  Die Implementierung von <code>GUARD</code> sehr einfach.  Wie komme ich aus einem tiefen Anruf heraus?  Ausnahmen verwenden.  Zu diesem Zweck gibt es eine globale Variable, die angibt, wie viel mehr Rekursion wir ausführen können.  Wenn es Null erreicht, werfen wir das <code>Continuation</code> Objekt, in dem es eine Continuation-Funktion und Argumente gibt: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> STACKLEN; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GUARD</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f, args</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (--STACKLEN &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Continuation(f, args); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Continuation</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f, args</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.f = f; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.args = args; }</code> </pre> <br><p>  Und am Ende brauchen wir eine Schleife, die <code>Continuation</code> Objekte <code>Continuation</code> .  Wir müssen den Interpreter über diese Schleife aufrufen, damit alles funktioniert: </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f, args</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { STACKLEN = <span class="hljs-number"><span class="hljs-number">200</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> f.apply(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, args); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(ex) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ex <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Continuation) f = ex.f, args = ex.args; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> ex; } }</code> </pre> <br><p>  Die <code>Execute</code> Funktion akzeptiert die <code>Execute</code> Funktion und die Argumente dafür.  Es funktioniert in einer Schleife, aber achten Sie darauf, dass Sie <code>return</code> wenn die Funktion ohne Stapelüberlauf funktioniert. Wir hören sofort auf.  <code>STACKLEN</code> jedes Mal zurückgesetzt, wenn wir eine Schleifeniteration starten.  Ein Wert von <code>200</code> - passt gut.  Wenn wir das <code>Continuation</code> Objekt abfangen, ersetzen wir eine neue Funktion und neue Argumente und setzen die Schleife fort.  Aufgrund einer Ausnahme wird der Stapel auch gelöscht, damit wir fortfahren können. </p><br><p>  Um den Interpreter zu starten, verwenden wir jetzt <code>Execute</code> : </p><br><pre> <code class="javascript hljs">Execute(evaluate, [ ast, globalEnv, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"*** Result:"</span></span>, result); }]);</code> </pre> <br><h2 id="test">  Test </h2><br><p>  Die <code>fib</code> Funktion funktioniert jetzt: </p><br><pre> <code class="python hljs">fib = λ(n) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &lt; <span class="hljs-number"><span class="hljs-number">2</span></span> then n <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> fib(n - <span class="hljs-number"><span class="hljs-number">1</span></span>) + fib(n - <span class="hljs-number"><span class="hljs-number">2</span></span>); time( λ() println(fib(<span class="hljs-number"><span class="hljs-number">20</span></span>)) ); <span class="hljs-comment"><span class="hljs-comment"># 6765, ~300ms</span></span></code> </pre> <br><p>  Schade, aber wenn Sie versuchen, <code>fib(27)</code> zu finden, <code>fib(27)</code> es ungefähr viermal so lange wie bei einem normalen Dolmetscher.  Aber dann haben wir jetzt eine unendliche Rekursion: </p><br><pre> <code class="javascript hljs">sum = λ(n, ret) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n == <span class="hljs-number"><span class="hljs-number">0</span></span> then ret <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> sum(n - <span class="hljs-number"><span class="hljs-number">1</span></span>, ret + n); # compute <span class="hljs-number"><span class="hljs-number">1</span></span> + <span class="hljs-number"><span class="hljs-number">2</span></span> + ... + <span class="hljs-number"><span class="hljs-number">50000</span></span> time( λ() println(sum(<span class="hljs-number"><span class="hljs-number">50000</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>)) ); # <span class="hljs-number"><span class="hljs-number">1250025000</span></span>, ~<span class="hljs-number"><span class="hljs-number">700</span></span>ms</code> </pre> <br><p>  Natürlich ist die λ-Sprache viel langsamer als JavaScript.  Stellen Sie sich vor, jeder Zugriff auf eine Variable erfolgt über ein <code>Environment</code> .  Es macht keinen Sinn zu versuchen, den Interpreter zu optimieren - wir werden keinen signifikanten Leistungsgewinn erzielen.  Um die Leistung zu verbessern, gibt es eine Lösung: Kompilieren Sie die λ-Sprache in JS, und dies werden wir tun.  Lassen Sie uns zunächst sehen, welche interessanten Dinge wir mit einem CPS-Interpreter tun können. </p><br><h1 id="prodolzheniya">  Fortsetzung </h1><br><p>  Nachdem der Interpreter im Stil der Übertragung von Fortsetzungen arbeitet und alle Funktionen, sowohl λ-Sprachfunktionen als auch native JS-Funktionen, die Fortsetzungsfunktion als erstes Argument erhalten, das das Ergebnis zurückgibt (dieses Argument ist für JavaScript-Funktionen erforderlich, obwohl es für λ-Sprachfunktionen unsichtbar ist). </p><br><p>  Der variable <code>callback</code> bedeutet die Fortsetzung des gesamten Programms.  <em>Alles, was das Programm als nächstes tun wird.</em>  Wir werden diese Variable 'aktuelle Fortsetzung' oder <code>k</code> im Code nennen. </p><br><p>  Wenn wir keine Fortsetzung verursachen, wird das Programm gestoppt.  Wir können dies nicht aus der λ-Sprache heraus tun, da <code>make_lambda</code> sowieso die Fortsetzung aufruft.  Aber wir können dies von einer nativen Funktion aus tun.  Ich habe eine Funktion erstellt, um zu zeigen, wie dies funktioniert: </p><br><pre> <code class="javascript hljs">globalEnv.def(<span class="hljs-string"><span class="hljs-string">"halt"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k</span></span></span><span class="hljs-function">)</span></span>{});</code> </pre> <br><p>  Dies ist eine Funktion, die nichts tut.  Sie erhält die Fortsetzung ( <code>k</code> ), nennt sie aber nicht: </p><br><pre> <code class="python hljs">println(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>); halt(); println(<span class="hljs-string"><span class="hljs-string">"bar"</span></span>);</code> </pre> <br><p>  Fazit: </p><br><pre> <code class="plaintext hljs">foo</code> </pre> <br><p>  Wenn Sie den Aufruf von <code>halt()</code> löschen, <code>println</code> die Ausgabe: <code>foo / bar / ***Result: false</code> (da der letzte <code>println</code> <code>false</code> zurückgibt).  Bei <code>halt()</code> nur <code>foo</code> .  * Jetzt gibt es nicht einmal ein Ergebnis, da <code>halt()</code> keine Fortsetzung verursacht und daher der Rückruf, den wir zur <code>evaluate</code> - derjenige, der die Zeichenfolge <code>***Result</code> anzeigt - niemals aufgerufen wird.  Die Funktion, die evalu <code>evaluate</code> bemerkt nicht, dass das Programm gestoppt wurde.  In NodeJS wäre das ein Schuss in den Fuß. </p><br><hr><br><p>  Stellen Sie sich vor, wir brauchen eine <code>sleepe</code> Funktion, die ein Programm stoppt, ohne den Browser zu stoppen (daher ohne dumme Schleifen).  Wir können dies einfach mit einer nativen Funktion implementieren: </p><br><pre> <code class="javascript hljs">globalEnv.def(<span class="hljs-string"><span class="hljs-string">"sleep"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k, milliseconds</span></span></span><span class="hljs-function">)</span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ Execute(k, [ <span class="hljs-literal"><span class="hljs-literal">false</span></span> ]); <span class="hljs-comment"><span class="hljs-comment">//   ,  'false' }, milliseconds); });</span></span></code> </pre> <br><p>  Eine leichte Unannehmlichkeit ist, dass wir <code>Execute</code> , da <code>setTimeout</code> einen Rückruf verursacht, der dann <code>Continuation</code> <code>setTimeout</code> und niemand ihn <code>setTimeout</code> .  So verwenden Sie es: </p><br><pre> <code class="python hljs">let loop (n = <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> n &lt; <span class="hljs-number"><span class="hljs-number">10</span></span> { println(n); sleep(<span class="hljs-number"><span class="hljs-number">250</span></span>); loop(n + <span class="hljs-number"><span class="hljs-number">1</span></span>); } }; println(<span class="hljs-string"><span class="hljs-string">"And we're done"</span></span>);</code> </pre> <br><p>  Fazit: </p><br><pre> <code class="plaintext hljs">0 1 2 3 4 5 6 7 8 9 And we're done ***Result: false</code> </pre> <br><p>  Beachten Sie, dass zwischen den einzelnen Zeilen eine geringfügige Verzögerung besteht.  Sie können versuchen, diesen Code im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Originalartikel</a> auszuführen. </p><br><p>  Dies ist bereits etwas, was Sie in normalem JavaScript nicht tun können, außer für die manuelle Übertragung der Fortsetzung (und Sie können auch keine <code>for</code> Schleife <code>for</code> ): </p><br><pre> <code class="javascript hljs">(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loop</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">n</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &lt; <span class="hljs-number"><span class="hljs-number">10</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(n); setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ loop(n + <span class="hljs-number"><span class="hljs-number">1</span></span>); }, <span class="hljs-number"><span class="hljs-number">250</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { println(<span class="hljs-string"><span class="hljs-string">"And we're done"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    } })(0);</span></span></code> </pre> <br><hr><br><p>  Stellen Sie sich vor, wie Sie die NodeJS-API in einer λ-Sprache verwenden können: </p><br><pre> <code class="javascript hljs">globalEnv.def(<span class="hljs-string"><span class="hljs-string">"readFile"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k, filename</span></span></span><span class="hljs-function">)</span></span>{ fs.readFile(filename, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err, data</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">// error handling is a bit more complex, ignoring for now Execute(k, [ data ]); // hope it's clear why we need the Execute }); }); globalEnv.def("writeFile", function(k, filename, data){ fs.writeFile(filename, data, function(err){ Execute(k, [ false ]); }); });</span></span></code> </pre> <br><p>  Verwendung: </p><br><pre> <code class="python hljs">copyFile = λ(source, dest) { writeFile(dest, readFile(source)); }; copyFile(<span class="hljs-string"><span class="hljs-string">"foo.txt"</span></span>, <span class="hljs-string"><span class="hljs-string">"bar.txt"</span></span>);</code> </pre> <br><p>  Und das alles funktioniert asynchron.  Keine Rückrufhölle mehr. </p><br><hr><br><p>  Hier ist ein interessanteres Beispiel.  Ich habe die folgende native Funktion geschrieben: </p><br><pre> <code class="javascript hljs">globalEnv.def(<span class="hljs-string"><span class="hljs-string">"twice"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k, a, b</span></span></span><span class="hljs-function">)</span></span>{ k(a); k(b); });</code> </pre> <br><p>  Das Programm verwendet zwei Argumente <code>a</code> und <code>b</code> und ruft die Fortsetzung zweimal auf, einmal für jedes Argument.  Nennen wir es: </p><br><pre> <code class="python hljs">println(<span class="hljs-number"><span class="hljs-number">2</span></span> + twice(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>)); println(<span class="hljs-string"><span class="hljs-string">"Done"</span></span>);</code> </pre> <br><p>  Fazit: </p><br><pre> <code class="plaintext hljs">5 Done ***Result: false 6 Done ***Result: false</code> </pre> <br><p>  Die Schlussfolgerung ist seltsam, wenn Sie noch nie mit der Weitergabe von Fortsetzungen gearbeitet haben, aber versuchen, diesen Code selbst zu verstehen.  Ein kleiner Hinweis: Das Programm startet einmal, gibt aber das Ergebnis zweimal zurück. </p><br><h2 id="obobschenie-callcc">  Verallgemeinerung: <code>CallCC</code> </h2><br><p>  Wir haben mit dem Feuer gespielt, als wir native Funktionen geschrieben haben.  In der Sprache λ gibt es keine Möglichkeit, die Ausführung der aktuellen Fortsetzung zu unterbrechen.  <code>CallCC</code> hilft bei der Lösung dieses Problems.  Der Name ist die Abkürzung für die Funktion aus Schema - <code>call-with-current-continuation</code> (im Schema normalerweise call / cc genannt). </p><br><pre> <code class="javascript hljs">globalEnv.def(<span class="hljs-string"><span class="hljs-string">"CallCC"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k, f</span></span></span><span class="hljs-function">)</span></span>{ f(k, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CC</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">discarded, ret</span></span></span><span class="hljs-function">)</span></span>{ k(ret); }); });</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die</a> aktuelle Fortsetzung wird in eine Funktion umgewandelt, die direkt aus der λ-Sprache aufgerufen werden kann.  Diese Funktion ignoriert die ursprünglich <code>discarded</code> Fortsetzung und ruft stattdessen die Fortsetzung auf, die an die <code>CallCC</code> Funktion übergeben wurde. </p><br><p>  Mit dieser Funktion können wir (bereits direkt in der λ-Sprache, nicht über native Funktionen!) Eine große Anzahl von Operatoren zur Steuerung des Ausführungsflusses implementieren, an die wir vorher noch nicht einmal gedacht haben - beginnend mit Ausnahmen und endend mit <code>return</code> .  Beginnen wir mit dem letzten. </p><br><h3 id="realizaciya-return">  Implementierungsrückgabe </h3><br><pre> <code class="python hljs">foo = λ(<span class="hljs-keyword"><span class="hljs-keyword">return</span></span>){ println(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(<span class="hljs-string"><span class="hljs-string">"DONE"</span></span>); println(<span class="hljs-string"><span class="hljs-string">"bar"</span></span>); }; CallCC(foo);</code> </pre> <br><p>  Fazit: </p><br><pre> <code class="plaintext hljs">foo ***Result: DONE</code> </pre> <br><p>  Die <code>foo</code> Funktion erhält ein Argument, das dasselbe wie die <code>return</code> von JavaScript tut (wird jedoch als reguläre Funktion aufgerufen).  Es überspringt die aktuelle Fortsetzung (die 'bar' ausgeben würde) und beendet die Funktion, wobei der angegebene Wert zurückgegeben wird ("DONE").  Dies funktioniert natürlich nur, wenn Sie eine Funktion <code>CallCC</code> , die <code>CallCC</code> , um die Fortsetzung als <code>return</code> .  Wir können einen Wrapper dafür erstellen: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> = λ(f) λ() CallCC(f); foo = <span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(λ(<span class="hljs-keyword"><span class="hljs-keyword">return</span></span>){ println(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(<span class="hljs-string"><span class="hljs-string">"DONE"</span></span>); println(<span class="hljs-string"><span class="hljs-string">"bar"</span></span>); }); foo();</code> </pre> <br><p>  Fazit: </p><br><pre> <code class="plaintext hljs">foo ***Result: DONE</code> </pre> <br><p>  Der Vorteil dieser Methode ist, dass wir <code>CallCC</code> nicht mehr verwenden müssen, wenn wir <code>foo</code> aufrufen.  Es wäre natürlich schön, wenn wir <code>return</code> als Argument akzeptieren oder die <code>with-return</code> Funktion verwenden müssten, aber in der Sprache gibt es keine Möglichkeit, syntaktischen Zucker direkt daraus hinzuzufügen, dafür müssen wir zumindest den Parser ändern (+1 für Lisp). </p><br><h3 id="perehody">  Übergänge </h3><br><p>  Zum Beispiel müssen wir ein Programm schreiben, das nach allen Paaren positiver Ganzzahlen bis zu 100 sucht, so dass, wenn ihre Multiplikation 84 ergibt. Dies ist keine schwierige Aufgabe, und Sie können sich sofort zwei verschachtelte Schleifen vorstellen, um sie zu lösen, aber hier gehen wir einen anderen Weg.  Wir werden zwei Funktionen erstellen: <code>guess</code> und <code>fail</code> .  Die erste wählt die Nummer aus und die zweite sagt ihr, "versuche es mit einer anderen Nummer".  Wir werden sie so verwenden: </p><br><pre> <code class="python hljs">a = guess(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-comment"><span class="hljs-comment">#  -  &gt;= 1 b = guess(a); #  -  &gt;= a if a * b == 84 { #    : print(a); print(" x "); println(b); }; fail(); #    `guess`    </span></span></code> </pre> <br><p>  : </p><br><pre> <code class="python hljs">fail = λ() false; guess = λ(current) { CallCC(λ(k){ let (prevFail = fail) { fail = λ(){ current = current + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> current &gt; <span class="hljs-number"><span class="hljs-number">100</span></span> { fail = prevFail; fail(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { k(current); }; }; k(current); }; }); }; a = guess(<span class="hljs-number"><span class="hljs-number">1</span></span>); b = guess(a); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> a * b == <span class="hljs-number"><span class="hljs-number">84</span></span> { print(a); print(<span class="hljs-string"><span class="hljs-string">" x "</span></span>); println(b); }; fail();</code> </pre> <br><p>     ,  ,      <code>a</code> ,    <code>84</code> ,   <code>b</code> ,  <code>84 / a</code> .           <code>guess</code> : <code>start</code>  <code>end</code> —      .   ,  . </p><br><h3 id="try-i-catch-iz-common-lisp"> <code>try</code>  <code>catch</code>  Common Lisp </h3><br><p>     — <code>catch</code>  <code>throw</code> .     : </p><br><pre> <code class="python hljs">f1 = λ() { throw(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>, <span class="hljs-string"><span class="hljs-string">"EXIT"</span></span>); print(<span class="hljs-string"><span class="hljs-string">"not reached"</span></span>); }; println(catch(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>, λ() { f1(); print(<span class="hljs-string"><span class="hljs-string">"not reached"</span></span>); })); <span class="hljs-comment"><span class="hljs-comment">#  EXIT</span></span></code> </pre> <br><ul><li>  <code>catch(TAG, function)</code>  ,    ,  <code>TAG</code> ',   <code>function</code> . </li><li>  <code>throw(TAG, value)</code>  ,     ,  <code>TAG</code> '  ,     <code>value</code> . </li></ul><br><p>  : </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment">##  , 'throw'   . ##       `error`, ##     JavaScript.    . throw = λ(){ println("ERROR: No more catch handlers!"); halt(); }; catch = λ(tag, func){ CallCC(λ(k){ let (rethrow = throw, ret) { ##   ,     . throw = λ(t, val) { throw = rethrow; #   ,   . if t == tag then k(val) else throw(t, val); }; ##      . ret = func(); ##       (  'throw') ##    .   . throw = rethrow; # XXX ##  . ret; }; }); };</span></span></code> </pre> <br><p>  Ein Beispiel: </p><br><pre> <code class="python hljs"><span class="hljs-comment"><span class="hljs-comment"># ... f1 = λ() { throw("foo", "EXIT"); print("not reached"); }; println(catch("foo", λ() { f1(); print("not reached"); }));</span></span></code> </pre> <br><h2 id="temnaya-storona-sily">    </h2><br><p>    <code>catch</code> ,     ,    ,    .   ,    , ,  <code>CallCC</code>     .    ,     .    "   " —      —  .    ,  ,     ,  <code>catch</code> / <code>throw</code>    ,  . </p><br><p>    .   ,    <code>catch</code> . ,   <code>throw</code>   , ,  <code>catch</code>   ,     .  Zum Beispiel: </p><br><pre> <code class="python hljs">exit = false; <span class="hljs-comment"><span class="hljs-comment">#  . x = 0; # :   ,   'exit()'  CallCC( λ(k) exit = k ); ## 'exit()'   ... if x == 0 then catch("foo", λ(){ println("in catch"); x = 1; #  exit(); }); println("After catch"); throw("foo", "FOO");</span></span></code> </pre> <br><p>  Fazit: </p><br><pre> <code class="plaintext hljs">After catch After catch ERROR: No more catch handlers!</code> </pre> <br><p>    'After catch' ,   'ERROR: No more catch handlers!'. -  ,   'After catch'   ,   . ,  ''  ,  <code>catch</code> . ,    'XXX'   <code>catch</code>   ,         <code>throw</code> ,   <code>catch</code>   . </p><br><p> (       ,     .) </p><br><p>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  CallCC</a> (, <em>   ,   CallCC</em> ).  ,    —  <code>CallCC</code>           . </p><br><h1 id="yield"> Yield </h1><br><p> ,    ,   <code>yield</code> : </p><br><pre> <code class="python hljs">foo = <span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(λ(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-string"><span class="hljs-string">"DONE"</span></span>; }); println(foo()); <span class="hljs-comment"><span class="hljs-comment"># 1 println(foo()); # 2 println(foo()); # 3 println(foo()); # DONE</span></span></code> </pre> <br><p>    <code>yield</code> ,       .  ,  <code>return</code> .      ,       ,    <code>yield</code> ,       . </p><br><p>  : </p><br><pre> <code class="python hljs">fib = <span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(λ(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>){ let loop (a = <span class="hljs-number"><span class="hljs-number">1</span></span>, b = <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(b); loop(b, a + b); }; }); <span class="hljs-comment"><span class="hljs-comment">##   50   let loop (i = 0) { if i &lt; 50 { println(fib()); loop(i + 1); }; };</span></span></code> </pre> <br><p>  <code>fib</code>   .    .  <code>yield</code>      .     ,    ,         50  ,      50 . </p><br><p> ,      ,     , ,            . </p><br><h2 id="neudachnaya-popytka-realizacii">    </h2><br><p>          ,         . </p><br><p>   <code>yield</code> ,  ,       .   ,        ,      <code>return</code> . ,  ,    <code>yield</code> ,       <code>yield</code> ,         <em></em> .   ,   .      : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> = λ(func) { <span class="hljs-comment"><span class="hljs-comment">## with-yield     λ() { CallCC(λ(kret){ # kret     let (yield) { ##  yield yield = λ(value) { # yield  ,    CallCC(λ(kyld){ # kyld    yield... func = kyld; # ...     kret(value); #  . }); }; ## , ,  ,   yield. func(yield); }; }); }; };</span></span></code> </pre> <br><p>       <code>yield</code>  ,     . ,         ,     ,      "DONE". </p><br><p> ,     .   ,     - ,     ,    4   : </p><br><pre> <code class="python hljs">println(foo()); foo();</code> </pre> <br><p>    . </p><br><h3 id="problema-1-yield-nikogda-ne-izmenyaetsya">  №1: yield    </h3><br><p>  ,   ,  ,   ,     <code>yield</code> ( <code>kyld</code> ,    ,   )    : </p><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-string"><span class="hljs-string">"DONE"</span></span>;</code> </pre> <br><p>    <code>yield</code>   ?     <code>yield</code> ,       ,    <code>yield</code>    . ,    .  ,     <code>yield</code>        <code>return</code> ,      : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> = λ(func) { let (<span class="hljs-keyword"><span class="hljs-keyword">return</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> = λ(value) { CallCC(λ(kyld){ func = kyld; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(value); <span class="hljs-comment"><span class="hljs-comment"># 'return'  ,     }); #        . }; # λ(val) { # CallCC(λ(kret){ # return = kret; # &lt;-  func(val || yield); }); }; }; };</span></span></code> </pre> <br><p> ,  ,       <code>yield</code>  ,   <code>yield</code>       (  ).      <code>yield</code> . </p><br><p>   ,    ,    <code>println(foo())</code>   : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> = λ(func) { let (<span class="hljs-keyword"><span class="hljs-keyword">return</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> = λ(value) { CallCC(λ(kyld){ func = kyld; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(value); }); }; λ(val) { CallCC(λ(kret){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> = kret; func(val || <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>); }); }; }; }; foo = <span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(λ(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-string"><span class="hljs-string">"DONE"</span></span>; }); println(foo()); println(foo()); println(foo());</code> </pre> <br><p> ,    .        ,      <code>print(foo()); foo()</code> .   ,     <code>println(foo())</code> ?   ... </p><br><h3 id="problema-2-wtf">  №2: WTF? </h3><br><p>     .     :    ,          <code>foo()</code> .  ,     ? —    . </p><br><pre> <code class="python hljs">println(foo()); <span class="hljs-comment"><span class="hljs-comment">## yield 1 &lt;-----------------  ---------------------------+ println(foo()); ## yield 2 | println(foo()); ## yield 3 | println(foo()); ##   "DONE",   foo()  --&gt;--+</span></span></code> </pre> <br><p>       <code>with-yield</code> : </p><br><pre> <code class="python hljs"> func(val || <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>); <span class="hljs-comment"><span class="hljs-comment">#...</span></span></code> </pre> <br><p>     <code>yield</code> ,   ,       <code>#...</code> .   ,   ,     ( <code>"DONE"</code> ),     ,   <code>"DONE"</code>   ,     . <code>foo()</code>     ,    <code>"DONE"</code>   .      : </p><br><pre> <code class="python hljs">println(foo()); println(<span class="hljs-string"><span class="hljs-string">"bar"</span></span>); println(foo()); println(foo()); foo();</code> </pre> <br><p>   : <code>1, bar, 2, 3, DONE, bar, DONE, bar, ...</code> . </p><br><p>      <code>func</code>  - ,    .   ,    <code>"no more continuations"</code> : </p><br><pre> <code class="python hljs"> val = func(val || <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>); func = λ() <span class="hljs-string"><span class="hljs-string">"NO MORE CONTINUATIONS"</span></span>; kret(val);</code> </pre> <br><p>     : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> = λ(func) { let (<span class="hljs-keyword"><span class="hljs-keyword">return</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> = λ(value) { CallCC(λ(kyld){ func = kyld; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(value); }); }; λ(val) { CallCC(λ(kret){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> = kret; val = func(val || <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>); func = λ() <span class="hljs-string"><span class="hljs-string">"NO MORE CONTINUATIONS"</span></span>; kret(val); }); }; }; }; foo = <span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(λ(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-string"><span class="hljs-string">"DONE"</span></span>; }); println(foo()); println(foo()); println(foo()); println(foo());</code> </pre> <br><p>      ,     : </p><br><pre> <code class="plaintext hljs">1 2 3 DONE NO MORE CONTINUATIONS NO MORE CONTINUATIONS NO MORE CONTINUATIONS ***Result: false</code> </pre> <br><p>    <code>1, 2, 3, DONE</code> ,      <code>"NO MORE CONTINUATIONS"</code>  .  ,       : </p><br><pre> <code class="python hljs">print(<span class="hljs-string"><span class="hljs-string">"A. "</span></span>); println(foo()); print(<span class="hljs-string"><span class="hljs-string">"B. "</span></span>); println(foo()); print(<span class="hljs-string"><span class="hljs-string">"C. "</span></span>); println(foo()); print(<span class="hljs-string"><span class="hljs-string">"D. "</span></span>); println(foo()); <span class="hljs-comment"><span class="hljs-comment">##   : A. 1 B. 2 C. 3 D. DONE B. NO MORE CONTINUATIONS C. NO MORE CONTINUATIONS D. NO MORE CONTINUATIONS ***Result: false</span></span></code> </pre> <br><p>  ,     :       , , ,      ,  <code>"B."</code>   . </p><br><p>       ,         <code>yield</code> ,     : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> = λ(func) { let (<span class="hljs-keyword"><span class="hljs-keyword">return</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> = λ(value) { CallCC(λ(kyld){ func = kyld; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>(value); }); }; λ(val) { CallCC(λ(kret){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> = kret; val = func(val || <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>); func = λ() <span class="hljs-string"><span class="hljs-string">"NO MORE CONTINUATIONS"</span></span>; kret(val); }); }; }; }; fib = <span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(λ(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>){ let loop (a = <span class="hljs-number"><span class="hljs-number">1</span></span>, b = <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(b); loop(b, a + b); }; }); <span class="hljs-comment"><span class="hljs-comment">##   50   let loop (i = 0) { if i &lt; 50 { println(fib()); loop(i + 1); }; };</span></span></code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Fazit</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040 1346269 2178309 3524578 5702887 9227465 14930352 24157817 39088169 63245986 102334155 165580141 267914296 433494437 701408733 1134903170 1836311903 2971215073 4807526976 7778742049 12586269025 20365011074 ***Result: false</code> </pre> </div></div><br><p> ,      (,       ),       " ". </p><br><h2 id="otdelennye-prodolzheniya-reset-i-shift">  : <code>reset</code>  <code>shift</code> </h2><br><p>    <code>yield</code>    : <code>reset</code>  <code>shift</code> .   " " — ,     .  <code>reset</code>  ,   <code>shift</code>     ,   <code>CallCC</code> . </p><br><p>  , <code>reset</code>  <code>shift</code>    — .     <code>reset</code> ,  <code>shift</code>      ,    <code>reset</code> . </p><br><p>  ,    <code>with-yield</code> : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> = λ(func) { let (<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>) { <span class="hljs-comment"><span class="hljs-comment">## 'yield'  'shift'     ##  'reset'.  ,   ,    ##   'func' — ,   `func()` ##    ,    . yield = λ(val) { shift(λ(k){ func = k; #    val; #    }); }; ##  `with-yield`      ##   'reset',    ,  ##   'yield' ( )    ##    λ(val) { reset( λ() func(val || yield) ); }; } };</span></span></code> </pre> <br><p>  ,      <code>reset</code> .  ,  ,       ,     <code>reset</code> .  ,    .     ,           . </p><br><p>     : </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> = λ(func) { let (<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> = λ(val) { shift(λ(k){ func = k; val; }); }; λ(val) { reset( λ() func(val || <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>) ); }; } }; foo = <span class="hljs-keyword"><span class="hljs-keyword">with</span></span>-<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(λ(<span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>){ <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(<span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span>(<span class="hljs-number"><span class="hljs-number">3</span></span>); <span class="hljs-string"><span class="hljs-string">"DONE"</span></span>; }); println(foo()); <span class="hljs-comment"><span class="hljs-comment">#  1 println(foo()); #  2 println(foo()); #  3 println(foo()); #  DONE</span></span></code> </pre> <br><h2 id="realizaciya-reset-i-shift">  <code>reset</code>  <code>shift</code> </h2><br><p>       ,      .    .     .     ,     ,        ,   .    <a href="">  Scheme</a> ( — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Oleg Kiselyov</a> ).   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a>     . </p><br><h3 id="ispolzuya-nativnye-funkcii">    </h3><br><p>      ,      (    <code>CallCC</code> )         .   : </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> pstack = []; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">_goto</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">f</span></span></span><span class="hljs-function">) </span></span>{ f(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">KGOTO</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">r</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> h = pstack.pop(); h(r); }); } globalEnv.def(<span class="hljs-string"><span class="hljs-string">"reset"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">KRESET, th</span></span></span><span class="hljs-function">)</span></span>{ pstack.push(KRESET); _goto(th); }); globalEnv.def(<span class="hljs-string"><span class="hljs-string">"shift"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">KSHIFT, f</span></span></span><span class="hljs-function">)</span></span>{ _goto(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">KGOTO</span></span></span><span class="hljs-function">)</span></span>{ f(KGOTO, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SK</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">k1, v</span></span></span><span class="hljs-function">)</span></span>{ pstack.push(k1); KSHIFT(v); }); }); });</code> </pre> <br><p>   ,   <code>reset</code> ,   <code>shift</code>  <code>_goto</code> ,  —  .     .  <code>_goto</code>         ( <code>KGOTO</code> ).  ,       <code>f</code> (  <code>CallCC</code> )    -      <code>KGOTO</code> ,     .  ,  <code>f</code> ,   ,    <code>KGOTO</code> ,      ,     . </p><br><p>  <code>reset</code>      ( <code>KRESET</code> )     <code>_goto(th)</code> .      ,    , ,      <code>_goto</code> . ,     , <code>KGOTO</code>   <code>KRESET</code> . </p><br><p>   , <code>shift</code>     <code>KGOTO</code>     ,  <code>KGOTO</code>    <code>pstack</code> ,      <code>SK</code> ,     ,   <code>shift</code>   (   <code>shift</code> — <code>KSHIFT</code> ).  <code>SK</code> —   —              ( <code>k1</code> )   .   ,     <code>shift2</code> ,    ,    <code>pstack.push(k1);</code>  :: </p><br><pre> <code class="python hljs">println(reset(λ(){ <span class="hljs-number"><span class="hljs-number">1</span></span> + shift( λ(k) k(k(<span class="hljs-number"><span class="hljs-number">2</span></span>)) ); })); println(reset(λ(){ <span class="hljs-number"><span class="hljs-number">1</span></span> + shift2( λ(k) k(k(<span class="hljs-number"><span class="hljs-number">2</span></span>)) ); }));</code> </pre> <br><p>  Fazit: </p><br><pre> <code class="plaintext hljs">4 3 ***Result: false</code> </pre> <br><p>  <code>shift</code>    ( <code>k</code> ),       <code>reset</code> .     —  1   <code>shift</code> : </p><br><pre> <code class="python hljs"><span class="hljs-number"><span class="hljs-number">1</span></span> + [?]</code> </pre> <br><p>    <code>k</code> ,   <code>?</code> .     — <code>k(k(2))</code> .   2   ,   <code>k(2)</code>  3. ,  <code>k(3)</code>  3     ,     4. </p><br><p> <code>shift2</code>  :  k(2)    . </p><br><h3 id="ispolzuya-callcc">  <code>CallCC</code> </h3><br><p>   ,       ,     <code>CallCC</code> ,    .     ,     JS, ,      ,       .    ,    <code>CallCC</code> ,    . </p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der interessanteste Teil dieses Codes ist, wie wir ihn implementiert </font></font><code>goto</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">haben und warum wir ihn so gemacht haben (aber versuchen Sie es selbst herauszufinden):</font></font></p><br><pre> <code class="plaintext hljs">pstack = NIL; goto = false; reset = λ(th) { CallCC(λ(k){ pstack = cons(k, pstack); goto(th); }); }; shift = λ(f) { CallCC(λ(k){ goto(λ(){ f(λ(v){ CallCC(λ(k1){ pstack = cons(k1, pstack); k(v); }); }); }); }); }; let (v = CallCC( λ(k){ goto = k; k(false) } )) { if v then let (r = v(), h = car(pstack)) { pstack = cdr(pstack); h(r); } };</code> </pre> <br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Im nächsten Teil des Artikels werden wir mit der Arbeit am Compiler beginnen - jetzt funktioniert unser Code auch schnell! </font></font></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de444024/">https://habr.com/ru/post/de444024/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de444014/index.html">Microsoft eröffnet die Business School, um KI-Strategien, Kultur und Verantwortung zu lernen</a></li>
<li><a href="../de444016/index.html">Erreichen Sie mehr mit Microsoft Game Stack</a></li>
<li><a href="../de444018/index.html">Wie eine Änderung der PostgreSQL-Konfiguration die Leistung langsamer Abfragen 50-mal verbessert</a></li>
<li><a href="../de444020/index.html">Karting in der UdSSR: Wie das Hobby amerikanischer Piloten zu einem massiven DIY-Hobby in der Sowjetunion wurde</a></li>
<li><a href="../de444022/index.html">Beego geht nicht mehr</a></li>
<li><a href="../de444026/index.html">MODX Digest # 1.1 (25. Februar - 11. März 2019)</a></li>
<li><a href="../de444028/index.html">Einführung in Microsoft Game Stack</a></li>
<li><a href="../de444030/index.html">Der chinesische Online-Händler Gearbest hat eine Datenbank mit Millionen persönlicher Kundendaten geöffnet</a></li>
<li><a href="../de444032/index.html">Warum ein 3D-Drucker kein Drucker ist</a></li>
<li><a href="../de444034/index.html">7 Todsünden eines Managers</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>