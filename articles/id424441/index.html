<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üóùÔ∏è üê© üò¨ Apa yang Baru di CTP Pertama SQL Server 2019 üê£ üç≤ üõê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Edisi pertama rilis CTP dari SQL Server 2019 disajikan pada 24 September, dan izinkan saya mengatakan bahwa ini penuh dengan segala macam perbaikan da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apa yang Baru di CTP Pertama SQL Server 2019</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424441/">  Edisi pertama rilis CTP dari SQL Server 2019 disajikan pada 24 September, dan izinkan saya mengatakan bahwa ini penuh dengan segala macam perbaikan dan fitur baru (banyak di antaranya dapat ditemukan dalam formulir pratinjau dalam database Azure SQL).  Saya memiliki kesempatan luar biasa untuk mengetahui hal ini sedikit lebih awal, yang memungkinkan saya untuk memperluas pemahaman saya tentang perubahan, bahkan secara dangkal.  Anda juga dapat membaca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">publikasi terbaru dari tim SQL Server</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi yang diperbarui</a> . <br><br>  Tanpa merinci lebih lanjut, saya akan membahas fitur-fitur kernel baru berikut: kinerja, pemecahan masalah, keamanan, ketersediaan, dan pengembangan.  Saat ini, saya memiliki sedikit lebih banyak detail daripada yang lain, dan beberapa di antaranya sudah siap untuk dipublikasikan.  Saya akan kembali ke bagian ini, juga ke banyak artikel dan dokumentasi lainnya, dan menerbitkannya.  Saya segera memberi tahu Anda bahwa ini bukan ulasan yang komprehensif, tetapi hanya sebagian dari fungsi yang saya berhasil ‚Äúsentuh‚Äù, hingga CTP 2.0.  Masih banyak yang harus dibicarakan. <br><a name="habracut"></a><br><h2>  Performa </h2><br><h4>  Variabel Tabel: Bangunan Rencana Tertunda </h4><br>  Variabel tabel memiliki reputasi yang tidak terlalu baik, sebagian besar di bidang estimasi biaya.  Secara default, SQL Server mengasumsikan bahwa variabel tabel hanya bisa berisi satu baris, yang terkadang mengarah ke pilihan paket yang tidak memadai ketika variabel akan berisi baris berkali-kali lebih banyak.  OPSI (RECOMPILE) biasanya digunakan sebagai solusi, tetapi ini membutuhkan perubahan kode dan boros dalam kaitannya dengan sumber daya untuk melakukan pembangunan kembali setiap waktu, sementara jumlah garis paling sering sama.  Untuk meniru pembangunan kembali, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bendera jejak 2453</a> diperkenalkan, tetapi juga membutuhkan peluncuran dengan bendera, dan hanya berfungsi ketika perubahan signifikan dalam garis terjadi. <br><br>  Pada tingkat kompatibilitas 150, konstruksi ditunda dilakukan jika variabel tabel hadir dan rencana kueri tidak dibangun sampai variabel tabel diisi satu kali.  Biaya akan diestimasi berdasarkan hasil penggunaan variabel tabel pertama, tanpa perubahan lebih lanjut.  Ini adalah kompromi antara pembangunan kembali konstan untuk mendapatkan biaya yang tepat, dan tidak adanya pembangunan kembali dengan biaya konstan 1. Jika jumlah baris tetap relatif konstan, maka ini adalah indikator yang baik (dan bahkan lebih baik jika jumlahnya melebihi 1), tetapi mungkin kurang menguntungkan jika ada variasi besar dalam jumlah baris. <br><br>  Saya mempresentasikan analisis yang lebih dalam dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tabular Variables</a> baru-baru ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">: Build Tertunda dalam SQL Server</a> , dan Brent Ozar juga membicarakan hal ini dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Fast Tabular Variables (Dan Masalah Analisis Parameter Baru)</a> . <br><br><h4>  Umpan Balik Alokasi Memori dalam Mode String </h4><br>  SQL Server 2017 memiliki umpan balik alokasi memori batch, yang dijelaskan secara rinci di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Pada dasarnya, untuk alokasi memori apa pun yang terkait dengan paket kueri yang menyertakan pernyataan mode kumpulan, SQL Server akan mengevaluasi memori yang digunakan oleh kueri dan membandingkannya dengan memori yang diminta.  Jika memori yang diminta terlalu kecil atau terlalu banyak, yang akan menyebabkan pengeringan dalam tempdb atau pemborosan memori, maka pada awal berikutnya memori yang dialokasikan untuk rencana kueri yang sesuai akan disesuaikan.  Perilaku ini akan mengurangi volume yang dialokasikan dan memperluas konkurensi, atau meningkatkannya, untuk meningkatkan kinerja. <br><br>  Sekarang kita mendapatkan perilaku yang sama untuk kueri dalam mode string, di bawah tingkat kompatibilitas 150. Jika kueri dipaksa untuk menggabungkan data ke disk, maka untuk peluncuran selanjutnya memori yang dialokasikan akan meningkat.  Jika setelah selesai setengah permintaan memori diperlukan daripada yang dialokasikan, maka untuk permintaan selanjutnya akan disesuaikan ke bawah.  Bretn Ozar menjelaskan hal ini lebih terinci dalam artikelnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Alokasi Memori Bersyarat</a> . <br><br><h4>  Mode batch untuk penyimpanan baris demi baris </h4><br>  Dimulai dengan SQL Server 2012, tabel kueri dengan indeks kolom telah mendapat manfaat dari peningkatan kinerja mode batch.  Peningkatan kinerja disebabkan oleh prosesor kueri yang melakukan pemrosesan batch dan bukan dari segi baris.  Garis juga diproses oleh inti penyimpanan dalam paket, yang menghindari pernyataan pertukaran mata uang.  Paul White ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">@SQL_Kiwi</a> ) mengingatkan saya bahwa jika Anda menggunakan tabel kosong dengan penyimpanan kolom untuk memungkinkan operasi mode batch, maka baris yang diproses akan dikumpulkan ke dalam paket dengan pernyataan yang tidak terlihat.  Namun, penopang ini dapat meniadakan perbaikan yang diterima dari pemrosesan batch.  Beberapa informasi tentang ini ada di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jawaban Stack Exchange</a> . <br><br>  Pada tingkat kompatibilitas 150, SQL Server 2019 akan secara otomatis memilih mode batch sebagai jalan tengah dalam kasus-kasus tertentu, bahkan ketika tidak ada indeks kolom.  Anda mungkin berpikir mengapa tidak membuat indeks kolom dan topi saja?  Atau terus menggunakan kruk yang disebutkan di atas?  Pendekatan ini juga diperluas ke objek tradisional dengan penyimpanan baris, karena indeks kolom, karena beberapa alasan, tidak selalu mungkin, termasuk batasan fungsional (misalnya, pemicu), overhead selama operasi pembaruan atau penghapusan yang sangat dimuat, dan kurangnya dukungan dari produsen pihak ketiga.  Dan tidak ada hal baik yang bisa diharapkan dari tongkat itu. <br>  Saya membuat tabel yang sangat sederhana dengan 10 juta baris dan satu indeks berkerumun pada kolom integer dan menjalankan kueri ini: <br><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> sa5, sa2, <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>(i1), <span class="hljs-keyword"><span class="hljs-keyword">SUM</span></span>(i2), <span class="hljs-keyword"><span class="hljs-keyword">COUNT</span></span>(*) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> dbo.FactTable <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> i1 &gt; <span class="hljs-number"><span class="hljs-number">100000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> sa5, sa2 <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> sa5, sa2;</code> </pre> <br>  Rencana tersebut dengan jelas menunjukkan pencarian indeks dan konkurensi, tetapi tidak sepatah kata pun tentang indeks kolom (seperti yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ditunjukkan oleh SentryOne Plan Explorer</a> ): <br><br><img src="https://habrastorage.org/webt/se/cp/6u/secp6uhnmrnslv_estaiqavexbm.png"><br><br>  Tetapi jika Anda menggali sedikit lebih dalam, Anda dapat melihat bahwa hampir semua operator dieksekusi dalam mode batch, bahkan penyortiran dan perhitungan skalar: <br><br><img src="https://habrastorage.org/webt/0t/uu/lf/0tuulfjwod55k5fufwksdyvauae.png"><br><br>  Anda dapat menonaktifkan fitur ini dengan tetap pada tingkat kompatibilitas yang lebih rendah dengan mengubah konfigurasi database atau dengan menggunakan prompt DISALLOW_BATCH_MODE dalam kueri: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">OPTION</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">USE</span></span> HINT (<span class="hljs-string"><span class="hljs-string">'DISALLOW_BATCH_MODE'</span></span>));</code> </pre> <br>  Dalam hal ini, operator pertukaran tambahan muncul, semua operator dieksekusi dalam mode baris demi baris, dan waktu eksekusi kueri hampir tiga kali lipat. <br><br><img src="https://habrastorage.org/webt/0n/v9/k9/0nv9k9ihqq1_jprzfth_o3wwrqs.png"><br><br>  Untuk tingkat tertentu, Anda bisa melihat ini dalam diagram, tetapi dalam pohon detail rencana Anda juga bisa melihat pengaruh kondisi pemilihan yang tidak dapat mengecualikan baris sampai penyortiran terjadi: <br><br><img src="https://habrastorage.org/webt/ek/p6/6c/ekp66cg3v8b1nfezgsyspmxgkbc.png"><br><br>  Pilihan mode batch tidak selalu merupakan langkah yang baik - heuristik yang termasuk dalam algoritma pengambilan keputusan memperhitungkan jumlah garis, jenis operator yang diusulkan dan manfaat yang diharapkan dari mode batch. <br><br><h4>  <font color="#004d71">APPROX_COUNT_DISTINCT</font> </h4><br>  Fungsi agregat baru ini dimaksudkan untuk skenario pergudangan data dan setara dengan COUNT (DISTINCT ()).  Namun, alih-alih melakukan penyortiran yang mahal untuk menentukan kuantitas aktual, fungsi baru bergantung pada statistik untuk mendapatkan data yang relatif akurat.  Anda perlu memahami bahwa kesalahan terletak pada 2% dari jumlah yang tepat, dan dalam 97% kasus yang merupakan norma untuk analisis tingkat tinggi, ini adalah nilai yang ditampilkan pada indikator atau digunakan untuk perkiraan cepat. <br><br>  Pada sistem saya, saya membuat tabel dengan kolom bilangan bulat yang menyertakan nilai unik dalam kisaran 100 hingga 1.000.000, dan kolom baris, dengan nilai unik di kisaran 100 hingga 100.000. Tidak memiliki indeks kecuali kunci primer yang dikelompokkan di awal kolom bilangan bulat.  Berikut adalah hasil dari mengeksekusi COUNT (DISTINCT ()) dan APPROX_COUNT_DISTINCT () pada kolom-kolom ini, yang darinya Anda dapat melihat sedikit perbedaan (tetapi selalu dalam 2%): <br><br><img src="https://habrastorage.org/webt/ou/a5/1x/oua51xwiabvnyltf75s-pjtqdn0.png"><br><br>  Gain sangat besar jika ada keterbatasan memori, yang berlaku untuk kebanyakan dari kita.  Jika Anda melihat paket kueri, dalam kasus khusus ini, Anda dapat melihat perbedaan besar dalam konsumsi memori oleh operator pencocokan hash: <br><br><img src="https://habrastorage.org/webt/xk/tl/sn/xktlsnekpwpu--xaebgb_ndkcn8.png"><br><br>  Perhatikan bahwa Anda biasanya hanya akan melihat peningkatan kinerja yang signifikan jika Anda sudah terikat memori.  Di sistem saya, eksekusi berlangsung sedikit lebih lama karena utilisasi CPU yang tinggi dari fitur baru: <br><br><img src="https://habrastorage.org/webt/d9/nl/n8/d9nln84mrqh-kfmumdca_u8tt8u.png"><br><br>  Mungkin perbedaannya akan lebih signifikan jika saya memiliki tabel yang lebih besar, lebih sedikit memori yang tersedia untuk SQL Server, konkurensi lebih tinggi, atau kombinasi di atas. <br><br><h4>  <font color="#004d71">Kiat untuk menggunakan tingkat kompatibilitas dalam kueri</font> </h4><br>  Apakah Anda memiliki permintaan khusus yang berfungsi lebih baik di bawah tingkat kompatibilitas tertentu, berbeda dari database saat ini?  Ini sekarang dimungkinkan berkat petunjuk permintaan baru yang mendukung enam tingkat kompatibilitas yang berbeda dan lima model berbeda untuk memperkirakan jumlah elemen.  Berikut ini adalah tingkat kompatibilitas yang tersedia, contoh sintaks, dan model tingkat kompatibilitas yang digunakan dalam setiap kasus.  Lihat bagaimana ini memengaruhi peringkat, bahkan untuk tampilan sistem: <br><br><img src="https://habrastorage.org/webt/gn/0n/g1/gn0ng1ar9z_cxpi7mt8_kaiqkmu.png"><br><br>  Singkatnya: tidak perlu lagi mengingat flag jejak, atau bertanya-tanya apakah Anda perlu khawatir tentang apakah tambalan TF 4199 untuk optimizer kueri didistribusikan, atau dibatalkan oleh beberapa paket layanan lainnya.  Perhatikan bahwa tips tambahan ini baru-baru ini ditambahkan untuk SQL Server 2017 dalam pembaruan kumulatif # 10 (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blog Pedro Lopez untuk</a> detailnya).  Anda dapat melihat semua petunjuk yang tersedia dengan perintah berikut: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">name</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> sys.dm_exec_valid_use_hints;</code> </pre> <br>  Tapi jangan lupa bahwa petunjuk adalah ukuran yang luar biasa, mereka sering cocok untuk keluar dari situasi yang sulit, tetapi jangan direncanakan untuk digunakan dalam jangka panjang, karena perilaku mereka dapat berubah dengan pembaruan berikutnya. <br><br><h2>  <font color="#c30">Pemecahan masalah</font> </h2><br><h4>  <font color="#004d71">Profil default sederhana</font> </h4><br>  Memahami peningkatan ini membutuhkan beberapa hal untuk diingat.  SQL Server 2014 memperkenalkan tampilan DMV sys.dm_exec_query_profiles, yang memungkinkan pengguna yang menjalankan kueri untuk mengumpulkan informasi diagnostik tentang semua pernyataan di semua bagian kueri.  Informasi yang dikumpulkan menjadi tersedia setelah penyelesaian kueri dan memungkinkan Anda untuk menentukan operator mana yang benar-benar menghabiskan sumber daya utama dan mengapa.  Setiap pengguna yang tidak memenuhi permintaan spesifik dapat menerima data ini untuk sesi apa pun di mana pernyataan STATISTIK XML atau STATISTIK PROFIL disertakan, atau untuk semua sesi, menggunakan acara extended_post_execution_showplan, meskipun acara ini, khususnya, dapat memengaruhi kinerja secara keseluruhan. <br><br>  Di Management Studio 2016, fungsionalitas telah ditambahkan yang memungkinkan Anda untuk menampilkan aliran data yang melewati rencana kueri secara real time berdasarkan informasi yang dikumpulkan dari DMV, yang membuatnya bahkan lebih kuat untuk pemecahan masalah.  Plan Explorer juga menawarkan kemampuan untuk memvisualisasikan data yang melewati kueri, baik dalam waktu nyata maupun dalam mode pemutaran. <br><br>  Dimulai dengan SQL Server 2016 Paket Layanan 1 (SP1), Anda juga dapat mengaktifkan versi ringan pengumpulan data ini untuk semua sesi menggunakan jejak jejak 7412 atau properti query_thread_profile canggih, yang memungkinkan Anda untuk segera mendapatkan informasi terbaru tentang sesi apa pun, tanpa perlu apa pun termasuk di dalamnya secara eksplisit (khususnya, hal-hal yang mempengaruhi kinerja).  Ini dijelaskan lebih rinci di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blog Pedro Lopez</a> . <br><br>  Di SQL Server 2019, fitur ini diaktifkan secara default, jadi Anda tidak perlu menjalankan sesi dengan peristiwa yang diperluas atau menggunakan tanda jejak dan pernyataan STATISTIK dalam kueri apa pun.  Lihat saja data dari DMV kapan saja untuk semua sesi bersamaan.  Namun dimungkinkan untuk menonaktifkan mode ini menggunakan LIGHTWEIGHT_QUERY_PROFILING, namun, sintaks ini tidak berfungsi di CTP 2.0 dan akan diperbaiki dalam edisi mendatang. <br><br><h4>  <font color="#004d71">Statistik indeks kolom yang dikelompokkan sekarang tersedia dalam database yang dikloning</font> </h4><br>  Dalam versi SQL Server saat ini, ketika kloning database, hanya statistik objek asli dari indeks kolom berkerumun digunakan, tidak termasuk pembaruan yang dibuat ke tabel setelah pembuatannya.  Jika Anda menggunakan klon untuk mengonfigurasi kueri dan pengujian kinerja lainnya, yang didasarkan pada peringkat daya, maka contoh ini mungkin tidak berfungsi.  Parikshit Savyani menjelaskan batasan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam publikasi ini</a> dan memberikan solusi sementara - sebelum membuat klon, Anda perlu membuat skrip yang mengeksekusi DBCC SHOW_STATISTICS ... DENGAN STATS_STREAM untuk setiap objek.  Itu mahal dan, tentu saja, mudah melupakannya. <br><br>  Di SQL Server 2019, statistik yang diperbarui ini akan secara otomatis tersedia di klon, sehingga Anda dapat menguji berbagai skenario kueri dan mendapatkan rencana obyektif berdasarkan statistik nyata, tanpa menjalankan STATS_STREAM secara manual untuk semua tabel. <br><br><h4>  <font color="#004d71">Prakiraan kompresi untuk penyimpanan kolom</font> </h4><br>  Dalam versi saat ini, prosedur sys.sp_estimate_data_compression_savings memiliki pemeriksaan berikut: <br><br><pre> <code class="sql hljs">if (@data_compression not in ('NONE', 'ROW', 'PAGE'))</code> </pre> <br>  Ini berarti Anda dapat memeriksa kompresi baris atau halaman (atau melihat hasil penghapusan kompresi saat ini).  Di SQL Server 2019, pemeriksaan ini sekarang terlihat seperti ini: <br><br><pre> <code class="sql hljs">if (@data_compression not in ('NONE', 'ROW', 'PAGE', 'COLUMNSTORE', 'COLUMNSTORE_ARCHIVE'))</code> </pre> <br>  Ini adalah berita bagus karena memungkinkan Anda untuk memperkirakan secara kasar dampak menambahkan indeks kolom ke tabel yang tidak memilikinya, atau mengonversi tabel atau partisi ke format penyimpanan kolom yang lebih terkompresi, tanpa harus mengembalikan tabel ke sistem lain.  Saya memiliki tabel dengan 10 juta baris, di mana saya melakukan prosedur tersimpan dengan masing-masing dari lima parameter: <br><br><pre> <code class="sql hljs">EXEC sys.sp_estimate_data_compression_savings @schema_name = N'dbo', @object_name = N'FactTable', @index_id = NULL, @partition_number = NULL, @data_compression = N'NONE'; <span class="hljs-comment"><span class="hljs-comment">-- repeat for ROW, PAGE, COLUMNSTORE, COLUMNSTORE_ARCHIVE</span></span></code> </pre> <br>  Hasil: <br><br><img src="https://habrastorage.org/webt/d6/xu/uy/d6xuuythndwrwogn22ljt83w8y4.png"><br><br>  Seperti jenis kompresi lainnya, akurasi sepenuhnya tergantung pada baris yang tersedia dan keterwakilan data lainnya.  Namun, ini adalah cara yang cukup ampuh untuk mendapatkan hasil yang dapat diprediksi tanpa banyak kesulitan. <br><br><h4>  <font color="#004d71">Fitur baru untuk mendapatkan info halaman</font> </h4><br>  Untuk waktu yang lama, PAGE DBCC dan DBCC IND digunakan untuk mengumpulkan informasi tentang halaman yang berisi bagian, indeks, atau tabel.  Tetapi mereka tidak berdokumen dan tidak didukung, dan mungkin membosankan untuk mengotomatisasi solusi tugas yang terkait dengan beberapa indeks atau halaman. <br><br>  Kemudian, fungsi administrasi dinamis (DMF) sys.dm_db_database_page_allocations muncul, yang mengembalikan set yang mewakili semua halaman di objek yang ditentukan.  Masih tidak terdokumentasi dan memiliki kekurangan yang dapat menjadi masalah nyata pada tabel besar: bahkan untuk mendapatkan informasi tentang satu halaman, ia harus membaca seluruh struktur, yang bisa sangat mahal. <br><br>  Di SQL Server 2019, DMF lain telah muncul - sys.dm_db_page_info.  Ini pada dasarnya mengembalikan semua informasi halaman, tanpa overhead distribusi DMF.  Namun, untuk menggunakan fungsi dalam build saat ini, Anda perlu mengetahui jumlah halaman yang Anda cari sebelumnya.  Mungkin langkah ini diambil dengan sengaja, karena  ini adalah satu-satunya cara untuk memastikan kinerja.  Jadi, jika Anda mencoba mengidentifikasi semua halaman dalam indeks atau tabel, maka Anda masih perlu menggunakan distribusi DMF.  Pada artikel selanjutnya saya akan menjelaskan pertanyaan ini secara lebih rinci. <br><br><h2>  <font color="#c30">Keamanan</font> </h2><br><h4>  <font color="#004d71">Enkripsi permanen menggunakan lingkungan yang aman (kantong)</font> </h4><br>  Saat ini, enkripsi permanen melindungi data sensitif selama transmisi dan dalam memori dengan enkripsi / dekripsi pada setiap akhir proses.  Sayangnya, ini sering mengarah pada batasan serius ketika bekerja dengan data, seperti ketidakmampuan untuk melakukan perhitungan dan pemfilteran, sehingga Anda harus mentransfer seluruh data yang ditetapkan ke sisi klien untuk melakukan, katakanlah, pencarian rentang. <br><br>  Lingkungan aman (enklosur) adalah area memori yang dilindungi di mana perhitungan dan penyaringan tersebut dapat didelegasikan (Windows menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">keamanan berbasis virtualisasi</a> ) - data tetap dienkripsi dalam kernel, tetapi dapat dengan aman didekripsi atau dienkripsi dalam lingkungan yang aman.  Anda hanya perlu menambahkan parameter ENCLAVE_COMPUTATIONS ke kunci utama menggunakan SSMS, misalnya, dengan mencentang kotak "Izinkan perhitungan dalam lingkungan yang aman": <br><br><img src="https://habrastorage.org/webt/do/ia/tp/doiatpb0ne_kpxgb5pbdep8ua5m.png"><br><br>  Sekarang Anda dapat mengenkripsi data hampir secara instan, dibandingkan dengan metode lama (di mana wizard, cmdlet Set-SqlColumnEncyption atau aplikasi Anda, harus sepenuhnya mendapatkan seluruh set dari database, mengenkripsi, dan mengirimkannya kembali): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> dbo.Patients <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> SSN <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">9</span></span>) <span class="hljs-comment"><span class="hljs-comment">-- currently not encrypted! ENCRYPTED WITH ( COLUMN_ENCRYPTION_KEY = ColumnEncryptionKeyName, ENCRYPTION_TYPE = Randomized, ALGORITHM = 'AEAD_AES_256_CBC_HMAC_SHA_256' ) NOT NULL;</span></span></code> </pre> <br>  Saya pikir bahwa bagi banyak organisasi peningkatan ini akan menjadi berita utama, tetapi dalam CTP saat ini beberapa subsistem ini masih diperbaiki, oleh karena itu mereka dimatikan secara default, tetapi di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> Anda dapat melihat cara menyalakannya. <br><br><h4>  <font color="#004d71">Manajemen Sertifikat di Manajer Konfigurasi</font> </h4><br>  Mengelola sertifikat SSL dan TLS selalu menyusahkan, dan banyak orang terpaksa melakukan pekerjaan yang membosankan dengan membuat skrip mereka sendiri untuk menggunakan dan mempertahankan sertifikat perusahaan mereka.  Manajer konfigurasi yang diperbarui untuk SQL Server 2019 akan membantu Anda dengan cepat melihat dan memverifikasi sertifikat dari setiap contoh, menemukan sertifikat yang segera kedaluwarsa, dan menyinkronkan penyebaran sertifikat di semua replikasi dalam grup ketersediaan atau semua node dalam instance cluster failover. <br><br>  Saya belum mencoba semua operasi ini, tetapi mereka harus bekerja untuk versi SQL Server sebelumnya jika manajemen berasal dari SQL Server 2019 Configuration Manager. <br><br><h4>  <font color="#004d71">Klasifikasi dan audit data bawaan</font> </h4><br>  Tim pengembangan SQL Server telah menambahkan kemampuan untuk mengklasifikasikan data dalam SSMS 17.5, yang memungkinkan Anda untuk mengidentifikasi kolom apa pun yang mungkin berisi informasi sensitif atau bertentangan dengan berbagai standar (HIPAA, SOX, PCI, dan GDPR, tentu saja).  Panduan menggunakan algoritme yang menawarkan kolom yang seharusnya menyebabkan masalah, tetapi Anda dapat menyesuaikan kalimatnya dengan menghapus kolom ini dari daftar, atau menambahkan milik Anda.  Untuk menyimpan klasifikasi, digunakan properti canggih;  Laporan SSMS bawaan menggunakan informasi yang sama untuk menampilkan datanya.  Di luar laporan, sifat-sifat ini tidak begitu jelas. <br><br>  SQL Server 2019 memperkenalkan pernyataan baru untuk metadata ini, yang sudah tersedia di Azure SQL Database, dan disebut ADD SENSITIVITY CLASSIFICATION.  Ini memungkinkan Anda untuk melakukan hal yang sama seperti wizard di SSMS, tetapi informasi tersebut tidak lagi disimpan di properti yang diperluas, dan setiap akses ke data ini secara otomatis ditampilkan dalam audit sebagai kolom XML baru data_sensitivity_information.  Ini berisi semua jenis informasi yang terpengaruh selama audit. <br><br>  Sebagai contoh cepat, misalkan saya punya meja untuk kontraktor eksternal: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> dbo.Contractors ( FirstName sysname, LastName sysname, SSN <span class="hljs-built_in"><span class="hljs-built_in">char</span></span>(<span class="hljs-number"><span class="hljs-number">9</span></span>), HourlyRate <span class="hljs-built_in"><span class="hljs-built_in">decimal</span></span>(<span class="hljs-number"><span class="hljs-number">6</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>) );</code> </pre> <br>  Melihat struktur seperti itu, menjadi jelas bahwa keempat kolom berpotensi rentan terhadap kebocoran, atau hanya dapat diakses oleh lingkaran orang yang terbatas.  Di sini Anda dapat bertahan dengan izin, tetapi setidaknya Anda harus fokus padanya.  Dengan demikian, kita dapat mengklasifikasikan kolom ini dengan cara yang berbeda: <br><br><pre> <code class="sql hljs">ADD SENSITIVITY CLASSIFICATION TO dbo.Contractors.FirstName, dbo.Contractors.LastName <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (LABEL = <span class="hljs-string"><span class="hljs-string">'Confidential √¢‚Ç¨‚Äú GDPR'</span></span>, INFORMATION_TYPE = <span class="hljs-string"><span class="hljs-string">'Personal Info'</span></span>); ADD SENSITIVITY CLASSIFICATION TO dbo.Contractors.SSN <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (LABEL = <span class="hljs-string"><span class="hljs-string">'Highly Confidential'</span></span>, INFORMATION_TYPE = <span class="hljs-string"><span class="hljs-string">'National ID'</span></span>); ADD SENSITIVITY CLASSIFICATION TO dbo.Contractors.HourlyRate <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (LABEL = <span class="hljs-string"><span class="hljs-string">'Highly Confidential'</span></span>, INFORMATION_TYPE = <span class="hljs-string"><span class="hljs-string">'Financial'</span></span>);</code> </pre> <br>  Sekarang, alih-alih melihat sys.extended_properties, Anda dapat melihatnya di sys.sensitivity_classifications: <br><br><img src="https://habrastorage.org/webt/xs/4u/bx/xs4ubxognfau0yxlbl_g8caqujm.png"><br><br>  Dan jika kita melakukan sampling audit (atau DML) untuk tabel ini, kita tidak perlu secara khusus mengubah apa pun;  setelah membuat klasifikasi, <code>SELECT *</code> akan mencatat dalam audit log, catatan dari jenis informasi ini dalam kolom baru data_sensitivity_information: <br><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">sensitivity_attributes</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">sensitivity_attribute</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">label</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Confidential - GDPR"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">information_type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Personal Info"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">sensitivity_attribute</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">label</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Highly Confidential"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">information_type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"National ID"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">sensitivity_attribute</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">label</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Highly Confidential"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">information_type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Financial"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">sensitivity_attributes</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br>  Tentu saja, ini tidak menyelesaikan semua masalah kepatuhan dengan standar, tetapi dapat memberikan keuntungan nyata.  Menggunakan wizard untuk secara otomatis mengidentifikasi kolom dan menerjemahkan panggilan properti sp_addextendedproperty menjadi perintah ADD SENSITIVITY CLASSIFICATION dapat sangat menyederhanakan tugas memenuhi standar.  Nanti, saya akan menulis artikel terpisah tentang ini. <br><br>  Anda juga dapat mengotomatiskan pembuatan (atau memperbarui) izin berdasarkan label pada metadata - pembuatan skrip SQL dinamis yang melarang akses ke semua kolom rahasia (GDPR), yang akan memungkinkan Anda untuk mengelola pengguna, grup, atau peranb.  Saya akan mengerjakan masalah ini di masa mendatang. <br><br><h2>  <font color="#c30">Ketersediaan</font> </h2><br><h4>  <font color="#004d71">Pembuatan indeks terbarukan waktu-nyata</font> </h4><br>  Dalam SQL Server 2017, menjadi mungkin untuk menunda dan melanjutkan membangun kembali indeks secara real time, yang dapat sangat berguna jika Anda perlu mengubah jumlah prosesor yang digunakan, melanjutkan dari saat penskorsan setelah kegagalan, atau hanya menjembatani kesenjangan antara jendela layanan.  Saya berbicara tentang fitur ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel sebelumnya</a> . <br><br>  Di SQL Server 2019, Anda dapat menggunakan sintaks yang sama untuk membuat indeks real-time, jeda dan lanjutkan, dan juga untuk membatasi waktu eksekusi (mengatur waktu jeda): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> foo <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> dbo.bar(blat) <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ONLINE</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">RESUMABLE</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>, MAX_DURATION = <span class="hljs-number"><span class="hljs-number">10</span></span> MINUTES);</code> </pre> <br>  Jika kueri ini bekerja terlalu lama, maka Anda dapat menjeda ALTER INDEX di sesi lain (bahkan jika indeks belum ada secara fisik): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> foo <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> dbo.bar PAUSE;</code> </pre> <br>  Dalam bangunan saat ini, tingkat paralelisme selama pembaruan tidak dapat dikurangi, seperti halnya dengan pembangunan kembali.  Saat mencoba mengurangi DOP: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> foo <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> dbo.bar <span class="hljs-keyword"><span class="hljs-keyword">RESUME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (MAXDOP = <span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  Kami mendapatkan yang berikut ini: <br><br><pre> <code class="hljs pgsql">Msg <span class="hljs-number"><span class="hljs-number">10666</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span>, State <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-type"><span class="hljs-type">Line</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> Cannot resume <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> build <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> required DOP <span class="hljs-number"><span class="hljs-number">4</span></span> (DOP operation was started <span class="hljs-keyword"><span class="hljs-keyword">with</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> available. Please ensure sufficient DOP <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> available <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abort</span></span> existing <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> operation <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> try again. The <span class="hljs-keyword"><span class="hljs-keyword">statement</span></span> has been terminated.</code> </pre> <br>  Bahkan, jika Anda mencoba melakukan ini, dan kemudian menjalankan perintah tanpa parameter tambahan, Anda akan mendapatkan kesalahan yang sama, setidaknya pada build saat ini.  Saya pikir upaya pembaruan direkam di suatu tempat dan sistem ingin menggunakannya lagi.  Untuk melanjutkan, Anda harus menentukan nilai DOP yang benar (atau lebih tinggi): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> foo <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> dbo.bar <span class="hljs-keyword"><span class="hljs-keyword">RESUME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (MAXDOP = <span class="hljs-number"><span class="hljs-number">4</span></span>);</code> </pre> <br>  Untuk memperjelas: Anda dapat meningkatkan DOP saat melanjutkan pembuatan indeks yang dijeda, tetapi tidak menurunkannya. <br><br>  Manfaat tambahan dari semua ini adalah Anda dapat mengonfigurasi pembuatan dan / atau pembaruan indeks secara real time sebagai mode default menggunakan klausa ELEVATE_ONLINE dan ELEVATE_RESUMABLE untuk database baru. <br><br><h4>  <font color="#004d71">Pembuatan / pembangunan kembali real-time dari indeks kolom berkerumun</font> </h4><br>  Selain pembuatan indeks yang dapat diperbarui, kami juga mendapatkan kesempatan untuk membuat atau membangun kembali indeks kolom yang dikelompokkan secara real time.  Ini adalah perubahan signifikan, yang memungkinkan Anda untuk tidak lagi menghabiskan waktu jendela layanan untuk pemeliharaan indeks tersebut atau (untuk kepastian yang lebih besar) untuk mengkonversi indeks dari baris-bijaksana ke kolom-bijaksana: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> dbo.splunge ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ); GO <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNIQUE</span></span> CLUSTERED <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> PK_Splunge <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> dbo.splunge(<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>); GO <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> CLUSTERED COLUMNSTORE <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> PK_Splunge <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> dbo.splunge <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (DROP_EXISTING = <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">ONLINE</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Satu peringatan: jika indeks cluster tradisional yang ada dibuat secara real time, maka konversinya ke indeks kolom cluster juga hanya dimungkinkan dalam mode ini. </font><font style="vertical-align: inherit;">Jika itu adalah bagian dari kunci utama, bawaan atau tidak ...</font></font><br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> dbo.splunge ( <span class="hljs-keyword"><span class="hljs-keyword">id</span></span> <span class="hljs-built_in"><span class="hljs-built_in">int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> PK_Splunge PRIMARY <span class="hljs-keyword"><span class="hljs-keyword">KEY</span></span> CLUSTERED (<span class="hljs-keyword"><span class="hljs-keyword">id</span></span>) ); GO <span class="hljs-comment"><span class="hljs-comment">-- or after the fact -- ALTER TABLE dbo.splunge ADD CONSTRAINT PK_Splunge PRIMARY KEY CLUSTERED(id);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami mendapatkan kesalahan berikut: </font></font><br><br><pre> <code class="hljs pgsql">Msg <span class="hljs-number"><span class="hljs-number">1907</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">Level</span></span> <span class="hljs-number"><span class="hljs-number">16</span></span> Cannot recreate <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> <span class="hljs-string"><span class="hljs-string">'PK_Splunge'</span></span>. The <span class="hljs-built_in"><span class="hljs-built_in">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">index</span></span> definition does <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> match the <span class="hljs-keyword"><span class="hljs-keyword">constraint</span></span> being enforced <span class="hljs-keyword"><span class="hljs-keyword">by</span></span> the existing <span class="hljs-keyword"><span class="hljs-keyword">index</span></span>.</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Anda harus terlebih dahulu menghapus kendala untuk mengubahnya menjadi indeks kolom berkerumun, tetapi kedua operasi ini dapat dilakukan secara real time: </font></font><br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> dbo.splunge <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CONSTRAINT</span></span> PK_Splunge <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ONLINE</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>); GO <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> CLUSTERED COLUMNSTORE <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> PK_Splunge <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> dbo.splunge <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">ONLINE</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span>);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini berfungsi, tetapi tabel besar cenderung memakan waktu lebih lama daripada jika kunci primer diimplementasikan sebagai indeks cluster unik. </font><font style="vertical-align: inherit;">Saya tidak bisa mengatakan dengan pasti apakah ini adalah pembatasan yang disengaja atau hanya batasan CTP saat ini.</font></font><br><br><h4> <font color="#004d71"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengarahkan koneksi replikasi dari server sekunder ke primer </font></font><br></font> </h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fungsi ini memungkinkan Anda untuk mengkonfigurasi pengalihan tanpa mendengarkan, sehingga Anda dapat mengalihkan koneksi ke server utama, bahkan jika sekunder ditentukan secara langsung dalam string koneksi. </font><font style="vertical-align: inherit;">Fungsi ini dapat digunakan ketika teknologi pengelompokan tidak mendukung mendengarkan, saat menggunakan AGs tanpa sebuah klaster, atau ketika ada skema pengalihan yang kompleks dalam skenario dengan beberapa subnet. </font><font style="vertical-align: inherit;">Ini akan mencegah koneksi dari, misalnya, mencoba menulis operasi untuk replikasi dalam mode read-only (dan kegagalan, masing-masing).</font></font><br><br><h2>  <font color="#c30">Pengembangan</font> </h2><br><h4> <font color="#004d71"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fitur tambahan dari grafik</font></font></font> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hubungan grafik sekarang mendukung pernyataan MERGE untuk node atau tabel batas menggunakan predikat MERGE; </font><font style="vertical-align: inherit;">Sekarang satu operator dapat memperbarui tepi yang ada atau memasukkan yang baru. </font><font style="vertical-align: inherit;">Pembatasan tepi baru memungkinkan Anda menentukan simpul mana yang dapat disambungkan tepi.</font></font><br><br><h4> <font color="#004d71"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Utf-8</font></font></font> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL Server 2012 menambahkan dukungan untuk UTF-16 dan karakter tambahan dengan mengatur penyortiran dengan menentukan nama dengan akhiran _SC, seperti Latin1_General_100_CI_AI_SC, untuk menggunakan kolom Unicode (nchar / nvarchar). Di SQL Server 2017, Anda dapat mengimpor dan mengekspor data UTF-8 dari dan ke kolom ini menggunakan alat seperti </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BCP</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">BULK INSERT</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di SQL Server 2019, ada opsi susunan baru untuk mendukung retensi paksa data UTF-8 dalam bentuk aslinya. </font><font style="vertical-align: inherit;">Jadi, Anda dapat dengan mudah membuat kolom char atau varchar dan menyimpan data UTF-8 dengan benar menggunakan susunan baru dengan akhiran _SC_UTF8, seperti Latin1_General_100_CI_AI_SC_UTF8. </font><font style="vertical-align: inherit;">Ini dapat membantu meningkatkan kompatibilitas dengan aplikasi eksternal dan DBMS, tanpa biaya pemrosesan dan penyimpanan nvarchar.</font></font><br><br><h4> <font color="#004d71"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Telur paskah saya temukan</font></font></font> </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Sejauh yang saya ingat, pengguna SQL Server mengeluh tentang pesan kesalahan yang tidak jelas ini: </font></font><br><br><pre> <code class="hljs vbscript">Msg <span class="hljs-number"><span class="hljs-number">8152</span></span> <span class="hljs-built_in"><span class="hljs-built_in">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> binary data would be truncated.</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Di CTP builds yang saya uji, ada pesan kesalahan yang menarik yang tidak ada sebelumnya: </font></font><br><br><pre> <code class="hljs pgsql">Msg <span class="hljs-number"><span class="hljs-number">2628</span></span> String <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> binary data would be truncated <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">table</span></span> <span class="hljs-string"><span class="hljs-string">'%.*ls'</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">column</span></span> <span class="hljs-string"><span class="hljs-string">'%.*ls'</span></span>. Truncated <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: <span class="hljs-string"><span class="hljs-string">'%.*ls'</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya tidak berpikir hal lain diperlukan di sini; ini merupakan peningkatan besar (meskipun sangat terlambat), dan berjanji untuk membuat banyak orang bahagia. Namun, fungsi ini tidak akan tersedia di CTP 2.0; Saya hanya memberi Anda kesempatan untuk melihat sedikit ke depan. Brent Ozar mendaftar semua pesan baru yang ia temukan di CTP saat ini dan membumbui mereka dengan beberapa komentar bermanfaat di artikel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sys.messages-</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> nya </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">: menemukan fitur tambahan</font></a><font style="vertical-align: inherit;"> .</font></font><br><br><h2>  <font color="#c30">Kesimpulan</font> </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SQL Server 2019 menawarkan fitur tambahan yang bagus yang akan membantu meningkatkan pekerjaan dengan platform basis data relasional favorit Anda, dan ada sejumlah perubahan yang belum saya bicarakan. Memori hemat energi, pengelompokan untuk layanan pembelajaran mesin, replikasi dan transaksi terdistribusi di Linux, Kubernetes, konektor untuk Oracle / Teradata / MongoDB, replikasi AG sinkron telah meningkat untuk mendukung Java (implementasi yang mirip dengan Python / R) dan, yang sama pentingnya, lompatan baru, berjudul Big Data Cluster. Untuk menggunakan beberapa fitur ini, Anda harus mendaftar menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">formulir EAP ini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Buku mendatang Bob Ward, </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pro SQL Server di Linux - Termasuk Penempatan Berbasis Kontainer dengan Docker dan Kubernetes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dapat memberikan beberapa petunjuk tentang sejumlah hal lain yang akan segera hadir. </font><font style="vertical-align: inherit;">Dan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">publikasi ini oleh</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Brent Ozar berbicara tentang kemungkinan perbaikan yang akan datang untuk fungsi skalar yang ditentukan pengguna. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tetapi bahkan dalam CTP publik pertama ini ada sesuatu yang signifikan bagi hampir semua orang, dan saya mendorong Anda untuk mencobanya sendiri!</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id424441/">https://habr.com/ru/post/id424441/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id424429/index.html">Sains Seni dan Suara: 4 proyek mengesankan</a></li>
<li><a href="../id424431/index.html">Valve Meluncurkan Peringkat Game Controller Steam</a></li>
<li><a href="../id424433/index.html">Mengapa hacker Mikrotik dan bagaimana saya menyembunyikan 100 ribu. RouterOS dari botnet</a></li>
<li><a href="../id424435/index.html">Kebun binatang pengeboran minyak: menertibkan</a></li>
<li><a href="../id424437/index.html">Elm Nyaman dan canggung. Json.Encoder dan Json.Decoder</a></li>
<li><a href="../id424443/index.html">Vivaldi 2.0 mendukung kami</a></li>
<li><a href="../id424445/index.html">Neil Ford menerjemahkan Microservices sebagai Arsitektur Evolusi</a></li>
<li><a href="../id424447/index.html">Lisp dibumbui dengan Pascal atau bahasa pemrograman 8501</a></li>
<li><a href="../id424453/index.html">Pelajari OpenGL. Pelajaran 6.2 - Rendering Berbasis Fisik. Sumber Cahaya Analitik</a></li>
<li><a href="../id424455/index.html">Intel Optane - Sekarang 1,5 Terabytes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>