<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧓🏽 🔙 🤝 Membuka kunci wadah LUKS root secara otomatis setelah boot panas 🏑 🖕🏿 🚜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mengapa orang umumnya mengenkripsi drive dari komputer pribadi mereka, dan kadang-kadang server? Jelas tidak ada yang mencuri foto kucing kesayangan m...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membuka kunci wadah LUKS root secara otomatis setelah boot panas</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/457396/"><p>  Mengapa orang umumnya mengenkripsi drive dari komputer pribadi mereka, dan kadang-kadang server?  Jelas tidak ada yang mencuri foto kucing kesayangan mereka dari disk!  Itu hanya nasib buruk: drive yang dienkripsi mengharuskan Anda memasukkan frasa kunci dari keyboard di setiap boot, dan itu panjang dan membosankan.  Untuk menghapusnya sehingga setidaknya kadang-kadang tidak perlu merekrutnya.  Ya, agar makna enkripsi tidak hilang. </p><br><div class="spoiler">  <b class="spoiler_title">Kucing untuk perhatian</b> <div class="spoiler_text"><p><img src="https://habrastorage.org/webt/sr/rt/ny/srrtnywyggbrscsufm8ux8tvxmu.jpeg" alt="Kucing"></p></div></div><br><p>  Nah, benar-benar menghapusnya tidak akan berhasil.  Sebagai gantinya Anda dapat membuat file kunci pada USB flash drive, dan itu juga akan berfungsi.  Dan tanpa flash drive (dan tanpa komputer kedua di jaringan) apakah mungkin?  Jika Anda beruntung dengan BIOS, Anda hampir bisa!  Di bawah potongan akan menjadi panduan tentang cara mengkonfigurasi enkripsi disk melalui LUKS dengan properti berikut: </p><br><ol><li> Frasa sandi atau file kunci tidak disimpan di mana pun dalam bentuk terbuka (atau dalam bentuk yang setara dengan terbuka) saat komputer dimatikan. </li><li>  Pertama kali Anda menyalakan komputer, Anda harus memasukkan frasa sandi. </li><li>  Pada reboot berikutnya (sebelum mematikan), frasa sandi tidak diperlukan. </li></ol><br><p>  Instruksi telah diuji pada CentOS 7.6, Ubuntu 19.04 dan openSUSE Leap 15.1 di mesin virtual dan pada perangkat keras nyata (desktop, laptop dan dua server).  Mereka harus bekerja pada distribusi lain yang memiliki versi Dracut yang berfungsi. </p><br><p>  Dan ya, dengan cara yang baik, ini seharusnya berakhir di hub "administrasi sistem abnormal", tetapi tidak ada hub seperti itu. </p><a name="habracut"></a><br><p>  Saya sarankan menggunakan slot terpisah di wadah LUKS dan menyimpan kunci untuk itu ... di RAM! </p><br><div class="spoiler">  <b class="spoiler_title">Slot apa?</b> <div class="spoiler_text"><p> Wadah LUKS mengimplementasikan enkripsi multi-level.  Data yang berguna pada disk dienkripsi dengan sandi simetris, biasanya <code>aes-xts-plain64</code> .  Kunci cipher simetris ini (kunci utama) dihasilkan pada tahap pembuatan wadah sebagai urutan byte acak.  Kunci master disimpan dalam bentuk terenkripsi, dalam kasus umum - dalam beberapa salinan (slot).  Secara default, hanya satu dari delapan slot yang aktif.  Setiap slot aktif memiliki frase kunci terpisah (atau file kunci terpisah), yang dengannya Anda dapat mendekripsi kunci master.  Dari sudut pandang pengguna, ternyata Anda dapat membuka kunci drive menggunakan salah satu dari beberapa frasa kunci yang berbeda (atau file kunci).  Dalam kasus kami, menggunakan frase kunci (slot 0) atau menggunakan sepotong memori yang digunakan sebagai file kunci (slot 6). </p></div></div><br><p>  BIOS pada kebanyakan motherboard tidak membersihkan memori selama reboot, atau Anda dapat mengonfigurasinya menjadi tidak bersih (pengecualian yang dikenal: "Intel Corporation S1200SP / S1200SP, BIOS S1200SP.86B.03.01.0042.013020190050 01/30/2019").  Karena itu, Anda dapat menyimpan kunci di sana.  Ketika daya dimatikan, isi RAM itu sendiri akan dihapus setelah beberapa saat, bersama dengan salinan kunci yang tidak dilindungi. </p><br><p>  Jadi ayo pergi. </p><br><h3 id="shag-pervyy-ustanovit-sistemu-na-zashifrovannyy-s-pomoschyu-luks-disk">  Langkah satu: instal sistem pada disk yang dienkripsi menggunakan LUKS </h3><br><p>  Dalam kasus ini, partisi disk (misalnya, <code>/dev/sda1</code> ) yang dipasang di <code>/boot</code> harus tetap tidak dienkripsi, dan partisi lain tempat segalanya (misalnya, <code>/dev/sda2</code> ) harus dienkripsi.  Sistem file pada partisi terenkripsi dapat berupa apa saja, Anda juga dapat menggunakan LVM sehingga sistem file root, volume untuk swap, dan semua yang lain kecuali <code>/boot</code> dalam wadah yang sama.  Ini sesuai dengan partisi disk default di CentOS 7 dan Debian ketika memilih opsi enkripsi.  SUSE melakukan semuanya secara berbeda (mengenkripsi <code>/boot</code> ) dan karenanya membutuhkan partisi manual dari disk. </p><br><p>  Hasilnya harus seperti berikut ini: </p><br><pre> <code class="plaintext hljs">$ lsblk NAME MAJ:MIN RM SIZE RO TYPE MOUNTPOINT sda 8:0 0 10G 0 disk ├─sda1 8:1 0 1G 0 part /boot └─sda2 8:2 0 9G 0 part └─luks-d07a97d7-3258-408c-a17c-e2fb56701c69 253:0 0 9G 0 crypt ├─centos_centos--encrypt2-root 253:1 0 8G 0 lvm / └─centos_centos--encrypt2-swap 253:2 0 1G 0 lvm [SWAP]</code> </pre> <br><p>  Dalam hal menggunakan UEFI, juga akan ada Partisi Sistem EFI. </p><br><blockquote>  Untuk pengguna Debian dan Ubuntu: ganti paket <code>initramfs-tools</code> dengan <code>dracut</code> . <br><pre> <code class="plaintext hljs"># apt install --no-install-recommends dracut</code> </pre> <br><br>  <code>initramfs-tools</code> mengimplementasikan logika yang salah dalam kasus kami, diterapkan pada bagian terenkripsi dengan file kunci.  Bagian tersebut diabaikan sepenuhnya, atau konten file kunci disalin ke initramfs (mis., Sebagai hasilnya, ke disk) di tempat kosong, yang tidak kita perlukan. </blockquote><br><h3 id="shag-vtoroy-sozdat-klyuchevoy-fayl-kotoryy-budet-ispolzovatsya-dlya-avtomaticheskogo-razblokirovaniya-diska-posle-goryachey-perezagruzki">  Langkah dua: buat file kunci yang akan digunakan untuk membuka kunci drive secara otomatis setelah reboot panas </h3><br><p>  128 bit acak sudah cukup untuk kita, yaitu  16 byte  File akan disimpan pada disk terenkripsi, sehingga tidak ada orang yang tidak tahu kunci enkripsi dan tidak memiliki akses root ke sistem yang dimuat tidak akan membacanya. </p><br><pre> <code class="plaintext hljs"># touch -m 0600 /root/key # head -c16 /dev/urandom &gt; /root/key</code> </pre> <br><p>  Ada cukup banyak bit acak dalam file kunci sehingga algoritma PBKDF yang lambat, yang membuat kunci enkripsi yang sulit untuk dipilih dari frase kunci yang berpotensi lemah, tidak benar-benar diperlukan.  Karena itu, ketika menambahkan kunci, Anda dapat mengurangi jumlah iterasi: </p><br><pre> <code class="plaintext hljs"># cryptsetup luksAddKey --key-slot=6 --iter-time=1 /dev/sda2 /root/key Enter any existing passphrase:</code> </pre> <br><p>  Seperti yang Anda lihat, file kunci disimpan pada disk terenkripsi dan karenanya tidak menimbulkan risiko keamanan jika komputer dimatikan. </p><br><h3 id="shag-tretiy-vydelit-mesto-v-fizicheskoy-pamyati-dlya-hraneniya-klyucha">  Langkah Tiga: Alokasikan ruang dalam memori fisik untuk menyimpan kunci </h3><br><p>  Linux memiliki setidaknya tiga driver berbeda yang memungkinkan Anda untuk mengakses memori fisik di alamat yang diketahui.  Ini adalah <code>linux/drivers/char/mem.c</code> , yang juga bertanggung jawab untuk perangkat <code>/dev/mem</code> , serta modul <code>phram</code> (mengemulasikan chip MTD, memberikan perangkat <code>/dev/mtd0</code> ) dan <code>nd_e820</code> (digunakan saat bekerja dengan NVDIMM, memberikan <code>/dev/pmem0</code> ).  Mereka semua memiliki fitur yang tidak menyenangkan: </p><br><ul><li>  <code>/dev/mem</code> tidak dapat ditulis ketika menggunakan Secure Boot jika distribusinya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menggunakan patch LOCKDOWN</a> dari Matthew Garrett (dan set patch ini diperlukan jika distribusi akan mendukung Secure Boot dengan bootloader yang ditandatangani oleh Microsoft); </li><li>  <code>phram</code> tidak tersedia di CentOS dan Fedora - pengelola tidak mengaktifkan opsi yang sesuai saat membangun kernel; </li><li>  <code>nd_e820</code> perlu mencadangkan setidaknya 128 megabita memori - ini adalah cara kerja NVDIMM.  Tetapi ini adalah satu-satunya opsi yang berjalan pada CentOS dengan Secure Boot. </li></ul><br><p>  Karena tidak ada opsi yang ideal, ketiganya dipertimbangkan di bawah ini. </p><br><blockquote>  Saat menggunakan salah satu metode, sangat diperlukan kehati-hatian agar tidak memengaruhi perangkat atau rentang memori selain dari yang diperlukan.  Ini terutama berlaku untuk komputer yang sudah memiliki chip MTD atau modul NVDIMM.  Yaitu, <code>/dev/mtd0</code> atau <code>/dev/pmem0</code> mungkin bukan perangkat yang sesuai dengan area memori yang disediakan untuk menyimpan kunci.  Penomoran perangkat yang ada, di mana file konfigurasi dan skrip bergantung, mungkin juga bingung.  Dengan demikian, Anda disarankan untuk menonaktifkan sementara semua layanan yang bergantung pada perangkat yang ada <code>/dev/mtd*</code> dan <code>/dev/pmem*</code> . </blockquote><p>  Memori fisik Linux <code>memmap</code> dengan meneruskan opsi <code>memmap</code> ke <code>memmap</code> .  Kami tertarik pada dua jenis opsi ini: </p><br><ul><li>  <code>memmap=4K$0x10000000</code> cadangan <code>memmap=4K$0x10000000</code> (mis., tanda dicadangkan sehingga kernel itu sendiri tidak menggunakan) 4 kilobyte memori, mulai dari alamat fisik 0x10000000; </li><li>  <code>memmap=128M!0x10000000</code> menandai 128 megabita memori fisik, dimulai dengan alamat 0x10000000, sebagai NVDIMM (jelas palsu, tetapi itu akan berlaku untuk kami). </li></ul><br><p>  Opsi c <code>$</code> cocok untuk digunakan dengan <code>/dev/mem</code> dan <code>phram</code> , opsi c <code>!</code>  - untuk <code>nd_e820</code> .  Saat menggunakan <code>$</code> alamat awal dari memori yang dicadangkan haruslah kelipatan <code>0x1000</code> (mis. 4 kilobyte), saat menggunakan <code>!</code>  - kelipatan <code>0x8000000</code> (mis. 128 megabita). </p><br><p>  Penting: tanda dolar ( <code>$</code> ) dalam file konfigurasi GRUB adalah karakter khusus dan harus diloloskan.  Dan dua kali: sekali - ketika menghasilkan <code>grub.cfg</code> dari <code>/etc/default/grub</code> , kedua kalinya - ketika mengartikan file konfigurasi yang dihasilkan pada tahap boot.  Yaitu  di <code>/etc/default/grub</code> , baris berikut pada akhirnya akan muncul: </p><br><pre> <code class="plaintext hljs">GRUB_CMDLINE_LINUX="memmap=4K\\\$0x10000000 ...  ..."</code> </pre> <br><p>  Tanpa dua kali lolos dari tanda <code>$</code> , sistem tidak akan bisa boot, karena akan berpikir bahwa ia hanya memiliki 4 kilobyte memori.  Tidak ada kesulitan seperti itu dengan tanda seru: </p><br><pre> <code class="plaintext hljs">GRUB_CMDLINE_LINUX="memmap=128M!0x10000000 ...  ..."</code> </pre> <br><p>  Kartu memori fisik (dan diperlukan untuk mengetahui alamat mana yang harus dipesan) dapat diakses oleh <code>root</code> di <code>/proc/iomem</code> pseudo <code>/proc/iomem</code> : </p><br><pre> <code class="plaintext hljs"># cat /proc/iomem ... 000f0000-000fffff : reserved 000f0000-000fffff : System ROM 00100000-7ffddfff : System RAM 2b000000-350fffff : Crash kernel 73a00000-7417c25e : Kernel code 7417c25f-747661ff : Kernel data 74945000-74c50fff : Kernel bss 7ffde000-7fffffff : reserved 80000000-febfffff : PCI Bus 0000:00 fd000000-fdffffff : 0000:00:02.0 ...</code> </pre> <br><p>  RAM ditandai sebagai "RAM Sistem", cukup bagi kami untuk memesan salah satu halamannya untuk menyimpan kunci.  Menebak bagian mana dari memori BIOS yang tidak menyentuh saat reboot tidak akan bekerja dengan baik sebelumnya.  Kecuali jika ada komputer lain dengan versi BIOS yang persis sama dan konfigurasi memori yang sama dengan yang telah dilakukan manual ini.  Oleh karena itu, dalam kasus umum, perlu untuk bertindak dengan coba-coba.  Sebagai aturan, ketika BIOS reboot, itu hanya mengubah data di awal dan di akhir setiap rentang memori.  Biasanya cukup untuk mundur 128 megabita ( <code>0x8000000</code> ) dari tepi.  Untuk mesin virtual KVM dengan memori 1 GB atau lebih, opsi yang diusulkan ( <code>memmap=4K$0x10000000</code> dan <code>memmap=128M!0x10000000</code> ) berfungsi. </p><br><p>  Saat menggunakan modul <code>phram</code> , <code>phram</code> membutuhkan parameter baris perintah kernel lain, yang, pada kenyataannya, memberi tahu modul bagian mana dari memori fisik yang akan digunakan - kita, disediakan.  Parameter disebut <code>phram.phram</code> dan berisi tiga bagian: nama (sewenang-wenang hingga 63 karakter, akan terlihat di <code>sysfs</code> ), alamat awal dan panjangnya.  Alamat dan panjang awal harus sama dengan di <code>memmap</code> , tetapi akhiran <code>K</code> dan <code>M</code> tidak didukung. </p><br><pre> <code class="plaintext hljs">GRUB_CMDLINE_LINUX="memmap=4K\\\$0x10000000 phram.phram=savedkey,0x10000000,4096 ..."</code> </pre> <br><p>  Setelah mengedit <code>/etc/default/grub</code> Anda perlu membuat ulang file konfigurasi nyata yang dibaca GRUB saat boot.  Perintah yang benar untuk ini tergantung pada distribusi. </p><br><pre> <code class="plaintext hljs"># grub2-mkconfig -o /boot/grub2/grub.cfg # CentOS (Legacy BIOS) # grub2-mkconfig -o /boot/efi/EFI/centos/grub.cfg # CentOS (UEFI) # update-grub # Debian, Ubuntu # update-bootloader --reinit # SUSE</code> </pre> <br><p>  Setelah memperbarui konfigurasi GRUB, komputer harus di-boot ulang, tetapi kami akan melakukannya nanti ketika kami memperbarui initramfs. </p><br><h3 id="shag-chetvertyy-nastroit-luks-na-chtenie-klyucha-iz-pamyati">  Langkah keempat: konfigurasikan LUKS untuk membaca kunci dari memori </h3><br><p>  Pengaturan enkripsi <code>/etc/crypttab</code> disimpan dalam file <code>/etc/crypttab</code> .  Setiap baris terdiri dari empat bidang: </p><br><ul><li>  perangkat yang harus diperoleh saat membuka kunci, </li><li>  perangkat terenkripsi </li><li>  tempat mendapatkan file kunci ( <code>none</code> artinya memasukkan frasa kunci dari keyboard), </li><li>  bidang opsional untuk opsi. </li></ul><br><p>  Jika file kunci ada, tetapi tidak cocok, maka Dracut meminta frasa kunci.  Yang mana, pada kenyataannya, akan diminta pada saat boot pertama. </p><br><p>  Contoh file <code>/etc/crypttab</code> dari distribusi yang baru diinstal: </p><br><pre> <code class="plaintext hljs"># cat /etc/crypttab #   luks-d07....69 UUID=d07....69 none</code> </pre> <br><p>  File kunci dalam kasus kami adalah sepotong memori fisik.  Yaitu  <code>/dev/mem</code> , <code>/dev/mtd0</code> atau <code>/dev/pmem0</code> , tergantung pada teknologi akses memori yang dipilih.  Opsi diperlukan untuk menunjukkan bagian file mana yang kuncinya. </p><br><pre> <code class="plaintext hljs"># cat /etc/crypttab #   #   /dev/mem: luks-d07....69 UUID=d07....69 /dev/mem keyfile-offset=0x10000000,keyfile-size=16 #   phram: luks-d07....69 UUID=d07....69 /dev/mtd0 keyfile-size=16 #   nd_e820: luks-d07....69 UUID=d07....69 /dev/pmem0 keyfile-size=16</code> </pre> <br><p>  Hanya saja itu tidak akan bekerja seperti itu. </p><br><p>  Intinya adalah bagaimana systemd menentukan kapan suatu perangkat dapat dibuka kuncinya.  Yaitu, ia mengambil perangkat dari kolom ketiga dan menunggu unit perangkat yang sesuai untuk menjadi aktif.  Tampaknya logis: tidak masuk akal untuk mencoba membuka kunci wadah LUKS sampai perangkat dengan file kunci muncul.  Tetapi unit perangkat tidak sama dengan perangkat itu sendiri.  Systemd secara default membuat unit perangkat hanya untuk perangkat kernel yang terkait dengan subsistem perangkat blok dan antarmuka jaringan.  Perangkat <code>/dev/mem</code> dan <code>/dev/mtd0</code> adalah karakter per karakter, oleh karena itu mereka tidak dipantau secara default dan tidak akan pernah diakui sebagai siap. </p><br><p>  Kita harus memberi tahu systemd bahwa ia harus melacaknya dengan membuat aturan udev di file <code>/etc/udev/rules.d/99-mem.rules</code> : </p><br><pre> <code class="plaintext hljs"># /dev/mem KERNEL=="mem", TAG+="systemd" # /dev/mtd* KERNEL=="mtd*", TAG+="systemd" #  /dev/pmem*      </code> </pre> <br><h3 id="shag-pyatyy-peregenerirovat-initramfs">  Langkah Kelima: Regenerasi initramfs </h3><br><blockquote>  Saya mengingatkan Anda: artikel ini hanya membahas distribusi menggunakan Dracut.  Termasuk yang tidak digunakan secara default, tetapi dapat diakses dan efisien. </blockquote><p>  Anda perlu membuat ulang initramfs untuk memperbarui file <code>/etc/crypttab</code> sana.  Dan juga - untuk memasukkan modul kernel tambahan dan aturan udev di sana.  Jika tidak, perangkat <code>/dev/mtd0</code> atau <code>/dev/pmem0</code> tidak akan dibuat.  Parameter konfigurasi <code>force_drivers</code> Dracut bertanggung jawab untuk mengaktifkan dan memuat modul kernel tambahan, dan <code>install_items</code> bertanggung jawab untuk file tambahan.  Kami membuat file <code>/etc/dracut.conf.d/mem.conf</code> dengan konten berikut (spasi setelah tanda kutip pembuka diperlukan, ini adalah pemisah): </p><br><pre> <code class="plaintext hljs">#   /dev/mem: install_items+=" /etc/udev/rules.d/99-mem.rules" #   phram: install_items+=" /etc/udev/rules.d/99-mem.rules" force_drivers+=" phram" #   nd_e820: force_drivers+=" nd_e820 nd_pmem"</code> </pre> <br><p>  Sebenarnya initramf regenerasi: </p><br><pre> <code class="plaintext hljs"># dracut -f</code> </pre> <br><blockquote>  Untuk pengguna Debian dan Ubuntu, pengelola membuat rake: file yang dihasilkan disebut salah.  Anda perlu mengganti nama sehingga namanya sama seperti yang ditentukan dalam konfigurasi GRUB: <br><pre> <code class="plaintext hljs"># mv /boot/initramfs-5.0.0-19-generic.img /boot/initrd.img-5.0.0-19-generic</code> </pre> <br><br>  Saat memasang kernel baru, pembuatan initramf otomatis melalui Dracut dilakukan dengan benar, bug hanya mempengaruhi peluncuran manual <code>dracut -f</code> . </blockquote><br><h3 id="shag-shestoy-perezagruzit-kompyuter">  Langkah Enam: Nyalakan Ulang Komputer Anda </h3><br><p>  Diperlukan reboot untuk perubahan pada konfigurasi GRUB dan Dracut agar dapat berlaku. </p><br><pre> <code class="plaintext hljs"># reboot</code> </pre> <br><p>  Pada tahap ini, tidak ada kunci dalam memori, jadi Anda harus memasukkan kata sandi. </p><br><p>  Setelah mem-boot ulang, Anda perlu memeriksa apakah cadangan memori berfungsi dengan benar.  Minimal, dalam file <code>/proc/iomem</code> pseudo <code>/proc/iomem</code> memori yang diperlukan harus ditandai sebagai "dicadangkan" (saat menggunakan <code>/dev/mem</code> atau <code>phram</code> ) atau sebagai "Memori Persisten (warisan)". </p><br><p>  Saat menggunakan <code>phram</code> atau <code>nd_e820</code> Anda perlu memastikan bahwa perangkat <code>/dev/mtd0</code> atau <code>/dev/pmem0</code> benar-benar merujuk pada bagian memori yang sebelumnya dipesan, dan bukan ke hal lain. </p><br><pre> <code class="plaintext hljs"># cat /sys/class/mtd/mtd0/name #  : "savedkey" # cat /sys/block/pmem0/device/resource #    </code> </pre> <br><p>  Jika ini bukan masalahnya, Anda perlu menemukan mana dari perangkat <code>/dev/mtd*</code> atau <code>/dev/pmem*</code> "milik kita", dan kemudian perbaiki / etc / crypttab, buat kembali initramfs dan periksa kembali hasilnya setelah reboot lagi. </p><br><h3 id="shag-sedmoy-nastroit-kopirovanie-klyuchevogo-fayla-v-pamyat">  Langkah ketujuh: konfigurasikan menyalin file kunci ke memori </h3><br><p>  File kunci akan disalin ke memori sebelum reboot.  Salah satu cara untuk menjalankan perintah apa pun pada tahap shutdown sistem adalah dengan mendaftarkannya di direktif <code>ExecStop</code> dalam layanan systemd.  Agar systemd memahami bahwa ini bukan daemon dan tidak bersumpah pada kurangnya arahan <code>ExecStart</code> , Anda perlu menentukan jenis layanan sebagai <code>oneshot</code> dan juga menyarankan bahwa layanan ini dianggap berjalan, bahkan jika tidak ada proses kerja yang terkait dengannya.  Jadi, inilah file <code>/etc/systemd/system/savekey.service</code> .  Penting untuk meninggalkan hanya satu dari varian yang diberikan dari arahan <code>ExecStop</code> . </p><br><pre> <code class="plaintext hljs">[Unit] Description=Saving LUKS key into RAM Documentation=https://habr.com/ru/post/457396/ [Service] Type=oneshot RemainAfterExit=true #   /dev/mem: ExecStop=/bin/sh -c 'dd if=/root/key of=/dev/mem bs=1 seek=$((0x10000000))' #   /dev/mtd0: ExecStop=/bin/dd if=/root/key of=/dev/mtd0 #   /dev/pmem0: ExecStop=/bin/dd if=/root/key of=/dev/pmem0 [Install] WantedBy=default.target</code> </pre> <br><p>  Konstruksi dengan <code>/bin/sh</code> diperlukan karena <code>dd</code> tidak mengerti notasi heksadesimal. </p><br><p>  Kami mengaktifkan layanan, periksa: </p><br><pre> <code class="plaintext hljs"># systemctl enable savekey # systemctl start savekey # reboot</code> </pre> <br><p>  Selama reboot berikutnya, Anda tidak harus memasukkan frasa sandi dari disk.  Dan jika perlu, ini biasanya berarti bahwa alamat awal area memori yang dipesan dipilih secara tidak benar.  Tidak apa-apa untuk memperbaiki dan membuat ulang beberapa file dan me-restart komputer dua kali. </p><br><p>  Saat menggunakan <code>phram</code> atau <code>nd_e820</code> hanya konfigurasi GRUB yang harus diedit.  Saat menggunakan <code>/dev/mem</code> alamat awal juga disebutkan di <code>/etc/crypttab</code> (oleh karena itu, initramfs harus dibuat ulang) dan di layanan systemd. </p><br><p>  Tapi itu belum semuanya. </p><br><h3 id="voprosy-bezopasnosti">  Masalah keamanan </h3><br><p>  Setiap diskusi tentang masalah keamanan didasarkan pada model ancaman.  Yaitu  pada tujuan dan sarana penyerang.  Saya sadar bahwa beberapa contoh di bawah ini tidak masuk akal. </p><br><p>  Situasi dengan akses fisik ke komputer yang dimatikan tidak berbeda dari yang tanpa penyimpanan kunci yang dikonfigurasi dalam memori.  Ada jenis serangan yang sama yang bertujuan untuk mendapatkan frasa kunci, termasuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Evil Maid</a> , dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fitur keamanan yang</a> sama.  Kami tidak berhenti pada mereka, karena tidak ada yang baru. </p><br><p>  Situasi yang lebih menarik adalah ketika komputer dihidupkan. </p><br><p>  <strong>Situasi 1</strong> .  Penyerang tidak memiliki akses fisik ke komputer, tidak tahu frasa sandi, tetapi memiliki akses root melalui ssh.  Tujuannya adalah kunci untuk mendekripsi disk.  Misalnya, untuk mengakses cadangan sektor per sektor lama dari citra disk mesin virtual. </p><br><p>  Sebenarnya, kunci pada piring ada di file <code>/root/key</code> .  Pertanyaannya adalah bagaimana ini berhubungan dengan apa yang terjadi sebelum pelaksanaan instruksi ini.  Jawab: untuk luks1, ancamannya bukan hal baru.  Ada <code>dmsetup table --target crypt --showkeys</code> yang menunjukkan kunci master, yaitu  juga data yang memungkinkan akses ke cadangan lama.  Untuk luks2, penurunan keamanan dalam skenario ini benar-benar terjadi: kunci dm-crypt disimpan di gantungan kunci di tingkat kernel, dan tidak mungkin untuk melihatnya dari userspace. </p><br><p>  <strong>Situasi 2</strong> .  Penyerang dapat menggunakan keyboard dan melihat layar, tetapi tidak siap untuk membuka kasing.  Misalnya, saya menggunakan kata sandi yang bocor dari IPMI atau mencegat sesi noVNC di cloud.  Dia tidak tahu frasa kunci, dia juga tidak tahu kata sandi lain.  Tujuannya adalah akses root. </p><br><p>  Tolong: reboot melalui <code>Ctrl-Alt-Del</code> , menambahkan opsi kernel <code>init=/bin/sh</code> melalui GRUB selesai.  Frasa sandi tidak diperlukan, karena kunci berhasil dibaca dari memori.  Untuk melindungi diri dari ini, Anda harus mencegah GRUB memuat apa yang tidak ada pada menu.  Sayangnya, fungsi ini diterapkan secara berbeda dalam distribusi yang berbeda. </p><br><p>  Dimulai dengan versi 7.2, CentOS memiliki perintah <code>grub2-setpassword</code> , yang sebenarnya melindungi GRUB dengan kata sandi.  Distribusi lain mungkin memiliki utilitas sendiri untuk tugas yang sama.  Jika tidak, maka Anda dapat langsung mengedit file di direktori <code>/etc/grub.d</code> dan membuat ulang <code>grub.cfg</code> . </p><br><p>  Dalam file <code>/etc/grub.d/10_linux</code> , ubah variabel CLASS, tambahkan opsi <code>--unrestricted</code> hingga akhir, jika tidak ada di sana: </p><br><pre> <code class="plaintext hljs">CLASS="--class gnu-linux --class gnu --class os --unrestricted"</code> </pre> <br><p>  Dalam file <code>/etc/grub.d/40_custom</code> tambahkan baris yang menentukan nama pengguna dan kata sandi yang diperlukan untuk mengedit baris perintah kernel: </p><br><pre> <code class="plaintext hljs">set superusers="root" password_pbkdf2 root grub.pbkdf2....... #    grub2-mkpasswd-pbkdf2</code> </pre> <br><p>  Atau, jika fungsi seperti itu perlu dinonaktifkan sama sekali, berikut ini adalah baris seperti ini: </p><br><pre> <code class="plaintext hljs">set superusers=""</code> </pre> <br><p>  <strong>Situasi 3</strong> .  Penyerang memiliki akses ke komputer yang disertakan, memungkinkan Anda untuk boot dari media yang tidak terpercaya.  Ini bisa berupa akses fisik tanpa membuka kasing atau akses melalui IPMI.  Tujuannya adalah akses root. </p><br><p>  Ia dapat memuat GRUB-nya dari USB flash drive atau CD-ROM dan menambahkan <code>init=/bin/sh</code> ke parameter kernel Anda, seperti pada contoh sebelumnya.  Karenanya, boot dari media mengerikan apa pun harus dilarang di BIOS.  Dan juga melindungi perubahan pengaturan BIOS dengan kata sandi. </p><br><p>  <strong>Situasi 4</strong> .  Penyerang memiliki akses fisik ke komputer yang disertakan, termasuk kemampuan untuk membuka kasing.  Tujuannya adalah untuk mengetahui kunci atau mendapatkan akses root. </p><br><p>  Secara umum, ini adalah situasi yang kalah.  Serangan pada modul memori dengan mendinginkannya ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Serangan boot dingin</a> ) belum dibatalkan.  Secara teoritis (tidak memeriksa), Anda dapat memanfaatkan fakta bahwa disk SATA modern mendukung koneksi ulang panas.  Ketika Anda me-restart komputer, lepaskan disk, ubah <code>grub.cfg</code> untuk <code>init=/bin/sh</code> , hubungkan kembali, biarkan sistem reboot.  Ternyata (jika saya mengerti benar) akses root. </p><br><p>  Tentang hal yang sama dapat dilakukan oleh karyawan yang tidak bertanggung jawab dari cloud hosting dengan membuat snapshot dari mesin virtual dengan modifikasi selanjutnya. </p><br><h3 id="prochie-voprosy">  Masalah lainnya </h3><br><p>  <strong>Menyimpan kunci dalam memori selama reboot adalah sebuah olok-olok.</strong>  <strong>Gunakan-setelah-bebas dalam bentuknya yang paling murni.</strong>  <strong>Solusi yang lebih bersih adalah menggunakan kexec dan menambahkan kunci ke initramf yang dihasilkan secara dinamis.</strong>  <strong>Ini juga melindungi dari mengganti parameter kernel</strong> .  Ya, benar, jika kexec berfungsi.  Distribusi modern membuat konfigurasi kexec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terlalu rumit</a> . </p><br><p>  <strong>Di pusat data, dan terlebih lagi di cloud, daya tidak pernah hilang.</strong>  <strong>Ternyata frasa kunci tidak lagi diperlukan?</strong>  Memang, <em>jika</em> Anda yakin akan hal ini, Anda dapat menghapusnya.  Ini akan berubah menjadi server yang berfungsi, kunci ke disk yang tidak diketahui siapa pun dan karena itu tidak akan memberikan, tetapi sistem yang dapat diperbarui menggunakan cara biasa.    —        <code>sudo poweroff</code> . </p><br><p> ¹    <code>/root/key</code> —         ,        cron. </p><br><p> <strong>   ?  IPMI,       </strong> .    IPMI      Java.        . </p><br><p> <strong>   ?     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> SSH</a></strong> . !    .  ,      <code>sudo reboot</code> ,      ? </p><br><p>             ,         .     SSH       ,      .       ,      ,   . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id457396/">https://habr.com/ru/post/id457396/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id457380/index.html">OpenGL Ultramodern. Bagian 2</a></li>
<li><a href="../id457382/index.html">7 kebiasaan programmer berkinerja tinggi</a></li>
<li><a href="../id457386/index.html">Memperkenalkan Linux Virtual Interfaces: Tunnels</a></li>
<li><a href="../id457390/index.html">Madagaskar - pulau kontras</a></li>
<li><a href="../id457392/index.html">Penghematan pada Pengembangan Lintas-Platform Seluler: Studi Kasus Skyeng</a></li>
<li><a href="../id457398/index.html">Tetapi apakah saya melakukan omong kosong? Mengapa pengembang pergi ke gemba</a></li>
<li><a href="../id457400/index.html">Jumlah korban dalam bencana nuklir seperti Chernobyl sangat dibesar-besarkan untuk drama</a></li>
<li><a href="../id457402/index.html">Bagaimana mengatur pengembangan dan dukungan sebuah blog di WordPress pada 2Q19 dan tidak memperbaikinya</a></li>
<li><a href="../id457404/index.html">Berita dari dunia OpenStreetMap No. 465 (06/11/2019 - 06/16/2019)</a></li>
<li><a href="../id457406/index.html">Berapa penghasilan lulusan berbagai universitas Rusia</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>