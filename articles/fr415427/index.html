<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤š ğŸ— ğŸ¡ Toute la vÃ©ritÃ© sur RTOS de Colin Walls. Article # 4. TÃ¢ches, changement de contexte et interruptions ğŸ‘¨ğŸ¿â€ğŸš’ ğŸ§“ğŸ¾ ğŸ’”</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Identificateurs de tÃ¢che 
 Vous devez Ãªtre en mesure d'identifier chaque tÃ¢che du systÃ¨me. Cette exigence est importante pour les autres objets du noy...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Toute la vÃ©ritÃ© sur RTOS de Colin Walls. Article # 4. TÃ¢ches, changement de contexte et interruptions</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/415427/"><h3>  Identificateurs de tÃ¢che </h3><br>  Vous devez Ãªtre en mesure d'identifier chaque tÃ¢che du systÃ¨me.  Cette exigence est importante pour les autres objets du noyau, mais il y a quelques nuances dans les tÃ¢ches qui correspondent au sujet de cet article. <br><br><img src="https://habrastorage.org/webt/6z/dy/vz/6zdyvzfbp4usza-socgerc4y5se.jpeg"><br><br>  Les dÃ©veloppeurs de RTOS utilisent diffÃ©rentes approches pour identifier les tÃ¢ches, mais quatre stratÃ©gies gÃ©nÃ©rales peuvent Ãªtre distinguÃ©es: <br><br><ul><li> La tÃ¢che est identifiÃ©e Ã  l'aide d'un pointeur sur son Â«bloc de contrÃ´leÂ».  Les pointeurs sont toujours uniques et Ã©galement pratiques Ã  utiliser, car l'accÃ¨s Ã  l'unitÃ© de contrÃ´le est requis pour de nombreux appels API.  Cela implique que toutes les donnÃ©es de tÃ¢che sont stockÃ©es dans la mÃ©moire vive (RAM), ce qui peut Ãªtre inefficace.  Un pointeur prend gÃ©nÃ©ralement environ 32 bits de mÃ©moire. </li><li>  Une tÃ¢che peut Ãªtre dÃ©finie Ã  l'aide d'un "numÃ©ro d'index" arbitraire.  Cette valeur peut Ãªtre utile lors de l'octroi de l'accÃ¨s aux enregistrements de certaines tables.  Un tel identifiant peut occuper huit bits de mÃ©moire ou moins, en fonction des limitations du nombre de tÃ¢ches prises en charge par le RTOS. </li><li>  Certains RTOS n'autorisent qu'une seule tÃ¢che par niveau de prioritÃ© et utilisent donc la prioritÃ© pour identifier de maniÃ¨re unique une tÃ¢che.  Cela signifie que la prioritÃ© de la tÃ¢che ne peut pas Ãªtre modifiÃ©e.  Cette approche est une variante de l'approche prÃ©cÃ©dente. </li><li>  Les tÃ¢ches peuvent avoir des noms qui sont des chaÃ®nes de caractÃ¨res.  Cela peut Ãªtre utile pour le dÃ©bogage, mais il est peu probable qu'il soit un moyen efficace d'identifier de maniÃ¨re unique une tÃ¢che.  Les RTOS qui prennent en charge la dÃ©nomination des tÃ¢ches ont gÃ©nÃ©ralement un identifiant supplÃ©mentaire (tel qu'un pointeur) utilisÃ© par les appels d'API, etc. Pour la plupart des systÃ¨mes intÃ©grÃ©s, les noms de texte sont en surcharge;  un bon dÃ©bogueur vous permet de les appeler localement sur l'hÃ´te. </li></ul><a name="habracut"></a><br>  Articles prÃ©cÃ©dents de la sÃ©rie: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TÃ¢ches et planification</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RTOS: Structure et mode temps rÃ©el</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Article # 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RTOS: introduction.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><br></a> <br><h3>  <b>Changement de contexte</b> </h3><br>  La commutation de contexte est le processus de transfert de contrÃ´le d'une tÃ¢che Ã  une autre.  Ce sujet mÃ©rite d'Ãªtre approfondi, car le fonctionnement du changement de contexte est un principe fondamental du RTOS. <br><br><h3>  <b>Qu'est-ce qu'une tÃ¢che?</b> </h3><br>  Nous savons qu'une tÃ¢che est un programme quasi indÃ©pendant qui partage le temps processeur avec un certain nombre d'autres tÃ¢ches sous le contrÃ´le de RTOS.  Mais vous devez penser Ã  ce qui caractÃ©rise vraiment la tÃ¢che. <br><br><h3>  <b>Ensemble de registres</b> </h3><br>  Une tÃ¢che est finalement un ensemble unique de valeurs de registre de processeur.  Ils sont soit chargÃ©s dans les registres du processeur (c'est-Ã -dire que la tÃ¢che est en cours), soit stockÃ©s quelque part jusqu'Ã  l'heure d'exÃ©cution planifiÃ©e.  Dans un monde idÃ©al, un processeur central aurait plusieurs ensembles de registres et chacun pourrait Ãªtre affectÃ© Ã  une tÃ¢che distincte.  Cela a Ã©tÃ© mis en Å“uvre pour des occasions spÃ©ciales.  Il y a de nombreuses annÃ©es, la sÃ©rie Texas Instruments TI 9900 avait de nombreux jeux de registres pour chaque tÃ¢che, mais ils Ã©taient implÃ©mentÃ©s dans la mÃ©moire principale, ce qui limitait les performances.  L'architecture SPARC (prÃ©cÃ©demment utilisÃ©e sur les systÃ¨mes de bureau Unix) prend en charge de nombreux ensembles de registres dans la Â«structure en anneauÂ», mais le nombre d'ensembles est toujours limitÃ©. <br><br><h3>  <b>DonnÃ©es internes</b> </h3><br>  La tÃ¢che aura probablement sa propre pile, dont la taille peut Ãªtre dÃ©finie sÃ©parÃ©ment pour chaque tÃ¢che ou peut Ãªtre un paramÃ¨tre global pour toutes les tÃ¢ches du systÃ¨me.  Ceci, avec les registres, fournit un stockage de donnÃ©es pour des tÃ¢ches spÃ©cifiques.  Il peut y avoir d'autres zones de mÃ©moire pour stocker des donnÃ©es pour une tÃ¢che spÃ©cifique. <br><br><h3>  <b>Ressources partagÃ©es</b> </h3><br>  Pratiquement toutes les ressources peuvent Ãªtre partagÃ©es entre les tÃ¢ches.  Le code peut Ãªtre gÃ©nÃ©ral: soit certaines fonctions, soit l'intÃ©gralitÃ© du code de tÃ¢che.  Il est nÃ©cessaire de s'assurer que le code est rÃ©entrant, tout d'abord, les variables statiques ne doivent pas Ãªtre utilisÃ©es (spÃ©cifiÃ©es comme statiques ou juste en dehors de la fonction).  Soyez prudent avec les modules de bibliothÃ¨que standard qui ne sont pas destinÃ©s Ã  une utilisation intÃ©grÃ©e;  ils ont gÃ©nÃ©ralement beaucoup de fonctions peu fiables. <br><br>  Le partage de donnÃ©es est Ã©galement possible, mais un contrÃ´le d'accÃ¨s minutieux est nÃ©cessaire.  IdÃ©alement, une seule tÃ¢che est le Â«propriÃ©taireÂ» des donnÃ©es Ã  un moment donnÃ©. <br><br><h3>  <b>Comment garder le contexte</b> </h3><br>  Lorsqu'une tÃ¢che est replanifiÃ©e (c'est-Ã -dire qu'elle cesse d'Ãªtre actuelle), son ensemble de registres doit Ãªtre enregistrÃ© quelque part.  Il y a au moins deux possibilitÃ©s: <br><br><ul><li>  Les registres peuvent Ãªtre stockÃ©s dans une table spÃ©ciale pour les tÃ¢ches.  Peut faire partie d'un bloc de contrÃ´le des tÃ¢ches (TCB).  La taille est une valeur prÃ©visible et constante (pour une architecture CPU spÃ©cifique). </li><li>  Les registres peuvent Ãªtre insÃ©rÃ©s dans la pile des tÃ¢ches.  Cela nÃ©cessite l'allocation d'un espace de pile supplÃ©mentaire suffisant et le stockage du pointeur (Ã©ventuellement dans le TCB). </li></ul><br>  Le choix du mÃ©canisme dÃ©pend des caractÃ©ristiques d'un RTOS particulier et du processeur cible.  Certains pÃ©riphÃ©riques (gÃ©nÃ©ralement 32 bits) peuvent accÃ©der efficacement Ã  la pile;  le reste (par exemple, 8 bits) peut Ãªtre plus optimal lorsque vous travaillez avec des tables. <br><br><h3>  <b>CrÃ©ation de tÃ¢che dynamique</b> </h3><br>  L'aspect principal de l'architecture RTOS est que le RTOS est soit Â«statiqueÂ» soit Â«dynamiqueÂ». <br><br>  Lors de l'utilisation d'un RTOS statique, tout est dÃ©terminÃ© lors de la construction de l'application, notamment le nombre de tÃ¢ches dans le systÃ¨me.  Il s'agit d'une solution logique pour les applications intÃ©grÃ©es, qui ont gÃ©nÃ©ralement des fonctionnalitÃ©s limitÃ©es. <br><br>  Dynamic RTOS lance une tÃ¢che (qui peut Ãªtre une tÃ¢che Â«principaleÂ» spÃ©cialisÃ©e) et crÃ©e et supprime Ã©galement d'autres tÃ¢ches selon les besoins.  Cela permet au systÃ¨me de s'adapter aux exigences changeantes et est un analogue plus proche du systÃ¨me de bureau, qui se comporte de cette faÃ§on.  La vue statique / dynamique s'applique Ã©galement aux autres objets du noyau. <br><br><h3>  <b>Exigence de crÃ©ation de tÃ¢che dynamique</b> </h3><br>  Cette fonctionnalitÃ© est incluse dans la plupart des RTOS commerciaux.  Cependant, seule une petite partie des applications a vraiment besoin d'un mode de fonctionnement dynamique.  TrÃ¨s souvent, le systÃ¨me dÃ©marre, crÃ©e toutes les tÃ¢ches nÃ©cessaires (et autres objets), puis ne crÃ©e et ne dÃ©truit plus le code d'application.  La possibilitÃ© de crÃ©er des tÃ¢ches dynamiques est devenue une formalitÃ©.  Un fournisseur l'a prÃ©sentÃ©, tous les autres ont emboÃ®tÃ© le pas. <br><br>  Il est Ã  noter que la norme OSEK / VDX nÃ©cessite une architecture statique, mÃªme si cela peut s'appliquer Ã  des applications assez complexes.  Le rÃ©sultat de ces exigences est l'impossibilitÃ© d'implÃ©menter OSEK / VDX avec un wrapper, une couche intermÃ©diaire au-dessus d'un RTOS rÃ©gulier (dynamique). <br><br><h3>  <b>PiÃ¨ges de la crÃ©ation de tÃ¢ches dynamiques</b> </h3><br>  Il y a plusieurs problÃ¨mes avec le mode de fonctionnement dynamique qui peuvent Ãªtre troublants. <br><br>  PremiÃ¨rement, le systÃ¨me devient plus complexe, ce qui signifie que pour les structures de donnÃ©es dÃ©crivant les tÃ¢ches (TCB), des informations supplÃ©mentaires sont nÃ©cessaires.  En rÃ¨gle gÃ©nÃ©rale, ils sont mis en Å“uvre sous la forme de listes bidirectionnelles, ce qui entraÃ®ne des coÃ»ts associÃ©s Ã  la quantitÃ© de mÃ©moire. <br>  Toutes les donnÃ©es dÃ©crivant la tÃ¢che doivent Ãªtre stockÃ©es dans la RAM.  Ceci est inefficace, car la plupart d'entre eux peuvent simplement Ãªtre des Ã©lÃ©ments de donnÃ©es persistants copiÃ©s Ã  partir de la ROM.  De plus, sur les processeurs d'un niveau infÃ©rieur (microcontrÃ´leurs), il peut ne pas obtenir de RAM. <br><br>  Le plus inquiÃ©tant est probablement la possibilitÃ© d'une pÃ©nurie imprÃ©visible de ressources, qui peut conduire Ã  l'incapacitÃ© de crÃ©er de nouveaux objets.  Ã‰tant donnÃ© que l'essence d'un systÃ¨me en temps rÃ©el est sa prÃ©visibilitÃ©, cela est inacceptable.  Par consÃ©quent, il faut Ãªtre prudent lors de l'utilisation de la crÃ©ation de tÃ¢ches dynamiques (et d'autres objets). <br><br><h3>  <b>Interruptions</b> </h3><br>  Il est possible qu'un systÃ¨me embarquÃ© en temps rÃ©el puisse Ãªtre implÃ©mentÃ© sans utiliser d'interruptions, mais ce n'est pas typique. <br><br><h3>  <b>Interruptions et noyau</b> </h3><br>  Lorsque vous utilisez RTOS, un gestionnaire d'interruption (ISR) est rendu aussi facile que possible pour Â«volerÂ» le temps minimum du processeur des tÃ¢ches planifiÃ©es.  Souvent, un pÃ©riphÃ©rique peut simplement Ãªtre rÃ©parÃ© et toute tÃ¢che requise sera mise en file d'attente pour le traitement.  De plus, il est difficile de parler de maniÃ¨re gÃ©nÃ©rale des interruptions et de leur interaction avec les noyaux, simplement parce qu'elles varient considÃ©rablement.  D'une part, le dÃ©veloppeur RTOS peut s'assurer que les interruptions ne se rapportent pas du tout au noyau, et le programmeur devra s'assurer que le planificateur de tÃ¢ches n'est pas surchargÃ©, en utilisant beaucoup de temps processeur dans l'ISR.  D'un autre cÃ´tÃ©, le RTOS peut contrÃ´ler entiÃ¨rement l'ensemble du sous-systÃ¨me d'interruption.  Aucune des approches dÃ©crites n'est bonne ou mauvaise, elles sont juste diffÃ©rentes. <br><br><h3>  <b>Enregistrement du contexte</b> </h3><br>  Les ISR doivent toujours maintenir un Â«contexteÂ» afin que le code interruptible ne soit pas affectÃ© par les calculs ISR.  Dans un systÃ¨me implÃ©mentÃ© sans RTOS, il s'agit simplement de sauvegarder les registres utilisÃ©s par l'ISR (gÃ©nÃ©ralement sur la pile) et de les restaurer avant de revenir.  Certains processeurs ont une pile ISR dÃ©diÃ©e, tandis que d'autres utilisent simplement la mÃªme pile que le code d'application. <br><br>  Lorsque vous utilisez RTOS, l'approche peut Ãªtre exactement la mÃªme.  De la mÃªme maniÃ¨re, la pile utilisÃ©e par l'ISR peut Ãªtre Â«empruntÃ©eÂ» Ã  la tÃ¢che en cours, ou il peut s'agir d'une autre pile allouÃ©e pour les interruptions.  Certains cÅ“urs implÃ©mentent cette fonctionnalitÃ©, mÃªme si le processeur lui-mÃªme ne prend pas en charge la pile d'interruptions.  La situation est compliquÃ©e si l'ISR effectue un appel d'API qui affecte le planificateur de tÃ¢ches.  Cela peut entraÃ®ner l'interruption de revenir Ã  une autre tÃ¢che Ã  partir de celle qui a Ã©tÃ© dÃ©marrÃ©e lorsque l'interruption s'est produite. <br><br><h3>  <b>Interruptions et planificateur</b> </h3><br>  Il existe plusieurs circonstances dans lesquelles le code d'exÃ©cution ISR peut revenir Ã  une autre tÃ¢che: <br><br><ul><li>  ISR peut attribuer une prioritÃ© plus Ã©levÃ©e Ã  une tÃ¢che dÃ©jÃ  terminÃ©e, plutÃ´t qu'Ã  la tÃ¢che actuelle, si le planificateur de tÃ¢ches prioritaires est utilisÃ©. </li><li>  ISR peut suspendre la tÃ¢che en cours. </li><li>  En utilisant le Time-Slice Scheduler (TS), le gestionnaire d'interruption du temporisateur systÃ¨me contrÃ´lera les intervalles de temps et pourra appeler le planificateur si nÃ©cessaire. </li></ul><br><h3>  <b>Minuterie d'horloge (Tick Clock)</b> </h3><br>  Dans les systÃ¨mes embarquÃ©s, l'utilisation d'une Â«horlogeÂ» pÃ©riodique (tranche de temps) est souvent trouvÃ©e.  Dans certains RTOS, c'est un composant requis.  En rÃ¨gle gÃ©nÃ©rale, la prÃ©sence d'une horloge est facultative et son absence empÃªche simplement la disponibilitÃ© de certains services.  Le gestionnaire d'interruption du minuteur fournit gÃ©nÃ©ralement quatre fonctionnalitÃ©s: <br><br><ul><li>  Si un planificateur d'intervalles de temps est utilisÃ©, le gestionnaire d'interruption de la minuterie contrÃ´lera le compteur de temps et planifiera une nouvelle tÃ¢che chaque fois que le temps sera Ã©coulÃ©. </li><li>  Fournit une prise en charge du temps systÃ¨me.  Il s'agit principalement d'une variable 32 bits qui est incrÃ©mentÃ©e par une minuterie et peut Ãªtre prÃ©dÃ©finie ou demandÃ©e par des tÃ¢ches. </li><li>  Si le RTOS fournit des applications avec des temporisateurs, il sera pris en charge par un gestionnaire d'interruption de temporisateur qui sera responsable de l'expiration et de la reprogrammation. </li><li>  Si le RTOS prend en charge les dÃ©lais d'expiration pour bloquer les appels d'API ou que les tÃ¢ches peuvent Ãªtre en veille, ces intervalles de temps seront pris en charge par le gestionnaire d'interruption du minuteur. </li></ul><br>  <i>Lorsque nous avons travaillÃ© sur notre propre systÃ¨me d'exploitation OSRV MAX en temps rÃ©el (articles dÃ©jÃ  publiÃ©s Ã  ce sujet), notre Ã©quipe a Â«dÃ©couvertÂ» le blog de Colin Walls, un expert en microÃ©lectronique et firmware de Mentor Graphics.</i>  <i>Les articles semblaient intÃ©ressants, les traduisaient eux-mÃªmes, mais afin de ne pas "Ã©crire sur la table", ils ont dÃ©cidÃ© de publier.</i>  <i>J'espÃ¨re qu'ils vous seront Ã©galement utiles.</i>  <i>Si c'est le cas, nous prÃ©voyons de publier tous les articles traduits de la sÃ©rie.</i> <i><br><br></i>  <i>Ã€ propos de l'auteur: Colin Walls travaille dans l'industrie Ã©lectronique depuis plus de trente ans, consacrant la majeure partie de son temps au micrologiciel.</i>  <i>Il est maintenant ingÃ©nieur firmware chez Mentor Embedded (une division de Mentor Graphics).</i>  <i>Colin Walls intervient souvent lors de confÃ©rences et sÃ©minaires, auteur de nombreux articles techniques et de deux livres sur le firmware.</i>  <i>Vit au Royaume-Uni.</i>  <i>Blog professionnel de Colin: blogs.mentor.com/colinwalls, e-mail: colin_walls@mentor.com</i> <i><br></i> <br>  Lisez les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">premier, deuxiÃ¨me</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">troisiÃ¨me</a> articles de la sÃ©rie publiÃ©e prÃ©cÃ©demment. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr415427/">https://habr.com/ru/post/fr415427/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr415413/index.html">FonctionnalitÃ© croisÃ©e, gestionnaire de dÃ©pendances, surveillance dans les tests iOS et UI. Comment Ã©tait l'Ã©dition Avito iOS Summer Edition</a></li>
<li><a href="../fr415415/index.html">Annonce d'une confÃ©rence de hackathon sur le dÃ©veloppement de jeux sur la blockchain GameNode</a></li>
<li><a href="../fr415417/index.html">Courte critique du smartphone ASUS ZenFone Max Pro (M1) ZB602KL</a></li>
<li><a href="../fr415421/index.html">Nous vous invitons Ã  Gravity Co-working Space pour le dernier tournoi d'embauche de la saison</a></li>
<li><a href="../fr415423/index.html">Infrastructure Ã  clÃ© publique: autoritÃ© de certification basÃ©e sur OpenSSL et SQLite3 Utility (Postcryptum)</a></li>
<li><a href="../fr415429/index.html">Toute la vÃ©ritÃ© sur RTOS de Colin Walls. Article # 5. Interaction et synchronisation des tÃ¢ches</a></li>
<li><a href="../fr415431/index.html">Annonce du hackathon SmartMail Hack 2: Appel de donnÃ©es</a></li>
<li><a href="../fr415433/index.html">GÃ©rer les communiquÃ©s sur le logement SIG et les services communaux - nous partageons notre expÃ©rience et combattons avec intuition</a></li>
<li><a href="../fr415435/index.html">DÃ©veloppement de cartes d'interface sur Soil Xilinx Zynq 7000 pour l'enregistrement vocal au format analogique et numÃ©rique</a></li>
<li><a href="../fr415437/index.html">Comment rouler ML en prod: six rÃ¢teaux sur lesquels nous avons marchÃ©</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>