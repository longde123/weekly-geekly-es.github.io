<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🤝‍👨🏾 👩‍👧 📠 Kami mempelajari janji berdasarkan spesifikasi Ecmascript. Kenalan 🤱🏻 🕟 🍘</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo Mempelajari JavaScript (dan, pada prinsipnya, teknologi lainnya), berbagai pertanyaan selalu muncul, yang utamanya adalah: "Mengapa ia bekerja se...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kami mempelajari janji berdasarkan spesifikasi Ecmascript. Kenalan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/478938/"><img src="https://habrastorage.org/webt/zo/be/at/zobeat0bkvnvgpgaxgkufwtm3li.png" alt="janji pengantar"><br><br><p>  Halo  Mempelajari JavaScript (dan, pada prinsipnya, teknologi lainnya), berbagai pertanyaan selalu muncul, yang utamanya adalah: "Mengapa ia bekerja seperti ini dan bukan sebaliknya?" Dan sangat penting saat ini tidak hanya untuk menemukan jawaban atas pertanyaan, tetapi juga penjelasan yang diterima menanamkan dalam satu sistem pengetahuan yang sudah diperoleh.  Kalau tidak, informasi yatim harus dihafalkan atau dilupakan. <br></p><br><p>  Mempelajari sesuatu bersama sangat membantu untuk menemukan jawaban.  Ketika seorang siswa / rekan bertanya pertanyaan tentang bagaimana memahami ungkapan - "... hasil dari yang sebelumnya" gagal "dalam janji berikutnya dalam rantai ..." yang tanpa sadar berpikir ... Ini adalah hal yang aneh.  Tapi Anda tidak bisa mengatakan lebih baik lagi, apakah itu benar-benar tidak jelas?  Anda melihat mata pendamping yang bersih, agak naif dan mengerti - Anda perlu mengatakan sesuatu yang lain.  Diinginkan sehingga Anda bahkan tidak perlu menghafal.  Untuk informasi baru secara organik sesuai dengan pemikiran manusia yang ada. <br></p><br><p>  Saya tidak akan menjelaskan apa yang kami coba, baca, tonton.  Sebagai hasilnya, kami menjadi tertarik pada spesifikasi ECMAScript.  Cara membaca dan memahaminya adalah percakapan terpisah (bahkan mungkin posting terpisah).  Tetapi cara janji dan perilaku mereka dijelaskan di sana, untuk pertama kalinya memberi kami pemahaman yang holistik dan logis secara koheren tentang topik ini.  Apa yang ingin saya bagikan dengan Anda. <br></p><a name="habracut"></a><br><p>  Artikel ini untuk pemula.  Janji-janji dalam hal spesifikasi naskah ECMAS akan dibahas di sini.  Aku tahu kedengarannya aneh, tetapi apa adanya. <br></p><br><h2>  Obyek yang dijanjikan: filosofi, presentasi teknis, kemungkinan kondisi <br></h2><br><p>  Saya telah memperhatikan lebih dari sekali bahwa pelatihan pemrograman berkualitas tinggi harus terdiri dari 2 bagian.  Ini adalah pemahaman filosofis dari ide tersebut, dan baru kemudian implementasi teknisnya.  Artinya, logika manusia biasa, yang dibimbing siswa ketika membuat keputusan, sangat memudahkan pemahaman tentang implementasi teknis dari keputusan ini.  Karena itu, kita mulai dengan apa janji itu dalam hidup, dan bagaimana kita menghubungkannya dengan itu?  Dan kemudian kita akan melihat: bagaimana contoh janji akan diimplementasikan dalam kode.  Pertimbangkan gambar-gambar berikut (Gbr. 1, 2, 3). <br></p><br><img src="https://habrastorage.org/webt/np/8l/ux/np8luxrdlenwq4o2lzikaludrlw.png" alt="Janji negara"><br>  <i>Gambar 1. ([[PromiseState]] - sebagai hasil dari janji)</i> <br><br><img src="https://habrastorage.org/webt/sj/xi/bq/sjxibq_vroug72q8bkdprh4rxik.png" alt="Hasil Janji"><br>  <i>gbr 2. ([[PromiseResult]] - sebagai informasi yang terkait dengan hasil dari janji yang terpenuhi atau tidak terpenuhi)</i> <br><br><img src="https://habrastorage.org/webt/2e/zj/l_/2ezjl_fhehmml3yhfqjijcnerbw.png" alt="Reaksi janji"><br>  <i>Gambar 3. ([[[Janji Janji]], [[Janji Janji]] - sebagai konsekuensi yang terjadi setelah memenuhi atau tidak memenuhi janji)</i> <br><br><p>  Kita melihat bahwa konsep janji berdiri di atas 3 pilar.  1) Apakah janji itu terpenuhi sama sekali?  2) Informasi tambahan apa yang dapat kita ekstrak setelah memenuhi atau menolak janji?  3) Apa akibatnya jika janji kita positif atau negatif? <br></p><br><p>  Secara teknis, janji adalah entitas biasa yang diekspresikan melalui tipe data seperti objek.  Entitas ini memiliki nama / kelas Janji.  Objek yang lahir dari kelas ini memiliki Promise.prototype dalam rantai prototipe mereka.  Dan entitas ini entah bagaimana harus terhubung dengan semua "informasi dari kehidupan" yang kami periksa di atas.  Spesifikasi ECMAScript memberikan informasi ini dalam janji bahkan pada tingkat yang lebih rendah dalam abstraksi daripada JavaScript itu sendiri.  Misalnya, di level C ++.  Dengan demikian, dalam objek janji ada tempat baik di bawah status, dan di bawah hasilnya, dan di bawah konsekuensi dari janji.  Lihatlah apa isi janji <a href="https://www.ecma-international.org/ecma-262/7.0/">ECMAScript</a> (Gambar 4). <br></p><br><img src="https://habrastorage.org/webt/bj/m5/lh/bjm5lhtxstjywkkfe6jnjqaqaes.png" alt="Bidang janji"><br>  <i>Gambar 4. (Bidang internal objek janji sesuai dengan spesifikasi skrip ECMAS)</i> <br><br><p>  Warna baru apa yang dimainkan oleh ungkapan “janji tidak berarti menikah” dalam pengertian seorang programmer?  1) [[PromiseState]].  Seseorang belum menikah.  2) [[PromiseResult]].  Karena dia tidak punya cukup uang untuk pernikahan.  3) [[PromiseRejectReactions]].  Akibatnya, ia memiliki banyak waktu luang yang ia habiskan untuk pengembangan diri 4) [[PromiseFulfillReactions]].  Mengapa seseorang membutuhkan rencana B ketika ia telah memilih rencana A? <br></p><br><p>  Ya, ada bidang kelima [[PromiseIsHandled]].  Itu tidak terlalu penting bagi kita semua, dan kita tidak akan lagi mengoperasikannya di masa depan.  Singkatnya: ada sinyal yang disimpan kepada penerjemah tentang apakah janji itu ditolak oleh programmer atau tidak.  Jika tidak, tolak janji mentah ditafsirkan oleh mesin JS sebagai kesalahan.  Untuk yang tidak sabar: jika programmer tidak menggantungkan fungsi Promise.prototype.then () sebagai pemanggil-fungsi-penangan kedua dari status yang ditolak dari janji, maka status objek yang “ditolak” dari objek akan menunjukkan kepada Anda kesalahan merah di konsol pengembang. <br></p><br><p>  Pernahkah Anda memperhatikan bahwa bidang objek janji terlampir dalam "[[" dan "]]"?  Ini menekankan bahwa programmer JS tidak memiliki akses langsung ke informasi ini.  Hanya melalui alat / perintah / API khusus, seperti perintah Promise.prototype.then ().  Jika Anda memiliki keinginan yang tak tertahankan untuk mengendalikan "dapur ini" secara langsung, selamat datang di klub standar spesifikasi EcmaScript. <br></p><br><p>  Sebuah komentar singkat di akhir sub-bab ini.  Jika dalam hidup di negara kita janji sebagian dapat dipenuhi, maka dalam EcmaScript - tidak.  Artinya, jika seseorang berjanji untuk memberi satu juta, dan memberi 950 ribu, maka dalam hidup, mungkin dia adalah mitra yang dapat diandalkan, tetapi untuk JavaScript debitur seperti itu akan masuk daftar hitam melalui [[PromiseState]] === "ditolak".  Objek Janji mengubah negaranya dengan jelas dan hanya sekali.  Bagaimana ini diterapkan secara teknis sedikit kemudian. <br></p><br><h2>  Promise Designer, filosofinya.  Pelaksana fungsi callback seperti "pelaksana" janji.  Skema interaksi: Janji (konstruktor) - pelaksana (panggilan balik) - janji (objek) </h2><br><p>  Jadi, kami menemukan bahwa janji adalah entitas yang secara teknis adalah objek JS dengan bidang internal tersembunyi khusus, yang pada gilirannya memberikan pengisian filosofis dengan makna kata "janji". <br></p><br><p>  Ketika seorang pemula membuat objek janji untuk pertama kalinya, gambar berikut menunggunya (Gbr. 5). <br></p><br><img src="https://habrastorage.org/webt/m1/xg/3u/m1xg3uoxgytd1nd2x7pc_z9i93m.png" alt="salah menciptakan objek janji"><br>  <i>Gambar 5. (Pertama kali kami secara intuitif membuat objek janji)</i> <br><br><p>  Apa yang salah dan mengapa kesalahan adalah pertanyaan standar.  Dalam menjawabnya, lebih baik untuk membawa analogi dari kehidupan lagi.  Misalnya, beberapa orang menyukai "lonceng kosong" di sekitar kita: yang hanya berjanji, tetapi tidak melakukan apa pun untuk memenuhi pernyataan mereka (politik tidak masuk hitungan).  Kami jauh lebih baik pada orang-orang yang, setelah janji mereka, punya rencana dan segera mengambil tindakan untuk mencapai hasil yang dijanjikan. <br></p><br><p>  Jadi filosofi ECMAScript menyiratkan bahwa jika Anda membuat janji, maka segera tunjukkan bagaimana Anda akan memenuhinya.  Programmer perlu menyusun rencana tindakannya dalam bentuk parameter fungsi, yang Anda berikan kepada konstruktor Janji.  Eksperimen selanjutnya terlihat seperti ini (Gbr. 6). <br></p><br><img src="https://habrastorage.org/webt/xh/sk/h7/xhskh7cuzrn1jxavomenlnfzwu0.png" alt="Konstruktor janji menggunakan pelaksana"><br>  <i>Gambar 6. (Membuat objek janji, meneruskan fungsi eksekutor ke konstruktor Janji)</i> <br><br><p>  Dari keterangan ke gambar, kita melihat bahwa fungsi (parameter konstruktor Janji) memiliki nama sendiri - pelaksana.  Tugasnya adalah untuk mulai memenuhi janji dan, lebih baik, membawanya ke semacam kesimpulan logis.  Dan jika pemrogram dapat menulis kode apa pun di pelaksana, lalu bagaimana pemrogram dapat memberi sinyal kepada JS bahwa semuanya - pekerjaan sudah selesai - dapatkah Anda melihat hasil dari janji tersebut? <br></p><br><p>  Marker atau sinyal yang membantu programmer untuk menginformasikan bahwa janji telah selesai diteruskan secara otomatis ke pelaksana-parameter dalam bentuk argumen yang khusus dibentuk oleh JavaScript.  Parameter ini dapat dipanggil sesuka Anda, tetapi paling sering Anda akan menamainya dengan nama seperti res dan rej.  Dalam spesifikasi skrip ECMAS, nama lengkapnya adalah fungsi penyelesaian dan fungsi tolak.  Penanda fungsi ini memiliki karakteristiknya sendiri, yang akan kita bahas nanti. <br></p><br><p>  Untuk memahami informasi baru, pendatang baru diundang untuk secara mandiri menyandikan pernyataan berikut: "Saya berjanji bahwa saya dapat membagi satu nomor menjadi yang lain dan memberikan jawaban, jika saja pembagi itu tidak nol."  Begini tampilannya kode (gbr. 7). <br></p><br><img src="https://habrastorage.org/webt/uu/to/gj/uutogjuluy9r5xxvwo2hrrwnaaq.png" alt="janji tugas: pembagian dengan nol"><br>  <i>Gambar 7. (Solusi masalah membagi 2 angka melalui janji)</i> <br><br><p>  Sekarang Anda dapat menganalisis hasilnya.  Kami melihat bahwa untuk kedua kalinya konsol browser menunjukkan objek Promis dengan cara yang menarik.  Yaitu: 2 bidang tambahan ditunjukkan dalam tanda kurung ganda.  Anda dapat dengan aman menggambar analogi antara [[PromiseState]] dan [[PromiseStatus]], terpenuhi dan diselesaikan, [[PromiseValue]] dan [[PromiseResult]].  Ya, browser itu sendiri mencoba memberi tahu programmer tentang keberadaan dan nilai bidang internal objek janji.  Kita juga melihat sistem yang terhubung dari objek janji, fungsi pelaksana, fungsi khusus-callback-token dan res. <br></p><br><p>  Agar siswa / pasangan menjadi lebih santai dalam materi ini, ia ditawari kode berikut (Gbr. 8).  Penting untuk menganalisis dan menjawab pertanyaan-pertanyaan berikut. <br></p><br><img src="https://habrastorage.org/webt/zs/md/vv/zsmdvv05gwmpi-vyq5a-d5sorjq.png" alt="janji tugas: pembagian dengan nol. Versi alternatif"><br>  <i>Gambar 8. (Variasi solusi untuk masalah membagi 2 angka melalui janji)</i> <br><br><p>  Akankah kodenya bekerja?  Di mana fungsi eksekutor di sini dan apa namanya?  Apakah nama "wantToDivide" sesuai dalam kode ini?  Apa fungsi ikat kembali setelah itu sendiri?  Mengapa argumen diteruskan ke fungsi bind hanya di tempat kedua dan ketiga?  Di mana fungsi khusus menyelesaikan fungsi dan menolak fungsi menghilang?  Bagaimana cara memasukkan nomor urut nomor 1 dan nomor 2 ke dalam “rencana pemenuhan janji”?  Berapa banyak elemen dalam argumen pseudo-array?  Apakah mungkin untuk memulihkan dari memori seperti apa jawabannya pada konsol browser? <br></p><br><p>  Pembaca diajak berpikir tentang jawaban atas pertanyaan itu sendiri.  Juga <br>  bereksperimen dalam kode.  Untungnya, kodenya kecil dan gagasan tugasnya sederhana.  Ya, ada pertanyaan tentang janji dan pengetahuan umum tentang JavaScript.  Apa yang harus dilakukan, di mana pun kami menunggu kejutan yang mencegah kami bersantai.  Segera setelah semuanya menjadi jelas bagi Anda, Anda dapat melanjutkan. <br></p><br><div class="spoiler">  <b class="spoiler_title">Lihat / salin kode</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> number1 = <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(prompt(<span class="hljs-string"><span class="hljs-string">"input number 1"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> number2 = <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(prompt(<span class="hljs-string"><span class="hljs-string">"input number 2"</span></span>)); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> wantToDivide = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>] === <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[<span class="hljs-number"><span class="hljs-number">3</span></span>](<span class="hljs-string"><span class="hljs-string">"it is forbidden to divide by zero"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> result = <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[<span class="hljs-number"><span class="hljs-number">0</span></span>] / <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">arguments</span></span>[<span class="hljs-number"><span class="hljs-number">2</span></span>](result); }; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> myPromise = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(wantToDivide.bind(<span class="hljs-literal"><span class="hljs-literal">null</span></span>, number1, number2)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myPromise);</code> </pre> <br></div></div><br><h2>  Pertimbangkan argumen eksekutor-a: selesaikan dan tolak fungsi <br></h2><br><p>  Jadi, kami minum kopi - kami melanjutkan.  Mari kita pertimbangkan lebih detail fungsi khusus fungsi penyelesaian dan fungsi tolak, yang secara otomatis dihasilkan oleh JavaScript untuk menerjemahkan janji objek ke keadaan terpenuhi atau ditolak, yang melambangkan akhir dari janji. <br></p><br><p>  Sebagai permulaan, mari kita coba melihatnya hanya di konsol pengembang (Gbr. 9). <br></p><br><img src="https://habrastorage.org/webt/rz/ox/vj/rzoxvjvsvmt3962toiukmqtf9ye.png" alt="fungsi tekad penelitian"><br>  <i>Gambar 9. (Menjelajahi fungsi fungsi penyelesaian - res)</i> <br><br><p>  Kita melihat bahwa fungsi resolusinya adalah fungsi yang mengambil satu argumen (panjang properti === 1).  Dan prototipe-nya adalah Function.prototype. <br></p><br><p>  Ok, mari kita lanjutkan eksperimen.  Dan apa yang akan terjadi jika kita menghapus tautan ke fungsi tekad / tolak dari pelaksana ke lingkup eksternal?  Akankah sesuatu pecah (gbr. 10)? <br></p><br><img src="https://habrastorage.org/webt/9z/2i/cf/9z2icfrmkwiwfeeerdphezhtjay.png" alt="eksternal contol objek janji"><br>  <i>Gambar 10. (Kami menerjemahkan janji myPromise ke status terpenuhi di luar janji)</i> <br><br><p>  Tidak ada yang luar biasa.  Fungsi sebagai subspesies objek dalam JavaScript dilewatkan dengan referensi.  Semuanya berjalan sesuai harapan kami.  Variabel dari penutupan outerRes mendapat referensi ke fungsi penyelesaian resolusi kami.  Dan kami menggunakan fungsinya untuk menempatkan janji dalam kondisi terpenuhi di luar pelaksana itu sendiri.  Contoh yang sedikit dimodifikasi berikut ini menunjukkan ide yang sama, jadi lihatlah kodenya dan pikirkan dalam kondisi apa dan dengan nilai apa myPromise1 dan myPromise2 nantinya (Gbr. 11).  Kemudian Anda dapat memeriksa asumsi Anda di bawah spoiler. </p><br><img src="https://habrastorage.org/webt/re/gf/ov/regfovwn9xc5-jwlkftz0ed8vgc.png" alt="janji tugas. Pertanyaan">  <i>Gambar 11. (Tugas refleksi. Dalam kondisi apa dan dengan nilai apa janji-janji myPromise1 dan myPromise2 ada di konsol pengembang?)</i> <br><br><div class="spoiler">  <b class="spoiler_title">Jawaban untuk masalah pada Gambar 11 (Gambar 12).</b> <div class="spoiler_text"><img src="https://habrastorage.org/webt/iy/3x/k-/iy3xk-yuomgcgev4ddftqcffnvm.png" alt="janji tugas. Jawab"><br>  <i>Gambar 12. (Jawaban untuk masalah pada Gambar 11)</i> <br></div></div><br><p>  Dan sekarang Anda dapat memikirkan satu pertanyaan menarik.  Tetapi bagaimana fungsi tekad / tolak selalu tahu persis janji mana yang harus diterjemahkan ke dalam kondisi yang disyaratkan?  Kita beralih ke <a href="https://www.ecma-international.org/ecma-262/7.0/">algoritma dalam spesifikasi</a> , yang menjelaskan bagaimana fungsi-fungsi ini dibuat (Gbr. 13). <br></p><br><img src="https://habrastorage.org/webt/4n/gq/k-/4ngqk-fikg8ddjo6uhe00_rhkci.png" alt="membuat fungsi penyelesaian"><br>  <i>Gambar 13. (Fitur membuat fungsi penyelesaian untuk satu objek janji tertentu)</i> <br><br><p>  Poin-poin penting untuk diperhatikan: <br></p><br><ul><li>  pada saat pembuatan fungsi resol / menolak, mereka secara kaku melekat pada satu-satunya objek janji yang sesuai dengannya <br></li><li>  fungsi resol / menolak sebagai tipe data objek memiliki bidang tersembunyi mereka sendiri [[Janji]] dan [[Sudah Diselesaikan]], yang memberikan semua orang dengan logika intuitif yang akrab yang a) - menyelesaikan fungsi sendiri menerjemahkan objek janji ke dalam kondisi yang diperlukan;  dan fakta bahwa b) suatu janji tidak dapat ditransfer ke negara bagian lain jika setidaknya sekali fungsi putuskan atau tolak dipanggil.  Algoritma ini dapat diwakili oleh gambar berikut (Gbr. 14). <br><br><img src="https://habrastorage.org/webt/0p/wt/1d/0pwt1dmqxhzhq0uuat_zljihrhc.png" alt="menyelesaikan fungsi dan menjanjikan objek"><br>  <i>Gambar 14. (Bidang fungsi tersembunyi fungsi tekad dan fungsi tolak)</i> <br><br><p>  Algoritma yang menggunakan informasi ini dari bidang tersembunyi tidak akan dipertimbangkan sekarang, karena mereka bertele-tele dan lebih kompleks.  Kita masih perlu mempersiapkan mereka secara teori dan moral.  Untuk saat ini, saya hanya bisa mengkonfirmasi pemikiran Anda: “Wow, betapa sederhananya itu ternyata.  Mungkin, pada setiap resolusi / resolusi janji objek, bendera "objek" {[[Nilai]]: false} akan diperiksa.  Dan jika itu benar, kami menghentikan proses menerjemahkan janji ke negara lain dengan pengembalian sederhana. "  Ya - itulah tepatnya yang terjadi.  Tampaknya Anda dapat menjawab pertanyaan berikut dengan benar tanpa masalah.  Apa yang akan terjadi pada konsol pengembang (Gbr. 15)? <br></p><br><img src="https://habrastorage.org/webt/p6/1l/co/p61lcoillhsvjme0-hotfyacsoi.png" alt="expertiment dengan menghubungkan fungsi penyelesaian dan objek janji"><br>  <i>Gambar 15. (Eksperimen yang menunjukkan hubungan antara fungsi resol dan menolak dengan satu objek janji tertentu)</i> <br><br><h2>  Algoritma untuk membuat objek janji sesuai dengan spesifikasi skrip ECMAS </h2><br><p>  Pertimbangkan saat menyihir ketika ia dilahirkan ke dunia - <a href="https://www.ecma-international.org/ecma-262/7.0/">objek janji</a> penuh (Gbr. 16). <br></p><br><img src="https://habrastorage.org/webt/xm/yu/09/xmyu0944vrpk4ykurzgunwst0ji.png" alt="janji penciptaan di ecmascript"><br>  <i>Gambar 16. (Algoritma untuk membuat objek janji dari spesifikasi EcmaScript)</i> <br><br><p>  Seharusnya tidak ada pertanyaan rumit yang muncul saat melihatnya: </p><p></p><ul><li>  Konstruktor janji harus dipanggil dalam mode konstruktor, dan bukan hanya pemanggilan fungsi <br></li><li>  Janji konstruktor membutuhkan fungsi pelaksana <br></li><li>  buat objek JavaScript dengan bidang tersembunyi tertentu <br></li><li>  inisialisasi bidang tersembunyi dengan beberapa nilai awal <br></li><li>  buat tekad dan tolak fungsi yang terkait dengan objek janji <br></li><li>  kami memanggil fungsi eksekutor untuk dieksekusi, lewat di sana sudah dihasilkan fungsi token token dan tolak fungsi sebagai argumen <br></li><li>  jika selama eksekusi eksekutor - ada yang tidak beres, letakkan objek janji kita di negara yang ditolak <br></li><li>  kembali ke variabel objek janji janji lahir. <br></li></ul><br><p>  Saya tidak tahu apakah ini merupakan penemuan untuk Anda bahwa algoritma pelaksana fungsi dijalankan di sini dan sekarang, dalam mode sinkron normal, bahkan sebelum sesuatu ditulis ke variabel di sebelah kiri konstruktor Janji.  Tetapi pada waktunya bagi saya itu menjadi wahyu. <br></p><br><p>  Karena kami telah menyinggung topik sinkronisasi dan asinkron, berikut adalah kode berikut untuk Anda “pikirkan” atau untuk eksperimen.  Pertanyaan: Setelah melihat beberapa kreasi programmer Dima, dapatkah Anda menjawab apa arti game yang disandikan di bawah ini? <br></p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randomInteger</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">min, max</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.floor(min + <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random() * (max + <span class="hljs-number"><span class="hljs-number">1</span></span> - min)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">game</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> guessCubeNumber = <span class="hljs-built_in"><span class="hljs-built_in">Number</span></span>(prompt(<span class="hljs-string"><span class="hljs-string">"Throw dice? Guess number?"</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">"throwing dice ... wait until it stop"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gameState = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res, rej</span></span></span><span class="hljs-function">) </span></span>{ setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gottenNumberDice = randomInteger(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>); gottenNumberDice === guessCubeNumber ? res(<span class="hljs-string"><span class="hljs-string">"you win!"</span></span>) : rej(<span class="hljs-string"><span class="hljs-string">`you loose. </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${gottenNumberDice}</span></span></span><span class="hljs-string"> points dropped on dice`</span></span>); }, <span class="hljs-number"><span class="hljs-number">3000</span></span>); }); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> gameState; } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(game());</code> </pre><br><p>  Tentu saja, ini adalah emulasi dari roll mati.  Bisakah pengguna menebak nomor yang terjatuh atau tidak?  Lihat bagaimana setTimeout terintegrasi secara asinkron secara organik ke dalam eksekutor sinkron - dalam rencana kami, putar dadu dan temukan nomor yang terjatuh.  Bagaimana seseorang dapat menginterpretasikan hasil di konsol pengembang dengan cara khusus (Gbr. 17)? <br></p><br><p>  Jika kita mencoba melihat janji sampai kubus berhenti (3000 ms ditunjukkan dalam kode), kita akan melihat bahwa janji itu masih dalam keadaan menunggu: permainan belum selesai, kubus belum berhenti, tidak ada nomor yang keluar.  Jika kita mencoba melihat objek janji setelah kubus berhenti, kita akan melihat informasi yang sangat spesifik: apakah pengguna menang (menebak nomornya), atau kalah dan mengapa (nomor berapa yang benar-benar jatuh). <br></p><br><img src="https://habrastorage.org/webt/g4/oi/ba/g4oibarzyfjcrnzbvdqs9nqddqm.png" alt="game janji - melempar dadu"><br>  <i>Gambar 17. (Status janji suatu objek ketika ada operasi asinkron dalam fungsi eksekutor)</i> <br><br><p>  Jika Anda tertarik pada contoh ini, atau jika Anda ingin menebak jumlah kubus terbalik, Anda dapat menyalin kode dan melakukan percobaan.  Berani! <br></p><br><h2>  Reaksi janji sebagai konsekuensi dari janji yang terpenuhi </h2><br><p>  Seperti yang Anda lihat pada Gambar 14, konsekuensi dari penyelesaian / penyelesaian janji suatu objek ditandatangani sebagai "+ reaksi" dan "-reaksi".  Istilah resmi untuk kata-kata ini dari spesifikasi ECMAScript adalah reaksi yang menjanjikan.  Diasumsikan bahwa dalam artikel berikut topik ini akan dipertimbangkan secara rinci.  Untuk saat ini, kami membatasi diri pada gagasan umum tentang apa itu reaksi janji, sehingga istilah ini dapat dikaitkan dengan benar dengan makna filosofis dari kata ini dan pelaksanaan teknisnya. <br></p><br><p>  Seperti yang kita ingat, sebuah janji mungkin memiliki konsekuensi, tetapi mungkin tidak.  Apa konsekuensinya?  Ini adalah tindakan yang akan terjadi beberapa waktu kemudian: setelah janji dipenuhi.  Dan karena ini adalah tindakan, konsekuensinya dapat diekspresikan oleh fungsi JavaScript normal.  Beberapa fungsi akan dieksekusi jika berhasil menyelesaikan janji (+ reaksi);  fungsi lain - dalam kasus ketika janji masuk ke negara yang ditolak (-reaksi).  Secara teknis, fungsi-fungsi ini (konsekuensi) diteruskan dalam argumen ketika metode Promise.prototype.then () dipanggil. <br></p><br><p>  Dengan demikian, bagian penting dari reaksi janji adalah tindakan asinkron yang dilakukan di masa depan.  Ada komponen penting kedua dari reaksi janji - ini adalah janji yang baru dibuat yang dikembalikan setelah perintah Promise.prototype.then () dieksekusi.  Ini karena konsekuensinya mempengaruhi janji-janji lain.  Misalnya, ada janji untuk membeli mobil, tetapi hanya setelah janji untuk mendapatkan sejumlah uang terpenuhi.  Satu janji terpenuhi - konsekuensinya berhasil - sekarang yang kedua dapat dipenuhi. <br></p><br><p>  Bahkan, reaksi janji mengikat janji satu sama lain dalam interval waktu tertentu.  Penting untuk diingat bahwa reaksi diproses secara otomatis.  Panggilan fungsi - konsekuensi dari penyelesaian janji - dibuat oleh mesin JS, bukan programmer (Gbr. 18).  Dan, karena reaksi itu berkaitan erat dengan objek janji (janji) itu sendiri, logis untuk mengasumsikan bahwa algoritma reaksi janji menggunakan bidang internal mereka dalam logika mereka.  Dan lebih baik untuk mengetahui tentang semua nuansa ini agar dapat mengendalikan logika asinkron secara sadar berdasarkan janji. <br></p><br><img src="https://habrastorage.org/webt/zc/tk/ja/zctkjapwx_daq-shustmj4yc5fo.png" alt="reaksi janji dalam metode ()"><br>  <i>Gambar 18. (Konsekuensi penyelesaian janji dicatat oleh fungsi callback dalam metode then (). Callback akan dipanggil secara asinkron secara otomatis oleh mesin JS)</i> <br><br><h2>  Untuk meringkas </h2><br><p>  1) Kami berkenalan dengan janji-janji dalam JavaScript, filosofi dan eksekusi teknis mereka.  Semua ini diimplementasikan menggunakan bidang janji internal khusus objek: [[PromiseState]], [[PromiseValue]], [[PromiseFulFillReactions]], [[PromiseRejectReactions]]. <br></p><br><p>  2) Programmer diberi kesempatan untuk memenuhi janjinya melalui fungsi pelaksana, disahkan sebagai argumen kepada konstruktor Janji. <br></p><br><p>  3) Batas-batas janji terpenuhi atau tidak terpenuhi ditentukan oleh fungsi penanda khusus, fungsi penyelesaian dan fungsi penolakan, sering kali dalam kode yang disebut res dan rej.  Fungsi-fungsi ini secara otomatis dibuat oleh JavaScript dan diteruskan dalam argumen ke pelaksana. <br></p><br><p>  4) fungsi penyelesaian dan fungsi penolakan selalu memiliki objek janji yang terkait dengannya, serta bidang khusus umum {[[Nilai]]: false}, yang memastikan bahwa janji tersebut diselesaikan hanya satu kali. <br></p><br><p>  5) [[PromiseFulFillReactions]] dan [[PromiseRejectReactions]] adalah bidang internal objek janji yang menyimpan konsekuensi penyelesaian janji, bagian penting yang merupakan fungsi asinkron khusus yang ditentukan melalui metode objek janji Promise.protot.then (). <br></p><br><h2>  PS </h2><br><p>  Artikel ini disiapkan sebagai abstrak dari sesi video grup InSimpleWords.  Ada "pelajaran video" yang cukup dan masih ada bahan untuk membuat catatan.  Pertanyaan lain adalah apakah akan menarik bagi anggota masyarakat untuk membaca artikel apa tentang janji secara berturut-turut.  Menunggu komentar Anda. <br></p><p></p><p></p></li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id478938/">https://habr.com/ru/post/id478938/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id478926/index.html">.NET Core 3.1 dirilis</a></li>
<li><a href="../id478928/index.html">Python atau bukan Python</a></li>
<li><a href="../id478930/index.html">Cara menggunakan MySQL tanpa kata sandi (dan risiko keamanan)</a></li>
<li><a href="../id478932/index.html">Docker untuk front-end. Bagian 1. Mengapa?</a></li>
<li><a href="../id478934/index.html">Modul library standar Python yang paling berguna yang selalu dilupakan setiap orang</a></li>
<li><a href="../id478942/index.html">Eksperimen porno yang hebat: sejarah Internet untuk orang dewasa</a></li>
<li><a href="../id478948/index.html">Cari kerentanan di Samsung TrustZone, atau AFL fuzz all</a></li>
<li><a href="../id478950/index.html">Hasil minggu ini: Huawei beradaptasi dengan sanksi, Putin menandatangani undang-undang yang sensasional, dan ShutterStock diblokir di Rusia</a></li>
<li><a href="../id478952/index.html">Sebulan dengan Onyx Boox Note Pro</a></li>
<li><a href="../id478954/index.html">RE: Ketakutan dan Kebencian pada IT</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>