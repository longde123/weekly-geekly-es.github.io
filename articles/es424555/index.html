<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª ü•ó ü§∂üèΩ Manual de Node.js, Parte 7: Programaci√≥n asincr√≥nica üì≥ üîù üßíüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoy, en la traducci√≥n de la s√©ptima parte del manual de Node.js, hablaremos sobre la programaci√≥n asincr√≥nica, consideraremos cuestiones como el uso d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Manual de Node.js, Parte 7: Programaci√≥n asincr√≥nica</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/424555/">  Hoy, en la traducci√≥n de la s√©ptima parte del manual de Node.js, hablaremos sobre la programaci√≥n asincr√≥nica, consideraremos cuestiones como el uso de devoluciones de llamada, promesas y la construcci√≥n as√≠ncrona / espera, y discutiremos c√≥mo trabajar con eventos. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/he/di/2j/hedi2j_qyfbnwfo_jqnnqd3ub6o.png"></a> <br><br><div class="spoiler">  <b class="spoiler_title">[Le aconsejamos que lea] Otras partes del ciclo</b> <div class="spoiler_text">  Parte 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Informaci√≥n general y primeros pasos</a> <br>  Parte 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JavaScript, V8, algunos trucos de desarrollo</a> <br>  Parte 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hosting, REPL, trabajar con la consola, m√≥dulos</a> <br>  Parte 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">archivos npm, package.json y package-lock.json</a> <br>  Parte 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">npm y npx</a> <br>  Parte 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bucle de eventos, pila de llamadas, temporizadores</a> <br>  Parte 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Programaci√≥n asincr√≥nica</a> <br>  Parte 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gu√≠a de Node.js, Parte 8: Protocolos HTTP y WebSocket</a> <br>  Parte 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gu√≠a de Node.js, parte 9: trabajar con el sistema de archivos</a> <br>  Parte 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Gu√≠a de Node.js, Parte 10: M√≥dulos est√°ndar, flujos, bases de datos, NODE_ENV</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PDF completo de la gu√≠a Node.js</a> <br></div></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Asincron√≠a en lenguajes de programaci√≥n.</font> </h2><br>  JavaScript en s√≠ es un lenguaje de programaci√≥n s√≠ncrono de un solo subproceso.  Esto significa que no puede crear nuevos subprocesos en el c√≥digo que se ejecutan en paralelo.  Sin embargo, las computadoras son inherentemente as√≠ncronas.  Es decir, ciertas acciones se pueden realizar independientemente del flujo principal de ejecuci√≥n del programa.  En las computadoras modernas, a cada programa se le asigna una cierta cantidad de tiempo de procesador, cuando este tiempo se agota, el sistema le da recursos a otro programa, tambi√©n por un tiempo.  Tales cambios se realizan c√≠clicamente, se hace tan r√°pido que una persona simplemente no puede notarlo, como resultado, creemos que nuestras computadoras ejecutan muchos programas simult√°neamente.  Pero esto es una ilusi√≥n (sin mencionar las m√°quinas multiprocesador). <br><br>  En las entra√±as de los programas se utilizan interrupciones: se√±ales transmitidas al procesador y que permiten atraer la atenci√≥n del sistema.  No entraremos en detalles, lo m√°s importante es recordar que el comportamiento as√≠ncrono, cuando el programa est√° en pausa hasta el momento en que necesita recursos del procesador, es completamente normal.  En un momento en que el programa no carga el sistema con trabajo, la computadora puede resolver otros problemas.  Por ejemplo, con este enfoque, cuando un programa espera una respuesta a una solicitud de red que se le hace, no bloquea el procesador hasta que se recibe una respuesta. <br><br>  Como regla general, los lenguajes de programaci√≥n son as√≠ncronos, algunos de ellos le dan al programador la capacidad de controlar mecanismos as√≠ncronos, utilizando las herramientas de lenguaje incorporadas o las bibliotecas especializadas.  Estamos hablando de lenguajes como C, Java, C #, PHP, Go, Ruby, Swift, Python.  Algunos de ellos le permiten programar en estilo asincr√≥nico, utilizando hilos, comenzando nuevos procesos. <br><br><h2>  <font color="#3AC1EF">Asincron√≠a JavaScript</font> </h2><br>  Como ya se mencion√≥, JavaScript es un lenguaje s√≠ncrono de subproceso √∫nico.  Las l√≠neas de c√≥digo escritas en JS se ejecutan en el orden en que aparecen en el texto, una tras otra.  Por ejemplo, aqu√≠ hay un programa JS muy normal que demuestra este comportamiento: <br><br><pre><code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c = a * b console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(c) doSomething()</code> </pre> <br>  Pero JavaScript fue creado para su uso en navegadores.  Su tarea principal, al principio, era organizar el procesamiento de eventos relacionados con las actividades del usuario.  Por ejemplo, estos son eventos como <code>onClick</code> , <code>onMouseOver</code> , <code>onChange</code> , <code>onSubmit</code> , etc.  ¬øC√≥mo resolver estos problemas en el marco de un modelo de programaci√≥n s√≠ncrono? <br><br>  La respuesta se encuentra en el entorno en el que se ejecuta JavaScript.  A saber, el navegador le permite resolver eficazmente tales problemas, d√°ndole al programador las API apropiadas. <br><br>  En el entorno de Node.js existen herramientas para realizar operaciones de E / S sin bloqueo, como trabajar con archivos, organizar el intercambio de datos a trav√©s de una red, etc. <br><br><h2>  <font color="#3AC1EF">Devoluciones de llamada</font> </h2><br>  Si hablamos de JavaScript basado en navegador, se puede observar que es imposible saber de antemano cuando el usuario hace clic en un bot√≥n.  Para garantizar que el sistema responda a tal evento, se crea un controlador para ello. <br><br>  El controlador de eventos acepta una funci√≥n que se llamar√° cuando ocurra el evento.  Se ve as√≠: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'button'</span></span>).addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    })</code> </pre> <br>  Dichas funciones tambi√©n se denominan funciones de devoluci√≥n de llamada o devoluciones de llamada. <br><br>  Una devoluci√≥n de llamada es una funci√≥n regular que se pasa como valor a otra funci√≥n.  Solo se llamar√° cuando ocurra un evento determinado.  JavaScript implementa el concepto de funciones de primera clase.  Dichas funciones pueden asignarse a variables y pasarse a otras funciones (llamadas funciones de orden superior). <br><br>  En el desarrollo de JavaScript del lado del cliente, el enfoque se generaliza cuando todo el c√≥digo del cliente se envuelve en un escucha del evento de <code>load</code> de un objeto de <code>window</code> , que llama a la devoluci√≥n de llamada que se le pasa despu√©s de que la p√°gina est√° lista para trabajar: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'load'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     })</code> </pre> <br>  Las devoluciones de llamada se usan en todas partes, y no solo para manejar eventos DOM.  Por ejemplo, ya nos hemos encontrado con su uso en temporizadores: <br><br><pre> <code class="hljs javascript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   2  }, 2000)</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Las solicitudes XHR</a> tambi√©n usan devoluciones de llamada.  En este caso, parece asignar una funci√≥n a la propiedad correspondiente.  Se llamar√° a una funci√≥n similar cuando ocurra un evento determinado.  En el siguiente ejemplo, dicho evento es un cambio de estado de solicitud: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest() xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xhr.readyState === <span class="hljs-number"><span class="hljs-number">4</span></span>) {   xhr.status === <span class="hljs-number"><span class="hljs-number">200</span></span> ? <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(xhr.responseText) : <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(<span class="hljs-string"><span class="hljs-string">'error'</span></span>) } } xhr.open(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'https://yoursite.com'</span></span>) xhr.send()</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Manejo de errores en devoluciones de llamada</font> </h3><br>  Hablemos sobre c√≥mo manejar errores en devoluciones de llamada.  Hay una estrategia com√∫n para manejar tales errores, que tambi√©n se usa en Node.js.  Consiste en el hecho de que el primer par√°metro de cualquier funci√≥n de devoluci√≥n de llamada es un objeto de error.  Si no hay errores, se escribir√° <code>null</code> en este par√°metro.  De lo contrario, habr√° un objeto de error que contiene su descripci√≥n e informaci√≥n adicional al respecto.  As√≠ es como se ve: <br><br><pre> <code class="hljs coffeescript">fs.readFile(<span class="hljs-string"><span class="hljs-string">'/file.json'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, data)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) {   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data) })</code> </pre> <br><h3>  <font color="#3AC1EF">‚ñç Problema de devoluci√≥n de llamada</font> </h3><br>  Las devoluciones de llamada son convenientes para usar en situaciones simples.  Sin embargo, cada devoluci√≥n de llamada es un nivel adicional de anidaci√≥n de c√≥digo.  Si se utilizan varias devoluciones de llamada anidadas, esto r√°pidamente conduce a una complicaci√≥n significativa de la estructura del c√≥digo: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'load'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'button'</span></span>).addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {     items.forEach(item =&gt; {       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>,  -      })   }, <span class="hljs-number"><span class="hljs-number">2000</span></span>) }) })</code> </pre> <br>  En este ejemplo, solo se muestran 4 niveles de c√≥digo, pero en la pr√°ctica uno puede encontrar una gran cantidad de niveles, generalmente llamados el "infierno de devoluci√≥n de llamada".  Puede resolver este problema utilizando otras construcciones de lenguaje. <br><br><h2>  <font color="#3AC1EF">Promesas y as√≠ncrono / espera</font> </h2><br>  Comenzando con el est√°ndar ES6, JavaScript introduce nuevas caracter√≠sticas que facilitan la escritura de c√≥digo asincr√≥nico, eliminando la necesidad de devoluciones de llamada.  Estamos hablando de las promesas que aparecieron en ES6, y la construcci√≥n as√≠ncrona / en espera que apareci√≥ en ES8. <br><br><h3>  <font color="#3AC1EF">‚ñç Promesas</font> </h3><br>  Las promesas (objetos de promesa) son una de las formas de trabajar con construcciones de software asincr√≥nicas en JavaScript, lo que, en general, reduce el uso de devoluciones de llamada. <br><br><h4>  Conocimiento de promesas </h4><br>  Las promesas generalmente se definen como objetos proxy para ciertos valores, cuya apariencia se espera en el futuro.  Las promesas tambi√©n se llaman "promesas" o "resultados prometidos".  Aunque este concepto existe desde hace muchos a√±os, las promesas se estandarizaron y se agregaron al lenguaje solo en ES2015.  En ES2017, apareci√≥ el dise√±o as√≠ncrono / espera, que se basa en promesas y que puede considerarse como su reemplazo conveniente.  Por lo tanto, incluso si no est√° planeando usar promesas regulares, es importante comprender c√≥mo funcionan para utilizar el constructo async / wait de manera efectiva. <br><br><h4>  C√≥mo funcionan las promesas </h4><br>  Despu√©s de que se llama una promesa, pasa a un estado pendiente.  Esto significa que la funci√≥n que caus√≥ la promesa contin√∫a ejecut√°ndose, mientras que se realizan algunos c√°lculos en la promesa, despu√©s de lo cual la promesa informa al respecto.  Si la operaci√≥n realizada por la promesa se completa con √©xito, la promesa se transfiere al estado cumplido.  Dicha promesa se dice que se resuelve con √©xito.  Si la operaci√≥n se completa con un error, la promesa se coloca en el estado rechazado. <br><br>  Hablemos de trabajar con promesas. <br><br><h4>  Crea promesas </h4><br>  La API para trabajar con promesas nos proporciona el constructor correspondiente, que se llama mediante un comando de la forma <code>new Promise()</code> .  As√≠ es como se crean las promesas: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> done = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isItDoneYet = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (done) {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> workDone = <span class="hljs-string"><span class="hljs-string">'Here is the thing I built'</span></span>     resolve(workDone)   } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> why = <span class="hljs-string"><span class="hljs-string">'Still working on something else'</span></span>     reject(why)   } } )</code> </pre> <br>  Promis comprueba la constante global <code>done</code> , y si su valor es <code>true</code> , se resuelve con √©xito.  De lo contrario, la promesa es rechazada.  Usando los par√°metros <code>resolve</code> y <code>reject</code> , que son funciones, podemos devolver valores de la promesa.  En este caso, devolvemos una cadena, pero aqu√≠ se puede usar un objeto. <br><br><h4>  Trabaja con promesas </h4><br>  Creamos una promesa arriba, ahora considera trabajar con ella.  Se ve as√≠: <br><br><pre> <code class="hljs coffeescript">const isItDoneYet = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise( <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>... ) const checkIfItsDone = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { isItDoneYet   .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ok)</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(ok)   })   .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err)   }) } checkIfItsDone()</code> </pre> <br>  Llamar a <code>checkIfItsDone()</code> conducir√° a la ejecuci√≥n de la <code>isItDoneYet()</code> isItDoneYet <code>isItDoneYet()</code> y a la organizaci√≥n de esperar su resoluci√≥n.  Si la promesa se resuelve con √©xito, la devoluci√≥n de llamada pasada al m√©todo <code>.then()</code> funcionar√°.  Si se produce un error, es decir, la promesa ser√° rechazada, se puede procesar en la funci√≥n que se pasa al m√©todo <code>.catch()</code> . <br><br><h4>  Promesas encadenadas </h4><br>  Los m√©todos de promesa devuelven promesas, lo que le permite combinarlos en cadenas.  Un buen ejemplo de este comportamiento es el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">API Fetch</a> basado en navegador, que es una capa de abstracci√≥n sobre <code>XMLHttpRequest</code> .  Hay un paquete npm bastante popular para Node.js que implementa la API Fetch, que discutiremos m√°s adelante.  Esta API se puede utilizar para cargar ciertos recursos de red y, gracias a la posibilidad de combinar promesas en cadenas, organizar el procesamiento posterior de los datos descargados.  De hecho, cuando llama a la API Fetch a trav√©s de una llamada a la funci√≥n <code>fetch()</code> , se crea una promesa. <br><br>  Considere el siguiente ejemplo de encadenamiento de promesas: <br><br><pre> <code class="hljs coffeescript">const fetch = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'node-fetch'</span></span>) const status = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.status &gt;= <span class="hljs-number"><span class="hljs-number">200</span></span> &amp;&amp; response.status &lt; <span class="hljs-number"><span class="hljs-number">300</span></span>) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Promise.resolve(response) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Promise.reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(response.statusText)) } const json = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response)</span></span></span><span class="hljs-function"> =&gt;</span></span> response.json() fetch(<span class="hljs-string"><span class="hljs-string">'https://jsonplaceholder.typicode.com/todos'</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(status) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(json) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Request succeeded with JSON response'</span></span>, data) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Request failed'</span></span>, error) })</code> </pre> <br>  Aqu√≠ usamos el paquete npm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">node-fetch</a> y el recurso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">jsonplaceholder.typicode.com</a> como fuente de datos JSON. <br><br>  En este ejemplo, la funci√≥n <code>fetch()</code> se usa para cargar un elemento de lista TODO usando una cadena de promesas.  Despu√©s de ejecutar <code>fetch()</code> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se</a> devuelve una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">respuesta</a> que tiene muchas propiedades, entre las cuales estamos interesados ‚Äã‚Äãen lo siguiente: <br><br><ul><li>  <code>status</code> es un valor num√©rico que representa el c√≥digo de estado HTTP. </li><li>  <code>statusText</code> : una descripci√≥n textual del c√≥digo de estado HTTP, que se representa con la cadena <code>OK</code> si la solicitud se realiz√≥ correctamente. </li></ul><br>  El objeto de <code>response</code> tiene un m√©todo <code>json()</code> que devuelve una promesa, tras la resoluci√≥n de la cual se presenta el contenido procesado del cuerpo de la solicitud, presentado en formato JSON. <br><br>  Dado lo anterior, describimos lo que est√° sucediendo en este c√≥digo.  La primera promesa en la cadena est√° representada por la funci√≥n <code>status()</code> que anunciamos, que verifica el estado de la respuesta, y si indica que la solicitud fall√≥ (es decir, el c√≥digo de estado HTTP no est√° en el rango entre 200 y 299), la promesa se rechaza.  Esta operaci√≥n lleva al hecho de que otras expresiones <code>.then()</code> en la cadena de promesas no se ejecutan e inmediatamente llegamos al m√©todo <code>.catch()</code> , que se env√≠a a la consola, junto con el mensaje de error, el texto <code>Request failed</code> . <br><br>  Si el c√≥digo de estado HTTP nos conviene, se llama a la funci√≥n <code>json()</code> declarada por nosotros.  Dado que la promesa anterior, si se resuelve con √©xito, devuelve un objeto de <code>response</code> , lo usamos como valor de entrada para la segunda promesa. <br><br>  En este caso, devolvemos los datos JSON procesados, por lo que la tercera promesa los recibe, luego de lo cual, precedidos por un mensaje que indica que como resultado de la solicitud fue posible obtener los datos necesarios, se muestran en la consola. <br><br><h4>  Manejo de errores </h4><br>  En el ejemplo anterior, ten√≠amos un m√©todo <code>.catch()</code> adjunto a una cadena de promesas.  Si algo en la cadena de promesas sale mal y ocurre un error, o si una de las promesas resulta ser rechazada, el control se transfiere a la expresi√≥n m√°s cercana <code>.catch()</code> .  Aqu√≠ est√° la situaci√≥n cuando ocurre un error en una promesa: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br>  Aqu√≠ hay un ejemplo de activaci√≥n de <code>.catch()</code> despu√©s de rechazar una promesa: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span><span class="hljs-function"> =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br><h4>  Manejo de errores en cascada </h4><br>  ¬øQu√© sucede si se produce un error en la expresi√≥n <code>.catch()</code> ?  Para manejar este error, puede incluir otra expresi√≥n <code>.catch()</code> en la cadena de promesas (y luego puede adjuntar tantas expresiones <code>.catch()</code> a la cadena como sea necesario): <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br>  Ahora echemos un vistazo a algunos m√©todos √∫tiles utilizados para gestionar las promesas. <br><br><h4>  Promise.all () </h4><br>  Si necesita realizar alguna acci√≥n despu√©s de resolver varias promesas, puede hacerlo utilizando el <code>Promise.all()</code> .  Considere un ejemplo: <br><br><pre> <code class="hljs coffeescript">const f1 = fetch(<span class="hljs-string"><span class="hljs-string">'https://jsonplaceholder.typicode.com/todos/1'</span></span>) const f2 = fetch(<span class="hljs-string"><span class="hljs-string">'https://jsonplaceholder.typicode.com/todos/2'</span></span>) Promise.all([f1, f2]).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Array of results'</span></span>, res) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br>  En ES2015, apareci√≥ la sintaxis de la asignaci√≥n destructiva; al usarla, puede crear construcciones de la siguiente forma: <br><br><pre> <code class="hljs powershell">Promise.all([<span class="hljs-type"><span class="hljs-type">f1</span></span>, <span class="hljs-type"><span class="hljs-type">f2</span></span>]).then(([<span class="hljs-type"><span class="hljs-type">res1</span></span>, <span class="hljs-type"><span class="hljs-type">res2</span></span>]) =&gt; {   console.log(<span class="hljs-string"><span class="hljs-string">'Results'</span></span>, res1, res2) })</code> </pre> <br>  Aqu√≠, como ejemplo, consideramos el API Fetch, pero <code>Promise.all()</code> , por supuesto, le permite trabajar con cualquier promesa. <br><br><h4>  Promise.race () </h4><br>  El <code>Promise.race()</code> permite realizar la acci√≥n especificada despu√©s de que se resuelva una de las promesas que se le pasaron.  La devoluci√≥n de llamada correspondiente que contiene los resultados de esta primera promesa se llama solo una vez.  Considere un ejemplo: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> first = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {   setTimeout(resolve, <span class="hljs-number"><span class="hljs-number">500</span></span>, <span class="hljs-string"><span class="hljs-string">'first'</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> second = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {   setTimeout(resolve, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-string"><span class="hljs-string">'second'</span></span>) }) <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.race([first, second]).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result) <span class="hljs-comment"><span class="hljs-comment">// second })</span></span></code> </pre> <br><h4>  Error TypeError no detectado que se produce al trabajar con promesas </h4><br>  Si, al trabajar con promesas, encuentra el Error de tipo <code>Uncaught TypeError: undefined is not a promise</code> error de <code>Uncaught TypeError: undefined is not a promise</code> , aseg√∫rese de que se use la <code>new Promise()</code> construcci√≥n <code>new Promise()</code> lugar de solo <code>Promise()</code> al crear promesas. <br><br><h3>  <font color="#3AC1EF">‚ñç dise√±o as√≠ncrono / espera</font> </h3><br>  La construcci√≥n async / await es un enfoque moderno para la programaci√≥n asincr√≥nica, simplific√°ndola.  Las funciones asincr√≥nicas se pueden representar como una combinaci√≥n de promesas y generadores, y, en general, esta construcci√≥n es una abstracci√≥n sobre las promesas. <br><br>  El dise√±o as√≠ncrono / espera reduce la cantidad de c√≥digo repetitivo que debe escribir cuando trabaja con promesas.  Cuando aparecieron las promesas en el est√°ndar ES2015, su objetivo era resolver el problema de la creaci√≥n de c√≥digo asincr√≥nico.  Hicieron frente a esta tarea, pero en dos a√±os, compartiendo el resultado de los est√°ndares ES2015 y ES2017, qued√≥ claro que no pod√≠an considerarse la soluci√≥n final del problema. <br><br>  Uno de los problemas que las promesas resolvieron fue el famoso "infierno de devoluciones de llamada", pero ellos, resolviendo este problema, crearon sus propios problemas de naturaleza similar. <br><br>  Las promesas eran construcciones simples alrededor de las cuales uno pod√≠a construir algo con una sintaxis m√°s simple.  Como resultado, cuando lleg√≥ el momento, apareci√≥ la construcci√≥n as√≠ncrona / espera.  Su uso le permite escribir c√≥digo que parece s√≠ncrono, pero es as√≠ncrono, en particular, no bloquea el hilo principal. <br><br><h4>  C√≥mo funciona la construcci√≥n async / await </h4><br>  Una funci√≥n asincr√≥nica devuelve una promesa, como en el siguiente ejemplo: <br><br><pre> <code class="hljs coffeescript">const doSomethingAsync = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve)</span></span></span><span class="hljs-function"> =&gt;</span></span> {       setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">3000</span></span>)   }) }</code> </pre> <br>  Cuando necesite llamar a una funci√≥n similar, debe colocar la palabra clave <code>await</code> antes del comando para llamarla.  Esto har√° que el c√≥digo que lo llama espere el permiso o el rechazo de la promesa correspondiente.  Cabe se√±alar que una funci√≥n que usa la palabra clave <code>await</code> debe declararse usando la <code>async</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> doSomethingAsync()) }</code> </pre> <br>  Combine los dos fragmentos de c√≥digo anteriores y examine su comportamiento: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomethingAsync = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) =&gt;</span></span> {       setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">3000</span></span>)   }) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> doSomethingAsync()) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Before'</span></span>) doSomething() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'After'</span></span>)</code> </pre> <br>  Este c√≥digo generar√° lo siguiente: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Before</span></span> <span class="hljs-keyword"><span class="hljs-keyword">After</span></span> I did something</code> </pre> <br>  El texto <code>I did something</code> entra en la consola con un retraso de 3 segundos. <br><br><h4>  Sobre promesas y funciones asincr√≥nicas </h4><br>  Si declara una determinada funci√≥n utilizando la <code>async</code> , esto significar√° que dicha funci√≥n devolver√° una promesa incluso si no se hace expl√≠citamente.  Por eso, por ejemplo, el siguiente ejemplo es un c√≥digo de trabajo: <br><br><pre> <code class="hljs powershell">const a<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">Function</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">async</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'test'</span></span> } aFunction().then(console.log) //    <span class="hljs-string"><span class="hljs-string">'test'</span></span></code> </pre> <br>  Este dise√±o es similar a este: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> aFunction = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'test'</span></span>) } aFunction().then(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log) <span class="hljs-comment"><span class="hljs-comment">//    'test'</span></span></code> </pre> <br><h4>  Fortalezas de as√≠ncrono / espera </h4><br>  Al analizar los ejemplos anteriores, puede ver que el c√≥digo que usa async / await es m√°s simple que el c√≥digo que usa el encadenamiento de promesas o el c√≥digo basado en funciones de devoluci√≥n de llamada.  Aqu√≠, por supuesto, miramos ejemplos muy simples.  Puede experimentar plenamente los beneficios anteriores trabajando con un c√≥digo mucho m√°s complejo.  Aqu√≠, por ejemplo, se explica c√≥mo cargar y analizar datos JSON usando promesas: <br><br><pre> <code class="hljs pgsql">const getFirstUserData = () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(<span class="hljs-string"><span class="hljs-string">'/users.json'</span></span>) //      .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(response =&gt; response.json()) //  <span class="hljs-type"><span class="hljs-type">JSON</span></span>   .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(users =&gt; users[<span class="hljs-number"><span class="hljs-number">0</span></span>]) //      .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(`/users/${<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.name}`)) //       .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(userResponse =&gt; userResponse.json()) //  <span class="hljs-type"><span class="hljs-type">JSON</span></span> } getFirstUserData()</code> </pre> <br>  As√≠ es como se ve la soluci√≥n al mismo problema usando async / await: <br><br><pre> <code class="hljs pgsql">const getFirstUserData = async () =&gt; { const response = await <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(<span class="hljs-string"><span class="hljs-string">'/users.json'</span></span>) //    const users = await response.json() //  <span class="hljs-type"><span class="hljs-type">JSON</span></span> const <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = users[<span class="hljs-number"><span class="hljs-number">0</span></span>] //    const userResponse = await <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(`/users/${<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.name}`) //     const userData = await userResponse.json() //  <span class="hljs-type"><span class="hljs-type">JSON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> userData } getFirstUserData()</code> </pre> <br><h4>  Usando secuencias de funciones asincr√≥nicas </h4><br>  Las funciones asincr√≥nicas se pueden combinar f√°cilmente en dise√±os que se parecen a las cadenas de Promise.  Los resultados de tal combinaci√≥n, sin embargo, son una legibilidad mucho mejor: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promiseToDoSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> {       setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">10000</span></span>)   }) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> watchOverSomeoneDoingSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> promiseToDoSomething()   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> something + <span class="hljs-string"><span class="hljs-string">' and I watched'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> watchOverSomeoneWatchingSomeoneDoingSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> watchOverSomeoneDoingSomething()   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> something + <span class="hljs-string"><span class="hljs-string">' and I watched as well'</span></span> } watchOverSomeoneWatchingSomeoneDoingSomething().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res) })</code> </pre> <br>  Este c√≥digo generar√° el siguiente texto: <br><br><pre> <code class="hljs pgsql">I did something <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> I watched <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> I watched <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> well</code> </pre> <br><h4>  Depuraci√≥n simplificada </h4><br>  Las promesas son dif√≠ciles de depurar, porque al usarlas no se pueden usar de manera efectiva las herramientas habituales del depurador (como "omisi√≥n de pasos", paso a paso).  El c√≥digo escrito usando async / await se puede depurar usando los mismos m√©todos que el c√≥digo s√≠ncrono normal. <br><br><h2>  <font color="#3AC1EF">Generaci√≥n de eventos en Node.js</font> </h2><br>  Si trabaj√≥ con JavaScript en un navegador, entonces sabe que los eventos juegan un papel muy importante en el manejo de las interacciones de los usuarios con las p√°ginas.  Se trata de manejar eventos causados ‚Äã‚Äãpor clics y movimientos del mouse, pulsaciones de teclas en el teclado, etc.  En Node.js, puede trabajar con eventos que el programador crea por s√≠ mismo.  Aqu√≠ puede crear su propio sistema de eventos utilizando el m√≥dulo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">eventos</a> .  En particular, este m√≥dulo nos ofrece la clase <code>EventEmitter</code> , <code>EventEmitter</code> capacidades se pueden utilizar para organizar el trabajo con eventos.  Antes de usar este mecanismo, debe conectarlo: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> EventEmitter = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'events'</span></span>).EventEmitter</code> </pre> <br>  Al trabajar con √©l, los m√©todos <code>on()</code> y <code>emit()</code> est√°n disponibles para nosotros, entre otros.  El m√©todo de <code>emit</code> usa para llamar a eventos.  El m√©todo <code>on</code> se utiliza para configurar devoluciones de llamada, controladores de eventos que se llaman cuando se llama a un determinado evento. <br><br>  Por ejemplo, creemos un evento de <code>start</code> .  Cuando sucede, enviaremos algo a la consola: <br><br><pre> <code class="hljs coffeescript">eventEmitter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventEmitter(); eventEmitter.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'started'</span></span>) })</code> </pre> <br>  Para desencadenar este evento, se utiliza la siguiente construcci√≥n: <br><br><pre> <code class="hljs mel">eventEmitter.<span class="hljs-keyword"><span class="hljs-keyword">emit</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>)</code> </pre> <br>  Como resultado de la ejecuci√≥n de este comando, se llama al controlador de eventos y la cadena <code>started</code> llega a la consola. <br><br>  Puede pasar argumentos al controlador de eventos, represent√°ndolos como argumentos adicionales para el m√©todo <code>emit()</code> : <br><br><pre> <code class="hljs coffeescript">eventEmitter.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(number)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(`<span class="javascript"><span class="javascript">started ${number}</span></span>`) }) eventEmitter.emit(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>)</code> </pre> <br>  Lo mismo sucede en los casos en que el controlador necesita pasar varios argumentos: <br><br><pre> <code class="hljs pgsql">eventEmitter.<span class="hljs-keyword"><span class="hljs-keyword">on</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) =&gt; { console.log(`started <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ${<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> ${<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>}`) }) eventEmitter.emit(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre> <br>  <code>EventEmitter</code> clase <code>EventEmitter</code> tienen algunos otros m√©todos √∫tiles: <br><br><ul><li>  <code>once()</code> : le permite registrar un controlador de eventos al que solo se puede llamar una vez. </li><li>  <code>removeListener()</code> : le permite eliminar el controlador que se le pas√≥ de la matriz de controladores del evento que se le pas√≥. </li><li>  <code>removeAllListeners()</code> : le permite eliminar todos los controladores del evento que se le pas√≥. </li></ul><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  Hoy hablamos sobre programaci√≥n asincr√≥nica en JavaScript, en particular, discutimos devoluciones de llamada, promesas y la construcci√≥n async / wait.  Aqu√≠ tocamos el tema de trabajar con eventos descritos por el desarrollador usando el m√≥dulo de <code>events</code> .  Nuestro pr√≥ximo tema ser√°n los mecanismos de red de la plataforma Node.js. <br><br>  <b>Estimados lectores!</b>  Al programar para Node.js, ¬øutiliza la construcci√≥n async / await? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es424555/">https://habr.com/ru/post/es424555/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es424539/index.html">Java 11: nuevo en String</a></li>
<li><a href="../es424541/index.html">Historia del fiasco de UGJ 2018: c√≥mo hacer un juego que a nadie le guste (¬°no lo hagas!)</a></li>
<li><a href="../es424543/index.html">Java 11 / JDK 11: Disponibilidad general</a></li>
<li><a href="../es424551/index.html">Warm and tube: cinco balalaikas sobre tecnolog√≠a de audio magn√©tico</a></li>
<li><a href="../es424553/index.html">Gu√≠a de Node.js, Parte 6: Bucle de eventos, Pila de llamadas, Temporizadores</a></li>
<li><a href="../es424557/index.html">Gu√≠a de Node.js, Parte 8: Protocolos HTTP y WebSocket</a></li>
<li><a href="../es424559/index.html">Big Data resistencia 1 o el esquivo Joe. Anonimato de Internet, anti-detecci√≥n, anti-seguimiento para anti-usted y anti-nosotros.</a></li>
<li><a href="../es424563/index.html">Beeline env√≠a detalles de conversaciones a extra√±os</a></li>
<li><a href="../es424565/index.html">Descripci√≥n general: escaneo 3D de locales inmobiliarios</a></li>
<li><a href="../es424567/index.html">La experiencia de bloquear la publicidad en l√≠nea en la red local de la compa√±√≠a.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>