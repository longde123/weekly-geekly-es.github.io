<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻 🥗 🤶🏽 Manual de Node.js, Parte 7: Programación asincrónica 📳 🔝 🧒🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoy, en la traducción de la séptima parte del manual de Node.js, hablaremos sobre la programación asincrónica, consideraremos cuestiones como el uso d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Manual de Node.js, Parte 7: Programación asincrónica</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/424555/">  Hoy, en la traducción de la séptima parte del manual de Node.js, hablaremos sobre la programación asincrónica, consideraremos cuestiones como el uso de devoluciones de llamada, promesas y la construcción asíncrona / espera, y discutiremos cómo trabajar con eventos. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/webt/he/di/2j/hedi2j_qyfbnwfo_jqnnqd3ub6o.png"></a> <br><br><div class="spoiler">  <b class="spoiler_title">[Le aconsejamos que lea] Otras partes del ciclo</b> <div class="spoiler_text">  Parte 1: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Información general y primeros pasos</a> <br>  Parte 2: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JavaScript, V8, algunos trucos de desarrollo</a> <br>  Parte 3: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Hosting, REPL, trabajar con la consola, módulos</a> <br>  Parte 4: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">archivos npm, package.json y package-lock.json</a> <br>  Parte 5: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">npm y npx</a> <br>  Parte 6: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bucle de eventos, pila de llamadas, temporizadores</a> <br>  Parte 7: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Programación asincrónica</a> <br>  Parte 8: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Guía de Node.js, Parte 8: Protocolos HTTP y WebSocket</a> <br>  Parte 9: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Guía de Node.js, parte 9: trabajar con el sistema de archivos</a> <br>  Parte 10: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Guía de Node.js, Parte 10: Módulos estándar, flujos, bases de datos, NODE_ENV</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">PDF completo de la guía Node.js</a> <br></div></div><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Asincronía en lenguajes de programación.</font> </h2><br>  JavaScript en sí es un lenguaje de programación síncrono de un solo subproceso.  Esto significa que no puede crear nuevos subprocesos en el código que se ejecutan en paralelo.  Sin embargo, las computadoras son inherentemente asíncronas.  Es decir, ciertas acciones se pueden realizar independientemente del flujo principal de ejecución del programa.  En las computadoras modernas, a cada programa se le asigna una cierta cantidad de tiempo de procesador, cuando este tiempo se agota, el sistema le da recursos a otro programa, también por un tiempo.  Tales cambios se realizan cíclicamente, se hace tan rápido que una persona simplemente no puede notarlo, como resultado, creemos que nuestras computadoras ejecutan muchos programas simultáneamente.  Pero esto es una ilusión (sin mencionar las máquinas multiprocesador). <br><br>  En las entrañas de los programas se utilizan interrupciones: señales transmitidas al procesador y que permiten atraer la atención del sistema.  No entraremos en detalles, lo más importante es recordar que el comportamiento asíncrono, cuando el programa está en pausa hasta el momento en que necesita recursos del procesador, es completamente normal.  En un momento en que el programa no carga el sistema con trabajo, la computadora puede resolver otros problemas.  Por ejemplo, con este enfoque, cuando un programa espera una respuesta a una solicitud de red que se le hace, no bloquea el procesador hasta que se recibe una respuesta. <br><br>  Como regla general, los lenguajes de programación son asíncronos, algunos de ellos le dan al programador la capacidad de controlar mecanismos asíncronos, utilizando las herramientas de lenguaje incorporadas o las bibliotecas especializadas.  Estamos hablando de lenguajes como C, Java, C #, PHP, Go, Ruby, Swift, Python.  Algunos de ellos le permiten programar en estilo asincrónico, utilizando hilos, comenzando nuevos procesos. <br><br><h2>  <font color="#3AC1EF">Asincronía JavaScript</font> </h2><br>  Como ya se mencionó, JavaScript es un lenguaje síncrono de subproceso único.  Las líneas de código escritas en JS se ejecutan en el orden en que aparecen en el texto, una tras otra.  Por ejemplo, aquí hay un programa JS muy normal que demuestra este comportamiento: <br><br><pre><code class="hljs vbscript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> a = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> b = <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> c = a * b console.<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>(c) doSomething()</code> </pre> <br>  Pero JavaScript fue creado para su uso en navegadores.  Su tarea principal, al principio, era organizar el procesamiento de eventos relacionados con las actividades del usuario.  Por ejemplo, estos son eventos como <code>onClick</code> , <code>onMouseOver</code> , <code>onChange</code> , <code>onSubmit</code> , etc.  ¿Cómo resolver estos problemas en el marco de un modelo de programación síncrono? <br><br>  La respuesta se encuentra en el entorno en el que se ejecuta JavaScript.  A saber, el navegador le permite resolver eficazmente tales problemas, dándole al programador las API apropiadas. <br><br>  En el entorno de Node.js existen herramientas para realizar operaciones de E / S sin bloqueo, como trabajar con archivos, organizar el intercambio de datos a través de una red, etc. <br><br><h2>  <font color="#3AC1EF">Devoluciones de llamada</font> </h2><br>  Si hablamos de JavaScript basado en navegador, se puede observar que es imposible saber de antemano cuando el usuario hace clic en un botón.  Para garantizar que el sistema responda a tal evento, se crea un controlador para ello. <br><br>  El controlador de eventos acepta una función que se llamará cuando ocurra el evento.  Se ve así: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'button'</span></span>).addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    })</code> </pre> <br>  Dichas funciones también se denominan funciones de devolución de llamada o devoluciones de llamada. <br><br>  Una devolución de llamada es una función regular que se pasa como valor a otra función.  Solo se llamará cuando ocurra un evento determinado.  JavaScript implementa el concepto de funciones de primera clase.  Dichas funciones pueden asignarse a variables y pasarse a otras funciones (llamadas funciones de orden superior). <br><br>  En el desarrollo de JavaScript del lado del cliente, el enfoque se generaliza cuando todo el código del cliente se envuelve en un escucha del evento de <code>load</code> de un objeto de <code>window</code> , que llama a la devolución de llamada que se le pasa después de que la página está lista para trabajar: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'load'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>     })</code> </pre> <br>  Las devoluciones de llamada se usan en todas partes, y no solo para manejar eventos DOM.  Por ejemplo, ya nos hemos encontrado con su uso en temporizadores: <br><br><pre> <code class="hljs javascript">setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-comment"><span class="hljs-comment">//   2  }, 2000)</span></span></code> </pre> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Las solicitudes XHR</a> también usan devoluciones de llamada.  En este caso, parece asignar una función a la propiedad correspondiente.  Se llamará a una función similar cuando ocurra un evento determinado.  En el siguiente ejemplo, dicho evento es un cambio de estado de solicitud: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> xhr = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> XMLHttpRequest() xhr.onreadystatechange = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (xhr.readyState === <span class="hljs-number"><span class="hljs-number">4</span></span>) {   xhr.status === <span class="hljs-number"><span class="hljs-number">200</span></span> ? <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(xhr.responseText) : <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(<span class="hljs-string"><span class="hljs-string">'error'</span></span>) } } xhr.open(<span class="hljs-string"><span class="hljs-string">'GET'</span></span>, <span class="hljs-string"><span class="hljs-string">'https://yoursite.com'</span></span>) xhr.send()</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Manejo de errores en devoluciones de llamada</font> </h3><br>  Hablemos sobre cómo manejar errores en devoluciones de llamada.  Hay una estrategia común para manejar tales errores, que también se usa en Node.js.  Consiste en el hecho de que el primer parámetro de cualquier función de devolución de llamada es un objeto de error.  Si no hay errores, se escribirá <code>null</code> en este parámetro.  De lo contrario, habrá un objeto de error que contiene su descripción e información adicional al respecto.  Así es como se ve: <br><br><pre> <code class="hljs coffeescript">fs.readFile(<span class="hljs-string"><span class="hljs-string">'/file.json'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err, data)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (err !== <span class="hljs-literal"><span class="hljs-literal">null</span></span>) {   <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>    <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(err)   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } <span class="hljs-regexp"><span class="hljs-regexp">//</span></span> ,   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(data) })</code> </pre> <br><h3>  <font color="#3AC1EF">▍ Problema de devolución de llamada</font> </h3><br>  Las devoluciones de llamada son convenientes para usar en situaciones simples.  Sin embargo, cada devolución de llamada es un nivel adicional de anidación de código.  Si se utilizan varias devoluciones de llamada anidadas, esto rápidamente conduce a una complicación significativa de la estructura del código: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-built_in"><span class="hljs-built_in">window</span></span>.addEventListener(<span class="hljs-string"><span class="hljs-string">'load'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.getElementById(<span class="hljs-string"><span class="hljs-string">'button'</span></span>).addEventListener(<span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {     items.forEach(item =&gt; {       <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>,  -      })   }, <span class="hljs-number"><span class="hljs-number">2000</span></span>) }) })</code> </pre> <br>  En este ejemplo, solo se muestran 4 niveles de código, pero en la práctica uno puede encontrar una gran cantidad de niveles, generalmente llamados el "infierno de devolución de llamada".  Puede resolver este problema utilizando otras construcciones de lenguaje. <br><br><h2>  <font color="#3AC1EF">Promesas y asíncrono / espera</font> </h2><br>  Comenzando con el estándar ES6, JavaScript introduce nuevas características que facilitan la escritura de código asincrónico, eliminando la necesidad de devoluciones de llamada.  Estamos hablando de las promesas que aparecieron en ES6, y la construcción asíncrona / en espera que apareció en ES8. <br><br><h3>  <font color="#3AC1EF">▍ Promesas</font> </h3><br>  Las promesas (objetos de promesa) son una de las formas de trabajar con construcciones de software asincrónicas en JavaScript, lo que, en general, reduce el uso de devoluciones de llamada. <br><br><h4>  Conocimiento de promesas </h4><br>  Las promesas generalmente se definen como objetos proxy para ciertos valores, cuya apariencia se espera en el futuro.  Las promesas también se llaman "promesas" o "resultados prometidos".  Aunque este concepto existe desde hace muchos años, las promesas se estandarizaron y se agregaron al lenguaje solo en ES2015.  En ES2017, apareció el diseño asíncrono / espera, que se basa en promesas y que puede considerarse como su reemplazo conveniente.  Por lo tanto, incluso si no está planeando usar promesas regulares, es importante comprender cómo funcionan para utilizar el constructo async / wait de manera efectiva. <br><br><h4>  Cómo funcionan las promesas </h4><br>  Después de que se llama una promesa, pasa a un estado pendiente.  Esto significa que la función que causó la promesa continúa ejecutándose, mientras que se realizan algunos cálculos en la promesa, después de lo cual la promesa informa al respecto.  Si la operación realizada por la promesa se completa con éxito, la promesa se transfiere al estado cumplido.  Dicha promesa se dice que se resuelve con éxito.  Si la operación se completa con un error, la promesa se coloca en el estado rechazado. <br><br>  Hablemos de trabajar con promesas. <br><br><h4>  Crea promesas </h4><br>  La API para trabajar con promesas nos proporciona el constructor correspondiente, que se llama mediante un comando de la forma <code>new Promise()</code> .  Así es como se crean las promesas: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> done = <span class="hljs-literal"><span class="hljs-literal">true</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> isItDoneYet = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>( <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (done) {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> workDone = <span class="hljs-string"><span class="hljs-string">'Here is the thing I built'</span></span>     resolve(workDone)   } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {     <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> why = <span class="hljs-string"><span class="hljs-string">'Still working on something else'</span></span>     reject(why)   } } )</code> </pre> <br>  Promis comprueba la constante global <code>done</code> , y si su valor es <code>true</code> , se resuelve con éxito.  De lo contrario, la promesa es rechazada.  Usando los parámetros <code>resolve</code> y <code>reject</code> , que son funciones, podemos devolver valores de la promesa.  En este caso, devolvemos una cadena, pero aquí se puede usar un objeto. <br><br><h4>  Trabaja con promesas </h4><br>  Creamos una promesa arriba, ahora considera trabajar con ella.  Se ve así: <br><br><pre> <code class="hljs coffeescript">const isItDoneYet = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise( <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>... ) const checkIfItsDone = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { isItDoneYet   .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ok)</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(ok)   })   .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> {     <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err)   }) } checkIfItsDone()</code> </pre> <br>  Llamar a <code>checkIfItsDone()</code> conducirá a la ejecución de la <code>isItDoneYet()</code> isItDoneYet <code>isItDoneYet()</code> y a la organización de esperar su resolución.  Si la promesa se resuelve con éxito, la devolución de llamada pasada al método <code>.then()</code> funcionará.  Si se produce un error, es decir, la promesa será rechazada, se puede procesar en la función que se pasa al método <code>.catch()</code> . <br><br><h4>  Promesas encadenadas </h4><br>  Los métodos de promesa devuelven promesas, lo que le permite combinarlos en cadenas.  Un buen ejemplo de este comportamiento es el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">API Fetch</a> basado en navegador, que es una capa de abstracción sobre <code>XMLHttpRequest</code> .  Hay un paquete npm bastante popular para Node.js que implementa la API Fetch, que discutiremos más adelante.  Esta API se puede utilizar para cargar ciertos recursos de red y, gracias a la posibilidad de combinar promesas en cadenas, organizar el procesamiento posterior de los datos descargados.  De hecho, cuando llama a la API Fetch a través de una llamada a la función <code>fetch()</code> , se crea una promesa. <br><br>  Considere el siguiente ejemplo de encadenamiento de promesas: <br><br><pre> <code class="hljs coffeescript">const fetch = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'node-fetch'</span></span>) const status = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (response.status &gt;= <span class="hljs-number"><span class="hljs-number">200</span></span> &amp;&amp; response.status &lt; <span class="hljs-number"><span class="hljs-number">300</span></span>) {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Promise.resolve(response) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Promise.reject(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(response.statusText)) } const json = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(response)</span></span></span><span class="hljs-function"> =&gt;</span></span> response.json() fetch(<span class="hljs-string"><span class="hljs-string">'https://jsonplaceholder.typicode.com/todos'</span></span>) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(status) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(json) .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Request succeeded with JSON response'</span></span>, data) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(error)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Request failed'</span></span>, error) })</code> </pre> <br>  Aquí usamos el paquete npm <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">node-fetch</a> y el recurso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">jsonplaceholder.typicode.com</a> como fuente de datos JSON. <br><br>  En este ejemplo, la función <code>fetch()</code> se usa para cargar un elemento de lista TODO usando una cadena de promesas.  Después de ejecutar <code>fetch()</code> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">se</a> devuelve una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">respuesta</a> que tiene muchas propiedades, entre las cuales estamos interesados ​​en lo siguiente: <br><br><ul><li>  <code>status</code> es un valor numérico que representa el código de estado HTTP. </li><li>  <code>statusText</code> : una descripción textual del código de estado HTTP, que se representa con la cadena <code>OK</code> si la solicitud se realizó correctamente. </li></ul><br>  El objeto de <code>response</code> tiene un método <code>json()</code> que devuelve una promesa, tras la resolución de la cual se presenta el contenido procesado del cuerpo de la solicitud, presentado en formato JSON. <br><br>  Dado lo anterior, describimos lo que está sucediendo en este código.  La primera promesa en la cadena está representada por la función <code>status()</code> que anunciamos, que verifica el estado de la respuesta, y si indica que la solicitud falló (es decir, el código de estado HTTP no está en el rango entre 200 y 299), la promesa se rechaza.  Esta operación lleva al hecho de que otras expresiones <code>.then()</code> en la cadena de promesas no se ejecutan e inmediatamente llegamos al método <code>.catch()</code> , que se envía a la consola, junto con el mensaje de error, el texto <code>Request failed</code> . <br><br>  Si el código de estado HTTP nos conviene, se llama a la función <code>json()</code> declarada por nosotros.  Dado que la promesa anterior, si se resuelve con éxito, devuelve un objeto de <code>response</code> , lo usamos como valor de entrada para la segunda promesa. <br><br>  En este caso, devolvemos los datos JSON procesados, por lo que la tercera promesa los recibe, luego de lo cual, precedidos por un mensaje que indica que como resultado de la solicitud fue posible obtener los datos necesarios, se muestran en la consola. <br><br><h4>  Manejo de errores </h4><br>  En el ejemplo anterior, teníamos un método <code>.catch()</code> adjunto a una cadena de promesas.  Si algo en la cadena de promesas sale mal y ocurre un error, o si una de las promesas resulta ser rechazada, el control se transfiere a la expresión más cercana <code>.catch()</code> .  Aquí está la situación cuando ocurre un error en una promesa: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br>  Aquí hay un ejemplo de activación de <code>.catch()</code> después de rechazar una promesa: <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span><span class="hljs-function"> =&gt;</span></span> { reject(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br><h4>  Manejo de errores en cascada </h4><br>  ¿Qué sucede si se produce un error en la expresión <code>.catch()</code> ?  Para manejar este error, puede incluir otra expresión <code>.catch()</code> en la cadena de promesas (y luego puede adjuntar tantas expresiones <code>.catch()</code> a la cadena como sea necesario): <br><br><pre> <code class="hljs coffeescript"><span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve, reject)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Error(<span class="hljs-string"><span class="hljs-string">'Error'</span></span>) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br>  Ahora echemos un vistazo a algunos métodos útiles utilizados para gestionar las promesas. <br><br><h4>  Promise.all () </h4><br>  Si necesita realizar alguna acción después de resolver varias promesas, puede hacerlo utilizando el <code>Promise.all()</code> .  Considere un ejemplo: <br><br><pre> <code class="hljs coffeescript">const f1 = fetch(<span class="hljs-string"><span class="hljs-string">'https://jsonplaceholder.typicode.com/todos/1'</span></span>) const f2 = fetch(<span class="hljs-string"><span class="hljs-string">'https://jsonplaceholder.typicode.com/todos/2'</span></span>) Promise.all([f1, f2]).<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res)</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Array of results'</span></span>, res) }) .<span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(err)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err) })</code> </pre> <br>  En ES2015, apareció la sintaxis de la asignación destructiva; al usarla, puede crear construcciones de la siguiente forma: <br><br><pre> <code class="hljs powershell">Promise.all([<span class="hljs-type"><span class="hljs-type">f1</span></span>, <span class="hljs-type"><span class="hljs-type">f2</span></span>]).then(([<span class="hljs-type"><span class="hljs-type">res1</span></span>, <span class="hljs-type"><span class="hljs-type">res2</span></span>]) =&gt; {   console.log(<span class="hljs-string"><span class="hljs-string">'Results'</span></span>, res1, res2) })</code> </pre> <br>  Aquí, como ejemplo, consideramos el API Fetch, pero <code>Promise.all()</code> , por supuesto, le permite trabajar con cualquier promesa. <br><br><h4>  Promise.race () </h4><br>  El <code>Promise.race()</code> permite realizar la acción especificada después de que se resuelva una de las promesas que se le pasaron.  La devolución de llamada correspondiente que contiene los resultados de esta primera promesa se llama solo una vez.  Considere un ejemplo: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> first = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {   setTimeout(resolve, <span class="hljs-number"><span class="hljs-number">500</span></span>, <span class="hljs-string"><span class="hljs-string">'first'</span></span>) }) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> second = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve, reject</span></span></span><span class="hljs-function">) =&gt;</span></span> {   setTimeout(resolve, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-string"><span class="hljs-string">'second'</span></span>) }) <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.race([first, second]).then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">result</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(result) <span class="hljs-comment"><span class="hljs-comment">// second })</span></span></code> </pre> <br><h4>  Error TypeError no detectado que se produce al trabajar con promesas </h4><br>  Si, al trabajar con promesas, encuentra el Error de tipo <code>Uncaught TypeError: undefined is not a promise</code> error de <code>Uncaught TypeError: undefined is not a promise</code> , asegúrese de que se use la <code>new Promise()</code> construcción <code>new Promise()</code> lugar de solo <code>Promise()</code> al crear promesas. <br><br><h3>  <font color="#3AC1EF">▍ diseño asíncrono / espera</font> </h3><br>  La construcción async / await es un enfoque moderno para la programación asincrónica, simplificándola.  Las funciones asincrónicas se pueden representar como una combinación de promesas y generadores, y, en general, esta construcción es una abstracción sobre las promesas. <br><br>  El diseño asíncrono / espera reduce la cantidad de código repetitivo que debe escribir cuando trabaja con promesas.  Cuando aparecieron las promesas en el estándar ES2015, su objetivo era resolver el problema de la creación de código asincrónico.  Hicieron frente a esta tarea, pero en dos años, compartiendo el resultado de los estándares ES2015 y ES2017, quedó claro que no podían considerarse la solución final del problema. <br><br>  Uno de los problemas que las promesas resolvieron fue el famoso "infierno de devoluciones de llamada", pero ellos, resolviendo este problema, crearon sus propios problemas de naturaleza similar. <br><br>  Las promesas eran construcciones simples alrededor de las cuales uno podía construir algo con una sintaxis más simple.  Como resultado, cuando llegó el momento, apareció la construcción asíncrona / espera.  Su uso le permite escribir código que parece síncrono, pero es asíncrono, en particular, no bloquea el hilo principal. <br><br><h4>  Cómo funciona la construcción async / await </h4><br>  Una función asincrónica devuelve una promesa, como en el siguiente ejemplo: <br><br><pre> <code class="hljs coffeescript">const doSomethingAsync = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Promise(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(resolve)</span></span></span><span class="hljs-function"> =&gt;</span></span> {       setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">3000</span></span>)   }) }</code> </pre> <br>  Cuando necesite llamar a una función similar, debe colocar la palabra clave <code>await</code> antes del comando para llamarla.  Esto hará que el código que lo llama espere el permiso o el rechazo de la promesa correspondiente.  Cabe señalar que una función que usa la palabra clave <code>await</code> debe declararse usando la <code>async</code> : <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> doSomethingAsync()) }</code> </pre> <br>  Combine los dos fragmentos de código anteriores y examine su comportamiento: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomethingAsync = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function">) =&gt;</span></span> {       setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">3000</span></span>)   }) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> doSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-keyword"><span class="hljs-keyword">await</span></span> doSomethingAsync()) } <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'Before'</span></span>) doSomething() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'After'</span></span>)</code> </pre> <br>  Este código generará lo siguiente: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">Before</span></span> <span class="hljs-keyword"><span class="hljs-keyword">After</span></span> I did something</code> </pre> <br>  El texto <code>I did something</code> entra en la consola con un retraso de 3 segundos. <br><br><h4>  Sobre promesas y funciones asincrónicas </h4><br>  Si declara una determinada función utilizando la <code>async</code> , esto significará que dicha función devolverá una promesa incluso si no se hace explícitamente.  Por eso, por ejemplo, el siguiente ejemplo es un código de trabajo: <br><br><pre> <code class="hljs powershell">const a<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">Function</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">async</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'test'</span></span> } aFunction().then(console.log) //    <span class="hljs-string"><span class="hljs-string">'test'</span></span></code> </pre> <br>  Este diseño es similar a este: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> aFunction = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>.resolve(<span class="hljs-string"><span class="hljs-string">'test'</span></span>) } aFunction().then(<span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log) <span class="hljs-comment"><span class="hljs-comment">//    'test'</span></span></code> </pre> <br><h4>  Fortalezas de asíncrono / espera </h4><br>  Al analizar los ejemplos anteriores, puede ver que el código que usa async / await es más simple que el código que usa el encadenamiento de promesas o el código basado en funciones de devolución de llamada.  Aquí, por supuesto, miramos ejemplos muy simples.  Puede experimentar plenamente los beneficios anteriores trabajando con un código mucho más complejo.  Aquí, por ejemplo, se explica cómo cargar y analizar datos JSON usando promesas: <br><br><pre> <code class="hljs pgsql">const getFirstUserData = () =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(<span class="hljs-string"><span class="hljs-string">'/users.json'</span></span>) //      .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(response =&gt; response.json()) //  <span class="hljs-type"><span class="hljs-type">JSON</span></span>   .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(users =&gt; users[<span class="hljs-number"><span class="hljs-number">0</span></span>]) //      .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">user</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(`/users/${<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.name}`)) //       .<span class="hljs-keyword"><span class="hljs-keyword">then</span></span>(userResponse =&gt; userResponse.json()) //  <span class="hljs-type"><span class="hljs-type">JSON</span></span> } getFirstUserData()</code> </pre> <br>  Así es como se ve la solución al mismo problema usando async / await: <br><br><pre> <code class="hljs pgsql">const getFirstUserData = async () =&gt; { const response = await <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(<span class="hljs-string"><span class="hljs-string">'/users.json'</span></span>) //    const users = await response.json() //  <span class="hljs-type"><span class="hljs-type">JSON</span></span> const <span class="hljs-keyword"><span class="hljs-keyword">user</span></span> = users[<span class="hljs-number"><span class="hljs-number">0</span></span>] //    const userResponse = await <span class="hljs-keyword"><span class="hljs-keyword">fetch</span></span>(`/users/${<span class="hljs-keyword"><span class="hljs-keyword">user</span></span>.name}`) //     const userData = await userResponse.json() //  <span class="hljs-type"><span class="hljs-type">JSON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> userData } getFirstUserData()</code> </pre> <br><h4>  Usando secuencias de funciones asincrónicas </h4><br>  Las funciones asincrónicas se pueden combinar fácilmente en diseños que se parecen a las cadenas de Promise.  Los resultados de tal combinación, sin embargo, son una legibilidad mucho mejor: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> promiseToDoSomething = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Promise</span></span>(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">resolve</span></span></span><span class="hljs-function"> =&gt;</span></span> {       setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> resolve(<span class="hljs-string"><span class="hljs-string">'I did something'</span></span>), <span class="hljs-number"><span class="hljs-number">10000</span></span>)   }) } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> watchOverSomeoneDoingSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> promiseToDoSomething()   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> something + <span class="hljs-string"><span class="hljs-string">' and I watched'</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> watchOverSomeoneWatchingSomeoneDoingSomething = <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> () =&gt; {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> something = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> watchOverSomeoneDoingSomething()   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> something + <span class="hljs-string"><span class="hljs-string">' and I watched as well'</span></span> } watchOverSomeoneWatchingSomeoneDoingSomething().then(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">res</span></span></span><span class="hljs-function">) =&gt;</span></span> {   <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(res) })</code> </pre> <br>  Este código generará el siguiente texto: <br><br><pre> <code class="hljs pgsql">I did something <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> I watched <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> I watched <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> well</code> </pre> <br><h4>  Depuración simplificada </h4><br>  Las promesas son difíciles de depurar, porque al usarlas no se pueden usar de manera efectiva las herramientas habituales del depurador (como "omisión de pasos", paso a paso).  El código escrito usando async / await se puede depurar usando los mismos métodos que el código síncrono normal. <br><br><h2>  <font color="#3AC1EF">Generación de eventos en Node.js</font> </h2><br>  Si trabajó con JavaScript en un navegador, entonces sabe que los eventos juegan un papel muy importante en el manejo de las interacciones de los usuarios con las páginas.  Se trata de manejar eventos causados ​​por clics y movimientos del mouse, pulsaciones de teclas en el teclado, etc.  En Node.js, puede trabajar con eventos que el programador crea por sí mismo.  Aquí puede crear su propio sistema de eventos utilizando el módulo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">eventos</a> .  En particular, este módulo nos ofrece la clase <code>EventEmitter</code> , <code>EventEmitter</code> capacidades se pueden utilizar para organizar el trabajo con eventos.  Antes de usar este mecanismo, debe conectarlo: <br><br><pre> <code class="hljs javascript"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> EventEmitter = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'events'</span></span>).EventEmitter</code> </pre> <br>  Al trabajar con él, los métodos <code>on()</code> y <code>emit()</code> están disponibles para nosotros, entre otros.  El método de <code>emit</code> usa para llamar a eventos.  El método <code>on</code> se utiliza para configurar devoluciones de llamada, controladores de eventos que se llaman cuando se llama a un determinado evento. <br><br>  Por ejemplo, creemos un evento de <code>start</code> .  Cuando sucede, enviaremos algo a la consola: <br><br><pre> <code class="hljs coffeescript">eventEmitter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventEmitter(); eventEmitter.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'started'</span></span>) })</code> </pre> <br>  Para desencadenar este evento, se utiliza la siguiente construcción: <br><br><pre> <code class="hljs mel">eventEmitter.<span class="hljs-keyword"><span class="hljs-keyword">emit</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>)</code> </pre> <br>  Como resultado de la ejecución de este comando, se llama al controlador de eventos y la cadena <code>started</code> llega a la consola. <br><br>  Puede pasar argumentos al controlador de eventos, representándolos como argumentos adicionales para el método <code>emit()</code> : <br><br><pre> <code class="hljs coffeescript">eventEmitter.<span class="hljs-literal"><span class="hljs-literal">on</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(number)</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(`<span class="javascript"><span class="javascript">started ${number}</span></span>`) }) eventEmitter.emit(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>)</code> </pre> <br>  Lo mismo sucede en los casos en que el controlador necesita pasar varios argumentos: <br><br><pre> <code class="hljs pgsql">eventEmitter.<span class="hljs-keyword"><span class="hljs-keyword">on</span></span>(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">end</span></span>) =&gt; { console.log(`started <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> ${<span class="hljs-keyword"><span class="hljs-keyword">start</span></span>} <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> ${<span class="hljs-keyword"><span class="hljs-keyword">end</span></span>}`) }) eventEmitter.emit(<span class="hljs-string"><span class="hljs-string">'start'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>)</code> </pre> <br>  <code>EventEmitter</code> clase <code>EventEmitter</code> tienen algunos otros métodos útiles: <br><br><ul><li>  <code>once()</code> : le permite registrar un controlador de eventos al que solo se puede llamar una vez. </li><li>  <code>removeListener()</code> : le permite eliminar el controlador que se le pasó de la matriz de controladores del evento que se le pasó. </li><li>  <code>removeAllListeners()</code> : le permite eliminar todos los controladores del evento que se le pasó. </li></ul><br><h2>  <font color="#3AC1EF">Resumen</font> </h2><br>  Hoy hablamos sobre programación asincrónica en JavaScript, en particular, discutimos devoluciones de llamada, promesas y la construcción async / wait.  Aquí tocamos el tema de trabajar con eventos descritos por el desarrollador usando el módulo de <code>events</code> .  Nuestro próximo tema serán los mecanismos de red de la plataforma Node.js. <br><br>  <b>Estimados lectores!</b>  Al programar para Node.js, ¿utiliza la construcción async / await? <br><br><div style="text-align:center;"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es424555/">https://habr.com/ru/post/es424555/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es424539/index.html">Java 11: nuevo en String</a></li>
<li><a href="../es424541/index.html">Historia del fiasco de UGJ 2018: cómo hacer un juego que a nadie le guste (¡no lo hagas!)</a></li>
<li><a href="../es424543/index.html">Java 11 / JDK 11: Disponibilidad general</a></li>
<li><a href="../es424551/index.html">Warm and tube: cinco balalaikas sobre tecnología de audio magnético</a></li>
<li><a href="../es424553/index.html">Guía de Node.js, Parte 6: Bucle de eventos, Pila de llamadas, Temporizadores</a></li>
<li><a href="../es424557/index.html">Guía de Node.js, Parte 8: Protocolos HTTP y WebSocket</a></li>
<li><a href="../es424559/index.html">Big Data resistencia 1 o el esquivo Joe. Anonimato de Internet, anti-detección, anti-seguimiento para anti-usted y anti-nosotros.</a></li>
<li><a href="../es424563/index.html">Beeline envía detalles de conversaciones a extraños</a></li>
<li><a href="../es424565/index.html">Descripción general: escaneo 3D de locales inmobiliarios</a></li>
<li><a href="../es424567/index.html">La experiencia de bloquear la publicidad en línea en la red local de la compañía.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>