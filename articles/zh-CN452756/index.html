<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✡️ 👨‍👨‍👦 ✍🏾 在Unity中创建塔防：敌人 🍴 🧛🏾 👉🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[ 第一部分：平铺并找到路径 ] 



- 放置敌人创造点。 
- 敌人的出现及其在野外的移动。 
- 以恒定的速度产生平稳的运动。 
- 更改敌人的大小，速度和位置。 
 这是一个简单的塔防游戏教程的第二部分。 它检查了创建敌人的过程及其向最近端点的移动。 

 本教程是在Unity 2018....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>在Unity中创建塔防：敌人</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452756/">  <i>[ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一部分：平铺并找到路径</a> ]</i> <br><br><ul><li> 放置敌人创造点。 </li><li> 敌人的出现及其在野外的移动。 </li><li> 以恒定的速度产生平稳的运动。 </li><li> 更改敌人的大小，速度和位置。 </li></ul><br> 这是一个简单的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">塔防</a>游戏教程的第二部分。 它检查了创建敌人的过程及其向最近端点的移动。 <br><br> 本教程是在Unity 2018.3.0f2中制作的。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2db/cf3/311/2dbcf331117740aa403cb12a757ae6fd.jpg" width="512" height="256"></div><br>  <i>到达终点的路上的敌人。</i> <br><a name="habracut"></a><br><h2> 敌人创造（产卵）点 </h2><br> 在开始制造敌人之前，我们需要确定将它们放置在场地上的位置。 为此，我们将创建派生点。 <br><br><h3> 平铺内容 </h3><br> 生成点是切片内容的另一种类型，因此请在<code>GameTileContentType</code>中<code>GameTileContentType</code>添加一个条目。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> GameTileContentType { Empty, Destination, Wall, SpawnPoint }</code> </pre> <br> 然后创建一个预制件以对其进行可视化。 起点的预制件副本非常适合我们，只需更改其内容类型并为其提供其他材料即可。 我把它弄成橙色。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e39/522/28d/e3952228dacd6801a6f5d2fb53826cc2.png" width="320" height="104"></div><br>  <i>生成点配置。</i> <br><br> 向内容工厂添加生成点支持，并为其提供到预制件的链接。 <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContent spawnPointPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContentType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Destination: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(destinationPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Empty: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(emptyPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Wall: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(wallPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.SpawnPoint: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(spawnPointPrefab); } Debug.Assert(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"Unsupported type: "</span></span> + type); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/10f/036/a17/10f036a17ae271cf7b7f7c9694e01782.png" width="320" height="142"></div><br>  <i>工厂支持生成点。</i> <br><br><h3> 启用或禁用生成点 </h3><br> 与其他切换方法一样，切换生成点状态的方法将添加到<code>GameBoard</code> 。 但是生成点不会影响对路径的搜索，因此更改之后，我们无需寻找新路径。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleSpawnPoint</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.SpawnPoint) { tile.Content = contentFactory.Get(GameTileContentType.Empty); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.SpawnPoint); } }</code> </pre> <br> 只有当我们有敌人并且他们需要生成点时，游戏才有意义。 因此，游戏场必须至少包含一个生成点。 以后，当我们添加敌人时，我们还需要访问生成点，因此让我们使用列表来跟踪具有这些点的所有图块。 切换生成点的状态时，我们将更新列表，并防止删除最后一个生成点。 <br><br><pre> <code class="cs hljs"> List&lt;GameTile&gt; spawnPoints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;GameTile&gt;(); … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleSpawnPoint</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.SpawnPoint) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spawnPoints.Count &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { spawnPoints.Remove(tile); tile.Content = contentFactory.Get(GameTileContentType.Empty); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.SpawnPoint); spawnPoints.Add(tile); } }</code> </pre> <br> 现在， <code>Initialize</code>方法应该设置生成点以创建字段的初始正确状态。 让我们仅包括第一个图块，它位于左下角。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector2Int size, GameTileContentFactory contentFactory </span></span></span><span class="hljs-function">)</span></span> { … ToggleDestination(tiles[tiles.Length / <span class="hljs-number"><span class="hljs-number">2</span></span>]); ToggleSpawnPoint(tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }</code> </pre> <br> 现在，我们将进行替代触摸，以切换生成点的状态，但是当您按住左Shift键（通过<code>Input.GetKey</code>方法检查击键）时，端点的状态将切换 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleAlternativeTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { board.ToggleDestination(tile); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { board.ToggleSpawnPoint(tile); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f9/cd6/22b/2f9cd622bf1aa41023e5204e1f4caa9a.png" width="230" height="230"></div><br>  <i>带有生成点的字段。</i> <br><br><h3> 可以访问生成点 </h3><br> 战场处理了所有的瓷砖，但敌人不是它的责任。 我们将可以通过带有索引参数的通用<code>GetSpawnPoint</code>方法访问其生成点。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSpawnPoint</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> spawnPoints[index]; }</code> </pre> <br> 为了知道哪个索引是正确的，需要有关生成点数的信息，因此我们将使用通用的getter属性使其通用。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SpawnPointCount =&gt; spawnPoints.Count;</code> </pre> <br><h2> 敌人产生 </h2><br> 生成敌人有点类似于创建图块的内容。 我们通过工厂创建一个预制实例，然后将其放置在现场。 <br><br><h3> 工厂工厂 </h3><br> 我们将为敌人建立一个工厂，将工厂创造的一切置于自己的舞台上。 此功能与我们已经拥有的工厂很常见，因此让我们将其代码放入通用基类<code>GameObjectFactory</code> 。 我们将只需要一个带有通用预制参数的<code>CreateGameObjectInstance</code>方法，该方法可以创建并返回一个实例，并且还可以管理整个场景。 我们创建<code>protected</code>方法，也就是说，它仅对类以及从其继承的所有类型可用。 这就是该类所做的一切；它不打算用作功能齐全的工厂。 因此，我们将其标记为<code>abstract</code> ，这将不允许我们创建其对象的实例。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.SceneManagement; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameObjectFactory</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { Scene scene; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> T CreateGameObjectInstance&lt;T&gt; (T prefab) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : MonoBehaviour { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!scene.isLoaded) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Application.isEditor) { scene = SceneManager.GetSceneByName(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!scene.isLoaded) { scene = SceneManager.CreateScene(name); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { scene = SceneManager.CreateScene(name); } } T instance = Instantiate(prefab); SceneManager.MoveGameObjectToScene(instance.gameObject, scene); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; } }</code> </pre> <br> 更改<code>GameTileContentFactory</code> ，使其<code>GameTileContentFactory</code>此类型的工厂，并在其<code>Get</code>方法中使用<code>CreateGameObjectInstance</code> ，然后从中删除场景控制代码。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [CreateAssetMenu] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTileContentFactory</span></span> : <span class="hljs-title"><span class="hljs-title">GameObjectFactory</span></span> { … <span class="hljs-comment"><span class="hljs-comment">//Scene contentScene; … GameTileContent Get (GameTileContent prefab) { GameTileContent instance = CreateGameObjectInstance(prefab); instance.OriginFactory = this; //MoveToFactoryScene(instance.gameObject); return instance; } //void MoveToFactoryScene (GameObject o) { // … //} }</span></span></code> </pre> <br> 之后，创建一个新的<code>EnemyFactory</code>类型，该类型使用<code>Get</code>方法以及随附的<code>Reclaim</code>方法创建一个<code>Enemy</code>预制实例。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [CreateAssetMenu] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemyFactory</span></span> : <span class="hljs-title"><span class="hljs-title">GameObjectFactory</span></span> { [SerializeField] Enemy prefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Enemy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Enemy instance = CreateGameObjectInstance(prefab); instance.OriginFactory = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reclaim</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Enemy enemy</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(enemy.OriginFactory == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"Wrong factory reclaimed!"</span></span>); Destroy(enemy.gameObject); } }</code> </pre> <br> 新的<code>Enemy</code>类型最初只需要跟踪其原始工厂。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Enemy</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { EnemyFactory originFactory; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> EnemyFactory OriginFactory { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; originFactory; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { Debug.Assert(originFactory == <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Redefined origin factory!"</span></span>); originFactory = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } }</code> </pre> <br><h3> 预制件 </h3><br> 敌人需要可视化，可视化可以是任何东西-机器人，蜘蛛，鬼魂，更简单的东西（例如，我们使用的立方体）。 但总的来说，敌人拥有复杂的3D模型。 为了确保其方便的支持，我们将对敌人的预制结构使用根对象，仅将<code>Enemy</code>组件附加到该根对象。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c6/348/428/7c6348428b50732e0a13efcdadfc9fff.png" width="320" height="160"></div><br>  <i>预制根</i> <br><br> 让我们为该对象创建唯一的子元素，它将成为模型的根。 它必须具有转换单位值。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce7/691/330/ce7691330dd6c6813d2a64398c582c2a.png" width="320" height="120"></div><br>  <i>模型的根。</i> <br><br> 该模型根的任务是相对于敌人坐标的本地原点定位3D模型，以便他将其视为敌人站立或悬挂的参考点。 在我们的例子中，模型将是标准的半角立方体，我将为其赋予深蓝色。 我们将其设为模型根的子级，并将Y位置设置为0.25，使其立足于地面。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65b/7a3/808/65b7a3808f469e2723b344afccd94f8f.png" width="320" height="206"></div><br>  <i>立方体模型</i> <br><br> 因此，敌人的预制件由三个嵌套对象组成：预制件根，模型根和立方体。 对于一个简单的多维数据集来说，它看起来像是半身像，但是这样的系统可以让您移动并为任何敌人设置动画，而无需担心其功能。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62a/0c9/abb/62a0c9abb59605150235ba6cec73eeb2.png" width="225" height="74"></div><br>  <i>敌人的预制等级。</i> <br><br> 让我们创建一个敌人工厂并为其分配一个预制件。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae3/ee2/345/ae3ee23456931ac6f989a763deb8b7b1.png" width="320" height="88"></div><br>  <i>资产工厂。</i> <br><br><h3> 将敌人放在野外 </h3><br> 要将敌人放到场上， <code>Game</code>必须获得指向敌人工厂的链接。 由于我们需要大量敌人，因此我们将添加一个配置选项来调整生成速度，以每秒的敌人数量表示。 可接受的范围是0.1–10，默认值为1。 <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] EnemyFactory enemyFactory = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; [SerializeField, Range(<span class="hljs-number"><span class="hljs-number">0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">10f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> spawnSpeed = <span class="hljs-number"><span class="hljs-number">1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/201/56b/338/20156b3384b45ab95d7aef5ed5397480.png" width="320" height="144"></div><br>  <i>与敌方工厂进行游戏并产生速度4。</i> <br><br> 我们将在<code>Update</code>跟踪生成的进度，以速度乘以增量时间来增加它。 如果prggress值超过1，则我们将其递减并使用新的<code>SpawnEnemy</code>方法生成敌人。 如果速度过高且帧时间过长，以至于无法同时创建多个敌人，我们将继续这样做，直到进度超过1。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> spawnProgress; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … spawnProgress += spawnSpeed * Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (spawnProgress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { spawnProgress -= <span class="hljs-number"><span class="hljs-number">1f</span></span>; SpawnEnemy(); } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">不需要在FixedUpdate中更新进度吗？</b> <div class="spoiler_text"> 是的，有可能，但是塔防游戏不需要如此精确的时间。 我们将仅在每一帧更新游戏状态，并使其在任何时间增量下都能正常运行。 </div></div><br> 让<code>SpawnEnemy</code>从字段中获得随机的生成点，并在此图块中创建一个敌人。 我们将为<code>Enemy</code> <code>SpawnOn</code>方法以正确<code>SpawnOn</code>自身。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnEnemy</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile spawnPoint = board.GetSpawnPoint(Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, board.SpawnPointCount)); Enemy enemy = enemyFactory.Get(); enemy.SpawnOn(spawnPoint); }</code> </pre> <br> 目前，所有<code>SpawnOn</code>要做的就是将其自己的位置设置为与图块的中心相等。 由于预制模型的位置正确，所以敌方立方体将位于此图块的顶部。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnOn</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { transform.localPosition = tile.transform.localPosition; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b5/74a/ce9/8b574ace93bd2c7f7829d41f9208a138.png" width="230" height="230"></div><br>  <i>敌人出现在产卵点。</i> <br><br><h2> 移动敌人 </h2><br> 敌人出现后，他必须开始沿路径移动到最近的终点。 为此，您需要为敌人设置动画。 我们从一个简单的平滑滑行开始，到另一块瓷砖，然后使它们的移动更加困难。 <br><br><h3> 收集敌人 </h3><br> 为了更新敌人的状态，我们将使用与“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">对象管理”</a>系列教程中使用的相同方法。 我们为<code>Enemy</code>添加<code>Enemy</code>通用的<code>GameUpdate</code>方法，该方法返回有关他是否还活着的信息，在此阶段，该信息将始终为真。 现在，只是让他根据时间变化而前进。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { transform.localPosition += Vector3.forward * Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br> 此外，我们需要维护一个活着的敌人列表并更新所有敌人，将它们从死敌列表中删除。 我们可以将所有这些代码放入<code>Game</code> ，但可以将其隔离并创建一个<code>EnemyCollection</code>类型。 这是一个可序列化的类，不继承任何东西。 我们给他一个添加敌人的一般方法，以及另一个更新整个集合的方法。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemyCollection</span></span> { List&lt;Enemy&gt; enemies = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Enemy&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Enemy enemy</span></span></span><span class="hljs-function">)</span></span> { enemies.Add(enemy); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; enemies.Count; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!enemies[i].GameUpdate()) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastIndex = enemies.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; enemies[i] = enemies[lastIndex]; enemies.RemoveAt(lastIndex); i -= <span class="hljs-number"><span class="hljs-number">1</span></span>; } } } }</code> </pre> <br> 现在， <code>Game</code>就足以创建一个这样的集合，在每一帧中对其进行更新并向其中添加创建的敌人。 在可能产生新敌人之后，我们将立即更新敌人，以便立即进行更新。 <br><br><pre> <code class="cs hljs"> EnemyCollection enemies = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EnemyCollection(); … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … enemies.GameUpdate(); } … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnEnemy</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … enemies.Add(enemy); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/25f/eb8/dc6/25feb8dc6f0d3a5a66be43f311cd7818.png" width="230" height="230"></div><br>  <i>敌人正在前进。</i> <br><br><h3> 一路走来 </h3><br> 敌人已经在移动，但到目前为止还没有走这条路。 为此，他们需要知道下一步去哪里。 因此，让我们为<code>GameTile</code>通用的getter属性，以获取路径上的下一个图块。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameTile NextTileOnPath =&gt; nextOnPath;</code> </pre> <br> 敌人知道要退出的地块以及需要进入的地块后，便可以确定移动一个地块的起点和终点。 敌人可以在这两点之间插入位置，以跟踪其移动。 移动完成后，对下一个图块重复此过程。 但是路径可以随时更改。 无需确定在移动过程中进一步移动的位置，我们只需继续沿着计划的路线移动并检查它，到达下一个图块即可。 <br><br> 让<code>Enemy</code>跟踪两个图块，以使其不受路径更改的影响。 他还将跟踪位置，以便我们不必在每个帧中都接收它们，并跟踪移动过程。 <br><br><pre> <code class="cs hljs"> GameTile tileFrom, tileTo; Vector3 positionFrom, positionTo; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> progress;</code> </pre> <br> 在<code>SpawnOn</code>初始化这些字段。 第一个点是敌人从其移动的图块，终点是路径上的下一个图块。 这假定存在下一个图块，除非在端点处创建了敌人，否则这是不可能的。 然后，我们缓存图块的位置并重置进度。 我们不需要在这里设置敌人的位置，因为他的<code>GameUpdate</code>方法<code>GameUpdate</code>在同一帧中调用的。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnOn</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//transform.localPosition = tile.transform.localPosition; Debug.Assert(tile.NextTileOnPath != null, "Nowhere to go!", this); tileFrom = tile; tileTo = tile.NextTileOnPath; positionFrom = tileFrom.transform.localPosition; positionTo = tileTo.transform.localPosition; progress = 0f; }</span></span></code> </pre> <br> 进度增量将在<code>GameUpdate</code>执行。 让我们添加一个恒定的时间变化量，以便敌人以每秒一格的速度移动。 进度完成后，我们将移动数据，以使<code>To</code>成为值<code>From</code> ，而新的<code>To</code>是路径上的下一个图块。 然后我们递减进度。 当数据变得有意义时，我们在<code>From</code>和<code>To</code>之间插入敌人的位置。 由于插值器是进步的，其值必须在0到1的范围内，因此我们可以使用s <code>Vector3.LerpUnclamped</code> 。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { progress += Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (progress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { tileFrom = tileTo; tileTo = tileTo.NextTileOnPath; positionFrom = positionTo; positionTo = tileTo.transform.localPosition; progress -= <span class="hljs-number"><span class="hljs-number">1f</span></span>; } transform.localPosition = Vector3.LerpUnclamped(positionFrom, positionTo, progress); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br> 这迫使敌人沿着这条路走，但在到达终点时不会行动。 因此，在更改<code>From</code>和<code>To</code>的位置之前，需要将路径上的下一个图块与<code>null</code>进行比较。 如果是这样，那么我们已经到达终点，敌人已经完成了行动。 我们为此执行Reclaim并返回<code>false</code> 。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (progress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { tileFrom = tileTo; tileTo = tileTo.NextTileOnPath; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tileTo == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { OriginFactory.Reclaim(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } positionFrom = positionTo; positionTo = tileTo.transform.localPosition; progress -= <span class="hljs-number"><span class="hljs-number">1f</span></span>; }</code> </pre> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>敌人走的路最短。</i> <br><br> 敌人现在正在从一个砖块的中心移动到另一个砖块的中心。 值得考虑的是，它们仅在砖块的中心改变其运动状态，因此它们无法立即响应野外变化。 这意味着有时敌人会穿过刚设置的墙壁。 一旦他们开始向牢房移动，没有什么可以阻止他们。 这就是为什么墙也需要真实的道路。 <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>敌人对变化的路径做出反应。</i> <br><br><h3> 边到边运动 </h3><br> 瓷砖中心之间的移动和方向的急剧变化对于抽象游戏来说是正常的，在这种抽象游戏中，敌人正在移动立方体，但通常平滑的运动看起来会更漂亮。 实施的第一步不是沿中心移动，而是沿图块的边缘移动。 <br><br> 相邻瓦片之间的边缘点可以通过平均其位置来找到。 我们仅在更改<code>GameTile.GrowPathTo</code>的路径时才对它进行计算，而不是对每个敌人都一步一步地计算。 使用<code>ExitPoint</code>属性使其可用。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 ExitPoint { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } … <span class="hljs-function"><span class="hljs-function">GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { … neighbor.ExitPoint = (neighbor.transform.localPosition + transform.localPosition) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> neighbor.Content.Type != GameTileContentType.Wall ? neighbor : <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br> 唯一的特殊情况是最终单元格，其出口点将是其中心。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BecomeDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; nextOnPath = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; ExitPoint = transform.localPosition; }</code> </pre> <br> 更改<code>Enemy</code> ，使其使用出口点而不是平铺中心。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { progress += Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (progress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { … positionTo = tileFrom.ExitPoint; progress -= <span class="hljs-number"><span class="hljs-number">1f</span></span>; } transform.localPosition = Vector3.Lerp(positionFrom, positionTo, progress); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnOn</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { … positionTo = tileFrom.ExitPoint; progress = <span class="hljs-number"><span class="hljs-number">0f</span></span>; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>敌人在边缘之间移动。</i> <br><br> 这种变化的副作用是，当敌人由于路径变化而转弯时，它们会保持一秒钟不动。 <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>转身时，敌人会停止。</i> <br><br><h3> 方向 </h3><br> 尽管敌人沿着小路移动，直到他们改变方向。 为了使他们可以看向运动方向，他们需要知道他们所遵循的路径的方向。 我们还将在寻找方法的过程中确定这一点，这样敌人就不必这样做了。 <br><br> 我们有四个方向：北，东，南和西。 让我们列举一下。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Direction { North, East, South, West }</code> </pre> <br> 然后，我们给<code>GameTile</code>属性存储其路径的方向。 <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Direction PathDirection { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br> 将方向参数添加到<code>GrowTo</code> ，以设置属性。 由于我们从头到尾都在发展一条道路，因此方向将与我们从那开始的道路相反。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathNorth</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(north, Direction.South); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathEast</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(east, Direction.West); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathSouth</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(south, Direction.North); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathWest</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(west, Direction.East); <span class="hljs-function"><span class="hljs-function">GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor, Direction direction</span></span></span><span class="hljs-function">)</span></span> { … neighbor.PathDirection = direction; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> neighbor.Content.Type != GameTileContentType.Wall ? neighbor : <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br> 我们需要将方向转换为以四元数表示的转弯。 如果我们可以只调用<code>GetRotation</code>作为方向，那将很方便，因此让我们通过创建扩展方法来实现。 添加一般的静态方法<code>DirectionExtensions</code> ，为其提供一个数组以缓存必要的四元数，并添加<code>GetRotation</code>方法以返回相应的方向值。 在这种情况下，将扩展类与枚举类型放在同一文件中是有意义的。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Direction { North, East, South, West } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DirectionExtensions</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Quaternion[] rotations = { Quaternion.identity, Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">180f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">270f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Quaternion </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRotation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Direction direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rotations[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction]; } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">什么是扩展方法？</b> <div class="spoiler_text"> 扩展方法是静态类内部的静态方法，其行为类似于某种类型的实例方法。 此类型可以是类，接口，结构，原始值或枚举。 扩展方法的第一个参数必须具有<code>this</code> 。 它定义该方法将使用的类型和实例的值。 这种方法意味着无法扩展属性。 <br><br> 这是否允许您将方法添加到任何内容？ 是的，就像您可以编写任何参数为任何类型的静态方法一样。 </div></div><br> 现在，我们可以在生成时以及每次输入新的图块时旋转<code>Enemy</code> 。 更新数据后，“ <code>From</code>磁贴为我们提供了方向。 <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { progress += Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (progress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { … transform.localRotation = tileFrom.PathDirection.GetRotation(); progress -= <span class="hljs-number"><span class="hljs-number">1f</span></span>; } transform.localPosition = Vector3.LerpUnclamped(positionFrom, positionTo, progress); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnOn</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { … transform.localRotation = tileFrom.PathDirection.GetRotation(); progress = <span class="hljs-number"><span class="hljs-number">0f</span></span>; }</code> </pre> <br><h3> 方向改变 </h3><br> 与其立即改变方向，不如在转弯之间插值，就像我们在位置之间插值一样。 要从一个方向转到另一个方向，我们需要知道需要完成的方向更改：无需转弯，右转，左转或后退。 为此，我们添加了一个枚举，该枚举又可以与<code>Direction</code>放置在同一文件中，因为它们很小并且紧密相关。 <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Direction { North, East, South, West } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> DirectionChange { None, TurnRight, TurnLeft, TurnAround }</code> </pre> <br> 添加另一个扩展方法，这一次是<code>GetDirectionChangeTo</code> ，它将返回从当前方向到下一个方向的方向更改。 如果方向一致，则没有移动。 如果下一个大于当前，则向右转。 但是由于重复了这些指示，因此下一个比当前指示少三个时，情况相同。 左转弯将是相同的，只有加法和减法会切换位置。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 剩下的唯一情况是转身。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> DirectionChange </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDirectionChangeTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Direction current, Direction next </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == next) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DirectionChange.None; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current + <span class="hljs-number"><span class="hljs-number">1</span></span> == next || current - <span class="hljs-number"><span class="hljs-number">3</span></span> == next) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DirectionChange.TurnRight; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current - <span class="hljs-number"><span class="hljs-number">1</span></span> == next || current + <span class="hljs-number"><span class="hljs-number">3</span></span> == next) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DirectionChange.TurnLeft; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DirectionChange.TurnAround; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们仅在一个维度上旋转，因此角度的线性插值对我们而言已足够。</font><font style="vertical-align: inherit;">添加另一种扩展方法，以度为单位获取方向角。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAngle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Direction direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)direction * <span class="hljs-number"><span class="hljs-number">90f</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，您必须</font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">跟踪需要进行插值的方向，方向变化和角度。</font></font><br><br><pre> <code class="cs hljs"> Direction direction; DirectionChange directionChange; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> directionAngleFrom, directionAngleTo;</code> </pre> <br> <code>SpawnOn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">变得越来越困难，所以让我们将状态准备代码移到另一种方法。</font><font style="vertical-align: inherit;">我们会将敌人的初始状态指定为入门状态，因此我们将其称为</font></font><code>PrepareIntro</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在这种状态下，敌人从中心移动到其初始图块的边缘，因此方向不变。</font><font style="vertical-align: inherit;">角度</font></font><code>From</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">相同的。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnOn</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(tile.NextTileOnPath != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Nowhere to go!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); tileFrom = tile; tileTo = tile.NextTileOnPath; <span class="hljs-comment"><span class="hljs-comment">//positionFrom = tileFrom.transform.localPosition; //positionTo = tileFrom.ExitPoint; //transform.localRotation = tileFrom.PathDirection.GetRotation(); progress = 0f; PrepareIntro(); } void PrepareIntro () { positionFrom = tileFrom.transform.localPosition; positionTo = tileFrom.ExitPoint; direction = tileFrom.PathDirection; directionChange = DirectionChange.None; directionAngleFrom = directionAngleTo = direction.GetAngle(); transform.localRotation = direction.GetRotation(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这个阶段，我们创建类似小型状态机的东西。</font><font style="vertical-align: inherit;">为简化起见</font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，请将状态代码移至新方法</font></font><code>PrepareNextState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们将仅保留磁贴</font></font><code>From</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font><font style="vertical-align: inherit;">的更改</font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为我们在此处使用它们来检查敌人是否完成了路径。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { progress += Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (progress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { … <span class="hljs-comment"><span class="hljs-comment">//positionFrom = positionTo; //positionTo = tileFrom.ExitPoint; //transform.localRotation = tileFrom.PathDirection.GetRotation(); progress -= 1f; PrepareNextState(); } … }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">过渡到新状态时，您始终需要更改位置，查找方向更改，更新当前方向并将角度</font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">移至</font></font><code>From</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们不再转弯。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareNextState</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { positionFrom = positionTo; positionTo = tileFrom.ExitPoint; directionChange = direction.GetDirectionChangeTo(tileFrom.PathDirection); direction = tileFrom.PathDirection; directionAngleFrom = directionAngleTo; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其他动作取决于方向的改变。</font><font style="vertical-align: inherit;">让我们为每个选项添加一个方法。</font><font style="vertical-align: inherit;">如果我们向前移动，则角度</font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与当前单元格路径的方向重合。</font><font style="vertical-align: inherit;">此外，我们需要设置旋转角度，以使敌人直视前方。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareForward</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { transform.localRotation = direction.GetRotation(); directionAngleTo = direction.GetAngle(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在转弯的情况下，我们不会立即转弯。</font><font style="vertical-align: inherit;">我们需要插值一个不同的角度：向右转90度，向左转90度，向后转180°。</font><font style="vertical-align: inherit;">为了避免由于角度值从359°变为0°而导致转向错误，</font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">应该相对于当前方向指示</font><font style="vertical-align: inherit;">角度</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们无需担心角度会小于0°或大于360°，因为我们</font></font><code>Quaternion.Euler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以处理它。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnRight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + <span class="hljs-number"><span class="hljs-number">90f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnLeft</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom - <span class="hljs-number"><span class="hljs-number">90f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnAround</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + <span class="hljs-number"><span class="hljs-number">180f</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，</font></font><code>PrepareNextState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以使用</font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">更改方向来确定要调用的四种方法中的哪一种。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareNextState</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (directionChange) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DirectionChange.None: PrepareForward(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DirectionChange.TurnRight: PrepareTurnRight(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DirectionChange.TurnLeft: PrepareTurnLeft(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: PrepareTurnAround(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在最后，</font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们需要检查方向是否已更改。</font><font style="vertical-align: inherit;">如果是这样，则在两个角之间进行插值并设置旋转角度。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … transform.localPosition = Vector3.LerpUnclamped(positionFrom, positionTo, progress); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (directionChange != DirectionChange.None) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> angle = Mathf.LerpUnclamped( directionAngleFrom, directionAngleTo, progress ); transform.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, angle, <span class="hljs-number"><span class="hljs-number">0f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">敌人在转。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 曲线运动 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以通过使敌人在转弯时沿着曲线移动来改善运动。</font><font style="vertical-align: inherit;">让它们走四分之一圈而不是从砖的边缘到边缘走。</font><font style="vertical-align: inherit;">这个圈子里的谎言在角落里常见到砖的中心</font></font><code>From</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，在同一边缘上的瓷砖进入了敌人</font></font><code>From</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d7/8a6/3a5/1d78a63a58d34a1d8cc9ff56a0b23cc3.png" width="256" height="256"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">四分之一圈旋转以向右转。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们可以通过使用三角函数沿弧形移动敌人，同时旋转敌人来实现这一点。</font><font style="vertical-align: inherit;">但这可以通过仅旋转将敌人坐标的本地原点暂时移动到圆心来简化。</font><font style="vertical-align: inherit;">为此，我们需要更改敌人模型的位置，因此我们将提供</font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此模型</font><font style="vertical-align: inherit;">的</font><font style="vertical-align: inherit;">链接，可通过配置字段访问</font><font style="vertical-align: inherit;">该</font><font style="vertical-align: inherit;">链接。</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] Transform model = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/72b/13c/28e/72b13c28ed9d6a8d34f3e17536e964cd.png" width="320" height="56"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与模型有关的敌人。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了准备前进或后退，模型应移动到标准位置，即敌人坐标的本地原点。</font><font style="vertical-align: inherit;">否则，必须将模型偏移测量单位的一半-旋转圆的半径，远离转折点。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareForward</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { transform.localRotation = direction.GetRotation(); directionAngleTo = direction.GetAngle(); model.localPosition = Vector3.zero; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnRight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + <span class="hljs-number"><span class="hljs-number">90f</span></span>; model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnLeft</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom - <span class="hljs-number"><span class="hljs-number">90f</span></span>; model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnAround</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + <span class="hljs-number"><span class="hljs-number">180f</span></span>; model.localPosition = Vector3.zero; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，敌人本人需要转移到转折点。</font><font style="vertical-align: inherit;">为此，还必须将其移动半个测量单位，但是确切的偏移量取决于方向。</font><font style="vertical-align: inherit;">让我们为它添加</font></font><code>Direction</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个辅助扩展方法</font></font><code>GetHalfVector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Vector3[] halfVectors = { Vector3.forward * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, Vector3.right * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, Vector3.back * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, Vector3.left * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> }; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHalfVector</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Direction direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> halfVectors[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 向右或向左旋转时，添加相应的向量。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnRight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + <span class="hljs-number"><span class="hljs-number">90f</span></span>; model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); transform.localPosition = positionFrom + direction.GetHalfVector(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnLeft</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom - <span class="hljs-number"><span class="hljs-number">90f</span></span>; model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); transform.localPosition = positionFrom + direction.GetHalfVector(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 当回头时，该位置应为通常的起点。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnAround</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + <span class="hljs-number"><span class="hljs-number">180f</span></span>; model.localPosition = Vector3.zero; transform.localPosition = positionFrom; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另外，在计算出口点时，我们可以使用</font></font><code>GameTile.GrowPathTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">向量的一半，这样就无需访问图块的两个位置。</font></font><br><br><pre> <code class="cs hljs"> neighbor.ExitPoint = neighbor.transform.localPosition + direction.GetHalfVector();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，在更改方向时，我们不必插值中的位置</font></font><code>Enemy.GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，因为旋转参与了运动。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (directionChange == DirectionChange.None) { transform.localPosition = Vector3.LerpUnclamped(positionFrom, positionTo, progress); } <span class="hljs-comment"><span class="hljs-comment">//if (directionChange != DirectionChange.None) { else { float angle = Mathf.LerpUnclamped( directionAngleFrom, directionAngleTo, progress ); transform.localRotation = Quaternion.Euler(0f, angle, 0f); } return true; }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">敌人在拐角处平稳弯曲。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 恒速 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到目前为止，敌人的速度始终等于每秒1个图块，无论它们在图块内部如何移动。</font><font style="vertical-align: inherit;">但是它们覆盖的距离取决于其状况，因此它们的速度（以每秒单位表示）会有所不同。</font><font style="vertical-align: inherit;">为了使此速度恒定，我们需要根据状态更改进度速度。</font><font style="vertical-align: inherit;">因此，添加进度乘数字段并使用它来缩放中的增量</font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> progress, progressFactor; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { progress += Time.deltaTime * progressFactor; … }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，如果进度根据状态而变化，则剩余的进度值不能直接用于下一个状态。</font><font style="vertical-align: inherit;">因此，在准备新状态之前，我们需要标准化进度并在新状态下应用新的乘数。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { progress += Time.deltaTime * progressFactor; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (progress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { … <span class="hljs-comment"><span class="hljs-comment">//progress -= 1f; progress = (progress - 1f) / progressFactor; PrepareNextState(); progress *= progressFactor; } … }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">向前移动不需要更改，因此它使用的系数为1。向右或向左转时，敌人经过了半径为½的四分之一圆，因此覆盖的距离为¼π。</font></font><code>progress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">等于一除以该值。</font><font style="vertical-align: inherit;">向后转弯应该不会花费太多时间，因此请将进度加倍，以便半秒钟。</font><font style="vertical-align: inherit;">最后，介绍性运动仅覆盖了瓷砖的一半，因此，要保持恒定的速度，其进度也需要加倍。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareForward</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnRight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (Mathf.PI * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnLeft</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (Mathf.PI * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnAround</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … progressFactor = <span class="hljs-number"><span class="hljs-number">2f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareIntro</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … progressFactor = <span class="hljs-number"><span class="hljs-number">2f</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为什么距离等于1/4 * pi？</font></font></b> <div class="spoiler_text"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">周长是半径的2π倍。</font><font style="vertical-align: inherit;">向右或向左旋转仅覆盖此长度的四分之一，半径为½，因此距离为½π×½。</font></font></div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 最终状态 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于我们有一个介绍性的状态，让我们添加最后一个状态。</font><font style="vertical-align: inherit;">目前，敌人到达端点后会立即消失，但让我们将它们的消失推迟到到达末端图块的中心。</font><font style="vertical-align: inherit;">让我们为此创建一个方法</font></font><code>PrepareOutro</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，设置向前移动，但仅将其移动到图块的中心，进度加倍以保持恒定的速度。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareOutro</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { positionTo = tileFrom.transform.localPosition; directionChange = DirectionChange.None; directionAngleTo = direction.GetAngle(); model.localPosition = Vector3.zero; transform.localRotation = direction.GetRotation(); progressFactor = <span class="hljs-number"><span class="hljs-number">2f</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了</font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不及早消灭敌人，我们将取消其平移。</font><font style="vertical-align: inherit;">他现在就做</font></font><code>PrepareNextState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">因此，</font><font style="vertical-align: inherit;">仅在最终状态结束之后</font><font style="vertical-align: inherit;">检查</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">返回</font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { progress += Time.deltaTime * progressFactor; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (progress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//tileFrom = tileTo; //tileTo = tileTo.NextTileOnPath; if (tileTo == null) { OriginFactory.Reclaim(this); return false; } … } … }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">随着</font></font><code>PrepareNextState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们开始转向瓷砖。</font><font style="vertical-align: inherit;">然后，在设置位置之后</font></font><code>From</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但在设置位置之前，</font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将检查图块是否等于</font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">值</font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果是这样，则准备最终状态并跳过其余方法。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareNextState</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { tileFrom = tileTo; tileTo = tileTo.NextTileOnPath; positionFrom = positionTo; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tileTo == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { PrepareOutro(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } positionTo = tileFrom.ExitPoint; … }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有恒定速度和最终状态的敌人。</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 敌人变异 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们有一连串的敌人，它们都是相同的立方体，以相同的速度移动。</font><font style="vertical-align: inherit;">结果更像是一条长长的蛇，而不是单个敌人。</font><font style="vertical-align: inherit;">让我们通过随机化它们的大小，位移和速度来使其与众不同。</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 浮点值范围 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将更改敌人的参数，从值的范围内随机选择其特征。</font></font><code>FloatRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们在“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对象管理，配置形状”一</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文中创建</font><font style="vertical-align: inherit;">的结构</font><font style="vertical-align: inherit;">在</font><font style="vertical-align: inherit;">这里很有用</font><font style="vertical-align: inherit;">，因此让我们对其进行复制。</font><font style="vertical-align: inherit;">唯一的变化是使用一个参数添加了一个构造函数，并使用readonly-properties打开了对最小值和最大值的访问，因此间隔是不可更改的。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> FloatRange { [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> min, max; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Min =&gt; min; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Max =&gt; max; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> RandomValueInRange { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Random.Range(min, max); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FloatRange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { min = max = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FloatRange</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> min, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> max</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.min = min; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.max = max &lt; min ? min : max; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我们还将属性集复制到该属性集以限制其间隔。 </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">FloatRangeSliderAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">PropertyAttribute</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Min { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Max { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FloatRangeSliderAttribute</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> min, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> max</span></span></span><span class="hljs-function">)</span></span> { Min = min; Max = max &lt; min ? min : max; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们仅需要滑块的可视化，因此将其复制</font></font><code>FloatRangeSliderDrawer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">到</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editor</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">文件夹</font><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEditor; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [CustomPropertyDrawer(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(FloatRangeSliderAttribute))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">FloatRangeSliderDrawer</span></span> : <span class="hljs-title"><span class="hljs-title">PropertyDrawer</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnGUI</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Rect position, SerializedProperty property, GUIContent label </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalIndentLevel = EditorGUI.indentLevel; EditorGUI.BeginProperty(position, label, property); position = EditorGUI.PrefixLabel( position, GUIUtility.GetControlID(FocusType.Passive), label ); EditorGUI.indentLevel = <span class="hljs-number"><span class="hljs-number">0</span></span>; SerializedProperty minProperty = property.FindPropertyRelative(<span class="hljs-string"><span class="hljs-string">"min"</span></span>); SerializedProperty maxProperty = property.FindPropertyRelative(<span class="hljs-string"><span class="hljs-string">"max"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> minValue = minProperty.floatValue; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> maxValue = maxProperty.floatValue; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fieldWidth = position.width / <span class="hljs-number"><span class="hljs-number">4f</span></span> - <span class="hljs-number"><span class="hljs-number">4f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sliderWidth = position.width / <span class="hljs-number"><span class="hljs-number">2f</span></span>; position.width = fieldWidth; minValue = EditorGUI.FloatField(position, minValue); position.x += fieldWidth + <span class="hljs-number"><span class="hljs-number">4f</span></span>; position.width = sliderWidth; FloatRangeSliderAttribute limit = attribute <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> FloatRangeSliderAttribute; EditorGUI.MinMaxSlider( position, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> minValue, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> maxValue, limit.Min, limit.Max ); position.x += sliderWidth + <span class="hljs-number"><span class="hljs-number">4f</span></span>; position.width = fieldWidth; maxValue = EditorGUI.FloatField(position, maxValue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (minValue &lt; limit.Min) { minValue = limit.Min; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maxValue &lt; minValue) { maxValue = minValue; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maxValue &gt; limit.Max) { maxValue = limit.Max; } minProperty.floatValue = minValue; maxProperty.floatValue = maxValue; EditorGUI.EndProperty(); EditorGUI.indentLevel = originalIndentLevel; } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 模型规模 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们将从改变敌人的规模开始。</font></font><code>EnemyFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将比例设置</font><font style="vertical-align: inherit;">添加到该</font><font style="vertical-align: inherit;">选项。</font><font style="vertical-align: inherit;">标度间隔不应太大，但应足以制造出微型而庞大的敌人。</font><font style="vertical-align: inherit;">在0.5–2之间且标准值为1的任何值。我们将在此间隔中选择一个随机标度，</font></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后通过一种新方法将其传递给敌人</font></font><code>Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, FloatRangeSlider(0.5f, 2f)</span></span>] FloatRange scale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">1f</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Enemy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Enemy instance = CreateGameObjectInstance(prefab); instance.OriginFactory = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; instance.Initialize(scale.RandomValueInRange); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该方法</font></font><code>Enemy.Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">只是将其模型的比例尺设置为在所有维度上都相同。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale</span></span></span><span class="hljs-function">)</span></span> { model.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(scale, scale, scale); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a7/cc3/f08/1a7cc3f082406d5c8672125ceb94913c.png" width="320" height="60" alt="检查员"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffe/396/7cf/ffe3967cfcfb6391269a5a7691317c60.png" width="230" height="230" alt="场景"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">刻度范围是0.5到1.5。</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 路径偏移 </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了进一步破坏敌人流动的均匀性，我们可以更改敌人在地砖内的相对位置。它们向前移动，因此沿该方向的移动只会改变其运动的时机，这并不是很明显。因此，我们会将它们移到侧面，远离通过瓷砖中心的理想路径。将一个</font></font><code>EnemyFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">路径偏移量</font><font style="vertical-align: inherit;">添加到该</font><font style="vertical-align: inherit;">间隔，并将随机偏移量传递给该方法</font></font><code>Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。偏移量可以是负数，也可以是正数，但不能超过½，因为这会将敌人移动到相邻的图块。此外，我们不希望敌人超出其跟随的范围，因此实际上间隔会更短，例如0.4，但是真正的限制取决于敌人的大小。</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, FloatRangeSlider(-0.4f, 0.4f)</span></span>] FloatRange pathOffset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Enemy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Enemy instance = CreateGameObjectInstance(prefab); instance.OriginFactory = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; instance.Initialize( scale.RandomValueInRange, pathOffset.RandomValueInRange ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于路径的位移会影响行进的路径，</font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此有必要对其进行跟踪。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> pathOffset; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathOffset</span></span></span><span class="hljs-function">)</span></span> { model.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(scale, scale, scale); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.pathOffset = pathOffset; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当完全笔直移动时（在介绍性，最终性或法向向前移动期间），我们只需将偏移量直接应用于模型即可。</font><font style="vertical-align: inherit;">回头时也会发生同样的事情。</font><font style="vertical-align: inherit;">通过右转或左转，我们已经移动了模型，该模型相对于路径的位移。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareForward</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { transform.localRotation = direction.GetRotation(); directionAngleTo = direction.GetAngle(); model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(pathOffset, <span class="hljs-number"><span class="hljs-number">0f</span></span>); progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnRight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + <span class="hljs-number"><span class="hljs-number">90f</span></span>; model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(pathOffset - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); transform.localPosition = positionFrom + direction.GetHalfVector(); progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (Mathf.PI * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnLeft</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom - <span class="hljs-number"><span class="hljs-number">90f</span></span>; model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(pathOffset + <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); transform.localPosition = positionFrom + direction.GetHalfVector(); progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (Mathf.PI * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnAround</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + <span class="hljs-number"><span class="hljs-number">180f</span></span>; model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(pathOffset, <span class="hljs-number"><span class="hljs-number">0f</span></span>); transform.localPosition = positionFrom; progressFactor = <span class="hljs-number"><span class="hljs-number">2f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareIntro</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(pathOffset, <span class="hljs-number"><span class="hljs-number">0f</span></span>); transform.localRotation = direction.GetRotation(); progressFactor = <span class="hljs-number"><span class="hljs-number">2f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareOutro</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(pathOffset, <span class="hljs-number"><span class="hljs-number">0f</span></span>); transform.localRotation = direction.GetRotation(); progressFactor = <span class="hljs-number"><span class="hljs-number">2f</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于旋转过程中路径的位移会改变半径，因此我们需要更改进度乘数的计算过程。</font><font style="vertical-align: inherit;">必须从½中减去路径偏移量，以使转弯半径向右，并在向左转弯的情况下增加。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnRight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (Mathf.PI * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * (<span class="hljs-number"><span class="hljs-number">0.5f</span></span> - pathOffset)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnLeft</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (Mathf.PI * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * (<span class="hljs-number"><span class="hljs-number">0.5f</span></span> + pathOffset)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">旋转180°时，我们还获得了旋转半径。在这种情况下，我们用半径等于路径偏移的半径覆盖了一半的圆，因此距离是偏移的π倍。但是，当位移为零时，这是行不通的；在小​​位移下，转弯过快。为了避免瞬时转弯，我们可以强制最小半径来计算速度，例如0.2。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnAround</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + (pathOffset &lt; <span class="hljs-number"><span class="hljs-number">0f</span></span> ? <span class="hljs-number"><span class="hljs-number">180f</span></span> : <span class="hljs-number"><span class="hljs-number">-180f</span></span>); model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(pathOffset, <span class="hljs-number"><span class="hljs-number">0f</span></span>); transform.localPosition = positionFrom; progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (Mathf.PI * Mathf.Max(Mathf.Abs(pathOffset), <span class="hljs-number"><span class="hljs-number">0.2f</span></span>)); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1db/8b2/b16/1db8b2b164cba05ff6f8fe7ffa0eed71.png" width="320" height="40" alt="检查员"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">路径偏移量在-0.25–0.25范围内。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">请注意，现在敌人即使转弯也不会改变其相对路径位移。因此，每个敌人的总路径长度各有不同。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了防止敌人到达附近的砖块，还必须考虑其最大可能的规模。我只是将大小限制为最大值1，因此多维数据集的最大允许偏移为0.25。如果最大尺寸为1.5，则最大位移应减小到0.125。</font></font><br><br><h3> 速度 </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们随机化的最后一件事是敌人的速度。</font><font style="vertical-align: inherit;">我们为其添加一个间隔，</font></font><code>EnemyFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">并将价值转移到创建的敌人副本中。</font><font style="vertical-align: inherit;">让我们将其作为method的第二个参数</font></font><code>Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">敌人不要太慢或太快，以免游戏变得简单或不可能。</font><font style="vertical-align: inherit;">让我们将间隔限制为0.2-5。</font><font style="vertical-align: inherit;">速度以每秒单位表示，仅在向前移动时才对应于每秒瓦片。</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, FloatRangeSlider(0.2f, 5f)</span></span>] FloatRange speed = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">1f</span></span>); [SerializeField, FloatRangeSlider(<span class="hljs-number"><span class="hljs-number">-0.4f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>)] FloatRange pathOffset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Enemy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Enemy instance = CreateGameObjectInstance(prefab); instance.OriginFactory = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; instance.Initialize( scale.RandomValueInRange, speed.RandomValueInRange, pathOffset.RandomValueInRange ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我</font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">必须跟踪和加快速度。</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed; … <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathOffset</span></span></span><span class="hljs-function">)</span></span> { model.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(scale, scale, scale); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.speed = speed; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.pathOffset = pathOffset; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 当我们没有明确设置速度时，我们仅使用值1。现在，我们只需要创建进度乘数对速度的依赖关系即可。 </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareForward</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … progressFactor = speed; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnRight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … progressFactor = speed / (Mathf.PI * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * (<span class="hljs-number"><span class="hljs-number">0.5f</span></span> - pathOffset)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnLeft</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … progressFactor = speed / (Mathf.PI * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * (<span class="hljs-number"><span class="hljs-number">0.5f</span></span> + pathOffset)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnAround</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … progressFactor = speed / (Mathf.PI * Mathf.Max(Mathf.Abs(pathOffset), <span class="hljs-number"><span class="hljs-number">0.2f</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareIntro</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … progressFactor = <span class="hljs-number"><span class="hljs-number">2f</span></span> * speed; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareOutro</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { … progressFactor = <span class="hljs-number"><span class="hljs-number">2f</span></span> * speed; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b8/e55/eeb/0b8e55eeb25d36349f606f0da60d3720.png" width="320" height="60"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">速度范围为0.75-1.25。</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，我们有许多敌人流向终点。</font><font style="vertical-align: inherit;">在下一个教程中，我们将学习如何处理它们。</font><font style="vertical-align: inherit;">是否想知道何时发布？</font><font style="vertical-align: inherit;">按照我在</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patreon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上的</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">页面</font></a><font style="vertical-align: inherit;">！</font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">资料库</font></font></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PDF文章</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN452756/">https://habr.com/ru/post/zh-CN452756/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN452746/index.html">《 R.沉浸在大数据中的编程艺术》一书</a></li>
<li><a href="../zh-CN452748/index.html">NGINX开发现代应用程序的原理。 第一部分</a></li>
<li><a href="../zh-CN452750/index.html">OpenLiteSpeed内部和外部的Nextcloud：配置反向代理</a></li>
<li><a href="../zh-CN452752/index.html">自制BigData。 第1部分。AWS集群上的Spark流实践</a></li>
<li><a href="../zh-CN452754/index.html">19％的最受欢迎的Docker映像没有root密码</a></li>
<li><a href="../zh-CN452760/index.html">维生素D。喝还是不喝，这就是问题所在。 （或关于我如何通过了未按规定进行分析的故事）</a></li>
<li><a href="../zh-CN452762/index.html">MVCC-7。 自动清洁</a></li>
<li><a href="../zh-CN452764/index.html">[Peter]与Sergei Melnikov会面JUG.ru-超光速分析：理论与实践</a></li>
<li><a href="../zh-CN452766/index.html">渐进式流技术，或如何通过网络观看4k视频而不会感到烦恼</a></li>
<li><a href="../zh-CN452768/index.html">如果您决定进入国外市场，如何设计产品</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>