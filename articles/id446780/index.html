<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖨️ 👂🏿 👋🏿 Cara membuat tema gelap dan tidak membahayakan. Pengalaman Tim Yandex.Mail 👨🏽‍💻 🙎🏻 🕝</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nama saya Vladimir, saya terlibat dalam antarmuka seluler di Yandex.Mail. Dalam aplikasi kami, sudah ada topik gelap, tetapi tidak cukup: kami bisa me...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara membuat tema gelap dan tidak membahayakan. Pengalaman Tim Yandex.Mail</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/446780/"><p><img src="https://habrastorage.org/webt/ji/4q/pr/ji4qprfkpuotssmzabus4cjflrq.png"></p><br><p>  Nama saya Vladimir, saya terlibat dalam antarmuka seluler di Yandex.Mail.  Dalam aplikasi kami, sudah ada topik gelap, tetapi tidak cukup: kami bisa mengecat ulang antarmuka dan huruf-huruf sederhana.  Tetapi surat-surat yang diformat tetap terang dan kontras dengan antarmuka gelap, yang bisa membuat mata saya lelah di malam hari. </p><br><p>  Hari ini saya akan memberi tahu para pembaca Habr bagaimana kami memecahkan masalah ini.  Anda akan belajar tentang dua metode sederhana yang tidak sesuai dengan kita, kemudian - tentang cara utama kita mengecat ulang halaman dan, akhirnya, tentang arah untuk iterasi berikutnya: mengecat ulang gambar.  Meskipun tugas itu sendiri - mengecat halaman dengan pemformatan sewenang-wenang - bersifat spesifik, saya pikir pengalaman kami juga akan berguna bagi Anda. </p><a name="habracut"></a><br><h2 id="prostye-sposoby">  Cara sederhana </h2><br><p>  Sebelum kita sampai ke "repainter" ajaib kami, kami mencoba dua opsi sederhana seperti gabus: menggantung gaya gelap tambahan atau filter CSS pada elemen.  Mereka tidak cocok untuk kita, tetapi mungkin untuk beberapa kasus mereka akan lebih baik (karena itu hanya = keren). </p><br><h3 id="pereopredelenie-stiley">  Timpa gaya </h3><br><p>  Cara paling sederhana, secara logis memperluas tema gelap aplikasi itu sendiri dalam CSS: kita akan menggantung gaya gelap pada wadah untuk surat (dalam kasus umum, untuk konten orang lain yang perlu dicat ulang): </p><br><pre><code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.message--dark</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">background-color</span></span>: black; <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: white; }</code> </pre> <br><p>  Tetapi jika elemen-elemen di dalam surat memiliki gaya mereka sendiri, mereka akan mendefinisikan ulang gaya root kami.  Tidak <code>!important</code> tidak akan membantu.  Anda dapat memeras ide dengan memenggal warisan: </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.message--dark</span></span> * { <span class="hljs-attribute"><span class="hljs-attribute">background-color</span></span>: black <span class="hljs-meta"><span class="hljs-meta">!important</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">color</span></span>: white <span class="hljs-meta"><span class="hljs-meta">!important</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">border-color</span></span>: <span class="hljs-number"><span class="hljs-number">#333</span></span> <span class="hljs-meta"><span class="hljs-meta">!important</span></span>; }</code> </pre> <br><p>  Dalam hal ini, Anda tidak dapat melakukannya tanpa <code>!important</code> , karena pemilih itu sendiri tidak terlalu spesifik.  Selain itu, akan diperlukan untuk mendefinisikan ulang gaya inline (dan gaya inline dengan <code>!important</code> tetap akan merangkak, tidak ada yang harus dilakukan). </p><br><p>  Gaya kami agak canggung dan warna semuanya sama, jadi masalah lain muncul: mungkin desainer ingin mengatakan sesuatu dengan mengatur warna (prioritas elemen dan hal-hal desainer lainnya), tetapi kami mengambil dan membuang seluruh gagasan ini. </p><br><p><img src="https://habrastorage.org/webt/cu/-1/ka/cu-1kav8ydvyjxlobshlklgio9u.png"></p><br><p>  Jika Anda kurang menghargai desainer daripada saya, dan masih memutuskan untuk menggunakan metode ini, jangan lupa untuk menyelesaikan hal-hal sepele yang tidak terlihat: </p><br><ul><li>  <code>box-shadow</code> - hanya warna yang tidak dapat didefinisikan ulang, Anda harus menghapus semua bayangan atau hidup dengan yang terang. </li><li>  Warna elemen semantik - tautan, elemen input. </li><li>  SVG sebaris - alih-alih <code>background</code> mereka perlu mengatur <code>fill</code> , dan bukannya <code>stroke</code> <code>color</code> , tapi ini tidak akurat, tergantung pada SVG mana - itu bisa dan sebaliknya. </li></ul><br><p>  Secara teknis, metode ini tidak buruk: ini adalah tiga baris kode (oke, tiga puluh untuk versi produksi dengan kasus sudut), kompatibilitas dengan semua browser di dunia, pemrosesan halaman dinamis di luar kotak dan tidak ada ikatan dengan cara menghubungkan gaya dalam dokumen asli.  Bonus khusus adalah Anda dapat dengan mudah mengubah warna dalam gaya sehingga cocok dengan aplikasi utama (katakanlah, buat latar belakang <code>#bbbbb8</code> bukan hitam). </p><br><p>  Ngomong-ngomong, kami biasa mengecat ulang surat dengan cara ini, tetapi jika kami menemukan gaya apa pun di dalam surat itu, kami takut dan membiarkan lampu itu menyala. </p><br><h3 id="css-filtr">  Filter CSS </h3><br><p>  Opsi yang sangat cerdas dan elegan.  Anda dapat mengecat ulang halaman dengan filter CSS: </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.message--dark</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">filter</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">invert</span></span>(100) <span class="hljs-built_in"><span class="hljs-built_in">hue-rotate</span></span>(180deg); <span class="hljs-comment"><span class="hljs-comment">/* hue-rotate    */</span></span> }</code> </pre> <br><p>  Setelah ini, foto-foto akan menjadi menyeramkan, tetapi tidak masalah - kami akan mengecatnya kembali: </p><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.message-dark</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">img</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">filter</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">invert</span></span>(100) <span class="hljs-built_in"><span class="hljs-built_in">hue-rotate</span></span>(180deg); }</code> </pre> <br><p><img src="https://habrastorage.org/webt/dr/3a/ix/dr3aix8opihd2nlq6oqzjfbdtvs.png"></p><br><p>  Masih ada masalah dengan gambar konten yang diikat melalui <code>background</code> (kami tahu bahwa lebih mudah untuk menyesuaikan rasio aspek, tetapi bagaimana dengan semantik?).  Misalkan kita dapat menemukan semua elemen seperti itu, tandai secara eksplisit dan cat ulang. </p><br><p>  Metode ini bagus karena mempertahankan rasio kecerahan dan kontras yang asli.  Di sisi lain, ada banyak masalah, dan mereka lebih penting daripada keuntungan: </p><br><p><img src="https://habrastorage.org/webt/ed/qe/h1/edqeh1dpkqv-w2gydobzojuaia0.png" width="300"></p><br><ol><li>  Halaman gelap menjadi terang. </li><li>  Warna yang dihasilkan tidak dapat dikontrol - filter mana yang diterapkan untuk menyempurnakan latar belakang ke <code>#bbbbb8</code> perusahaan Anda?  Teka-teki itu. </li><li>  Setelah dua kali pengecatan ulang, gambar memudar. </li><li>  Semuanya melambat (terutama pada ponsel) - ini logis, sekarang alih-alih rendering sederhana yang dibutuhkan browser untuk mendorong pemrosesan gambar di setiap layar. </li></ol><br><p>  Metode ini cocok untuk huruf-huruf yang terdiri dari teks dengan nada netral, tetapi siapa aesthetes yang mendapatkan kotak masuk lengkap dari konten aneh seperti itu?  Tetapi filter dapat mengecat ulang elemen yang isinya tidak dapat diakses - bingkai, komponen web, gambar. </p><br><h2 id="adaptivnaya-tema">  Tema Responsif </h2><br><p>  Saatnya sihir!  Dari kekurangan dua pendekatan pertama, kami mengumpulkan daftar periksa: </p><br><ol><li>  Jadikan latar belakang gelap, cahaya teks, medium batas. </li><li>  Identifikasi halaman yang sudah gelap dan jangan dicat ulang. </li><li>  Pertahankan rasio kecerahan dan kontras yang asli. </li><li>  Berikan kemampuan untuk menyesuaikan warna. </li><li>  Biarkan nada seperti di awal. </li></ol><br><p>  Kita perlu mengubah warna gaya agar latar belakangnya gelap.  Dan mengapa tidak melakukannya secara harfiah?  Kami hanya mengambil semua gaya, mencari aturan yang terkait dengan warna ( <code>color</code> , <code>background</code> , <code>border</code> , <code>box-shadow</code> , sub-properti mereka), dan menggantinya dengan "gelap" - menggelapkan latar belakang, mencerahkan teks, menggelapkan batas kurang dari latar belakang, dll. </p><br><p>  Metode ini memiliki satu keuntungan luar biasa yang akan menghangatkan jiwa setiap pengembang.  Setiap properti dapat dikonfigurasi (ya, jelaskan secara langsung dengan kode!) Aturannya sendiri untuk konversi warna.  Dengan imajinasi yang memadai, Anda dapat berintegrasi dengan tema eksternal apa saja, melakukan koreksi warna apa pun (misalnya, membuat warna terang atau abu-abu-cokelat-bukan tema gelap) dan bahkan menambahkan sedikit konteks - katakan, pegang batas lebar dan sempit secara berbeda. </p><br><p>  Kerugian adalah standar untuk semuanya.  Ya, kami menjalankan skrip, memecah enkapsulasi gaya dan parse CSS regexp.  Yah, tidak seperti HTML, yang terakhir tidak begitu memalukan karena tata bahasa CSS (dari tingkat yang kita butuhkan) masih teratur. </p><br><p>  Rencana pengecatan ulang adalah sebagai berikut: </p><br><ol><li>  Kami menormalkan properti warisan gaya ( <code>bgcolor</code> dan teman-teman), menggesernya ke <code>style="..."</code> . </li><li>  Temukan semua gaya sebaris. </li><li>  Dalam setiap gaya kami menemukan semua aturan warna ( <code>background-color</code> , <code>color</code> , <code>box-shadow</code> , dll.). </li><li>  Dari semua aturan warna, kami mendapatkan warna, kami menemukan konverter yang diinginkan (lebih gelap untuk latar belakang, lebih jelas untuk teks). </li><li>  Kami memanggil konverter. </li><li>  Menempatkan aturan yang dikonversi kembali ke CSS. </li></ol><br><p>  Pengikatan (normalisasi, pencarian gaya, parsing) cukup sederhana.  Kami akan mencari tahu bagaimana tepatnya <em>konverter</em> ajaib kami bekerja. </p><br><h3 id="hsl-preobrazovaniya">  Konversi HSL </h3><br><p>  "Peredupan warna" bukanlah tindakan yang sesederhana mungkin, terutama jika kita ingin mempertahankan nada (cyan menjadi biru tua, bukan oranye).  Ini bisa dilakukan dalam RGB normal, tetapi bermasalah.  Penggemar desain algoritmik tahu bahwa gradien di sana pun bengkok.  Tetapi bekerja dengan warna dalam HSL adalah kesenangan murni: alih-alih Merah, Hijau dan Biru, yang tidak jelas apa yang harus dilakukan, kami memiliki tiga saluran lain: </p><br><ul><li>  Hue hanyalah nada yang ingin kita pertahankan. </li><li>  Saturaion - saturasi, yang tidak terlalu penting bagi kita sekarang. </li><li>  Lightness - kecerahan yang akan kita ubah. </li></ul><br><p>  Ruang seperti itu direpresentasikan dalam bentuk silinder.  Dan tugas kita adalah membalik silinder ini.  Fungsi pemeringkatan warna melakukan sesuatu seperti <code>(h, s, l) =&gt; [h, s, 1 - l]</code> . </p><br><h3 id="cveta-s-kotorymi-i-tak-vsyo-horosho">  Warna-warna yang semuanya bagus </h3><br><p>  Terkadang situasinya berhasil: desain eksklusif surat itu (atau sebagian darinya) sudah gelap.  Dalam hal ini, Anda tidak perlu mengubah apa pun, lebih baik untuk hanya diam-diam bahagia - mungkin perancang memilih warna yang tidak lebih buruk daripada algoritma kami.  Di HSL, lihat saja L - brightness.  Jika lebih tinggi (untuk teks) atau lebih rendah (untuk latar belakang) ambang (yang, tentu saja, dapat disesuaikan), kami tidak melakukan apa pun. </p><br><h3 id="dinamicheskiy-cirk">  Sirkus dinamis </h3><br><p>  Meskipun kami tidak membutuhkannya (terima kasih lagi, sanitizer, Anda menyelamatkan saya dari kegilaan!), Saya akan tetap memberi tahu Anda apa jenis pengaya yang dibutuhkan tema adaptif untuk menggelapkan halaman penuh, dan bukan hanya huruf statis bodoh dari tahun sembilan puluhan.  Lebih tepatnya, ini adalah tugas bagi mereka yang menyukai aroma pemilih di pagi hari. </p><br><h4 id="dinamicheskie-inlayn-stili">  Gaya inline dinamis </h4><br><p>  Kasus paling sederhana yang memecah halaman gelap kami adalah mengubah gaya sebaris.  Operasi sering, tetapi perbaikannya sederhana: tambahkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><code>MutationObserver</code></a> dan cepat perbaiki gaya sebaris saat mengubah. </p><br><h4 id="vneshnie-stili">  Gaya eksternal </h4><br><p>  Bekerja dengan gaya dari <code>&lt;link&gt;</code> dari bagian dalam halaman agak menyakitkan karena asynchrony dan <code>@import</code> , dan CORS tidak lagi menyenangkan.  Tampaknya masalah ini dapat diselesaikan dengan sangat elegan melalui pekerja web (proxy untuk <code>*.css</code> ). </p><br><h4 id="dinamicheskie-stili">  Gaya dinamis </h4><br><p>  Akhirnya, menyatukan semua masalah kami, kami ingat bahwa skrip umumnya dapat menambah, menghapus dan mengatur ulang (spesifisitas! Cascade!) <code>&lt;style&gt;</code> dan <code>&lt;link&gt;</code> , dan bahkan mengubah aturan dalam <code>&lt;style&gt;</code> .  Semuanya dipecahkan oleh <code>MutationObserver</code> sama untuk elemen gaya, tetapi untuk setiap perubahan ada lebih banyak pemrosesan. </p><br><h4 id="css-peremennye">  Variabel CSS </h4><br><p>  Putaran kegilaan baru datang ketika variabel CSS memasuki permainan.  Kami tidak dapat mengaburkan variabel itu sendiri: bahkan jika kami berasumsi bahwa kami akan menebak dengan format bahwa variabel berisi warna (meskipun saya tidak akan menyarankan Anda untuk melakukan ini), tidak diketahui dalam peran apa yang akan bertemu dengan kita - latar belakang, teks, perbatasan, sekaligus?  Selain itu, nilai-nilai variabel diwariskan, jadi kita perlu mempertimbangkan tidak hanya gaya, tetapi juga elemen yang mereka terapkan, dan semua ini dengan cepat meningkat dan meledak. </p><br><p>  Jika variabel CSS sampai ke arus utama, kami memiliki masalah.  Di sisi lain, pada saat itu, <code>color()</code> sudah akan dimulai, yang memungkinkan untuk tidak mengubah warna dalam JS, tetapi cukup mengganti warna dengan <code>color(var(--bg) lightness(-50%))</code> . </p><br><h3 id="rezyume">  Ringkasan </h3><br><p><img src="https://habrastorage.org/webt/46/rl/mz/46rlmzxvgus52n7_77t3ydz2ms0.png"></p><br><p>  Untuk kasus kami, ketika sanitizer hanya menyisakan gaya inline, peredupan adaptif pada tingkat CSS berfungsi dengan baik: memberikan kualitas peredupan terbaik, tidak merusak huruf dan bekerja relatif cepat dan mudah.  Tidak yakin apakah opsi dengan semua isian untuk dinamika tidak sia-sia.  Untungnya, jika Anda bekerja dengan konten yang dibuat pengguna dan tidak menulis browser, pembersih Anda juga harus melakukan hal yang sama. </p><br><p>  Dalam praktiknya, mode adaptif harus digunakan bersama-sama dengan redefinisi gaya: gaya biasanya tidak diterapkan secara eksplisit ke elemen standar seperti <code>&lt;input&gt;</code> atau <code>&lt;a&gt;</code> , tetapi secara default mereka ringan. </p><br><h2 id="kak-zatemnyat-kartinki">  Cara menggelapkan gambar </h2><br><p>  Pengecatan ulang gambar adalah masalah terpisah yang mengganggu saya secara pribadi.  Ini menarik, dan saya akhirnya memiliki kesempatan untuk menggunakan frase "analisis spektral".  Ada beberapa masalah umum dengan gambar dalam subjek yang gelap. </p><br><p>  Pertama, gambarnya terlalu terang.  Ini bekerja dengan cara yang sama seperti huruf yang tidak dicat yang dengannya semuanya dimulai.  Seringkali (tetapi tidak harus) ini adalah foto biasa.  Karena tata letak buletin tidak terlalu menyenangkan, banyak orang hanya mengekspor bagian surat yang sulit sebagai gambar, itu tidak mengecat ulang dan pada malam hari menyinari kesempurnaan saya.  Gambar-gambar seperti itu perlu digelapkan, tetapi tidak terbalik - jika tidak, akan muncul negatif yang mengerikan. </p><br><p><img src="https://habrastorage.org/webt/6-/zz/nx/6-zznxvkap9ywdvgjpglm5v6wqc.png"></p><br><p>  Kedua, gambar gelap dengan transparansi nyata.  Masalah ini sering ditemukan pada logo - mereka dirancang untuk latar belakang yang terang dan, ketika kita menggantinya dengan yang gelap, bergabung dengannya.  Gambar seperti itu perlu dibalik. </p><br><p><img src="https://habrastorage.org/webt/xo/at/cc/xoatcc7dg3nhb_ufdoyye4hxsoo.png"></p><br><p>  Di suatu tempat di tengah ada gambar yang putih mewakili "latar belakang transparan", tapi sekarang mereka hanya berdiri di beberapa persegi panjang putih yang aneh.  Di dunia yang ideal, kami akan mengganti latar belakang putih dengan yang transparan, tetapi jika Anda pernah bekerja dengan tongkat ajaib di editor foto, maka Anda tahu bahwa melakukan ini secara otomatis tidak begitu mudah. </p><br><p><img src="https://habrastorage.org/webt/fi/o4/v9/fio4v9n1lcpve_wa1jhj5usj4yo.png"></p><br><p>  Sangat menarik bahwa kadang-kadang gambar tidak memiliki arti sama sekali - ini adalah pelacakan piksel dan "pemegang format" dalam tata letak yang sangat buruk.  Ini dapat dengan aman dibuat tidak terlihat (katakanlah, <code>opacity: 0</code> ). </p><br><p><img src="https://habrastorage.org/webt/5y/ba/tu/5ybatucrfhczsgc_aqykbgtnop0.png"></p><br><h3 id="evristiki-s-introspekciey">  Heuristik introspeksi </h3><br><p>  Untuk memutuskan apa yang harus dilakukan dengan gambar, kita perlu masuk dan menganalisis isinya - dan dengan cara yang sederhana dan cepat.  Menurut serangkaian masalah kami, versi pertama dari algoritma tersebut tampak.  Itu dia. </p><br><p>  Kami menganggap piksel gelap, terang, dan transparan dalam gambar, dan tidak semua, tetapi secara selektif - optimalisasi yang jelas.  Kami menentukan kecerahan keseluruhan gambar (terang, gelap, sedang) dan adanya transparansi.  Balikkan gambar gelap dengan transparansi, cahaya tanpa transparansi - bisu, jangan sentuh sisanya. </p><br><p>  Kegembiraan heuristik yang luar biasa ini berakhir ketika saya menemukan buletin amal dengan foto pelajaran di sekolah Afrika.  Semuanya akan baik-baik saja, tetapi perancang memusatkannya, menambahkan piksel transparan di sepanjang tepinya.  Kami tidak ingin menemukan diri kami di tengah-tengah cerita baru tentang pengenalan gambar yang ofensif, dan kami memutuskan untuk tidak melakukan pemrosesan gambar sama sekali dalam versi pertama. </p><br><p>  Di masa depan, heuristik tambahan, yang saya sebut "analisis spektral", harus melindungi terhadap masalah seperti itu - kami menghitung jumlah warna yang berbeda dalam gambar dan membalikkan hanya jika ada beberapa.  Kriteria yang sama dapat digunakan untuk mencari gambar cahaya grafis dan mengecatnya kembali - kedengarannya menggoda. </p><br><p><img src="https://habrastorage.org/webt/sj/c1/di/sjc1diiz68fpljjzii64f9j7nrq.png"></p><br><h2 id="itog">  Ringkasan </h2><br><p>  Untuk topik gelap penuh dalam surat, kami tidak memiliki surat mengecat dengan gaya, dan kami menemukan cara untuk mengaturnya.  Dua opsi sederhana dalam CSS murni - mendefinisikan ulang gaya dan filter CSS - tidak berfungsi: yang pertama terlalu sulit pada desain aslinya, yang kedua tidak berfungsi dengan baik.  Hasilnya, kami menggunakan peredupan adaptif - kami mengurai gaya, mengganti warna dengan yang lebih cocok dan mengumpulkannya kembali.  Sekarang kami sedang mengembangkan tema menjadi gambar - untuk ini kita perlu menganalisis isinya dan mengecat ulang hanya sedikit. </p><br><p>  Jika Anda perlu mengecat ulang HTML khusus ke tema gelap, ingat tiga metode berikut: </p><br><ul><li>  Overriding styles - Anda tetap membutuhkannya untuk aplikasi utama Anda, dengan murah dan marah, tetapi itu akan membunuh semua warna asli. </li><li>  Filter CSS memang keren, tetapi berfungsi begitu-begitu.  Gunakan hanya untuk elemen buram (dalam hal akses) seperti bingkai atau komponen web. </li><li>  Gaya konversi - menggelapkan kualitas sangat tinggi, tetapi lebih rumit daripada metode lain. </li></ul><br><p>  Bahkan jika Anda tidak pernah melakukan ini, saya harap Anda bersenang-senang! </p><br><p>  <strong>Tautan yang bermanfaat</strong> : </p><br><ol><li><p>  Jika Anda tertarik untuk membahas topik ini dengan hidup dan dalam konteks pengembangan untuk Android, maka kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">mengundang Anda untuk mengunjungi</a> kantor Yandex di Petersburg pada 18 April. </p><br></li><li><p>  Baru-baru ini, kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berbicara</a> tentang memecahkan masalah lain dari pengguna surat - masalah surat. </p><br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id446780/">https://habr.com/ru/post/id446780/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id446768/index.html">Pengetikan nominal dalam TypeScript atau cara melindungi antarmuka Anda dari pengidentifikasi asing</a></li>
<li><a href="../id446770/index.html">12 trik JavaScript tidak ditemukan di sebagian besar tutorial</a></li>
<li><a href="../id446772/index.html">Jangan membuka port ke dunia - mereka akan menghancurkan Anda (risiko)</a></li>
<li><a href="../id446774/index.html">Desain Karakter Poli Rendah</a></li>
<li><a href="../id446776/index.html">Bukti Kerja Efektif</a></li>
<li><a href="../id446782/index.html">Yo-ho-ho dan sebotol rum</a></li>
<li><a href="../id446786/index.html">Mengapa saya menolak Disqus dan Anda harus pergi juga</a></li>
<li><a href="../id446788/index.html">Kiat & trik Kubernetes: tentang pengembangan lokal dan Telepresence</a></li>
<li><a href="../id446790/index.html">Bagaimana saya menemukan telur paskah di keamanan Android dan tidak mendapatkan pekerjaan di Google</a></li>
<li><a href="../id446794/index.html">Kami bekerja dengan Wordstat dengan benar. Panduan lengkap</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>