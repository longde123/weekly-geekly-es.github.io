<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌘 👶 👨🏿‍🎤 自动化程序管理模型 🛩️ 🤱 🧦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="1.简介 
 在[1]中，给出了关于什么是自动编程（AP）的问题的答案，但是有限状态机（SC）的模型没有作为自动程序的控制模型进行详细描述。 显然，纯抽象自动机不适合担任此角色，因为 受频道数量限制。 但是，自动机的结构模型以及与之对应的结构自动机的理论尚不能给出关于自动机模型选择的答案。 

 问...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>自动化程序管理模型</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484588/"><h3>  1.简介 </h3><br> 在[1]中，给出了关于什么是自动编程（AP）的问题的答案，但是有限状态机（SC）的模型没有作为自动程序的控制模型进行详细描述。 显然，纯抽象自动机不适合担任此角色，因为 受频道数量限制。 但是，自动机的结构模型以及与之对应的结构自动机的理论尚不能给出关于自动机模型选择的答案。 <br><br> 问题开始于以下事实：在有限自动机理论（TCA）的众多著作中，很少有人对结构有限自动机（SCA）的模型进行定义。 的确，可以理解，结构自动机是实现抽象自动机模型的基本自动机（功能元素）的[结构]图[2]。 回想一下，根据理论，所有步骤都始于以抽象自动机的形式创建设备模型，然后任务是合成实现该模型的数字电路[3]。 <br><br> 乍一看编程似乎有点像数字电路的综合。 但仅在开始时。 首先，到处都是以算法开始的。 其次，组织和实现数字电路以及编程的结构性问题有很多共同点，尤其是在并行编程的情况下。 但是我们将单独讨论并行性主题。 同时，我们的任务是选择和/或修改有限状态机的模型，这对于被各种软件工具宠坏的程序员而言是可以理解，方便且令人愉悦的。 <br><br> 没错，这个问题是合乎逻辑的-为什么还要一个又不寻常的“自动工具箱”？ 我们将尝试通过定义[嵌套]自动控制模型来回答这个问题，同时还要考虑与常规编程模型相比的优势。 <br><a name="habracut"></a><br><h3>  2.自动程序控制模型的定义 </h3><br> 在进化的过程中，编程实践对程序管理模型形成了一定的要求。 必须认识到，经典有限状态机的模型与之对应的很少。 如果任务是在编程中使用自动机，则需要对其进行调整。 希望在自动机理论的框架内进行此操作。 对现有AP的主要主张减少到违反此条件的事实。 <br><br>  <i>定义1.</i>我们称<i>有限自动机的析取范式（DNKA）</i>完全定义的有限自动机，其转变由逻辑变量的基本合取来标记。 <br><br>  DNA模型基于<i>具有抽象状态</i> [4]和<i>逻辑自动机</i> [5]的完全（完全）定义的<i>自动机的</i>形式模型。 <br><br>  <i>定义2.</i>我们<i>将有限自动机（DFA）的</i>析<i>取形式</i>称为仅包含<i>结果转换</i>的DFA形式<i>的</i>自动机。 <br><br> 用输出信号标记的过渡和用破折号代替可改变自动机当前状态的输出信号的过渡被分类为有效过渡。 不包含在分离自动机描述中的转换构成了<i>将DKA（DDA）添加</i>到完全定义的DFA自动机中的功能。 这种加法是一个自动机，它由孤立的状态组成，这些状态具有循环形式的过渡，并用破折号代替输出信号。 <br><br><h3>  3.计算模型AP的存储模型 </h3><br>  DFA的许多输入和输出的存在设置了与之关联的软件操作员/功能的并行性。 为了正确实现，需要使用CREW类型的内存模型（并发读-写并发）[6]。 在其框架内，允许在所有函数集（谓词和操作）中读取当前数据值，并且仅允许其中一个更改并行可执行操作的<i>常规数据</i> 。 <br><br> 与多线程计算模型相比，自动控制模型明显将自动程序的运算符/功能的执行限制在离散时间周期的边界。 在这种情况下，可以将在当前时钟周期上执行的操作对存储器的任何更改写入<i>“影子存储器”</i> ，以便在它们完成之后且在下一个离散时钟周期开始之前，将其变为新值。 <br><br> 自动机程序运算符与存储器的相互作用将被称为<i>影子存储器模型</i> 。 该模型是自动编程通用模型的重要组成部分。 它确保了AP操作员并行操作的正确性，并简化了并行过程的编程。 <br><br> 在内存模型的框架内，实际上不需要用于进程的多线程同步的复杂且不是很可靠的机制（有关更多详细信息，请参见[7]）。 但是，如果有必要，由于自动机和<i>算法的图形方案（GAW）</i>等效[8]，自动编程模型不会限制其应用。 <br><br><h3>  4.自动机的嵌套和惯性模型 </h3><br> 进一步以示例为例，创建延迟逻辑元素模型的任务一方面展示了自动机经典模型的问题，另一方面又反映了DFA模型的特质，该模型以更直观，更便捷的方式解决了算法问题。 引入的嵌套自动机模型生成自动机模型的子类，以下称为<i>惯性自动机</i> ，以及相应的<i>惯性算法</i>子类。 <br><br> 因此，以创建实现二进制输入信号传输的延迟逻辑元件的离散模型为任务。 此外，在通常情况下，其分别延迟到单位状态和零状态的时间t01和t10的时间不一致。 <br><br> 图1显示了采用Mealy自动机形式的<i>单个延迟</i>的最简单模型。  1（作为比较，请参见[2]中的延迟模型）。 它的延迟由单个离散时钟周期决定。 分别以Miley自动机和组合的Miley-Moore模型的形式，给出了更复杂的<i>运输</i>延误模型（有关延误类型的更多详细信息，请参见[9]）。  2a和图。  2b。 <br><br><img src="https://habrastorage.org/webt/1v/1j/pw/1v1jpwicourr8xbg6yf2egq5nxk.jpeg" alt="图片"><br> 图  1.英里自动机形式的单位延迟模型 <br><br><img src="https://habrastorage.org/webt/di/bf/-d/dibf-daun_zrsuqr6hohywv2le0.jpeg" alt="图片"><br> 图  2. Miles（a）和Miles-Moore（b）的运输延迟模型 <br><br> 如果时钟计数器的值等于等于延迟t01或t10的变量t的值，则输入信号x3（我们记得在自动程序中它对应于谓词[1]）取真值。 变量t的值分配给信号y3和y4（在程序中，动作功能的名称与输出信号的名称相同）。 信号y1，y2设置代表模型输出的变量的值。 信号y5使时钟计数器递增，并由信号y6复位。 <br><br>  <i>备注2.图中模型的内部状态。</i>  <i>如图1所示，与元素的输出状态相关联是方便的。</i>  <i>这使我们不仅可以排除运算符y1和y2，还可以排除输出变量本身。</i> <i><br></i> <br> 类似于调用子例程的自动机嵌入的实现形成了模块化自动机编程技术。 同时，在软件级别，与硬件级别的类似尝试相比（请参阅[10]进行比较），这要简单得多。 为此，您需要插入嵌套自动机的程序调用，然后像常规处理器一样，执行自动机的内核将控制权返回到当前的嵌套级别。 <br><br>  <i>定义3.嵌套自动机</i>将被称为具有最终状态的自动机，过渡到该状态将启动返回到嵌套的上一级别（等级）的过程。 <br><br> 自动机嵌套的正确实现对创建它们的过程施加了限制。 首先，嵌套自动机只能是从属的。 此外，不包括零等级的顶级自动机也可以是嵌套自动机。 其次，在任何过渡情况<b>下，</b>都只能创建<b>一个</b>嵌套自动机。 嵌套自动机的机制也为基于自动控制的递归算法的实现奠定了基础。 <br><br><img src="https://habrastorage.org/webt/8c/4u/e5/8c4ue5ufusdgforqughwh5aw83w.jpeg" alt="图片"><br> 图  3.嵌套自动机形式的延迟模型 <br><br> 图3示出了延迟模型，其中图3a表示上层模型，图3b和图3b表示延迟模型。  3c-嵌套自动机的变体，用于运输和<i>惯性</i>延迟（有关延迟类型的更多详细信息，请参见[8]）。 同时，这些是嵌套自动机两种类型的示例- <i>普通</i>和<i>惯性</i> 。 嵌套自动机的类型由其最终状态的名称定义：名称为“ 00”的状态决定了嵌套自动机的通常退出状态，而名称为“ XX”的状态不会更改顶级自动机的当前状态。 <br><br> 理解惯性延迟算法的重要说明。 为此（参见图3c），谓词x1的值取决于在其上创建嵌入式自动机的过渡。 换句话说，状态为“ 0”的谓词控制输入的“零”的保留，而状态为“ 1”的谓词则控制“单位”的保留。 如果输入的值为零，而输出的值为零，则需要返回真实值。 此外，如果违反了输入的稳定性（值x1为假）并且延迟时间未到期（值x3为假），则通过惯性状态实现从嵌入式机器的退出（见图3c）。 <br><br>  <i>定义4.</i>自动机，包括具有最终惯性状态的嵌套自动机的调用，将称为<i>惯性自动机</i> 。 <br><br> 在图3a的模型中，如果定义了延迟值，则动作z1（为包括对嵌套自动机的调用的动作的名称选择了z符号）会创建嵌套自动机。 作为该动作的一部分，确定指定的延迟类型，根据该延迟类型，创建嵌套自动机之一，如图3b或图3所示。  3c。 <br><br> 在层次结构的顶层，图3a中自动机的视图与图1中的模型在结构上完全重合，仅在过渡上存在动作时有所不同。 与图2中的单层模型相比，嵌套自动机的延迟具有更简单的形式。 嵌套自动机也可以视为可以从任何其他自动机调用的“库自动机”。 <br><br><h3>  3.对象自动机编程 </h3><br> 除图形形式外，自动控制模型还具有简单的表格形式-转换表（TP），可以在C ++中对其进行有效解释。 在其框架内，一个单独的自动机程序（或其一部分）以及相应的以程序电路S形式的定义可以用一个类来表示。 在这种情况下，内存模型将对应于类的属性，操作集将对应于类的方法，而TP形式的自动控制将描述类的行为。 将控制引入到类中后，我们可以讨论活动对象，通常也称为代理等。 <br><br> 具有自动机控制形式的行为的许多对象将<i>对象自动机并行程序</i>的概念形式化。 在这种情况下，任何并行程序的模型都可以由程序图表示，其中控制C将以自动机网络的形式呈现，其中组件自动机描述活动对象的行为，存储器M由对象属性的组合表示，许多运算符A由程序对象方法的组合表示。 <br><br> 在VKPA环境中，自动编程语言的角色分配给了C ++语言。 在“自动C ++”中，对象具有活动/行为，并具有描述和实现并行性的手段，无论是在单个对象的方法级别还是在描述许多对象的并行操作的级别。 <br><br>  AP的现有对象实现相当复杂。 在VKPa中，其对象实现基于自动机的解释和程序的专用控制。 与直接在SWITH技术中使用的自动机不同，这种方法省去了将自动机模型转换为流程图模型的过程。  VKPa中使用的解释算法类似于E. Hamby [12]解释决策表的方法。 <br><br> 除非另有说明，否则我们将在OOP的意义上进一步将自动机程序的概念与<i>自动机对象（AO）</i>的概念相关联，但要考虑到上面介绍的对象自动机并行程序的概念。 因此，将通过活动对象的方法和属性来确定AP的运算符和内存。 自动机对象与普通对象的区别在于状态机模型确定的行为。 <br><br><h3>  4.结论 </h3><br> 创建嵌套自动机模型是朝着编程技术的质变迈出的一步。 所描述的自动机惯性模型类似于UML中的历史状态的概念。 通常的自动机嵌入在编程中有一个类似物，“惯性嵌入”中没有，因为 在程序中，不能返回子例程调用之前的命令。 这些是自动编程和普通编程之间在质量上存在差异的要素。 <br><br> 当然，您可以将影子存储器引入普通编程中并表示功能的并行性。 但是在自动机模型的框架中，所有这些在描述和性能方面都有一个有机的形式。 一切都取决于模型的自然并行性。 框图模型不具有这种功能。 <br><br> 活动对象还扩展了编程功能。 但是，“对象包装器”从本质上影响自动编程，从而简化了调用和实现嵌套自动机的过程。 因此，使用[local]类属性可以使您不仅实现嵌入，还可以实现任何递归算法。 <br><br><div class="spoiler">  <b class="spoiler_title">参考文献</b> <div class="spoiler_text">  1.图灵机，作为自动程序的模型。  [电子资源]，访问方式： <a href="https://habr.com/ru/post/481998/">habr.com/en/post/481998</a> ，免费。 亚兹 俄文  （治疗日期07.01.2020）。 <br>  2. KUDRYAVTSEV VB，Aleshin S.V.，PODKOLZIN A.S. 自动机理论简介-M。：Science。 频道  ed。 物理数学。 点燃.1985。-320羽 <br>  3. GLUSHKOV V.M. 合成数字机器。  M.：Fizmatgiz，1962年。 <br>  4. ZAKREVSKY A.D. 级联方案的逻辑综合。  -M。：科学。 频道  ed。 物理垫 点燃。，1981.-416羽 <br>  5. KUZNETSOV O.P. 逻辑自动机图及其转换//自动和远程机械。  -1975年-第9号。S。149-158。 <br>  6. Kormen T.，Leiserson Ch。，Rivest R.算法：构造和分析-M.：MCCMO，2001年-960页。 <br>  7. BUCH G.，RAMBO J.，Jacobson I. UML。 用户手册。 第二版。  IT学院：莫斯科，2007年-493页 <br>  8. BARANOV S.I. 固件综合  -L。：能源，1979年。-232秒。 <br>  9. ARMSTRONG J.R. 用VHDL语言进行数字系统建模：Transl。from English / M .: Mir，1992.-175 p。 <br>  10. HAMBARTSUMYAN A.A.，ZAPOLSKYH E.N. 关于自动机暂时分解的一种方法。 我，Avtomat。  and Telemech。，1981，第2期，135-144 <br>  11. SHALYTO A. A.自动编程的范例。 圣彼得堡国立信息技术，机械和光学大学的科学技术通报。 卷  53.自动编程。  2008年，第  3-23。 <br>  12. HAMBI E.编程决策表。  M .:米尔（Mir），1976 .-- 86羽 <br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN484588/">https://habr.com/ru/post/zh-CN484588/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN484578/index.html">服务水平目标-Google体验（Google SRE图书章节的翻译）</a></li>
<li><a href="../zh-CN484580/index.html">您需要了解的有关内存模拟器的知识</a></li>
<li><a href="../zh-CN484582/index.html">ASP.NET MVC-实体框架，MySQL并使用Dependency Resolver选择存储库</a></li>
<li><a href="../zh-CN484584/index.html">为什么我们在IT项目中需要经理，如果没有经理，会发生什么？</a></li>
<li><a href="../zh-CN484586/index.html">在PHP中使用IPv6</a></li>
<li><a href="../zh-CN484590/index.html">这样男孩们就不会羞于表现出来</a></li>
<li><a href="../zh-CN484592/index.html">上周第398期（2020年1月13日至19日）来自前端世界的新鲜材料摘要</a></li>
<li><a href="../zh-CN484596/index.html">Blazor客户端在线商店：第1部分-授权oidc（oauth2）+ Identity Server4</a></li>
<li><a href="../zh-CN484600/index.html">Microsoft点燃巡回布拉格技术会议</a></li>
<li><a href="../zh-CN484602/index.html">书籍“在iOS和Android中使用C＃开发移动应用程序”</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>