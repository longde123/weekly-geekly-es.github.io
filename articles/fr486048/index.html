<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👈 🤽🏻 🤢 Qu'est-ce que «cela» et que mange-t-il 🤟🏻 🧔🏻 🎻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Photo de Sebastian Herrmann . 

 Bonjour mes amis! 

 Je vous présente la traduction de l'article de Daniel James «Qu'est-ce que« ceci »? Pourquoi cel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Qu'est-ce que «cela» et que mange-t-il</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486048/"><img src="https://habrastorage.org/webt/hp/hc/s0/hphcs0pvspbd2pixgpfcnws9zg4.jpeg"><br>  Photo de <a href="https://unsplash.com/%40officestock" rel="nofollow">Sebastian Herrmann</a> . <br><br>  Bonjour mes amis! <br><br>  Je vous présente la traduction de l'article de Daniel James <a href="https://www.javascriptjanuary.com/blog/what-is-this-why-is-that" rel="nofollow">«Qu'est-ce que« ceci »?</a>  <a href="https://www.javascriptjanuary.com/blog/what-is-this-why-is-that" rel="nofollow">Pourquoi cela? ”</a> . <br><br><h2>  Qu'est-ce que «cela» et que mange-t-il </h2><br>  Quand j'ai commencé à apprendre JavaScript, le concept de cela m'a semblé extrêmement déroutant. <br><br><h3>  Présentation </h3><br>  La croissance rapide de la popularité de JS s'explique en partie par un seuil d'entrée bas.  Des fonctionnalités telles que les fonctions et cela fonctionnent généralement comme prévu.  Pour devenir un professionnel de JS, vous n'avez pas besoin de connaître beaucoup de petits détails et de détails (je dirais avec cela - environ Per.).  Mais une fois, chaque développeur rencontre une erreur causée par la valeur de ceci. <br><br>  Après cela, vous avez envie de comprendre comment cela fonctionne dans JS.  S'agit-il d'un concept de programmation orientée objet (POO)?  JS est-il un langage de programmation orienté objet (OOJP)?  Si vous "google" cela, vous recevrez en réponse la mention de certains prototypes.  Quel genre de prototypes?  À quoi servait le «nouveau» mot clé avant que les classes n'apparaissent dans JS? <br><br>  Toutes ces choses sont étroitement liées.  Mais avant d'expliquer comment cela fonctionne, je vais me permettre une petite digression.  Je veux parler un peu de la raison pour laquelle JS est ce qu'il est. <br><a name="habracut"></a><br><h3>  POO dans JS </h3><br>  Le paradigme de programmation (héritage) de prototype dans JS est l'une des caractéristiques de la POO.  Même avant l'avènement des classes JS, il y avait OOJP.  JS est un langage simple qui utilise seulement quelques éléments de la POO.  Les plus importants d'entre eux sont les fonctions, les fermetures, ceci, les prototypes, les littéraux d'objet et le nouveau mot-clé. <br><br><h3>  Encapsulation et réutilisabilité avec fermetures </h3><br>  Créons la classe Counter.  Cette classe doit avoir des méthodes pour réinitialiser et incrémenter le compteur.  Nous pouvons écrire quelque chose comme ceci: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Counter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> _count = initialValue <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">reset</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ _count = <span class="hljs-number"><span class="hljs-number">0</span></span> }, <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ++_count } } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myCounter = Counter() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myCounter.next()) <span class="hljs-comment"><span class="hljs-comment">// 1</span></span></code> </pre> <br>  Dans ce cas, nous nous sommes limités à utiliser des fonctions et des littéraux d'objet sans cela ou nouveau.  Oui, nous avons déjà reçu quelque chose de la POO.  Nous avons la possibilité de créer de nouvelles instances de Counter.  Chaque instance de Counter a son propre nombre de variables internes.  Nous avons implémenté l'encapsulation et la réutilisation de manière purement fonctionnelle. <br><br><h3>  Problème de performance </h3><br>  Supposons que nous écrivons un programme qui utilise un grand nombre de compteurs.  Chaque compteur aura ses propres méthodes de réinitialisation et ensuite (Counter (). Reset! = Counter (). Reset).  La création de telles fermetures pour chaque méthode de chaque instance nécessitera une énorme quantité de mémoire!  Une telle architecture est «insoutenable».  Par conséquent, nous devons trouver un moyen de stocker dans chaque instance de Counter uniquement des références aux méthodes qu'il utilise (en fait, c'est ce que font tous les OOJP, comme Java). <br><br>  Nous pourrions résoudre ce problème comme suit (sans impliquer des fonctionnalités de langue supplémentaires): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> Counter = { <span class="hljs-attr"><span class="hljs-attr">reset</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">counter</span></span></span><span class="hljs-function">)</span></span>{ counter._count = <span class="hljs-number"><span class="hljs-number">0</span></span> }, <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">counter</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ++counter._count }, <span class="hljs-attr"><span class="hljs-attr">new</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">_count</span></span>: initialValue } } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myCounter = Counter.new() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(Counter.next(myCounter)) <span class="hljs-comment"><span class="hljs-comment">// 1</span></span></code> </pre><br>  Cette approche résout le problème de performance, mais nous avons dû faire un compromis sérieux, qui consiste en la nécessité d'une participation élevée du programmeur à l'exécution du programme (en s'assurant que le code fonctionne).  Sans outils supplémentaires, il faudrait se contenter de cette approche. <br><br><h3>  Cela se précipite à la rescousse </h3><br>  Nous réécrivons notre exemple en utilisant ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> Counter = { <span class="hljs-attr"><span class="hljs-attr">reset</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count = <span class="hljs-number"><span class="hljs-number">0</span></span> }, <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ++<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count }, <span class="hljs-attr"><span class="hljs-attr">new</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">_count</span></span>: initialValue, <span class="hljs-comment"><span class="hljs-comment">//          reset: Counter.reset, next: Counter.next } } } const myCounter = Counter.new() myCounter.next() // ,  reset     myCounter (Counter.new()).reset() console.log(myCounter.next()) // 2</span></span></code> </pre><br>  Notez que nous continuons à créer des fonctions simples de réinitialisation et ensuite (Counter.new (). Reset == Counter.new (). Reset).  Dans l'exemple précédent, pour que le programme fonctionne, nous avons été obligés de fournir un descripteur d'instance pour les méthodes implémentées conjointement.  Maintenant, nous appelons simplement myCounter.next () et faisons référence à l'instance utilisant ceci.  Mais comment ça marche?  Reset et next sont déclarés dans l'objet Counter.  Comment JS sait-il à quoi cela se réfère lors de l'appel d'une fonction? <br><br><h3>  Appel de fonction dans JS </h3><br>  Vous savez très bien que les fonctions de JS ont une méthode d'appel (il y a aussi une méthode apply; la différence entre ces méthodes n'est pas significative. La différence est dans la façon dont nous passons les paramètres: in apply en tant que tableau, en appel séparé par des virgules - environ Per.) .  En utilisant call, vous décidez de ce que cela signifie lorsque la fonction est appelée: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myCounter = Counter.new() Counter.next.call(myCounter)</code> </pre><br>  C'est en fait ce que fait la notation par points derrière la scène lorsque nous appelons la fonction.  lhs.fn () est identique à fn.call (lhs). <br><br>  Il s'agit donc d'un identifiant spécial qui est défini lors de l'appel de la fonction. <br><br><h3>  Les problèmes commencent </h3><br>  Supposons que vous souhaitiez créer un compteur et incrémenter sa valeur à chaque seconde.  Voici comment procéder: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myCounter = Counter.new() setInterval(myCounter.next, <span class="hljs-number"><span class="hljs-number">1000</span></span>) <span class="hljs-comment"><span class="hljs-comment">//    console.log(`Why is ${myCounter.next()} still 0?`) //  myCounter.next()    0?</span></span></code> </pre><br>  Voyez-vous une erreur ici?  Lorsque setInterval démarre, la valeur de ceci n'est pas définie, donc rien ne se passe.  Ce problème peut être résolu comme suit: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myCounter = Counter.new() setInterval(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ myCounter.next() }, <span class="hljs-number"><span class="hljs-number">1000</span></span>)</code> </pre><br><h3>  Un peu de lier </h3><br>  Il existe une autre façon de résoudre ce problème: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindThis</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn, _this</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn.call(_this, ...args) } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myCounter = Counter.new() setInterval(bindThis(myCounter.next, myCounter), <span class="hljs-number"><span class="hljs-number">1000</span></span>)</code> </pre><br>  En utilisant la fonction d'usine bindThis, nous pouvons être sûrs que Counter.next appelle toujours myCounter comme ceci, quelle que soit la façon dont la nouvelle fonction est appelée.  En fait, nous ne changeons pas la fonction de Counter.next.  JS a une méthode de liaison intégrée.  Par conséquent, nous pouvons réécrire l'exemple ci-dessus comme ceci: setInterval (myCounter.next.bind (myCounter), 1000). <br><br><h3>  Nous travaillons avec des prototypes </h3><br>  En ce moment, nous avons une belle classe Counter, mais elle est toujours un peu "tordue".  Ce sont les lignes suivantes: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ... reset: Counter.reset, next: Counter.next, // ...</span></span></code> </pre><br>  Nous avons besoin d'un meilleur moyen de partager les méthodes de classe avec ses instances.  Les prototypes en font un excellent travail.  Si vous vous référez à la propriété d'une fonction ou d'un objet qui n'existe pas, JS recherchera cette propriété dans le prototype de cette fonction ou de cet objet (puis dans le prototype du prototype et ainsi de suite au Object.prototype situé en haut de la chaîne du prototype - environ Trans.).  Vous pouvez définir le prototype d'un objet à l'aide d'Object.setPrototypeOf.  Réécrivons notre classe Counter en utilisant des prototypes: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> Counter = { <span class="hljs-attr"><span class="hljs-attr">reset</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count = <span class="hljs-number"><span class="hljs-number">0</span></span> }, <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ++<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count }, <span class="hljs-attr"><span class="hljs-attr">new</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count = initialValue } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newInstanceOf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">klass, ...args</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       "klass",  "class"   const instance = {} Object.setPrototypeOf(instance, klass) instance.new(...args) return instance } const myCounter = newInstanceOf(Counter) console.log(myCounter.next()) // 1</span></span></code> </pre><br><h3>  Mot-clé "nouveau" </h3><br>  L'utilisation de setPrototypeOf est très similaire à la façon dont fonctionne le "nouvel" opérateur.  La différence est que new utilisera le constructeur prototype de la fonction passée.  Par conséquent, au lieu de créer un objet pour nos méthodes, nous les passons au prototype du constructeur de la fonction: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Counter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count = initialValue } Counter.prototype.reset = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count = <span class="hljs-number"><span class="hljs-number">0</span></span> } Counter.prototype.next = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ++<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myCounter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Counter() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${myCounter.next()}</span></span></span><span class="hljs-string">`</span></span>) <span class="hljs-comment"><span class="hljs-comment">// 1</span></span></code> </pre><br>  Enfin, nous avons le code sous la forme dans laquelle il peut être trouvé dans la pratique.  Avant l'apparition des classes dans JS, c'était l'approche standard pour créer et initialiser des classes. <br><br><h3>  Mot-clé "classe" </h3><br>  J'espère que vous comprenez maintenant pourquoi nous utilisons le prototype du constructeur de fonction et comment cela fonctionne dans les méthodes de fonction.  Cependant, notre code peut être amélioré.  Heureusement, aujourd'hui, dans JS, il existe une meilleure façon de déclarer des classes: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Counter</span></span></span><span class="hljs-class"> </span></span>{ reset(){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count = <span class="hljs-number"><span class="hljs-number">0</span></span> } next(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ++<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count } <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(initialValue = 0){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count = initialValue } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myCounter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Counter() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${myCounter.next()}</span></span></span><span class="hljs-string">`</span></span>) <span class="hljs-comment"><span class="hljs-comment">// 1</span></span></code> </pre><br>  Le mot-clé «classe» ne fait rien spécialement sous «chat».  Vous pouvez le considérer comme du sucre syntaxique, un wrapper pour l'approche «prototype».  Si vous exécutez le transporteur orienté vers ES3, vous obtiendrez quelque chose comme ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Counter = <span class="hljs-comment"><span class="hljs-comment">/** @class **/</span></span> (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Counter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(initialValue === <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>) { initialValue = <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count = initialValue } Counter.prototype.reset = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count = <span class="hljs-number"><span class="hljs-number">0</span></span> } Counter.prototype.next = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ ++<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Counter }()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myCounter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Counter() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myCounter.next())</code> </pre><br>  Notez que le transpilateur a généré du code qui est presque identique à l'exemple précédent. <br><br><h3>  Fonctions fléchées </h3><br>  Si vous écrivez du code en JS depuis 5 ans, vous serez peut-être surpris que je mentionne les fonctions fléchées.  Mon conseil: utilisez toujours les fonctions flèches jusqu'à ce que vous ayez vraiment besoin d'une fonction régulière.  Il se trouve que la définition du constructeur et des méthodes de la classe est juste le cas lorsque nous devons utiliser des fonctions ordinaires.  L'une des caractéristiques des fonctions fléchées est l'obscurcissement. <br><br><h3>  Cette fonction fléchée </h3><br>  Certains peuvent supposer que les fonctions fléchées en prennent la valeur actuelle lors de leur création.  C'est incorrect d'un point de vue technique (le sens de cela n'est pas défini, il est tiré de l'environnement lexical), mais c'est un bon modèle mental.  Une fonction flèche comme celle-ci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myArrowFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.doSomething() }</code> </pre><br>  Vous pouvez le réécrire comme ceci: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _this = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myRegularFunction = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ _this.doSomething() }</code> </pre><br>  Merci de votre attention.  Mes meilleurs vœux. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr486048/">https://habr.com/ru/post/fr486048/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr486032/index.html">Comment devenir concepteur de dialogues</a></li>
<li><a href="../fr486034/index.html">Accès rapide à la gestion des produits via Open source</a></li>
<li><a href="../fr486036/index.html">Analyse de sentiment de texte sur Node.js</a></li>
<li><a href="../fr486042/index.html">Messagers et législation télécom</a></li>
<li><a href="../fr486046/index.html">Noyau Linux inclus WireGuard VPN</a></li>
<li><a href="../fr486050/index.html">Bibliothèque JavaScript Webix vue par un débutant. Partie 3. Modules, diagrammes, tables arborescentes</a></li>
<li><a href="../fr486052/index.html">Scorched Earth est la mère de tous les jeux. Entretien avec le créateur</a></li>
<li><a href="../fr486056/index.html">Des scripts à notre propre plateforme: comment nous avons automatisé le développement au Cyan Institute</a></li>
<li><a href="../fr486060/index.html">Trouver l'ordre dans le chaos de l'informatique: organiser votre propre développement</a></li>
<li><a href="../fr486062/index.html">Rendu simple sans copie de la vidéo avec accélération matérielle en QML</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>