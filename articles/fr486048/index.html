<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëà ü§Ωüèª ü§¢ Qu'est-ce que ¬´cela¬ª et que mange-t-il ü§üüèª üßîüèª üéª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Photo de Sebastian Herrmann . 

 Bonjour mes amis! 

 Je vous pr√©sente la traduction de l'article de Daniel James ¬´Qu'est-ce que¬´ ceci ¬ª? Pourquoi cel...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Qu'est-ce que ¬´cela¬ª et que mange-t-il</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/486048/"><img src="https://habrastorage.org/webt/hp/hc/s0/hphcs0pvspbd2pixgpfcnws9zg4.jpeg"><br>  Photo de <a href="https://unsplash.com/%40officestock" rel="nofollow">Sebastian Herrmann</a> . <br><br>  Bonjour mes amis! <br><br>  Je vous pr√©sente la traduction de l'article de Daniel James <a href="https://www.javascriptjanuary.com/blog/what-is-this-why-is-that" rel="nofollow">¬´Qu'est-ce que¬´ ceci ¬ª?</a>  <a href="https://www.javascriptjanuary.com/blog/what-is-this-why-is-that" rel="nofollow">Pourquoi cela? ‚Äù</a> . <br><br><h2>  Qu'est-ce que ¬´cela¬ª et que mange-t-il </h2><br>  Quand j'ai commenc√© √† apprendre JavaScript, le concept de cela m'a sembl√© extr√™mement d√©routant. <br><br><h3>  Pr√©sentation </h3><br>  La croissance rapide de la popularit√© de JS s'explique en partie par un seuil d'entr√©e bas.  Des fonctionnalit√©s telles que les fonctions et cela fonctionnent g√©n√©ralement comme pr√©vu.  Pour devenir un professionnel de JS, vous n'avez pas besoin de conna√Ætre beaucoup de petits d√©tails et de d√©tails (je dirais avec cela - environ Per.).  Mais une fois, chaque d√©veloppeur rencontre une erreur caus√©e par la valeur de ceci. <br><br>  Apr√®s cela, vous avez envie de comprendre comment cela fonctionne dans JS.  S'agit-il d'un concept de programmation orient√©e objet (POO)?  JS est-il un langage de programmation orient√© objet (OOJP)?  Si vous "google" cela, vous recevrez en r√©ponse la mention de certains prototypes.  Quel genre de prototypes?  √Ä quoi servait le ¬´nouveau¬ª mot cl√© avant que les classes n'apparaissent dans JS? <br><br>  Toutes ces choses sont √©troitement li√©es.  Mais avant d'expliquer comment cela fonctionne, je vais me permettre une petite digression.  Je veux parler un peu de la raison pour laquelle JS est ce qu'il est. <br><a name="habracut"></a><br><h3>  POO dans JS </h3><br>  Le paradigme de programmation (h√©ritage) de prototype dans JS est l'une des caract√©ristiques de la POO.  M√™me avant l'av√®nement des classes JS, il y avait OOJP.  JS est un langage simple qui utilise seulement quelques √©l√©ments de la POO.  Les plus importants d'entre eux sont les fonctions, les fermetures, ceci, les prototypes, les litt√©raux d'objet et le nouveau mot-cl√©. <br><br><h3>  Encapsulation et r√©utilisabilit√© avec fermetures </h3><br>  Cr√©ons la classe Counter.  Cette classe doit avoir des m√©thodes pour r√©initialiser et incr√©menter le compteur.  Nous pouvons √©crire quelque chose comme ceci: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Counter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> _count = initialValue <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">reset</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ _count = <span class="hljs-number"><span class="hljs-number">0</span></span> }, <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ++_count } } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myCounter = Counter() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myCounter.next()) <span class="hljs-comment"><span class="hljs-comment">// 1</span></span></code> </pre> <br>  Dans ce cas, nous nous sommes limit√©s √† utiliser des fonctions et des litt√©raux d'objet sans cela ou nouveau.  Oui, nous avons d√©j√† re√ßu quelque chose de la POO.  Nous avons la possibilit√© de cr√©er de nouvelles instances de Counter.  Chaque instance de Counter a son propre nombre de variables internes.  Nous avons impl√©ment√© l'encapsulation et la r√©utilisation de mani√®re purement fonctionnelle. <br><br><h3>  Probl√®me de performance </h3><br>  Supposons que nous √©crivons un programme qui utilise un grand nombre de compteurs.  Chaque compteur aura ses propres m√©thodes de r√©initialisation et ensuite (Counter (). Reset! = Counter (). Reset).  La cr√©ation de telles fermetures pour chaque m√©thode de chaque instance n√©cessitera une √©norme quantit√© de m√©moire!  Une telle architecture est ¬´insoutenable¬ª.  Par cons√©quent, nous devons trouver un moyen de stocker dans chaque instance de Counter uniquement des r√©f√©rences aux m√©thodes qu'il utilise (en fait, c'est ce que font tous les OOJP, comme Java). <br><br>  Nous pourrions r√©soudre ce probl√®me comme suit (sans impliquer des fonctionnalit√©s de langue suppl√©mentaires): <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> Counter = { <span class="hljs-attr"><span class="hljs-attr">reset</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">counter</span></span></span><span class="hljs-function">)</span></span>{ counter._count = <span class="hljs-number"><span class="hljs-number">0</span></span> }, <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">counter</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ++counter._count }, <span class="hljs-attr"><span class="hljs-attr">new</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">_count</span></span>: initialValue } } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myCounter = Counter.new() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(Counter.next(myCounter)) <span class="hljs-comment"><span class="hljs-comment">// 1</span></span></code> </pre><br>  Cette approche r√©sout le probl√®me de performance, mais nous avons d√ª faire un compromis s√©rieux, qui consiste en la n√©cessit√© d'une participation √©lev√©e du programmeur √† l'ex√©cution du programme (en s'assurant que le code fonctionne).  Sans outils suppl√©mentaires, il faudrait se contenter de cette approche. <br><br><h3>  Cela se pr√©cipite √† la rescousse </h3><br>  Nous r√©√©crivons notre exemple en utilisant ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> Counter = { <span class="hljs-attr"><span class="hljs-attr">reset</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count = <span class="hljs-number"><span class="hljs-number">0</span></span> }, <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ++<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count }, <span class="hljs-attr"><span class="hljs-attr">new</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">_count</span></span>: initialValue, <span class="hljs-comment"><span class="hljs-comment">//          reset: Counter.reset, next: Counter.next } } } const myCounter = Counter.new() myCounter.next() // ,  reset     myCounter (Counter.new()).reset() console.log(myCounter.next()) // 2</span></span></code> </pre><br>  Notez que nous continuons √† cr√©er des fonctions simples de r√©initialisation et ensuite (Counter.new (). Reset == Counter.new (). Reset).  Dans l'exemple pr√©c√©dent, pour que le programme fonctionne, nous avons √©t√© oblig√©s de fournir un descripteur d'instance pour les m√©thodes impl√©ment√©es conjointement.  Maintenant, nous appelons simplement myCounter.next () et faisons r√©f√©rence √† l'instance utilisant ceci.  Mais comment √ßa marche?  Reset et next sont d√©clar√©s dans l'objet Counter.  Comment JS sait-il √† quoi cela se r√©f√®re lors de l'appel d'une fonction? <br><br><h3>  Appel de fonction dans JS </h3><br>  Vous savez tr√®s bien que les fonctions de JS ont une m√©thode d'appel (il y a aussi une m√©thode apply; la diff√©rence entre ces m√©thodes n'est pas significative. La diff√©rence est dans la fa√ßon dont nous passons les param√®tres: in apply en tant que tableau, en appel s√©par√© par des virgules - environ Per.) .  En utilisant call, vous d√©cidez de ce que cela signifie lorsque la fonction est appel√©e: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myCounter = Counter.new() Counter.next.call(myCounter)</code> </pre><br>  C'est en fait ce que fait la notation par points derri√®re la sc√®ne lorsque nous appelons la fonction.  lhs.fn () est identique √† fn.call (lhs). <br><br>  Il s'agit donc d'un identifiant sp√©cial qui est d√©fini lors de l'appel de la fonction. <br><br><h3>  Les probl√®mes commencent </h3><br>  Supposons que vous souhaitiez cr√©er un compteur et incr√©menter sa valeur √† chaque seconde.  Voici comment proc√©der: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myCounter = Counter.new() setInterval(myCounter.next, <span class="hljs-number"><span class="hljs-number">1000</span></span>) <span class="hljs-comment"><span class="hljs-comment">//    console.log(`Why is ${myCounter.next()} still 0?`) //  myCounter.next()    0?</span></span></code> </pre><br>  Voyez-vous une erreur ici?  Lorsque setInterval d√©marre, la valeur de ceci n'est pas d√©finie, donc rien ne se passe.  Ce probl√®me peut √™tre r√©solu comme suit: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myCounter = Counter.new() setInterval(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ myCounter.next() }, <span class="hljs-number"><span class="hljs-number">1000</span></span>)</code> </pre><br><h3>  Un peu de lier </h3><br>  Il existe une autre fa√ßon de r√©soudre ce probl√®me: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bindThis</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">fn, _this</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fn.call(_this, ...args) } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myCounter = Counter.new() setInterval(bindThis(myCounter.next, myCounter), <span class="hljs-number"><span class="hljs-number">1000</span></span>)</code> </pre><br>  En utilisant la fonction d'usine bindThis, nous pouvons √™tre s√ªrs que Counter.next appelle toujours myCounter comme ceci, quelle que soit la fa√ßon dont la nouvelle fonction est appel√©e.  En fait, nous ne changeons pas la fonction de Counter.next.  JS a une m√©thode de liaison int√©gr√©e.  Par cons√©quent, nous pouvons r√©√©crire l'exemple ci-dessus comme ceci: setInterval (myCounter.next.bind (myCounter), 1000). <br><br><h3>  Nous travaillons avec des prototypes </h3><br>  En ce moment, nous avons une belle classe Counter, mais elle est toujours un peu "tordue".  Ce sont les lignes suivantes: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// ... reset: Counter.reset, next: Counter.next, // ...</span></span></code> </pre><br>  Nous avons besoin d'un meilleur moyen de partager les m√©thodes de classe avec ses instances.  Les prototypes en font un excellent travail.  Si vous vous r√©f√©rez √† la propri√©t√© d'une fonction ou d'un objet qui n'existe pas, JS recherchera cette propri√©t√© dans le prototype de cette fonction ou de cet objet (puis dans le prototype du prototype et ainsi de suite au Object.prototype situ√© en haut de la cha√Æne du prototype - environ Trans.).  Vous pouvez d√©finir le prototype d'un objet √† l'aide d'Object.setPrototypeOf.  R√©√©crivons notre classe Counter en utilisant des prototypes: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> Counter = { <span class="hljs-attr"><span class="hljs-attr">reset</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count = <span class="hljs-number"><span class="hljs-number">0</span></span> }, <span class="hljs-attr"><span class="hljs-attr">next</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ++<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count }, <span class="hljs-attr"><span class="hljs-attr">new</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count = initialValue } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">newInstanceOf</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">klass, ...args</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-comment"><span class="hljs-comment">//       "klass",  "class"   const instance = {} Object.setPrototypeOf(instance, klass) instance.new(...args) return instance } const myCounter = newInstanceOf(Counter) console.log(myCounter.next()) // 1</span></span></code> </pre><br><h3>  Mot-cl√© "nouveau" </h3><br>  L'utilisation de setPrototypeOf est tr√®s similaire √† la fa√ßon dont fonctionne le "nouvel" op√©rateur.  La diff√©rence est que new utilisera le constructeur prototype de la fonction pass√©e.  Par cons√©quent, au lieu de cr√©er un objet pour nos m√©thodes, nous les passons au prototype du constructeur de la fonction: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Counter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue = </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">0</span></span></span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count = initialValue } Counter.prototype.reset = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count = <span class="hljs-number"><span class="hljs-number">0</span></span> } Counter.prototype.next = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ++<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myCounter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Counter() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${myCounter.next()}</span></span></span><span class="hljs-string">`</span></span>) <span class="hljs-comment"><span class="hljs-comment">// 1</span></span></code> </pre><br>  Enfin, nous avons le code sous la forme dans laquelle il peut √™tre trouv√© dans la pratique.  Avant l'apparition des classes dans JS, c'√©tait l'approche standard pour cr√©er et initialiser des classes. <br><br><h3>  Mot-cl√© "classe" </h3><br>  J'esp√®re que vous comprenez maintenant pourquoi nous utilisons le prototype du constructeur de fonction et comment cela fonctionne dans les m√©thodes de fonction.  Cependant, notre code peut √™tre am√©lior√©.  Heureusement, aujourd'hui, dans JS, il existe une meilleure fa√ßon de d√©clarer des classes: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Counter</span></span></span><span class="hljs-class"> </span></span>{ reset(){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count = <span class="hljs-number"><span class="hljs-number">0</span></span> } next(){ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ++<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count } <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(initialValue = 0){ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count = initialValue } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myCounter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Counter() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">`</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${myCounter.next()}</span></span></span><span class="hljs-string">`</span></span>) <span class="hljs-comment"><span class="hljs-comment">// 1</span></span></code> </pre><br>  Le mot-cl√© ¬´classe¬ª ne fait rien sp√©cialement sous ¬´chat¬ª.  Vous pouvez le consid√©rer comme du sucre syntaxique, un wrapper pour l'approche ¬´prototype¬ª.  Si vous ex√©cutez le transporteur orient√© vers ES3, vous obtiendrez quelque chose comme ceci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> Counter = <span class="hljs-comment"><span class="hljs-comment">/** @class **/</span></span> (<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Counter</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">initialValue</span></span></span><span class="hljs-function">)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(initialValue === <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>) { initialValue = <span class="hljs-number"><span class="hljs-number">0</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count = initialValue } Counter.prototype.reset = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count = <span class="hljs-number"><span class="hljs-number">0</span></span> } Counter.prototype.next = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ ++<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._count } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Counter }()); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myCounter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Counter() <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(myCounter.next())</code> </pre><br>  Notez que le transpilateur a g√©n√©r√© du code qui est presque identique √† l'exemple pr√©c√©dent. <br><br><h3>  Fonctions fl√©ch√©es </h3><br>  Si vous √©crivez du code en JS depuis 5 ans, vous serez peut-√™tre surpris que je mentionne les fonctions fl√©ch√©es.  Mon conseil: utilisez toujours les fonctions fl√®ches jusqu'√† ce que vous ayez vraiment besoin d'une fonction r√©guli√®re.  Il se trouve que la d√©finition du constructeur et des m√©thodes de la classe est juste le cas lorsque nous devons utiliser des fonctions ordinaires.  L'une des caract√©ristiques des fonctions fl√©ch√©es est l'obscurcissement. <br><br><h3>  Cette fonction fl√©ch√©e </h3><br>  Certains peuvent supposer que les fonctions fl√©ch√©es en prennent la valeur actuelle lors de leur cr√©ation.  C'est incorrect d'un point de vue technique (le sens de cela n'est pas d√©fini, il est tir√© de l'environnement lexical), mais c'est un bon mod√®le mental.  Une fonction fl√®che comme celle-ci: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myArrowFunction = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.doSomething() }</code> </pre><br>  Vous pouvez le r√©√©crire comme ceci: <br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _this = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myRegularFunction = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ _this.doSomething() }</code> </pre><br>  Merci de votre attention.  Mes meilleurs v≈ìux. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr486048/">https://habr.com/ru/post/fr486048/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr486032/index.html">Comment devenir concepteur de dialogues</a></li>
<li><a href="../fr486034/index.html">Acc√®s rapide √† la gestion des produits via Open source</a></li>
<li><a href="../fr486036/index.html">Analyse de sentiment de texte sur Node.js</a></li>
<li><a href="../fr486042/index.html">Messagers et l√©gislation t√©l√©com</a></li>
<li><a href="../fr486046/index.html">Noyau Linux inclus WireGuard VPN</a></li>
<li><a href="../fr486050/index.html">Biblioth√®que JavaScript Webix vue par un d√©butant. Partie 3. Modules, diagrammes, tables arborescentes</a></li>
<li><a href="../fr486052/index.html">Scorched Earth est la m√®re de tous les jeux. Entretien avec le cr√©ateur</a></li>
<li><a href="../fr486056/index.html">Des scripts √† notre propre plateforme: comment nous avons automatis√© le d√©veloppement au Cyan Institute</a></li>
<li><a href="../fr486060/index.html">Trouver l'ordre dans le chaos de l'informatique: organiser votre propre d√©veloppement</a></li>
<li><a href="../fr486062/index.html">Rendu simple sans copie de la vid√©o avec acc√©l√©ration mat√©rielle en QML</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>