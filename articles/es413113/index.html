<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèæ‚Äçüåæ ü•á üåº Soporte de serializaci√≥n JavaScript JavaScript de clase üì∏ üë®üèø‚Äç‚öïÔ∏è üö¥üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Prologo 


 Actualmente, estoy desarrollando un editor de esquemas Javascript, y en el proceso de este trabajo, encontr√© un problema en el que este ar...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Soporte de serializaci√≥n JavaScript JavaScript de clase</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/413113/"><h3 id="prolog">  Prologo </h3><br><p>  Actualmente, estoy desarrollando un editor de esquemas Javascript, y en el proceso de este trabajo, encontr√© un problema en el que este art√≠culo se centrar√°, a saber, la serializaci√≥n y deserializaci√≥n de objetos de datos complejos. </p><br><p> Sin entrar en detalles del proyecto, noto que seg√∫n mi idea, el esquema es una matriz de elementos (v√©rtices) heredados de la clase base.  En consecuencia, cada clase secundaria implementa su propia l√≥gica.  Adem√°s, los v√©rtices contienen enlaces entre s√≠ (flechas), que tambi√©n deben conservarse.  Te√≥ricamente, los v√©rtices pueden referirse a s√≠ mismos directamente oa trav√©s de otros v√©rtices.  JSON.stringify est√°ndar no puede serializar dicha matriz, por lo que decid√≠ hacer mi propio serializador que resuelva los dos problemas descritos: </p><br><ol><li>  Posibilidad de guardar informaci√≥n de clase durante la serializaci√≥n y restaurarla durante la deserializaci√≥n. </li><li>  La capacidad de guardar y restaurar enlaces a objetos, incluidos  c√≠clico </li></ol><br><p>  Lea m√°s sobre el enunciado del problema y su soluci√≥n bajo el corte. </p><a name="habracut"></a><br><h3 id="proekt-serializatora-na-github">  Proyecto serializador de Github </h3><br><p>  Enlace al proyecto github: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enlace</a> . <br>  Ejemplos complejos tambi√©n se encuentran en la carpeta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">test-src</a> . </p><br><p>  Serializador recursivo: <a href="">enlace</a> . <br>  Serializador plano: <a href="">enlace</a> . </p><br><h3 id="postanovka-zadachi">  Declaraci√≥n del problema. </h3><br><p>  Como ya se√±al√©, la tarea inicial es serializar circuitos arbitrarios para el editor.  Para no perder el tiempo describiendo el editor, configuramos la tarea m√°s f√°cilmente.  Supongamos que queremos hacer una descripci√≥n formal de un esquema de algoritmo simple usando clases ES6 Javascript, y luego serializar y deserializar este esquema. </p><br><p>  En Internet, encontr√© una imagen adecuada del algoritmo m√°s simple para determinar el m√°ximo de dos valores: </p><br><p><img src="https://habrastorage.org/webt/dk/fa/yk/dkfaykajbnvk5ma4djpceof1wps.png" alt="imagen"></p><br><p>  Aqu√≠ debo decir que no soy un desarrollador de Javascript, y mi lenguaje "nativo" es C #, por lo que el enfoque para resolver el problema est√° dictado por la experiencia del desarrollo orientado a objetos en C #.  Mirando este diagrama, veo los v√©rtices de los siguientes tipos (los nombres condicionales y los roles especiales no juegan): </p><br><ul><li>  Iniciar v√©rtice (Inicio) </li><li>  Pico final (acabado) </li><li>  Team Top (Comando) </li><li>  V√©rtice de asignaci√≥n (Let) </li><li>  Verificaci√≥n Verificaci√≥n Arriba (si) </li></ul><br><p>  Estos v√©rtices tienen algunas diferencias entre s√≠ en su conjunto de datos o sem√°ntica, pero todos se heredan del v√©rtice base (Nodo).  En el mismo lugar, en la clase Node, se describe el campo de enlaces, que contiene enlaces a otros v√©rtices, y el m√©todo addLink permite agregar estos enlaces.  El c√≥digo completo de todas las clases se puede encontrar <a href="">aqu√≠</a> . </p><br><p>  Escribamos el c√≥digo que recoge el circuito de la imagen e intente serializar el resultado. </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo de dise√±o de algoritmo</b> <div class="spoiler_text"><pre><code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   let start = new Schema.Start(); let input = new Schema.Command(' A, B'); let check = new Schema.If('A &gt; B'); let maxIsA = new Schema.Let('Max', 'A'); let maxIsB = new Schema.Let('Max', 'B'); let output = new Schema.Command(' Max'); let finish = new Schema.Finish(); //   start.addLink(input); input.addLink(check); check.addLink(maxIsA, { condition: 'true' }); check.addLink(maxIsB, { condition: 'false' }); maxIsA.addLink(output); maxIsB.addLink(output); output.addLink(finish); //    ( ) let schema = [ start, input, check, maxIsA, maxIsB, output, finish ];</span></span></code> </pre> </div></div><br><p>  Si serializamos este esquema usando JSON.stringify, obtenemos algo terrible.  Dar√© las primeras l√≠neas del resultado, en las que agregu√© mis comentarios: </p><br><div class="spoiler">  <b class="spoiler_title">Resultado JSON.stringify</b> <div class="spoiler_text"><pre> <code class="hljs objectivec">[ <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"d9c8ab69-e4fa-4433-80bb-1cc7173024d6"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-string"><span class="hljs-string">"links"</span></span>: { <span class="hljs-string"><span class="hljs-string">"2e3d482b-187f-4c96-95cd-b3cde9e55a43"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"2e3d482b-187f-4c96-95cd-b3cde9e55a43"</span></span>, <span class="hljs-string"><span class="hljs-string">"target"</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"f87a3913-84b0-4b70-8927-6111c6628a1f"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-string"><span class="hljs-string">"links"</span></span>: { <span class="hljs-string"><span class="hljs-string">"4f623116-1b70-42bf-8a47-da1e9be5e4b2"</span></span>: { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"4f623116-1b70-42bf-8a47-da1e9be5e4b2"</span></span>, <span class="hljs-string"><span class="hljs-string">"target"</span></span>: <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> { <span class="hljs-string"><span class="hljs-string">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"94a47403-13ab-4c83-98fe-3b201744c8f2"</span></span>, <span class="hljs-string"><span class="hljs-string">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"If"</span></span>, <span class="hljs-string"><span class="hljs-string">"links"</span></span>: { ...</code> </pre> </div></div><br><p>  Porque  el primer v√©rtice conten√≠a un enlace al segundo, y que a los siguientes, luego, como resultado de su serializaci√≥n, se serializ√≥ todo el circuito.  Luego se serializ√≥ el segundo pico y todo lo que depend√≠a de √©l, y as√≠ sucesivamente.  Puede restaurar los enlaces originales de este hash solo mediante identificadores, pero no ayudar√°n si alguno de los v√©rtices se refiere a s√≠ mismo directamente oa trav√©s de otros v√©rtices.  En este caso, el serializador <u>arrojar√° un Error de tipo no capturado: convertir la estructura circular en un</u> error <u>JSON</u> .  Si no est√° claro, este es el ejemplo m√°s simple que genera este error: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://jsfiddle.net/L4guo86w/</a> . </p><br><p>  Adem√°s, JSON no contiene ninguna informaci√≥n sobre las clases de origen, por lo que no hay forma de comprender qu√© tipo era cada v√©rtice antes de la serializaci√≥n. </p><br><p>  Al darme cuenta de estos problemas, me conect√© a Internet y comenc√© a buscar soluciones listas para usar.  Hab√≠a muchos, pero la mayor√≠a eran muy voluminosos o requer√≠an una descripci√≥n especial de las clases serializables, por lo que se decidi√≥ hacer su propia bicicleta.  Y s√≠, me encantan las bicicletas. </p><br><h3 id="koncepciya-serializatora">  Concepto de serializador </h3><br><p>  Esta secci√≥n es para aquellos que desean participar en la creaci√≥n de un algoritmo de serializaci√≥n conmigo, aunque sea virtualmente. </p><br><h4 id="sohranenie-informacii-o-tipah-dannyh">  Guardar informaci√≥n del tipo de datos </h4><br><p>  Uno de los problemas con Javascript es la falta de metadatos que pueden hacer maravillas en lenguajes como C # o Java (atributos y reflexi√≥n).  Por otro lado, no necesito una serializaci√≥n s√∫per compleja con la capacidad de definir una lista de campos serializables, validaci√≥n y otros chips.  Por lo tanto, la idea principal es agregar informaci√≥n sobre su tipo al objeto y serializarlo con JSON.stringify ordinario. </p><br><p>  Mientras buscaba soluciones, me encontr√© con un art√≠culo interesante cuyo t√≠tulo se traduce como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"6 maneras incorrectas de agregar informaci√≥n de tipo en JSON"</a> .  De hecho, los m√©todos son muy buenos, y eleg√≠ el que est√° en el n√∫mero 5. Si eres demasiado vago para leer el art√≠culo, pero recomiendo hacerlo, describir√© brevemente este m√©todo: cuando serializamos un objeto, lo envolvemos en otro objeto con el √∫nico un campo cuyo nombre tiene el formato <code>"@&lt;type&gt;"</code> y el valor son los datos del objeto.  Durante la deserializaci√≥n, extraemos el nombre del tipo, recreamos el objeto del constructor y leemos los datos de sus campos. </p><br><p>  Si eliminamos enlaces de nuestro ejemplo anterior, entonces JSON.stringify est√°ndar serializa datos como este: </p><br><div class="spoiler">  <b class="spoiler_title">JSON.stringify</b> <div class="spoiler_text"><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"d04d6a58-7215-4102-aed0-32122e331cf4"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {} }, { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"5c58c3fc-8ce1-45a5-9e44-90d5cebe11d3"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">" A, B"</span></span> }, ... }</code> </pre> </div></div><br><p>  Y nuestro serializador lo envolver√° as√≠: </p><br><div class="spoiler">  <b class="spoiler_title">Resultado de serializaci√≥n</b> <div class="spoiler_text"><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Start"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"d04d6a58-7215-4102-aed0-32122e331cf4"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {} } }, { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"5c58c3fc-8ce1-45a5-9e44-90d5cebe11d3"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">" A, B"</span></span> } }, ... }</code> </pre> </div></div><br><p>  Por supuesto, hay un inconveniente: el serializador debe conocer los tipos que puede serializar, y los objetos en s√≠ no deben contener campos cuyo nombre comience con un perro.  Sin embargo, el segundo problema se resuelve mediante un acuerdo con los desarrolladores o reemplazando el s√≠mbolo del perro con otra cosa, y el primer problema se resuelve en una l√≠nea de c√≥digo (a continuaci√≥n se mostrar√° un ejemplo).  Sabemos exactamente lo que serializaremos, ¬øverdad? </p><br><h4 id="reshenie-problemy-so-ssylkami">  Resolviendo el problema del enlace </h4><br><p>  Todav√≠a es m√°s simple en t√©rminos de algoritmo, pero m√°s dif√≠cil de implementar. </p><br><p>  Al serializar instancias de clases registradas en el serializador, las almacenaremos en el cach√© y les asignaremos un n√∫mero de serie.  Si en el futuro volvemos a encontrarnos con esta instancia, en la primera definici√≥n agregaremos este n√∫mero (el nombre del campo tomar√° la forma <code>"@&lt;type&gt;|&lt;index&gt;"</code> ), y en el lugar de la serializaci√≥n insertaremos el enlace en forma de un objeto </p><br><pre> <code class="hljs json"> { <span class="hljs-attr"><span class="hljs-attr">"@&lt;type&gt;"</span></span>: &lt;index&gt; }</code> </pre> <br><p>  Por lo tanto, durante la deserializaci√≥n, observamos cu√°l es exactamente el valor del campo.  Si este es un n√∫mero, entonces extraemos el objeto del cach√© por este n√∫mero.  De lo contrario, esta es su primera definici√≥n. </p><br><p>  Regresemos el enlace de la primera parte superior del esquema a la segunda y veamos el resultado: </p><br><div class="spoiler">  <b class="spoiler_title">Resultado de serializaci√≥n</b> <div class="spoiler_text"><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Start"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"a26a3a29-9462-4c92-8d24-6a93dd5c819a"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"25fa2c44-0446-4471-a013-8b24ffb33bac"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Link"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"25fa2c44-0446-4471-a013-8b24ffb33bac"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command|1"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"4f4f5521-a2ee-4576-8aec-f61a08ed38dc"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">" A, B"</span></span> } } } } } } }, { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }, ... }</code> </pre> </div></div><br><p>  A primera vista no parece muy claro, porque  el segundo v√©rtice se define por primera vez dentro del primero en el objeto de comunicaci√≥n Enlace, pero es importante que este enfoque funcione.  Adem√°s, cre√© la segunda versi√≥n del serializador, que evita el √°rbol no en profundidad, sino en ancho, lo que evita tales "escaleras". </p><br><h3 id="sozdanie-serializatora">  Crear serializador </h3><br><p>  Esta secci√≥n est√° destinada a aquellos que est√©n interesados ‚Äã‚Äãen implementar las ideas descritas anteriormente. </p><br><h4 id="zagotovka-serializatora">  Serializador en blanco </h4><br><p>  Como cualquier otro, nuestro serializador tendr√° dos m√©todos principales: serializar y deserializar.  Adem√°s, necesitaremos un m√©todo que le informe al serializador sobre las clases que debe serializar (registrar) y las clases que no deben (ignorar).  Esto √∫ltimo es necesario para no serializar elementos DOM, objetos JQuery o cualquier otro tipo de datos que no puedan ser serializados o que no sean necesarios para ser serializados.  Por ejemplo, en mi editor almaceno un elemento visual correspondiente a un v√©rtice o enlace.  Se crea durante la inicializaci√≥n y, por supuesto, no debe caer en la base de datos. </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo de shell del serializador</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Serializer</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/** *  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._nameToCtor = []; <span class="hljs-comment"><span class="hljs-comment">//    this._ctorToName = []; //    this._ignore = [Element]; //    } /** *   * @param {string} alias  * @param {Function} ctor  */ register(alias, ctor) { if (typeof ctor === 'undefined' &amp;&amp; typeof alias === 'function') { //    -  ctor = alias; alias = ctor.name; } this._nameToCtor[alias] = ctor; this._ctorToName[ctor] = alias; } /** *     * @param {Function} ctor  */ ignore(ctor) { if (this._ignore.indexOf(ctor) &lt; 0) { this._ignore.push(ctor); } } /** *   * @param {any} val  * @param {Function} [replacer]       * @param {string} [space]   * @returns {string}  */ serialize(val, replacer, space) { return JSON.stringify(new SerializationContext(this).serialize(val), replacer, space); } /** *     json * @param {any} val    json * @returns {any}  */ deserialize(val) { //     if (isString(val)) val = JSON.parse(val); return new DeserializationContext(this).deserialize(val); } }</span></span></code> </pre> </div></div><br><p>  Explicaciones </p><br><p>  Para registrar una clase, debe pasar su constructor al m√©todo de registro de una de dos maneras: </p><br><ol><li>  registrarse (MyClass) </li><li>  registrarse ('MyNamespace.MyClass', MyClass) </li></ol><br><p>  En el primer caso, el nombre de la clase se extraer√° del nombre de la funci√≥n constructora (no es compatible con IE), en el segundo, usted mismo especifica el nombre.  El segundo m√©todo es preferible, porque  le permite usar espacios de nombres, y el primero, por dise√±o, est√° dise√±ado para registrar tipos de Javascript integrados con l√≥gica de serializaci√≥n redefinida. </p><br><p>  Para nuestro ejemplo, la inicializaci√≥n del serializador es la siguiente: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Schema <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'./schema'</span></span>; ... <span class="hljs-comment"><span class="hljs-comment">//   let serializer = new Serializer(); //   Object.keys(Schema).forEach(key =&gt; serializer.register(`Schema.${key}`, Schema[key]));</span></span></code> </pre> <br><p>  El objeto Schema contiene descripciones de todas las clases de v√©rtices, por lo que el c√≥digo de registro de clase cabe en una l√≠nea. </p><br><h4 id="kontekst-serializacii-i-deserializacii">  El contexto de serializaci√≥n y deserializaci√≥n. </h4><br><p>  Es posible que haya notado las clases cr√≠pticas SerializationContext y DeserializationContext.  Son ellos quienes hacen todo el trabajo, y son necesarios principalmente para separar los datos de diferentes procesos de serializaci√≥n / deserializaci√≥n, porque  para cada llamada necesitan almacenar informaci√≥n intermedia: un cach√© de objetos serializados y un n√∫mero de serie para el enlace. </p><br><h4 id="serializationcontext">  SerializationContext </h4><br><p>  Analizar√© en detalle solo el serializador recursivo, porque  su contraparte "plana" es algo m√°s complicada y solo difiere en su enfoque para procesar un √°rbol de objetos. </p><br><p>  Comencemos con el constructor: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *  * @param {Serializer} ser  */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(ser) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.__proto__.__proto__ = ser; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cache = []; <span class="hljs-comment"><span class="hljs-comment">//    this.index = 0; //     }</span></span></code> </pre> <br><p>  <code>this.__proto__.__proto__ = ser;</code> de explicar la l√≠nea misteriosa <code>this.__proto__.__proto__ = ser;</code> <br>  En la entrada del constructor, aceptamos el objeto del serializador en s√≠, y esta l√≠nea hereda nuestra clase de √©l.  Esto permite el acceso a los datos del serializador a trav√©s de <code>this</code> . <br>  Por ejemplo, <code>this._ignore</code> refiere a una lista de clases ignoradas del serializador (la "lista negra"), que es muy √∫til.  De lo contrario, tendr√≠amos que escribir algo como <code>this._serializer._ignore</code> . </p><br><p>  M√©todo de serializaci√≥n principal: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *   * @param {any} val  * @returns {string}  */</span></span> serialize(val) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>.isArray(val)) { <span class="hljs-comment"><span class="hljs-comment">//  return this.serializeArray(val); } else if (isObject(val)) { //  if (this._ignore.some(e =&gt; val instanceof e)) { //   return undefined; } else { return this.serializeObject(val); } } else { //   return val; } }</span></span></code> </pre> <br><p>  Cabe se√±alar que hay tres tipos b√°sicos de datos que procesamos: matrices, objetos y valores simples.  Si el constructor de un objeto est√° en la "lista negra", entonces este objeto no est√° serializado. </p><br><p>  Serializaci√≥n de matriz: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *   * @param {Array} val  * @returns {Array}  */</span></span> serializeArray(val) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = []; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> val) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> e = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.serialize(item); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> e !== <span class="hljs-string"><span class="hljs-string">'undefined'</span></span>) res.push(e); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; }</code> </pre> <br><p>  Puede escribir m√°s corto a trav√©s del mapa, pero esto no es cr√≠tico.  Solo una cosa es importante: verificar el valor de indefinido.  Si hay una clase no serializable en la matriz, entonces, sin esta verificaci√≥n, caer√° en la matriz como indefinida, lo que no es muy bueno.  Tambi√©n en mi implementaci√≥n, las matrices se serializan sin claves.  Te√≥ricamente, puede refinar el algoritmo para serializar matrices asociativas, pero para estos prop√≥sitos prefiero usar objetos.  Adem√°s, a JSON.stringify tampoco le gustan las matrices asociativas. </p><br><p>  Serializaci√≥n de objetos: </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *   * @param {Object} val  * @returns {Object}  */</span></span> serializeObject(val) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> name = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>._ctorToName[val.constructor]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (name) { <span class="hljs-comment"><span class="hljs-comment">//     if (!val.__uuid) val.__uuid = ++uuid; let cached = this.cache[val.__uuid]; if (cached) { //     if (!cached.index) { //     cached.index = ++this.index; let key = Object.keys(cached.ref)[0]; let old = cached.ref[key]; cached.ref[`@${name}|${cached.index}`] = old; delete cached.ref[key]; } //     return { [`@${name}`]: cached.index }; } else { let res; let cached = { ref: { [`@${name}`]: {} } }; this.cache[val.__uuid] = cached; if (typeof val.serialize === 'function') { //     res = val.serialize(); } else { //   res = this.serializeObjectInner(val); } cached.ref[Object.keys(cached.ref)[0]] = res; return cached.ref; } } else { //   return this.serializeObjectInner(val); } }</span></span></code> </pre> </div></div><br><p>  Obviamente, esta es la parte m√°s dif√≠cil del serializador, su coraz√≥n.  Vamos a desarmarlo. </p><br><p>  Para comenzar, verificamos si el constructor de la clase est√° registrado en el serializador.  Si no, entonces este es un objeto simple para el cual se llama al m√©todo de utilidad <code>serializeObjectInner</code> . </p><br><p>  De lo contrario, verificamos si al objeto se le asigna un identificador √∫nico <strong>__uuid</strong> .  Esta es una variable de contador simple que es com√∫n a todos los serializadores y se utiliza para mantener la referencia a la instancia de clase en la memoria cach√©.  Podr√≠a prescindir de √©l y almacenar la instancia en s√≠ sin una clave en el cach√©, pero luego para verificar si el objeto est√° almacenado en el cach√©, tendr√≠a que revisar todo el cach√©, y aqu√≠ es suficiente para verificar la clave.  Creo que esto es m√°s r√°pido en t√©rminos de implementaci√≥n interna de objetos en los navegadores.  Adem√°s, intencionalmente no serializo campos que comienzan con dos guiones bajos, por lo que el campo <strong>__uuid</strong> no caer√° en el json resultante, como otros campos de clase privada.  Si esto es inaceptable para su tarea, puede cambiar esta l√≥gica. </p><br><p>  Luego, por el valor de <strong>__uuid,</strong> buscamos un objeto que describa la instancia de la clase en el cach√© (en <strong>cach√©</strong> ). </p><br><p>  Si tal objeto existe, entonces el valor ya se ha serializado anteriormente.  En este caso, asignamos un n√∫mero de serie al objeto, si esto no se ha hecho antes: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!cached.index) { <span class="hljs-comment"><span class="hljs-comment">//     cached.index = ++this.index; let key = Object.keys(cached.ref)[0]; let old = cached.ref[key]; cached.ref[`@${name}|${cached.index}`] = old; delete cached.ref[key]; }</span></span></code> </pre> <br><p>  El c√≥digo parece confuso y se puede simplificar asignando un n√∫mero a todas las clases que serializamos.  Pero para depurar y percibir el resultado, es mejor cuando el n√∫mero se asigna solo a aquellas clases a las que hay enlaces en el futuro. </p><br><p>  Cuando se asigna el n√∫mero, devolvemos el enlace de acuerdo con el algoritmo: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     return { [`@${name}`]: cached.index };</span></span></code> </pre> <br><p>  Si el objeto se serializa por primera vez, creamos una instancia de su cach√©: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> cached = { <span class="hljs-attr"><span class="hljs-attr">ref</span></span>: { [<span class="hljs-string"><span class="hljs-string">`@</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${name}</span></span></span><span class="hljs-string">`</span></span>]: {} } }; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.cache[val.__uuid] = cached;</code> </pre> <br><p>  Y luego serializarlo: </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> val.serialize === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//     res = val.serialize(); } else { //   res = this.serializeObjectInner(val); } cached.ref[Object.keys(cached.ref)[0]] = res;</span></span></code> </pre> <br><p>  Hay una verificaci√≥n para la implementaci√≥n de la interfaz de serializaci√≥n por parte de la clase (que se discutir√° m√°s adelante), as√≠ como la construcci√≥n de <code>Object.keys(cached.ref)[0]</code> .  El hecho es que cached.ref almacena un enlace al objeto contenedor <code>{ "@&lt;type&gt;[|&lt;index&gt;]": &lt;&gt; }</code> , pero el nombre del campo de objeto es desconocido para nosotros, porque  En esta etapa, a√∫n no sabemos si el nombre contendr√° el n√∫mero de objeto (√≠ndice).  Esta construcci√≥n simplemente extrae el primer y √∫nico campo del objeto. </p><br><p>  Finalmente, el m√©todo de utilidad de serializar objetos internos: </p><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/** *   * @param {Object} val  * @returns {Object}  */</span></span> serializeObjectInner(val) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> res = {}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyNames(val)) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!(isString(key) &amp;&amp; key.startsWith(<span class="hljs-string"><span class="hljs-string">'__'</span></span>))) { <span class="hljs-comment"><span class="hljs-comment">//  ,      res[key] = this.serialize(val[key]); } } return res; }</span></span></code> </pre> <br><p>  Creamos un nuevo objeto y copiamos los campos del antiguo en √©l. </p><br><h4 id="deserializationcontext">  Deserializaci√≥n Contexto </h4><br><p>  El proceso de deserializaci√≥n funciona en orden inverso y no necesita comentarios especiales. </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="hljs powershell">/** *   */ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">DeserializationContext</span></span></span></span> { /** *  * @<span class="hljs-keyword"><span class="hljs-keyword">param</span></span> {Serializer} ser  */ constructor(ser) { this.__proto__.__proto__ = ser; this.cache = []; //    } /** *   json * @<span class="hljs-keyword"><span class="hljs-keyword">param</span></span> {any} val  json * @returns {any}  */ deserialize(val) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Array.isArray(val)) { //  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.deserializeArray(val); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isObject(val)) { //  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.deserializeObject(val); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; } } /** *   * @<span class="hljs-keyword"><span class="hljs-keyword">param</span></span> {Object} val  * @returns {Object}  */ deserializeArray(val) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val.map(item =&gt; this.deserialize(item)); } /** *   * @<span class="hljs-keyword"><span class="hljs-keyword">param</span></span> {Array} val  * @returns {Array}  */ deserializeObject(val) { let res = {}; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let key of Object.getOwnPropertyNames(val)) { let <span class="hljs-keyword"><span class="hljs-keyword">data</span></span> = val[<span class="hljs-type"><span class="hljs-type">key</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isString(key) &amp;&amp; key.startsWith(<span class="hljs-string"><span class="hljs-string">'@'</span></span>)) { //   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (isInteger(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>)) { //  res = this.cache[<span class="hljs-type"><span class="hljs-type">data</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (res) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { console.error(`     <span class="hljs-variable"><span class="hljs-variable">$</span></span>{<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>}`); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">data</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //   let [<span class="hljs-type"><span class="hljs-type">name</span></span>, <span class="hljs-type"><span class="hljs-type">id</span></span>] = key.substr(<span class="hljs-number"><span class="hljs-number">1</span></span>).split(<span class="hljs-string"><span class="hljs-string">'|'</span></span>); let ctor = this._nameToCtor[<span class="hljs-type"><span class="hljs-type">name</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctor) { //     res = new ctor(); //   ,    <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (id) this.cache[<span class="hljs-type"><span class="hljs-type">id</span></span>] = res; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (typeof res.deserialize === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) { //     res.deserialize(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (let key of Object.getOwnPropertyNames(<span class="hljs-keyword"><span class="hljs-keyword">data</span></span>)) { res[<span class="hljs-type"><span class="hljs-type">key</span></span>] = this.deserialize(data[<span class="hljs-type"><span class="hljs-type">key</span></span>]); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //    console.error(`  <span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$</span></span></span><span class="hljs-string">{name}"</span></span>  .`); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val[<span class="hljs-type"><span class="hljs-type">key</span></span>]; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { //   res[<span class="hljs-type"><span class="hljs-type">key</span></span>] = this.deserialize(val[<span class="hljs-type"><span class="hljs-type">key</span></span>]); } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res; } }</code> </pre> </div></div><br><h3 id="dopolnitelnye-vozmozhnosti">  Caracter√≠sticas adicionales </h3><br><h4 id="interfeys-serializacii">  Interfaz de serializaci√≥n </h4><br><p>  No hay soporte de interfaz en Javascript, pero podemos estar de acuerdo en que si la clase implementa los m√©todos de serializaci√≥n y deserializaci√≥n, estos m√©todos se utilizar√°n para la serializaci√≥n / deserializaci√≥n, respectivamente. </p><br><p>  Adem√°s, Javascript le permite implementar estos m√©todos para los tipos integrados, por ejemplo, para Fecha: </p><br><div class="spoiler">  <b class="spoiler_title">Fecha de serializaci√≥n al formato ISO</b> <div class="spoiler_text"><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.prototype.serialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.toISOString(); }; <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>.prototype.deserialize = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">val</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> date = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Date</span></span>(val); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setDate(date.getDate()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.setTime(date.getTime()); };</code> </pre> </div></div><br><p>  Lo principal es recordar registrar el tipo de fecha: <code>serializer.register(Date);</code>  . </p><br><p>  Resultado: </p><br><pre> <code class="hljs json">{ <span class="hljs-attr"><span class="hljs-attr">"@Date"</span></span>: <span class="hljs-string"><span class="hljs-string">"2018-06-02T20:41:06.861Z"</span></span> }</code> </pre> <br><p>  La √∫nica limitaci√≥n: el resultado de la serializaci√≥n no debe ser un n√∫mero entero, porque  en este caso, se interpretar√° como una referencia al objeto. </p><br><p>  Del mismo modo, puede serializar clases simples en cadenas.  Un ejemplo de serializaci√≥n de la clase Color, que describe el color, a la l√≠nea <code>#rrggbb</code> est√° en <a href="">github</a> . </p><br><h4 id="ploskiy-serializator">  Serializador plano </h4><br><p>  Especialmente para ustedes, queridos lectores, escrib√≠ la <a href="">segunda versi√≥n del serializador</a> , que atraviesa el √°rbol de objetos no recursivamente en profundidad, sino iterativamente en ancho usando una cola. </p><br><p>  A modo de comparaci√≥n, dar√© un ejemplo de serializaci√≥n de los dos primeros v√©rtices de nuestro esquema en ambos casos. </p><br><div class="spoiler">  <b class="spoiler_title">Serializador recursivo (serializaci√≥n en profundidad)</b> <div class="spoiler_text"><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Start"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"5ec74f26-9515-4789-b852-12feeb258949"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"102c3dca-8e08-4389-bc7f-68862f2061ef"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Link"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"102c3dca-8e08-4389-bc7f-68862f2061ef"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command|1"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"447f6299-4bd4-48e4-b271-016a0d47fc0e"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">" A, B"</span></span> } } } } } } }, { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } ]</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Serializador plano (serializaci√≥n amplia)</b> <div class="spoiler_text"><pre> <code class="hljs json">[ { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Start"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"1412603f-24c2-4513-836e-f2b0c0392483"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Start"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"b94ac7e5-d75f-44c1-960f-a02f52c994da"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Link"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"b94ac7e5-d75f-44c1-960f-a02f52c994da"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command"</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> } } } } } }, { <span class="hljs-attr"><span class="hljs-attr">"@Schema.Command|1"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"a93e452e-4276-4d6a-86a1-0681226d79f0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Command"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"links"</span></span>: {}, <span class="hljs-attr"><span class="hljs-attr">"command"</span></span>: <span class="hljs-string"><span class="hljs-string">" A, B"</span></span> } } ]</code> </pre> </div></div><br><p>  Personalmente, me gusta la segunda opci√≥n incluso m√°s que la primera, pero debe recordarse que al elegir una de las opciones, no se puede usar la otra.  Se trata de los enlaces.  Tenga en cuenta que en el serializador plano, un enlace al segundo v√©rtice va antes de su descripci√≥n. </p><br><h3 id="plyusy-i-minusy-serializatora">  Pros y contras del serializador </h3><br><p>  Pros: </p><br><ul><li>  El c√≥digo del serializador es bastante simple y compacto (aproximadamente 300 l√≠neas, la mitad de las cuales son comentarios). </li><li>  El serializador es f√°cil de usar y no requiere bibliotecas de terceros. </li><li>  Hay soporte incorporado para la interfaz de serializaci√≥n para la serializaci√≥n arbitraria de clases. </li><li>  El resultado es agradablemente agradable a la vista (en mi humilde opini√≥n). </li><li>  Desarrollar un serializador / deserializador similar en otros idiomas no es un problema.  Esto puede ser necesario si el resultado de la serializaci√≥n se procesa en la parte posterior. </li></ul><br><p>  Contras: </p><br><ul><li>  El serializador requiere el registro de clases que puede serializar. </li><li>  Existen ligeras restricciones en los nombres de campo de los objetos. </li><li>  El serializador est√° escrito noob en Javascript, por lo que puede contener errores y errores. </li><li>  El rendimiento en grandes cantidades de datos puede verse afectado. </li></ul><br><p>  Tambi√©n una desventaja es que el c√≥digo est√° escrito en ES6.  Por supuesto, es posible convertir a versiones anteriores de Javascript, pero no verifiqu√© la compatibilidad del c√≥digo resultante con diferentes navegadores. </p><br><h3 id="drugie-moi-publikacii">  Mis otras publicaciones </h3><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Localizaci√≥n de proyectos en .NET con un int√©rprete de funciones.</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Relleno de plantillas de texto con datos basados ‚Äã‚Äãen modelos.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Implementaci√≥n de .NET usando funciones de bytecode din√°mico (IL)</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u="><br></a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es413113/">https://habr.com/ru/post/es413113/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es413103/index.html">3CX v15.5 Actualizaci√≥n 5 Beta e integraci√≥n REST con AmoCRM lanzado</a></li>
<li><a href="../es413105/index.html">Notas del proveedor de IoT. Activaci√≥n y seguridad en LoraWAN</a></li>
<li><a href="../es413107/index.html">Traducci√≥n del wiki del proyecto Svelto.ECS. Marco ECS para Unity3D</a></li>
<li><a href="../es413109/index.html">C√≥mo construir una plataforma de integraci√≥n de productos SaaS: experiencia de pago de Cloud Poster</a></li>
<li><a href="../es413111/index.html">STM32 + NetBeans =?</a></li>
<li><a href="../es413117/index.html">C√≥mo programar de forma segura en bash</a></li>
<li><a href="../es413119/index.html">El resumen de materiales frescos del mundo del front-end para la √∫ltima semana No. 317 (28 de mayo - 3 de junio de 2018)</a></li>
<li><a href="../es413121/index.html">Recorrido fotogr√°fico por el coworking de Mosc√∫ #tceh</a></li>
<li><a href="../es413123/index.html">√öNETE en bases de datos NoSQL</a></li>
<li><a href="../es413125/index.html">La terapia g√©nica brinda a los pacientes peque√±os con atrofia muscular la oportunidad de sobrevivir</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>