<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎲 🌂 💪🏻 Teknik mengembangkan server yang sangat andal di Go 👏🏼 ⛹️ 🚢</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dari waktu ke waktu, programmer web menghadapi tugas yang bahkan dapat menakuti para profesional. Kita berbicara tentang mengembangkan aplikasi server...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Teknik mengembangkan server yang sangat andal di Go</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/413681/">  Dari waktu ke waktu, programmer web menghadapi tugas yang bahkan dapat menakuti para profesional.  Kita berbicara tentang mengembangkan aplikasi server yang tidak memiliki hak untuk melakukan kesalahan, tentang proyek-proyek di mana biaya kegagalan sangat tinggi.  Penulis materi, terjemahan yang kami terbitkan hari ini, akan berbicara tentang bagaimana mendekati tugas-tugas tersebut. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/2r/ma/ty/2rmaty9ihtz7cjzhhvzqgm5e7ia.jpeg"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Tingkat keandalan apa yang dibutuhkan proyek Anda?</font> </h2><br>  Sebelum mempelajari rincian pengembangan aplikasi server yang sangat andal, Anda harus bertanya pada diri sendiri apakah proyek Anda benar-benar membutuhkan tingkat keandalan tertinggi yang dapat dicapai.  Proses pengembangan sistem yang dirancang untuk skenario kerja di mana kesalahannya mirip dengan bencana universal dapat menjadi sangat rumit untuk sebagian besar proyek di mana konsekuensi dari kemungkinan kesalahan tidak terlalu menakutkan. <br><br>  Jika biaya kesalahan tidak menjadi sangat tinggi, suatu pendekatan dapat diterima, di mana pengembang melakukan upaya yang paling masuk akal untuk memastikan pengoperasian proyek, dan jika masalah muncul, ia hanya memahaminya.  Alat pemantauan modern dan proses penyebaran perangkat lunak berkelanjutan memungkinkan Anda mengidentifikasi masalah produksi dengan cepat dan memperbaikinya hampir secara instan.  Dalam banyak kasus, ini sudah cukup. <br><br>  Dalam proyek yang saya kerjakan hari ini, ini tidak begitu.  Kita berbicara tentang implementasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blockchain</a> - infrastruktur server terdistribusi untuk eksekusi kode yang aman di lingkungan dengan tingkat kepercayaan rendah, sambil mencapai konsensus.  Salah satu aplikasi teknologi ini adalah mata uang digital.  Ini adalah contoh klasik dari sistem dengan biaya kesalahan yang sangat tinggi.  Dalam hal ini, pengembang proyek benar-benar perlu membuatnya sangat, sangat andal. <br><br>  Namun, dalam beberapa proyek lain, bahkan jika mereka tidak terkait dengan keuangan, pengejaran keandalan kode tertinggi masuk akal.  Biaya pemeliharaan basis kode yang sering rusak dapat dengan cepat mencapai nilai-nilai astronomi.  Kemampuan untuk mengidentifikasi masalah pada tahap awal proses pengembangan, ketika biaya untuk memperbaikinya masih rendah, terlihat seperti imbalan yang sangat nyata untuk investasi waktu dan upaya tepat waktu ke dalam metodologi pengembangan sistem yang sangat andal. <br><br><h2>  <font color="#3AC1EF">Mungkin solusinya adalah TDD?</font> </h2><br>  Pengembangan melalui pengujian ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Test Driven Development</a> , TDD) sering dianggap obat terbaik untuk kode buruk.  TDD adalah metodologi pengembangan murni, dalam penerapan tes yang ditulis pertama, dan hanya kemudian - kode yang ditambahkan ke proyek hanya ketika tes yang memeriksanya, berhenti menghasilkan kesalahan.  Proses ini menjamin cakupan 100% dari kode dengan tes dan sering memberikan ilusi bahwa kode diuji dalam semua varian yang mungkin dari penggunaannya. <br><br>  Namun, ini tidak benar.  TDD adalah metodologi hebat yang bekerja dengan baik di beberapa area, tetapi untuk mengembangkan kode yang benar-benar andal, tidak cukup.  Lebih buruk lagi, TDD menginspirasi pengembang dengan kepercayaan yang salah dan penerapan metodologi ini dapat mengarah pada fakta bahwa ia tidak akan, karena malas, menulis tes untuk memeriksa kegagalan sistem dalam situasi yang kemunculannya, dari sudut pandang akal sehat, hampir mustahil.  Kami akan membicarakan ini nanti. <br><br><h2>  <font color="#3AC1EF">Tes adalah kunci keandalan</font> </h2><br>  Sebenarnya, tidak masalah apakah Anda membuat tes sebelum menulis kode, atau setelahnya, apakah Anda menggunakan metodologi pengembangan seperti TDD, atau tidak.  Yang utama adalah fakta menjalani tes.  Pengujian adalah benteng pertahanan terbaik yang melindungi kode Anda dari masalah produksi. <br><br>  Karena kita akan menjalankan tes kita sangat sering, idealnya setelah menambahkan setiap baris baru ke kode, tes tersebut perlu dilakukan secara otomatis.  Kepercayaan kami pada kualitas kode tidak boleh didasarkan pada pemeriksaan manualnya.  Masalahnya, orang cenderung membuat kesalahan.  Perhatian seseorang terhadap detail melemah setelah dia menyelesaikan tugas yang sama berkali-kali berturut-turut. <br><br>  Tes harus cepat.  Sangat cepat. <br><br>  Jika diperlukan lebih dari beberapa detik untuk menyelesaikan rangkaian uji, pengembang kemungkinan besar akan malas dan menambahkan kode ke proyek tanpa mengujinya.  Kecepatan adalah salah satu kekuatan terbesar Go.  Toolkit pengembangan dalam bahasa ini adalah salah satu yang tercepat di antara yang ada.  Menyusun, membangun kembali, dan menguji proyek dilakukan dalam hitungan detik. <br><br>  Tes, sebagai tambahan, adalah salah satu kekuatan pendorong penting dari proyek open source.  Misalnya, ini berlaku untuk semua yang terkait dengan teknologi blockchain.  Sumber terbuka di sini hampir merupakan sebuah agama.  Basis kode untuk mendapatkan kepercayaan pada mereka yang akan menggunakannya harus terbuka.  Ini memungkinkan, misalnya, untuk melakukan auditnya, ia menciptakan suasana desentralisasi, di mana tidak ada entitas tertentu yang mengendalikan proyek. <br><br>  Tidak masuk akal untuk menunggu kontribusi yang signifikan terhadap proyek open source dari pengembang eksternal jika proyek ini tidak termasuk tes kualitas.  Peserta proyek eksternal membutuhkan mekanisme untuk dengan cepat memeriksa kompatibilitas dari apa yang mereka tulis dengan apa yang sudah ditambahkan ke proyek.  Seluruh rangkaian tes, pada kenyataannya, harus dilakukan secara otomatis setelah menerima setiap permintaan untuk menambahkan kode baru ke proyek.  Jika sesuatu yang seharusnya ditambahkan ke proyek melalui permintaan seperti itu merusakkan sesuatu, tes harus segera melaporkannya. <br><br>  Cakupan penuh basis kode dengan tes adalah metrik yang menipu tetapi penting.  Tujuan mencapai cakupan kode 100% dengan tes mungkin tampak berlebihan, tetapi jika Anda memikirkannya, ternyata jika kode tersebut tidak sepenuhnya dicakup oleh tes, beberapa bagian dari kode dikirim ke produksi tanpa verifikasi, yang belum pernah dilakukan sebelumnya. <br><br>  Cakupan penuh kode dengan tes tidak selalu berarti bahwa ada cukup tes dalam proyek, dan tidak berarti bahwa ini adalah tes yang benar-benar memberikan semua opsi untuk menggunakan kode.  Dengan percaya diri, kami hanya dapat mengatakan bahwa jika proyek tidak 100% dicakup dalam pengujian, pengembang tidak dapat memastikan keandalan mutlak kode, karena beberapa bagian dari kode tidak pernah diuji. <br><br>  Meskipun demikian, ada situasi di mana ada terlalu banyak tes.  Idealnya, setiap kesalahan yang mungkin harus mengarah pada kegagalan satu tes.  Jika jumlah tes berlebihan, yaitu, tes yang berbeda memeriksa fragmen kode yang sama, kemudian memodifikasi kode yang ada dan mengubah perilaku sistem yang ada akan mengarah pada fakta bahwa agar tes yang ada sesuai dengan kode baru, akan terlalu banyak waktu untuk memprosesnya . <br><br><h2>  <font color="#3AC1EF">Mengapa Go adalah pilihan tepat untuk proyek yang sangat andal?</font> </h2><br>  Go adalah bahasa yang diketik statis.  Jenis adalah kontrak antara berbagai bagian kode yang dieksekusi bersama.  Tanpa pengecekan tipe otomatis selama proses perakitan proyek, jika Anda harus mematuhi aturan ketat untuk mencakup kode dengan pengujian, kami harus menerapkan tes yang memverifikasi "kontrak" ini dengan kami sendiri.  Ini, misalnya, terjadi di proyek server dan klien berdasarkan JavaScript.  Menulis tes kompleks yang hanya ditujukan untuk memeriksa jenis berarti banyak pekerjaan tambahan, yang, dalam kasus Go, dapat dihindari. <br><br>  Go adalah bahasa yang sederhana dan dogmatis.  Seperti yang Anda ketahui, Go menyertakan banyak ide tradisional untuk bahasa pemrograman, seperti warisan OOP klasik.  Kompleksitas adalah musuh terburuk dari kode yang dapat diandalkan.  Masalah cenderung bersembunyi di sendi struktur yang kompleks.  Ini dinyatakan dalam kenyataan bahwa meskipun opsi tipikal untuk menggunakan desain tertentu mudah untuk diuji, ada kasus perbatasan aneh yang mungkin tidak dipikirkan oleh pengembang tes.  Proyek ini, pada akhirnya, akan menurunkan hanya satu dari kasus-kasus ini.  Dalam pengertian ini, dogmatisme juga berguna.  Di Go, seringkali hanya ada satu cara untuk melakukan suatu tindakan.  Ini mungkin tampak seperti faktor yang menahan semangat bebas programmer, tetapi ketika sesuatu dapat dilakukan hanya dengan satu cara, sulit untuk melakukan sesuatu yang salah. <br><br>  Go singkat tapi ekspresif.  Kode yang mudah dibaca lebih mudah untuk dianalisis dan diaudit.  Jika kode terlalu verbose, tujuan utamanya mungkin tenggelam dalam "noise" konstruksi tambahan.  Jika kodenya terlalu singkat, program-program di atasnya mungkin sulit dibaca dan dipahami.  Go menjaga keseimbangan antara keringkasan dan ekspresi.  Misalnya, tidak ada banyak konstruksi bantu di dalamnya, seperti dalam bahasa seperti Java atau C ++.  Pada saat yang sama, konstruksi Go, yang berkaitan, misalnya, dengan bidang-bidang seperti penanganan kesalahan, sangat jelas dan cukup rinci, yang menyederhanakan pekerjaan programmer, membantunya memastikan, misalnya, bahwa ia telah memeriksa semua yang mungkin. <br><br>  Go memiliki mekanisme penanganan kesalahan dan pemulihan yang jelas setelah crash.  Mekanisme penanganan kesalahan runtime yang baik adalah landasan kode yang sangat andal.  Go memiliki aturan ketat untuk mengembalikan dan mendistribusikan kesalahan.  Dalam lingkungan seperti Node.js, mencampuradukkan pendekatan untuk mengendalikan aliran program, seperti panggilan balik, janji, dan fungsi asinkron, sering menyebabkan kesalahan yang tidak tertangani, seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penolakan janji yang tidak tertangani</a> .  Memulihkan program setelah kejadian serupa hampir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak mungkin</a> . <br><br>  Go memiliki perpustakaan standar yang luas.  Ketergantungan adalah risiko, terutama ketika sumbernya adalah proyek di mana perhatian yang cukup diberikan untuk keandalan kode.  Aplikasi server yang masuk ke produksi berisi semua dependensi.  Selain itu, jika terjadi kesalahan, pengembang aplikasi yang sudah selesai akan bertanggung jawab untuk ini, dan bukan orang yang membuat salah satu perpustakaan yang digunakan olehnya.  Akibatnya, dalam lingkungan di mana proyek yang ditulisnya kewalahan dengan ketergantungan kecil, lebih sulit untuk membuat aplikasi yang andal. <br><br>  Ketergantungan juga merupakan risiko keamanan, karena tingkat kerentanan proyek sesuai dengan tingkat kerentanan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ketergantungannya</a> yang paling <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak aman</a> .  Pustaka standar Go yang luas dikelola oleh pengembangnya dalam kondisi sangat baik, keberadaannya mengurangi kebutuhan akan ketergantungan eksternal. <br><br>  Kecepatan pengembangan tinggi.  Fitur utama dari lingkungan seperti Node.js adalah siklus pengembangannya yang sangat singkat.  Menulis kode membutuhkan waktu lebih sedikit, sebagai akibatnya, programmer menjadi lebih produktif. <br><br>  Go juga memiliki kecepatan pengembangan yang tinggi.  Seperangkat alat untuk membangun proyek cukup cepat untuk dapat langsung melihat kode dalam tindakan.  Waktu kompilasi sangat singkat, sebagai hasilnya, menjalankan kode on Go dianggap seolah-olah tidak dikompilasi, tetapi ditafsirkan.  Pada saat yang sama, bahasa tersebut memiliki abstraksi yang cukup, seperti sistem pengumpulan sampah, yang memungkinkan pengembang untuk mengarahkan upaya untuk mengimplementasikan fungsionalitas proyek mereka, dan tidak menyelesaikan tugas tambahan. <br><br><h2>  <font color="#3AC1EF">Eksperimen praktis</font> </h2><br>  Sekarang kita telah menyuarakan poin-poin umum yang cukup, saatnya untuk melihat kode.  Kita membutuhkan contoh yang cukup sederhana sehingga, ketika mempelajarinya, kita dapat fokus pada metodologi pengembangan, tetapi pada saat yang sama, itu harus cukup maju sehingga kita, ketika menjelajahi itu, memiliki sesuatu untuk dibicarakan.  Saya memutuskan bahwa akan lebih mudah untuk mengambil sesuatu dari apa yang saya lakukan setiap hari.  Oleh karena itu, saya mengusulkan untuk mengurai penciptaan server yang memproses sesuatu yang menyerupai transaksi keuangan.  Pengguna server ini akan dapat memeriksa saldo akun yang terkait dengan akun mereka.  Selain itu, mereka akan dapat mentransfer dana dari satu akun ke akun lainnya. <br><br>  Kami akan berusaha untuk tidak menyulitkan contoh ini.  Sistem kami akan memiliki satu server.  Kami tidak akan menghubungi sistem otentikasi dan kriptografi.  Ini adalah bagian integral dari proyek kerja.  Tetapi kita perlu fokus pada inti dari proyek semacam itu, untuk menunjukkan bagaimana membuatnya seandal mungkin. <br><br><h3>  <font color="#3AC1EF">Ivid Membagi proyek kompleks menjadi bagian-bagian yang nyaman untuk dikelola</font> </h3><br>  Kompleksitas adalah musuh terburuk keandalan.  Salah satu pendekatan terbaik ketika bekerja dengan sistem yang kompleks adalah dengan menerapkan prinsip lama "membagi dan menaklukkan."  Tugas ini perlu dibagi menjadi beberapa subtugas kecil dan menyelesaikannya secara terpisah.  Sisi mana yang mendekati partisi tugas kita?  Kami akan mengikuti prinsip <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tanggung jawab bersama</a> .  Setiap bagian dari proyek kami harus memiliki bidang tanggung jawabnya sendiri. <br><br>  Ide ini sangat cocok dengan arsitektur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">microservice yang</a> populer.  Server kami akan terdiri dari layanan terpisah.  Setiap layanan akan memiliki area tanggung jawab yang jelas dan antarmuka yang dijelaskan dengan jelas untuk berinteraksi dengan layanan lain. <br><br>  Setelah kami menyusun server dengan cara ini, kami akan dapat membuat keputusan tentang bagaimana masing-masing layanan harus bekerja.  Semua layanan dapat dilakukan bersama, dalam proses yang sama, dari masing-masing Anda dapat membuat server terpisah dan membangun interaksinya menggunakan RPC, Anda dapat memisahkan layanan dan menjalankannya di komputer yang berbeda. <br><br>  Kami tidak akan mempersulit tugas, kami akan memilih opsi yang paling sederhana.  Yaitu, semua layanan akan dieksekusi dalam proses yang sama, mereka akan bertukar informasi secara langsung, seperti perpustakaan.  Jika perlu, di masa depan solusi arsitektur ini dapat dengan mudah ditinjau dan diubah. <br><br>  Jadi layanan apa yang kita butuhkan?  Server kami mungkin terlalu sederhana untuk membaginya menjadi beberapa bagian, tetapi, untuk tujuan pendidikan, kami, bagaimanapun, akan membaginya.  Kita perlu menanggapi permintaan HTTP klien yang ditujukan untuk memeriksa saldo dan mengeksekusi transaksi.  Salah satu layanan dapat bekerja dengan antarmuka HTTP untuk klien.  <code>PublicApi</code> saja <code>PublicApi</code> .  Layanan lain akan memiliki informasi tentang keadaan sistem - neraca.  <code>StateStorage</code> saja <code>StateStorage</code> .  Layanan ketiga akan menggabungkan keduanya yang dijelaskan di atas dan menerapkan logika "kontrak" yang ditujukan untuk mengubah saldo.  Tugas layanan ketiga adalah pelaksanaan kontrak.  <code>VirtualMachine</code> saja <code>VirtualMachine</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8a2/a04/79b/8a2a0479b551df5fd2a3c46e67bb46a7.png"></div><br>  <i><font color="#999999">Arsitektur Server Aplikasi</font></i> <br><br>  Tempatkan kode layanan ini dalam folder proyek <code>/services/publicapi</code> , <code>/services/virtualmachine</code> dan <code>/services/statestorage</code> . <br><br><h3>  <font color="#3AC1EF">▍ Definisi tanggung jawab layanan yang jelas</font> </h3><br>  Selama implementasi layanan, kami ingin dapat bekerja dengan masing-masing secara individual.  Bahkan dimungkinkan untuk membagi pengembangan layanan ini antara programmer yang berbeda.  Karena layanan saling bergantung, dan kami ingin memparalelkan pengembangannya, kami harus mulai bekerja dengan definisi antarmuka yang jelas yang mereka gunakan untuk berinteraksi satu sama lain.  Dengan menggunakan antarmuka ini, kita dapat menguji layanan secara mandiri dengan menyiapkan stubs untuk semua yang ada di luar masing-masing. <br><br>  Bagaimana cara mendeskripsikan antarmuka?  Salah satu opsi adalah untuk mendokumentasikan semuanya, tetapi dokumentasi memiliki properti menjadi usang, dalam proses mengerjakan suatu proyek, perbedaan mulai menumpuk antara dokumentasi dan kode.  Selain itu, kita dapat menggunakan deklarasi antarmuka Go.  Ini adalah opsi yang menarik, tetapi lebih baik untuk mendeskripsikan antarmuka sehingga deskripsi ini tidak tergantung pada bahasa pemrograman tertentu.  Ini akan berguna bagi kita dalam situasi yang sangat nyata, jika dalam proses mengerjakan suatu proyek akan diputuskan untuk mengimplementasikan beberapa layanannya dalam bahasa lain, kemampuan yang lebih cocok untuk memecahkan masalah mereka. <br><br>  Salah satu opsi untuk menggambarkan antarmuka adalah dengan menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">protobuf</a> .  Ini adalah protokol independen bahasa dan bahasa yang sederhana untuk menggambarkan pesan dan titik akhir layanan. <br><br>  Mari kita mulai dengan antarmuka untuk layanan <code>StateStorage</code> .  Kami akan menyajikan keadaan aplikasi dalam bentuk struktur tampilan nilai kunci.  Berikut adalah kode untuk file <code>statestorage.proto</code> : <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">syntax</span></span> = <span class="hljs-string"><span class="hljs-string">"proto3"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">package</span></span> statestorage; <span class="hljs-attribute"><span class="hljs-attribute">service</span></span> StateStorage { <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> WriteKey (WriteKeyInput) returns (WriteKeyOutput); <span class="hljs-attribute"><span class="hljs-attribute">rpc</span></span> ReadKey (ReadKeyInput) returns (ReadKeyOutput); } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> WriteKeyInput { <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> key = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">int32</span></span> value = <span class="hljs-number"><span class="hljs-number">2</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> WriteKeyOutput { } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> ReadKeyInput { <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> key = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> ReadKeyOutput { <span class="hljs-attribute"><span class="hljs-attribute">int32</span></span> value = <span class="hljs-number"><span class="hljs-number">1</span></span>; }</code> </pre> <br>  Meskipun klien menggunakan HTTP melalui layanan <code>PublicApi</code> , ia juga tidak mengganggu antarmuka yang jelas yang dijelaskan dengan cara yang sama seperti di atas (file <code>publicapi.proto</code> ): <br><br><pre> <code class="hljs pgsql">syntax = "proto3"; package publicapi; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> "protocol/transactions.proto"; service PublicApi { rpc Transfer (TransferInput) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> (TransferOutput); rpc GetBalance (GetBalanceInput) <span class="hljs-keyword"><span class="hljs-keyword">returns</span></span> (GetBalanceOutput); } message TransferInput { protocol.<span class="hljs-keyword"><span class="hljs-keyword">Transaction</span></span> <span class="hljs-keyword"><span class="hljs-keyword">transaction</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; } message TransferOutput { string success = <span class="hljs-number"><span class="hljs-number">1</span></span>; int32 result = <span class="hljs-number"><span class="hljs-number">2</span></span>; } message GetBalanceInput { protocol.Address <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> = <span class="hljs-number"><span class="hljs-number">1</span></span>; } message GetBalanceOutput { string success = <span class="hljs-number"><span class="hljs-number">1</span></span>; int32 result = <span class="hljs-number"><span class="hljs-number">2</span></span>; }</code> </pre> <br>  Sekarang kita perlu menggambarkan struktur data <code>Transaction</code> dan <code>Address</code> (file <code>transactions.proto</code> ): <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">syntax</span></span> = <span class="hljs-string"><span class="hljs-string">"proto3"</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">package</span></span> protocol; <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> Address { <span class="hljs-attribute"><span class="hljs-attribute">string</span></span> username = <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-attribute"><span class="hljs-attribute">message</span></span> Transaction { <span class="hljs-attribute"><span class="hljs-attribute">Address</span></span> from = <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">Address</span></span> to = <span class="hljs-number"><span class="hljs-number">2</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">int32</span></span> amount = <span class="hljs-number"><span class="hljs-number">3</span></span>; }</code> </pre> <br>  Dalam proyek tersebut, deskripsi proto untuk layanan ditempatkan di folder <code>/types/services</code> , dan deskripsi struktur data tujuan umum ada di folder <code>/types/protocol</code> . <br><br>  Setelah deskripsi antarmuka siap, mereka dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dikompilasi</a> ke dalam kode Go. <br><br>  Kelebihan dari pendekatan ini adalah kode yang tidak cocok dengan deskripsi antarmuka tidak muncul dalam hasil kompilasi.  Menggunakan metode alternatif akan mengharuskan kita untuk menulis tes khusus untuk memverifikasi bahwa kode tersebut cocok dengan deskripsi antarmuka. <br><br>  Definisi lengkap, file Go yang dihasilkan, dan instruksi kompilasi dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Ini dimungkinkan berkat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Square Engineering</a> dan pengembangan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">goprotowrap mereka</a> . <br><br>  Harap dicatat bahwa dalam proyek kami layer transport RPC tidak diimplementasikan dan pertukaran data antara layanan tampak seperti panggilan perpustakaan biasa.  Ketika kami siap untuk mendistribusikan layanan di server yang berbeda, kami dapat menambahkan lapisan transport seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gRPC</a> ke sistem. <br><br><h3>  <font color="#3AC1EF">▍ Jenis tes yang digunakan dalam proyek</font> </h3><br>  Karena tes adalah kunci untuk kode yang sangat andal, saya menyarankan agar kita pertama-tama berbicara tentang tes mana yang akan kita tulis untuk proyek kita. <br><br><h4>  Tes unit </h4><br>  Tes unit adalah inti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari piramida pengujian</a> .  Kami akan menguji setiap modul secara terpisah.  Apa itu modul?  Di Go, kita dapat melihat modul sebagai file terpisah dalam sebuah paket.  Sebagai contoh, jika kita memiliki file <code>/services/publicapi/handlers.go</code> , maka kita akan menempatkan tes unit untuk itu dalam paket yang sama di <code>/services/publicapi/handlers_test.go</code> . <br><br>  Cara terbaik adalah menempatkan tes unit dalam paket yang sama dengan kode tes, yang memungkinkan tes memiliki akses ke variabel dan fungsi yang tidak diekspor. <br><br><h4>  Tes Layanan </h4><br>  Jenis tes berikut dikenal dengan berbagai nama.  Ini adalah layanan yang disebut, tes integrasi atau komponen.  Esensi mereka adalah mengambil beberapa modul dan menguji kerja bersama mereka.  Tes-tes ini satu tingkat lebih tinggi dari tes unit dalam piramida tes.  Dalam kasus kami, kami akan menggunakan tes integrasi untuk menguji seluruh layanan.  Tes-tes ini menentukan spesifikasi untuk layanan.  Misalnya, tes untuk layanan <code>StateStorage</code> akan ditempatkan di folder <code>/services/statestorage/spec</code> . <br><br>  Cara terbaik untuk menempatkan tes ini dalam paket yang berbeda dari yang di mana kode yang diuji terletak sehingga akses ke kemampuan kode ini dilakukan hanya melalui antarmuka yang diekspor. <br><br><h4>  Tes ujung ke ujung </h4><br>  Tes-tes ini berada di puncak piramida pengujian, dengan bantuan mereka memeriksa keseluruhan sistem dan semua layanannya dilakukan.  Tes tersebut menggambarkan spesifikasi end-to-end, e2e untuk sistem, jadi kami akan menempatkannya di folder <code>/e2e/spec</code> . <br><br>  Tes ujung ke ujung, serta tes layanan, harus ditempatkan dalam paket yang berbeda dari yang di mana kode yang diuji terletak sehingga sistem hanya dapat dioperasikan melalui antarmuka yang diekspor. <br><br>  Tes apa yang harus ditulis terlebih dahulu?  Mulailah dengan dasar "piramida" dan naik?  Atau mulai dari atas dan turun?  Salah satu dari pendekatan ini memiliki hak untuk hidup.  Manfaat dari pendekatan top-down adalah menciptakan spesifikasi terlebih dahulu untuk seluruh sistem.  Biasanya paling mudah untuk membahas di awal pekerjaan tentang fitur-fitur sistem secara keseluruhan.  Bahkan jika kita membagi sistem ke dalam layanan terpisah secara tidak benar, spesifikasi sistem akan tetap tidak berubah.  Ini, sebagai tambahan, akan membantu kita memahami bahwa sesuatu, pada level yang lebih rendah, dilakukan secara tidak benar. <br><br>  Kelemahan dari pendekatan top-down adalah bahwa tes end-to-end adalah tes yang digunakan setelah semua yang lain, ketika seluruh sistem yang dikembangkan dibuat.  Ini berarti bahwa mereka akan menghasilkan kesalahan untuk waktu yang lama.  Saat menulis tes untuk proyek kami, kami akan menggunakan pendekatan ini. <br><br><h3>  <font color="#3AC1EF">DevelopmentTes pengembangan</font> </h3><br><h4>  Pengembangan tes ujung ke ujung </h4><br>  Sebelum membuat tes, kita perlu memutuskan apakah kita akan menulisnya tanpa menggunakan alat bantu apa pun atau menggunakan semacam kerangka kerja.  Mengandalkan kerangka kerja, menggunakannya sebagai ketergantungan pengembangan, kurang berbahaya daripada mengandalkan kerangka kerja dalam kode yang masuk ke produksi.  Dalam kasus kami, karena perpustakaan Go standar tidak memiliki dukungan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">BDD yang</a> layak, dan format ini sangat bagus untuk menggambarkan spesifikasi, kami akan memilih opsi kerja yang mencakup penggunaan kerangka kerja. <br><br>  Ada banyak kerangka kerja hebat yang memberikan apa yang kita butuhkan.  Di antara mereka adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GoConvey</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ginkgo</a> . <br><br>  Secara pribadi, saya suka menggunakan kombinasi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ginkgo</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gomega</a> (nama-nama yang mengerikan, tetapi apa yang harus dilakukan) yang menggunakan konstruksi sintaksis seperti <code>Describe()</code> dan <code>It()</code> . <br><br>  Seperti apa pengujian kami?  Misalnya, berikut ini adalah tes untuk mekanisme pemeriksaan saldo pengguna (file <code>sanity.go</code> ): <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> spec <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _ = Describe(<span class="hljs-string"><span class="hljs-string">"Sanity"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( node services.Node ) BeforeEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { node = services.NewNode() node.Start() }) AfterEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { node.Stop() }) It(<span class="hljs-string"><span class="hljs-string">"should show balances with GET /api/balance"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { resp, err := http.Get(<span class="hljs-string"><span class="hljs-string">"http://localhost:8080/api/balance?from=user1"</span></span>) Expect(err).ToNot(HaveOccurred()) Expect(resp.StatusCode).To(Equal(http.StatusOK)) Expect(ResponseBodyAsString(resp)).To(Equal(<span class="hljs-string"><span class="hljs-string">"0"</span></span>)) }) })</code> </pre> <br>  Karena server dapat diakses dari dunia luar melalui HTTP, kami akan bekerja dengan API webnya menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://golang.org/pkg/net/">http.Get</a> .  Bagaimana dengan pengujian transaksional?  Berikut adalah kode untuk tes yang sesuai: <br><br><pre> <code class="hljs lisp">It(<span class="hljs-string"><span class="hljs-string">"should transfer funds with POST /api/transfer"</span></span>, func() { resp, err <span class="hljs-symbol"><span class="hljs-symbol">:=</span></span> http.Get(<span class="hljs-string"><span class="hljs-string">"http://localhost:8080/api/transfer?from=user1&amp;to=user2&amp;amount=17"</span></span>) Expect(<span class="hljs-name"><span class="hljs-name">err</span></span>).ToNot(<span class="hljs-name"><span class="hljs-name">HaveOccurred</span></span>()) Expect(<span class="hljs-name"><span class="hljs-name">resp</span></span>.StatusCode).To(<span class="hljs-name"><span class="hljs-name">Equal</span></span>(<span class="hljs-name"><span class="hljs-name">http</span></span>.StatusOK)) Expect(<span class="hljs-name"><span class="hljs-name">ResponseBodyAsString</span></span>(<span class="hljs-name"><span class="hljs-name">resp</span></span>)).To(<span class="hljs-name"><span class="hljs-name">Equal</span></span>(<span class="hljs-string"><span class="hljs-string">"-17"</span></span>)) resp, err = http.Post(<span class="hljs-string"><span class="hljs-string">"http://localhost:8080/api/balance?from=user2"</span></span>, <span class="hljs-string"><span class="hljs-string">"text/plain"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>) Expect(<span class="hljs-name"><span class="hljs-name">err</span></span>).ToNot(<span class="hljs-name"><span class="hljs-name">HaveOccurred</span></span>()) Expect(<span class="hljs-name"><span class="hljs-name">resp</span></span>.StatusCode).To(<span class="hljs-name"><span class="hljs-name">Equal</span></span>(<span class="hljs-name"><span class="hljs-name">http</span></span>.StatusOK)) Expect(<span class="hljs-name"><span class="hljs-name">ResponseBodyAsString</span></span>(<span class="hljs-name"><span class="hljs-name">resp</span></span>)).To(<span class="hljs-name"><span class="hljs-name">Equal</span></span>(<span class="hljs-string"><span class="hljs-string">"17"</span></span>)) })</code> </pre><br>  Kode tes dengan sempurna menggambarkan esensi mereka, bahkan dapat menggantikan dokumentasi.  Seperti yang Anda lihat, kami mengakui adanya saldo akun pengguna negatif.  Ini adalah fitur dari proyek kami.  Jika dilarang, keputusan ini akan tercermin dalam tes. <br><br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ini adalah</a> kode tes lengkap <br><br><h4>  Pengembangan Tes Layanan </h4><br>  Sekarang, setelah mengembangkan tes end-to-end, kami pergi ke piramida pengujian dan melanjutkan untuk membuat tes layanan.  Tes semacam itu dikembangkan untuk setiap layanan individual.  Kami memilih layanan yang memiliki ketergantungan pada layanan lain, karena kasus ini lebih menarik daripada mengembangkan tes untuk layanan independen. <br><br>  Mari kita mulai dengan layanan <code>VirtualMachine</code> .  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sini</a> Anda dapat menemukan antarmuka dengan proto-deskripsi untuk layanan ini.  Karena layanan <code>VirtualMachine</code> bergantung pada layanan <code>StateStorage</code> dan mengaksesnya, kita perlu membuat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">objek tiruan</a> untuk layanan <code>StateStorage</code> untuk menguji layanan <code>VirtualMachine</code> secara terpisah.  Objek rintisan memungkinkan kita untuk mengontrol respons <code>StateStorage</code> selama pengujian. <br><br>  Bagaimana cara mengimplementasikan objek rintisan di Go?  Ini dapat dilakukan secara eksklusif melalui bahasa, tanpa alat bantu, atau Anda dapat menggunakan perpustakaan yang sesuai, yang, di samping itu, akan memungkinkan untuk bekerja dengan pernyataan dalam proses pengujian.  Untuk tujuan ini, saya lebih suka menggunakan perpustakaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">go-mock</a> . <br><br>  Kami akan menempatkan kode rintisan di file <code>/services/statestorage/mock.go</code> .  Cara terbaik adalah menempatkan objek rintisan di tempat yang sama dengan entitas yang ditirunya untuk memberi mereka akses ke variabel dan fungsi yang tidak diekspor.  Rintisan pada tahap ini adalah implementasi skematis dari layanan, tetapi, ketika layanan berkembang, kita mungkin perlu mengembangkan implementasi rintisan.  Berikut adalah kode untuk objek stub (file <code>mock.go</code> ): <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> statestorage <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> MockService <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { mock.Mock } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *MockService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { s.Called() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *MockService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Stop</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { s.Called() } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *MockService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">IsStarted</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.Called().Bool(<span class="hljs-number"><span class="hljs-number">0</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *MockService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">WriteKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(input *statestorage.WriteKeyInput)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*statestorage.WriteKeyOutput, error)</span></span></span></span> { ret := s.Called(input) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret.Get(<span class="hljs-number"><span class="hljs-number">0</span></span>).(*statestorage.WriteKeyOutput), ret.Error(<span class="hljs-number"><span class="hljs-number">1</span></span>) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *MockService)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ReadKey</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(input *statestorage.ReadKeyInput)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*statestorage.ReadKeyOutput, error)</span></span></span></span> { ret := s.Called(input) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret.Get(<span class="hljs-number"><span class="hljs-number">0</span></span>).(*statestorage.ReadKeyOutput), ret.Error(<span class="hljs-number"><span class="hljs-number">1</span></span>) }</code> </pre> <br>  Jika Anda memberikan pengembangan layanan individual ke pemrogram yang berbeda, masuk akal untuk membuat rintisan terlebih dahulu dan meneruskannya ke tim. <br><br>  Mari kita kembali mengembangkan tes layanan untuk <code>VirtualMachine</code> .  Skenario apa yang harus saya periksa di sini?  Yang terbaik adalah fokus pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">antarmuka</a> layanan dan tes desain untuk setiap titik akhir.  Kami menerapkan tes untuk titik akhir <code>CallContract()</code> dengan argumen yang mewakili metode <code>"GetBalance"</code> .  Berikut adalah kode yang sesuai (file <code>contracts.go</code> ): <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> spec <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ... <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> _ = Describe(<span class="hljs-string"><span class="hljs-string">"Contracts"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ( service uut.Service stateStorage *_statestorage.MockService ) BeforeEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { service = uut.NewService() stateStorage = &amp;_statestorage.MockService{} service.Start(stateStorage) }) AfterEach(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { service.Stop() }) It(<span class="hljs-string"><span class="hljs-string">"should support 'GetBalance' contract method"</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { stateStorage.When(<span class="hljs-string"><span class="hljs-string">"ReadKey"</span></span>, &amp;statestorage.ReadKeyInput{Key: <span class="hljs-string"><span class="hljs-string">"user1"</span></span>}).Return(&amp;statestorage.ReadKeyOutput{Value: <span class="hljs-number"><span class="hljs-number">100</span></span>}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>).Times(<span class="hljs-number"><span class="hljs-number">1</span></span>) addr := protocol.Address{Username: <span class="hljs-string"><span class="hljs-string">"user1"</span></span>} out, err := service.CallContract(&amp;virtualmachine.CallContractInput{Method: <span class="hljs-string"><span class="hljs-string">"GetBalance"</span></span>, Arg: &amp;addr}) Expect(err).ToNot(HaveOccurred()) Expect(out.Result).To(BeEquivalentTo(<span class="hljs-number"><span class="hljs-number">100</span></span>)) Expect(stateStorage).To(ExecuteAsPlanned()) }) })</code> </pre><br>  Harap perhatikan bahwa layanan yang kami uji, <code>VirtualMachine</code> , mendapat petunjuk untuk ketergantungannya, <code>StateStorage</code> , dalam metode <code>Start()</code> melalui mekanisme injeksi ketergantungan sederhana.  Di sinilah kita melewatkan turunan objek stub.  Juga, perhatikan status <code>stateStorage.When("ReadKey", &amp;statestorage.ReadKeyInput{Key…</code> , di mana kita memberi tahu objek stub bagaimana seharusnya berperilaku ketika mengaksesnya. Ketika metode <code>ReadKey</code> , itu harus mengembalikan nilai 100. Kemudian, di baris <code>Expect(stateStorage).To(ExecuteAsPlanned())</code> , kami memeriksa bahwa perintah ini dipanggil tepat sekali. <br><br>  Tes serupa menjadi spesifikasi untuk layanan ini.  Set lengkap pengujian untuk layanan <code>VirtualMachine</code> dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> .  Suite tes untuk layanan lain dari proyek kami dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . <br><br><h4>  Pengembangan Tes Unit </h4><br>  Mungkin implementasi kontrak untuk metode <code>"GetBalance"</code> terlalu sederhana, jadi <code>"GetBalance"</code> bicara tentang menerapkan metode <code>"Transfer"</code> sedikit lebih kompleks.  Kontrak untuk mentransfer dana dari satu akun ke akun lain yang diwakili oleh metode ini perlu membaca data tentang saldo pengirim dan penerima dana, untuk menghitung saldo baru dan untuk mencatat apa yang terjadi dalam keadaan aplikasi.  Tes layanan untuk semua ini sangat mirip dengan yang baru saja kami terapkan (file <code>transactions.go</code> ): <br><br><pre> <code class="hljs lisp">It(<span class="hljs-string"><span class="hljs-string">"should support 'Transfer' transaction method"</span></span>, func() { stateStorage.When(<span class="hljs-string"><span class="hljs-string">"ReadKey"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">&amp;statestorage</span></span>.ReadKeyInput{Key: <span class="hljs-string"><span class="hljs-string">"user1"</span></span>}).Return(<span class="hljs-name"><span class="hljs-name">&amp;statestorage</span></span>.ReadKeyOutput{Value: <span class="hljs-number"><span class="hljs-number">100</span></span>}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>).Times(<span class="hljs-number"><span class="hljs-number">1</span></span>) stateStorage.When(<span class="hljs-string"><span class="hljs-string">"ReadKey"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">&amp;statestorage</span></span>.ReadKeyInput{Key: <span class="hljs-string"><span class="hljs-string">"user2"</span></span>}).Return(<span class="hljs-name"><span class="hljs-name">&amp;statestorage</span></span>.ReadKeyOutput{Value: <span class="hljs-number"><span class="hljs-number">50</span></span>}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>).Times(<span class="hljs-number"><span class="hljs-number">1</span></span>) stateStorage.When(<span class="hljs-string"><span class="hljs-string">"WriteKey"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">&amp;statestorage</span></span>.WriteKeyInput{Key: <span class="hljs-string"><span class="hljs-string">"user1"</span></span>, Value: <span class="hljs-number"><span class="hljs-number">90</span></span>}).Return(<span class="hljs-name"><span class="hljs-name">&amp;statestorage</span></span>.WriteKeyOutput{}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>).Times(<span class="hljs-number"><span class="hljs-number">1</span></span>) stateStorage.When(<span class="hljs-string"><span class="hljs-string">"WriteKey"</span></span>, <span class="hljs-symbol"><span class="hljs-symbol">&amp;statestorage</span></span>.WriteKeyInput{Key: <span class="hljs-string"><span class="hljs-string">"user2"</span></span>, Value: <span class="hljs-number"><span class="hljs-number">60</span></span>}).Return(<span class="hljs-name"><span class="hljs-name">&amp;statestorage</span></span>.WriteKeyOutput{}, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>).Times(<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-literal"><span class="hljs-literal">t</span></span> <span class="hljs-symbol"><span class="hljs-symbol">:=</span></span> protocol.Transaction{From: <span class="hljs-symbol"><span class="hljs-symbol">&amp;protocol</span></span>.Address{Username: <span class="hljs-string"><span class="hljs-string">"user1"</span></span>}, To: <span class="hljs-symbol"><span class="hljs-symbol">&amp;protocol</span></span>.Address{Username: <span class="hljs-string"><span class="hljs-string">"user2"</span></span>}, Amount: <span class="hljs-number"><span class="hljs-number">10</span></span>} out, err <span class="hljs-symbol"><span class="hljs-symbol">:=</span></span> service.ProcessTransaction(<span class="hljs-name"><span class="hljs-name">&amp;virtualmachine</span></span>.ProcessTransactionInput{Method: <span class="hljs-string"><span class="hljs-string">"Transfer"</span></span>, Arg: <span class="hljs-symbol"><span class="hljs-symbol">&amp;t</span></span>}) Expect(<span class="hljs-name"><span class="hljs-name">err</span></span>).ToNot(<span class="hljs-name"><span class="hljs-name">HaveOccurred</span></span>()) Expect(<span class="hljs-name"><span class="hljs-name">out</span></span>.Result).To(<span class="hljs-name"><span class="hljs-name">BeEquivalentTo</span></span>(<span class="hljs-number"><span class="hljs-number">90</span></span>)) Expect(<span class="hljs-name"><span class="hljs-name">stateStorage</span></span>).To(<span class="hljs-name"><span class="hljs-name">ExecuteAsPlanned</span></span>()) })</code> </pre> <br>  Dalam proses mengerjakan proyek, kami akhirnya bisa membuat mekanisme internal dan membuat modul yang terletak di file <code>processor.go</code> , yang berisi implementasi kontrak.  Ini adalah versi aslinya (file <code>processor.go</code> ): <br><br><pre> <code class="hljs go"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> virtualmachine <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *service)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">processTransfer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(fromUsername </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, toUsername </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, amount </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int32</span></span></span></span><span class="hljs-function"><span class="hljs-params">, error)</span></span></span></span> { fromBalance, err := s.stateStorage.ReadKey(&amp;statestorage.ReadKeyInput{Key: fromUsername}) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, err } toBalance, err := s.stateStorage.ReadKey(&amp;statestorage.ReadKeyInput{Key: toUsername}) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, err } _, err = s.stateStorage.WriteKey(&amp;statestorage.WriteKeyInput{Key: fromUsername, Value: fromBalance.Value - amount}) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, err } _, err = s.stateStorage.WriteKey(&amp;statestorage.WriteKeyInput{Key: toUsername, Value: toBalance.Value + amount}) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>, err } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fromBalance.Value - amount, <span class="hljs-literal"><span class="hljs-literal">nil</span></span> }</code> </pre><br>  Desain ini memenuhi uji layanan, tetapi dalam kasus kami, uji integrasi hanya berisi tes skenario dasar.  Bagaimana dengan kasus batas dan potensi kegagalan?  Seperti yang Anda lihat, semua panggilan yang kami lakukan untuk <code>StateStorage</code> mungkin gagal.  Jika cakupan 100% dari kode dengan tes diperlukan, kita perlu memeriksa semua situasi ini.  Tes unit sangat bagus untuk menerapkan tes semacam itu. <br><br>  Karena kita akan memanggil fungsi beberapa kali dengan data input yang berbeda dan mensimulasikan parameter untuk mencapai semua cabang kode, untuk membuat proses ini lebih efisien, kita dapat menggunakan tes berbasis tabel.  Go cenderung menghindari kerangka uji unit eksotis.  Kita bisa menolak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ginkgo</a> , tetapi mungkin kita harus meninggalkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gomega</a> .  Akibatnya, pemeriksaan yang dilakukan di sini akan sama dengan yang kami lakukan di tes sebelumnya.  Berikut adalah kode tes (file <code>processor_test.go</code> ): <br><br><pre> <code class="hljs lua"><span class="hljs-built_in"><span class="hljs-built_in">package</span></span> virtualmachine import ... var transferTable = []struct{ to <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> //  ,    read1Err <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> //       read2Err <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> //       write1Err <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> //       write2Err <span class="hljs-built_in"><span class="hljs-built_in">error</span></span> //       <span class="hljs-built_in"><span class="hljs-built_in">output</span></span> int32 //   errs bool //        }{ {<span class="hljs-string"><span class="hljs-string">"user2"</span></span>, errors.New(<span class="hljs-string"><span class="hljs-string">"a"</span></span>), <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>}, {<span class="hljs-string"><span class="hljs-string">"user2"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.New(<span class="hljs-string"><span class="hljs-string">"a"</span></span>), <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>}, {<span class="hljs-string"><span class="hljs-string">"user2"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.New(<span class="hljs-string"><span class="hljs-string">"a"</span></span>), <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>}, {<span class="hljs-string"><span class="hljs-string">"user2"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, errors.New(<span class="hljs-string"><span class="hljs-string">"a"</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>}, {<span class="hljs-string"><span class="hljs-string">"user2"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, <span class="hljs-number"><span class="hljs-number">90</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>}, } func TestTransfer(t *testing.T) { Ω := NewGomegaWithT(t) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, tt := range transferTable { s := NewService() ss := &amp;_statestorage.MockService{} s.Start(ss) ss.When(<span class="hljs-string"><span class="hljs-string">"ReadKey"</span></span>, &amp;statestorage.ReadKeyInput{Key: <span class="hljs-string"><span class="hljs-string">"user1"</span></span>}).Return(&amp;statestorage.ReadKeyOutput{Value: <span class="hljs-number"><span class="hljs-number">100</span></span>}, tt.read1Err) ss.When(<span class="hljs-string"><span class="hljs-string">"ReadKey"</span></span>, &amp;statestorage.ReadKeyInput{Key: <span class="hljs-string"><span class="hljs-string">"user2"</span></span>}).Return(&amp;statestorage.ReadKeyOutput{Value: <span class="hljs-number"><span class="hljs-number">50</span></span>}, tt.read2Err) ss.When(<span class="hljs-string"><span class="hljs-string">"WriteKey"</span></span>, &amp;statestorage.WriteKeyInput{Key: <span class="hljs-string"><span class="hljs-string">"user1"</span></span>, Value: <span class="hljs-number"><span class="hljs-number">90</span></span>}).Return(&amp;statestorage.WriteKeyOutput{}, tt.write1Err) ss.When(<span class="hljs-string"><span class="hljs-string">"WriteKey"</span></span>, &amp;statestorage.WriteKeyInput{Key: <span class="hljs-string"><span class="hljs-string">"user2"</span></span>, Value: <span class="hljs-number"><span class="hljs-number">60</span></span>}).Return(&amp;statestorage.WriteKeyOutput{}, tt.write2Err) <span class="hljs-built_in"><span class="hljs-built_in">output</span></span>, err := s.(*service).processTransfer(<span class="hljs-string"><span class="hljs-string">"user1"</span></span>, tt.to, <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> tt.errs { Ω.Expect(err).To(HaveOccurred()) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { Ω.Expect(err).ToNot(HaveOccurred()) Ω.Expect(<span class="hljs-built_in"><span class="hljs-built_in">output</span></span>).To(BeEquivalentTo(tt.<span class="hljs-built_in"><span class="hljs-built_in">output</span></span>)) } } }</code> </pre> <br>     «Ω» —  ,    —    (     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Gomega</a> ).          . <br><br>        ,        TDD,          ,     ,     .       <code>processTransfer()</code>         . <br><br>       <code>VirtualMachine</code>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> . <br><br>    100%   .    ,    .             . <br><br>   ,        ?   .        , ,    ,     . <br><br><h3> <font color="#3AC1EF">▍  -</font> </h3><br>              .         ?  HTTP-  Go     (goroutine).     ,  —        ,     . ,      ,  ,   . <br><br>           -               . ,   ,   ,          ,        .  -     <code>/e2e/stress</code> .   - ( <code>stress.go</code> ): <br><br><pre> <code class="hljs perl"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> stress import ... const NUM_TRANSACTIONS = <span class="hljs-number"><span class="hljs-number">20000</span></span> const NUM_USERS = <span class="hljs-number"><span class="hljs-number">100</span></span> const TRANSACTIONS_PER_BATCH = <span class="hljs-number"><span class="hljs-number">200</span></span> const BATCHES_PER_SEC = <span class="hljs-number"><span class="hljs-number">40</span></span> var <span class="hljs-number"><span class="hljs-number">_</span></span> = Describe(<span class="hljs-string"><span class="hljs-string">"Transaction Stress Test"</span></span>, func() { var ( node services.Node ) BeforeEach(func() { node = services.NewNode() node.Start() }) AfterEach(func() { node.Stop() }) It(<span class="hljs-string"><span class="hljs-string">"should handle lots and lots of transactions"</span></span>, func() { <span class="hljs-regexp"><span class="hljs-regexp">//</span></span>  HTTP-     transport := http.Transport{ IdleConnTimeout: time.Second*<span class="hljs-number"><span class="hljs-number">20</span></span>, MaxIdleConns: TRANSACTIONS_PER_BATCH*<span class="hljs-number"><span class="hljs-number">10</span></span>, MaxIdleConnsPerHost: TRANSACTIONS_PER_BATCH*<span class="hljs-number"><span class="hljs-number">10</span></span>, } client := &amp;http.Client{Transport: &amp;transport} //      ledger := <span class="hljs-keyword"><span class="hljs-keyword">map</span></span>[string]int32{} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; NUM_USERS; i++ { ledger[fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"user%d"</span></span>, i+<span class="hljs-number"><span class="hljs-number">1</span></span>)] = <span class="hljs-number"><span class="hljs-number">0</span></span> } //     HTTP   rand.Seed(<span class="hljs-number"><span class="hljs-number">42</span></span>) done := make(chan error, TRANSACTIONS_PER_BATCH) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; NUM_TRANSACTIONS / TRANSACTIONS_PER_BATCH; i++ { log.Printf(<span class="hljs-string"><span class="hljs-string">"Sending %d transactions... (batch %d out of %d)"</span></span>, TRANSACTIONS_PER_BATCH, i+<span class="hljs-number"><span class="hljs-number">1</span></span>, NUM_TRANSACTIONS / TRANSACTIONS_PER_BATCH) time.Sleep(time.Second / BATCHES_PER_SEC) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j := <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; TRANSACTIONS_PER_BATCH; j++ { from := randomizeUser() to := randomizeUser() amount := randomizeAmount() ledger[from] -= amount ledger[to] += amount go sendTransaction(client, from, to, amount, &amp;done) } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j := <span class="hljs-number"><span class="hljs-number">0</span></span>; j &lt; TRANSACTIONS_PER_BATCH; j++ { err := &lt;- done Expect(err).ToNot(HaveOccurred()) } } //   <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; NUM_USERS; i++ { user := fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"user%d"</span></span>, i+<span class="hljs-number"><span class="hljs-number">1</span></span>) resp, err := client.Get(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"http://localhost:8080/api/balance?from=%s"</span></span>, user)) Expect(err).ToNot(HaveOccurred()) Expect(resp.StatusCode).To(Equal(http.StatusOK)) Expect(ResponseBodyAsString(resp)).To(Equal(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"%d"</span></span>, ledger[user]))) } }) }) func randomizeUser() string { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"user%d"</span></span>, rand.Intn(NUM_USERS)+<span class="hljs-number"><span class="hljs-number">1</span></span>) } func randomizeAmount() int32 { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rand.Int31n(<span class="hljs-number"><span class="hljs-number">1000</span></span>)+<span class="hljs-number"><span class="hljs-number">1</span></span> } func sendTransaction(client *http.Client, from string, to string, amount int32, done *chan error) { url := fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"http://localhost:8080/api/transfer?from=%s&amp;to=%s&amp;amount=%d"</span></span>, from, to, amount) resp, err := client.Post(url, <span class="hljs-string"><span class="hljs-string">"text/plain"</span></span>, nil) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err == nil { ioutil.ReadAll(resp.Body) resp.Body.Close() } *done &lt;- err }</code> </pre> <br>    ,  -   .           (       <code>rand.Seed(42)</code> )  ,    .         .     ,            ,  — ,     . <br><br>    -  HTTP   ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>          TCP- (     ,     ,           ).  ,  ,              200     <code>IdleConnection</code>    TCP-   .       ,      100. <br><br>  …   : <br><br><pre> <code class="hljs go">fatal error: concurrent <span class="hljs-keyword"><span class="hljs-keyword">map</span></span> writes goroutine <span class="hljs-number"><span class="hljs-number">539</span></span> [running]: runtime.throw(<span class="hljs-number"><span class="hljs-number">0x147bf</span></span>60, <span class="hljs-number"><span class="hljs-number">0x15</span></span>) /usr/local/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>/src/runtime/<span class="hljs-built_in"><span class="hljs-built_in">panic</span></span>.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">616</span></span> +<span class="hljs-number"><span class="hljs-number">0x81</span></span> fp=<span class="hljs-number"><span class="hljs-number">0xc4207159d</span></span>8 sp=<span class="hljs-number"><span class="hljs-number">0xc4207159b8</span></span> pc=<span class="hljs-number"><span class="hljs-number">0x102ca01</span></span> runtime.mapassign_faststr(<span class="hljs-number"><span class="hljs-number">0x13f</span></span>5140, <span class="hljs-number"><span class="hljs-number">0xc4201ca0c0</span></span>, <span class="hljs-number"><span class="hljs-number">0xc4203a8097</span></span>, <span class="hljs-number"><span class="hljs-number">0x6</span></span>, <span class="hljs-number"><span class="hljs-number">0x1012001</span></span>) /usr/local/<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>/src/runtime/hashmap_fast.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">703</span></span> +<span class="hljs-number"><span class="hljs-number">0x3e9</span></span> fp=<span class="hljs-number"><span class="hljs-number">0xc420715a48</span></span> sp=<span class="hljs-number"><span class="hljs-number">0xc4207159d</span></span>8 pc=<span class="hljs-number"><span class="hljs-number">0x100d</span></span>879 services/statestorage.(*service).WriteKey(<span class="hljs-number"><span class="hljs-number">0xc42000c060</span></span>, <span class="hljs-number"><span class="hljs-number">0xc4209e6800</span></span>, <span class="hljs-number"><span class="hljs-number">0xc4206491a0</span></span>, <span class="hljs-number"><span class="hljs-number">0x0</span></span>, <span class="hljs-number"><span class="hljs-number">0x0</span></span>) services/statestorage/methods.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">15</span></span> +<span class="hljs-number"><span class="hljs-number">0x10c</span></span> fp=<span class="hljs-number"><span class="hljs-number">0xc420715a88</span></span> sp=<span class="hljs-number"><span class="hljs-number">0xc420715a48</span></span> pc=<span class="hljs-number"><span class="hljs-number">0x138339c</span></span> services/virtualmachine.(*service).processTransfer(<span class="hljs-number"><span class="hljs-number">0xc4201ca090</span></span>, <span class="hljs-number"><span class="hljs-number">0xc4203a8097</span></span>, <span class="hljs-number"><span class="hljs-number">0x6</span></span>, <span class="hljs-number"><span class="hljs-number">0xc4203a80a1</span></span>, <span class="hljs-number"><span class="hljs-number">0x6</span></span>, <span class="hljs-number"><span class="hljs-number">0x2a4</span></span>, <span class="hljs-number"><span class="hljs-number">0xc420715b30</span></span>, <span class="hljs-number"><span class="hljs-number">0x1012928</span></span>, <span class="hljs-number"><span class="hljs-number">0x40</span></span>) services/virtualmachine/processor.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">19</span></span> +<span class="hljs-number"><span class="hljs-number">0x16e</span></span> fp=<span class="hljs-number"><span class="hljs-number">0xc420715ad</span></span>0 sp=<span class="hljs-number"><span class="hljs-number">0xc420715a88</span></span> pc=<span class="hljs-number"><span class="hljs-number">0x13840ee</span></span> services/virtualmachine.(*service).ProcessTransaction(<span class="hljs-number"><span class="hljs-number">0xc4201ca090</span></span>, <span class="hljs-number"><span class="hljs-number">0xc4209e67c0</span></span>, <span class="hljs-number"><span class="hljs-number">0x30</span></span>, <span class="hljs-number"><span class="hljs-number">0x1433660</span></span>, <span class="hljs-number"><span class="hljs-number">0x12a1d</span></span>01) Ginkgo ran <span class="hljs-number"><span class="hljs-number">1</span></span> suite in <span class="hljs-number"><span class="hljs-number">1.288879763s</span></span> Test Suite Failed</code> </pre> <br>  ?   <code>StateStorage</code>       ( <code>map</code> ),   . ,     ,            .     ,           <code>map</code>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sync.map</a> .     . <br><br>     <a href="">processTransfer()</a> .         ,   —      .         , ,         ,        ,     .     ,          <code>processTransfer()</code> . <a href=""></a>  . <br><br>    ,   . ,    ,     . <br><br><pre> <code class="hljs go">e2e/stress/transactions.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">44</span></span> Expected &lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;: <span class="hljs-number"><span class="hljs-number">-7498</span></span> to equal &lt;<span class="hljs-keyword"><span class="hljs-keyword">string</span></span>&gt;: <span class="hljs-number"><span class="hljs-number">-7551</span></span> e2e/stress/transactions.<span class="hljs-keyword"><span class="hljs-keyword">go</span></span>:<span class="hljs-number"><span class="hljs-number">82</span></span> ------------------------------ Ginkgo ran <span class="hljs-number"><span class="hljs-number">1</span></span> suite in <span class="hljs-number"><span class="hljs-number">5.251593179s</span></span> Test Suite Failed</code> </pre> <br>       ,    . ,   ,          ( ,           ).    ,   <a href=""></a> ,    . <br><br>  —  .    TDD         .   ?           ,       100%?!   ,    —      .    <code>processTransfer()</code>      ,       ,    . <br><br>             .  ,       <a href=""></a>   ,   . <a href=""></a>    . <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br> , ,  ,     -,      ,      ,  ?     ?   — . <br><br>       ,     -.  ,  «»  <code>processTransfer()</code>      .  ,  ,    <a href=""></a> .         ,   — .    ,      -       .     ,        ,        . <br><br>     . ,         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a> .  ,     <code>StateStorage</code>   <code>WriteKey</code> ,     , , ,     <code>WriteKeys</code>    ,         ,       . <br><br>   ,        :          .            « ».       -,        ,  ,     ,    ,      .   —     .     ,   ,    —      . <br><br>       ,       —   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>  GitHub.          .  ,   ,    , , ,     ,      . <br><br>  <b>Pembaca yang budiman!</b>        ? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id413681/">https://habr.com/ru/post/id413681/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id413669/index.html">Samsung IT School: mengajar siswa bagaimana mengembangkan aplikasi mobile</a></li>
<li><a href="../id413673/index.html">Pada masalah kinerja versi lama dan baru dari sebuah node</a></li>
<li><a href="../id413675/index.html">Joker 2018: Klub Pengembang Java Anonim</a></li>
<li><a href="../id413677/index.html">Peluncuran ROS pada robot self-balancing EduMIP</a></li>
<li><a href="../id413679/index.html">Angular6. PWA. Modul pemuatan malas. Penyebaran otomatis di Firebase</a></li>
<li><a href="../id413683/index.html">ILV telah membuka blokir 7 juta alamat IP. Tetap terkunci 4 juta</a></li>
<li><a href="../id413689/index.html">Debian + Postfix + Dovecot + Multidomain + SSL + IPv6 + OpenVPN + Multi-interface + SpamAssassin-learn + Bind</a></li>
<li><a href="../id413691/index.html">Mulai</a></li>
<li><a href="../id413693/index.html">Handmade: Keyboard yang dapat diprogram untuk perdagangan online do-it-yourself</a></li>
<li><a href="../id413695/index.html">Keamanan Messenger: mengapa menyimpan pesan di blockchain mungkin merupakan ide yang bagus</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>