<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💭 🔥 👩🏽‍✈️ Die ganze Wahrheit über RTOS. Artikel Nr. 17. Ereignisflag-Gruppen: Einführung und Basisdienste 👩🏻‍⚖️ ♏️ 👏🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Gruppen von Ereignisflags wurden bereits in einem der vorherigen Artikel (Nr. 5) erwähnt. In Nucleus SE ähneln sie Signalen, sind jedoch flexibler. Si...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ganze Wahrheit über RTOS. Artikel Nr. 17. Ereignisflag-Gruppen: Einführung und Basisdienste</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428131/"><img src="https://habrastorage.org/webt/y6/hx/yw/y6hxyww0r_cp5m_lr0uspctzgqk.jpeg"><br><br>  Gruppen von Ereignisflags wurden bereits in einem der vorherigen Artikel (Nr. 5) erwähnt.  In Nucleus SE ähneln sie Signalen, sind jedoch flexibler.  Sie bieten eine kostengünstige und flexible Möglichkeit, einfache Nachrichten zwischen Aufgaben zu übertragen. <br><a name="habracut"></a><br><br>  Frühere Artikel in der Reihe: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Signale</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherpartitionen: Dienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherbereiche: Einführung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabendatenstrukturen und nicht unterstützte API-Aufrufe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstleistungen für die Arbeit mit Aufgaben</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben: Konfiguration und Einführung in die API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Erweiterte Funktionen und Kontexterhaltung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Implementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Internes Design und Bereitstellung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Einführung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andere RTOS-Dienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabeninteraktion und Synchronisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben, Kontextwechsel und Interrupts</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben und Planung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Struktur und Echtzeitmodus</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Einführung.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a> <br><br><h2>  Ereignisflags verwenden </h2><br>  In Nucleus SE werden Ereignisflags während der Erstellungsphase definiert.  Die maximale Anzahl von Ereignisflaggruppen in der Anwendung beträgt 16. Wenn keine Ereignisflaggruppen definiert sind, wird der Code, der sich auf die Datenstrukturen und Serviceaufrufe der Ereignisflaggruppen bezieht, nicht in die Anwendung aufgenommen. <br><br>  Gruppe von Ereignisflags - Ein Satz von 8-Bit-Flags, auf die der Zugriff so geregelt ist, dass mehrere Aufgaben ein Flag sicher verwenden können.  Eine Aufgabe kann eine beliebige Kombination von Ereignisflags setzen oder löschen.  Eine andere Aufgabe besteht darin, jederzeit eine Gruppe von Flags zu lesen, und sie kann auch auf eine bestimmte Folge von Flags warten (durch Abfrage oder mit einer Pause). <br><br><h2>  Ereignisflaggruppen konfigurieren </h2><br><h3>  Anzahl der Ereignisflaggruppen </h3><br>  Wie bei den meisten Nucleus SE-Objekten wird die Konfiguration von Ereignisflaggruppen durch die Direktiven <b>#define</b> in <b>nuse_config.h festgelegt</b> .  Der Hauptparameter ist <b>NUSE_EVENT_GROUP_NUMBER</b> , der bestimmt, wie viele Gruppen von Ereignisflags in der Anwendung definiert werden.  Standardmäßig ist dieser Parameter auf 0 gesetzt ( <b>dh</b> Gruppen von Ereignisflags werden nicht verwendet) und kann einen beliebigen Wert von bis zu 16 haben. Ein falscher Wert führt zu einem Kompilierungsfehler, der durch Einchecken von <b>nuse_config_check.h</b> generiert wird (aktiviert durch <b>nuse_config.c)</b> Dies bedeutet, dass es mit diesem Modul kompiliert wird. Infolgedessen <b>funktioniert die</b> Direktive <b>#error</b> .  Die Auswahl eines Werts ungleich Null dient als Hauptaktivator für die Ereignisflaggruppen.  Dieser Parameter wird beim Definieren von Datenstrukturen verwendet und ihre Größe hängt von ihrem Wert ab (mehr dazu in den folgenden Artikeln).  Darüber hinaus aktiviert ein Wert ungleich Null die API-Einstellungen. <br><br><h3>  API-Aufrufe aktivieren </h3><br>  Jede API-Funktion (Dienstprogrammaufruf) in Nucleus SE wird durch die Direktive <b>#define</b> in <b>nuse_config.h</b> aktiviert.  Für Gruppen von Ereignisflags gehören dazu: <br> <code>NUSE_EVENT_GROUP_SET <br> NUSE_EVENT_GROUP_RETRIEVE <br> NUSE_EVENT_GROUP_INFORMATION <br> NUSE_EVENT_GROUP_COUNT <br></code> <br>  Standardmäßig sind sie auf <b>FALSE gesetzt</b> , wodurch jeder Serviceabruf deaktiviert und die Aufnahme von Code blockiert wird, der sie implementiert.  Um Gruppen von Ereignisflags zu konfigurieren, müssen Sie die erforderlichen API-Aufrufe auswählen und die entsprechenden Anweisungen auf <b>TRUE setzen</b> . <br><br>  Das Folgende ist ein Auszug aus der Standarddatei nuse_config.h. <br><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUSE_EVENT_GROUP_NUMBER 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Number of event groups in the system - 0-16 */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUSE_EVENT_GROUP_SET FALSE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Service call enabler */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUSE_EVENT_GROUP_RETRIEVE FALSE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Service call enabler */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUSE_EVENT_GROUP_INFORMATION FALSE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Service call enabler */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUSE_EVENT_GROUP_COUNT FALSE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Service call enabler */</span></span></span></span></code> </pre><br>  Eine aktivierte API-Funktion, wenn keine Ereignisflaggruppen in der Anwendung vorhanden sind, führt zu einem Kompilierungsfehler (mit Ausnahme von <b>NUSE_Event_Group_Count ()</b> , das immer aktiviert ist).  Wenn Ihr Code einen API-Aufruf verwendet, der nicht aktiviert wurde, tritt ein Layoutfehler auf, da der Implementierungscode nicht in der Anwendung enthalten war. <br><br><h2>  Ereignisaufruf-Dienstprogrammaufrufe </h2><br>  Nucleus RTOS unterstützt sieben Dienstprogrammaufrufe mit den folgenden Funktionen: <br><br><ul><li>  Setzen Sie Ereignisflags.  Nucleus SE ist in der Funktion <b>NUSE_Event_Group_Set ()</b> implementiert. </li><li>  Ereignisflags lesen.  In Nucleus SE, implementiert in <b>NUSE_Event_Group_Retrieve ()</b> . </li><li>  Bereitstellung von Informationen zu einer bestimmten Gruppe von Ereignisflags.  In Nucleus SE, implementiert in <b>NUSE_Event_Group_Information ()</b> . </li><li>  Gibt die Anzahl der aktuell konfigurierten Ereignisflaggruppen in der Anwendung zurück.  In Nucleus SE, implementiert in <b>NUSE_Event_Group_Count ()</b> . </li><li>  Hinzufügen einer neuen Gruppe von Ereignisflags zur Anwendung.  Nucleus SE ist nicht implementiert. </li><li>  Entfernen einer Gruppe von Ereignisflags aus der Anwendung.  Nucleus SE ist nicht implementiert. </li><li>  Rückgabe von Zeigern auf alle Gruppen von Ereignisflags in der Anwendung.  Nucleus SE ist nicht implementiert. </li></ul><br>  Die Implementierung jedes dieser Overhead-Aufrufe wird nachstehend ausführlich erläutert. <br><br>  Es ist erwähnenswert, dass weder in Nucleus RTOS noch in Nucleus SE eine Rücksetzfunktion vorhanden ist.  Dies geschieht absichtlich.  Die Rücksetzfunktion impliziert die Prävalenz des Sonderzustands der Flags.  Für Gruppen von Ereignisflags besteht der einzige "spezielle" Status darin, alle Flags zurückzusetzen, was mit <b>NUSE_Event_Group_Set () erfolgen kann</b> . <br><br><h2>  Serviceaufrufe zum Setzen und Lesen von Ereignisflaggruppen </h2><br>  Die grundlegenden Operationen, die für eine Gruppe von Ereignisflags ausgeführt werden können, sind das Setzen des Werts eines oder mehrerer Flags sowie das Lesen der aktuellen Flagwerte.  Nucleus RTOS und Nucleus SE bieten vier grundlegende API-Aufrufe für diese Vorgänge. <br><br>  Da Ereignisflags Bits sind, werden sie am besten als Binärzahlen dargestellt.  Da Standard C die Darstellung von <b>Binärkonstanten</b> (nur oktal und hexadezimal) in der <b>Vergangenheit</b> nicht unterstützt hat, verfügt Nucleus SE über eine nützliche Header-Datei <b>nuse_binary.h</b> , die <b>#</b> <b>define-</b> Zeichen wie <b>b01010101</b> für alle 256 8-Bit-Werte enthält. <br><br><h3>  Ereignisflags setzen </h3><br>  Der Aufruf des Nucleus RTOS API-Dienstprogramms zum Kennzeichnen ist sehr flexibel und ermöglicht das Festlegen und Löschen von Kennzeichnungswerten mithilfe von <b>UND-</b> und <b>ODER-</b> Operationen.  Nucleus SE bietet ähnliche Funktionen, die Unterbrechung der Aufgabe ist jedoch optional. <br><br>  <b><i>Aufruf zum Setzen von Flags in Nucleus RTOS</i></b> <br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NU_Set_Events (Gruppe NU_EVENT_GROUP *, UNSIGNED event_flags, OPTION-Operation);</b> <br><br>  Parameter: <br><br>  <b>group</b> - ein Zeiger auf einen vom Benutzer bereitgestellten Steuerblock für eine Gruppe von Ereignisflags; <br>  <b>event_flags</b> - Wert der Bitmaske der <b>Flaggruppe</b> ; <br>  <b>Operation</b> - Die <b>auszuführende</b> <b>Operation</b> , <b>NU_OR</b> (zum Setzen von Flags) oder <b>NU_AND</b> (zum Löschen von Flags). <br><br>  Rückgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_GROUP</b> - ungültiger Zeiger auf eine Gruppe von Ereignisflags; <br>  <b>NU_INVALID_OPERATION</b> - Die angegebene Operation unterscheidet sich von <b>NU_OR</b> und <b>NU_AND</b> . <br><br>  <b><i>Aufruf zum Setzen von Flags in Nucleus SE</i></b> <br>  Dieser API-Aufruf unterstützt die Kernfunktionalität der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NUSE_Event_Group_Set (Gruppe NUSE_EVENT_GROUP, U8 event_flags, OPTION-Operation);</b> <br><br>  Parameter: <br><br>  <b>Gruppe</b> - der Index (ID) der Ereignisgruppe, deren Flags gesetzt / gelöscht sind; <br>  <b>event_flags</b> - Wert des <b>Bitmaxi</b> einer Gruppe von Flags; <br>  <b>Operation</b> - Die <b>auszuführende</b> <b>Operation</b> , <b>NUSE_OR</b> (zum Setzen von Flags) oder <b>NUSE_AND</b> (zum Löschen von Flags). <br><br>  Rückgabewert: <br><br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INVALID_GROUP</b> - ungültiger Index einer Gruppe von Ereignisflags; <br>  <b>NUSE_INVALID_OPERATION</b> - Die angegebene Operation unterscheidet sich von <b>NUSE_OR</b> und <b>NUSE_AND</b> . <br><br>  <b><i>Implementierung der Installation von Ereignisflags in Nucleus SE</i></b> <br>  Der Anfangscode der API-Funktion <b>NUSE_Event_Group_Set ()</b> ist allgemein (nach Überprüfung der Parameter), unabhängig davon, ob die API das Blockieren von Aufrufen unterstützt (Task-Suspendierung) oder nicht.  Die Logik ist ziemlich einfach: <br><br><pre> <code class="hljs powershell">NUSE_CS_Enter(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (operation == NUSE_OR) { NUSE_Event_Group_Data[<span class="hljs-type"><span class="hljs-type">group</span></span>] |= event_flags; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> /* NUSE_AND */ { NUSE_Event_Group_Data[<span class="hljs-type"><span class="hljs-type">group</span></span>] &amp;= event_flags; }</code> </pre> <br>  Die <b>Bitmaske event_flags wird</b> (unter Verwendung der <b>UND-</b> oder <b>ODER-</b> Verknüpfung) dem Wert der ausgewählten Gruppe von Ereignisflags überlagert. <br><br>  Der verbleibende Code wird nur aktiviert, wenn die Task-Sperre aktiviert ist: <br><br><pre> <code class="hljs mel">#<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> NUSE_BLOCKING_ENABLE <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (NUSE_Event_Group_Blocking_Count[<span class="hljs-keyword"><span class="hljs-keyword">group</span></span>] != <span class="hljs-number"><span class="hljs-number">0</span></span>) { U8 index; <span class="hljs-comment"><span class="hljs-comment">/* check whether any tasks are blocked */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* on this event group */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (index=<span class="hljs-number"><span class="hljs-number">0</span></span>; index&lt;NUSE_TASK_NUMBER; index++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((LONIB(NUSE_Task_Status[index]) == NUSE_EVENT_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == <span class="hljs-keyword"><span class="hljs-keyword">group</span></span>)) { NUSE_Task_Blocking_Return[index] = NUSE_SUCCESS; NUSE_Task_Status[index] = NUSE_READY; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } NUSE_Event_Group_Blocking_Count[<span class="hljs-keyword"><span class="hljs-keyword">group</span></span>]--; } #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> NUSE_SCHEDULER_TYPE == NUSE_PRIORITY_SCHEDULER NUSE_Reschedule(NUSE_NO_TASK); #endif #endif NUSE_CS_Exit(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NUSE_SUCCESS;</code> </pre> <br>  Wenn Aufgaben (zum Lesen) von dieser Gruppe von Flags angehalten werden, werden sie fortgesetzt.  Wenn sie die Möglichkeit erhalten, die Ausführung fortzusetzen (dies hängt vom Scheduler ab), können sie feststellen, ob die Bedingungen für ihre Wiederaufnahme erfüllt sind oder nicht (siehe Lesen von Ereignisflags). <br><br><h3>  Ereignisflags lesen </h3><br>  Die Aufrufe des Nucleus RTOS API-Dienstprogramms zum Lesen sind sehr flexibel und ermöglichen es Ihnen, Aufgaben auf unbestimmte Zeit oder mit einem bestimmten Zeitlimit anzuhalten, wenn der Vorgang nicht sofort abgeschlossen werden kann (z. B. wenn Sie versuchen, eine bestimmte Folge von Ereignisflags zu lesen, die nicht den aktuellen Status darstellen).  Nucleus SE bietet dieselben Funktionen, nur die Unterbrechung der Aufgabe ist optional und das Zeitlimit ist nicht implementiert. <br><br>  <b><i>Flags Challenge in Nucleus RTOS</i></b> <br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NU_Retrieve_Events (Gruppe NU_EVENT_GROUP *, UNSIGNED Requested_events, OPTION-Operation, UNSIGNED * Retrieved_events, UNSIGNED Suspend);</b> <br><br>  Parameter: <br><br>  <b>group</b> - ein Zeiger auf einen vom Benutzer bereitgestellten Steuerblock für eine Gruppe von Ereignisflags; <br>  <b>request_events</b> - eine Bitmaske, die die zu lesenden Flags definiert; <br>  <b>Operation</b> - Es stehen vier <b>Operationen</b> zur Verfügung: <b>NU_AND</b> , <b>NU_AND_CONSUME</b> , <b>NU_OR</b> und <b>NU_OR_CONSUME</b> .  Die Operationen <b>NU_AND</b> und <b>NU_AND_CONSUME</b> geben an, dass alle angeforderten Flags erforderlich sind.  Die Operationen <b>NU_OR</b> und <b>NU_OR_CONSUME</b> zeigen an, dass eines oder mehrere der angeforderten Flags ausreichend sind.  Der Parameter <b>CONSUME</b> löscht nach einer erfolgreichen Anforderung automatisch vorhandene Flags. <br>  <b>retrieved_events</b> - Speicherzeiger für die Werte der Leseereignisflags; <br>  <b>suspend</b> - Spezifikation für das Anhalten von Aufgaben;  kann die Werte <b>NU_NO_SUSPEND</b> oder <b>NU_SUSPEND</b> oder den Timeout-Wert in Takt- <b>Ticks</b> (von 1 bis 4.294.967.293) <b>annehmen</b> . <br><br>  Rückgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_NOT_PRESENT</b> - Die angegebene Operation hat keine Ereignisse zurückgegeben (kein einziges Ereignis im Fall von NU_OR und nicht alle Ereignisse im Fall von NU_AND). <br>  <b>NU_INVALID_GROUP</b> - ungültiger Zeiger auf eine Gruppe von Ereignisflags; <br>  <b>NU_INVALID_OPERATION</b> - Die angegebene Operation war falsch. <br>  <b>NU_INVALID_POINTER</b> - Nullzeiger auf den Speicher der Ereignisflags (NULL); <br>  <b>NU_INVALID_SUSPEND</b> - Versuch, von einem nicht aufgabenbezogenen Thread aus <b>anzuhalten</b> ; <br>  <b>NU_TIMEOUT</b> - Die erforderliche Kombination von Ereignisflags wurde auch nach dem angegebenen Zeitlimit nicht gesetzt. <br>  <b>NU_GROUP_DELETED</b> - Die Gruppe von Ereignisflags wurde gelöscht, während die Aufgabe angehalten wurde. <br><br>  <b><i>Flags Challenge in Nucleus SE</i></b> <br>  Dieser API-Aufruf unterstützt die Kernfunktionalität der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NUSE_Event_Group_Retrieve (Gruppe NUSE_EVENT_GROUP, U8 angeforderte_Ereignisse, OPTION-Operation, U8 * abgerufene_Ereignisse, U8-Suspend);</b> <br><br>  Parameter: <br><br>  <b>Gruppe</b> - Index (ID) der gelesenen Gruppe von Ereignisflags; <br>  <b>request_events</b> - eine Bitmaske, die die zu lesenden Flags definiert; <br>  <b>operation</b> - eine Spezifikation, die die Anzahl der benötigten Flags <b>angibt</b> : <b>NUSE OR</b> (einige Flags) oder <b>NUSE AND</b> (alle Flags); <br>  <b>retrieved_events</b> - ein Zeiger auf den Speicher für die tatsächlichen Werte der <b>Leseereignisflags</b> (bei der Operation <b>NUSE_AND entspricht</b> dies der <b>Übergabe</b> im Parameter <b>request_events</b> ); <br>  <b>suspend</b> - Spezifikation zum Anhalten einer Aufgabe, die die Werte <b>NUSE_NO_SUSPEND</b> oder <b>NUSE_SUSPEND annehmen kann</b> . <br><br>  Rückgabewert: <br><br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_NOT_PRESENT</b> - Die angegebene Operation hat keine Ereignisse zurückgegeben (kein einziges Ereignis im Fall von <b>NUSE_OR</b> und nicht alle Ereignisse im Fall von <b>NUSE_AND</b> ). <br>  <b>NUSE_INVALID_GROUP</b> - ungültiger Index einer Gruppe von Ereignisflags; <br>  <b>NUSE_INVALID_OPERATION</b> - Die angegebene Operation unterscheidet sich von <b>NUSE_OR</b> oder <b>NUSE_AND</b> . <br>  <b>NUSE_INVALID_POINTER</b> - ein Nullzeiger auf den Speicher der <b>Leseereignisflags</b> ( <b>NULL</b> ); <br>  <b>NUSE_INVALID_SUSPEND</b> - Ein Versuch, eine Pause von einem Nicht-Task-Flow <b>einzulegen</b> oder wenn die Unterstützung für das Blockieren von API-Aufrufen deaktiviert ist. <br><br>  <b><i>Implementieren des Lesens von Ereignisflags in Nucleus SE</i></b> <br>  Die Version des API-Funktionscodes <b>NUSE_Event_Group_Retrieve ()</b> (nach Überprüfung der Parameter) wird während der bedingten Kompilierung ausgewählt, je nachdem, ob die Unterstützung für die API-Aufrufe zum Blockieren (Anhalten) von Aufgaben aktiviert ist oder nicht.  Betrachten wir diese beiden Optionen getrennt. <br><br>  Wenn die Sperre deaktiviert ist, sieht der vollständige Code für diesen API-Aufruf folgendermaßen aus: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">temp_events</span></span> = NUSE_Event_Group_Data[group] &amp; requested_events; <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (operation == NUSE_OR) { <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (temp_events != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-attribute"><span class="hljs-attribute">return_value</span></span> = NUSE_SUCCESS; } <span class="hljs-section"><span class="hljs-section">else</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">return_value</span></span> = NUSE_NOT_PRESENT; } } <span class="hljs-attribute"><span class="hljs-attribute">else</span></span> /* operation == NUSE_AND */ { <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (temp_events == requested_events) { <span class="hljs-attribute"><span class="hljs-attribute">return_value</span></span> = NUSE_SUCCESS; } <span class="hljs-section"><span class="hljs-section">else</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">return_value</span></span> = NUSE_NOT_PRESENT; } }</code> </pre><br>  Die erforderlichen Ereignisflags werden aus der angegebenen Ereignisflaggruppe ausgewählt.  Der Wert wird unter Berücksichtigung der <b>UND / ODER-</b> Operation sowie des zurückgegebenen Ergebnisses und der unmittelbaren Werte der angeforderten Flags mit den erforderlichen Ereignissen verglichen. <br><br>  Wenn die Task-Sperre aktiviert ist, wird der Code komplexer: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { temp_events = NUSE_Event_Group_Data[group] &amp; requested_events; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (operation == NUSE_OR) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp_events != <span class="hljs-number"><span class="hljs-number">0</span></span>) { return_value = NUSE_SUCCESS; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { return_value = NUSE_NOT_PRESENT; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment">/* operation == NUSE_AND */</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp_events == requested_events) { return_value = NUSE_SUCCESS; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { return_value = NUSE_NOT_PRESENT; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (return_value == NUSE_SUCCESS) { <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> = NUSE_NO_SUSPEND; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> == NUSE_SUSPEND) <span class="hljs-comment"><span class="hljs-comment">/* block task */</span></span> { NUSE_Event_Group_Blocking_Count[group]++; NUSE_Suspend_Task(NUSE_Task_Active, (group &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) | NUSE_EVENT_SUSPEND); return_value = NUSE_Task_Blocking_Return[NUSE_Task_Active]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (return_value != NUSE_SUCCESS) { <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> = NUSE_NO_SUSPEND; } } } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> == NUSE_SUSPEND);</code> </pre><br>  Der Code wird in eine <b>do ... while-Schleife</b> <b>eingefügt</b> , die funktioniert, während der <b>suspend-</b> Parameter <b>NUSE_SUSPEND lautet</b> . <br><br>  Die angeforderten Ereignisflags werden so gelesen, als würden sie ohne Blockierung aufgerufen.  Wenn der <b>Lesevorgang</b> nicht erfolgreich ist und der <b>Suspend-</b> Parameter <b>NUSE_NO_SUSPEND lautet</b> , wird der API-Aufruf auf <b>NUSE_NOT_PRESENT gesetzt</b> .  Wenn der <b>Suspend-</b> Parameter auf <b>NUSE_SUSPEND gesetzt wurde</b> , wird die Task <b>angehalten</b> .  Wenn bei der Rückkehr (wenn die Aufgabe <b>fortgesetzt</b> wird) der Rückgabewert <b>NUSE_SUCCESS</b> lautet und <b>angibt</b> , dass die Aufgabe fortgesetzt wurde, weil die Ereignisflags in dieser Gruppe gesetzt oder gelöscht wurden, beginnt der Zyklus von <b>vorne</b> , die Flags werden gelesen und überprüft.  Da es keine API-Funktion zum Zurücksetzen von Ereignisflaggruppen gibt, ist dies der einzige Grund für die Wiederaufnahme der Aufgabe. Der Überprüfungsprozess <b>NUSE_Task_Blocking_Return []</b> wurde jedoch auf dem System belassen, um die Kompatibilität der <b>Sperrsteuerung</b> mit anderen <b>Objekttypen zu</b> gewährleisten. <br><br>  Der folgende Artikel beschreibt zusätzliche API-Aufrufe, die Ereignisflaggruppen zugeordnet sind, sowie deren Datenstrukturen. <br><br>  <b>Über den Autor:</b> Colin Walls ist seit über dreißig Jahren in der Elektronikindustrie tätig und widmet sich die meiste Zeit der Firmware.  Heute ist er Firmware-Ingenieur bei Mentor Embedded (einer Abteilung von Mentor Graphics).  Colin Walls spricht häufig auf Konferenzen und Seminaren, Autor zahlreicher technischer Artikel und zweier Bücher über Firmware.  Lebt in Großbritannien.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Colins</a> professioneller <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog</a> , E-Mail: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428131/">https://habr.com/ru/post/de428131/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428121/index.html">Stan Drapkin. Hochrangige Kryptografiefallen in .NET</a></li>
<li><a href="../de428123/index.html">Sicherheitswoche 41: Gute Nachrichten</a></li>
<li><a href="../de428125/index.html">Wer sind Produktanalysen und warum werden sie in einem Team benötigt?</a></li>
<li><a href="../de428127/index.html">Nginx-Cache: alles neu - gut vergessen alt</a></li>
<li><a href="../de428129/index.html">Einfache Fuzzy-Logik „für das, was für ein Gasturbinentriebwerk war“</a></li>
<li><a href="../de428133/index.html">Hasura. Hochleistungs-GraphQL-zu-SQL-Server-Architektur</a></li>
<li><a href="../de428135/index.html">So konfigurieren oder deaktivieren Sie Flusen im integrierten Code-Editor</a></li>
<li><a href="../de428137/index.html">Olympiade, Ideenwettbewerb, Vorträge über IT-Projektmanagement und Filmvorführungen: 10 bevorstehende Veranstaltungen an der ITMO University</a></li>
<li><a href="../de428141/index.html">Das Backend für das Frontend oder How Yandex.Market erstellt eine API ohne Krücken</a></li>
<li><a href="../de428143/index.html">ReactJS RBAC-Implementierungsansatz</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>