<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí≠ üî• üë©üèΩ‚Äç‚úàÔ∏è Die ganze Wahrheit √ºber RTOS. Artikel Nr. 17. Ereignisflag-Gruppen: Einf√ºhrung und Basisdienste üë©üèª‚Äç‚öñÔ∏è ‚ôèÔ∏è üëèüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Gruppen von Ereignisflags wurden bereits in einem der vorherigen Artikel (Nr. 5) erw√§hnt. In Nucleus SE √§hneln sie Signalen, sind jedoch flexibler. Si...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Die ganze Wahrheit √ºber RTOS. Artikel Nr. 17. Ereignisflag-Gruppen: Einf√ºhrung und Basisdienste</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/428131/"><img src="https://habrastorage.org/webt/y6/hx/yw/y6hxyww0r_cp5m_lr0uspctzgqk.jpeg"><br><br>  Gruppen von Ereignisflags wurden bereits in einem der vorherigen Artikel (Nr. 5) erw√§hnt.  In Nucleus SE √§hneln sie Signalen, sind jedoch flexibler.  Sie bieten eine kosteng√ºnstige und flexible M√∂glichkeit, einfache Nachrichten zwischen Aufgaben zu √ºbertragen. <br><a name="habracut"></a><br><br>  Fr√ºhere Artikel in der Reihe: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 16.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Signale</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 15.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherpartitionen: Dienste und Datenstrukturen</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel # 14.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Speicherbereiche: Einf√ºhrung und Grundversorgung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel Nr. 13.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabendatenstrukturen und nicht unterst√ºtzte API-Aufrufe</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 12.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dienstleistungen f√ºr die Arbeit mit Aufgaben</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 11.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben: Konfiguration und Einf√ºhrung in die API</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 10.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Erweiterte Funktionen und Kontexterhaltung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 9.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Scheduler: Implementierung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 8.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Internes Design und Bereitstellung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 7.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nucleus SE: Einf√ºhrung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 6.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Andere RTOS-Dienste</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 5.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgabeninteraktion und Synchronisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 4.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben, Kontextwechsel und Interrupts</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 3.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Aufgaben und Planung</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 2.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Struktur und Echtzeitmodus</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel 1.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">RTOS: Einf√ºhrung.</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><br></a> <br><br><h2>  Ereignisflags verwenden </h2><br>  In Nucleus SE werden Ereignisflags w√§hrend der Erstellungsphase definiert.  Die maximale Anzahl von Ereignisflaggruppen in der Anwendung betr√§gt 16. Wenn keine Ereignisflaggruppen definiert sind, wird der Code, der sich auf die Datenstrukturen und Serviceaufrufe der Ereignisflaggruppen bezieht, nicht in die Anwendung aufgenommen. <br><br>  Gruppe von Ereignisflags - Ein Satz von 8-Bit-Flags, auf die der Zugriff so geregelt ist, dass mehrere Aufgaben ein Flag sicher verwenden k√∂nnen.  Eine Aufgabe kann eine beliebige Kombination von Ereignisflags setzen oder l√∂schen.  Eine andere Aufgabe besteht darin, jederzeit eine Gruppe von Flags zu lesen, und sie kann auch auf eine bestimmte Folge von Flags warten (durch Abfrage oder mit einer Pause). <br><br><h2>  Ereignisflaggruppen konfigurieren </h2><br><h3>  Anzahl der Ereignisflaggruppen </h3><br>  Wie bei den meisten Nucleus SE-Objekten wird die Konfiguration von Ereignisflaggruppen durch die Direktiven <b>#define</b> in <b>nuse_config.h festgelegt</b> .  Der Hauptparameter ist <b>NUSE_EVENT_GROUP_NUMBER</b> , der bestimmt, wie viele Gruppen von Ereignisflags in der Anwendung definiert werden.  Standardm√§√üig ist dieser Parameter auf 0 gesetzt ( <b>dh</b> Gruppen von Ereignisflags werden nicht verwendet) und kann einen beliebigen Wert von bis zu 16 haben. Ein falscher Wert f√ºhrt zu einem Kompilierungsfehler, der durch Einchecken von <b>nuse_config_check.h</b> generiert wird (aktiviert durch <b>nuse_config.c)</b> Dies bedeutet, dass es mit diesem Modul kompiliert wird. Infolgedessen <b>funktioniert die</b> Direktive <b>#error</b> .  Die Auswahl eines Werts ungleich Null dient als Hauptaktivator f√ºr die Ereignisflaggruppen.  Dieser Parameter wird beim Definieren von Datenstrukturen verwendet und ihre Gr√∂√üe h√§ngt von ihrem Wert ab (mehr dazu in den folgenden Artikeln).  Dar√ºber hinaus aktiviert ein Wert ungleich Null die API-Einstellungen. <br><br><h3>  API-Aufrufe aktivieren </h3><br>  Jede API-Funktion (Dienstprogrammaufruf) in Nucleus SE wird durch die Direktive <b>#define</b> in <b>nuse_config.h</b> aktiviert.  F√ºr Gruppen von Ereignisflags geh√∂ren dazu: <br> <code>NUSE_EVENT_GROUP_SET <br> NUSE_EVENT_GROUP_RETRIEVE <br> NUSE_EVENT_GROUP_INFORMATION <br> NUSE_EVENT_GROUP_COUNT <br></code> <br>  Standardm√§√üig sind sie auf <b>FALSE gesetzt</b> , wodurch jeder Serviceabruf deaktiviert und die Aufnahme von Code blockiert wird, der sie implementiert.  Um Gruppen von Ereignisflags zu konfigurieren, m√ºssen Sie die erforderlichen API-Aufrufe ausw√§hlen und die entsprechenden Anweisungen auf <b>TRUE setzen</b> . <br><br>  Das Folgende ist ein Auszug aus der Standarddatei nuse_config.h. <br><br><pre> <code class="hljs cpp"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUSE_EVENT_GROUP_NUMBER 0 </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Number of event groups in the system - 0-16 */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUSE_EVENT_GROUP_SET FALSE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Service call enabler */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUSE_EVENT_GROUP_RETRIEVE FALSE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Service call enabler */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUSE_EVENT_GROUP_INFORMATION FALSE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Service call enabler */</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> NUSE_EVENT_GROUP_COUNT FALSE </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">/* Service call enabler */</span></span></span></span></code> </pre><br>  Eine aktivierte API-Funktion, wenn keine Ereignisflaggruppen in der Anwendung vorhanden sind, f√ºhrt zu einem Kompilierungsfehler (mit Ausnahme von <b>NUSE_Event_Group_Count ()</b> , das immer aktiviert ist).  Wenn Ihr Code einen API-Aufruf verwendet, der nicht aktiviert wurde, tritt ein Layoutfehler auf, da der Implementierungscode nicht in der Anwendung enthalten war. <br><br><h2>  Ereignisaufruf-Dienstprogrammaufrufe </h2><br>  Nucleus RTOS unterst√ºtzt sieben Dienstprogrammaufrufe mit den folgenden Funktionen: <br><br><ul><li>  Setzen Sie Ereignisflags.  Nucleus SE ist in der Funktion <b>NUSE_Event_Group_Set ()</b> implementiert. </li><li>  Ereignisflags lesen.  In Nucleus SE, implementiert in <b>NUSE_Event_Group_Retrieve ()</b> . </li><li>  Bereitstellung von Informationen zu einer bestimmten Gruppe von Ereignisflags.  In Nucleus SE, implementiert in <b>NUSE_Event_Group_Information ()</b> . </li><li>  Gibt die Anzahl der aktuell konfigurierten Ereignisflaggruppen in der Anwendung zur√ºck.  In Nucleus SE, implementiert in <b>NUSE_Event_Group_Count ()</b> . </li><li>  Hinzuf√ºgen einer neuen Gruppe von Ereignisflags zur Anwendung.  Nucleus SE ist nicht implementiert. </li><li>  Entfernen einer Gruppe von Ereignisflags aus der Anwendung.  Nucleus SE ist nicht implementiert. </li><li>  R√ºckgabe von Zeigern auf alle Gruppen von Ereignisflags in der Anwendung.  Nucleus SE ist nicht implementiert. </li></ul><br>  Die Implementierung jedes dieser Overhead-Aufrufe wird nachstehend ausf√ºhrlich erl√§utert. <br><br>  Es ist erw√§hnenswert, dass weder in Nucleus RTOS noch in Nucleus SE eine R√ºcksetzfunktion vorhanden ist.  Dies geschieht absichtlich.  Die R√ºcksetzfunktion impliziert die Pr√§valenz des Sonderzustands der Flags.  F√ºr Gruppen von Ereignisflags besteht der einzige "spezielle" Status darin, alle Flags zur√ºckzusetzen, was mit <b>NUSE_Event_Group_Set () erfolgen kann</b> . <br><br><h2>  Serviceaufrufe zum Setzen und Lesen von Ereignisflaggruppen </h2><br>  Die grundlegenden Operationen, die f√ºr eine Gruppe von Ereignisflags ausgef√ºhrt werden k√∂nnen, sind das Setzen des Werts eines oder mehrerer Flags sowie das Lesen der aktuellen Flagwerte.  Nucleus RTOS und Nucleus SE bieten vier grundlegende API-Aufrufe f√ºr diese Vorg√§nge. <br><br>  Da Ereignisflags Bits sind, werden sie am besten als Bin√§rzahlen dargestellt.  Da Standard C die Darstellung von <b>Bin√§rkonstanten</b> (nur oktal und hexadezimal) in der <b>Vergangenheit</b> nicht unterst√ºtzt hat, verf√ºgt Nucleus SE √ºber eine n√ºtzliche Header-Datei <b>nuse_binary.h</b> , die <b>#</b> <b>define-</b> Zeichen wie <b>b01010101</b> f√ºr alle 256 8-Bit-Werte enth√§lt. <br><br><h3>  Ereignisflags setzen </h3><br>  Der Aufruf des Nucleus RTOS API-Dienstprogramms zum Kennzeichnen ist sehr flexibel und erm√∂glicht das Festlegen und L√∂schen von Kennzeichnungswerten mithilfe von <b>UND-</b> und <b>ODER-</b> Operationen.  Nucleus SE bietet √§hnliche Funktionen, die Unterbrechung der Aufgabe ist jedoch optional. <br><br>  <b><i>Aufruf zum Setzen von Flags in Nucleus RTOS</i></b> <br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NU_Set_Events (Gruppe NU_EVENT_GROUP *, UNSIGNED event_flags, OPTION-Operation);</b> <br><br>  Parameter: <br><br>  <b>group</b> - ein Zeiger auf einen vom Benutzer bereitgestellten Steuerblock f√ºr eine Gruppe von Ereignisflags; <br>  <b>event_flags</b> - Wert der Bitmaske der <b>Flaggruppe</b> ; <br>  <b>Operation</b> - Die <b>auszuf√ºhrende</b> <b>Operation</b> , <b>NU_OR</b> (zum Setzen von Flags) oder <b>NU_AND</b> (zum L√∂schen von Flags). <br><br>  R√ºckgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_INVALID_GROUP</b> - ung√ºltiger Zeiger auf eine Gruppe von Ereignisflags; <br>  <b>NU_INVALID_OPERATION</b> - Die angegebene Operation unterscheidet sich von <b>NU_OR</b> und <b>NU_AND</b> . <br><br>  <b><i>Aufruf zum Setzen von Flags in Nucleus SE</i></b> <br>  Dieser API-Aufruf unterst√ºtzt die Kernfunktionalit√§t der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NUSE_Event_Group_Set (Gruppe NUSE_EVENT_GROUP, U8 event_flags, OPTION-Operation);</b> <br><br>  Parameter: <br><br>  <b>Gruppe</b> - der Index (ID) der Ereignisgruppe, deren Flags gesetzt / gel√∂scht sind; <br>  <b>event_flags</b> - Wert des <b>Bitmaxi</b> einer Gruppe von Flags; <br>  <b>Operation</b> - Die <b>auszuf√ºhrende</b> <b>Operation</b> , <b>NUSE_OR</b> (zum Setzen von Flags) oder <b>NUSE_AND</b> (zum L√∂schen von Flags). <br><br>  R√ºckgabewert: <br><br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_INVALID_GROUP</b> - ung√ºltiger Index einer Gruppe von Ereignisflags; <br>  <b>NUSE_INVALID_OPERATION</b> - Die angegebene Operation unterscheidet sich von <b>NUSE_OR</b> und <b>NUSE_AND</b> . <br><br>  <b><i>Implementierung der Installation von Ereignisflags in Nucleus SE</i></b> <br>  Der Anfangscode der API-Funktion <b>NUSE_Event_Group_Set ()</b> ist allgemein (nach √úberpr√ºfung der Parameter), unabh√§ngig davon, ob die API das Blockieren von Aufrufen unterst√ºtzt (Task-Suspendierung) oder nicht.  Die Logik ist ziemlich einfach: <br><br><pre> <code class="hljs powershell">NUSE_CS_Enter(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (operation == NUSE_OR) { NUSE_Event_Group_Data[<span class="hljs-type"><span class="hljs-type">group</span></span>] |= event_flags; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> /* NUSE_AND */ { NUSE_Event_Group_Data[<span class="hljs-type"><span class="hljs-type">group</span></span>] &amp;= event_flags; }</code> </pre> <br>  Die <b>Bitmaske event_flags wird</b> (unter Verwendung der <b>UND-</b> oder <b>ODER-</b> Verkn√ºpfung) dem Wert der ausgew√§hlten Gruppe von Ereignisflags √ºberlagert. <br><br>  Der verbleibende Code wird nur aktiviert, wenn die Task-Sperre aktiviert ist: <br><br><pre> <code class="hljs mel">#<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> NUSE_BLOCKING_ENABLE <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (NUSE_Event_Group_Blocking_Count[<span class="hljs-keyword"><span class="hljs-keyword">group</span></span>] != <span class="hljs-number"><span class="hljs-number">0</span></span>) { U8 index; <span class="hljs-comment"><span class="hljs-comment">/* check whether any tasks are blocked */</span></span> <span class="hljs-comment"><span class="hljs-comment">/* on this event group */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (index=<span class="hljs-number"><span class="hljs-number">0</span></span>; index&lt;NUSE_TASK_NUMBER; index++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ((LONIB(NUSE_Task_Status[index]) == NUSE_EVENT_SUSPEND) &amp;&amp; (HINIB(NUSE_Task_Status[index]) == <span class="hljs-keyword"><span class="hljs-keyword">group</span></span>)) { NUSE_Task_Blocking_Return[index] = NUSE_SUCCESS; NUSE_Task_Status[index] = NUSE_READY; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } } NUSE_Event_Group_Blocking_Count[<span class="hljs-keyword"><span class="hljs-keyword">group</span></span>]--; } #<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> NUSE_SCHEDULER_TYPE == NUSE_PRIORITY_SCHEDULER NUSE_Reschedule(NUSE_NO_TASK); #endif #endif NUSE_CS_Exit(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NUSE_SUCCESS;</code> </pre> <br>  Wenn Aufgaben (zum Lesen) von dieser Gruppe von Flags angehalten werden, werden sie fortgesetzt.  Wenn sie die M√∂glichkeit erhalten, die Ausf√ºhrung fortzusetzen (dies h√§ngt vom Scheduler ab), k√∂nnen sie feststellen, ob die Bedingungen f√ºr ihre Wiederaufnahme erf√ºllt sind oder nicht (siehe Lesen von Ereignisflags). <br><br><h3>  Ereignisflags lesen </h3><br>  Die Aufrufe des Nucleus RTOS API-Dienstprogramms zum Lesen sind sehr flexibel und erm√∂glichen es Ihnen, Aufgaben auf unbestimmte Zeit oder mit einem bestimmten Zeitlimit anzuhalten, wenn der Vorgang nicht sofort abgeschlossen werden kann (z. B. wenn Sie versuchen, eine bestimmte Folge von Ereignisflags zu lesen, die nicht den aktuellen Status darstellen).  Nucleus SE bietet dieselben Funktionen, nur die Unterbrechung der Aufgabe ist optional und das Zeitlimit ist nicht implementiert. <br><br>  <b><i>Flags Challenge in Nucleus RTOS</i></b> <br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NU_Retrieve_Events (Gruppe NU_EVENT_GROUP *, UNSIGNED Requested_events, OPTION-Operation, UNSIGNED * Retrieved_events, UNSIGNED Suspend);</b> <br><br>  Parameter: <br><br>  <b>group</b> - ein Zeiger auf einen vom Benutzer bereitgestellten Steuerblock f√ºr eine Gruppe von Ereignisflags; <br>  <b>request_events</b> - eine Bitmaske, die die zu lesenden Flags definiert; <br>  <b>Operation</b> - Es stehen vier <b>Operationen</b> zur Verf√ºgung: <b>NU_AND</b> , <b>NU_AND_CONSUME</b> , <b>NU_OR</b> und <b>NU_OR_CONSUME</b> .  Die Operationen <b>NU_AND</b> und <b>NU_AND_CONSUME</b> geben an, dass alle angeforderten Flags erforderlich sind.  Die Operationen <b>NU_OR</b> und <b>NU_OR_CONSUME</b> zeigen an, dass eines oder mehrere der angeforderten Flags ausreichend sind.  Der Parameter <b>CONSUME</b> l√∂scht nach einer erfolgreichen Anforderung automatisch vorhandene Flags. <br>  <b>retrieved_events</b> - Speicherzeiger f√ºr die Werte der Leseereignisflags; <br>  <b>suspend</b> - Spezifikation f√ºr das Anhalten von Aufgaben;  kann die Werte <b>NU_NO_SUSPEND</b> oder <b>NU_SUSPEND</b> oder den Timeout-Wert in Takt- <b>Ticks</b> (von 1 bis 4.294.967.293) <b>annehmen</b> . <br><br>  R√ºckgabewert: <br><br>  <b>NU_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NU_NOT_PRESENT</b> - Die angegebene Operation hat keine Ereignisse zur√ºckgegeben (kein einziges Ereignis im Fall von NU_OR und nicht alle Ereignisse im Fall von NU_AND). <br>  <b>NU_INVALID_GROUP</b> - ung√ºltiger Zeiger auf eine Gruppe von Ereignisflags; <br>  <b>NU_INVALID_OPERATION</b> - Die angegebene Operation war falsch. <br>  <b>NU_INVALID_POINTER</b> - Nullzeiger auf den Speicher der Ereignisflags (NULL); <br>  <b>NU_INVALID_SUSPEND</b> - Versuch, von einem nicht aufgabenbezogenen Thread aus <b>anzuhalten</b> ; <br>  <b>NU_TIMEOUT</b> - Die erforderliche Kombination von Ereignisflags wurde auch nach dem angegebenen Zeitlimit nicht gesetzt. <br>  <b>NU_GROUP_DELETED</b> - Die Gruppe von Ereignisflags wurde gel√∂scht, w√§hrend die Aufgabe angehalten wurde. <br><br>  <b><i>Flags Challenge in Nucleus SE</i></b> <br>  Dieser API-Aufruf unterst√ºtzt die Kernfunktionalit√§t der Nucleus RTOS-API. <br><br>  Prototyp eines Serviceabrufs: <br><br>  <b>STATUS NUSE_Event_Group_Retrieve (Gruppe NUSE_EVENT_GROUP, U8 angeforderte_Ereignisse, OPTION-Operation, U8 * abgerufene_Ereignisse, U8-Suspend);</b> <br><br>  Parameter: <br><br>  <b>Gruppe</b> - Index (ID) der gelesenen Gruppe von Ereignisflags; <br>  <b>request_events</b> - eine Bitmaske, die die zu lesenden Flags definiert; <br>  <b>operation</b> - eine Spezifikation, die die Anzahl der ben√∂tigten Flags <b>angibt</b> : <b>NUSE OR</b> (einige Flags) oder <b>NUSE AND</b> (alle Flags); <br>  <b>retrieved_events</b> - ein Zeiger auf den Speicher f√ºr die tats√§chlichen Werte der <b>Leseereignisflags</b> (bei der Operation <b>NUSE_AND entspricht</b> dies der <b>√úbergabe</b> im Parameter <b>request_events</b> ); <br>  <b>suspend</b> - Spezifikation zum Anhalten einer Aufgabe, die die Werte <b>NUSE_NO_SUSPEND</b> oder <b>NUSE_SUSPEND annehmen kann</b> . <br><br>  R√ºckgabewert: <br><br>  <b>NUSE_SUCCESS</b> - Der Anruf wurde erfolgreich abgeschlossen. <br>  <b>NUSE_NOT_PRESENT</b> - Die angegebene Operation hat keine Ereignisse zur√ºckgegeben (kein einziges Ereignis im Fall von <b>NUSE_OR</b> und nicht alle Ereignisse im Fall von <b>NUSE_AND</b> ). <br>  <b>NUSE_INVALID_GROUP</b> - ung√ºltiger Index einer Gruppe von Ereignisflags; <br>  <b>NUSE_INVALID_OPERATION</b> - Die angegebene Operation unterscheidet sich von <b>NUSE_OR</b> oder <b>NUSE_AND</b> . <br>  <b>NUSE_INVALID_POINTER</b> - ein Nullzeiger auf den Speicher der <b>Leseereignisflags</b> ( <b>NULL</b> ); <br>  <b>NUSE_INVALID_SUSPEND</b> - Ein Versuch, eine Pause von einem Nicht-Task-Flow <b>einzulegen</b> oder wenn die Unterst√ºtzung f√ºr das Blockieren von API-Aufrufen deaktiviert ist. <br><br>  <b><i>Implementieren des Lesens von Ereignisflags in Nucleus SE</i></b> <br>  Die Version des API-Funktionscodes <b>NUSE_Event_Group_Retrieve ()</b> (nach √úberpr√ºfung der Parameter) wird w√§hrend der bedingten Kompilierung ausgew√§hlt, je nachdem, ob die Unterst√ºtzung f√ºr die API-Aufrufe zum Blockieren (Anhalten) von Aufgaben aktiviert ist oder nicht.  Betrachten wir diese beiden Optionen getrennt. <br><br>  Wenn die Sperre deaktiviert ist, sieht der vollst√§ndige Code f√ºr diesen API-Aufruf folgenderma√üen aus: <br><br><pre> <code class="hljs nginx"><span class="hljs-attribute"><span class="hljs-attribute">temp_events</span></span> = NUSE_Event_Group_Data[group] &amp; requested_events; <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (operation == NUSE_OR) { <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (temp_events != <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-attribute"><span class="hljs-attribute">return_value</span></span> = NUSE_SUCCESS; } <span class="hljs-section"><span class="hljs-section">else</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">return_value</span></span> = NUSE_NOT_PRESENT; } } <span class="hljs-attribute"><span class="hljs-attribute">else</span></span> /* operation == NUSE_AND */ { <span class="hljs-attribute"><span class="hljs-attribute">if</span></span> (temp_events == requested_events) { <span class="hljs-attribute"><span class="hljs-attribute">return_value</span></span> = NUSE_SUCCESS; } <span class="hljs-section"><span class="hljs-section">else</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">return_value</span></span> = NUSE_NOT_PRESENT; } }</code> </pre><br>  Die erforderlichen Ereignisflags werden aus der angegebenen Ereignisflaggruppe ausgew√§hlt.  Der Wert wird unter Ber√ºcksichtigung der <b>UND / ODER-</b> Operation sowie des zur√ºckgegebenen Ergebnisses und der unmittelbaren Werte der angeforderten Flags mit den erforderlichen Ereignissen verglichen. <br><br>  Wenn die Task-Sperre aktiviert ist, wird der Code komplexer: <br><br><pre> <code class="hljs kotlin"><span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { temp_events = NUSE_Event_Group_Data[group] &amp; requested_events; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (operation == NUSE_OR) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp_events != <span class="hljs-number"><span class="hljs-number">0</span></span>) { return_value = NUSE_SUCCESS; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { return_value = NUSE_NOT_PRESENT; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-comment"><span class="hljs-comment">/* operation == NUSE_AND */</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (temp_events == requested_events) { return_value = NUSE_SUCCESS; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { return_value = NUSE_NOT_PRESENT; } } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (return_value == NUSE_SUCCESS) { <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> = NUSE_NO_SUSPEND; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> == NUSE_SUSPEND) <span class="hljs-comment"><span class="hljs-comment">/* block task */</span></span> { NUSE_Event_Group_Blocking_Count[group]++; NUSE_Suspend_Task(NUSE_Task_Active, (group &lt;&lt; <span class="hljs-number"><span class="hljs-number">4</span></span>) | NUSE_EVENT_SUSPEND); return_value = NUSE_Task_Blocking_Return[NUSE_Task_Active]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (return_value != NUSE_SUCCESS) { <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> = NUSE_NO_SUSPEND; } } } } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> == NUSE_SUSPEND);</code> </pre><br>  Der Code wird in eine <b>do ... while-Schleife</b> <b>eingef√ºgt</b> , die funktioniert, w√§hrend der <b>suspend-</b> Parameter <b>NUSE_SUSPEND lautet</b> . <br><br>  Die angeforderten Ereignisflags werden so gelesen, als w√ºrden sie ohne Blockierung aufgerufen.  Wenn der <b>Lesevorgang</b> nicht erfolgreich ist und der <b>Suspend-</b> Parameter <b>NUSE_NO_SUSPEND lautet</b> , wird der API-Aufruf auf <b>NUSE_NOT_PRESENT gesetzt</b> .  Wenn der <b>Suspend-</b> Parameter auf <b>NUSE_SUSPEND gesetzt wurde</b> , wird die Task <b>angehalten</b> .  Wenn bei der R√ºckkehr (wenn die Aufgabe <b>fortgesetzt</b> wird) der R√ºckgabewert <b>NUSE_SUCCESS</b> lautet und <b>angibt</b> , dass die Aufgabe fortgesetzt wurde, weil die Ereignisflags in dieser Gruppe gesetzt oder gel√∂scht wurden, beginnt der Zyklus von <b>vorne</b> , die Flags werden gelesen und √ºberpr√ºft.  Da es keine API-Funktion zum Zur√ºcksetzen von Ereignisflaggruppen gibt, ist dies der einzige Grund f√ºr die Wiederaufnahme der Aufgabe. Der √úberpr√ºfungsprozess <b>NUSE_Task_Blocking_Return []</b> wurde jedoch auf dem System belassen, um die Kompatibilit√§t der <b>Sperrsteuerung</b> mit anderen <b>Objekttypen zu</b> gew√§hrleisten. <br><br>  Der folgende Artikel beschreibt zus√§tzliche API-Aufrufe, die Ereignisflaggruppen zugeordnet sind, sowie deren Datenstrukturen. <br><br>  <b>√úber den Autor:</b> Colin Walls ist seit √ºber drei√üig Jahren in der Elektronikindustrie t√§tig und widmet sich die meiste Zeit der Firmware.  Heute ist er Firmware-Ingenieur bei Mentor Embedded (einer Abteilung von Mentor Graphics).  Colin Walls spricht h√§ufig auf Konferenzen und Seminaren, Autor zahlreicher technischer Artikel und zweier B√ºcher √ºber Firmware.  Lebt in Gro√übritannien.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Colins</a> professioneller <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Blog</a> , E-Mail: colin_walls@mentor.com. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de428131/">https://habr.com/ru/post/de428131/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de428121/index.html">Stan Drapkin. Hochrangige Kryptografiefallen in .NET</a></li>
<li><a href="../de428123/index.html">Sicherheitswoche 41: Gute Nachrichten</a></li>
<li><a href="../de428125/index.html">Wer sind Produktanalysen und warum werden sie in einem Team ben√∂tigt?</a></li>
<li><a href="../de428127/index.html">Nginx-Cache: alles neu - gut vergessen alt</a></li>
<li><a href="../de428129/index.html">Einfache Fuzzy-Logik ‚Äûf√ºr das, was f√ºr ein Gasturbinentriebwerk war‚Äú</a></li>
<li><a href="../de428133/index.html">Hasura. Hochleistungs-GraphQL-zu-SQL-Server-Architektur</a></li>
<li><a href="../de428135/index.html">So konfigurieren oder deaktivieren Sie Flusen im integrierten Code-Editor</a></li>
<li><a href="../de428137/index.html">Olympiade, Ideenwettbewerb, Vortr√§ge √ºber IT-Projektmanagement und Filmvorf√ºhrungen: 10 bevorstehende Veranstaltungen an der ITMO University</a></li>
<li><a href="../de428141/index.html">Das Backend f√ºr das Frontend oder How Yandex.Market erstellt eine API ohne Kr√ºcken</a></li>
<li><a href="../de428143/index.html">ReactJS RBAC-Implementierungsansatz</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>