<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚂 🧓🏾 🍜 MIT-Kurs "Computer Systems Security". Vorlesung 4: „Privilegien teilen“, Teil 2 👩🏻‍💼 ⚱️ 🛌🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Massachusetts Institute of Technology. Vorlesung # 6.858. "Sicherheit von Computersystemen." Nikolai Zeldovich, James Mickens. 2014 Jahr 
 Computer Sy...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MIT-Kurs "Computer Systems Security". Vorlesung 4: „Privilegien teilen“, Teil 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ua-hosting/blog/418197/"><h3>  Massachusetts Institute of Technology.  Vorlesung # 6.858.  "Sicherheit von Computersystemen."  Nikolai Zeldovich, James Mickens.  2014 Jahr </h3><br>  Computer Systems Security ist ein Kurs zur Entwicklung und Implementierung sicherer Computersysteme.  Die Vorträge behandeln Bedrohungsmodelle, Angriffe, die die Sicherheit gefährden, und Sicherheitstechniken, die auf jüngsten wissenschaftlichen Arbeiten basieren.  Zu den Themen gehören Betriebssystemsicherheit, Funktionen, Informationsflussmanagement, Sprachsicherheit, Netzwerkprotokolle, Hardwaresicherheit und Sicherheit von Webanwendungen. <br><br>  Vorlesung 1: „Einführung: Bedrohungsmodelle“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 2: „Kontrolle von Hackerangriffen“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 3: „Pufferüberläufe: Exploits und Schutz“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <br>  Vorlesung 4: „Trennung von Privilegien“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> / <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> <a name="habracut"></a><br><br>  Was hatten wir sonst noch auf dieser Liste?  Prozesse.  Gedächtnis geschieht gleichzeitig mit dem Prozess.  Wenn Sie sich also nicht in diesem Prozess befinden, können Sie nicht auf den Speicher zugreifen.  Der virtuelle Speicher verbessert diese Isolation für uns perfekt.  Darüber hinaus können Sie mit dem Debugging-Mechanismus in den Speicher eines anderen Prozesses "springen", wenn Sie dieselbe Benutzer-ID haben <br><br>  Als nächstes haben wir das Netzwerk.  Netzwerke in <b>Unix</b> entsprechen nicht ganz dem oben beschriebenen Modell, was teilweise darauf zurückzuführen ist, dass das <b>Unix-</b> Betriebssystem zuerst entwickelt wurde und dann ein Netzwerk erschien, das bald populär wurde.  Es gibt ein etwas anderes Regelwerk.  Daher müssen wir wirklich jemanden mit dem Netzwerk verbinden, wenn Sie das Netzwerk verwalten, oder einen Port abhören, wenn Sie als Server fungieren.  Möglicherweise müssen Sie Daten über diese Verbindung lesen oder schreiben oder Rohpakete senden und empfangen. <br><br><img src="https://habrastorage.org/webt/dw/gn/zv/dwgnzva6txwuj_esllvdnx3uexg.jpeg"><br><br>  Daher sind Netzwerke unter <b>Unix</b> meist nicht mit der <b>Benutzer-ID verbunden</b> .  Die Regeln lauten, dass jeder jederzeit eine Verbindung zu einem Computer oder einer IP-Adresse herstellen oder eine Verbindung herstellen kann.  Wenn Sie einen Port abhören möchten, gibt es in diesem Fall einen Unterschied: Den meisten Benutzern ist es verboten, Ports mit einer Zahl unter dem „magischen Wert“ von 1024 abzuhören. Grundsätzlich können Sie solche Ports abhören, in diesem Fall sollten Sie dies jedoch tun Sei ein spezieller Benutzer namens <b>"Super User"</b> mit <b>uid = 0</b> . <br><br>  Im Allgemeinen gibt es unter Unix das Konzept des Administrators oder Superusers, der durch die Kennung uid = 0 dargestellt wird und fast alle diese Überprüfungen umgehen kann. Wenn Sie also mit Root-Rechten arbeiten, können Sie Dateien lesen und schreiben und die Zugriffsrechte darauf ändern.  Das Betriebssystem ermöglicht Ihnen dies, da es der Meinung ist, dass Sie alle Berechtigungen haben sollten.  Und Sie brauchen wirklich solche Privilegien, um Ports mit der Nummer &lt;1024 abzuhören. Was halten Sie von einer so seltsamen Einschränkung? <br><br>  <b>Zielgruppe:</b> Es identifiziert bestimmte Portnummern für bestimmte Verbindungen, z. B. für <b>http</b> an Port 80. <br><br>  <b>Professor:</b> Ja, standardmäßig verwendet das <b>HTTP-Protokoll</b> Port 80. Andererseits können andere Dienste Ports mit einer Nummer über 1024 verwenden. Warum ist diese Einschränkung erforderlich?  Was nützt das hier? <br><br>  <b>Zielgruppe:</b> Sie möchten nicht, dass jemand versehentlich auf Ihr <b>HTTP</b> hört. <br><br>  <b>Professor:</b> Ja.  Ich denke, der Grund dafür ist, dass Sie früher viele Benutzer auf demselben Computer hatten.  Sie haben sich mit ihren Anmeldungen angemeldet und ihre Anwendungen gestartet. Sie wollten also sicherstellen, dass ein zufälliger Benutzer, der sich am Computer angemeldet hat, nicht auf den darauf laufenden Webserver zugreifen kann.  Da Benutzer, die von außen eine Verbindung herstellen, nicht wissen, wer an diesem Port arbeitet, und nur eine Verbindung zu Port 80 herstellen. Wenn ich diesen Computer betreten und meinen eigenen Webserver starten möchte, übertrage ich einfach den gesamten Webserververkehr an dieses Auto.  Dies ist wahrscheinlich kein sehr guter Plan, aber auf diese Weise verhindert das Unix-Netzwerksubsystem, dass zufällige Benutzer bekannte Dienste steuern, die auf diesen niedrigen Portnummern ausgeführt werden.  Das ist der Grund für eine solche Einschränkung. <br><br><img src="https://habrastorage.org/webt/ba/0o/qn/ba0oqn2qgabud4-_hmizsks086s.jpeg"><br><br>  Wenn Sie unter dem Gesichtspunkt des Lesens und Schreibens von Verbindungsdaten eine Deskriptordatei für einen bestimmten Socket haben, können Sie mit <b>Unix</b> alle Daten in dieser <b>TCP-</b> oder <b>uTP-Verbindung</b> lesen und schreiben.  Beim Senden <b>von</b> Rohpaketen verhält sich <b>Unix</b> wie ein Paranoiker, sodass Sie keine beliebigen Pakete über das Netzwerk senden können.  Dies sollte im Kontext der speziellen Verbindung erfolgen, es sei denn, Sie haben <b>root - das</b> Recht und können tun, was Sie wollen. <br><br>  Eine interessante Frage, die Sie sich stellen könnten, ist, woher all diese <b>Benutzer-IDs</b> stammen. <br><br>  Wir sprechen über Prozesse mit <b>Benutzer-</b> oder <b>Gruppen-</b> <b>ID</b> .  Wenn Sie <b>PS</b> auf Ihrem Computer starten, werden Sie definitiv eine Reihe von Prozessen mit unterschiedlichen <b>UID-</b> Werten sehen.  Woher kamen sie? <br><br>  Wir benötigen einen Mechanismus, um alle diese <b>Benutzer-ID-</b> Werte zu laden.  <b>Unix</b> verfügt über mehrere Systemaufrufe, die dafür ausgelegt sind.  Um diese Bezeichnerwerte zu <b>booten</b> , gibt es daher eine Funktion namens <b>setuid (uid)</b> , sodass Sie diesem Wert die <b>UID-</b> Nummer eines aktuellen Prozesses zuweisen können.  Dies ist tatsächlich eine gefährliche Operation, wie alles andere in der <b>Unix-</b> Tradition, da Sie dies nur tun können, wenn Ihre <b>UID = 0 ist</b> .  In jedem Fall sollte es so sein. <br><br>  Wenn Sie also ein Benutzer mit Root-Rechten sind und <b>uid = 0 haben</b> , können Sie <b>setuid (uid) aufrufen</b> und den Benutzer zu einem beliebigen Prozess wechseln.  Es gibt einige ähnliche Systemaufrufe zum Initialisieren prozessbezogener <b>GIDs</b> : <b>Setgid</b> und <b>Setgroups</b> .  Daher können Sie mit diesen Systemaufrufen Prozessberechtigungen konfigurieren. <br><br><img src="https://habrastorage.org/webt/qs/6m/bk/qs6mbkc520bn-n_vlpznivx1z0q.jpeg"><br><br>  Die Tatsache, dass Ihre Prozesse die richtigen Zugriffsrechte erhalten, wenn Sie sich am <b>Unix-</b> Computer anmelden, tritt nicht auf, weil Sie dieselbe <b>ID</b> wie die Prozesse haben, weil das System noch nicht weiß, wer Sie sind.  Stattdessen gibt es unter <b>Unix</b> eine Art Anmeldeverfahren, wenn das <b>SSH</b> Secure Shell- <b>Protokoll</b> den Prozess für jeden startet, der eine Verbindung zum Computer herstellt und versucht, den Benutzer zu authentifizieren. <br><br>  Daher beginnt dieser Anmeldevorgang zunächst mit <b>uid = 0</b> wie für einen Benutzer mit Root-Rechten. Wenn er einen bestimmten Benutzernamen und ein bestimmtes Kennwort erhält, überprüft er diese in seiner eigenen Kontodatenbank.  Unter <b>Unix werden</b> diese Daten in der Regel in zwei Dateien gespeichert: <b>/ etc / password</b> (aus historischen Gründen werden Kennwörter nicht mehr in dieser Datei gespeichert) und in der Datei <b>/ etc / shadow</b> , in der Kennwörter gespeichert sind.  In der Datei <b>/ etc / password</b> befindet sich jedoch eine Tabelle, in der jeder Benutzername im System als ganzzahliger Wert angezeigt wird. <br><br>  Daher wird Ihr Benutzername einer bestimmten Ganzzahl in dieser <b>/ etc / password-</b> Datei zugeordnet, und der Anmeldevorgang prüft, ob Ihr Passwort gemäß dieser Datei korrekt ist.  Wenn es Ihre ganzzahlige <b>UID findet</b> , setzt es die <b>Setuid-</b> Funktionen auf diesen <b>UID-</b> Wert und startet die Shell mit dem Befehl <b>exec (/ bin / sh)</b> .  Jetzt können Sie mit der Shell interagieren, diese funktioniert jedoch unter Ihrer <b>UID</b> , sodass Sie diese Maschine nicht versehentlich beschädigen können. <br><br><img src="https://habrastorage.org/webt/oa/vi/t8/oavit8bjjn_skjz8-n1k5dhc6co.jpeg"><br><br>  <b>Zielgruppe:</b> <b>Ist</b> es möglich, einen neuen Prozess mit <b>uid = 0</b> zu starten, wenn Ihre <b>uid</b> nicht wirklich 0 ist? <br><br>  <b>Professor:</b> Wenn Sie Root-Rechte haben, können Sie sich auf eine andere <b>UID beschränken</b> , Ihre Autorität <b>verringern</b> , aber in jedem Fall können Sie einen Prozess mit nur derselben <b>UID</b> wie Ihrer erstellen.  Es kommt jedoch vor, dass Sie aus verschiedenen Gründen Ihre Berechtigungen erhöhen möchten.  Angenommen, Sie müssen ein Paket installieren, für das Sie <b>Root-</b> Rechte benötigen. <br><br>  Es gibt zwei Möglichkeiten, Berechtigungen für <b>Unix festzulegen</b> .  Eine, die wir bereits erwähnt haben, ist ein Dateideskriptor.  Wenn Sie also Ihre Berechtigungen wirklich erhöhen möchten, können Sie mit jemandem sprechen, der unter Root-Rechten arbeitet, und ihn bitten, diese Datei für Sie zu öffnen.  Oder Sie müssen eine neue Schnittstelle installieren, dann öffnet dieser Assistent eine Datei für Sie und gibt Ihnen mithilfe der <b>fd-</b> Übertragung einen Dateideskriptor zurück.  Dies ist eine Möglichkeit, Ihre Berechtigungen zu erhöhen, ist jedoch unpraktisch, da in einigen Fällen Prozesse mit einer großen Anzahl von Berechtigungen ausgeführt werden.  Dafür verfügt <b>Unix</b> über einen intelligenten, aber gleichzeitig problematischen Mechanismus namens <b>"setuid binaries"</b> .  Dieser Mechanismus ist eine reguläre ausführbare Datei in einem <b>Unix-</b> Dateisystem, es sei denn, Sie führen <b>exec</b> auf der <b>setuid-</b> Binärdatei aus, z. B. <b>/ bin / su</b> auf den meisten Computern oder <b>sudo</b> beim Start. <br><br>  Ein typisches <b>Unix-</b> System verfügt über eine Reihe von <b>Setuid-</b> Binärdateien.  Der Unterschied besteht darin, dass beim Ausführen einer dieser Binärdateien die <b>Benutzer-ID des</b> Prozesses tatsächlich auf den Eigentümer dieser Binärdatei umgeschaltet wird.  Dieser Mechanismus scheint seltsam, wenn Sie ihn zum ersten Mal sehen.  In der Regel besteht die Möglichkeit darin, dass diese "Binärdatei" höchstwahrscheinlich eine Eigentümer- <b>UID von</b> 0 hat, da Sie wirklich viele Berechtigungen wiederherstellen möchten. <br><br><img src="https://habrastorage.org/webt/zt/s5/8d/zts58db83nchnbo1a6qqobpbpuw.jpeg"><br><br>  Sie möchten die Superuser-Rechte wiederherstellen, damit Sie diesen Befehl <b>su</b> ausführen können, und der Kernel schaltet beim Ausführen dieser Binärdatei die Prozess- <b>UID</b> auf 0, sodass dieses Programm nun einige privilegierte <b>Aktionen</b> ausführt. <br><br>  <b>Zielgruppe:</b> Wenn Sie <b>uid = 0 haben</b> und die <b>uid</b> all dieser <b>setuid-</b> Binärdateien auf etwas anderes als 0 ändern, können Sie Ihre Berechtigungen wiederherstellen? <br><br>  <b>Professor:</b> Nein, viele Prozesse können beim Verringern der Zugriffsebene keine Berechtigungen wiederherstellen, sodass Sie möglicherweise an dieser Stelle stecken bleiben.  Dieser Mechanismus ist nicht an <b>uid = 0</b> gebunden.  Wie jeder Benutzer eines <b>Unix-</b> Systems können Sie eine beliebige Binärdatei erstellen, ein Programm erstellen, kompilieren und dieses <b>Setuid-</b> Bit auf das Programm selbst setzen.  Es gehört Ihnen, dem Benutzer, Ihrer Benutzer-ID.  Und das bedeutet, dass jeder, der Ihr Programm ausführt, diesen Code mit Ihrer Benutzer-ID ausführt.  Gibt es ein Problem damit?  Was muss getan werden? <br><br>  <b>Zielgruppe:</b> Wenn also ein Fehler in Ihrer Bewerbung aufgetreten ist, kann jemand etwas damit anfangen und mit Ihren Privilegien handeln? <br><br>  <b>Professor:</b> Richtig, es passiert, wenn meine Anwendung "fehlerhaft" ist oder wenn Sie damit alles ausführen können, was Sie wollen.  Angenommen, ich könnte die System-Shell kopieren und für mich <b>setuid</b> machen, aber dann kann jeder diese Shell unter meinem Konto ausführen.  Dies ist wahrscheinlich nicht der beste Aktionsplan.  Ein solcher Mechanismus verursacht jedoch kein Problem, da die einzige Person, die das <b>setuid-</b> Bit für eine Binärdatei setzen kann, der Eigentümer dieser Datei ist.  Sie als Eigentümer der Datei haben das <b>UID-</b> Privileg, sodass Sie Ihr Konto auf eine andere Person übertragen können. Diese andere Person kann die <b>setuid-</b> Binärdatei jedoch nicht mit Ihrer <b>Benutzer-ID</b> erstellen. <br><br>  Dieses Setuid-Bit wird neben diesen Berechtigungsbits gespeichert, <b>dh</b> in jedem <b>Inode</b> befindet sich auch ein <b>Setuid-</b> Bit, das <b>angibt</b> , ob diese ausführbare Datei während der Ausführung auf die Eigentümer- <b>UID</b> umgeschaltet werden soll oder nicht. <br><br><img src="https://habrastorage.org/webt/4d/o0/cf/4do0cfauri7y6g94omunnrdyv14.jpeg"><br><br>  Es stellt sich heraus, dass dies bei korrekter Verwendung ein sehr kniffliger Mechanismus ist, und dank dessen implementiert der Kernel das Programm korrekt.  Dies ist eigentlich recht einfach, da nur eine Prüfung durchgeführt wird: Wenn dieses <b>Setuid-</b> Bit vorhanden ist, wechselt der Prozess zu <b>UID</b> .  Es ist ziemlich einfach. <br><br>  Die sichere Verwendung ist jedoch recht schwierig, da Sie, wie bereits erwähnt, unter <b>uid = 0</b> oder unter einer anderen <b>uid</b> beliebige <b>Aktionen ausführen können</b> , wenn dieses Programm Fehler enthält oder unerwartete <b>Aktionen</b> <b>ausführt</b> .  Unter <b>Unix</b> erben Sie beim Ausführen eines Programms viele Dinge von Ihrem übergeordneten Prozess. <br><br>  Beispielsweise können Sie Umgebungsvariablen an <b>setuid-</b> Binärdateien übergeben.  Tatsache ist, dass Sie unter <b>Unix</b> angeben können, welche gemeinsam genutzte Bibliothek für den Prozess verwendet werden soll, indem Sie die Umgebungsvariable festlegen. <b>Setuid-</b> Binärdateien kümmern sich nicht um das Filtern dieser Umgebungsvariablen. <br><br>  Sie können beispielsweise <b>bin / su</b> ausführen, aber gemeinsam genutzte Bibliotheken für die Funktion <b>printf</b> verwenden, sodass Ihre <b>printf</b> startet, wenn <b>bin / su</b> etwas druckt, und Sie können die Shell anstelle von <b>printf</b> ausführen. <br><br>  Es gibt viele Feinheiten, die Sie in Bezug auf das Misstrauen des Programms gegenüber den vom Benutzer eingegebenen Daten richtig verstehen müssen.  Da Sie normalerweise Benutzereingaben vertrauen, war <b>setuid</b> nie der sicherste Teil eines gesamten <b>Unix-</b> Systems.  Haben Sie Fragen dazu? <br><br>  <b>Zielgruppe:</b> <b>Gilt setuid</b> auch für Gruppen oder nur für den Benutzer? <br><br>  <b>Professor:</b> Es gibt ein <b>Setgid-</b> Bit, das symmetrisch zum <b>Setuid-</b> Bit ist und das Sie auch setzen können.  Wenn die Datei eine bestimmte <b>GID hat</b> und dieses <b>Setgid-</b> Bit beim <b>Starten</b> des Programms gesetzt ist, erhalten Sie es. <br><br>  <b>Setgid wird</b> nicht besonders verwendet, kann jedoch in Fällen nützlich sein, in denen Sie ganz bestimmte Berechtigungen bereitstellen möchten.  Zum Beispiel benötigt <b>bin / su</b> wahrscheinlich viele Berechtigungen, aber vielleicht gibt es ein Programm, das einige zusätzliche Berechtigungen benötigt, um beispielsweise etwas in eine spezielle Protokolldatei zu schreiben.  Daher möchten Sie ihr wahrscheinlich eine bestimmte Gruppe zur Verfügung stellen und eine Protokolldatei für sie erstellen, die von dieser Gruppe geschrieben werden kann.  Selbst wenn das Programm "fehlerhaft" ist, verlieren Sie nichts anderes als diese Gruppe.  Dies ist nützlich als Mechanismus, der aus irgendeinem Grund nicht zu oft verwendet wird, da die Benutzer schließlich mehr Root-Rechte verwenden sollten. <br><br>  <b>Zielgruppe:</b> Gibt es Einschränkungen, wer den Zugriff ändern kann? <br><br>  <b>Professor:</b> Ja.  Unterschiedliche <b>Unix-</b> Implementierungen haben hierfür unterschiedliche Prüfungen.  Die allgemeine Regel lautet, dass nur root den Eigentümer der Datei ändern kann, da Sie keine Dateien erstellen möchten, die jemand anderem gehören, und natürlich nicht die Dateien anderer Personen verwenden möchten.  Wenn Ihre <b>UID also</b> nicht 0 ist, stecken Sie fest.  Sie können den Besitz einer Datei nicht ändern.  Wenn Ihre <b>UID = 0 ist</b> , haben Sie Root-Rechte und können den Eigentümer in einen beliebigen ändern.  Es gibt einige Komplikationen, wenn Sie eine binäre <b>Setuid haben</b> und von einer <b>UID</b> zu einer anderen wechseln. Dies ist ziemlich schwierig, aber im Grunde können Sie den Dateibesitzer nicht grundsätzlich ändern, wenn Sie keine Root-Rechte haben. <br><br>  In jedem Fall ist dies ein leicht veraltetes System.  Sie können sich wahrscheinlich viele Möglichkeiten vorstellen, die oben beschriebenen Prozesse zu vereinfachen, aber tatsächlich sehen die meisten fortschrittlichen Systeme so aus, weil sie sich im Laufe der Zeit weiterentwickeln.  Sie können diese Mechanismen jedoch perfekt als "Sandbox" verwenden. <br><br>  Dies sind nur einige grundlegende <b>Unix-</b> Prinzipien, die in fast jedem Unix-ähnlichen Betriebssystem vorkommen: <b>Mac OS X</b> , <b>Linux</b> , <b>FreeBSD</b> , <b>Solaris</b> , wenn jemand anderes sie verwendet, und so weiter.  Jedes dieser Systeme verfügt jedoch über ausgefeiltere Mechanismen, die Sie verwenden können.  Unter <b>Linux</b> gibt es beispielsweise ein "Sandbox" <b>-Set COMP</b> , <b>Mac OS X</b> verwendet den "Sandbox" <b>-Sicherheitsgurt</b> .  Nächste Woche werde ich Ihnen Beispiele für <b>Sandboxen</b> geben, die auf jedem <b>Unix-</b> basierten System verfügbar sind. <br><br>  Einer der letzten Mechanismen, die wir vor dem <b>Eintauchen</b> in <b>OKWS berücksichtigen werden</b> , erklärt, wie Sie mit <b>Setuid-</b> Binärdateien umgehen müssen, und zeigt, wie Sie sich vor vorhandenen Sicherheitslücken schützen können.  Das Problem ist, dass Sie zwangsläufig einige <b>Setuid-</b> Binärdateien auf Ihrem System haben, wie z. B. <b>/ bin / su</b> oder <b>sudo</b> oder etwas anderes, und es ist wahrscheinlich, dass Ihre Programme Fehler aufweisen.  Aus diesem Grund kann jemand die <b>setuid-</b> Binärdatei ausführen und der Prozess kann <b>Root-</b> Zugriff erhalten, den Sie nicht zulassen möchten. <br><br><img src="https://habrastorage.org/webt/gy/nt/aa/gyntaadl0kgyfcku6ncq8v334kg.jpeg"><br><br>  Der <b>Unix-</b> Mechanismus, der häufig verwendet wird, um die Ausführung eines potenziell böswilligen Prozesses mithilfe von <b>Setuid-</b> Binärdateien zu verhindern, besteht darin, ihn mithilfe des Dateisystem-Namespace mithilfe des <b>Chroot-</b> Systemaufrufs zu ändern. Dabei wird das Stammverzeichnis geändert.  <b>OKWS</b> als Webserver, der sich auf die Erstellung schneller und sicherer Webdienste spezialisiert hat, nutzt dies in großem <b>Umfang</b> . <br><br><img src="https://habrastorage.org/webt/m3/x1/xr/m3x1xrg_tmht2b2l8rwd8kzzy7s.jpeg"><br><br>  Unter <b>Unix können</b> Sie <b>chroot also</b> in einem bestimmten Verzeichnis ausführen. Vielleicht können Sie auch <b>chroot ("/ foo")</b> ausführen. <br><br>  Es gibt 2 Erklärungen dafür, was <b>Chroot</b> macht.  Das erste ist nur intuitiv, <b>dh</b> nach dem Ausführen von <b>chroot entspricht</b> das Stammverzeichnis oder das Verzeichnis hinter dem Schrägstrich im Wesentlichen dem, was <b>/ foo verwendet hat,</b> bevor Sie <b>chroot</b> aufgerufen haben.  Es sieht so aus, als würde der Namespace unter Ihrem <b>/ foo eingeschränkt</b> .  Wenn Sie also eine Datei haben, die früher <b>/ foo / x genannt</b> wurde <b>,</b> können Sie diese Datei nach dem Aufruf von <b>chroot</b> einfach durch Öffnen von <b>/ x abrufen</b> .  Beschränken Sie Ihren Namespace also einfach auf ein Unterverzeichnis.  Hier ist die intuitive Version. <br><br><img src="https://habrastorage.org/webt/2w/58/wf/2w58wflgecku62k-urraxwggxcc.jpeg"><br><br>  Aus Sicherheitsgründen ist natürlich nicht die intuitive Version von Bedeutung, aber was genau macht der Kernel mit diesem Systemaufruf?  Und es macht im Grunde zwei Dinge.  Erstens ändert sich der Wert dieses Schrägstrichs. Wenn Sie also auf den Verzeichnisnamen zugreifen oder ihn mit einem Schrägstrich beginnen, enthält der Kernel alle Dateien, die Sie mit <b>Chroot-</b> Operationen bereitgestellt haben.  In unserem Beispiel ist dies die Datei <b>/ foo,</b> bevor Sie <b>chroot</b> aufgerufen haben, <b>dh</b> wir erhalten diese <b>/ = / foo</b> . <br><br><img src="https://habrastorage.org/webt/gn/yx/-t/gnyx-tksd5brn4avys0dhppaw6c.jpeg"><br><br>  Das nächste, was der Kernel versuchen wird, ist, Sie <b>davor zu</b> schützen, aus Ihrem <b>/</b> "entkommen" zu können, wenn Sie dies tun <b>/../</b> .  Denn unter <b>Unix</b> könnte ich Sie bitten, mir zum Beispiel <b>/../etc/password zu geben</b> .  Wenn ich diese Zeile also wie <b>folgt</b> ergänzen würde: <b>/foo/../etc/password</b> , wäre das nicht gut, da ich einfach <b>/ foo beenden</b> und <b>/ etc / password</b> <b>abrufen</b> könnte. <br><br>  Das zweite, was der Kernel mit einem <b>Unix-</b> Systemaufruf macht, ist, dass wenn Sie <b>chroot</b> für diesen bestimmten Prozess aufrufen, sich die Art und Weise ändert, wie <b>/../</b> in diesem Verzeichnis ausgewertet wird.  Daher ändert es <b>/../</b> so, dass <b>/ foo</b> auf sich selbst zeigt.  Auf diese Weise können Sie nicht „entkommen“, und diese Änderung gilt nur für diesen Prozess und wirkt sich nicht auf den Rest aus.  Welche Ideen haben Sie, wie Sie mit ihrer Implementierung aus der <b>Chroot-</b> Umgebung „entkommen“ können? <br><br>  Interessanterweise überwacht der Kernel nur ein <b>Chroot-</b> Verzeichnis, sodass Sie wahrscheinlich die Operation <b>chroot = (/ foo)</b> ausführen könnten, aber Sie würden an dieser Stelle <b>hängen</b> bleiben.  Sie möchten <b>/ etc / password erhalten</b> , aber wie geht das?  Sie können das Stammverzeichnis jetzt <b>öffnen,</b> indem Sie <b>open (* / *)</b> eingeben.  Dadurch erhalten Sie einen Dateideskriptor, der beschreibt, was <b>/ foo ist</b> .  Dann können Sie <b>chroot</b> erneut aufrufen und <b>chroot (`/ bar)</b> ausführen. <br><br><img src="https://habrastorage.org/webt/er/ce/o6/erceo6xadygvj95nuy8fj-zn1bi.jpeg"><br><br> ,    : <b>root</b>   <b>/foo</b> ,  <b>/foo/bar</b>   <b>/../</b>     <b>/foo / bar/..</b> <br><br><img src="https://habrastorage.org/webt/gi/vb/zy/givbzygict7u1xirzzwneycl3sw.jpeg"><br><br>  ,          <b>/foo</b> .            <b>fchdir (fd)</b>     <b>(*/*)</b> ,      <b>chdir (..)</b> . <br><br><img src="https://habrastorage.org/webt/lb/qz/mx/lbqzmxnz8308avfwfyaxxprq7d8.jpeg"><br><br><img src="https://habrastorage.org/webt/gu/cn/kd/gucnkdez6q9ntda3zwtotnc4igg.jpeg"><br><br>       <b>/foo</b> ,     <b>/../</b> .     <b>/foo</b>        ,       <b>root</b> ,       . <br><br> ,    ,       .       .   <b>Unix</b>    root-   <b>chroot</b> ,  <b>chroot</b>     .  ,  <b>Unix</b>    <b>uid = 0</b>  ,      <b>chroot</b> .   .           ,         ,    <b>chroot</b> ,   <b>userid</b>   .   ,     <b>Unix</b> ,     ,    <b>root</b> ,    . <br><br>       ,  , ,     .      <b>chroot</b>       —      .    . <br><br> <b>:</b>  ,       <b>inod</b> ,      ? <br><br> <b>:</b>    !              ,  , , : «   <b>inode</b>  23»,      -        <b>hroot</b> .  ,  <b>Unix</b>     <b>inode</b>   <b>inode</b> ,  , ,   root-. <br><br>  ,      ,  ,   <b>OKWS</b> .  ,      <b>OKWS</b> . <br><br>  ,     -,   ,      -  ,      .          , , <b>httpd</b> , ,  <b>Apache</b> . <br><br>        <b>userid</b>   <b>www</b>  <b>/etc/password</b> .     ,   ,     <b>SSL</b> ,      <b>PHP</b>   ,        .   ,       , , <b>MySQL</b> ,           .    <b>MySQL</b>     .      <b>MySQL</b> , , ,      . <br><br><img src="https://habrastorage.org/webt/sx/tx/gd/sxtxgdpf7q9jr3q_tfxyzi6zgdc.jpeg"><br><br> ,  ,    ,    <b>MySQL</b>    ,        ,             . <br><br>         ,       ,  ,         ,   .    ,      , ,     <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apache</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder in </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SSL</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> oder vielleicht im Anwendungscode oder im </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PHP-</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Interpreter </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Und da es Fehler gibt, können Sie sie verwenden, um den gesamten Inhalt der Anwendung abzurufen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">52:30 min </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fortsetzung:</font></font><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MIT-Kurs "Computer Systems Security".</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vorlesung 4: „Privilegien teilen“, Teil 2</font></font></a> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/dNl22h1kW1k" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Vollversion des Kurses finden Sie </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hier</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br>  Vielen Dank für Ihren Aufenthalt bei uns.  Gefällt dir unser Artikel?  Möchten Sie weitere interessante Materialien sehen?  Unterstützen Sie uns, indem Sie eine Bestellung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">aufgeben</a> oder sie Ihren Freunden empfehlen. <b>Habr-Benutzer erhalten 30% Rabatt auf ein einzigartiges Analogon von Einstiegsservern, das wir für Sie erfunden haben:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die ganze Wahrheit über VPS (KVM) E5-2650 v4 (6 Kerne) 10 GB DDR4 240 GB SSD 1 Gbit / s $ 20 oder wie teilt man den Server?</a>  (Optionen sind mit RAID1 und RAID10, bis zu 24 Kernen und bis zu 40 GB DDR4 verfügbar). <br><br>  <b>Dell R730xd 2 mal günstiger?</b>  Nur wir haben <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">2 x Intel Dodeca-Core Xeon E5-2650v4 128 GB DDR4 6 x 480 GB SSD 1 Gbit / s 100 TV von 249 US-Dollar</a> in den Niederlanden und den USA!</b>  Lesen Sie mehr über <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Aufbau eines Infrastrukturgebäudes.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Klasse mit Dell R730xd E5-2650 v4 Servern für 9.000 Euro für einen Cent?</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418197/">https://habr.com/ru/post/de418197/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418187/index.html">In Amerika wurde vorgeschlagen, alle Bibliotheken durch Amazon-Hubs zu ersetzen. Die Öffentlichkeit ist empört</a></li>
<li><a href="../de418189/index.html">Erbe des Zeus: Warum der IcedID-Trojaner für Bankkunden gefährlich ist</a></li>
<li><a href="../de418191/index.html">Analoge in Python und JavaScript. Teil drei</a></li>
<li><a href="../de418193/index.html">Wie fühlt es sich an, 2017 ein Spiel für Game Boy zu erstellen?</a></li>
<li><a href="../de418195/index.html">MIT-Kurs "Computer Systems Security". Vorlesung 4: „Privilegien teilen“, Teil 1</a></li>
<li><a href="../de418199/index.html">Wie man eine einfache technische Aufgabe macht und nicht Geld und Nerven verliert</a></li>
<li><a href="../de418201/index.html">Können wir Duck Hunt wiederbeleben?</a></li>
<li><a href="../de418203/index.html">GraphQL API (CRUD) für unterwegs</a></li>
<li><a href="../de418205/index.html">Space Language Vol. 2: Willkommen, GJ273b</a></li>
<li><a href="../de418207/index.html">Überprüfung der Gaming-Laptops ASUS ROG Strix GL504GS SCAR II und ASUS ROG Strix GL504GM HERO II</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>