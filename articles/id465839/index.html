<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ¤˜ğŸ¿ ğŸ”Œ ğŸ‘¶ğŸ» Semua yang Perlu Anda Ketahui Tentang CSS Margin ğŸ¤° ğŸ‘©ğŸ¾ ğŸ¥¡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Salah satu hal pertama yang banyak dari kita pelajari ketika kita belajar CSS adalah fitur dari berbagai elemen blok di CSS, digambarkan sebagai "Mode...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Semua yang Perlu Anda Ketahui Tentang CSS Margin</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465839/"> Salah satu hal pertama yang banyak dari kita pelajari ketika kita belajar CSS adalah fitur dari berbagai elemen blok di CSS, digambarkan sebagai "Model Blok CSS".  Salah satu elemen dalam model blok adalah margin (margin luar), area transparan di sekitar blok yang mengusir elemen lain dari isi blok ini.  Properti <code>margin-top</code> , <code>margin-right</code> , <code>margin-bottom</code> dan <code>margin-left</code> digambarkan sedini CSS1, bersama dengan properti margin yang disingkat untuk pengaturan simultan di keempat properti. <br><br>  Margin tampaknya cukup mudah, namun, dalam artikel ini kita akan melihat beberapa poin yang orang temukan ketika menggunakannya.  Secara khusus, bagaimana margin berinteraksi satu sama lain dan bagaimana jatuhnya margin luar benar-benar bekerja. <br><a name="habracut"></a><br><hr><br><h2>  Model blok CSS </h2><br>  Seperti semua artikel tentang komponen Model Blok CSS CSS, kita harus menentukan apa yang kita maksudkan dengan ini dan bagaimana model itu diklasifikasikan dalam berbagai versi CSS.  Model blok mengacu pada bagaimana komponen yang berbeda dari blok - konten (pad), padding (bantalan), perbatasan (bingkai) dan margin (bantalan) -ditempatkan dan berinteraksi satu sama lain.  Dalam CSS1, model blok digambarkan menggunakan diagram ASCII yang ditunjukkan pada gambar di bawah ini. <br><img src="https://habrastorage.org/webt/kz/y0/gy/kzy0gyiegyv8r-cjmfcxnksats8.jpeg"><br>  Keempat properti untuk setiap sisi blok dan properti margin disingkat didefinisikan dalam CSS1. <br><br>  Spesifikasi CSS2.1 memiliki ilustrasi untuk menunjukkan model blok dan juga mendefinisikan istilah yang kami terus gunakan untuk menggambarkan blok yang berbeda.  Spesifikasi tersebut menguraikan kotak konten, kotak bantalan, kotak batas, dan kotak margin, yang masing-masing ditentukan oleh batas konten, bantalan, batas, dan margin. <br><br><img src="https://habrastorage.org/webt/ay/gd/-d/aygd-dqsahkl-ctmivtbuajno_e.jpeg"><br><br>  Saat ini ada spesifikasi untuk versi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Block Model 3</a> sebagai konsep kerja.  Saat mendefinisikan Model Blok dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">margin</a> , ia mengembalikan kita ke CSS2, jadi di seluruh artikel kita akan menggunakan definisi dari CSS2. <br><br><h2>  Ciutkan margin </h2><br>  Spesifikasi CSS1 tidak hanya menentukan margin, tetapi juga keruntuhannya.  Perilaku ini telah menjadi sumber banyak kekecewaan.  Runtuh margin masuk akal ketika Anda mempertimbangkan bahwa pada masa itu, CSS digunakan sebagai bahasa markup untuk dokumen teks.  Collapsing margin berarti bahwa ketika heading dengan margin yang lebih rendah diikuti oleh paragraf yang memiliki margin atas, kedua indentasi ini tidak bertambah, sehingga menciptakan celah besar di antara elemen-elemen tersebut. <br><br>  Ketika dua margin runtuh, ruang antara elemen menjadi sama dengan yang lebih besar dari dua indentasi.  Lekukan yang lebih kecil benar-benar berakhir di dalam yang lebih besar <br><br>  Keruntuhan margin dalam situasi berikut: <br><br><ul><li>  Saudara yang berdekatan (orang tua tunggal) </li><li>  Blok kosong </li><li>  Induk dan anak pertama / terakhir </li></ul><br><h3>  Elemen Keperawatan yang Berdekatan </h3><br>  Saya akan memulai deskripsi dengan menunjukkan bagaimana margin runtuh antara saudara kandung yang berdekatan.  Kecuali seperti yang disebutkan di bawah ini, jika Anda memiliki dua elemen ditampilkan satu per satu di aliran normal, margin bawah elemen pertama akan runtuh dengan margin atas elemen berikutnya. <br><br>  Dalam contoh CodePen di bawah ini, ada tiga elemen <code>div</code> .  Untuk elemen pertama, margin atas dan bawah adalah 50px, untuk yang kedua - 20px, untuk yang ketiga - 3em.  Margin antara dua elemen pertama adalah 50px, karena margin yang lebih rendah dari elemen yang lebih rendah diserap oleh margin yang lebih tinggi dari elemen atas.  Margin antara dua elemen kedua adalah 3em, karena 3em lebih besar dari 20 piksel pada margin yang lebih rendah dari elemen kedua. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/rachelandrew/embed/preview/OevMPo" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3>  Blok kosong </h3><br>  Jika blok kosong, margin atas dan bawahnya bisa saling runtuh.  Dalam contoh CodePen berikut, elemen kedua dengan kelas <code>empty</code> (tidak terlihat, karena kosong) memiliki margin atas dan bawah 50px, namun, ruang antara elemen pertama dan ketiga bukan 100 piksel, tetapi 50. Ini adalah hasil dari keruntuhan dua margin. <br><br>  Menambahkan sesuatu ke blok (bahkan padding) akan menyebabkan margin atas dan bawah digunakan, tidak runtuh. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/rachelandrew/embed/preview/JQLGMr" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h3>  Induk dan anak pertama / terakhir </h3><br>  Skenario keruntuhan margin ini membingungkan orang lebih sering daripada yang lain, karena tidak intuitif.  Di CodePen berikutnya, kita memiliki <code>div</code> dengan <code>wrapper</code> kelas (wrapper), dan saya mengatur <code>div</code> ini <code>div</code> properti <code>outline</code> merah, sehingga batas-batasnya dapat dilihat.  Ketiga anak memiliki margin 50 piksel.  Namun, elemen pertama dan terakhir berdekatan dengan batas elemen wrapper;  tidak ada lekukan 50 piksel antara elemen dan pembungkus. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/rachelandrew/embed/preview/BgrKGp" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Ini karena margin anak runtuh dengan margin orangtua sedemikian rupa sehingga berakhir di luar orangtua.  Anda dapat melihat ini jika Anda menguji anak menggunakan panel browser pengembang.  Area yang disorot dengan warna kuning adalah margin. <br><br><img src="https://habrastorage.org/webt/_5/tz/-t/_5tz-tnvcus6rog4a6uhqatlw7m.jpeg"><br><br><h2>  Ciutkan hanya margin </h2><br>  Contoh terakhir juga menyoroti sesuatu tentang collapsing margin.  Dalam CSS2, hanya margin vertikal (atas dan bawah) yang dirancang untuk runtuh.  Oleh karena itu, dalam contoh di atas, margin di kiri dan kanan tidak runtuh dan berakhir di dalam pembungkus. <br><br>  Catatan: Perlu diingat bahwa margin runtuh hanya ke arah blok, misalnya antara paragraf. <br><br><h2>  Pencegahan keruntuhan </h2><br>  Margin tidak runtuh jika elemen diatur ke posisi absolut atau properti <code>float</code> .  Namun, jika Anda berada dalam situasi di mana margin runtuh, bagaimana ini bisa dicegah? <br><br>  Runtuh margin tidak terjadi dalam situasi ketika ada sesuatu di antaranya. <br><br>  Misalnya, margin atas dan bawah dari blok kosong tidak runtuh jika blok diatur ke perbatasan atau padding.  Pada contoh di bawah ini, saya menambahkan blok padding 1px.  Sekarang di bagian atas dan bawah blok ada margin 50px. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/rachelandrew/embed/preview/gNeMpg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Ini adalah logikanya: jika blok kosong tidak memiliki batas atau bantalan, itu menjadi hampir tidak terlihat.  Misalnya, bisa berupa paragraf kosong yang ditempatkan di markup CMS Anda.  Jika CMS Anda menambahkan elemen paragraf yang berlebihan, Anda mungkin tidak ingin mereka menyebabkan lekukan yang besar di antara paragraf lain karena marginnya diperhitungkan.  Tambahkan sesuatu ke blok dan dapatkan indentasi ini. <br><br>  Perilaku serupa dapat dilihat dengan margin anak pertama atau terakhir yang marginnya melampaui orang tua.  Jika kita menambahkan batas pada induk, margin anak akan tetap di dalam. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/rachelandrew/embed/preview/vqRKKX" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Dan lagi, ada logika dalam perilaku ini.  Jika Anda memiliki elemen pembungkus untuk keperluan semantik yang tidak ditampilkan secara visual, Anda mungkin tidak ingin mereka membuat lekukan besar saat ditampilkan.  Ini lebih berguna ketika web sebagian besar berupa teks.  Dan perilaku ini kurang bermanfaat ketika kita menggunakan elemen tata letak. <br><br><h3>  Membuat "Block Formatting Context" </h3><br>  "Block Formatting Context" (BFC) yang baru akan mencegah margin dari elemen induk.  Jika kita melihat kembali contoh dengan anak-anak pertama dan terakhir yang marginnya berada di luar batas elemen pembungkus dan mengatur pembungkus untuk <code>display: flow-root</code> , sehingga menciptakan BFC, margin anak-anak akan tetap di dalam. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/rachelandrew/embed/preview/VJXjEp" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Untuk mempelajari lebih lanjut tentang <code>display: flow-root</code> , baca artikel saya " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memahami Tata Letak CSS dan Konteks Pemformatan Blok</a> ".  Mengubah nilai properti <code>overflow</code> ke <code>auto</code> akan memiliki efek yang sama, karena juga menciptakan BFC baru, meskipun dapat menyebabkan bilah gulir yang tidak diperlukan dalam kasus tertentu <br><br><h3>  Flex dan Grid Containers </h3><br>  Wadah Flex dan Grid mengatur konteks format Flex dan Grid untuk anak-anak, sehingga mereka memiliki perilaku tata letak blok yang berbeda.  Salah satu perbedaan ini adalah bahwa margin tidak runtuh: <br><blockquote>  Wadah fleksibel menetapkan konteks format fleksibel baru untuk konten.  Ini sama dengan mengatur konteks pemformatan blok, kecuali bahwa markup fleksibel digunakan sebagai pengganti markup blok.  Misalnya, mengapung tidak berfungsi di dalam wadah fleksibel, dan margin wadah fleksibel tidak runtuh dengan margin elemen anak. <br>  - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Flexbox Level 1</a> <br></blockquote>  Jika kita mengambil contoh di atas dan membungkusnya dengan wadah Flex, menunjukkan arah sumbu utama arah fleksibel: kolom, menjadi jelas bahwa sekarang margin anak-anak tidak melampaui bungkus.  Selain itu, margin antara item fleksibel yang berdekatan tidak runtuh, jadi kami mendapatkan jarak 100 piksel antara item fleksibel, yang merupakan jumlah dari margin atas dan bawah, yang masing-masing 50px. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/rachelandrew/embed/preview/mZxreL" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Strategi margin untuk situs web Anda </h2><br>  Karena runtuh, solusi yang baik adalah menawarkan cara yang konsisten untuk bekerja dengan margin di situs Anda.  Hal paling sederhana yang dapat Anda lakukan adalah membuat aturan untuk menetapkan margin hanya di bagian atas atau bawah elemen.  Dalam hal ini, Anda tidak boleh terlalu sering mengalami masalah keruntuhan, karena sisi di mana margin ditetapkan akan selalu berdekatan dengan sisi elemen lain tanpa margin. <br><br>  <b>Catatan</b> : Harry Roberts <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">memiliki publikasi yang luar biasa yang</a> merinci alasan mengapa menetapkan margin dalam satu arah saja adalah ide yang bagus, dan bukan hanya karena menyelesaikan masalah keruntuhan. <br><br>  Pendekatan ini tidak menyelesaikan masalah margin yang keluar dari elemen anak di luar batas orangtua, yang mungkin Anda temui.  Masalah khusus ini biasanya kurang umum dan memahami mengapa ini terjadi dapat membantu menemukan solusi.  Solusi ideal adalah mengatur komponen yang mengharuskan ini untuk <code>display: flow-root</code> , dan dengan fallback (fallback) untuk browser lama Anda dapat menggunakan <code>overflow</code> untuk membuat BFC (konteks format blok);  mengubah induk menjadi wadah fleksibel;  atau bahkan mengatur padding ke 1px.  Ingatlah bahwa Anda dapat menggunakan permintaan dukungan browser untuk properti untuk menentukan apakah properti <code>display: flow-root</code> didukung sehingga hanya browser lama yang mendapatkan solusi yang kurang optimal. <br><br>  Saya percaya bahwa dalam kebanyakan kasus, memahami mengapa margin runtuh (atau tidak) adalah kuncinya.  Ini akan memungkinkan Anda untuk menentukan cara menangani ini dalam setiap kasus.  Metode apa pun yang Anda pilih, bagikan informasi ini dengan tim Anda.  Cukup sering, keruntuhan margin sedikit misterius, sehingga cara untuk menghadapinya tidak selalu jelas.  Sebuah komentar dalam kode Anda mungkin sesuai - Anda bahkan dapat memasukkan tautan ke artikel ini di dalamnya dan membantu berbagi pengetahuan tentang margin yang runtuh. <br><br>  Saya memutuskan bahwa saya akan menambah artikel ini dengan beberapa data tambahan yang berkaitan dengan margin. <br><br><h2>  Margin bunga </h2><br>  Saat Anda menggunakan persentase dalam CSS, itu haruslah persentase dari sesuatu.  Margin (dan juga padding) yang ditetapkan sebagai persentase akan selalu dihitung relatif terhadap lebar elemen induk.  Ini berarti bahwa saat menggunakan persentase, Anda akan selalu memiliki margin yang sama dari semua sisi di sekitar elemen. <br><br>  Dalam contoh CodePen di bawah ini, saya memiliki pembungkus dengan lebar 200px, di dalamnya adalah blok yang memiliki margin = 10%.  Dari semua sisi, margin adalah 20px, yaitu 10% dari 200px. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/rachelandrew/embed/preview/orqzrP" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Margin dalam dunia yang tergantung aliran </h2><br>  Sepanjang artikel ini, kami berbicara tentang margin vertikal, namun, CSS modern, sebagai aturan, berpikir tentang lokasi elemen relatif terhadap aliran lebih dari relatif terhadap sisi fisik.  Karena itu, ketika kita berbicara tentang margin vertikal, kita sebenarnya berbicara tentang margin dalam dimensi blok.  Margin ini dapat atas atau bawah dalam mode penulisan horizontal, atau kanan atau kiri dalam mode vertikal. <br><br>  Setelah bekerja dengan arah logis relatif terhadap aliran, menjadi lebih mudah untuk berbicara tentang awal dan akhir blok daripada tentang bagian atas dan bawah.  Untuk mempermudah ini, spesifikasi Properti dan Nilai Boolean diperkenalkan dalam CSS.  Ini menggantikan sifat fisik dengan sifat yang berkaitan dengan aliran. <br><br>  Jika kita berbicara tentang margin, ini memberi kita alternatif berikut (jika kita bekerja dengan bahasa Inggris atau mode lain yang direkam secara horizontal dengan arah teks dari kiri ke kanan). <br><br><ul><li>  margin-top = margin-block-start </li><li>  margin-right = margin-inline-end </li><li>  margin-bottom = margin-block-end </li><li>  margin-left = margin-inline-start </li></ul><br>  Kami juga memiliki dua properti disingkat baru: <br><br><ul><li>  blok-margin </li><li>  margin-inline </li></ul><br>  Dalam contoh CodePen berikut, saya menggunakan kata kunci yang terkait dengan aliran dan kemudian mengubah mode ejaan blok.  Anda dapat melihat bagaimana margin mengikuti aliran teks, daripada terikat pada sisi fisik. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/rachelandrew/embed/preview/BgrQRj" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Anda dapat membaca lebih lanjut tentang properti logis dan nilai-nilai pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">MDN</a> atau di artikel saya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memahami Properti dan Nilai-Nilai Logis</a> , di Smashing Magazine. <br><br><h2>  Kesimpulannya </h2><br>  Sekarang Anda tahu sebagian besar dari apa yang harus Anda ketahui tentang margin.  Secara singkat: <br><br><ul><li>  Margin bisa runtuh.  Memahami kapan ini terjadi dan kapan tidak akan membantu Anda memecahkan masalah yang mungkin mereka buat. </li><li>  Memasang margin hanya dalam satu arah memecahkan banyak masalah yang terkait dengannya. </li><li>  Seperti halnya situasi CSS, bagikan keputusan yang Anda buat dengan tim Anda dan komentari kode Anda </li><li>  Memperhatikan pengukuran blok dan garis akun alih-alih sisi fisik, atas, kanan, bawah, dan kiri akan membantu Anda, karena web bergerak ke arah yang independen dari mode penulisan </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id465839/">https://habr.com/ru/post/id465839/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id465823/index.html">Operator kubernet Tarantool</a></li>
<li><a href="../id465825/index.html">Direktori telepon Asterisk FreePBX dari tabel SQL (direktori berbasis web, unggah ke file XML untuk ponsel Grandstream)</a></li>
<li><a href="../id465829/index.html">[Tutorial] Cara membuat game JavaScript IDLE tambahan pertama Anda</a></li>
<li><a href="../id465833/index.html">TOKEN2 Molto-1, token perangkat keras multi-profil multi-profil pertama di dunia</a></li>
<li><a href="../id465835/index.html">Pabrik abstrak di jari</a></li>
<li><a href="../id465841/index.html">Pelacak GPS BOXY</a></li>
<li><a href="../id465843/index.html">Nikel untuk minyak</a></li>
<li><a href="../id465845/index.html">Tentang Pemodelan Struktural Perubahan Organisasi</a></li>
<li><a href="../id465849/index.html">Pengalaman pengembangan saya di Playcanvas</a></li>
<li><a href="../id465853/index.html">Tautan bantuan yang berguna untuk bekerja dengan data</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>