<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üê® üë®üèº‚Äç‚öñÔ∏è üíü Verwenden von GtkApplication. Librsvg-Rendering-Funktionen ü§∏üèø üö∏ üëê</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Zusammenfassung des Artikels. 



- Verwenden von GtkApplication. Wireframe-Anwendung. Makefile. 
- Rendern durch die Bibliothek librsvg. 
- Exportier...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Verwenden von GtkApplication. Librsvg-Rendering-Funktionen</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435564/">  Zusammenfassung des Artikels. <br><br><ul><li>  Verwenden von GtkApplication.  Wireframe-Anwendung.  Makefile. </li><li>  Rendern durch die Bibliothek librsvg. </li><li>  Exportieren Sie ein Bild nach GtkImage und skalieren Sie es. </li><li>  SVG-Skalierung mit benutzerdefinierten Funktionen. </li><li>  Den vollst√§ndigen Pfad in Anwendungen abrufen. </li><li>  Leistungstests GtkDrawingArea vs GtkImage. </li></ul><a name="habracut"></a><br>  Fr√ºher gab es Artikel (nicht meine) im GTK + -Hub, die in den Beispielen die Funktion void gtk_main (void) verwenden.  Mit der GtkApplication-Klasse k√∂nnen Sie die R√ºckruffunktionen application_activate und application_shutdown explizit hervorheben.  Bei gtk_main m√ºssen Sie gtk_main_quit explizit einbinden, damit die Anwendung beendet wird, wenn Sie auf das Kreuz klicken.  GtkApplication beendet die Anwendung durch Klicken auf das Kreuz, was logischer ist.  Das Anwendungsframework selbst besteht aus main.h, Makefile, string.gresource.xml, main.c. <br><br>  <b>main.h</b> <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;gtk/gtk.h&gt; typedef struct{ GtkApplication *restrict app; GtkWidget *restrict win; GtkBuilder *restrict builder; }appdata; appdata data; appdata *data_ptr; #endif</span></span></span></span></code> </pre> <br>  <b>Makefile</b> <br><br>  Hier k√∂nnen Sie universell alle Quelldateien kompilieren, ohne bestimmte Dateinamen anzugeben. Wenn sich jedoch zus√§tzliche Dateien im Ordner befinden, schw√∂rt der Compiler. <br>  Sie k√∂nnen auch CC = g ++ -std = c ++ 11 verwenden, aber die R√ºckruffunktionen eingeben <br>  extern "C". <br><br><pre> <code class="cmake hljs">CC = gcc -std=c99 PKGCONFIG = $(shell which pkg-config) CFLAGS = $(shell $(PKGCONFIG) --cflags gio-<span class="hljs-number"><span class="hljs-number">2.0</span></span> gtk+-<span class="hljs-number"><span class="hljs-number">3.0</span></span> librsvg-<span class="hljs-number"><span class="hljs-number">2.0</span></span>) -rdynamic -O3 LIBS = $(shell $(PKGCONFIG) --libs gio-<span class="hljs-number"><span class="hljs-number">2.0</span></span> gtk+-<span class="hljs-number"><span class="hljs-number">3.0</span></span> gmodule-<span class="hljs-number"><span class="hljs-number">2.0</span></span> librsvg-<span class="hljs-number"><span class="hljs-number">2.0</span></span> epoxy) -lm GLIB_COMPILE_RESOURCES = $(shell $(PKGCONFIG) --variable=glib_compile_resources gio-<span class="hljs-number"><span class="hljs-number">2.0</span></span>) SRC = $(wildcard *.c) GEN = gresources.c BIN = main ALL = $(GEN) $(SRC) OBJS = $(ALL:.c=.o) all: $(BIN) gresources.c: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.gresource.xml $(shell $(GLIB_COMPILE_RESOURCES) --sourcedir=. --generate-dependencies <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.gresource.xml) $(GLIB_COMPILE_RESOURCES) <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>.gresource.xml --<span class="hljs-keyword"><span class="hljs-keyword">target</span></span>=$@ --sourcedir=. --generate-source %.o: %.c $(CC) $(CFLAGS) -c -o $(@F) $&lt; $(BIN): $(OBJS) $(CC) -o $(@F) $(OBJS) $(LIBS) clean: @rm -f $(GEN) $(OBJS) $(BIN)</code> </pre><br>  <b>string.gresource.xml</b> <br><br>  dient dazu, Ressourcen in die ausf√ºhrbare Datei aufzunehmen. In diesem Fall handelt es sich um eine Beschreibungsdatei der window.glade-Schnittstelle <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">gresources</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">gresource</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">prefix</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"/com/example/YourApp"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">file</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">preprocess</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"xml-stripblanks"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">compressed</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"true"</span></span></span><span class="hljs-tag">&gt;</span></span>window.glade<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">file</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">gresource</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">gresources</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  <b>main.c</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> GtkBuilder* builder_init(void) { GError *</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta"> = NULL; data.builder = gtk_builder_new(); </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> (!gtk_builder_add_from_resource (data.builder, </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"/com/example/YourApp/window.glade"</span></span></span><span class="hljs-meta">, &amp;</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">error</span></span></span><span class="hljs-meta">)) { </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//     g_critical ("   : %s", error-&gt;message); g_error_free (error); } gtk_builder_connect_signals (data.builder,NULL); return data.builder; } void application_activate(GtkApplication *application, gpointer user_data) { GtkBuilder *builder=builder_init(); data_ptr=&amp;data; data.win=GTK_WIDGET(gtk_builder_get_object(builder, "window1")); gtk_widget_set_size_request(data.win,360,240); gtk_application_add_window(data.app,GTK_WINDOW(data.win)); gtk_widget_show_all(data.win); } void application_shutdown(GtkApplication *application, gpointer user_data) { g_object_unref(data.builder); } int main (int argc, char *argv[]) { gtk_init (&amp;argc, &amp;argv); gint res; data.app = gtk_application_new("gtk.org", G_APPLICATION_FLAGS_NONE); g_signal_connect(data.app, "activate", G_CALLBACK(application_activate), NULL); g_signal_connect(data.app, "shutdown", G_CALLBACK(application_shutdown), NULL); res = g_application_run(G_APPLICATION(data.app), 0, NULL); return 0; }</span></span></span></span></code> </pre><br>  Im ersten Argument der Funktion gtk_application_new k√∂nnen Sie einen beliebigen Text platzieren, der jedoch ohne Punkt nicht funktioniert hat.  In diesem Beispiel wird auch die Datei window.glade weggelassen, die im Glade-UI-Editor erstellt werden kann. <br><br>  Wir teilen das Fenster mit dem GtkBox-Container in zwei Teile, in einen setzen wir GtkDrawingArea, in den anderen: <br><br><img src="https://habrastorage.org/webt/d4/_f/qy/d4_fqyifbcg7k12sfrrrw6d-xw0.png"><br><br>  Infolgedessen √§ndern sich die App-Daten <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class">{</span></span> GtkApplication *<span class="hljs-keyword"><span class="hljs-keyword">restrict</span></span> app; GtkWidget *<span class="hljs-keyword"><span class="hljs-keyword">restrict</span></span> win; GtkBuilder *<span class="hljs-keyword"><span class="hljs-keyword">restrict</span></span> builder; GtkDrawingArea *<span class="hljs-keyword"><span class="hljs-keyword">restrict</span></span> draw; GtkImage *<span class="hljs-keyword"><span class="hljs-keyword">restrict</span></span> image; GtkEventBox *<span class="hljs-keyword"><span class="hljs-keyword">restrict</span></span> eventbox1; RsvgHandle *<span class="hljs-keyword"><span class="hljs-keyword">restrict</span></span> svg_handle_image; RsvgHandle *<span class="hljs-keyword"><span class="hljs-keyword">restrict</span></span> svg_handle_svg; GdkPixbuf *pixbuf; <span class="hljs-keyword"><span class="hljs-keyword">cairo_t</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">restrict</span></span> cr; <span class="hljs-keyword"><span class="hljs-keyword">cairo_surface_t</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">restrict</span></span> surf; }appdata;</code> </pre><br>  Und entsprechend Initialisierung. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">application_activate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkApplication *application, gpointer user_data)</span></span></span><span class="hljs-function"> </span></span>{ GtkBuilder *builder=builder_init(); data_ptr=&amp;data; data.win=GTK_WIDGET(gtk_builder_get_object(builder, <span class="hljs-string"><span class="hljs-string">"window1"</span></span>)); data.draw=GTK_DRAWING_AREA(gtk_builder_get_object(builder, <span class="hljs-string"><span class="hljs-string">"drawingarea1"</span></span>)); data.image=GTK_IMAGE(gtk_builder_get_object(builder, <span class="hljs-string"><span class="hljs-string">"image1"</span></span>)); gtk_widget_set_size_request(data.win,<span class="hljs-number"><span class="hljs-number">640</span></span>,<span class="hljs-number"><span class="hljs-number">480</span></span>); gtk_application_add_window(data.app,GTK_WINDOW(data.win)); gtk_widget_show_all(data.win); }</code> </pre><br>  F√ºgen Sie den Pfad #include &lt;librsvg-2.0 / librsvg / rsvg.h&gt; hinzu.  (Die Pakete librsvg und librsvg-dev m√ºssen installiert sein.) <br><br>  Die Namen der R√ºckruffunktionen stammen aus der .glade-Datei, die Funktion ist daf√ºr verantwortlich <br>  gtk_builder_connect_signals (data.builder, NULL); <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">gboolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawingarea1_draw_cb</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkWidget *widget, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">cairo_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *cr, gpointer user_data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!data.svg_handle_svg) {data.svg_handle_svg=rsvg_handle_new_from_file(<span class="hljs-string"><span class="hljs-string">"compassmarkings.svg"</span></span>,<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);} gboolean result=rsvg_handle_render_cairo(data.svg_handle_svg,cr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(result&amp;&amp;cr) {cairo_stroke(cr);} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">" \n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FALSE; }</code> </pre><br>  In einigen Situationen (z. B. HMI) m√ºssen Sie m√∂glicherweise die Gr√∂√üe des SVG √§ndern.  Kann <br>  √Ñndern Sie die Parameter f√ºr Breite und H√∂he in der SVG-Datei.  Oder auf GtkPixbuf √ºbertragen und dort bereits skalieren.  Da GtkImage nicht von GtkBin geerbt wird, kann es keine eigenen Ereignisse vom Typ ButtonClick (cursorbezogene Ereignisse) haben.  Hierf√ºr gibt es einen leeren Container - GtkEventBox.  Und die Zeichnung selbst kann direkt an GtkImage aufgeh√§ngt werden. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">gboolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image1_draw_cb</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkWidget *widget, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">cairo_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *cr, gpointer user_data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!data.svg_handle_image) { data.svg_handle_image=rsvg_handle_new_from_file(<span class="hljs-string"><span class="hljs-string">"compassmarkings.svg"</span></span>,<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); data.surf=cairo_image_surface_create_from_png(<span class="hljs-string"><span class="hljs-string">"2.png"</span></span>); data.pixbuf=rsvg_handle_get_pixbuf(data.svg_handle_image); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(data.pixbuf) { cairo_set_source_surface(cr,data.surf,<span class="hljs-number"><span class="hljs-number">0</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>); GdkPixbuf *dest=gdk_pixbuf_scale_simple (data.pixbuf,<span class="hljs-number"><span class="hljs-number">250</span></span>,<span class="hljs-number"><span class="hljs-number">250</span></span>,GDK_INTERP_BILINEAR); gtk_image_set_from_pixbuf (data.image,dest); g_object_unref(dest); cairo_paint(cr); } }</code> </pre><br>  Diese Funktion l√§dt das Hintergrundbild (2.png), das am h√§ufigsten dargestellt wird <br>  1x1 Zeichnung mit einem transparenten Pixel.  Anschlie√üend wird eine Zeichnung (pixbuf) auf diese Oberfl√§che gerendert und anschlie√üend wird gezoomt und in das Bild exportiert (Bild). <br><br>  Und wir d√ºrfen nicht vergessen, die Erinnerung zu l√∂schen. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">application_shutdown</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkApplication *application, gpointer user_data)</span></span></span><span class="hljs-function"> </span></span>{ cairo_surface_destroy(data.surf); g_object_unref(data.svg_handle_image); g_object_unref(data.svg_handle_svg); g_object_unref(data.pixbuf); g_object_unref(data.builder); }</code> </pre><br>  Das Ergebnis ist: <br><br><img src="https://habrastorage.org/webt/hw/bn/yi/hwbnyikg3opargq5pg5pbzqnweg.png"><br>  Wenn die Werte f√ºr Breite und H√∂he in den SVG-Parametern festgelegt sind, kann das Bild beim Exportieren nach PNG unscharf werden. <br><br>  Sie k√∂nnen auch Breite und H√∂he programmgesteuert √§ndern.  Daf√ºr habe ich separate Dateien erstellt <br>  svg_to_pixbuf_class.c und svg_to_pixbuf_class.h.  Das hei√üt, die Datei wird in √Ñnderungen Breite, H√∂he ge√∂ffnet. <br><br>  Es wird in / dev / shm / gespeichert.  Nach dem Exportieren der Informationen nach svg_handle m√ºssen Sie die Datei selbst und den Zeilenpfad zur Datei l√∂schen.  Bruchbreiten- / L√§ngenwerte werden ebenfalls unterst√ºtzt. <br><br><div class="spoiler">  <b class="spoiler_title">svg_to_pixbuf_class.c</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string.h&gt; #include &lt;stdlib.h&gt; #include &lt;stdio.h&gt; #include &lt;gtk/gtk.h&gt; #include &lt;sys/types.h&gt; #include &lt;sys/stat.h&gt; #include &lt;fcntl.h&gt; #include &lt;math.h&gt; #include &lt;stdbool.h&gt; int char_to_digit(char num) { switch(num) { case '0': return 0; case '1': return 1; case '2': return 2; case '3': return 3; case '4': return 4; case '5': return 5; case '6': return 6; case '7': return 7; case '8': return 8; case '9': return 9; case '.': return -1; default: return -2; } } //     text double read_num_in_text(char* text) { double result=0; int i=0; bool fractional_flag=FALSE; char whole_part[16]={0}; char whole_digits=0; char fractional_part[16]={0}; char fractional_digits=0; while(char_to_digit(text[i])!=-2) { if(char_to_digit(text[i])!=-1&amp;&amp;!fractional_flag) { whole_part[whole_digits]=char_to_digit(text[i]); printf("text_num=%d|%c\n",char_to_digit(text[i]),text[i]); ++whole_digits; ++i; } else { if(char_to_digit(text[i])==-1) { printf("fractional flag is true\n"); fractional_flag=TRUE; ++i; } else { fractional_part[fractional_digits]=char_to_digit(text[i]); ++fractional_digits; printf("frac_digit=%d|%c\n",char_to_digit(text[i]),text[i]); ++i; } } } ///    i=whole_digits; result=whole_part[whole_digits]; while(i&gt;0) { --i; printf("whole=%d\n",whole_part[i]); result=result+pow(10,whole_digits-i-1)*whole_part[i]; } i=0; while(i&lt;=fractional_digits) { result=result+pow(0.1,i+1)*fractional_part[i]; ++i; } printf("result_read_num=%lf\n",result); return result; } //  ,    // int count_of_digits_for_delete(char* text) { int i=0; bool fractional_flag=FALSE; char whole_part[16]={0}; int whole_digits=0; char fractional_part[16]={0}; int fractional_digits=0; while(char_to_digit(text[i])!=-2) { if(char_to_digit(text[i])!=-1&amp;&amp;!fractional_flag) { whole_part[whole_digits]=char_to_digit(text[i]); printf("text_num=%d|%c\n",char_to_digit(text[i]),text[i]); ++whole_digits; ++i; } else { if(char_to_digit(text[i])==-1) { printf("fractional flag is true\n"); fractional_flag=TRUE; ++i; } else { fractional_part[fractional_digits]=char_to_digit(text[i]); ++fractional_digits; printf("frac_digit=%d|%c\n",char_to_digit(text[i]),text[i]); ++i; } } } if(fractional_flag) return whole_digits+1+fractional_digits; else return whole_digits; } //      /dev/shm //      char* create_dump_file(char *file_with_path) { char *file=NULL; int i=0; while(file_with_path[i]!='\0') {++i;} while(file_with_path[i]!='/'&amp;&amp;i&gt;0) {--i;} file=file_with_path+i; GString *string=g_string_new("test -f /dev/shm"); g_string_append(string,file); g_string_append(string,"|| touch /dev/shm/"); g_string_append(string,file); system(string-&gt;str); ///  -  GString *full_path=g_string_new("/dev/shm"); g_string_append(full_path,file); char *result=g_string_free(full_path,FALSE); return result; } //result must be freed with g_string_free GString* read_file_in_buffer(char *file_with_path) { FILE *input = NULL; struct stat buf; int fh, result; char *body=NULL; // GString *resultat=g_string_new(""); fh=open(file_with_path, O_RDONLY); result=fstat(fh, &amp;buf); if (result !=0) printf("  \n"); else { printf("%s",file_with_path); printf(" : %ld\n", buf.st_size); printf(" : %lu\n", buf.st_dev); printf(" : %s", ctime(&amp;buf.st_atime)); input = fopen(file_with_path, "r"); if (input == NULL) { printf("Error opening file"); } body=(char*)calloc(buf.st_size+64,sizeof(char)); //    //    if(body==NULL) { printf("      body\n"); } int size_count=fread(body,sizeof(char),buf.st_size, input); if(size_count!=buf.st_size) printf("   "); resultat=g_string_append(resultat,body); free(body); } fclose(input); return resultat; } void* write_string_to_file(char* writed_file, char* str_for_write, int lenght) { FILE * ptrFile = fopen (writed_file ,"wb"); size_t writed_byte_count=fwrite(str_for_write,1,lenght,ptrFile); //if(writed_byte_count&gt;4) return TRUE; //else return FALSE; fclose(ptrFile); } //      g_free char* get_resized_svg(char *file_with_path, int width, int height) { char *writed_file=create_dump_file(file_with_path); //       GString *body=read_file_in_buffer(file_with_path); char *start_search=NULL; char *end_search=NULL; char *width_start=NULL; char *width_end=NULL; char *height_start=NULL; char *height_end=NULL; start_search=strstr(body-&gt;str,"&lt;svg"); int j=0; //   if(start_search) { end_search=strstr(start_search,"&gt;"); if(end_search) { ///  width width_start=strstr(start_search,"width"); width_end=width_start+strlen("width"); ///   width    while(width_end[j]==0x0A||width_end[j]==0x20) ++j; if(width_end[j]=='=') ++j; while(width_end[j]==0x0A||width_end[j]==0x20) ++j; if(width_end[j]!='"') printf("   svg.     width=%c\n",width_end[j]); else ++j; ///  ///  ,   gssize size=count_of_digits_for_delete(width_end+j); ///   (1  - 1 ) gssize pos=width_end+j-body-&gt;str; ///       g_string_erase(body,pos,size); char width_new[8]; g_snprintf(width_new,8,"%d",width); g_string_insert(body, pos, width_new); ///  height height_start=strstr(start_search,"height"); height_end=height_start+strlen("height"); ///   height    j=0; while(height_end[j]==0x0A||height_end[j]==0x20) ++j; if(height_end[j]=='=') ++j; while(height_end[j]==0x0A||height_end[j]==0x20) ++j; if(height_end[j]!='"') printf("   svg. \    height=%c%c%c\n",height_end[j-1],height_end[j],height_end[j+1]); else ++j; ///  ///  ,   size=count_of_digits_for_delete(height_end+j); ///   (1  - 1 ) pos=height_end+j-body-&gt;str; ///       g_string_erase(body,pos,size); char height_new[8]; g_snprintf(height_new,8,"%d",height); g_string_insert(body, pos, height_new); ///      dev/shm/ ///   write_string_to_file(writed_file,body-&gt;str,strlen(body-&gt;str)); return writed_file; //g_free(writed_file); g_string_free(body,TRUE); } else printf(" :      svg"); } } void resized_svg_free(char *path) { if (remove (path)==-1 ) { printf("    %s\n",path); } }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">svg_to_pixbuf_class.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> SVG_TO_PIXBUF_CLASS_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> SVG_TO_PIXBUF_CLASS_H void resized_svg_free(char *path); char* get_resized_svg(char *file_with_path, int width, int height); </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//result must be freed with g_free() #endif</span></span></span></span></code> </pre><br></div></div><br>  √Ñndern Sie nun die Gr√∂√üe der linken Seite (GtkDrawingArea). <br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">gboolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawingarea1_draw_cb</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkWidget *widget, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">cairo_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *cr, gpointer user_data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!data.svg_handle_svg) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* path=get_resized_svg(<span class="hljs-string"><span class="hljs-string">"/home/alex/svg_habr/compassmarkings.svg"</span></span>, <span class="hljs-number"><span class="hljs-number">220</span></span>, <span class="hljs-number"><span class="hljs-number">220</span></span>); data.svg_handle_svg=rsvg_handle_new_from_file(path,<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); resized_svg_free(path); g_free(path); } gboolean result=rsvg_handle_render_cairo(data.svg_handle_svg,cr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(result&amp;&amp;cr) {cairo_stroke(cr);} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">" \n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FALSE; }</code> </pre><br>  Wie Sie sehen k√∂nnen, gibt es hier ein unangenehmes Merkmal - den vollst√§ndigen Weg.  Das hei√üt, es lohnt sich, den Ordner zu verschieben, da der linke Teil (der GtkDrawingArea) nicht mehr angezeigt wird.  Gleiches gilt f√ºr alle Ressourcen, die nicht in der ausf√ºhrbaren Datei enthalten sind.  Zu diesem Zweck habe ich eine Funktion geschrieben, die den vollst√§ndigen Pfad zur ausf√ºhrbaren Datei berechnet, unabh√§ngig davon, wie sie ausgef√ºhrt wurde. <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   data.path void get_real_path(char *argv0) { char* result=(char*)calloc(1024,sizeof(char)); char* cwd=(char*)calloc(1024,sizeof(char)); getcwd(cwd, 1024); int i=0; while(argv0[i]!='\0'&amp;&amp;i&lt;1024) ++i; while(argv0[i]!='/'&amp;&amp;i&gt;0) --i; result[i]='\0'; while(i&gt;0) { --i; result[i]=argv0[i]; } /*alex@alex-System-Product-Name:~/project_manager$ ./manager.elf argv[0]=./manager.elf path=/home/alex/project_manager*/ if(strlen(result)&lt;=strlen(cwd)) //   { free(result); strcpy(data.path,cwd); strcat(data.path,"/"); //printf("path_cwd=%s\n",cwd); free(cwd);} else { /*alex@alex-System-Product-Name:/home$ '/home/alex/project_manager/manager.elf' argv[0]=/home/alex/project_manager/manager.elf path=/home*/ free(cwd); strcpy(data.path,result); strcat(data.path,"/"); //printf("path_result=%s\n",result); free(result); } }</span></span></code> </pre><br>  Der Code enth√§lt zwei Beispiele f√ºr die Ausf√ºhrung der Datei manager.elf.  Sie m√ºssen au√üerdem main () am Anfang der Funktion einf√ºgen <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">char</span></span> cwd[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; getcwd(cwd, <span class="hljs-keyword"><span class="hljs-keyword">sizeof</span></span>(cwd)); get_real_path(argv[<span class="hljs-number"><span class="hljs-number">0</span></span>]);</code> </pre><br>  Die Zeichenfunktion hat die folgende Form <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">gboolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">drawingarea1_draw_cb</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkWidget *widget, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">cairo_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *cr, gpointer user_data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!data.svg_handle_svg) { <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> image_path[<span class="hljs-number"><span class="hljs-number">1024</span></span>]; <span class="hljs-built_in"><span class="hljs-built_in">strcat</span></span>(image_path,data.path); <span class="hljs-built_in"><span class="hljs-built_in">strcat</span></span>(image_path,<span class="hljs-string"><span class="hljs-string">"compassmarkings.svg"</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"image_path=%s\n"</span></span>,image_path); <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* path=get_resized_svg(image_path, <span class="hljs-number"><span class="hljs-number">220</span></span>, <span class="hljs-number"><span class="hljs-number">220</span></span>); data.svg_handle_svg=rsvg_handle_new_from_file(path,<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); resized_svg_free(path); g_free(path); } gboolean result=rsvg_handle_render_cairo(data.svg_handle_svg,cr); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(result&amp;&amp;cr) {cairo_stroke(cr);} <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">" \n"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> FALSE; }</code> </pre><br>  <b>Schnelle Aktionstests.</b> <br><br>  Wir haben 2 Zeichenfunktionen (GtkDrawingArea und GtkImage). <br><br>  Wir werden jeden von ihnen in ein Design eines Typs einf√ºgen (ohne zu vergessen, &lt;time.h&gt; zu verbinden). <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">clock_t</span></span> tic = clock(); <span class="hljs-keyword"><span class="hljs-keyword">clock_t</span></span> toc = clock(); <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"image1_draw_cb elapsed : %f seconds\n"</span></span>, (<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>)(toc - tic) / CLOCKS_PER_SEC);</code> </pre><br>  In der htop-Anwendung k√∂nnen Sie sehen, wie das Programm 20 bis 30% jedes Athlon 2 X3 2,5 GHz-Kerns verbraucht. <br><br>  Der Fehler wurde schnell gefunden. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">gboolean </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">image1_draw_cb</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(GtkWidget *widget, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">cairo_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *cr, gpointer user_data)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">clock_t</span></span> tic = clock(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(!data.svg_handle_image) { data.svg_handle_image=rsvg_handle_new_from_file(<span class="hljs-string"><span class="hljs-string">"compassmarkings.svg"</span></span>,<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>); data.surf=cairo_image_surface_create_from_png(<span class="hljs-string"><span class="hljs-string">"2.png"</span></span>); data.pixbuf=rsvg_handle_get_pixbuf(data.svg_handle_image); <span class="hljs-comment"><span class="hljs-comment">//} //if(data.pixbuf) // { cairo_set_source_surface(cr,data.surf,0,0); GdkPixbuf *dest=gdk_pixbuf_scale_simple (data.pixbuf,250,250,GDK_INTERP_BILINEAR); gtk_image_set_from_pixbuf (data.image,dest); g_object_unref(dest); //cairo_paint(cr); } clock_t toc = clock(); printf("image1_draw_cb elapsed : %f seconds\n", (double)(toc - tic) / CLOCKS_PER_SEC); return FALSE; }</span></span></code> </pre><br>  Wie sich herausstellte, verf√ºgt GtkImage √ºber ein eigenes Rendering-System, und der Inhalt von image1_draw_cb kann nur einmal initialisiert werden.  Kommentierte Zeilen waren √ºberfl√ºssig. <br><br><img src="https://habrastorage.org/webt/2s/2p/4i/2s2p4ibxxewesxsfsupstrcwzju.png"><br><br>  Wie Sie sehen, dauert das erste Rendern mit GtkImage l√§nger als mit GtkDrawingArea, aber theoretisch sollte die Aktualisierung des Bildes schneller sein.  4 Millionen Prozessorzyklen f√ºr jedes Neuzeichnen von 220px * 220px-Bildern sind etwas viel, aber Sie k√∂nnen nur √ºber pixbuf zwischenspeichern (zumindest kenne ich keine anderen Methoden). <br><br>  Vielen Dank f√ºr Ihre Aufmerksamkeit. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435564/">https://habr.com/ru/post/de435564/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435552/index.html">Importsubstitution - Epitaph aus der Digitalisierung</a></li>
<li><a href="../de435556/index.html">Umzug ins Rechenzentrum: wie es war</a></li>
<li><a href="../de435558/index.html">Testen von PostgreSQL mit HugePages unter Linux</a></li>
<li><a href="../de435560/index.html">Erster kommerzieller Quantencomputer - IBM</a></li>
<li><a href="../de435562/index.html">Der Weg eines Rauchers: Wie man als Humanist in den Beruf eines Programmierers einsteigt</a></li>
<li><a href="../de435568/index.html">VyOS OpenSource Router</a></li>
<li><a href="../de435572/index.html">Anycubic i3 Mega: Qualit√§ts-Remake von Prusa i3</a></li>
<li><a href="../de435574/index.html">Wie funktioniert Zickzack?</a></li>
<li><a href="../de435576/index.html">1C, keine Schmerzen</a></li>
<li><a href="../de435578/index.html">Weltraumspaziergang zu Weihnachten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>