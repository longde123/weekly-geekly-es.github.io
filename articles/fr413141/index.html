<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌜 🐜 💿 Classer de grandes quantités de données sur Apache Spark à l'aide de modèles d'apprentissage automatique arbitraires 🥘 🐓 🚡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Partie 2: Solution 
 Bonjour encore! Aujourd'hui, je vais continuer mon histoire sur la façon dont nous classons de grandes quantités de données sur A...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Classer de grandes quantités de données sur Apache Spark à l'aide de modèles d'apprentissage automatique arbitraires</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/lanit/blog/413141/"><h2>  Partie 2: Solution </h2><br>  Bonjour encore!  Aujourd'hui, je vais continuer mon histoire sur la façon dont nous classons de grandes quantités de données sur Apache Spark à l'aide de modèles d'apprentissage automatique arbitraires.  Dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">première partie de l'article,</a> nous avons examiné l'énoncé du problème lui-même, ainsi que les principaux problèmes qui se posent lors de l'organisation de l'interaction entre le cluster sur lequel les données initiales sont stockées et traitées, et le service de classification externe.  Dans la deuxième partie, nous considérerons l'une des options pour résoudre ce problème en utilisant l'approche Reactive Streams et son implémentation en utilisant la bibliothèque akka-streams. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6m/bg/fu/6mbgfuuatqlimwnapnl3tlrzn8q.png"></div><a name="habracut"></a><br><h3>  Concept de flux réactifs </h3><br>  Pour résoudre les problèmes décrits dans la première partie, vous pouvez utiliser l'approche, appelée <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Reactive Streams</a> .  Il vous permet de contrôler le processus de transfert des flux de données entre les étapes de traitement, fonctionnant à différentes vitesses et indépendamment les uns des autres sans avoir besoin de mise en mémoire tampon.  Si l'une des étapes de traitement est plus lente que la précédente, il est nécessaire de signaler l'étape la plus rapide sur la quantité de données d'entrée qu'elle est prête à traiter pour le moment.  Cette interaction est appelée contre-pression.  Elle consiste dans le fait que les étapes les plus rapides traitent exactement autant d'éléments que nécessaire pour l'étape la plus lente, et pas plus, puis libèrent des ressources informatiques. <br><br>  En général, Reactive Streams est une spécification pour implémenter le modèle <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Publisher-Subscriber</a> .  Cette spécification définit un ensemble de quatre interfaces (éditeur, abonné, processeur et abonnement) et un contrat pour leurs méthodes. <br><br>  Examinons ces interfaces plus en détail: <br><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscriber&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; s)</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSubscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscription s)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Throwable t)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscription</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Processor</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt;, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">R</span></span></span><span class="hljs-class">&gt; </span></span>{ }</code> </pre> <br>  Le modèle Publisher-Subscriber a deux côtés: la transmission et la réception.  Lors de l'implémentation de Reactive Streams, la classe qui implémente l'interface Publisher est responsable du transfert de données et l'Abonné est responsable de la réception.  Pour établir une communication entre eux, l'Abonné doit être enregistré auprès de Publisher en appelant sa méthode d'abonnement.  Selon la spécification, après avoir enregistré un abonné, Publisher doit appeler ses méthodes dans l'ordre suivant: <br><br><ol><li>  onSubscribe.  Cette méthode est appelée immédiatement après l'enregistrement de l'abonné auprès de Publisher.  En tant que paramètre, un objet Subscription lui est transmis via lequel l'Abonné demandera des données à Publisher.  Cet objet doit être stocké et appelé uniquement dans le contexte de cet abonné. </li><li>  Une fois que l'Abonné a demandé des données à Publisher en appelant la méthode de demande sur l'objet Subscription correspondant, Publisher peut appeler la méthode Subscriber onNext, en passant l'élément suivant. </li><li>  L'abonné peut ensuite appeler périodiquement la méthode de demande sur l'abonnement, mais Publisher ne peut pas appeler la méthode onNext plus que le total demandé via la méthode de demande. </li><li>  Si le flux de données est fini, après avoir passé tous les éléments via la méthode onNext, Publisher doit appeler la méthode onComplete. </li><li>  Si une erreur s'est produite dans Publisher et qu'un traitement ultérieur des éléments n'est pas possible, il doit appeler la méthode onError </li><li>  Après avoir appelé les méthodes onComplete ou onError, l'interaction ultérieure de Publisher avec l'abonné doit être exclue. </li></ol><br>  Les appels de méthode peuvent être considérés comme l'envoi de signaux entre l'éditeur et l'abonné.  L'abonné signale à Publisher le nombre d'éléments qu'il est prêt à traiter, et Publisher, à son tour, lui signale qu'il existe soit l'élément suivant, soit qu'il n'y a plus d'éléments, ou qu'une erreur s'est produite. <br><br>  Afin d'exclure une autre influence de Publisher et Subscriber l'un sur l'autre, les appels à toutes les méthodes qui implémentent les interfaces Reactive Streams doivent être non bloquants.  Dans ce cas, l'interaction entre eux sera complètement asynchrone. <br><br>  Plus de détails sur la spécification des interfaces Reactive Streams peuvent être trouvés <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  Ainsi, en reliant les itérateurs d'origine et résultants en les convertissant respectivement en Publisher et Subscriber, nous pouvons résoudre les problèmes identifiés dans la partie précédente de l'article.  Le problème de dépassement de tampon entre les étapes est résolu en demandant un certain nombre d'éléments à l'Abonné.  Le problème de l'achèvement réussi ou échoué est résolu en envoyant des signaux à l'Abonné via les méthodes onComplete ou onError, respectivement.  L'éditeur devient responsable de l'envoi de ces signaux, qui dans notre cas doivent contrôler le nombre de requêtes HTTP envoyées et le nombre de réponses reçues.  Après avoir reçu la dernière réponse et traité tous les résultats qui y sont entrés, il doit envoyer un signal onComplete.  En cas d'échec de l'une des demandes, il doit envoyer un signal onError et cesser d'envoyer d'autres éléments à l'Abonné, ainsi que de soustraire des éléments de l'itérateur d'origine. <br><br>  L'itérateur résultant doit être implémenté en tant qu'abonné.  Dans ce cas, nous ne pouvons pas nous passer d'un tampon dans lequel les éléments seront écrits lorsque la méthode onNext est appelée à partir de l'interface Subscriber et soustraits à l'aide des méthodes hasNext et next de l'interface Iterator.  En tant qu'implémentation de tampon, vous pouvez utiliser une file d'attente de blocage, par exemple, LinkedBlockedQueue. <br><br>  Un lecteur attentif posera immédiatement la question: pourquoi la file d'attente est-elle bloquante, car selon la spécification Reactive Streams, l'implémentation de toutes les méthodes devrait être non bloquante?  Mais tout va bien ici: puisque nous demandons à Publisher un nombre d'éléments strictement défini, la méthode onNext ne sera pas appelée plus que ce nombre de fois, et la file d'attente peut toujours ajouter un nouvel élément sans bloquer. <br><br>  En revanche, un blocage peut se produire lorsque la méthode hasNext est appelée en cas de file d'attente vide.  Cependant, tout va bien: la méthode hasNext ne fait pas partie du contrat de l'interface Abonné, elle est définie dans l'interface Iterator, qui, comme nous l'avons expliqué précédemment, est une structure de données bloquante.  Lors de l'appel de la méthode suivante, nous soustrayons l'élément suivant de la file d'attente, et lorsque sa taille devient inférieure à un certain seuil, nous devrons demander la partie suivante des éléments via un appel à la méthode request. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tz/xy/8t/tzxy8tn05km8fox0bkwk_zsxvcg.png" width="650"></div>  <i>Figure 7. Interaction asynchrone avec un service externe à l'aide de l'approche Reactive Streams</i> <br><br>  Bien sûr, dans ce cas, nous ne nous débarrasserons pas complètement du blocage des appels.  Cela est dû à une incompatibilité de paradigmes entre les flux réactifs, qui supposent une interaction complètement asynchrone, et un itérateur, qui doit appeler trueN ou false lors de l'appel de la méthode hasNext.  Cependant, contrairement à l'interaction synchrone avec un service externe, les temps d'arrêt dus aux verrous peuvent être considérablement réduits en augmentant la charge globale des cœurs de processeur. <br><br>  Il serait pratique que les développeurs Apache Spark dans les futures versions implémentent un analogue de la méthode mapPartitions, qui fonctionne avec Publisher et Subscriber.  Cela permettrait une interaction complètement asynchrone, éliminant ainsi la possibilité de bloquer les threads. <br><br><h3>  Akka-streams et akka-http comme implémentation de la spécification Reactive Streams </h3><br>  Actuellement, il existe déjà plus d'une douzaine d'implémentations de la spécification Reactive Streams.  Une telle implémentation est le module akka-streams de la bibliothèque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">akka</a> .  Dans le monde de la JVM, akka s'est imposé comme l'un des moyens les plus efficaces pour écrire des systèmes parallèles et distribués.  Ceci est obtenu grâce au fait que le principe de base énoncé dans sa fondation est <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le modèle d'acteur</a> , qui vous permet d'écrire des applications hautement compétitives sans contrôle direct des threads et de leurs pools. <br><br>  Beaucoup de littérature a été écrite sur la mise en œuvre du concept d'acteurs dans l'akka, donc nous ne nous arrêterons pas là (le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">site officiel de</a> l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">akka</a> est une très bonne source d'information, je recommande également l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">akka dans le</a> livre d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">action</a> ).  Ici, nous allons examiner de plus près le côté technologique de la mise en œuvre dans le cadre de la JVM. <br><br>  En général, les acteurs n'existent pas par eux-mêmes, mais forment un système hiérarchique.  Afin de créer un système d'acteur, vous devez lui allouer des ressources, donc la première étape lorsque vous travaillez avec akka est de créer une instance de l'objet ActorSystem.  Lorsque ActorSystem démarre, un pool séparé de threads est créé, appelé le répartiteur, dans lequel tout le code défini dans les acteurs est exécuté.  En règle générale, un seul thread exécute le code de plusieurs acteurs, cependant, si nécessaire, vous pouvez configurer un répartiteur distinct pour un groupe spécifique d'acteurs (par exemple, pour les acteurs interagissant directement avec une API de blocage). <br><br>  L'une des tâches les plus courantes résolues à l'aide d'acteurs est le traitement séquentiel des flux de données.  Auparavant, pour cela, il était nécessaire de créer manuellement des chaînes d'acteurs et de s'assurer qu'il n'y avait pas de goulots d'étranglement entre eux (par exemple, si un acteur traite les messages plus rapidement que le suivant, il peut alors avoir un débordement de la file d'attente des messages entrants, conduisant à une erreur OutOfMemoryError). <br><br>  À partir de la version 2.4, le module akka-streams a été ajouté à akka, ce qui vous permet de définir de manière déclarative le processus de traitement des données, puis de créer les acteurs nécessaires à son exécution.  Akka-streams met également en œuvre le principe de la contre-pression, ce qui élimine la possibilité de déborder la file d'attente des messages entrants pour tous les acteurs impliqués dans le traitement. <br><br>  Les principaux éléments permettant de définir le schéma de traitement des flux de données dans les akka-streams sont Source, Flow et Sink.  En les combinant les uns avec les autres, nous obtenons un graphique exécutable.  Pour démarrer le processus de traitement, un matérialiseur est utilisé, ce qui crée des acteurs travaillant selon le graphe défini par nous (l'interface Materializer et son implémentation ActorMaterializer). <br><br>  Examinons plus en détail les étapes Source, Flow et Sink.  La source définit la source de données.  Akka-streams prend en charge plus d'une douzaine de façons différentes de créer des sources, y compris à partir d'un itérateur: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> featuresSource: <span class="hljs-type"><span class="hljs-type">Source</span></span>[<span class="hljs-type"><span class="hljs-type">Array</span></span>[<span class="hljs-type"><span class="hljs-type">Float</span></span>], <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = <span class="hljs-type"><span class="hljs-type">Source</span></span>.fromIterator { () =&gt; featuresIterator }</code> </pre><br>  La source peut également être obtenue en convertissant une source existante: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newSource: <span class="hljs-type"><span class="hljs-type">Source</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = source.map(item =&gt; transform(item))</code> </pre> <br>  Si la transformation est une opération non triviale, elle peut être représentée comme une entité Flow.  Akka-streams prend en charge de nombreuses façons de créer Flow.  La façon la plus simple est de créer à partir d'une fonction: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> someFlow: <span class="hljs-type"><span class="hljs-type">Flow</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = <span class="hljs-type"><span class="hljs-type">Flow</span></span>.fromFunction((x: <span class="hljs-type"><span class="hljs-type">String</span></span>) =&gt; x.length)</code> </pre> <br>  En combinant Source et Flow, nous obtenons une nouvelle Source. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> newSource: <span class="hljs-type"><span class="hljs-type">Source</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>, <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = oldSource.via(someFlow)</code> </pre> <br>  L'évier est utilisé comme étape finale du traitement des données.  Comme dans le cas de Source, akka-streams fournit plus d'une douzaine d'options Sink différentes, par exemple, Sink.foreach effectue une certaine opération pour chaque élément, Sink.seq collecte tous les éléments d'une collection, etc. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> printSink: <span class="hljs-type"><span class="hljs-type">Sink</span></span>[<span class="hljs-type"><span class="hljs-type">Any</span></span>, <span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Done</span></span>]] = <span class="hljs-type"><span class="hljs-type">Sink</span></span>.foreach(println)</code> </pre> <br>  Source, Flow et Sink sont paramétrés respectivement par les types d'éléments d'entrée et / ou de sortie.  De plus, chaque étape de traitement peut avoir un certain résultat de son travail.  Pour cela, Source, Flow et Sink sont également paramétrés par un type supplémentaire qui détermine le résultat de l'opération.  Ce type est appelé type de valeur matérialisée.  Si l'opération n'implique pas la présence d'un résultat supplémentaire de son travail, par exemple, lorsque nous définissons Flow through a function, le type NotUsed est utilisé comme valeur matérialisée. <br><br>  En combinant la source, le flux et le puits nécessaires, nous obtenons RunnableGraph.  Il est paramétré par un type, qui détermine le type de valeur obtenu suite à l'exécution de ce graphe.  Si nécessaire, lors de la combinaison des étapes, vous pouvez spécifier le résultat de laquelle des étapes sera le résultat de l'ensemble du graphique des opérations.  Par défaut, le résultat de l'étape Source est pris: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> graph: <span class="hljs-type"><span class="hljs-type">RunnableGraph</span></span>[<span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = someSource.to(<span class="hljs-type"><span class="hljs-type">Sink</span></span>.foreach(println))</code> </pre> <br>  Cependant, si le résultat de l'étape Sink est plus important pour nous, alors nous devons l'indiquer explicitement: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> graph: <span class="hljs-type"><span class="hljs-type">RunnableGraph</span></span>[<span class="hljs-type"><span class="hljs-type">Future</span></span>[<span class="hljs-type"><span class="hljs-type">Done</span></span>]] = someSource.toMat(<span class="hljs-type"><span class="hljs-type">Sink</span></span>.foreach(println))(<span class="hljs-type"><span class="hljs-type">Keep</span></span>.right)</code> </pre><br>  Après avoir défini le graphe des opérations, nous devons l'exécuter.  Pour ce faire, runnableGraph doit appeler la méthode run.  En tant que paramètre, cette méthode prend un objet ActorMaterializer (qui peut également être dans une portée implicite), qui est responsable de la création d'acteurs qui effectueront des opérations.  En règle générale, un ActorMaterializer est créé immédiatement après la création d'un ActorSystem, attaché à son cycle de vie, et l'utilise pour créer des acteurs.  Prenons un exemple: <br><br><pre> <code class="scala hljs"><span class="hljs-comment"><span class="hljs-comment">//   ActorSystem,       implicit val system = ActorSystem(“system name”) // ,       ActorSystem implicit val materializer = ActorMaterializer() //    ,       Sink val graph: RunnableGraph[Future[immutable.Seq[Int]]] = Source.fromIterator(() =&gt; (1 to 10).iterator).toMat(Sink.seq)(Keep.right) //   ,    implicit scope. val result: Future[immutable.Seq[Int]] = graph.run()</span></span></code> </pre><br>  Dans le cas de combinaisons simples, vous pouvez vous passer de la création d'un RunnableGraph distinct, mais connectez simplement Source à Sink et démarrez-les en appelant la méthode runWith sur Source.  Cette méthode suppose également qu'un objet ActorMaterializer est présent dans la portée implicite.  De plus, dans ce cas, la valeur matérialisée définie dans Sink sera utilisée.  Par exemple, en utilisant le code suivant, nous pouvons convertir Source en Publisher à partir de la spécification Reactive Streams: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> source: <span class="hljs-type"><span class="hljs-type">Source</span></span>[<span class="hljs-type"><span class="hljs-type">Score</span></span>, <span class="hljs-type"><span class="hljs-type">NotUsed</span></span>] = <span class="hljs-type"><span class="hljs-type">Source</span></span>.fromIterator(() =&gt; sourceIterator).map(item =&gt; transform(item)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> publisher: <span class="hljs-type"><span class="hljs-type">Publisher</span></span>[<span class="hljs-type"><span class="hljs-type">Score</span></span>] = source.runWith(<span class="hljs-type"><span class="hljs-type">Sink</span></span>.asPublisher(<span class="hljs-literal"><span class="hljs-literal">false</span></span>))</code> </pre><br>  Ainsi, nous avons maintenant montré comment obtenir Reactive Streams Publisher en créant une source à partir de l'itérateur source et en effectuant des transformations sur ses éléments.  Nous pouvons maintenant l'associer à un abonné qui fournit des données à l'itérateur résultant.  Reste à considérer la dernière question: comment organiser l'interaction HTTP avec un service externe. <br><br>  La structure d'akka comprend le module <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=https://doc.akka.io/docs/akka-">akka-http</a> , qui vous permet d'organiser une communication asynchrone non bloquante sur HTTP.  De plus, ce module est construit sur la base de flux akka, ce qui vous permet d'ajouter une interaction HTTP comme étape supplémentaire dans le graphique des opérations de traitement des flux de données. <br><br>  Pour se connecter à des services externes, akka-http propose trois interfaces différentes. <br><br><ol><li>  API au niveau de la demande - est l'option la plus simple pour le cas de demandes uniques à une machine arbitraire.  À ce niveau, les connexions HTTP sont gérées de manière entièrement automatique et, à chaque demande, il est nécessaire de transmettre l'adresse complète de la machine à laquelle la demande est envoyée. </li><li>  API au niveau de l'hôte - appropriée lorsque nous savons à quel port sur quelle machine nous allons accéder.  Dans ce cas, akka-http prend le contrôle du pool de connexions HTTP, et dans les requêtes, il suffit de spécifier le chemin relatif vers la ressource demandée. </li><li>  API au niveau de la connexion - vous permet d'obtenir un contrôle total sur la gestion des connexions HTTP, c'est-à-dire l'ouverture, la fermeture et la distribution des demandes sur les connexions. </li></ol><br>  Dans notre cas, l'adresse du service de classification nous est connue à l'avance, il est donc nécessaire d'organiser l'interaction HTTP uniquement avec cette machine particulière.  Par conséquent, l'API au niveau de l'hôte est la meilleure pour nous.  Voyons maintenant comment le pool de connexions HTTP est créé lors de son utilisation: <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> httpFlow: <span class="hljs-type"><span class="hljs-type">Flow</span></span>[(<span class="hljs-type"><span class="hljs-type">HttpRequest</span></span>,<span class="hljs-type"><span class="hljs-type">Id</span></span>), (<span class="hljs-type"><span class="hljs-type">Try</span></span>[<span class="hljs-type"><span class="hljs-type">HttpResponse</span></span>],<span class="hljs-type"><span class="hljs-type">Id</span></span>), <span class="hljs-type"><span class="hljs-type">Http</span></span>.<span class="hljs-type"><span class="hljs-type">HostConnectionPool</span></span>] = <span class="hljs-type"><span class="hljs-type">Http</span></span>().cachedHostConnectionPool[<span class="hljs-type"><span class="hljs-type">Id</span></span>](hostAddress, portNumber)</code> </pre><br>  Lors de l'appel à Http (). CachedHostConnectionPool [T] (hostAddress, portNumber) dans l'ActorSystem, qui est dans une portée implicite, les ressources sont allouées pour créer un pool de connexions, mais les connexions elles-mêmes ne sont pas établies.  À la suite de cet appel, Flow est renvoyé, qui reçoit une paire d'une demande HTTP et un objet d'identification Id en entrée.  L'objet d'identification est nécessaire pour faire correspondre la demande avec la réponse correspondante, car l'appel HTTP dans akka-http est une opération asynchrone, et l'ordre dans lequel les réponses sont reçues ne correspond pas nécessairement à l'ordre dans lequel les demandes sont envoyées.  Par conséquent, à la sortie, Flow donne un couple du résultat de la requête et de l'objet d'identification correspondant. <br><br>  Directement, les connexions HTTP sont établies lorsqu'un graphique (y compris ce flux) est lancé (matérialisé).  Akka-http est implémenté de telle manière que peu importe le nombre de fois où les graphiques contenant httpFlow ont été matérialisés, au sein du même ActorSystem, il y aura toujours un pool commun de connexions HTTP qui sera utilisé par toutes les matérialisations.  Cela vous permet de mieux contrôler l'utilisation des ressources réseau et d'éviter de les surcharger. <br><br>  Ainsi, le cycle de vie du pool de connexions HTTP est lié à l'ActorSystem.  Comme déjà mentionné, le cycle de vie du pool de threads lui est également attaché, dans lequel les opérations définies dans les acteurs (ou dans notre cas, définies comme les étapes akka-streams et akka-http) sont effectuées.  Par conséquent, pour atteindre une efficacité maximale, nous devons réutiliser une instance d'ActorSystem au sein du même processus JVM. <br><br><h3>  Mettre tout cela ensemble: un exemple de mise en œuvre de l'interaction avec le service de classification </h3><br>  Ainsi, nous pouvons maintenant passer au processus de classification de grands volumes de données distribuées sur Apache Spark en utilisant une interaction asynchrone avec des services externes.  Le schéma général de cette interaction a déjà été illustré à la figure 7. <br><br>  Supposons que nous ayons défini un [jeu de données] initial.  En lui appliquant l'opération mapPartitions, nous devrions obtenir un ensemble de données, dans lequel chaque identifiant de l'ensemble source est estampillé avec une certaine valeur obtenue à la suite de la classification (ensemble de données [score]).  Pour organiser le traitement asynchrone sur les exécuteurs, nous devons encapsuler la source et les itérateurs résultants dans Publisher et Subscriber, respectivement, à partir de la spécification des flux réactifs et les lier ensemble. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Features</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, vector: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-class"><span class="hljs-params">[</span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span><span class="hljs-class"><span class="hljs-params">]</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Score</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">id: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, score: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Float</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">1</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">val</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">batchesRequestCount</span></span></span><span class="hljs-class"> </span></span>= config.getInt(“scoreService. batchesRequestCount”)<span class="hljs-comment"><span class="hljs-comment">//(2) //... val scoreDs: Dataset[Score] = featuresDs.mapPartitions { fi: Iterator[Features] =&gt; val publisher: Publisher[Iterable[Score]] = createPublisher(fi) //(3) val iteratorSubscriber: Iterator[Score] = new IteratorSubscriber(batchesRequestCount) //(4) publisher.subscribe(batchesRequestCount) //(5) iteratorSubscriber //(6) }</span></span></code> </pre> <br>  Dans cette implémentation, il est pris en compte que le service de classification pour un appel peut traiter un groupe de vecteurs de caractéristiques à la fois, par conséquent, le résultat de la classification après un appel à celui-ci sera également disponible immédiatement pour l'ensemble du groupe.  Par conséquent, en tant que type de paramètre pour Publisher, nous n'avons pas seulement Score, comme vous pouvez vous y attendre, mais Iterable [Score].  Ainsi, nous envoyons les résultats de classification de ce groupe à l'itérateur résultant (qui est également un abonné) par un seul appel à la méthode onNext.  C'est beaucoup plus efficace que d'appeler onNext pour chaque élément.  Nous allons maintenant analyser ce code plus en détail. <br><br><ol><li>  Nous déterminons la structure des données d'entrée et de sortie.  En entrée, nous aurons un tas d'identifiant avec un vecteur d'entité, et en sortie, nous aurons un tas d'identifiant avec une valeur numérique obtenue à la suite de la classification. </li><li>  Nous déterminons le nombre de groupes que l'abonné demandera à l'éditeur à la fois.  Comme il est supposé que ces valeurs se trouveront dans le tampon et attendront d'être lues dans l'itérateur résultant, cette valeur dépend de la quantité de mémoire allouée à l'exécuteur. </li><li>  Créez Publisher à partir de l'itérateur source.  Il sera responsable de l'interaction avec le service de classification.  La fonction createPublisher est décrite ci-dessous. </li><li>  Créez un abonné, qui sera l'itérateur résultant.  Le code de la classe IteratorSubscriber est également donné ci-dessous. </li><li>  Enregistrement de l'abonné auprès de Publisher. </li><li>  Renvoie IteratorSubscriber comme résultat de l'opération mapPartitions. </li></ol><br>  Considérons maintenant l'implémentation de la fonction createPublisher. <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Ids</span></span></span><span class="hljs-class"> </span></span>= <span class="hljs-type"><span class="hljs-type">Seq</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] <span class="hljs-comment"><span class="hljs-comment">//(1) val batchSize = config.getInt("scoreService.batchSize") val parallelismLevel = config.getInt("scoreService.parallelismLevel") //(2) //... def createPublisher(fi: Iterator[Features]): Publisher[Iterable[Score]] = { import ActorSystemHolder._ //(3) Source .fromIterator(() =&gt; fi) //(4) .grouped(batchSize) //(5) .map { groupedFeatures: Seq[Features] =&gt; val request: (HttpRequest, Ids) = createHttpRequest(groupedFeatures) //(6) logger.debug(s"Sending request for the first id: ${request._2(0)}") request } .via(httpFlow) //(7) .flatMapMerge(parallelismLevel, { //(8) case (Success(response), ids) if response.status.isSuccess() =&gt; logger.debug(s"Processing successful result for the first id: ${ids(0)}") val resultSource: Source[Iterable[Score], _] = response.entity.dataBytes.reduce(_ ++ _).map { responseBytes =&gt; processSuccessfulResponse(responseBytes, ids) } //(9) resultScore case (Success(response), ids) =&gt; logger.warn( s"Failed result for the first id: ${ids(0)}, HTTP status: ${response.status}" ) response.discardEntityBytes() Source.failed( new IOException(s"Non-successful HTTP status: ${response.status}") ) //(10) case (Failure(ex), ids) =&gt; logger.warn(s"Failed result: an exception has occured", ex) Source.failed(ex) //(11) }) .runWith(Sink.asPublisher(false)) //(12) } def createHttpRequest(featuresSeq: Seq[Features]): (HttpRequest, ProfileIds) = { val requestBytes: Array[Byte] = featuresToMatrixBytes(featuresSeq) val ids: ProfileIds = extractIds(featuresSeq) val httpRequest = HttpRequest( method = HttpMethods.PUT, uri = "/score", entity = requestBytes ) httpRequest -&gt; ids }</span></span></code> </pre><br><ol><li>    -   ,   .         httpFlow,           . </li><li>     :     ,     (batchSize)        (parallelismLevel). </li><li>   implicit scope ActorSystem, ActorMaterializer  httpFlow.        Spark-.  ActorSystemHolder    . </li><li>     akka-streams   .     Source[Features]   . </li><li>            batchSize       . </li><li>     HttpRequest       .   HttpRequest      createHttpRequest.      createPublisher.      feature-,   ,      (            predict).       ,      HTTP-.      ,   HTTP-,    HTTP-, URI      . </li><li>        httpFlow. </li><li>     ,   .      flatMapMerge,        akka-http    Source[ByteString],      ,       .           .  parallelismLevel ,      (     ).      HTTP-:   ,  ,  ,   . </li><li>       :          .      akka    ByteString.    ,    ByteString    O(1),    ByteString        .       ,    ,         .                ,     . </li><li>       HTTP-     ,  Stream .         ,      discardEntityBytes    ,    ,  . </li><li>         .      akka-http    ,       . </li><li>       ,    Publisher,     .    ,    .  false   Sink.asPublisher ,   Publisher    Subscriber-. </li></ol><br>      ,    akka  ActorSystem,        .  ,        Spark ,          .   Spark    JVM , ,        ,     ActorSystem    ActorMatrializer  httpFlow. <br><br><pre> <code class="scala hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ActorSystemHolder</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">implicit</span></span> <span class="hljs-keyword"><span class="hljs-keyword">lazy</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> actorSystem: <span class="hljs-type"><span class="hljs-type">ActorSystem</span></span> = { <span class="hljs-comment"><span class="hljs-comment">//(1) val actorSystemName = s"score-service-client" logger.debug(s"Creating actor system $actorSystemName") val as = ActorSystem(actorSystemName) //(2) logger.debug("Adding shutdown hook for the actor system") scala.sys.addShutdownHook { //(3) logger.debug(s"Terminating actor system $actorSystemName") Await.result(as.terminate(), 30.seconds) //to Mars :) logger.debug(s"The actor system $actorSystemName has been terminated") } as } implicit lazy val materializer: ActorMaterializer = { //(4) logger.debug(s"Creating actor materializer for actor system ${actorSystem.name}") ActorMaterializer() } lazy val httpFlow: Flow[ (HttpRequest,ProfileIds), (Try[HttpResponse], ProfileIds), Http.HostConnectionPool] = { //(5) val httpFlowSettings = ConnectionPoolSettings(actorSystem) logger.debug(s"Creating http flow with settings $httpFlowSettings") Http().cachedHostConnectionPool[ProfileIds]( config.getString("scoreService.host"), config.getInt("scoreService.int"), settings = httpFlowSettings ) } }</span></span></code> </pre><br><ol><li>     ,   ,       ,     . </li><li>    ActorSystem   . </li><li>  ,     ,    ActorSystem,       terminate, ,   ,   ,     .      ,     JVM-. </li><li>    ActorMaterializer,      akka-streams,   ActorSystem. </li><li> ,   httpFlow     .      ,       HTTP-   ActorSystem. </li></ol><br>       Subscriber-    HTTP-. <br><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueueItem</span></span></span><span class="hljs-class">[+</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Item</span></span></span><span class="hljs-class">[+</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">item: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">T</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueueItem</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">object</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Done</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueueItem</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nothing</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">case</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Failure</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">cause: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">QueueItem</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Nothing</span></span></span><span class="hljs-class">] </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">1</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StreamErrorCompletionException</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">cause: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Throwable</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Exception</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">cause</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">//</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">2</span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IteratorSubscriber</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">](</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">requestSize: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Iterable</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">]] </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">with</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Iterator</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//(3) private val buffer: BlockingQueue[QueueItem[Iterable[T]]] = new LinkedBlockingQueue[QueueItem[Iterable[T]]]() //(4) private var expecting: Int = 0 //(5) private val subscriptionPromise: Promise[Subscription] = Promise() private lazy val subscription: Subscription = Await.result(subscriptionPromise.future, 5.minutes) //(6) private var currentIterator: Iterator[T] = Iterator.empty //(7) private var isDone = false //(8) override def onSubscribe(s: Subscription): Unit = { subscriptionPromise.success(s) //(9) logger.trace("The iterator has been subscribed") } override def onNext(t: Iterable[T]): Unit = { logger.trace("Putting a next batch to the buffer") buffer.put(Item(t)) //(10) } override def onComplete(): Unit = { logger.debug("The stream has been succesfully completed") buffer.put(Done) //(11) } override def onError(t: Throwable): Unit = { logger.warn("The stream has been completed with error", t) buffer.put(Failure(t)) //(12) } override def hasNext: Boolean = { logger.trace("Asking hasNext") if (currentIterator.hasNext) { //(13) true } else if (isDone) { //(14) false } else { if (expecting &lt; requestSize) { requestNextBatches() //(15) } buffer.take() match { //(16) case Item(batch) =&gt; currentIterator = batch.iterator expecting -= 1 this.hasNext //(17) case Done =&gt; isDone = true false //(18) case Failure(exception) =&gt; throw new StreamErrorCompletionException(exception) //(19) } } } override def next(): T = { val out = currentIterator.next() logger.trace("The next element is {}", out) out //(20) } private def requestNextBatches(): Unit = { logger.debug(s"Requesting {} batches", requestSize) subscription.request(requestSize) expecting += requestSize //(21) } }</span></span></code> </pre><br>  IteratorSubscriber    Producer-Consumer.   ,    Subscriber,  Producer-,  ,   Iterator, – Consumer-.      ,     .    Iterator       Apache Spark,    Subscriber –  ,  ActorSystem. <br><br>      IteratorSubscriber  . <br><br><ol><li>          .          ,     Done,    ,  Throwable,    . </li><li>      ,        hasNext    . </li><li>  ,    ,        Publisher-. </li><li>    ,     .    LinkedBlockingQueue,      . ,         . </li><li>     ,    .     ,         ,       Publisher-.   ,    ,      Publisher-   .         hasNext  next ( requestNextBatches    hasNext),       ,       . </li><li>  subscriptionPromise  subscription     Subscription,    Publisher    onSubscribe. ,    Reactive Streams        Subscriber-  Publisher-     ,   ,   hasNext   ,  onSubscribe.      ,     subscription,          Publisher-.     lazy   subscription,    Promise. </li><li>       .          hasNext  next,     ,       . </li><li>     ,        ,  hasNext   false     .           hasNext,         . </li><li>    onSubscribe    Publisher-  Subscription    Promise,        subscription. </li><li> onNext  Publisher-,        .      . </li><li>       Publisher   onComplete,          Done. </li><li>    Publisher   onError.       . </li><li>    hasNext     ,      .      ,    true,       .     ,         . </li><li>        ,            false. </li><li>  ,   ,        requestSize,       Publisher.         ,    ,     ,   Publisher-    ,   HTTP-     . </li><li>        .  ,   ,      ,      .  ,       ,     (  ,    ,        subscription), ,     ,   ,      . </li><li>       ,           currentIterator.        ,          . ,       hasNext  ,         (    ,   ),        . </li><li>     ,    false        hasNext. ,     isDone,   ,     .   - ,   hasNext        ,         false.        ,       hasNext  ,    false      ,      .          ,      . </li><li>        ,    ,     ,     . </li><li>  next      .    ,        hasNext,    next        . </li><li>     Publisher-  ,       ,   subscription,       Publisher-.     requestSize.         . </li></ol><br>  ,       ,   ,   : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6m/bg/fu/6mbgfuuatqlimwnapnl3tlrzn8q.png"></div> <i> 8.       .</i> <br><br><h3>  :      </h3><br>      ,        ,      .     ,       HTTP ,      .         . <br><br>    –         .    ,     ,       Hadoop ,      .  ,    ,       -       .     ,  ,   hdfs, ,          , ,       . <br><br>  ,         . ,   akka-http              ,         .   ,      -,       -       Apache Spark ,       ,  ,    -. <br><br> ,   ,         .   ,   ,        http-,          ,     . <br><br>          ,         .  ,        ,    .     ,   .  ,         . <br><br>                ,    . ,  ,    Hadoop    ,           ,     . <br><br>  ,  ,  Hadoop-    ,     ,         . <br><br>  ,  ,          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CleverDATA</a> .                      .  ,  ,     ,  ,    ,            .  ,            . <br><br><div class="spoiler"> <b class="spoiler_title">,      .</b> <div class="spoiler_text"><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Développeur Java</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ingénieur système</font></font></a> </li></ul><br></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr413141/">https://habr.com/ru/post/fr413141/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr413129/index.html">25 erreurs d'un programmeur débutant</a></li>
<li><a href="../fr413133/index.html">Antipatterns populaires: pagination</a></li>
<li><a href="../fr413135/index.html">Mission de test de révision de code des développeurs juniors de React</a></li>
<li><a href="../fr413137/index.html">Classer de grandes quantités de données sur Apache Spark à l'aide de modèles d'apprentissage automatique arbitraires</a></li>
<li><a href="../fr413139/index.html">Voitures électriques: la révolution arrive</a></li>
<li><a href="../fr413143/index.html">Bobby Urban Lite: le nouveau sac à dos urbain de XD Design</a></li>
<li><a href="../fr413145/index.html">Un analyste aide les entreprises à gagner de l'argent</a></li>
<li><a href="../fr413147/index.html">Est-il possible d'utiliser Tibero au lieu d'Oracle. Et est-ce nécessaire</a></li>
<li><a href="../fr413149/index.html">Entrepôt de données distribué dans le concept Data Lake: par où commencer</a></li>
<li><a href="../fr413151/index.html">La NSA a proposé une norme de chiffrement pour les appareils IoT, mais l'ISO l'a rejetée</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>