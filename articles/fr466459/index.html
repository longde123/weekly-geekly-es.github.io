<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👮 🐔 🏇🏾 Tests d'intégration parallèle Postgresql dans l'application GO 😇 🆙 🐠</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Les tests d'intégration sont l'un des niveaux de la pyramide des tests . Ils nécessitent généralement plus de temps, car en eux, nous ne remplaçons ri...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tests d'intégration parallèle Postgresql dans l'application GO</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466459/"><img src="https://habrastorage.org/webt/zj/wu/-i/zjwu-izj7zhrdl1oabereu-kiuy.png"><br>  Les tests d'intégration sont l'un des niveaux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de la pyramide des tests</a> .  Ils nécessitent généralement plus de temps, car  en eux, nous ne remplaçons rien par des simulations de composants réels.  Pour réduire le temps de tels tests, nous pouvons les exécuter en parallèle.  Ici, je vais parler spécifiquement de ces tests pour Postgresql. <br><br>  Idéalement, chaque test devrait être indépendant, afin qu'ils ne s'influencent pas mutuellement.  En d'autres termes, chaque fonction de test a son propre état.  C'est un bon signe pour utiliser des tests parallèles.  Pour obtenir mon ensemble de données personnelles pour chaque fonction de test, j'ai créé une fonction qui, lors du démarrage d'un test, crée un circuit temporaire, y charge des données et détruit le circuit une fois le test terminé.  Chaque <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">schéma</a> créé contient un hachage dans le nom pour éviter les conflits de nom. <br><a name="habracut"></a><br><br><h3>  Fonction d'assistance </h3><br>  Commençons par une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">fonction d'aide</a> pour afficher les erreurs dans les tests.  J'ai pris les fonctions d'assistance de Ben Johnson (Ben Johnson), ce qui m'a aidé à enregistrer quelques lignes de code et à rendre mes erreurs plus claires et détaillées. <br><br><h3>  Données de test </h3><br>  Pour exécuter le test d'intégration de la base de données, des données de test doivent être fournies.  L'outil de test Go a une bonne prise en charge pour le chargement des données de test à partir de fichiers.  Tout d'abord, allez créer des dossiers ignorés appelés "testdata".  Deuxièmement, lorsque vous exécutez «go test», il change le dossier actuel en dossier de package.  Cela vous permet d'utiliser le chemin d'accès relatif au dossier testdata pour charger l'ensemble de données de test. <br><br><h3>  Création d'une connexion à la base de données pour le test </h3><br><pre><code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> database <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"math/rand"</span></span> <span class="hljs-string"><span class="hljs-string">"strconv"</span></span> <span class="hljs-string"><span class="hljs-string">"testing"</span></span> <span class="hljs-string"><span class="hljs-string">"time"</span></span> _ <span class="hljs-string"><span class="hljs-string">"github.com/lib/pq"</span></span> <span class="hljs-string"><span class="hljs-string">"database/sql"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( dbPort = <span class="hljs-number"><span class="hljs-number">5439</span></span> dbUser = <span class="hljs-string"><span class="hljs-string">"postgres"</span></span> dbPassword = <span class="hljs-string"><span class="hljs-string">"postgres"</span></span> dbName = <span class="hljs-string"><span class="hljs-string">"test"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateTestDatabase</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(t *testing.T)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*sql.DB, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">)</span></span> { connectionString := fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"port=%d user=%s password=%s dbname=%s sslmode=disable"</span></span>, dbPort, dbUser, dbPassword, dbName) db, dbErr := sql.Open(<span class="hljs-string"><span class="hljs-string">"postgres"</span></span>, connectionString) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> dbErr != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { t.Fatalf(<span class="hljs-string"><span class="hljs-string">"Fail to create database. %s"</span></span>, dbErr.Error()) } rand.Seed(time.Now().UnixNano()) schemaName := <span class="hljs-string"><span class="hljs-string">"test"</span></span> + strconv.FormatInt(rand.Int63(), <span class="hljs-number"><span class="hljs-number">10</span></span>) _, err := db.Exec(<span class="hljs-string"><span class="hljs-string">"CREATE SCHEMA "</span></span> + schemaName) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { t.Fatalf(<span class="hljs-string"><span class="hljs-string">"Fail to create schema. %s"</span></span>, err.Error()) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> db, schemaName, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { _, err := db.Exec(<span class="hljs-string"><span class="hljs-string">"DROP SCHEMA "</span></span> + schemaName + <span class="hljs-string"><span class="hljs-string">" CASCADE"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { t.Fatalf(<span class="hljs-string"><span class="hljs-string">"Fail to drop database. %s"</span></span>, err.Error()) } } }</code> </pre> <br><br>  Appel de «CreateTestDatabase» pour créer une connexion à la base de données de test et créer un nouveau schéma de données pour les tests.  Cette fonction renvoie la connexion à la base de données, le nom du schéma créé et la fonction de purge pour supprimer ce schéma.  Pour un test, il vaut mieux échouer le test que renvoyer une erreur à l'appelant.  (Remarque: le retour de la fonction de nettoyage est basé sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les tests avancés de Mitchell Hashimoto avec Go Talk</a> ). <br><br><h3>  Télécharger le jeu de données de test </h3><br>  J'ai utilisé les fichiers «.sql».  Un (1) sql contient des données pour une (1) table.  Cela inclut la création d'une table et son remplissage avec des données.  Tous les fichiers sql sont stockés dans le dossier «testdata».  Voici un exemple de fichier sql. <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> book ( title <span class="hljs-built_in"><span class="hljs-built_in">character</span></span> <span class="hljs-built_in"><span class="hljs-built_in">varying</span></span>(<span class="hljs-number"><span class="hljs-number">50</span></span>), author <span class="hljs-built_in"><span class="hljs-built_in">character</span></span> <span class="hljs-built_in"><span class="hljs-built_in">varying</span></span>(<span class="hljs-number"><span class="hljs-number">50</span></span>) ); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> book <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'First Book'</span></span>,<span class="hljs-string"><span class="hljs-string">'First Author'</span></span>), (<span class="hljs-string"><span class="hljs-string">'Second Book'</span></span>,<span class="hljs-string"><span class="hljs-string">'Second Author'</span></span>) ;</code> </pre> <br>  Et voici la partie complexe.  Parce que chaque fonction s'exécute dans son propre schéma de données unique, nous ne pouvons pas simplement exécuter (écrire) une requête dans ces fichiers sql.  Nous devons spécifier le schéma avant les noms de table afin de créer une table ou insérer des données dans le schéma temporaire souhaité.  Par exemple, le livre CREATE TABLE ... doit être écrit comme CREATE TABLE uniqueschema.book ... et le livre INSERT INTO ... doit être changé en INSERT INTO uniqueschema.book ....  J'ai utilisé des expressions régulières pour modifier les requêtes avant de les exécuter.  Voici le code de téléchargement des données de test: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> datalayer <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"bufio"</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"io"</span></span> <span class="hljs-string"><span class="hljs-string">"os"</span></span> <span class="hljs-string"><span class="hljs-string">"regexp"</span></span> <span class="hljs-string"><span class="hljs-string">"testing"</span></span> <span class="hljs-string"><span class="hljs-string">"database/sql"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/Hendra-Huang/databaseintegrationtest/testingutil"</span></span> <span class="hljs-comment"><span class="hljs-comment">//     (   ,  79) ) //        var schemaPrefixRegexps = [...]*regexp.Regexp{ regexp.MustCompile(`(?i)(^CREATE SEQUENCE\s)(["\w]+)(.*)`), regexp.MustCompile(`(?i)(^CREATE TABLE\s)(["\w]+)(\s.+)`), regexp.MustCompile(`(?i)(^ALTER TABLE\s)(["\w]+)(\s.+)`), regexp.MustCompile(`(?i)(^UPDATE\s)(["\w]+)(\s.+)`), regexp.MustCompile(`(?i)(^INSERT INTO\s)(["\w]+)(\s.+)`), regexp.MustCompile(`(?i)(^DELETE FROM\s)(["\w]+)(.*)`), regexp.MustCompile(`(?i)(.+\sFROM\s)(["\w]+)(.*)`), regexp.MustCompile(`(?i)(\sJOIN\s)(["\w]+)(.*)`), } //      func addSchemaPrefix(schemaName, query string) string { prefixedQuery := query for _, re := range schemaPrefixRegexps { prefixedQuery = re.ReplaceAllString(prefixedQuery, fmt.Sprintf("${1}%s.${2}${3}", schemaName)) } return prefixedQuery } func loadTestData(t *testing.T, db *sql.DB, schemaName string, testDataNames ...string) { for _, testDataName := range testDataNames { file, err := os.Open(fmt.Sprintf("./testdata/%s.sql", testDataName)) testingutil.Ok(t, err) reader := bufio.NewReader(file) var query string for { line, err := reader.ReadString('\n') if err == io.EOF { break } testingutil.Ok(t, err) line = line[:len(line)-1] if line == "" { query = addSchemaPrefix(schemaName, query) _, err := db.Exec(query) testingutil.Ok(t, err) query = "" } query += line } file.Close() } }</span></span></code> </pre> <br><br><h3>  Création de test </h3><br>  Avant de commencer chaque test, une base de données de test sera créée avec un nom unique pour le schéma et l'exécution de la fonction de nettoyage sera retardée pour supprimer ce schéma.  Le nom du schéma sera inséré dans la demande du test.  La chose la plus importante dans cette implémentation est que la connexion à la base de données doit être personnalisable pour changer la connexion de la base de données réelle à la connexion à la base de données de test.  Ajoutez «t.Parallel ()» au début de chaque fonction de test pour indiquer à l'environnement de test la nécessité d'exécuter ce test en parallèle. <br>  Voici le code complet: <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//            "integration" (. build flags) // +build integration package datalayer import ( "context" "testing" "github.com/Hendra-Huang/databaseintegrationtest/database" "github.com/Hendra-Huang/databaseintegrationtest/testingutil" ) func TestInsertBook(t *testing.T) { t.Parallel() db, schemaName, cleanup := database.CreateTestDatabase(t) defer cleanup() loadTestData(t, db, schemaName, "book") // will load data which the filename is book title := "New title" author := "New author" // those 2 lines code below are not a good practice // but it is intentional to keep the focus only on integration test part // the important part is database connection has to be configurable insertBookQuery = addSchemaPrefix(schemaName, insertBookQuery) // override the query and add schema to the query err := InsertBook(context.Background(), db, title, author) // will execute insertBookQuery with the provided connection testingutil.Ok(t, err) } func TestGetBooks(t *testing.T) { t.Parallel() db, schemaName, cleanup := database.CreateTestDatabase(t) defer cleanup() loadTestData(t, db, schemaName, "book") getBooksQuery = addSchemaPrefix(schemaName, getBooksQuery) books, err := GetBooks(context.Background(), db) testingutil.Ok(t, err) testingutil.Equals(t, 2, len(books)) }</span></span></code> </pre> <br><br>  <i>Remarque: Sous «TestGetBooks», je suppose que la requête renverra 2 livres, comme</i>  <i>J'ai donné tellement de données de test dans «testdata / book.sql» bien qu'il y ait un test d'insertion ci-dessus.</i>  <i>Si nous ne partageons pas le circuit entre les deux tests, «TestGetBooks» échouera, car</i>  <i>maintenant 3 lignes dans le tableau, 2 du test, 1 de l'insert de test ci-dessus.</i>  <i>C'est l'avantage de circuits séparés pour les tests - leurs données sont indépendantes, et donc les tests sont indépendants les uns des autres.</i> <br><br>  L'exemple de projet que j'ai posté ici <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github</a> .  Vous pouvez le copier pour vous-même, exécuter le test et voir le résultat. <br><br><h3>  Conclusion </h3><br>  Pour mon projet, cette approche réduit le temps de test de 40 à 50% par rapport aux tests séquentiels.  Un autre avantage de l'exécution de tests en parallèle est que nous pouvons éviter certaines erreurs qui peuvent se produire lorsqu'une application traite plusieurs actions concurrentielles. <br><br>  Bon test. <br><br>  - Photo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">medium.com/kongkow-it-medan/parallel-database-integration-test-on-go-application-8706b150ee2e</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr466459/">https://habr.com/ru/post/fr466459/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr466449/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 44. Introduction à OSPF</a></li>
<li><a href="../fr466451/index.html">Read_You can't_throw</a></li>
<li><a href="../fr466453/index.html">Formation Cisco 200-125 CCNA v3.0. Jour 45. Configuration d'OSPF</a></li>
<li><a href="../fr466455/index.html">Services, microservices et programmation orientée batch</a></li>
<li><a href="../fr466457/index.html">Agriculture et panneaux solaires - stratégie gagnant-gagnant pour les ingénieurs électriciens et les agriculteurs</a></li>
<li><a href="../fr466461/index.html">Sommet Zabbix 2019: à quoi s'attendre cette année</a></li>
<li><a href="../fr466463/index.html">Comment nous avons créé un prototype d'application de réparation d'arrêt</a></li>
<li><a href="../fr466465/index.html">Summ3r 0f H4ck 2019: résultats de recherche</a></li>
<li><a href="../fr466467/index.html">Prise en charge des jetons jwt anonymes dans IdentityServer4 utilisant AnonymousIdentity</a></li>
<li><a href="../fr466473/index.html">Comment nous avons créé le système IoT pour gérer la consommation d'énergie solaire</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>