<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🖐🏽 👩‍👦‍👦 🕺🏻 OS1: kernel primitif di Rust untuk x86. Bagian 2. VGA, GDT, IDT 🕙 💨 🧘🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagian pertama 


 Artikel pertama belum punya waktu untuk menenangkan, tetapi saya memutuskan untuk tidak membuat Anda tertarik dan menulis sekuel. 
...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OS1: kernel primitif di Rust untuk x86. Bagian 2. VGA, GDT, IDT</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/445584/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian pertama</a> </p><br><p>  Artikel pertama belum punya waktu untuk menenangkan, tetapi saya memutuskan untuk tidak membuat Anda tertarik dan menulis sekuel. </p><br><p>  Jadi, pada artikel sebelumnya kita berbicara tentang menautkan, memuat file kernel, dan inisialisasi primer.  Saya memberikan beberapa tautan bermanfaat, memberi tahu bagaimana kernel yang dimuat terletak di memori, bagaimana alamat virtual dan fisik dibandingkan pada saat boot, dan bagaimana mengaktifkan dukungan untuk mekanisme halaman.  Terakhir, kontrol diteruskan ke fungsi kmain dari kernel saya, yang ditulis dalam Rust.  Saatnya untuk melanjutkan dan mencari tahu seberapa dalam lubang kelinci! </p><br><p>  Pada bagian catatan ini, saya <strong>akan menjelaskan secara singkat konfigurasi Rust saya, secara umum saya akan berbicara tentang output informasi dalam VGA, dan secara rinci tentang pengaturan segmen dan interupsi</strong> .  Saya meminta semua yang tertarik di bawah potongan, dan kami mulai. </p><a name="habracut"></a><br><h1 id="nastroyka-rust">  Setup karat </h1><br><p> Secara umum, tidak ada yang rumit dalam prosedur ini, untuk detail Anda dapat menghubungi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blog Philippe</a> .  Namun, saya akan berhenti di beberapa titik. </p><br><p>  Stable Rust masih tidak mendukung beberapa fitur yang diperlukan untuk pengembangan tingkat rendah, oleh karena itu, untuk menonaktifkan perpustakaan standar dan membangun di Bare Bones, kita perlu Rust malam.  Hati-hati, sekali setelah memperbarui ke terbaru saya mendapat kompiler yang benar-benar tidak beroperasi dan harus memutar kembali ke yang stabil terdekat.  Jika Anda yakin bahwa kompiler Anda berfungsi kemarin, tetapi diperbarui dan tidak berfungsi, jalankan perintah, gantilah tanggal yang Anda butuhkan </p><br><pre><code class="plaintext hljs">rustup override add nightly-YYYY-MM-DD</code> </pre> <br><p>  Untuk detail mekanisme, Anda dapat menghubungi di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p>  Selanjutnya, konfigurasikan platform target yang akan kita tuju.  Saya berdasarkan pada blog Philip Opperman, begitu banyak hal dalam bagian ini diambil darinya, dibongkar oleh tulang dan disesuaikan dengan kebutuhan saya.  Philip mengembangkan untuk x64 di blog-nya, saya awalnya memilih x32, jadi target.json saya akan sedikit berbeda.  Saya membawanya sepenuhnya </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"llvm-target"</span></span>: <span class="hljs-string"><span class="hljs-string">"i686-unknown-none"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"data-layout"</span></span>: <span class="hljs-string"><span class="hljs-string">"em:ep:32:32-f64:32:64-f80:32-n8:16:32-S128"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"arch"</span></span>: <span class="hljs-string"><span class="hljs-string">"x86"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target-endian"</span></span>: <span class="hljs-string"><span class="hljs-string">"little"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target-pointer-width"</span></span>: <span class="hljs-string"><span class="hljs-string">"32"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"target-c-int-width"</span></span>: <span class="hljs-string"><span class="hljs-string">"32"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"os"</span></span>: <span class="hljs-string"><span class="hljs-string">"none"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"executables"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"linker-flavor"</span></span>: <span class="hljs-string"><span class="hljs-string">"ld.lld"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"linker"</span></span>: <span class="hljs-string"><span class="hljs-string">"rust-lld"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"panic-strategy"</span></span>: <span class="hljs-string"><span class="hljs-string">"abort"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"disable-redzone"</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">"features"</span></span>: <span class="hljs-string"><span class="hljs-string">"-mmx,-sse,+soft-float"</span></span> }</code> </pre> <br><p>  Bagian tersulit di sini adalah parameter " <strong>data-layout</strong> ".  Dokumentasi LLVM memberi tahu kita bahwa ini adalah opsi tata letak data, dipisahkan oleh “-”.  Karakter “e” pertama bertanggung jawab untuk keindonesiaan - dalam kasus kami ini adalah little-endian, seperti yang dibutuhkan oleh platform.  Karakter kedua adalah m, "distorsi".  Bertanggung jawab atas nama karakter selama tata letak.  Karena format output kami adalah ELF (lihat skrip pembuatan), kami memilih "m: e".  Karakter ketiga adalah ukuran pointer dalam bit dan ABI (Application binary interface).  Semuanya sederhana di sini, kami memiliki 32 bit, jadi kami dengan berani menempatkan "p: 32: 32".  Selanjutnya adalah angka floating point.  Kami melaporkan bahwa kami mendukung angka 64-bit sesuai dengan ABI 32 dengan perataan 64 - "f64: 32: 64", serta angka 80-bit dengan perataan secara default - "f80: 32".  Elemen selanjutnya adalah bilangan bulat.  Kami mulai dengan 8 bit dan pindah ke platform maksimum 32 bit - "n8: 16: 32".  Yang terakhir adalah penjajaran tumpukan.  Saya bahkan perlu integer 128 bit, jadi biarlah S128.  Bagaimanapun, LLVM dapat dengan aman mengabaikan parameter ini, ini adalah preferensi kami. </p><br><p>  Mengenai parameter yang tersisa, Anda bisa mengintip Philip, ia menjelaskan semuanya dengan baik. </p><br><p>  Kami juga membutuhkan kargo-xbuild - alat yang memungkinkan Anda melakukan kompilasi silang-inti saat membangun di bawah platform target yang tidak dikenal. <br>  Instal. </p><br><pre> <code class="bash hljs">cargo install cargo-xbuild</code> </pre> <br><p>  Kami akan mengumpulkannya seperti ini. </p><br><pre> <code class="bash hljs">cargo xbuild -Z unstable-options --manifest-path=kernel/Cargo.toml --target kernel/targets/$(ARCH).json --out-dir=build/lib</code> </pre> <br><p>  Saya membutuhkan manifes untuk operasi Make yang benar, karena ini dimulai dari direktori root, dan kernel terletak di direktori kernel. </p><br><p>  Dari fitur manifes, saya hanya dapat menyorot <em>crate-type = ["staticlib"]</em> , yang memberikan file yang dapat <em>ditautkan</em> ke output.  Kami akan memberinya makan di LLD. </p><br><h1 id="kmain-i-pervonachalnaya-nastroyka">  kmain dan pengaturan awal </h1><br><p>  Menurut konvensi Rust, jika kita membuat pustaka statis (atau file biner "flat"), root dari peti harus berisi file lib.rs, yang merupakan titik masuk.  Di dalamnya, dengan bantuan atribut, fitur bahasa dikonfigurasikan, dan juga kmain berharga terletak. </p><br><p>  Jadi, pada langkah pertama kita perlu menonaktifkan perpustakaan std.  Ini dilakukan dengan makro. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#![no_std]</span></span></code> </pre> <br><p>  Dengan langkah sederhana ini, kami segera melupakan multithreading, memori dinamis, dan kesenangan lain dari perpustakaan standar.  Selain itu, kami bahkan menghilangkan println !, makro, jadi kami harus menerapkannya sendiri.  Saya akan memberi tahu Anda cara melakukannya lain kali. </p><br><p>  Banyak tutorial di suatu tempat di tempat ini berakhir dengan output dari "Hello World" dan tanpa menjelaskan bagaimana hidup.  Kami akan pergi ke arah lain.  Pertama-tama, kita perlu mengatur kode dan segmen data untuk mode terproteksi, mengkonfigurasi VGA, mengkonfigurasi interupsi, yang akan kita lakukan. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#![no_std]</span></span> <span class="hljs-meta"><span class="hljs-meta">#[macro_use]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> debug; <span class="hljs-meta"><span class="hljs-meta">#[cfg(target_arch = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"x86"</span></span></span><span class="hljs-meta">)]</span></span> <span class="hljs-meta"><span class="hljs-meta">#[path = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"arch/i686/mod.rs"</span></span></span><span class="hljs-meta">]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mod</span></span> arch; <span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-string"><span class="hljs-string">"C"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kmain</span></span></span></span>(pd: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, mb_pointer: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, mb_magic: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { arch::arch_init(pd); ...... } <span class="hljs-meta"><span class="hljs-meta">#[panic_handler]</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">panic</span></span></span></span>(_info: &amp;PanicInfo) -&gt; ! { <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"{}"</span></span>, _info); <span class="hljs-keyword"><span class="hljs-keyword">loop</span></span> {} }</code> </pre> <br><p>  Apa yang sedang terjadi di sini?  Seperti yang saya katakan, kami mematikan perpustakaan standar.  Kami juga akan mengumumkan dua modul yang sangat penting - debug (di mana kami akan menulis di layar) dan lengkungan (di mana semua sihir yang bergantung pada platform akan hidup).  Saya menggunakan fitur Rust dengan konfigurasi untuk mendeklarasikan antarmuka yang sama dalam implementasi arsitektur yang berbeda dan menggunakannya secara maksimal.  Di sini saya berhenti hanya pada x86 dan kemudian kita hanya membicarakannya. </p><br><p>  Saya menyatakan penangan panik yang benar-benar primitif, yang dituntut oleh Rust.  Maka akan dimungkinkan untuk memodifikasinya. </p><br><p>  kmain menerima tiga argumen dan juga diekspor dalam notasi C tanpa distorsi nama sehingga linker dapat dengan benar mengaitkan fungsi dengan panggilan dari _loader, yang saya jelaskan di artikel sebelumnya.  Argumen pertama adalah alamat tabel halaman PD, yang kedua adalah alamat <strong>fisik</strong> struktur GRUB, dari mana kita akan mendapatkan kartu memori, yang ketiga adalah angka ajaib.  Di masa depan, saya ingin mengimplementasikan dukungan Multiboot 2 dan bootloader saya sendiri, jadi saya menggunakan angka ajaib untuk mengidentifikasi metode boot. </p><br><p>  Panggilan kmain pertama adalah inisialisasi platform khusus.  Kami masuk ke dalam.  Fungsi arch_init terletak di file arch / i686 / mod.rs, bersifat publik, 32-bit x86-spesifik, dan terlihat seperti ini: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">arch_init</span></span></span></span>(pd: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { vga::VGA_WRITER.lock().init(); gdt::setup_gdt(); idt::init_idt(); paging::setup_pd(pd); } }</code> </pre> <br><p>  Seperti yang Anda lihat, untuk x86, output, segmentasi, interupsi, dan paging diinisialisasi secara berurutan.  Mari kita mulai dengan VGA. </p><br><h1 id="inicializaciya-vga">  Inisialisasi VGA </h1><br><p>  Setiap tutorial menganggap itu tugas mereka untuk mencetak Hello World, sehingga Anda akan menemukan cara bekerja dengan VGA di mana-mana.  Untuk alasan ini, saya akan pergi sesingkat mungkin, saya akan fokus hanya pada chip yang saya buat sendiri.  Tentang penggunaan lazy_static, saya akan mengirim Anda ke blog Philippe dan tidak akan menjelaskan secara detail.  const fn belum dirilis, jadi inisialisasi statis yang indah belum dapat dilakukan.  Dan kami akan menambahkan kunci putar sehingga tidak menjadi berantakan. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> lazy_static::lazy_static; <span class="hljs-keyword"><span class="hljs-keyword">use</span></span> spin::Mutex; lazy_static! { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> VGA_WRITER : Mutex&lt;Writer&gt; = Mutex::new(Writer { cursor_position: <span class="hljs-number"><span class="hljs-number">0</span></span>, vga_color: ColorCode::new(Color::LightGray, Color::Black), buffer: <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> *(<span class="hljs-number"><span class="hljs-number">0xC00B8000</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> VgaBuffer) } }); }</code> </pre> <br><p>  Seperti yang Anda ketahui, buffer layar terletak di alamat fisik 0xB8000 dan memiliki ukuran 80x25x2 byte (lebar dan tinggi layar, byte per karakter dan atribut: warna, flicker).  Karena kami telah mengaktifkan memori virtual, mengakses alamat ini akan macet, jadi kami menambahkan 3 GB.  Kami juga melakukan penunjuk pointer mentah, yang tidak aman - tapi kami tahu apa yang kami lakukan. <br>  Dari hal-hal menarik dalam file ini, mungkin, hanya penerapan struktur Writer, yang memungkinkan tidak hanya untuk menampilkan karakter dalam satu baris, tetapi juga untuk menggulir, pergi ke setiap tempat di layar dan hal-hal sepele yang menyenangkan lainnya. </p><br><div class="spoiler">  <b class="spoiler_title">Penulis Vga</b> <div class="spoiler_text"><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Writer</span></span></span></span> { cursor_position: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, vga_color: ColorCode, buffer: &amp;<span class="hljs-symbol"><span class="hljs-symbol">'static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> VgaBuffer, } <span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Writer { <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">init</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vga_color = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.vga_color; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..(VGA_HEIGHT - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..VGA_WIDTH { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.buffer.chars[y * VGA_WIDTH + x] = ScreenChar { ascii_character: <span class="hljs-string"><span class="hljs-string">b' '</span></span>, color_code: vga_color, } } } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set_cursor_abs(<span class="hljs-number"><span class="hljs-number">0</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_cursor_abs</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, position: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> { outb(<span class="hljs-number"><span class="hljs-number">0x3D4</span></span>, <span class="hljs-number"><span class="hljs-number">0x0F</span></span>); outb(<span class="hljs-number"><span class="hljs-number">0x3D5</span></span>, (position &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>); outb(<span class="hljs-number"><span class="hljs-number">0x3D4</span></span>, <span class="hljs-number"><span class="hljs-number">0x0E</span></span>); outb(<span class="hljs-number"><span class="hljs-number">0x3D4</span></span>, ((position &gt;&gt; <span class="hljs-number"><span class="hljs-number">8</span></span>) &amp; <span class="hljs-number"><span class="hljs-number">0xFF</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position = position; } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">set_cursor</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, x: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set_cursor_abs(y * VGA_WIDTH + x); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">move_cursor</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, offset: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position + offset; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set_cursor_abs(<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_x</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> { (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position % VGA_WIDTH) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_y</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> { (<span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position / VGA_WIDTH) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">scroll</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..(VGA_HEIGHT - <span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..VGA_WIDTH { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.buffer.chars[y * VGA_WIDTH + x] = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.buffer.chars[(y + <span class="hljs-number"><span class="hljs-number">1</span></span>) * VGA_WIDTH + x] } } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>..VGA_WIDTH { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> color_code = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.vga_color; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.buffer.chars[(VGA_HEIGHT - <span class="hljs-number"><span class="hljs-number">1</span></span>) * VGA_WIDTH + x] = ScreenChar { ascii_character: <span class="hljs-string"><span class="hljs-string">b' '</span></span>, color_code } } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ln</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> next_line = <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.get_y() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> next_line &gt;= VGA_HEIGHT { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.scroll(); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set_cursor(<span class="hljs-number"><span class="hljs-number">0</span></span>, VGA_HEIGHT - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set_cursor(<span class="hljs-number"><span class="hljs-number">0</span></span>, next_line) } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_byte_at_xy</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, byte: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>, color: ColorCode, x: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>, y: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.buffer.chars[y * VGA_WIDTH + x] = ScreenChar { ascii_character: byte, color_code: color } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_byte_at_pos</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, byte: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>, color: ColorCode, position: <span class="hljs-built_in"><span class="hljs-built_in">usize</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.buffer.chars[position] = ScreenChar { ascii_character: byte, color_code: color } } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_byte</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, byte: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position &gt;= VGA_WIDTH * VGA_HEIGHT { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.scroll(); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.set_cursor(<span class="hljs-number"><span class="hljs-number">0</span></span>, VGA_HEIGHT - <span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.write_byte_at_pos(byte, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.vga_color, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.cursor_position); <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.move_cursor(<span class="hljs-number"><span class="hljs-number">1</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_string</span></span></span></span>(&amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, s: &amp;<span class="hljs-built_in"><span class="hljs-built_in">str</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> byte <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> s.bytes() { <span class="hljs-keyword"><span class="hljs-keyword">match</span></span> byte { <span class="hljs-number"><span class="hljs-number">0x20</span></span>...<span class="hljs-number"><span class="hljs-number">0xFF</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.write_byte(byte), <span class="hljs-string"><span class="hljs-string">b'\n'</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.ln(), _ =&gt; <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.write_byte(<span class="hljs-number"><span class="hljs-number">0xfe</span></span>), } } } }</code> </pre> </div></div><br><p>  Saat memutar, cukup salin bagian memori ukuran lebar layar ke belakang, dengan mengisi baris baru (ini adalah cara saya melakukan pembersihan).  Panggilan outb sedikit lebih menarik - tidak lain daripada bekerja dengan port I / O tidak mungkin untuk memindahkan kursor.  Namun, kami masih membutuhkan input / output melalui port, sehingga mereka dikirim dalam paket terpisah dan dibungkus dengan pembungkus yang aman.  Di bawah spoiler di bawah ini adalah kode assembler.  Untuk saat ini, cukup mengetahui bahwa: </p><br><ul><li>  Offset kursor absolut, bukan koordinat, ditampilkan. </li><li>  Anda dapat output ke controller satu byte pada suatu waktu </li><li>  Output dari satu byte terjadi dalam dua perintah - pertama kita menulis perintah ke controller, kemudian data. </li><li>  Port untuk perintah adalah 0x3D4, port data adalah 0x3D5 </li><li>  Pertama, cetak byte bawah posisi dengan perintah 0x0F, lalu atas dengan perintah 0x0E </li></ul><br><div class="spoiler">  <b class="spoiler_title">keluar</b> <div class="spoiler_text"><p>  Perhatikan bekerja dengan variabel lulus pada stack.  Karena tumpukan dimulai pada akhir ruang dan mengurangi penunjuk tumpukan saat memanggil fungsi, untuk mendapatkan parameter, titik kembali, dll., Anda perlu menambahkan ukuran argumen yang disejajarkan dengan penyelarasan tumpukan ke register ESP, dalam kasus kami 4 byte. </p><br><pre> <code class="plaintext hljs">global writeb global writew global writed section .text writeb: push ebp mov ebp, esp mov edx, [ebp + 8] ;port in stack: 8 = 4 (push ebp) + 4 (parameter port length is 2 bytes but stack aligned 4 bytes) mov eax, [ebp + 8 + 4] ;value in stack - 8 = see ^, 4 = 1 byte value aligned 4 bytes out dx, al ;write byte by port number an dx - value in al mov esp, ebp pop ebp ret writew: push ebp mov ebp, esp mov edx, [ebp + 8] ;port in stack: 8 = 4 (push ebp) + 4 (parameter port length is 2 bytes but stack aligned 4 bytes) mov eax, [ebp + 8 + 4] ;value in stack - 8 = see ^, 4 = 1 word value aligned 4 bytes out dx, ax ;write word by port number an dx - value in ax mov esp, ebp pop ebp ret writed: push ebp mov ebp, esp mov edx, [ebp + 8] ;port in stack: 8 = 4 (push ebp) + 4 (parameter port length is 2 bytes but stack aligned 4 bytes) mov eax, [ebp + 8 + 4] ;value in stack - 8 = see ^, 4 = 1 double word value aligned 4 bytes out dx, eax ;write double word by port number an dx - value in eax mov esp, ebp pop ebp ret</code> </pre> </div></div><br><h1 id="nastroyka-segmentov">  Pengaturan Segmen </h1><br><p>  Kami sampai pada yang paling membingungkan, tetapi pada saat yang sama topik paling sederhana.  Seperti yang saya katakan di artikel sebelumnya, organisasi memori halaman dan segmen dicampur di kepala saya, saya memuat alamat tabel halaman ke dalam GDTR dan meraih kepala saya.  Butuh beberapa bulan bagi saya untuk membaca materi itu dengan cukup, mencernanya dan dapat menyadarinya.  Saya mungkin telah menjadi korban Assembler buku teks Peter Abel.  Bahasa dan pemrograman untuk PC IBM ”(buku yang hebat!), Yang menjelaskan segmentasi untuk Intel 8086. Di masa-masa yang menyenangkan itu, kami memasukkan 16 bit teratas dari alamat dua puluh bit ke register segmen, dan itu adalah alamat dalam memori.  Ternyata menjadi kekecewaan yang kejam karena mulai dengan i286 dalam mode terproteksi, semuanya benar-benar salah. </p><br><p>  Jadi, teori telanjangnya adalah bahwa x86 mendukung model memori tersegmentasi, karena program yang lebih lama hanya dapat melampaui 640 KB, dan kemudian memori 1 MB. </p><br><p>  Programmer harus memikirkan cara menempatkan kode yang dapat dieksekusi, cara menempatkan data, dan cara menjaga keamanannya.  Munculnya organisasi halaman membuat organisasi tersegmentasi tidak perlu, tetapi tetap untuk tujuan kompatibilitas dan perlindungan (pemisahan hak istimewa untuk ruang kernel dan ruang pengguna), jadi tanpa itu tidak ada tempat.  Beberapa instruksi prosesor dilarang ketika level privilege lebih lemah dari 0, dan akses antara segmen program dan kernel akan menyebabkan kesalahan segmentasi. </p><br><p>  Mari kita lakukan lagi (semoga yang terakhir) tentang terjemahan alamat <br>  Alamat baris [0x08: 0xFFFFFFFF] -&gt; Verifikasi izin segmen 0x08 -&gt; Alamat virtual [0xFFFFFFFF] -&gt; Tabel halaman + TLB -&gt; Alamat fisik [0xAAAAFFFF] </p><br><p>  Segmen digunakan hanya di dalam prosesor, disimpan dalam register segmen khusus (CS, SS, DS, ES, FS, GS) dan digunakan secara eksklusif untuk memeriksa hak untuk mengeksekusi kode dan kontrol transfer.  Itulah sebabnya Anda tidak bisa hanya mengambil dan memanggil fungsi kernel dari ruang pengguna.  Segmen dengan deskriptor 0x18 (saya punya satu, Anda punya yang berbeda) memiliki hak level 3, dan segmen dengan deskriptor 0x08 memiliki hak level 0. Menurut konvensi x86, untuk melindungi terhadap akses tidak sah, segmen dengan sedikit hak istimewa tidak dapat secara langsung memanggil segmen dengan besar hak melalui jmp 0x08: [EAX], tetapi wajib menggunakan mekanisme lain, seperti jebakan, gerbang, interupsi. </p><br><p>  Segmen dan jenisnya (kode, data, tangga, gerbang) harus dijelaskan dalam tabel deskriptor global GDT, alamat <strong>virtual,</strong> dan ukurannya yang dimuat ke dalam register GDTR.  Saat beralih antar segmen (untuk kemudahan, saya berasumsi bahwa transisi langsung dimungkinkan), Anda harus menghubungi instruksi jmp 0x08: [EAX], di mana 0x08 adalah <strong>offset dari deskriptor yang valid pertama dalam byte dari awal tabel</strong> , dan EAX adalah register yang berisi alamat transisi.  Offset (pemilih) akan dimuat ke dalam register CS, dan deskriptor yang sesuai akan dimuat ke dalam register bayangan prosesor.  Setiap deskriptor adalah struktur 8 byte.  Ini didokumentasikan dengan baik dan deskripsinya dapat ditemukan di OSDev dan di dokumentasi Intel (lihat artikel pertama). </p><br><p>  Saya meringkas.  Ketika kita menginisialisasi GDT dan menjalankan transisi jmp 0x08: [EAX], status prosesor adalah sebagai berikut: </p><br><ul><li>  GDTR berisi alamat GDT <strong>virtual</strong> </li><li>  CS berisi nilai 0x08 </li><li>  Pegangan ke alamat [GDTR + 0x08] disalin ke register bayangan CS dari memori </li><li>  Register EIP berisi alamat dari register EAX </li></ul><br><p>  Deskriptor nol harus selalu tidak diinisialisasi dan akses ke sana dilarang.  Saya akan membahas deskriptor TSS dan artinya secara lebih rinci ketika kita membahas multithreading.  Tabel GDT saya sekarang terlihat seperti ini: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_gdt</span></span></span></span>(base: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GdtEntry, limit: <span class="hljs-built_in"><span class="hljs-built_in">u16</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup_gdt</span></span></span></span>() { GDT[<span class="hljs-number"><span class="hljs-number">5</span></span>].set_offset((&amp;super::tss::TSS) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>); GDT[<span class="hljs-number"><span class="hljs-number">5</span></span>].set_limit(core::mem::size_of::&lt;super::tss::Tss&gt;() <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u32</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> gdt_ptr: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> GdtEntry = GDT.as_ptr(); <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> limit = (GDT.len() * core::mem::size_of::&lt;GdtEntry&gt;() - <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-built_in"><span class="hljs-built_in">u16</span></span>; load_gdt(gdt_ptr, limit); } <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> GDT: [GdtEntry; <span class="hljs-number"><span class="hljs-number">7</span></span>] = [ <span class="hljs-comment"><span class="hljs-comment">//null descriptor - cannot access GdtEntry::new(0, 0, 0, 0), //kernel code GdtEntry::new(0, 0xFFFFFFFF, GDT_A_PRESENT | GDT_A_RING_0 | GDT_A_SYSTEM | GDT_A_EXECUTABLE | GDT_A_PRIVILEGE, GDT_F_PAGE_SIZE | GDT_F_PROTECTED_MODE), //kernel data GdtEntry::new(0, 0xFFFFFFFF, GDT_A_PRESENT | GDT_A_RING_0 | GDT_A_SYSTEM | GDT_A_PRIVILEGE, GDT_F_PAGE_SIZE | GDT_F_PROTECTED_MODE), //user code GdtEntry::new(0, 0xFFFFFFFF, GDT_A_PRESENT | GDT_A_RING_3 | GDT_A_SYSTEM | GDT_A_EXECUTABLE | GDT_A_PRIVILEGE, GDT_F_PAGE_SIZE | GDT_F_PROTECTED_MODE), //user data GdtEntry::new(0, 0xFFFFFFFF, GDT_A_PRESENT | GDT_A_RING_3 | GDT_A_SYSTEM | GDT_A_PRIVILEGE, GDT_F_PAGE_SIZE | GDT_F_PROTECTED_MODE), //TSS - for interrupt handling in multithreading GdtEntry::new(0, 0, GDT_A_PRESENT | GDT_A_RING_3 | GDT_A_TSS_AVAIL, 0), GdtEntry::new(0, 0, 0, 0), ];</span></span></code> </pre> <br><p>  Dan di sini adalah inisialisasi, yang saya bicarakan di atas.  Alamat dan ukuran pemuatan GDT dilakukan melalui struktur terpisah, yang hanya berisi dua bidang.  Alamat struktur ini diteruskan ke perintah lgdt.  Di register segmen data, muat deskriptor berikut dengan offset 0x10. </p><br><pre> <code class="plaintext hljs">global load_gdt section .text gdtr dw 0 ; For limit storage dd 0 ; For base storage load_gdt: mov eax, [esp + 4] mov [gdtr + 2], eax mov ax, [esp + 8] mov [gdtr], ax lgdt [gdtr] jmp 0x08:.reload_CS .reload_CS: mov ax, 0x10 ; 0x10 points at the new data selector mov ds, ax mov es, ax mov fs, ax mov gs, ax mov ss, ax mov ax, 0x28 ltr ax ret</code> </pre> <br><p>  Maka semuanya akan sedikit lebih mudah, tetapi tidak kalah menarik. </p><br><h1 id="preryvaniya">  Gangguan </h1><br><p>  Sebenarnya, ini saatnya memberi kita kesempatan untuk berinteraksi dengan inti kita (setidaknya untuk melihat apa yang kita tekan pada keyboard).  Untuk melakukan ini, Anda harus menginisialisasi pengontrol interupsi. </p><br><p>  Penyimpangan liris tentang gaya kode. </p><br><p>  Berkat upaya komunitas dan khususnya Philip Opperman, konvensi panggilan interupsi x86 telah ditambahkan ke Rust, yang memungkinkan Anda untuk menulis penangan interupsi yang menjalankan iret.  Namun, saya secara sadar memutuskan untuk tidak pergi rute ini, karena saya memutuskan untuk memisahkan assembler dan Rust ke file yang berbeda, dan karena itu berfungsi.  Ya, saya menggunakan memori tumpukan secara tidak masuk akal, saya menyadari hal ini, tetapi rasanya masih enak.  Penangan interupsi saya ditulis dalam assembler dan melakukan tepat satu hal: mereka memanggil penangan interupsi yang hampir sama yang ditulis dalam Rust.  Terimalah fakta ini dan bersikap sabar. </p><br><p>  Secara umum, proses inisialisasi interupsi mirip dengan menginisialisasi GDT, tetapi lebih mudah dimengerti.  Di sisi lain, Anda memerlukan banyak kode seragam.  Para pengembang Redox OS membuat keputusan yang indah, menggunakan semua kesenangan bahasa, tetapi saya pergi "di dahi" dan memutuskan untuk mengizinkan duplikasi kode. </p><br><p>  Menurut konvensi x86, kami memiliki interupsi, tetapi ada situasi luar biasa.  Dalam konteks ini, pengaturan untuk kami praktis sama.  Satu-satunya perbedaan adalah bahwa ketika pengecualian dilemparkan, tumpukan mungkin berisi informasi tambahan.  Sebagai contoh, saya menggunakannya untuk menangani kekurangan halaman ketika bekerja dengan banyak (tetapi semuanya memiliki waktu).  Kedua interupsi dan pengecualian diproses dari tabel yang sama, yang harus Anda dan saya isi.  Hal ini juga diperlukan untuk memprogram PIC (Programmable Interrupt Controller).  Ada juga APIC, tapi saya belum menemukan jawabannya. </p><br><p>  Bekerja dengan PIC, saya tidak akan memberikan banyak komentar, karena ada banyak contoh di jaringan untuk bekerja dengannya.  Saya akan mulai dengan penangan di assembler.  Semuanya benar-benar identik, jadi saya akan menghapus kode untuk spoiler. </p><br><div class="spoiler">  <b class="spoiler_title">IRQ</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">global irq0 global irq1 ...... global irq14 global irq15 extern kirq0 extern kirq1 ...... extern kirq14 extern kirq15 section .text irq0: pusha call kirq0 popa iret irq1: pusha call kirq1 popa iret ...... irq14: pusha call kirq14 popa iret irq15: pusha call kirq15 popa iret</code> </pre> </div></div><br><p>  Seperti yang Anda lihat, semua panggilan ke fungsi Rust dimulai dengan awalan "k" - untuk perbedaan dan kenyamanan.  Penanganan pengecualian sama persis.  Untuk fungsi assembler, awalan "e" dipilih, untuk Rust, "k".  Penangan Kesalahan Halaman berbeda, tetapi tentang hal itu - dalam catatan tentang manajemen memori. </p><br><div class="spoiler">  <b class="spoiler_title">Pengecualian</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">global e0_zero_divide global e1_debug ...... global eE_page_fault ...... global e14_virtualization global e1E_security extern k0_zero_divide extern k1_debug ...... extern kE_page_fault ...... extern k14_virtualization extern k1E_security section .text e0_zero_divide: pushad call k0_zero_divide popad iret e1_debug: pushad call k1_debug popad iret ...... eE_page_fault: pushad mov eax, [esp + 32] push eax mov eax, cr2 push eax call kE_page_fault pop eax pop eax popad add esp, 4 iret ...... e14_virtualization: pushad call k14_virtualization popad iret e1E_security: pushad call k1E_security popad iret</code> </pre> </div></div><br><p>  Kami menyatakan assembler handler: </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load_idt</span></span></span></span>(base: *<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> IdtEntry, limit: <span class="hljs-built_in"><span class="hljs-built_in">u16</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e0_zero_divide</span></span></span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e1_debug</span></span></span></span>(); ...... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e14_virtualization</span></span></span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">e1E_security</span></span></span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">irq0</span></span></span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">irq1</span></span></span></span>(); ...... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">irq14</span></span></span></span>(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">irq15</span></span></span></span>(); }</code> </pre> <br><p>  Kami mendefinisikan penangan karat yang kami sebut di atas.  Harap dicatat bahwa untuk mengganggu keyboard, saya cukup menampilkan kode yang diterima, yang saya dapatkan dari port 0x60 - ini adalah cara keyboard bekerja dalam mode paling sederhana.  Di masa depan, ini berubah menjadi pengemudi yang penuh, saya harap.  Setelah setiap interupsi, Anda perlu mengeluarkan sinyal pada akhir pemrosesan 0x20 ke controller, ini penting!  Jika tidak, Anda tidak akan mendapatkan lebih banyak interupsi. </p><br><pre> <code class="rust hljs"><span class="hljs-meta"><span class="hljs-meta">#[no_mangle]</span></span> <span class="hljs-keyword"><span class="hljs-keyword">pub</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">kirq0</span></span></span></span>() { <span class="hljs-comment"><span class="hljs-comment">// println!("IRQ 0"); outb(0x20, 0x20); } #[no_mangle] pub unsafe extern fn kirq1() { let ch: char = inb(0x60) as char; crate::arch::vga::VGA_WRITER.force_unlock(); println!("IRQ 1 {}", ch); outb(0x20, 0x20); } #[no_mangle] pub unsafe extern fn kirq2() { println!("IRQ 2"); outb(0x20, 0x20); } ...</span></span></code> </pre> <br><p>  Inisialisasi IDT dan PIC.  Tentang PIC dan remappingnya, saya menemukan sejumlah besar tutorial dengan berbagai tingkat detail, dimulai dengan OSDev dan berakhir dengan situs amatir.  Karena prosedur pemrograman beroperasi dengan urutan operasi konstan dan perintah konstan, saya akan memberikan kode ini tanpa penjelasan lebih lanjut.     ,        0x20-0x2F  ,       0x20  0x28,     16    IDT. </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsafe</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">setup_pic</span></span></span></span>(pic1: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>, pic2: <span class="hljs-built_in"><span class="hljs-built_in">u8</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Start initialization outb(PIC1, 0x11); outb(PIC2, 0x11); // Set offsets outb(PIC1 + 1, pic1); /* remap */ outb(PIC2 + 1, pic2); /* pics */ // Set up cascade outb(PIC1 + 1, 4); /* IRQ2 -&gt; connection to slave */ outb(PIC2 + 1, 2); // Set up interrupt mode (1 is 8086/88 mode, 2 is auto EOI) outb(PIC1 + 1, 1); outb(PIC2 + 1, 1); // Unmask interrupts outb(PIC1 + 1, 0); outb(PIC2 + 1, 0); // Ack waiting outb(PIC1, 0x20); outb(PIC2, 0x20); } pub unsafe fn init_idt() { IDT[0x0].set_func(e0_zero_divide); IDT[0x1].set_func(e1_debug); ...... IDT[0x14].set_func(e14_virtualization); IDT[0x1E].set_func(e1E_security); IDT[0x20].set_func(irq0); IDT[0x21].set_func(irq1); ...... IDT[0x2E].set_func(irq14); IDT[0x2F].set_func(irq15); setup_pic(0x20, 0x28); let idt_ptr: *const IdtEntry = IDT.as_ptr(); let limit = (IDT.len() * core::mem::size_of::&lt;IdtEntry&gt;() - 1) as u16; load_idt(idt_ptr, limit); }</span></span></code> </pre> <br><p>      IDTR   GDTR —       .  STI        —         —  ,    ,  ASCII-   -. </p><br><pre> <code class="plaintext hljs">global load_idt section .text idtr dw 0 ; For limit storage dd 0 ; For base storage load_idt: mov eax, [esp + 4] mov [idtr + 2], eax mov ax, [esp + 8] mov [idtr], ax lidt [idtr] sti ret</code> </pre> <br><h1 id="posleslovie">  Kata penutup </h1><br><p>  ,     ,            .      setup_pd,           . ,   ,     ,  . </p><br><p>   - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  GitLab</a> . </p><br><p>  Terima kasih atas perhatian anda! </p><br><p> UPD: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> 3</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id445584/">https://habr.com/ru/post/id445584/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id445568/index.html">Pemantauan jarak jauh dan pengelolaan perangkat berbasis Linux / OpenWrt / Lede melalui port 80 ...</a></li>
<li><a href="../id445570/index.html">Intisari acara untuk profesional SDM di bidang TI untuk April 2019</a></li>
<li><a href="../id445572/index.html">Pemerintah AS berencana mengirim orang ke bulan dalam 5 tahun</a></li>
<li><a href="../id445580/index.html">Daftar lengkap perbedaan antara VB.NET dan C #. Bagian 2</a></li>
<li><a href="../id445582/index.html">Sistem CRM: perlindungan atau ancaman?</a></li>
<li><a href="../id445586/index.html">Akademi Android di Moskow - bicarakan tentang itu dan bagikan materi pelajaran</a></li>
<li><a href="../id445588/index.html">Pemindaian 3D seseorang dalam 30 detik akan ditampilkan di pameran</a></li>
<li><a href="../id445590/index.html">Tata bahasa Inggris. Siapa vs Siapa - bagaimana memahami kata mana yang digunakan</a></li>
<li><a href="../id445592/index.html">Inisialisasi malas di Boot Musim Semi 2.2</a></li>
<li><a href="../id445594/index.html">Alat untuk membuat situs responsif tanpa akses ke situs</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>