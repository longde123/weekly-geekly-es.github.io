<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐯 💆🏽 😹 Membuat trek di salju di Unreal Engine 4 ⤴️ 🗺️ 👻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jika Anda memainkan game AAA modern, Anda mungkin telah memperhatikan kecenderungan untuk menggunakan lanskap yang tertutup salju. Misalnya, mereka be...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membuat trek di salju di Unreal Engine 4</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416703/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/ox/49/ct/ox49ctzii2nk6gryoeuvbcxf96a.gif"></div><br>  Jika Anda memainkan game AAA modern, Anda mungkin telah memperhatikan kecenderungan untuk menggunakan lanskap yang tertutup salju.  Misalnya, mereka berada di <i>Horizon Zero Dawn</i> , <i>Rise of the Tomb Raider</i> dan <i>God of War</i> .  Dalam semua gim ini, salju memiliki fitur penting: Anda dapat meninggalkan jejak di atasnya! <br><br>  Berkat interaksi dengan lingkungan ini, pencelupan pemain dalam permainan ditingkatkan.  Itu membuat lingkungan lebih realistis, dan mari kita jujur ​​- itu hanya menarik.  Mengapa menghabiskan waktu berjam-jam menciptakan mekanik yang ingin tahu jika Anda bisa membiarkan pemain jatuh ke tanah dan membuat malaikat salju? <br><br>  Dalam tutorial ini Anda akan mempelajari hal-hal berikut: <br><br><ul><li>  Buat jejak kaki menggunakan capture adegan untuk menutupi objek yang dekat dengan tanah </li><li>  Gunakan topeng dengan bahan medan untuk membuat salju yang dapat dideformasi </li><li>  Untuk mengoptimalkan, tampilkan jejak kaki di salju hanya di sebelah pemain </li></ul><a name="habracut"></a><br><blockquote>  <em>Catatan:</em> dipahami bahwa Anda sudah terbiasa dengan dasar-dasar bekerja dengan Unreal Engine.  Jika Anda baru, lihat seri tutorial <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mesin Nyata</a> kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk pemula</a> . </blockquote><br><h2>  Mulai bekerja </h2><br>  Unduh <a href="">materi</a> untuk tutorial ini.  Buka <em>zip</em> mereka, pergi ke <em>SnowDeformationStarter</em> dan buka <em>SnowDeformation.uproject</em> .  Dalam tutorial ini kita akan membuat jejak dengan bantuan karakter dan beberapa kotak. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a1f/8c7/b72/a1f8c7b7279319c558685c1b09858726.gif"></div><br>  Sebelum kita mulai, Anda perlu tahu bahwa metode dari tutorial ini hanya akan menyimpan jejak di area tertentu, dan tidak di seluruh dunia, karena kecepatannya tergantung pada resolusi render target. <br><br>  Misalnya, jika kita ingin menyimpan jejak untuk area yang luas, maka kita harus meningkatkan resolusi.  Tapi itu juga meningkatkan dampak pengambilan adegan pada kecepatan game dan ukuran memori untuk target render.  Untuk optimasi, Anda perlu membatasi ruang lingkup dan resolusi. <br><br>  Setelah mengatasinya, mari cari tahu apa yang diperlukan untuk mewujudkan jejak kaki di salju. <br><br><h2>  Implementasi jejak kaki di salju </h2><br>  Hal pertama yang Anda butuhkan untuk membuat jejak adalah <em>target render</em> .  Target render akan menjadi topeng dalam skala abu-abu, di mana putih menunjukkan adanya jejak, dan hitam menunjukkan tidak adanya.  Kemudian kita dapat memproyeksikan target render ke tanah dan menggunakannya untuk mencampur tekstur dan menggeser simpul. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea7/f0c/7f4/ea7f0c7f4eee82e34ebf74afeab25a72.gif"></div><br>  Hal kedua yang kita butuhkan adalah cara untuk menutupi hanya benda-benda yang mempengaruhi salju.  Ini dapat diterapkan dengan terlebih dahulu merender objek dalam <em>Kedalaman Kustom</em> .  Anda kemudian dapat menggunakan <em>tangkapan layar</em> dengan <em>bahan proses pos</em> untuk menutupi semua objek yang dirender di Custom Depth.  Kemudian Anda bisa menampilkan topeng di render target. <br><br><blockquote>  <em>Catatan:</em> pengambilan adegan pada dasarnya adalah kamera dengan kemampuan untuk menghasilkan render target. </blockquote><br>  Bagian terpenting dari mengabadikan sebuah adegan adalah lokasinya.  Berikut ini adalah contoh dari target render yang diambil dari tampilan <em>atas</em> .  Di sini, karakter dan kotak orang ketiga disamarkan. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/886/2e0/4cf/8862e04cfeb3f6ce26918d4ffa8b00a0.jpg"></div><br>  Sekilas, tangkapan dengan tampilan atas cocok untuk kami.  Formulir terlihat cocok untuk jerat, jadi seharusnya tidak ada masalah, bukan? <br><br>  Tidak juga.  Masalah menangkap dari tampilan atas adalah bahwa ia tidak menangkap apa pun di bawah titik terlebar.  Berikut ini sebuah contoh: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6ae/952/8b1/6ae9528b111143c408aab2642fe4c781.gif"></div><br>  Bayangkan bahwa panah kuning sampai ke tanah.  Dalam kasus kubus dan kerucut, panah akan selalu tetap berada di dalam objek.  Namun, dalam kasus bola, titik muncul darinya ketika mendekati bumi.  Namun menurut kamera, ujungnya selalu di dalam bola.  Beginilah bentuk sphere untuk kamera: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/35f/580/cab/35f580cab1df39d4707c344f9e902e9d.jpg"></div><br>  Oleh karena itu, topeng bola akan lebih besar dari yang seharusnya, bahkan jika area kontak dengan bumi kecil. <br><br>  Selain itu, masalah ini dilengkapi dengan fakta bahwa sulit bagi kita untuk menentukan apakah objek tersebut menyangkut tanah. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9e3/df9/a48/9e3df9a4804b5c317f40f57389fc1a8c.gif"></div><br>  Untuk mengatasi kedua masalah ini, Anda dapat menggunakan tangkapan <em>dari bawah</em> . <br><br><h3>  Pegangan bawah </h3><br>  Tangkapan dari bawah adalah sebagai berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c3f/348/aad/c3f348aad117b479acf5fd9505f9c860.gif"></div><br>  Seperti yang Anda lihat, kamera sekarang menangkap sisi bawah, yaitu, yang menyentuh tanah.  Ini menghilangkan masalah "area terluas" yang muncul saat menangkap dari atas. <br><br>  Untuk menentukan apakah suatu benda menyentuh tanah, Anda dapat menggunakan bahan pasca-pemrosesan untuk melakukan pemeriksaan kedalaman.  Ini memeriksa apakah kedalaman objek lebih besar dari kedalaman bumi <i>dan</i> apakah itu di bawah offset yang telah ditentukan.  Jika kedua kondisi terpenuhi, maka kita dapat menutupi piksel ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6b/83f/e87/a6b83fe8713950c52f917314de9d7c88.jpg"></div><br>  Di bawah ini adalah contoh di dalam mesin dengan zona tangkap 20 unit di atas tanah.  Perhatikan bahwa topeng hanya muncul ketika objek melewati titik tertentu.  Perhatikan juga bahwa topeng menjadi lebih putih saat objek mendekati tanah. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/949/1bb/d76/9491bbd768781cbca7c07a652172ba2c.gif"></div><br>  Pertama, buat bahan pasca pemrosesan untuk melakukan pemeriksaan mendalam. <br><br><h2>  Membuat Bahan Uji Kedalaman </h2><br>  Untuk melakukan pemeriksaan kedalaman, Anda perlu menggunakan dua buffer kedalaman - satu untuk tanah, yang lainnya untuk objek yang mempengaruhi salju.  Karena menangkap pemandangan hanya melihat bumi, <em>Pemandangan Kedalaman</em> akan menyimpulkan kedalaman untuk bumi.  Untuk mendapatkan kedalaman untuk objek, kami hanya akan membuatnya <em>Depth Kustom</em> . <br><br><blockquote>  <em>Catatan:</em> untuk menghemat waktu, saya telah merender karakter dan kotak di Kedalaman Kustom.  Jika Anda ingin menambahkan objek lain yang memengaruhi salju, Anda harus mengaktifkan <em>Render CustomDepth Pass untuknya</em> . </blockquote><br>  Pertama, Anda perlu menghitung jarak setiap piksel ke tanah.  Buka <em>Bahan \ PP_DepthPeriksa</em> dan buat yang berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f32/7bb/226/f327bb226d1764c3f848d1c43a6304ca.jpg"></div><br>  Selanjutnya, Anda perlu membuat zona tangkap.  Untuk melakukan ini, tambahkan node yang disorot: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/908/37d/0eb/90837d0eb07af42121b2a113b1229230.jpg"></div><br>  Sekarang jika pixel berada dalam <em>25</em> unit bumi, maka akan muncul di mask.  Kecerahan Masking tergantung pada seberapa dekat pixel ke tanah.  Klik <em>Terapkan</em> dan kembali ke editor utama. <br><br>  Selanjutnya Anda perlu membuat tangkapan adegan. <br><br><h2>  Buat tangkapan adegan </h2><br>  Pertama, kita membutuhkan target render untuk menangkap adegan.  Buka folder <em>RenderTarget</em> dan buat <em>Target Render</em> baru yang disebut <em>RT_Capture</em> . <br><br>  Sekarang mari kita membuat capture adegan.  Dalam tutorial ini kita akan menambahkan adegan pengambilan ke cetak biru, karena nanti kita akan memerlukan skrip untuk itu.  Buka <em>Cetak Biru \ BP_Capture</em> dan tambahkan <em>Komponen</em> <em>Pengambilan Gambar</em> <em>2D</em> .  Beri nama <em>SceneCapture</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3d0/df9/915/3d0df9915e8aa04d9577193a53bcfc05.jpg"></div><br>  Pertama, kita perlu mengatur pergantian tangkapan sehingga terlihat di tanah.  Buka panel Detail dan atur <em>Rotasi ke</em> <em>(0, 90, 90)</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6e2/c35/407/6e2c354070055e1f427d626b1c0df408.jpg"></div><br>  Selanjutnya adalah jenis proyeksi.  Karena topeng adalah representasi 2D dari adegan, kita perlu menyingkirkan distorsi perspektif.  Untuk melakukan ini, tetapkan <em>Jenis Proyeksi \ Jenis Proyeksi</em> ke <em>Orthografis</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78b/e54/adf/78be54adf3666b52564582f07153f8df.jpg"></div><br>  Selanjutnya, kita perlu memberi tahu tangkapan adegan yang menjadi target rekaman untuk direkam.  Untuk melakukan ini, pilih nilai <em>RT_Capture</em> untuk <em>Scene Capture \ Target Tekstur</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c6/a76/2c5/5c6a762c53867499e5f3ace3de1b1eee.jpg"></div><br>  Akhirnya, kita perlu menggunakan bahan pemeriksaan kedalaman.  Tambahkan PP_DepthPeriksa ke <em>Rendering Features \ Post Process Materials</em> .  Agar post-processing berfungsi, kita juga perlu mengubah <em>Scene Capture \ Capture Source</em> ke <em>Final Color (LDR) di RGB</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3ec/1f1/26f/3ec1f126fce6ccea0625ae5d33193fdd.jpg"></div><br>  Sekarang setelah pengambilan adegan dikonfigurasikan, kita perlu menentukan ukuran area pengambilan. <br><br><h3>  Mengatur ukuran area tangkapan </h3><br>  Karena lebih baik menggunakan resolusi rendah untuk target render, kita perlu menggunakan ruang secara efisien.  Artinya, kita harus memilih area mana yang satu piksel akan mencakup.  Misalnya, jika resolusi area tangkap dan target render sama, maka kami mendapatkan rasio 1: 1.  Setiap piksel akan mencakup area 1 × 1 (dalam satuan dunia). <br><br>  Untuk trek di salju, rasio 1: 1 tidak diperlukan, karena kita kemungkinan besar tidak membutuhkan detail seperti itu.  Saya sarankan menggunakan rasio yang lebih besar karena ini akan memungkinkan Anda untuk meningkatkan ukuran area pengambilan pada resolusi rendah.  Tetapi jangan membuat rasio terlalu besar, jika tidak rinciannya akan mulai hilang.  Dalam tutorial ini, kita akan menggunakan rasio 8: 1, yaitu, ukuran setiap piksel akan menjadi 8 × 8 unit dunia. <br><br>  Anda dapat mengubah ukuran area pengambilan dengan mengubah properti <em>Scene Capture \ Ortho Width</em> .  Misalnya, jika Anda ingin menangkap area 1024 × 1024, maka atur nilainya menjadi 1024. Karena kami menggunakan rasio 8: 1, atur nilainya menjadi <em>2048</em> (resolusi default dari target render adalah 256 × 256). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/411/c60/994/411c60994d4b52dc80553a375496363b.jpg"></div><br>  Ini berarti bahwa pengambilan adegan akan menangkap area <em>2048 × 2048</em> .  Berjarak sekitar 20 × 20 meter. <br><br>  Bahan dasar juga membutuhkan akses untuk menangkap ukuran untuk memproyeksikan render target dengan benar.  Cara termudah untuk melakukan ini adalah dengan menyimpan ukuran tangkapan di <em>Koleksi Parameter Material</em> .  Ini pada dasarnya adalah kumpulan variabel yang dapat diakses materi <i>apa pun</i> . <br><br><h3>  Menyimpan ukuran tangkapan </h3><br>  Kembali ke editor utama dan buka folder <em>Bahan</em> .  Buat <em>Koleksi Parameter Bahan</em> yang akan di <em>Bahan &amp; Tekstur</em> .  Ubah nama menjadi <em>MPC_Capture</em> dan buka. <br><br>  Kemudian buat <em>Parameter Skalar</em> baru dan <em>beri</em> nama <em>CaptureSize</em> .  Jangan khawatir tentang pengaturan nilainya - kami akan melakukannya terus terang. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3bd/e83/fd4/3bde83fd4df9a960ef4ebde57830b749.jpg"></div><br>  Kembali ke <em>BP_Capture</em> dan tambahkan node yang disorot ke <em>Event BeginPlay</em> .  Setel <em>Koleksi</em> ke <em>MPC_Capture</em> , dan <em>Nama Parameter</em> ke <em>CaptureSize</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eed/843/d3d/eed843d3d5ddc063f9e1c7664b514286.jpg"></div><br>  Sekarang bahan apa pun bisa mendapatkan nilai <em>Lebar Ortho</em> dengan membacanya dari parameter <em>CaptureSize</em> .  Sejauh ini dengan penangkapan adegan kami selesai.  Klik <em>Kompilasi</em> dan kembali ke editor utama.  Langkah selanjutnya adalah memproyeksikan target render ke tanah dan menggunakannya untuk merusak lanskap. <br><br><h2>  Deformasi lanskap </h2><br>  Buka <em>M_Landscape</em> dan buka panel Detail.  Kemudian atur properti berikut: <br><br><ul><li>  Untuk <em>Dua Sisi,</em> pilih <em>diaktifkan</em> .  Karena menangkap pemandangan akan "melihat" dari bawah, ia hanya akan melihat muka bumi yang terbalik.  Secara default, mesin tidak membuat permukaan belakang jerat.  Ini berarti bahwa ia tidak akan menyimpan kedalaman bumi dalam buffer kedalaman.  Untuk memperbaiki ini, kita perlu memberitahu mesin untuk membuat kedua sisi mesh. </li><li>  Untuk <em>D3D11 Tessellation,</em> pilih <em>Flat Tessellation</em> (PN Segitiga juga dapat digunakan).  Tessellation akan memecah segitiga jala menjadi yang lebih kecil.  Intinya, ini meningkatkan resolusi mesh dan memungkinkan kita untuk mendapatkan detail yang lebih baik saat menggeser simpul.  Tanpa ini, kepadatan puncak akan terlalu rendah untuk membuat jejak yang bisa dipercaya. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc2/99b/a26/dc299ba26cb64d251af3844faf0f5079.jpg"></div><br>  Setelah tessellations diaktifkan, <em>Pengganda</em> <em>Dunia</em> dan <em>Pengganda Tessellation</em> akan menyala. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e8d/675/c53/e8d675c535ce64980597cf10a16ffafe.jpg"></div><br>  <em>Tessellation Multipler</em> mengontrol jumlah tessellation.  Dalam tutorial ini, kita tidak akan menghubungkan node ini, yaitu, kita menggunakan nilai default ( <em>1</em> ). <br><br>  <em>World Displacement</em> mendapatkan nilai vektor yang menggambarkan ke arah mana dan seberapa banyak untuk memindahkan titik.  Untuk menghitung nilai kontak ini, pertama-tama kita harus memproyeksikan target render ke tanah. <br><br><h3>  Render Target Proyek </h3><br>  Untuk memproyeksikan target render, Anda perlu menghitung koordinat UV-nya.  Untuk melakukan ini, buat skema berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cbb/88f/b59/cbb88fb598e75fc8c9bd9991806d5892.jpg"></div><br>  Apa yang terjadi di sini: <br><br><ol><li>  Pertama kita perlu mendapatkan posisi XY dari simpul saat ini.  Karena kami menangkap dari bawah, koordinat X dibalik, jadi Anda perlu membaliknya kembali (jika kami ingin menangkap dari atas, kami tidak memerlukan ini). </li><li>  Bagian ini melakukan dua tugas.  Pertama, ia memusatkan target render sedemikian rupa sehingga medianya berada di koordinat <em>(0, 0) dari</em> ruang dunia.  Dia kemudian mengubah koordinat dari ruang dunia ke ruang UV. </li></ol><br>  Selanjutnya, buat node yang dipilih dan gabungkan perhitungan sebelumnya seperti yang ditunjukkan di bawah ini.  Untuk <em>Sampel Tekstur,</em> pilih <em>RT_Capture</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e95/38d/398/e9538d398f9ba02da2aea238c45651dd.jpg"></div><br>  Ini akan memproyeksikan target render ke tanah.  Namun, semua simpul di luar area tangkapan akan mengambil sampel tepi target render.  Ini sebenarnya masalah karena target render seharusnya hanya digunakan untuk simpul dalam area tangkapan.  Begini tampilannya dalam game: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a4/e28/a04/1a4e28a04c7b6356bff76d8e1c4f4ce9.gif"></div><br>  Untuk memperbaikinya, kita perlu menutupi semua UV yang berada di luar kisaran 0 hingga 1 (mis., Area tangkapan).  Untuk ini, saya membuat fungsi <em>MF_MaskUV0-1</em> .  Ini mengembalikan <em>0</em> jika UV yang ditransmisikan berada di luar kisaran 0 hingga 1 dan mengembalikan <em>1</em> jika ada di dalamnya.  Mengalikan hasilnya dengan target render, kami melakukan masking. <br><br>  Sekarang kita telah memproyeksikan render target, kita dapat menggunakannya untuk mencampur warna dan memindahkan titik. <br><br><h3>  Menggunakan Target Render </h3><br>  Mari kita mulai dengan mencampur warna.  Untuk melakukan ini, kita cukup menghubungkan <em>1-x</em> ke <em>Lerp</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bc2/4e2/6fa/bc24e26fab908757ce5a0dded5d9ce21.jpg"></div><br><blockquote>  <em>Catatan:</em> jika Anda tidak mengerti mengapa saya menggunakan <em>1-x</em> , saya akan menjelaskan - ini diperlukan untuk membalikkan target render, sehingga perhitungannya menjadi sedikit lebih mudah. </blockquote><br>  Sekarang kita memiliki jejak, warna bumi berubah menjadi cokelat.  Jika tidak ada warna, tetap putih. <br><br>  Langkah selanjutnya adalah perpindahan simpul.  Untuk melakukan ini, tambahkan node yang dipilih dan hubungkan semuanya sebagai berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d7/6b2/6bd/4d76b26bddbf7640fae8032449bea285.jpg"></div><br>  Ini akan menyebabkan semua area salju naik <em>25</em> unit.  Daerah tanpa salju memiliki offset nol, yang akan membuat jejak. <br><br><blockquote>  <em>Catatan: Anda</em> dapat mengubah <em>DisplacementHeight</em> untuk menambah atau mengurangi level salju.  Perhatikan juga bahwa DisplacementHeight memiliki nilai yang sama dengan capture offset.  Ketika mereka memiliki makna yang sama, itu memberi kita deformasi yang tepat.  Tetapi ada beberapa kasus ketika Anda perlu mengubahnya secara individual, jadi saya meninggalkannya sebagai parameter terpisah. </blockquote><br>  Klik <em>Terapkan</em> dan kembali ke editor utama.  Buat instance <em>BP_Capture</em> di level dan berikan koordinatnya <em>(0, 0, -2000)</em> untuk meletakkannya di bawah tanah.  Klik <em>Play</em> dan berkeliaran dengan tombol <em>W</em> , <em>A</em> , <em>S</em> dan <em>D</em> untuk membelokkan salju. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f6d/a1e/47b/f6da1e47b364e53b0245e53919f4a654.gif"></div><br>  Deformasi bekerja, tetapi tidak ada jejak yang tersisa!  Ini terjadi karena penangkapan menimpa target yang diberikan setiap kali penangkapan dilakukan.  Kami membutuhkan beberapa cara untuk membuat trek <em>permanen</em> . <br><br><h2>  Membuat Jejak Permanen </h2><br>  Untuk membuat kegigihan, kita perlu render target lain ( <em>buffer konstan</em> ), di mana semua konten capture akan disimpan sebelum ditimpa.  Kemudian kita akan menambahkan buffer konstan ke capture (setelah menimpanya).  Kami mendapatkan loop di mana setiap target membuat menulis ke yang lain.  Ini adalah bagaimana kami akan membuat jejak permanen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04e/3bd/a26/04e3bda26fe04e7832163e2e08abdd64.gif"></div><br>  Pertama, kita perlu membuat buffer konstan. <br><br><h3>  Membuat buffer persisten </h3><br>  Buka folder <em>RenderTarget</em> dan buat <em>Target Render</em> baru yang disebut <em>RT_Persistent</em> .  Dalam tutorial ini kami tidak perlu mengubah parameter tekstur, tetapi dalam proyek Anda sendiri, Anda harus memastikan bahwa kedua target yang dirender menggunakan resolusi yang sama. <br><br>  Selanjutnya, kita membutuhkan materi yang akan menyalin tangkapan ke buffer permanen.  Buka <em>Bahan \ M_DrawToPersistent</em> dan tambahkan simpul <em>Contoh Tekstur</em> .  Pilih tekstur <em>RT_Capture untuknya</em> dan sambungkan sebagai berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/29e/b31/328/29eb3132825b6b7ee68ddd5c45a73454.jpg"></div><br>  Sekarang kita perlu menggunakan bahan gambar.  Klik <em>Terapkan</em> , lalu buka <em>BP_Capture</em> .  Pertama, buat instance dinamis dari materi (nanti kita perlu memberikan nilai padanya).  Tambahkan node yang disorot ke <em>Event BeginPlay</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ca2/1d0/6a1/ca21d06a1bfa563eee0df19b4da6e129.jpg"></div><br>  <em>Clear Render Target 2D</em> node menghapus setiap target render sebelum digunakan. <br><br>  Kemudian buka fungsi <em>DrawToPersistent</em> dan tambahkan node yang disorot: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c21/88c/051/c2188c0511541f5fcaee1773318653ac.jpg"></div><br>  Selanjutnya, kita perlu memastikan bahwa gambar ke buffer konstan dilakukan di setiap frame, karena penangkapan terjadi di setiap frame.  Untuk melakukan ini, tambahkan <em>DrawToPersistent</em> ke <em>Event Tick</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a88/47a/e9d/a8847ae9d4bafffbaacf448af86f538d.jpg"></div><br>  Akhirnya, kita perlu menambahkan buffer persisten kembali ke target capture render. <br><br><h3>  Rekam kembali untuk ditangkap </h3><br>  Klik <em>Kompilasi</em> dan buka <em>PP_DepthCheck</em> .  Kemudian tambahkan node yang disorot.  Untuk <em>Sampel Tekstur,</em> tetapkan nilainya ke <em>RT_Persistent</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/afb/ff2/a99/afbff2a99105d523fd44acf437787e06.jpg"></div><br>  Sekarang target membuat menulis satu sama lain, kami mendapatkan jejak yang tersisa.  Klik <em>Terapkan</em> , lalu tutup materi.  Klik <em>Play</em> dan mulai meninggalkan trek! <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d79/b8a/fd8/d79b8afd898378111e1fc6b62464bf2a.gif"></div><br>  Hasilnya tampak hebat, tetapi sirkuit yang dihasilkan hanya berfungsi untuk satu area peta.  Jika Anda melampaui area tangkapan, jejak akan berhenti muncul. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/764/641/1a7/7646411a7886c8c1004a34b2d6f3bda9.gif"></div><br>  Anda dapat mengatasi masalah ini dengan memindahkan area tangkap dengan pemain.  Ini berarti bahwa jejak akan selalu muncul di sekitar area di mana pemain berada. <br><br>  <em>Catatan:</em> saat pengambilan bergerak, semua informasi di luar area pengambilan dihapus.  Ini berarti bahwa jika Anda kembali ke area di mana sudah ada jejak, maka mereka akan menghilang.  Dalam tutorial berikutnya, saya akan menunjukkan kepada Anda cara membuat trek yang dipertahankan sebagian. <br><br><h2>  Tangkap gerakan </h2><br>  Anda dapat memutuskan bahwa itu cukup sederhana untuk mengikat posisi penangkapan XY ke posisi pemain XY.  Tetapi jika Anda melakukannya, maka target render akan mulai kabur.  Ini karena kami memindahkan target render dengan langkah yang kurang dari satu piksel.  Ketika ini terjadi, posisi piksel baru berada di <i>antara</i> piksel.  Akibatnya, satu piksel diinterpolasi oleh beberapa piksel.  Begini tampilannya: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d6f/e29/d8e/d6fe29d8ea33db2479e5e897e6d90344.gif"></div><br>  Untuk memperbaiki masalah ini, kita perlu memindahkan tangkapan dalam langkah-langkah terpisah.  Kami menghitung <em>ukuran piksel di dunia</em> , dan kemudian memindahkan tangkapan ke langkah yang sama dengan ukuran itu.  Maka setiap piksel tidak akan pernah berada di antara yang lain, sehingga kekaburan tidak akan muncul. <br><br>  Untuk memulai, mari kita buat parameter di mana lokasi pengambilan akan disimpan.  Bahan bumi akan membutuhkannya untuk melakukan perhitungan proyeksi.  Buka <em>MPC_Capture</em> dan tambahkan <em>Parameter Vektor yang</em> disebut <em>CaptureLocation</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e4/0c7/4c3/1e40c74c3c19e6e8a2520d10874b9c13.jpg"></div><br>  Selanjutnya, Anda perlu memperbarui materi bumi untuk menggunakan parameter baru.  Tutup <em>MPC_Capture</em> dan buka <em>M_Landscape</em> .  Ubah bagian pertama dari perhitungan proyeksi sebagai berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d22/8e4/411/d228e4411ac885ec3a29878f7b5d930f.jpg"></div><br>  Sekarang target render akan selalu diproyeksikan ke lokasi penangkapan.  Klik <em>Terapkan</em> dan tutup materi. <br><br>  Selanjutnya, kita akan melakukan penangkapan dengan langkah terpisah. <br><br><h3>  Gerakan menangkap langkah diskrit </h3><br>  Untuk menghitung ukuran piksel di dunia, Anda dapat menggunakan persamaan berikut: <br><br><pre><code class="cpp hljs">(<span class="hljs-number"><span class="hljs-number">1</span></span> / RenderTargetResolution) * CaptureSize</code> </pre> <br>  Untuk menghitung posisi baru, kami menggunakan persamaan yang ditunjukkan di bawah ini untuk setiap komponen posisi (dalam kasus kami, untuk koordinat X dan Y). <br><br><pre> <code class="cpp hljs">(<span class="hljs-built_in"><span class="hljs-built_in">floor</span></span>(Position / PixelWorldSize) + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * PixelWorldSize</code> </pre> <br>  Sekarang gunakan dalam pengambilan cetak biru.  Untuk menghemat waktu, saya membuat makro <em>SnapToPixelWorldSize</em> untuk persamaan kedua.  Buka <em>BP_Capture</em> , lalu buka fungsi <em>MoveCapture</em> .  Selanjutnya, buat diagram berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c10/e17/55d/c10e1755df187bb3578d1b496402101f.jpg"></div><br>  Ini akan menghitung lokasi baru, dan kemudian menyimpan perbedaan antara lokasi baru dan saat ini di <em>MoveOffset</em> .  Jika Anda menggunakan resolusi selain 256 × 256, maka ubah nilai yang disorot. <br><br>  Selanjutnya, tambahkan node yang dipilih: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e9/963/879/1e9963879bfe2465f49a71665317db20.jpg"></div><br>  Sirkuit ini akan memindahkan tangkapan dengan offset yang dihitung.  Dia kemudian akan menyimpan lokasi pengambilan baru di <em>MPC_Capture</em> sehingga dapat digunakan oleh bahan dasar. <br><br>  Akhirnya, kita perlu melakukan pembaruan posisi di setiap frame.  Tutup fungsinya dan tambahkan ke <em>Event Tick</em> sebelum <em>DrawToPersistent</em> <em>MoveCapture</em> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f15/3c6/d54/f153c6d5438ba54a85f2b3749b179bb9.jpg"></div><br>  Memindahkan tangkapan hanya setengah dari solusi.  Kita juga perlu memindahkan buffer konstan.  Kalau tidak, capture dan buffer persisten akan tidak sinkron dan akan menghasilkan hasil yang aneh. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e1f/4fa/008/e1f4fa0086dc9f41412b70856f246149.gif"></div><br><h3>  Pindah Buffer Permanen </h3><br>  Untuk menggeser buffer konstan, kita harus melewati offset perpindahan yang dihitung.  Buka <em>M_DrawToPersistent</em> dan tambahkan node yang disorot: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e65/d15/16b/e65d1516bc33002a2e2a3bc7e9c96b00.jpg"></div><br>  Karena ini, buffer konstan akan digeser oleh nilai offset yang ditransmisikan.  Seperti pada materi bumi, kita perlu membalik koordinat X dan melakukan masking.  Klik <em>Terapkan</em> dan tutup materi. <br><br>  Maka Anda perlu mentransfer ofset.  Buka <em>BP_Capture</em> , lalu buka fungsi <em>DrawToPersistent</em> .  Selanjutnya, tambahkan node yang disorot: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/666/621/f22/666621f22bde013dd710991d5adfa7e4.jpg"></div><br>  Ini adalah bagaimana kami mengonversi <em>MoveOffset</em> ke ruang UV, dan kemudian meneruskannya ke bahan gambar. <br><br>  Klik <em>Kompilasi</em> , lalu tutup cetak biru.  Klik <em>Play</em> dan jalankan sesuka hati Anda!  Tidak peduli seberapa jauh Anda berlari, jejak akan selalu ada di sekitar Anda. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a94/097/5cb/a940975cb157444251cdb31bf195c8f2.gif"></div><br><h2>  Ke mana harus pergi selanjutnya? </h2><br>  Proyek yang sudah selesai dapat diunduh dari sini. <br><br>  Tidak perlu menggunakan trek yang dibuat dalam tutorial ini untuk salju saja.  Anda bahkan dapat menggunakannya untuk hal-hal seperti rumput yang dihancurkan (dalam tutorial berikutnya saya akan menunjukkan cara membuat versi lanjutan dari sistem). <br><br>  Jika Anda ingin bekerja dengan lanskap dan rendering target, saya sarankan menonton video Chris Murphy <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Building High-End Gameplay Effects dengan Blueprint</a> .  Tutorial ini akan menunjukkan cara membuat laser besar yang membakar bumi dan rumput! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id416703/">https://habr.com/ru/post/id416703/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id416691/index.html">Keamanan Pembelajaran Mesin: Teknik Pertahanan yang Efektif atau Ancaman Baru?</a></li>
<li><a href="../id416693/index.html">Sertifikat D-Link dan Mengubah Teknologi Informasi yang digunakan untuk menandatangani malware</a></li>
<li><a href="../id416695/index.html">Dukungan untuk vSphere 6.7 dan fitur-fitur lain dari Pembaruan & Replikasi Veeam 9.5 9.5 Pembaruan 3a</a></li>
<li><a href="../id416697/index.html">Penggabungan operator telekomunikasi pada tahun 2018</a></li>
<li><a href="../id416699/index.html">Sniper geek atau cara membuat "mata tajam"</a></li>
<li><a href="../id416707/index.html">Perangkat Lunak Manajemen Desktop Jarak Jauh - Aspia</a></li>
<li><a href="../id416709/index.html">IoT dan kemajuan alami: teknologi dan gadget paling kontroversial</a></li>
<li><a href="../id416711/index.html">Halaman sejarah Intel. Kebakaran pabrik Penang</a></li>
<li><a href="../id416713/index.html">Laporan Club of Rome 2018, Bab 3.14: “Bukan PDB tunggal ...”</a></li>
<li><a href="../id416719/index.html">Ekstensi PHP dan Kotlin Asli. Bagian Dua, Sadar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>