<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎷 🛂 ㊙️ Deep (Learning + Random) Hutan dan artikel parsing 🤙 ⚛️ 👨‍👧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami terus berbicara tentang konferensi tentang statistik dan pembelajaran mesin AISTATS 2019. Dalam posting ini kami akan menganalisis artikel tentan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Deep (Learning + Random) Hutan dan artikel parsing</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ru_mts/blog/458388/"><p>  Kami terus berbicara tentang konferensi tentang statistik dan pembelajaran mesin AISTATS 2019. Dalam posting ini kami akan menganalisis artikel tentang model mendalam dari ansambel pohon, mencampur regularisasi untuk data yang sangat jarang, dan perkiraan waktu validasi silang yang hemat waktu. </p><br><p><img src="https://habrastorage.org/webt/n-/uv/xj/n-uvxjud1se0puoearqtlott2de.jpeg"></p><a name="habracut"></a><br><h2 id="algoritm-glubokiy-les-an-exploration-to-non-nn-deep-models-based-on-non-differentiable-modules">  Algoritma Hutan Dalam: Eksplorasi Model Non-NN Deep berdasarkan Modul Non-Diferensial </h2><br><p>  Zhi-Hua Zhou (Universitas Nanjing) <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Presentasi</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel</a> <br>  Implementasi - di bawah ini </p><br><p>  Seorang profesor dari Tiongkok berbicara tentang ansambel pohon, yang penulis sebut sebagai pelatihan mendalam pertama tentang modul yang tidak dapat dibedakan.  Ini mungkin tampak seperti pernyataan yang terlalu keras, tetapi profesor ini dan indeks-H 95-nya diundang sebagai pembicara, fakta ini memungkinkan kita untuk menganggap pernyataan itu lebih serius.  Teori dasar Deep Forest telah dikembangkan sejak lama, artikel aslinya sudah 2017 (hampir 200 kutipan), tetapi penulis menulis perpustakaan dan setiap tahun mereka meningkatkan algoritma dalam kecepatan.  Dan sekarang, tampaknya, mereka telah mencapai titik di mana teori yang indah ini akhirnya dapat dipraktikkan. </p><br><p>  <em>Pandangan umum arsitektur Deep Forest</em> <br><img src="https://habrastorage.org/webt/4k/7q/1q/4k7q1qlzs5rixw4itr5luctdpuq.jpeg"></p><br><p>  <strong>Latar belakang</strong> </p><br><p>  Model mendalam, yang sekarang dipahami sebagai jaringan saraf dalam, digunakan untuk menangkap dependensi data yang kompleks.  Selain itu, ternyata meningkatkan jumlah lapisan lebih efisien daripada meningkatkan jumlah unit pada setiap lapisan.  Tetapi jaringan saraf memiliki kelemahan: </p><br><ul><li>  Dibutuhkan banyak data untuk tidak berlatih kembali, </li><li>  Dibutuhkan banyak sumber daya komputasi untuk belajar dalam jumlah waktu yang wajar, </li><li>  Terlalu banyak hiperparameter yang sulit dikonfigurasi secara optimal </li></ul><br><p>  Selain itu, elemen jaringan syaraf dalam adalah modul yang dapat dibedakan yang belum tentu efektif untuk setiap tugas.  Terlepas dari kerumitan jaringan saraf, algoritma konseptual sederhana, seperti hutan acak, sering bekerja lebih baik atau tidak jauh lebih buruk.  Tetapi untuk algoritma seperti itu, Anda perlu merancang fitur secara manual, yang juga sulit dilakukan secara optimal. </p><br><p>  Para peneliti telah memperhatikan bahwa ansambel pada Kaggle: “sangat sempurna”, dan terinspirasi oleh kata-kata Scholl dan Hinton bahwa diferensiasi adalah sisi terlemah dari Deep Learning, mereka memutuskan untuk membuat ansambel pohon dengan properti DL. </p><br><p>  <em>Slide “Cara membuat ansambel yang bagus”</em> <br><img src="https://habrastorage.org/webt/8w/cb/z9/8wcbz9ml-7qidb5ii4-meqcinec.jpeg"></p><br><p>  Arsitekturnya disimpulkan dari sifat-sifat ansambel: unsur-unsur ansambel tidak boleh sangat buruk dalam kualitas dan berbeda. </p><br><p>  GcForest terdiri dari dua fase: Cascade Forest dan Multi-Grained Scanning.  Selain itu, agar kaskade tidak berlatih kembali, terdiri dari 2 jenis pohon - salah satunya adalah pohon yang benar-benar acak yang dapat digunakan pada data yang tidak terisi.  Jumlah lapisan ditentukan di dalam algoritma cross-validation. <br><img src="https://habrastorage.org/webt/qv/co/-b/qvco-br5vregwj-rrxn3bxnyfeq.jpeg"></p><br><p>  <em>Dua jenis pohon</em> <br><img src="https://habrastorage.org/webt/mc/kp/ia/mckpiaiavjyh9hawcxhvtbusego.jpeg"></p><br><p>  <strong>Hasil</strong> </p><br><p>  Selain hasil pada dataset standar, penulis mencoba menggunakan gcForest pada transaksi sistem pembayaran Cina untuk mencari penipuan dan mendapatkan F1 dan AUC jauh lebih tinggi daripada LR dan DNN.  Hasil ini hanya dalam presentasi, tetapi kode untuk dijalankan pada beberapa dataset standar ada di Git. </p><br><p><img src="https://habrastorage.org/webt/y3/kf/gy/y3kfgytp_qawqyskwmvrrumzdna.jpeg"></p><br><p>  <em>Hasil substitusi algoritma.</em>  <em>mdDF adalah optimal Margin Distribution Deep Forest, varian dari gcForest</em> </p><br><p><img src="https://habrastorage.org/webt/e1/oh/wq/e1ohwqrilda60nmdnosaa_ye4yk.jpeg"></p><br><p>  Pro: </p><br><ul><li>  Beberapa hiperparameter, jumlah lapisan disesuaikan secara otomatis di dalam algoritma </li><li>  Pengaturan default dipilih untuk bekerja dengan baik pada banyak tugas. </li><li>  Kompleksitas adaptif model, pada data kecil - model kecil </li><li>  Tidak perlu mengatur fitur </li><li>  Ini berfungsi sebanding dalam kualitas dengan jaringan saraf yang dalam, dan kadang-kadang lebih baik </li></ul><br><p>  Cons: </p><br><ul><li>  Tidak dipercepat pada GPU </li><li>  Dalam gambar kehilangan DNN </li></ul><br><p>  Jaringan saraf memiliki masalah redaman gradien, sementara hutan yang dalam memiliki masalah “diversifikasi menghilang”.  Karena ini adalah ansambel, semakin banyak elemen "berbeda" dan "baik" untuk digunakan, semakin tinggi kualitasnya.  Masalahnya adalah bahwa penulis telah mencoba hampir semua pendekatan klasik (pengambilan sampel, pengacakan).  Selama tidak ada penelitian dasar baru yang muncul pada topik “perbedaan”, akan sulit untuk meningkatkan kualitas hutan yang dalam.  Tetapi sekarang mungkin untuk meningkatkan kecepatan komputasi. </p><br><p>  <strong>Reproduksibilitas hasil</strong> </p><br><p>  Saya tertarik oleh XGBoost pada data tabular, dan saya ingin mereproduksi hasilnya.  Saya mengambil dataset Dewasa dan menerapkan GcForestCS (versi yang sedikit dipercepat dari GcForest) dengan parameter dari penulis artikel dan XGBoost dengan parameter default.  Dalam contoh yang dimiliki penulis, fitur kategorikal sudah dipra-proses sebelumnya, tetapi tidak ditunjukkan caranya.  Akibatnya, saya menggunakan CatBoostEncoder dan metrik lainnya - ROC AUC.  Hasilnya berbeda secara statistik - XGBoost menang.  Waktu operasi XGBoost dapat diabaikan, sementara gcForestCS memiliki 20 menit masing-masing cross-validasi pada 5 kali lipat.  Di sisi lain, penulis menguji algoritma pada dataset yang berbeda, dan menyesuaikan parameter untuk dataset ini dengan preprocessing fitur mereka. </p><br><p>  Kode dapat ditemukan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sini</a> . </p><br><p>  <strong>Implementasi</strong> </p><br><p>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode resmi dari penulis artikel</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Modifikasi yang ditingkatkan resmi, lebih cepat, tetapi tidak ada dokumentasi</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Implementasi lebih sederhana</a> </p><br><h2 id="pclasso-the-lasso-meets-principal-components-regression">  PcLasso: laso memenuhi regresi komponen utama </h2><br><p>  J. Kenneth Tay, Jerome Friedman, Robert Tibshirani (Universitas Stanford) </p><br><p>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Presentasi</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Contoh penggunaan</a> </p><br><p>  Pada awal 2019, J. Kenneth Tay, Jerome Friedman, dan Robert Tibshirani dari Stanford University mengusulkan metode pengajaran baru dengan seorang guru, terutama cocok untuk data yang jarang. </p><br><p>  Para penulis artikel memecahkan masalah menganalisis data pada studi ekspresi gen, yang dijelaskan dalam Zeng &amp; Breesy (2016).  Target adalah status mutasi gen p53, yang mengatur ekspresi gen dalam menanggapi berbagai sinyal stres seluler.  Tujuan dari penelitian ini adalah untuk mengidentifikasi prediktor yang berkorelasi dengan status mutasi p53.  Data terdiri dari 50 baris, 17 di antaranya diklasifikasikan sebagai normal dan 33 lainnya membawa mutasi pada gen p53.  Menurut analisis dalam Subramanian et al.  (2005) 308 set gen yang antara 15 dan 500 dimasukkan dalam analisis ini.  Kit gen ini mengandung total 4.301 gen dan tersedia dalam paket grpregOverlap R.  Saat memperluas data untuk memproses grup yang tumpang tindih, 13.237 kolom adalah output.  Para penulis artikel menggunakan metode pcLasso, yang membantu meningkatkan hasil model. </p><br><p>  <em>Dalam gambar kita melihat peningkatan AUC saat menggunakan "pcLasso"</em> <br><img src="https://habrastorage.org/webt/ok/p6/mg/okp6mgex-l9p49vcz5gedg8xa5o.jpeg"></p><br><p>  <strong>Esensi dari metode ini</strong> </p><br><p>  Metode menggabungkan <img src="https://tex.s2cms.ru/svg/l_1" alt="l_1">  -regulasi dengan <img src="https://tex.s2cms.ru/svg/l_2" alt="l_2">  , yang mempersempit vektor koefisien ke komponen utama dari matriks fitur.  Mereka menyebut metode yang diusulkan "komponen laso inti" ("pcLasso" tersedia di R).  Metode ini bisa sangat kuat jika variabel sebelumnya dikelompokkan (pengguna memilih apa dan bagaimana mengelompokkan).  Dalam hal ini, pcLasso memampatkan setiap grup dan mendapatkan solusi sesuai dengan komponen utama grup ini.  Dalam proses penyelesaian, pemilihan kelompok yang signifikan di antara yang tersedia juga dilakukan. </p><br><p>  Kami menyajikan matriks diagonal dari dekomposisi singular dari matriks fitur terpusat <img src="https://tex.s2cms.ru/svg/X" alt="X">  sebagai berikut: </p><br><p>  Kami mewakili dekomposisi singular kami dari matriks berpusat X (SVD) sebagai <img src="https://tex.s2cms.ru/svg/X%3DUDV%5ET" alt="X = UDV ^ T">  dimana <img src="https://tex.s2cms.ru/svg/D" alt="D">  Merupakan matriks diagonal yang terdiri dari nilai singular.  Dalam bentuk ini <img src="https://tex.s2cms.ru/svg/l_2" alt="l_2">  - Regularisasi dapat diwakili: <br><img src="https://tex.s2cms.ru/svg/%5Cbeta%5ET%20VZV%5ET%20%5Cbeta" alt="\ beta ^ T VZV ^ T \ beta">  dimana <img src="https://tex.s2cms.ru/svg/Z" alt="Z">  - matriks diagonal yang berisi fungsi kuadrat dari nilai singular: <img src="https://tex.s2cms.ru/svg/Z_%7B11%7D%3Df_1%20(d_1%5E2%2Cd_2%5E2%2C%E2%80%A6%2Cd_m%5E2%20)%2C%E2%80%A6%2CZ_%7B22%7D%3Df_2%20(d_1%5E2%2Cd_2%5E2%2C%E2%80%A6%2Cd_m%5E2%20)" alt="Z_ {11} = f_1 (d_1 ^ 2, d_2 ^ 2, ..., d_m ^ 2), ..., Z_ {22} = f_2 (d_1 ^ 2, d_2 ^ 2, ..., d_m ^ 2)">  . </p><br><p>  Secara umum, dalam <img src="https://tex.s2cms.ru/svg/l_2" alt="l_2">  -regulasi <img src="https://tex.s2cms.ru/svg/Z_%7Bjj%7D%3D1" alt="Z_ {jj} = 1">  untuk semua <img src="https://tex.s2cms.ru/svg/j" alt="j">  yang sesuai <img src="https://tex.s2cms.ru/svg/%5Cbeta%5ET%20%5Cbeta" alt="\ beta ^ T \ beta">  .  Mereka menyarankan meminimalkan fungsi berikut: </p><br><p><img src="https://habrastorage.org/webt/6l/fj/lv/6lfjlv9m-zy8qfhcvrcqcymuuxa.jpeg"></p><br><p>  Di sini <img src="https://tex.s2cms.ru/svg/D" alt="D">  - matriks perbedaan elemen diagonal <img src="https://tex.s2cms.ru/svg/d_1%5E2-d_1%5E2%2Cd_1%5E2-d_2%5E2%2C%E2%80%A6%2Cd_1%5E2-d_m%5E2" alt="d_1 ^ 2-d_1 ^ 2, d_1 ^ 2-d_2 ^ 2, ..., d_1 ^ 2-d_m ^ 2">  .  Dengan kata lain, kami mengontrol vektor <img src="https://tex.s2cms.ru/svg/%5Cbeta%20" alt="\ beta">  menggunakan hyperparameter juga <img src="https://tex.s2cms.ru/svg/%5Ctheta" alt="\ theta">  . <br>  Mengubah ungkapan ini, kami mendapatkan solusinya: </p><br><p><img src="https://habrastorage.org/webt/vf/qs/6b/vfqs6b8fnqo3bmlacyr5j4fpigs.jpeg"></p><br><p>  Tetapi "fitur" utama dari metode ini, tentu saja, adalah kemampuan untuk mengelompokkan data, dan atas dasar kelompok-kelompok ini untuk menyoroti komponen utama kelompok.  Kemudian kami menulis ulang solusi kami dalam bentuk: </p><br><p><img src="https://habrastorage.org/webt/9l/ij/wc/9lijwc3_kvwtvxalszzyt4zq4l4.jpeg"></p><br><p>  Di sini <img src="https://tex.s2cms.ru/svg/%5Cbeta_k" alt="\ beta_k">  - vektor subvektor <img src="https://tex.s2cms.ru/svg/%5Cbeta" alt="\ beta">  sesuai dengan grup k, <img src="https://tex.s2cms.ru/svg/d_k%3D(d_%7Bk1%7D%2C%E2%80%A6%2Cd_%7Bkmk%7D)" alt="d_k = (d_ {k1}, ..., d_ {kmk})">  - nilai tunggal <img src="https://tex.s2cms.ru/svg/X_k" alt="X_k">  diatur dalam urutan menurun, dan <img src="https://tex.s2cms.ru/svg/D_%7Bd_%7Bk1%7D%5E2-d_%7Bkj%7D%5E2%7D" alt="D_ {d_ {k1} ^ 2-d_ {kj} ^ 2}">  - matriks diagonal <img src="https://tex.s2cms.ru/svg/d_%7Bk1%7D%5E2-d_%7Bkj%7D%5E2%2C%20j%3D1%2C2%2C%E2%80%A6%2Cm_k" alt="d_ {k1} ^ 2-d_ {kj} ^ 2, j = 1,2, ..., m_k"></p><br><p>  Beberapa catatan tentang solusi fungsional target: </p><br><ol><li><p>  Fungsi obyektif adalah cembung, dan komponen yang tidak halus dapat dipisahkan.  Oleh karena itu, dapat dioptimalkan secara efektif menggunakan gradient descent. <br>  Pendekatannya adalah dengan mengkomit banyak nilai <img src="https://tex.s2cms.ru/svg/%5Ctheta" alt="\ theta">  (termasuk nol, masing-masing, mendapatkan standar <img src="https://tex.s2cms.ru/svg/l_1" alt="l_1">  -regulasi), dan kemudian mengoptimalkan: <img src="https://habrastorage.org/webt/uz/bf/eo/uzbfeori9kupj8b05x46dcj6iri.jpeg">  mengambil <img src="https://tex.s2cms.ru/svg/%5Clambda" alt="\ lambda">  .  Dengan demikian, parameter <img src="https://tex.s2cms.ru/svg/%5Ctheta" alt="\ theta">  dan <img src="https://tex.s2cms.ru/svg/%5Clambda" alt="\ lambda">  dipilih untuk validasi silang. </p><br></li><li><p>  Parameter <img src="https://tex.s2cms.ru/svg/%5Ctheta" alt="\ theta">  sulit diartikan.  Dalam perangkat lunak (paket pcLasso), pengguna sendiri menetapkan nilai parameter ini, yang termasuk dalam interval [0,1], di mana 1 sesuai dengan <img src="https://tex.s2cms.ru/svg/%5Ctheta" alt="\ theta">  = 0 (laso). </p><br></li></ol><br><p>  Dalam praktiknya, variasikan nilainya <img src="https://tex.s2cms.ru/svg/%5Ctheta" alt="\ theta">  = 0,25, 0,5, 0,75, 0,9, 0,95 dan 1, Anda dapat mencakup berbagai model. </p><br><p>  <em>Algoritma itu sendiri adalah sebagai berikut</em> <br><img src="https://habrastorage.org/webt/l-/3x/si/l-3xsipork2hzeh7ws1bg1hz86o.jpeg"></p><br><p>  Algoritma ini sudah ditulis dalam R, jika Anda mau, Anda sudah bisa menggunakannya.  Perpustakaan itu disebut 'pcLasso'. </p><br><h2>  Jackknife Infinitesimal Tentara Swiss </h2><br><p>  Ryan Giordano (UC Berkeley);  William Stephenson (MIT);  Runjing Liu (UC Berkeley); <br>  Michael Jordan (UC Berkeley);  Tamara Broderick (MIT) </p><br><p>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel</a> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kode</a> </p><br><p>  Kualitas algoritma pembelajaran mesin sering diukur dengan multi-validasi silang (cross-validation atau bootstrap).  Metode ini sangat kuat, tetapi lambat pada set data besar. </p><br><p>  Dalam pekerjaan ini, kolega menggunakan perkiraan bobot, menghasilkan hasil yang bekerja lebih cepat.  Perkiraan linier ini dikenal dalam literatur statistik sebagai "pisau lipat kecil".  Ini terutama digunakan sebagai alat teoritis untuk membuktikan hasil asimptotik.  Hasil artikel ini berlaku terlepas dari apakah bobot dan data bersifat stokastik atau deterministik.  Sebagai konsekuensinya, perkiraan ini secara berurutan memperkirakan validasi silang sebenarnya untuk setiap k tetap. </p><br><p>  <em>Penyajian Paper Award kepada penulis artikel</em> <br><img src="https://habrastorage.org/webt/3n/1a/-k/3n1a-kygdmkbs0drfjdg38b9z5g.jpeg"></p><br><p>  <strong>Esensi dari metode ini</strong> </p><br><p>  Pertimbangkan masalah estimasi parameter yang tidak diketahui <img src="https://tex.s2cms.ru/svg/%5Ctheta%20%5Cin%20%5COmega_%7B%5Ctheta%7D%20%5Csubset%20R%5E%7BD%7D" alt="\ theta \ in \ Omega _ {\ theta} \ subset R ^ {D}">  dimana <img src="https://tex.s2cms.ru/svg/%5COmega_%7B%5Ctheta%7D%20" alt="\ Omega _ {\ theta}">  Ringkas, dan ukuran dataset kami adalah <img src="https://tex.s2cms.ru/svg/N" alt="N">  .  Analisis kami akan dilakukan pada kumpulan data tetap.  Tentukan peringkat kami <img src="https://tex.s2cms.ru/svg/%5Ctheta%20%5Cin%20%5COmega_%7B%5Ctheta%7D%20" alt="\ theta \ in \ Omega _ {\ theta}">  sebagai berikut: </p><br><ol><li>  Untuk masing-masing <img src="https://tex.s2cms.ru/svg/n%3D1%2C2%E2%80%A6%2CN" alt="n = 1,2 ..., N">  diatur <img src="https://tex.s2cms.ru/svg/g_n" alt="g_n">  ( <img src="https://tex.s2cms.ru/svg/%5Ctheta" alt="\ theta">  ) Merupakan fungsi dari <img src="https://tex.s2cms.ru/svg/%5COmega_%7B%5Ctheta%7D%20%5Csubset%20R%5E%7BD%7D" alt="\ Omega _ {\ theta} \ subset R ^ {D}"></li><li><img src="https://tex.s2cms.ru/svg/%5Comega_n%20" alt="\ omega_n">  Adalah bilangan real, dan <img src="https://tex.s2cms.ru/svg/%5Comega" alt="\ omega">  Merupakan vektor yang terdiri dari <img src="https://tex.s2cms.ru/svg/%5Comega_n" alt="\ omega_n"></li></ol><br><p>  Lalu <img src="https://tex.s2cms.ru/svg/%5Chat%7B%5Ctheta%7D" alt="\ hat {\ theta}">  dapat direpresentasikan sebagai: </p><br><p><img src="https://habrastorage.org/webt/zh/ce/yi/zhceyifw80rl6neeoaedkd7x-20.jpeg"></p><br><p>  Memecahkan masalah optimisasi ini dengan metode gradien, kami mengasumsikan bahwa fungsinya dapat dibedakan dan kita dapat menghitung Hessian.  Masalah utama yang kami selesaikan adalah biaya komputasi yang terkait dengan evaluasi <img src="https://tex.s2cms.ru/svg/%5Chat%7B%5Ctheta%7D%20%CC%82(%5Comega)" alt="\ hat {\ theta} ̂ (\ omega)">  untuk semua <img src="https://tex.s2cms.ru/svg/%5Comega%E2%88%88W" alt="\ omega∈W">  .  Kontribusi utama penulis artikel adalah menghitung estimasi <img src="https://tex.s2cms.ru/svg/%5Chat%7B%5Ctheta%7D_1%3D%5Chat%7B%5Ctheta%7D_1%20(1_%7B%5Comega%7D)" alt="\ hat {\ theta} _1 = \ hat {\ theta} _1 (1 _ {\ omega})">  dimana <img src="https://tex.s2cms.ru/svg/1_%5Comega%3D(1%2C1%2C%E2%80%A6%2C1)" alt="1_ \ omega = (1,1, ..., 1)">  .  Dengan kata lain, optimasi kami hanya akan bergantung pada turunannya <img src="https://tex.s2cms.ru/svg/g_n%20(%5Ctheta)" alt="g_n (\ theta)">  yang kami anggap ada dan Hessian: </p><br><p><img src="https://habrastorage.org/webt/tb/zb/t2/tbzbt2u2q_bdqidfjxfl9ywqesc.jpeg"></p><br><p>  Selanjutnya, kita mendefinisikan persamaan dengan titik tetap dan turunannya: <br><img src="https://habrastorage.org/webt/hj/8f/x3/hj8fx3broftye-ssmq4mwpkvaui.jpeg"></p><br><p>  Ini ada baiknya memperhatikan itu <img src="https://tex.s2cms.ru/svg/G(%5Ctheta%20%CC%82(%5Comega)%2Cw)%3D0" alt="G (\ theta ̂ (\ omega), w) = 0">  sejak itu <img src="https://tex.s2cms.ru/svg/%5Chat%7B%5Ctheta%7D%20(%5Comega)" alt="\ hat {\ theta} (\ omega)">  - solusi untuk <img src="https://tex.s2cms.ru/svg/%5Cfrac%7B%201%20%7D%7B%20N%20%7D%20%5Csum_%7Bn%3D1%7D%5E%7BN%7D%20%5Comega_n%20g_n%20(%5Ctheta)%3D0" alt="\ frac {1} {N} \ sum_ {n = 1} ^ {N} \ omega_n g_n (\ theta) = 0">  .  Kami juga mendefinisikan: <img src="https://tex.s2cms.ru/svg/H_1%3DH(%5Chat%7B%5Ctheta%7D_1%2C1_%5Comega)" alt="H_1 = H (\ hat {\ theta} _1,1_ \ omega)">  , dan matriks bobot sebagai: <img src="https://tex.s2cms.ru/svg/%5CDelta%5Comega%3D%20%5Comega-1_%5Comega%20%5Cin%20R%5E%7Bn%7D" alt="\ Delta \ omega = \ omega-1_ \ omega \ dalam R ^ {n}">  .  Dalam hal kapan <img src="https://tex.s2cms.ru/svg/H_1" alt="H_1">  memiliki matriks terbalik, kita dapat menggunakan teorema fungsi implisit dan 'aturan rantai': </p><br><p><img src="https://habrastorage.org/webt/c7/iv/x2/c7ivx2dadeupxwlo2hzgmxslrxe.jpeg"></p><br><p>  Derivatif ini memungkinkan kita untuk membentuk perkiraan linier <img src="https://tex.s2cms.ru/svg/%5Chat%7B%5Ctheta%7D%20%CC%82(%5Comega)" alt="\ hat {\ theta} ̂ (\ omega)">  melalui <img src="https://tex.s2cms.ru/svg/%5Chat%7B%5Ctheta%7D_1" alt="\ hat {\ theta} _1">  yang terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/webt/lc/rc/5h/lcrc5hirn1act9jl8lp2jakjpsk.jpeg"></p><br><p>  Sejak <img src="https://tex.s2cms.ru/svg/%5Chat%7B%5Ctheta%7D_%7BIJ%7D" alt="\ hat {\ theta} _ {IJ}">  hanya bergantung pada <img src="https://tex.s2cms.ru/svg/%5Chat%7B%5Ctheta%7D_1" alt="\ hat {\ theta} _1">  dan <img src="https://tex.s2cms.ru/svg/%5CDelta%20%5Comega" alt="\ Delta \ omega">  , dan bukan dari solusi untuk nilai lainnya <img src="https://tex.s2cms.ru/svg/%5Comega" alt="\ omega">  , oleh karena itu, tidak perlu menghitung ulang dan menemukan nilai baru new.  Sebagai gantinya, seseorang perlu menyelesaikan SLE (sistem persamaan linear). </p><br><p>  <strong>Hasil</strong> </p><br><p>  Dalam praktiknya, ini secara signifikan mengurangi waktu dibandingkan dengan validasi silang: <br><img src="https://habrastorage.org/webt/sw/dr/6-/swdr6-j8t7pqcdwf_96705qs1tg.jpeg"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id458388/">https://habr.com/ru/post/id458388/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id458374/index.html">TJBOT sebagai ilustrasi layanan IBM Watson</a></li>
<li><a href="../id458376/index.html">Bukan bahasa pemrograman lain. Bagian 1: Logika Domain</a></li>
<li><a href="../id458378/index.html">Menggunakan Avocode untuk tata letak situs. Tinjau untuk pemula. Bonus - mendaftar periode percobaan 30 hari</a></li>
<li><a href="../id458382/index.html">Mengapa kita mengajarkan ini?</a></li>
<li><a href="../id458384/index.html">HP 3D Structured Light Scanner Pro S3 Ulasan dan Uji</a></li>
<li><a href="../id458390/index.html">Ceph - dari "di lutut" ke "produksi" bagian 2</a></li>
<li><a href="../id458394/index.html">Mengamankan protokol nirkabel menggunakan LoRaWAN sebagai contoh</a></li>
<li><a href="../id458396/index.html">Bagaimana saya membuat pengembangan di Vue.js nyaman dengan rendering sisi server</a></li>
<li><a href="../id458398/index.html">Kebersihan pekerjaan jarak jauh atau manfaat telepati</a></li>
<li><a href="../id458400/index.html">Arsitektur & implementasi Microservices Langkah-demi-Langkah Bagian 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>