<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👴🏼 👨🏻‍🔬 👸🏽 创建程序生成的地图的边框 📥 🐜 🥋</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="斯科特·特纳（Scott Turner）继续从事他的程序化游戏的工作，现在决定解决设计地图边框的问题。 为此，他必须解决一些难题，甚至必须创建自己的语言来描述边界。 

 边界仍然是幻想卡的重要元素，幻想卡在我的名单上已经存在了一段时间。 功能地图通常具有简单的边界线 ，但是幻想地图和中世纪地图（其...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>创建程序生成的地图的边框</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444190/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ce/ea0/3df/0ceea03df1f07131e0ad27e6bbd45731.png" alt="图片"></div><br>  <i>斯科特·特纳（Scott Turner）继续从事他的程序化游戏的工作，现在决定解决设计地图边框的问题。</i>  <i>为此，他必须解决一些难题，甚至必须创建自己的语言来描述边界。</i> <br><br> 边界仍然是幻想卡的重要元素，幻想卡在我的名单上已经存在了一段时间。 功能地图通常具有简单的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">边界线</a> ，但是幻想地图和中世纪地图（其中前者经常借鉴思想）具有相当周到且具有艺术性的边界。 这些边界清楚地表明，地图是有意制作的，给观众一种奇观的感觉。 <br><br> 目前，在《 <b>Dragons Abound》</b>游戏中有几种简单的绘制边界的方法。 她可以在地图的周围绘制单线或双线，并在拐角处添加简单的元素，如下图所示： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aed/9f8/477/aed9f8477ef53b5550b742ea1fde36b2.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cac/37e/bac/cac37ebac81815955dfc940bacdc2eff.png"></div><br> 游戏还可以在边框的底部添加一个字段，用于输入地图名称。  《 <b>龙腾飞腾》</b>中此字段有多种变体，包括诸如假螺丝头之类的复杂元素： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/42f/f6f/c3a/42ff6fc3adae5b40293bb82d5a1be325.png"></div><br> 这些名称字段存在差异，但是它们都是手动创建的。 <br><br> 幻想卡片边界的一个有趣方面是，它们既具有创造力又是模板。 通常，它们由少量简单元素组成，这些元素以不同的方式组合在一起以产生独特的结果。 与往常一样，对我来说，处理新主题时的第一步是研究地图示例的集合，创建边界元素类型的目录，并研究其外观。 <br><a name="habracut"></a><br> 最简单的边界是一条沿地图边缘延伸并指示其边界的线。 正如我上面所说的，它也称为“框架线”： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/99f/c81/c98/99fc81c98e1092077272081464d28752.png"></div><br> 地图中边框的位置也有所不同。 在此版本中，地图到达图像的边缘，但是边框在图像内部创建了虚拟边框： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43f/aef/1db/43faef1db7bf3af195c857d7ed673710.png"></div><br> 可以使用任何类型的边框来完成此操作，但通常仅用于简单边框（如框架的边框）。 <br><br> 流行的幻想卡片设计概念是模拟仿佛它们是在旧的破烂的羊皮纸上绘制的。 有时这是通过将边框绘制为纸张的粗糙边缘来实现的： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/907/cb2/ff1/907cb2ff125bbd178f9a16717e5e724f.png"></div><br> 这是一个更复杂的示例： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/751/860/d6e/751860d6e43ed2e857cf6f3ba7f766e0.png"></div><br> 以我的经验，由于使用了数字工具，因此这种方法不太流行。 如果您希望卡片看起来像旧的破烂的羊皮纸，那么将羊皮纸纹理应用于卡片比手动绘制要容易得多。 <br><br> 创建地图边框最强大的工具是可重复性。 在最简单的情况下，重复一行以创建两行就足够了： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31d/139/e12/31d139e129fe513e07937c5a2bd88979.png"></div><br> 您可以通过更改重复元素的样式来增加对地图的兴趣，在这种情况下，可以通过将粗线和细线组合在一起来实现： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/530/ccd/118/530ccd11872f4aa6a32d4b3271cf94f3.png"></div><br> 根据元素的不同，可能会有各种样式变化。 在此示例中，该行重复出现，但是颜色发生了变化： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc7/89e/96c/fc789e96ccfba58ac4cb595e5ec33fb7.png"></div><br> 要创建更复杂的模式，可以使用“可重复性”。 该边框由大约五条不同宽度和距离的单线组成： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/796/488/ef4/796488ef402e59ed7e092e0e14ff2469.png"></div><br> 此边框重复了线条，但将它们分开，使它们看起来像两个单独的细边框。 在本文的这一部分中，我将不讨论角度的处理，但是两条线的不同角度也有助于造成这种差异。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97b/fd8/336/97bfd833697b9278660772c1bd04ee46.png"></div><br> 这是两行，四行还是六行？ 我认为这完全取决于您如何绘制它们！ <br><br> 样式化的另一个元素是用颜色，图案或纹理填充元素之间的空间。 在此示例中，由于两行之间的强调色填充，边框变得更加有趣： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d8/ccf/158/1d8ccf158b9ae0378ddaef1031ba15c9.png"></div><br> 这是如何用图案填充边框的示例： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f87/37d/bb2/f8737dbb215166947e42f0da1b45cfc7.png"></div><br> 同样，可以对元素进行样式设置，使它们看起来是三维的。 这是一张地图，其中的边框被着色以使其看起来很丰富： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a80/25b/695/a8025b69549773f8935d2b37680401a3.png"></div><br> 在此地图中，边框被着色为看起来是三维的，并且与边界在地图边缘内的位置结合在一起： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/36c/899/9e7/36c8999e74172c962aef40a4a9e3addc.png"></div><br> 另一个常见的边框元素是彩色条纹形式的比例尺： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ee/f62/0b8/4eef620b830eb0249d019229140e34e6.png"></div><br> 这些条纹形成一个栅格（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">制图栅格</a> ）。 在真实地图上，比例尺有助于确定距离，但是在幻想地图上，比例尺主要是装饰元素。 <br><br> 这些条纹通常以黑白绘制，但有时会添加红色或其他颜色： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/450/f0f/f67/450f0ff67ac1fdf5c5e2ffaf8fbe80c0.png"></div><br> 该元素也可以与其他元素组合，例如在本示例中使用线条和比例尺： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/313/d56/29d/313d5629d6ec8b8d7c7c4c1ead322a09.png"></div><br> 这个例子有点不寻常。 通常，比例尺（如果有）是边框的最内部元素。 <br><br> 在此地图上，具有不同分辨率的不同比例尺（以及奇怪的符文注释！）： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/74b/cd6/217/74bcd62173160e440a4ee6cfad2128c1.png"></div><br>  （在Reddit上，用户<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">AbouBenAdhem</a>告诉我，符文标记是用巴比伦楔形文字写的数字48和47。此外，“具有不同分辨率的标度”有6个格，分为10个较小的格，对应于巴比伦的十六进制数字系统。通常我指出了地图的来源，但是这篇文章中有太多小作品，所以我没有理会。但是， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">这张地图是</a>由<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">托马斯·雷</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Thomas Ray）</a>为作者S.E.博林（S.E. Boleyn <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">）</a>创建的，所以也许他书中的动作发生在巴比伦的随行人员中。） <br><br> 除了线条和比例尺外，最常见的元素是重复的几何图案。 它通常由圆形，菱形和矩形等部分组成： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/31c/6ba/f61/31c6baf612bf2fa11a13905e4482d82e.png"></div><br> 可以对几何元素（如线）进行阴影处理以使其看起来是三维的： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/43e/cc8/c33/43ecc8c33bbf3143ba32c18b878d16e2.png"></div><br> 可以通过以不同方式组合这些元素来创建复杂的边界。 这是结合了线条，几何图案和比例的边框： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b7/70e/c95/7b770ec95296ce07e0d18ede205c8798.png"></div><br> 上面显示的示例是数字卡，但是，当然，手写卡也可以完成相同的操作。 这是一个手工创建的简单几何图案的示例： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6f7/c2d/e3d/6f7c2de3d5db82a9c7e9884d726be98e.png"></div><br> 这些元素还可以通过多种方式灵活组合。 这是结合了“边缘参差不齐”的几何图案： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0fa/f1a/150/0faf1a15052e90a479428c4c495ad44c.png"></div><br> 在上面显示的示例中，几何图案非常简单。 但是您可以通过以不同方式组合基本几何元素来创建非常复杂的图案： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/38e/13f/fc2/38e13ffc2a2aac266aabb291a7d7f0e6.png"></div><br> 图案的另一个流行元素是编织或凯尔特结： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07e/00e/8d8/07e00e8d868b6ca48be746fbe07e61ca.png"></div><br> 这是一个更复杂的柳条边框，其中包含颜色，比例和其他元素： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e1/580/140/5e158014012fffcbc51e2e3fe71772d6.png"></div><br> 在此地图上，编织与边缘参差不齐的元素结合在一起： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e95/4df/588/e954df58825bc42d408b61804a1287a9.png"></div><br> 除了几何图案和编织以外，任何重复的图案都可以成为卡片边框的一部分。 这是使用类似于箭头的形状的示例： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7be/5ce/64e/7be5ce64eb09de2eeefdb18992978d03.png"></div><br> 这是一个重复波形的示例： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/841/c13/3c2/841c133c2f1c0f724b5d076e5ea415fb.png"></div><br> 最后，符文或幻想字母的其他元素有时会添加到幻想卡的边缘： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15f/6dd/3a3/15f6dd3a3e6191da02dc884193b72c82.png"></div><br> 以上示例摘自现代幻想地图，但以下是带有线条和手绘图案的历史（18世纪）地图示例： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d7/b9f/3b8/1d7b9f3b8f0c7eb296079c5f6f6b23aa.png"></div><br> 当然，您可以找到边界带有许多其他元素的地图示例。 一些最漂亮的是完全手工绘制的，并具有精心制作的装饰，以至于它们可以超越卡片本身（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">《阿尔玛世界》</a> ，弗朗西斯卡·巴格拉德）： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1c7/004/e18/1c7004e186e0d2be63b98539375316ff.png"></div><br> 关于<i>对称性</i>也值得一提。 像重复性一样，对称性是一种强大的工具，地图边界通常是对称的或具有对称的元素。 <br><br> 许多地图边框从内到外都是对称的，如以下示例所示： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/796/488/ef4/796488ef402e59ed7e092e0e14ff2469.png"></div><br> 在此，边框由多条填充和不填充的线组成，但理想情况是从外向内相对于边框的中心重复。 <br><br> 在这个更复杂的示例中，边框是对称的，除了比例尺的黑白条纹交替出现： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5e1/580/140/5e158014012fffcbc51e2e3fe71772d6.png"></div><br> 由于复制比例尺没有意义，因此即使边框的其余部分是对称的，也经常将其视为单独的元素。 <br><br> 除了内部-外部对称之外，边界通常沿其长度重新对称。 一些显示的边框可能具有简单的设计，跨越了地图边缘的整个长度，但在大多数情况下，图案很短且重复，从一个角到另一个角填充了边框： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b7/70e/c95/7b770ec95296ce07e0d18ede205c8798.png"></div><br> 请注意，在此示例中，模式包含一个不对称的元素（从左到右），但是常规模式是对称的并重复： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7be/5ce/64e/7be5ce64eb09de2eeefdb18992978d03.png"></div><br> 该规则的一个显着例外是边框充满了符文或字母字符。 通常，它们看起来是唯一的，就像在边框上写了一些长消息一样： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15f/6dd/3a3/15f6dd3a3e6191da02dc884193b72c82.png"></div><br> 当然，这里还没有考虑其他许多地图边框元素的示例，但是我们已经有了一个很好的参考点。 在接下来的几部分中，我将在<b>Dragons Abound中</b>开发一些功能，以描述，显示并以程序方式生成类似于这些示例的地图边框。 在第二部分中，我们将从设置用于描述地图边界的语言开始。 <br><br><h2> 第二部分 </h2><br> 在这一部分中，我将创建“地图边框描述语言”（MBDL）的初始版本。 <br><br> 为什么要花时间创建地图边界描述语言？ 首先，这将是我这一代人的目标。 稍后，我将编写一种用于创建新地图边界的算法，该算法的输出将是对MBDL上新边界的描述。 其次，MBDL将用作地图边界的文本表示。 特别是，我需要能够保存和重用我喜欢的边框。 为此，我需要一个可以书写并用于重新创建地图边框的文本符号。 <br><br> 我将通过定义最简单的元素（线）开始创建MBDL。 该线具有颜色和宽度。 因此，在MBDL中，我将以以下形式显示该行： <br><br><blockquote><code>L(width, color)</code> </blockquote> <br> 以下是一些示例（对不起我的Photoshop技能）： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/db2/db8/68e/db2db868ede7282a34c695f8062a691b.png"></div><br> 元素的顺序是从外部到内部（*）的，因此我们假定这是地图顶部的边框： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b7c/75e/b3a/b7c75eb3aefb8f77d1915166c0bdd979.png"></div><br> 看第二个示例-带边框的线表示为三个单独的线元素。 <br><br>  <i>（*从外部到内部进行绘制是一个任意选择-在我看来，这比从内部向外部进行绘制更为自然。不幸的是，由于后来发现，有充分的理由朝相反的方向进行工作。很快我会告诉您的，但是一切都留在了帖子中-旧的，因为重做所有插图会花费很多时间）</i> <br><br> 方便地，空格可以表示为没有颜色的线： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ba/1a4/171/0ba1a41719610641d7b5a5e26da0692e.png"></div><br> 但是具有特定的垂直空间元素会更直观： <br><br><blockquote>  VS（宽度） </blockquote><br> 以下简单元素是几何形状：条纹，菱形和椭圆形。 假定线条在边框的整个长度上伸展，因此它们没有明确指定的长度。 但是几何图形不能填满整条线，因此，除了宽度（*）外，每个几何图形还必须具有长度，轮廓颜色，轮廓宽度和填充颜色： <br><br><blockquote> <code>B(width, length, outline, outline width, fill) <br> D(width, length, outline, outline width, fill) <br> E(width, length, outline, outline width, fill)</code> </blockquote> <br>  （*我接受了，我将考虑从外到内的方向上的宽度，并沿着边框测量长度。） <br><br> 以下是简单几何形状的示例： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a3d/fad/cf6/a3dfadcf6a5a98a9785b0b487a6e17fc.png"></div><br> 为了使这些元素填充边框的整个长度，必须重复它们。 为了指示将重复以填充边框长度的元素组，我使用方括号： <br><br><blockquote> <code>[ element element element ... ]</code> </blockquote> <br> 这是矩形和菱形的重复图案的示例： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/420/d88/64e/420d8864e72e178252766172dc0320ab.png"></div><br> 有时，在重复模式的元素之间需要一个（水平）空间。 尽管您可以使用没有颜色的元素来创建空间，但是拥有水平空间元素会更聪明，更方便： <br><br><blockquote> <code>HS(length)</code> </blockquote> <br>  MBDL的第一次迭代所需的最后一个功能是能够将元素堆叠在彼此之上。 这是边框示例： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ea/7e9/3f3/8ea7e93f3040563ef7ec2715ca39a14d.png"></div><br> 描述它的最简单方法是在上方图案下的一条宽黄线。 您可以通过不同的方式（例如，负的垂直空间）实现此目的，但是我决定使用花括号指示元素向内的顺序： <br><br><blockquote> <code>{element element element ...}</code> </blockquote> <br> 实际上，该条目告诉您记住进入方括号时图案从外向内的位置，然后在离开方括号时返回到该点。 括号也可被视为对占据垂直空间的元素的描述。 因此，上面显示的边框可以描述如下： <br><br><blockquote> <code><b>L(1, black) <br> {L(20, yellow)} <br> VS(3) <br> [B(5, 10, black, 3, none) <br> D(5, 10, black,3,red)] <br> VS(3) <br> L(1, black)</b></code> </blockquote> <br> 我们绘制一条黑线，固定在哪里，绘制一条黄线，然后返回到先前的固定位置，放下一点，绘制矩形和菱形图案，放下一点，然后再绘制一条黑线。 <br><br>  MBDL还有很多事情要做，但这足以描述地图的许多边界。 下一步是将MBDL上的边界描述转换为边界本身。 这类似于将计算机程序（例如Javascript）的书面表示形式转换为该程序的执行形式。 第一步是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">语言的词法分析（解析）</a> -将源文本转换为地图的真实边框或某种易于转换为边框的中间形式。 <br><br> 解析是计算机科学领域中经​​过充分研究的领域。 解析语言不是很简单，但是在我们的例子中，MBDL是一种无<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上下文</a>语法，这很不错（*）。 上下文无关的语法很容易解析，并且有许多针对它们的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Javascript解析工具</a> 。 我选择了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Nearley.js</a> ，它似乎已经相当成熟，并且（更重要的是）一个有据可查的工具。 <br><br>  <i>（*这不只是运气，我确保该语言是上下文无关的。）</i> <br><br> 我不会向您介绍无上下文语法，但是Nearley语法非常简单，您应该毫无问题地理解其含义。 语法Nearley由一组规则组成。 每个规则在规则的左侧，箭头和右侧都有一个字符，该字符可以是字符和非字符的序列，以及用“ |”分隔的各种选项  （或）： <br><br><blockquote> <code><b>border -&gt; element | element border <br> element -&gt;</b> “ <b>L"</b></code> </blockquote> <br> 每个规则都说左侧可以用右侧的任何选项代替。 也就是说，第一个规则说一个边界是一个元素或一个元素，后跟另一个边界。 本身可以是元素，也可以是后跟边框的元素，依此类推。 第二条规则说，一个元素只能是字符串“ L”。 也就是说，这些规则共同对应于以下边界： <br><br><blockquote> <code><b>L <br> LLL</b></code> </blockquote> <br> 并且不符合以下边界： <br><br><blockquote> <code><b>X <br> L3L</b></code> </blockquote> <br> 顺便说一句，如果您想在Nearley中尝试这种（或任何其他）语法，那么这里有一个在线沙箱。 您可以输入语法和测试用例以查看其匹配项和不匹配项。 <br><br> 这是线图元的更完整定义： <br><br><blockquote> <code><b>@builtin “number.ne" <br> @builtin “string.ne" <br> border -&gt; element | element border <br> element -&gt; “L(" decimal “," dqstring “)"</b></code> </blockquote> <br>  Nearley有几个常见的内置元素，数字是其中之一。 因此，我可以用它来识别线图元的数值宽度。 对于颜色识别，我使用了另一个内置元素，并允许在双引号中使用任何字符串。 <br><br> 在不同字符之间添加空格会很好，所以让我们开始吧。  Nearley支持字符类，并且<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">RBNF</a>使用“：*”表示“零个或多个”，因此我可以使用它来指定“零个或多个空格”，并将其粘贴到任何地方以允许在说明中使用空格： <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element border <br> WS -&gt; [\s]:* <br> number -&gt; WS decimal WS <br> color -&gt; WS dqstring WS <br> element -&gt; "L(" number "," color ")"</b></code> </blockquote> <br> 但是，由于遍及WS的使用使语法难以阅读，因此我将放弃它们，但可以想象它们是。 <br><br> 元素也可以是垂直空间： <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element " " border <br> number -&gt; decimal <br> color -&gt; dqstring <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")"</b></code> </blockquote> <br> 这对应于这样的边界 <br><br><blockquote> <code><b>L(3.5,"black") VS(3.5)</b></code> </blockquote> <br> 接下来是带状，菱形和椭圆形的基元。 <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element " " border <br> number -&gt; decimal <br> color -&gt; dqstring <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")" <br> geometric -&gt; "B(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "E(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "D(" number "," number "," color "," number "," color ")"</b></code> </blockquote> <br> 它将匹配这样的元素 <br><br><blockquote> <code><b>B(34, 17, "white", 3, "black")</b></code> </blockquote> <br>  （请注意，几何图元不是“元素”，因为它们不能在顶层单独存在。必须将其包含在模式中。） <br><br> 我还需要一个水平空间图元： <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element " " border <br> number -&gt; decimal <br> color -&gt; dqstring <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")" <br> geometric -&gt; "B(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "E(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "D(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "HS(" number ")"</b></code> </blockquote> <br> 现在，我将添加一个模式（重复）操作。 这是方括号内的一个或多个元素的序列。 我将使用RBNF运算符“：+”，在这里表示“一个或多个”。 <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element " " border <br> number -&gt; decimal <br> color -&gt; dqstring <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")" <br> geometric -&gt; "B(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "E(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "D(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "HS(" number ")" <br> element -&gt; "[" (geometric):+ "]"</b></code> </blockquote> <br> 请注意，图案只能用几何图元填充。 例如，我们不能在图案内放置一条线。 现在pattern元素将匹配这样的内容。 <br><br><blockquote> <code><b>[B(34,17,"white",3,"black")E(13,21,"white",3,"rgb(27,0,0)")]</b></code> </blockquote> <br> 语言的最后一部分是覆盖运算符。 这是括号内任意数量的元素。 <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; element | element " " border <br> number -&gt; decimal <br> color -&gt; dqstring <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")" <br> geometric -&gt; "B(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "E(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "D(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "HS(" number ")" <br> element -&gt; "[" (geometric ):+ "]" <br> element -&gt; "{" (element ):+ "}"</b></code> </blockquote> <br> 这使我们可以执行以下操作： <br><br><blockquote> <code><b>{L(3.5,"rgb(98,76,15)")VS(3.5)}</b></code> </blockquote> <br>  （请注意，与重复运算符不同，可以在内部使用overlay运算符。） <br><br> 清除描述并在必要的位置添加空格后，我们得到以下MBDL语法： <br><br><blockquote> <code><b>@builtin "number.ne" <br> @builtin "string.ne" <br> border -&gt; (element WS):+ <br> WS -&gt; [\s]:* <br> number -&gt; WS decimal WS <br> color -&gt; WS dqstring WS <br> element -&gt; "L(" number "," color ")" <br> element -&gt; "VS(" number ")" <br> element -&gt; "(" WS (element WS):+ ")" <br> element -&gt; "[" WS (geometric WS):+ "]" <br> geometric -&gt; "B(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "E(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "D(" number "," number "," color "," number "," color ")" <br> geometric -&gt; "HS(" number ")"</b></code> </blockquote> <br> 因此，现在已经定义了MBDL，并且我们已经创建了该语言的语法。 它可以与Nearley一起使用以识别语言字符串。 在深入研究MBDL / Nearley之前，我想实现MBDL中使用的原语，以便可以显示MBDL上描述的边界。 我们将在下一部分中进行此操作。 <br><br><h2> 第三部分 </h2><br> 现在我们将开始自己实现渲染原语。  （目前，我还不需要将解析器绑定到呈现原语。为了进行测试，我将手动对其进行调用。） <br><br> 让我们从原始行开始。 回忆一下它的样子： <br><br><blockquote> <code><b>L(width, color)</b></code> </blockquote> <br> 除了宽度和颜色，这里还有一个隐式参数-距地图外边缘的距离。  （我从地图的边缘向外绘制边界。请注意，我们从另一个边界开始！）它不应指向MBDL，因为运行MBDL绘制边界的解释器可以跟踪该边界。 但是，应将其输入所有渲染图元，以便它们知道在何处绘制它们。 我称这个参数为偏移量。 <br><br> 如果只需要在地图顶部绘制边框，则线图元将非常容易实现。 但是，实际上，我将需要从上方进行绘制。 底部，左侧和右侧。  （也许有一天我会认识到倾斜或弯曲的边界，但是现在我们将遵循标准的矩形边界。）此外，线元素的长度和位置取决于地图的大小（以及偏移量）。 因此，作为参数，我需要所有这些数据。 <br><br> 设置所有这些参数后，只需创建一个线图元并使用它在地图上画一条线就足够了： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a56/74f/785/a5674f78512bef22e569656701203401.png"></div><br>  （请注意，我使用了<b>Dragons Abound的</b>各种功能来绘制“手写”线。）让我们尝试创建一个更复杂的边框： <br><br><blockquote> <code><b>L(3, black) L(10, gold) L(3, black)</b></code> </blockquote> <br> 看起来像这样： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/86a/ad8/849/86aad88494c1c17f993524ef09ef9b2f.png"></div><br> 还不错 请注意，在某些情况下，黑线和金线由于波动而无法完全对齐。 如果我想摆脱这些斑点，那么您可以简单地减少振荡量。 <br><br> 实现垂直空间图元非常简单； 它只是执行偏移增量。 让我们添加一些空间： <br><br><blockquote> <code><b>L(3, black) L(10, gold) L(3, black) <br> VS(5) <br> L(3, black) L(10, red) L(3, black)</b></code> </blockquote> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eab/471/b90/eab471b902eb44e703f460d700936937.png"></div><br> 在绘制线时，可以通过在偏移量和沿地图的顺时针方向之间绘制来实现角度。 但总的来说，我需要在地图边框的每一侧实现截断以创建<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">与bevel</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">角度连接</a> 。 这对于创建带有在拐角处正确连接的图案的边框是必要的，并且在通常情况下，将不需要绘制边缘具有一定角度的元素。  （*） <br><br>  <i>（注意：正如以下部分所述，随着时间的流逝，我在实现角度时拒绝使用截断区域。主要原因是要创建复杂的角度，例如正方形偏移：</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97b/fd8/336/97bfd833697b9278660772c1bd04ee46.png"></div><br>  <i>需要越来越复杂的截断区域。</i>  <i>另外，随着时间的流逝，我发现了一种更好的方法来处理角落的图案。</i>  <i>我决定不返回并重写本文的这一部分，而是决定保留它来说明“创造力”的过程。）</i> <br><br> 主要思想是沿对角线截断每个边框并创建四个截断区域，在该区域中将绘制边框的每一侧： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9fb/31a/cf9/9fb31acf993cde46b6a7fdc408be6afd.png"></div><br> 截断时，在相应区域中绘制的所有内容都会以所需的角度被切除。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/52b/f00/f02/52bf00f026f6979f6425345389fa646a.png"></div><br> 不幸的是，这会沿对角线产生小的间隙，这可能是因为浏览器未完全沿截断的边缘进行平滑处理。 测试表明，背景从两条边缘之间的缝隙中发出光芒。 可以通过稍微扩展其中一个遮罩来解决此问题（一半像素似乎足够了），但这有时不能解决问题。 <br><br> 接下来，您需要实现几何形状。 与线条不同，它们在图案中重复出现，填充了地图边框的一面： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/420/d88/64e/420d8864e72e178252766172dc0320ab.png"></div><br> 一个人会从左到右绘制该图案，绘制一个矩形，一个菱形，然后重复该图案直到填充整个边框。 因此，这也可以在程序中通过沿边框绘制图案来实现。 但是，先绘制所有矩形，然后绘制所有菱形会更容易。 只需沿边界间隔绘制相同的几何图形就足够了。 每个元素具有相同的间隔非常方便。 当然，一个人不会这样做，因为将元素安排在正确的位置太困难了，但这对程序来说不是问题。 <br><br> 也就是说，绘制简单几何形状的过程需要使用参数，在该参数中，图形的所有尺寸和颜色（即宽度，长度，线宽，线颜色和填充）都将被转移，并且起始位置（由于其原因将很快变得清晰，我将考虑图形的中心），重复之间的过渡的水平空间间隔以及重复的次数。 以向量[dx，dy]的形式指示重复方向也很方便，这样我们就可以从左到右，从右到左，上或下执行重复，只需更改向量和起点即可。 将它们放在一起，得到一条重复的形状： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/409/bcd/c33/409bcdc33756610ac6ace2d0fde0a3a4.png"></div><br> 多次使用此代码并以相同的偏移量进行渲染，我可以结合使用黑白条纹来创建地图比例尺： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b88/8f5/0d9/b888f50d9f164b9319cc8b3cf8d38588.png"></div><br> 在我开始弄清楚如何将所有这些内容应用到地图的真实边界之前，让我们首先为椭圆和菱形实现相同的功能。 <br><br> 菱形只是具有旋转顶点的矩形，因此您只需要对代码进行一些更改。 事实证明，我仍然没有现成的代码来渲染椭圆，但是很容易<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">获得椭圆</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">参数视图</a>并创建一个函数，该函数可以给我椭圆的要点： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3fa/74e/079/3fa74e079dd2c29afa5acb0135d4092f.png"></div><br> 这是一个使用上面实现的功能的示例（手动创建）： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf8/bf2/d39/bf8bf2d3992b34bc173622dc86c0d8b5.png"></div><br> 对于这么少量的代码，它看起来还不错！ <br><br> 现在，让我们解决带有重复元素（角）的边界的复杂情况。 <br><br> 如果边界带有重复元素，则有几种方法可以解决带有拐角的问题。 首先是调整重复，以使它们在角落处执行而不会引起明显的婚姻： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b7/70e/c95/7b770ec95296ce07e0d18ede205c8798.png"></div><br> 另一种选择是在两侧拐角附近的某个位置停止重复。 如果无法在角落轻松“旋转”图案，通常可以这样做： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/15f/6dd/3a3/15f6dd3a3e6191da02dc884193b72c82.png"></div><br> 最后一个选择是用一些角装饰关闭图案： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7be/5ce/64e/7be5ce64eb09de2eeefdb18992978d03.png"></div><br> 总有一天，我会去装饰角落，但现在我们将使用第一种选择。 如何在地图的角落中使条纹或圆形图案“旋转”而没有间隙？ <br><br> 主要思想是将pattern元素准确地放置在角落中，以使其一半位于地图的一侧，另一侧位于相邻的一侧。 在此示例中，圆正好在角上，并且可以从任何方向绘制： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7b7/70e/c95/7b770ec95296ce07e0d18ede205c8798.png"></div><br> 在其他情况下，该元素在一个方向上绘制一半，在另一个方向上绘制一半，但边缘重合： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ee/f62/0b8/4eef620b830eb0249d019229140e34e6.png"></div><br> 在这种情况下，在两侧都绘制了白色条纹，但在角落之间没有间隙地连接。 <br><br> 将元素放置在角落时，需要考虑两个方面。 <br><br> 首先，转角元素将相对于穿过元素中心的对角线进行拆分和镜像。 具有径向对称性的元素（例如正方形，圆形和星形）不会改变其形状。 没有径向对称的元素（例如矩形和菱形）在相对于对角线镜像时会改变形状。 <br><br> 其次，为了使两侧的角元素正确连接，地图的两侧必须有整数个元素（*）。 它们的编号不必相同，但是两侧的元素数必须为整数。 如果一侧上包含少量图案，则从一侧边缘开始，该图案将与相邻侧面不重合。 <br><br>  <i>（*在某些情况下，例如，带有长条纹的情况下，部分重复可能会发生完全重复，并且元素无论如何都会对齐。但是，生成的角元素将是不对称的，并且其长度与地图两侧的相同元素不同。在此处可以看到以下示例：</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/263/418/110/263418110aafe94ef8c62d57e8540371.png"></div><br>  <i>出现白色比例尺，并带有不同的部分重复，因此获得了相对于中心偏移的元素。</i>  <i>对于地图比例尺，情况并非总是如此，因为它可以显示绝对距离并且不必对称。</i>  <i>但是对于装饰图案，通常看起来很糟糕。）</i> <br><br> 这是一个示例，显示了如何精确地修剪角落的整数重复： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8ab/8de/0a3/8ab8de0a3452332e2813b3771091b165.png"></div><br> 如果从所有四个侧面都进行同样的操作，则边角将重合，并且图案将沿着边框的整个长度无缝定位： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfc/c9a/e46/dfcc9ae46a68807e983705e553aa2ba3.png"></div><br> 经过仔细检查，您会发现该图案并非完全出现在角落。 每个角的半个圆是从每个侧面截取的，并且这两个半部是用手独立绘制的，因此它们不是完美的。 但是现在他们已经足够接近这个了。 <br><br> 因此，我们可以为角上的图案实现完美的连接，为每个边缘选择整数个重复。 但是，解决这个问题的方法并不简单。 <br><br> 首先，假设我们知道边长为866像素，并且我们想重复元素43次。 然后，该元素应每20.14像素重复一次。 我们如何设置元素的特定长度（通常情况下，元素的模式）？ 在上面的示例中，我在圆圈之间添加了额外的空间。 但是，如果圆圈最初相互接触，则将改变模式。 也许值得扩大圈子，使他们继续相互接触？ <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e36/2b0/ebd/e362b0ebd3fd04e5d8b00de5d3aba151.png"></div><br> 现在元素正在接触，但是圆已变成椭圆，并且拐角处的形状很奇怪。  （请记住，我说过没有径向对称的元素在相对于角度反射时会改变形状吗？对于条纹来说，这不是什么大问题。）或者，也许值得压缩所有元素，使它们彼此接触并适合合适的长度： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d7c/ba8/0af/d7cba80afb431dc6c9afc52d7ad94b5c.png"></div><br> 但是为了实现这一点，我们需要使元素比原始元素小得多。 这些选项似乎都不完美。 <br><br> 当卡的侧面尺寸不同时，会发生第二个问题。 现在我们需要解决找到适合双方的整数重复的问题。 找到适合双方的解决方案将是理想的。 但是我不想这样做，但要以过多的模式更改为代价。 如果它们都足够接近原始图案，则在两侧都创建稍微不同的图案可能会更好。 <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 最后，当我使用将多个元素相互叠加的功能时，会出现第三个问题： </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4d9/4ed/6ac/4d94ed6acf107193f2109bd2b2f07a67.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我不想对模式进行任何更改，以免破坏元素之间的关系。</font><font style="vertical-align: inherit;">我认为通过适当的缩放比例，整个比例将保持不变，但是我需要对此进行测试。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有趣的任务，对不对？</font><font style="vertical-align: inherit;">到目前为止，我还没有针对她的高质量解决方案。</font><font style="vertical-align: inherit;">也许它们会稍后出现！</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 第4部分 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，我们已经实现了用于绘制线条和几何形状的图元。我开始使用重复形状填充边框，并谈到了在地图边框上放置任意图案以使其完美适合角落的困难。主要问题是，在一般情况下，您必须使图案更长（或更短），以使其适合侧面。更改模式长度的选项（添加或删除空格，更改模式元素的长度）会导致模式本身发生各种变化。从多个元素中选择模式似乎很困难！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当我遇到这些看似毫不妥协的任务时，我喜欢从实现一个简单的版本开始。不成功的任务通常可以通过反复解决“简单”问题来解决，直到结果足够好为止。有时，简单版本的实现可以提供一些理解，从而简化对更复杂问题的解决方案。如果情况没有好转，而问题仍然令人不舒服，那么至少我们会得到一个简化的版本，尽管它不尽如人意，但仍然可以派上用场。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最简单的方法是通过增加长度而不改变图案中的任何内容来改变图案的长度。</font><font style="vertical-align: inherit;">本质上，这会在模式的末尾添加空白。</font><font style="vertical-align: inherit;">（注意：最好在模式中的所有元素之间分配空白空间。）值得考虑的是，这种解决方案只能延长模式。</font><font style="vertical-align: inherit;">我们总是可以在模式中添加空白空间，但是在必要时不能使用它-也许模式中将不再有空白空间！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用这种方法，卡侧面的图案定位算法将非常简单：</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 用卡片的一面的长度除以图案的长度，然后将其四舍五入，以确定适合该面的图案的重复次数。 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这种情况下，元素之间的距离将等于边的长度除以重复次数。</font><font style="vertical-align: inherit;">（鉴于我们只能增加空间，因此这是最接近原始位置的位置。）</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 考虑到计算出的距离，沿着侧面画一个图案。 </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">很难实施该系统。</font><font style="vertical-align: inherit;">角落固执地不想重合。</font><font style="vertical-align: inherit;">我花了太多时间才意识到，当地图不是正方形时，我无法从地图中心画出四边的截断区域，因为这会产生不等于45度的截断角。</font><font style="vertical-align: inherit;">实际上，截断区域应类似于信封的背面：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b20/29a/beb/b2029abeb54302b5f7d3335a15c95f86.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当我弄清楚这一点时，该算法开始正常工作。</font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（但是请不要忘记前面的说明，随着时间的流逝，我会放弃截断区域！）</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是一个示例，比率约为2：1：</font></font><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bff/739/d19/bff739d19d76fdb4db63033b970eb241.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这样的规模上，很难注意到，但是角落正确连接，并且两侧之间只有很小的视觉差异。</font><font style="vertical-align: inherit;">在这种情况下，用于对齐图案的算法仅需要插入小数像素，因此肉眼看不到它，尤其是因为圆的轮廓被像素重叠。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是另一个带有条纹的示例：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/aa8/852/625/aa8852625e15121ce822cc6ca5fe8742.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是方形边框的顶部。</font><font style="vertical-align: inherit;">这是矩形地图上的相同边框：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90d/207/9b1/90d2079b1e869c59ee204f1a75f5dbc7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里，您可以看到在卡的侧面上，条带之间在视觉上有较大的间隙。</font><font style="vertical-align: inherit;">该算法插入的空间不得超过一个完整元素的长度；</font><font style="vertical-align: inherit;">因此，最糟糕的情况是当我们的元素较长且边长短而与合适的尺寸略有不同时。</font><font style="vertical-align: inherit;">但是在大多数实际情况下，对齐并不是很有害。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是带有多个元素的模式的示例：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d18/602/4f8/d186024f8ee1e4fbcd5918c63537a024.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 这里的条纹与条纹重叠： </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c60/af7/ad6/c60af7ad6c71ee4ef1850f0bf194af62.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以看到，由于对每个元素执行相同的对齐，因此条纹保持相对于彼此居中。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我建议很难将图案放置在地图的侧面，但是采用非常简单的方法来均匀分布图案元素以填充所需的空间对于许多图案来说效果很好。这提醒我们所有人：无需假设决策必须很复杂；它可能比您想象的要容易！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，该解决方案不适用于带有触摸元素的图案，例如，地图比例尺。在这种情况下，增加空间会移动元素：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3cd/d7e/27f/3cdd7e27f8c2d92be26d36e7b4807f5a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我上面提到的延长图案的另一种方法是拉伸图案的各个元素。</font><font style="vertical-align: inherit;">它适用于诸如比例尺图案之类的东西，但是在具有对称元素的图案中看起来会很糟糕，因为拉伸会使它们不对称。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事实证明，通过拉伸实现该选项比我预期的要困难得多，这主要是因为我不得不以不同的尺寸拉伸地图不同边缘上的元素（因为地图可能不是正方形而是矩形），并且还基于新的拉伸对象动态更改了元素的排列方式大小。</font><font style="vertical-align: inherit;">但是几个小时后，我设法实现了这一点：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d1c/552/3c4/d1c5523c43a9828cd9c1c1bee6f4bbde.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 现在，我具有绘制地图边框所需的所有功能（尽管border元素本身是手动创建的）： </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d2b/ccc/326/d2bccc326a0500f92267378e137e2f6e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我将图像转换为灰度，因为我不想打扰颜色的选择，而且卡本身也很无聊，但作为概念证明，边框看起来很漂亮。 </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 第5部分 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在第2部分中，我开发了地图边界描述语言（MBDL）语法，在第3部分和第4部分中，我实现了执行所有语言原语的过程。</font><font style="vertical-align: inherit;">现在，我将连接这些部分，以便我可以在MBDL上描述边框并将其绘制在地图上。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在第3部分中，我编写了MBDL语法，使其可以与</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nearley</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Javascript </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">解析工具一起使用</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">完成的语法如下所示：</font></font><br><br><blockquote> <code><b>@builtin</b> <b>"</b> <b>number.ne"</b> <br> <b>@builtin</b> <b>"</b> <b>string.ne"</b> <br> <b>border -&gt; (element WS):+ <br> WS -&gt; [\s]:* <br> number -&gt; WS decimal WS <br> color -&gt; WS dqstring WS <br> element -&gt;</b> <b>"</b> <b>L(" number</b> <b>"</b> <b>," color</b> <b>"</b> <b>)"</b> <br> <b>element -&gt;</b> <b>"</b> <b>VS(" number</b> <b>"</b> <b>)"</b> <br> <b>element -&gt;</b> <b>"</b> <b>(" WS (element WS):+</b> <b>"</b> <b>)"</b> <br> <b>element -&gt;</b> <b>"</b> <b>[" WS (geometric WS):+</b> <b>"</b> <b>]"</b> <br> <b>geometric -&gt;</b> <b>"</b> <b>B(" number</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>)"</b> <br> <b>geometric -&gt;</b> <b>"</b> <b>E(" number</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>)"</b> <br> <b>geometric -&gt;</b> <b>"</b> <b>D(" number</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>," number</b> <b>"</b> <b>," color</b> <b>"</b> <b>)"</b> <br> <b>geometric -&gt;</b> <b>"</b> <b>HS(" number</b> <b>"</b> <b>)"</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">默认情况下，当使用Nearley成功解析规则时，该规则将返回一个数组，其中包含与该规则右侧相对应的所有元素。</font><font style="vertical-align: inherit;">例如，如果规则</font></font><br><br><blockquote> <code><b>test -&gt;</b> <b>"</b> <b>A" |</b> <b>"</b> <b>B" |</b> <b>"</b> <b>C"</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 与字符串匹配 </font></font><br><br><blockquote> <code><b>A</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 然后Nearley将返回 </font></font><br><br><blockquote> <code><b>[</b> <b>"</b> <b>A" ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">具有单个值的数组是对应于规则右侧的字符串“ A”。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">使用此规则解析元素时，Nearley返回什么？</font></font><br><br><blockquote> <code><b>number -&gt; WS decimal WS</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规则的右侧分为三部分，因此它将返回一个包含三个值的数组。</font><font style="vertical-align: inherit;">第一个值将是返回WS规则的值，第二个值将是返回十进制规则的值，第三个值将是返回WS规则的值。</font><font style="vertical-align: inherit;">如果使用上述规则，我将解析为“ 57”，则结果将如下所示：</font></font><br><br><blockquote> <code><b>[ <br> [ " " ], <br> [ "5", "7" ], <br> [ ] <br> ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nearley解析的最终结果将是一个嵌套的数组数组，这是一个</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">语法树</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。在某些情况下，语法树是非常有用的表示形式；在其他情况下，则不是。</font><font style="vertical-align: inherit;">例如，</font><font style="vertical-align: inherit;">在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dragons Abound中</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，这样的树不是特别有用。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">幸运的是，Nearley规则可以覆盖标准行为并返回所需的任何内容。实际上，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">十进制</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的（内置）规则</font><font style="vertical-align: inherit;">不会返回数字列表，它会返回等效的Javascript数字，这在大多数情况下更为有用，也就是说，</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数字</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规则的返回值</font><font style="vertical-align: inherit;">具有以下形式：</font></font><br><br><blockquote> <code><b>[ <br> [ " " ], <br> 57, <br> [ ] <br> ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nearley规则通过向规则添加后处理器，采用标准数组并将其替换为所需的内容来重新定义标准行为。后处理器只是规则末尾特殊括号内的Javascript代码。例如，在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数字</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规则中，</font><font style="vertical-align: inherit;">我从不对数字两侧的空格感兴趣。因此，如果规则仅返回一个数字，而不是三个元素的数组，将很方便。这是执行此任务的后处理器：</font></font><br><br><blockquote> <code><b>number -&gt; WS decimal WS {% default =&gt; default[1] %}</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该后处理器采用标准结果（上面显示的三元素数组），并用该数组的第二个元素替换它，这是</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">十进制</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规则中的Javascript数字</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">因此，现在</font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数字</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">规则</font><font style="vertical-align: inherit;">返回实数。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此功能可用于将输入语言处理为中间语言，从而更易于使用。</font><font style="vertical-align: inherit;">例如，我可以使用Nearley语法将MBDL字符串转换为Javascript结构的数组，每个Javascript结构均表示由“ op”字段标识的原语。</font><font style="vertical-align: inherit;">行基元的规则如下所示：</font></font><br><br><blockquote> <code><b>element -&gt;</b> <b>"</b> <b>L(" number</b> <b>"</b> <b>," color</b> <b>"</b> <b>)" {% data=&gt; {op:</b> <b>"</b> <b>L", width: data[1], color: data[3]} %}</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 也就是说，解析“ L（13，黑色）”的结果将是Javascript结构： </font></font><br><br><blockquote> <code><b>{op:</b> <b>"</b> <b>L", width: 13, color:</b> <b>"</b> <b>black"}</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">添加适当的后处理后，从语法返回的结果可以是传入行的操作结构的序列（数组）。</font><font style="vertical-align: inherit;">也就是说，解析字符串的结果</font></font><br><br><blockquote> <code><b>L( 415, “black") <br> VS(5) <br> [B(1, 2, “black", 3, “white") HS(5) E(1, 2, “black", 3, “white")]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 将是 </font></font><br><br><blockquote> <code><b>[ <br> {op: "L", width: 415, color: "black"}, <br> {op: "VS", width: 5}, <br> {op: "P", <br> elements: [{op: "B", width: 1, length: 2, <br> olColor: "black", olWidth: 3, <br> fill: "white"}, <br> {op: "HS", width: 5}, <br> {op: "E", width: 1, length: 2, <br> olColor: "black", olWidth: 3, <br> fill: "white"}]} <br> ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建地图边框要容易得多。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此时，您可能会提出一个问题-如果Nearley规则的后处理阶段可以包含任何Javascript，那么为什么不跳过中间视图并在后处理过程中直接绘制地图边框呢？</font><font style="vertical-align: inherit;">对于许多任务，此方法将是理想的。</font><font style="vertical-align: inherit;">我出于某些原因决定不使用它。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，在MBDL中，有两个（*）组件在解析过程中无法执行。例如，在解析过程中，我们无法绘制重复的几何元素（条形或菱形），因为我们需要从相同模式的其他元素中获取信息。特别是，我们需要知道模式的总长度，以便了解我们需要安排每个单独元素的重复的距离。也就是说，图案的元素仍应创建所有几何元素的中间表示。</font></font><br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（*我还没有谈论过其他具有类似限制的组件。）</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">其次，Nearley中的Javascript已嵌入到规则中，因此，除了全局变量之外，我们将无法将其他信息传递给Javascript。例如，要绘制边框，我需要知道地图的大小，所使用的四个截断区域等。尽管我可以添加使该信息可用于Nearley后处理器的代码，但是这会有些混乱，并且维护此类代码可能很困难。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于这些原因，我正在解析为一个中间表示，然后执行该中间表示以创建地图本身的边框。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下一步是开发一个解释器，该解释器接收MBDL的中间表示并运行它以生成地图边界。这不是很难做到的。基本上，工作是设置初始条件（例如，为地图的四个边生成截断区域），并在每个中间表示的结构序列上进行迭代。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有一些湿滑的时刻。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，我需要从内部渲染到从内部到外部的绘制。原因是因为我希望大多数边界不与地图重叠，所以我需要绘制边界，以使内部边缘的线与地图的边缘重合。如果从外部向内绘制，则在开始绘制之前我需要知道边框的宽度，以便边框不会与地图重叠。如果从内向外绘制，则仅从地图边缘开始绘制。还可以选择在地图上加上边框。只需从负的垂直空间（VS）开始边界即可。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">另一个困难点是重复模式。</font><font style="vertical-align: inherit;">要绘制重复的图案，我需要查看图案的所有元素并确定最宽的元素，因为这将设置整个图案的宽度。</font><font style="vertical-align: inherit;">我还需要查看并跟踪模式的长度，以便在每次重复之前知道要离开多少距离。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是我用来测试解释器的一个相当复杂的边框示例：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3c8/88a/2a9/3c888a2a96352845f6165f5eca7f6ab3.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 我认为有可能（必要吗？）将其附加到解析器进行测试，但是对于这个边界，我只是手动创建了一个中间视图： </font></font><br><br><blockquote> <code><b>[ <br> {op:'P', elements: [ <br> {op:'B', width: 10, length: 37, lineWidth: 2, color: 'black', fill: 'white'}, <br> {op:'B', width: 10, length: 37, lineWidth: 2, color: 'black', fill: 'black'}, <br> ]}, <br> {op:'VS', width: 2}, <br> {op:'L', width:3, color: 'black'}, <br> {op:'PUSH'}, <br> {op:'L', width:10, color: 'rgb(222,183,64)'}, <br> {op:'POP'}, <br> {op:'PUSH'}, <br> {op:'P', elements: [ <br> {op:'E', width: 5, length: 5, lineWidth: 1, color: 'black', fill: 'red'}, <br> {op:'HS', length: 10}, <br> ]}, <br> {op:'L', width:3, color: 'black'}, <br> {op:'POP'}, <br> {op:'VS', width: 2}, <br> {op:'P', elements: [ <br> {op:'E', width: 2, length: 2, lineWidth: 0, color: 'black', fill: 'white'}, <br> {op:'HS', length: 13}, <br> ]}, <br> ]</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我通过反复试验创建了此视图。不管怎么说，口译员都可以工作！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最后，让我使用解析器从MBDL版本创建中间视图。在这里没有太多要显示给我的东西：我必须修复一些字段名，但是否则代码可以正常工作。对于边框，我使用了稍有不同的MBDL版本：</font></font><br><br><blockquote> <code><b>[B(5,37,"black",2,"white") B(5,37,"black",2,"black")] <br> VS(3) <br> L(3,"black") <br> {L(10,"rgb(222,183,64)")} <br> [E(5,5,"black",1,"red") HS(-5) E(2,2,"none",0,"white") HS(10)] <br> L(3,"black")</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">她绘制相同的边框，但方式略有不同。</font><font style="vertical-align: inherit;">我还更改了叠加层的语法，用花括号替换了括号，以使其与其他语法有更多不同。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了说明为什么我要从内向外绘制，而不仅仅是自动将边框放置在地图的外部，我可以在此边框的开头添加一个负的垂直空间，以将地图比例尺移动到地图的边缘：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0ce/ea0/3df/0ceea03df1f07131e0ad27e6bbd45731.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我拥有了程序生成地图边界所需的大多数基础结构：边界描述语言，语言解析器和执行中间表示的过程。</font><font style="vertical-align: inherit;">剩下的只是处理困难的部分-程序生成！</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 第6部分 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，整个MBDL均已实现，我打算继续进行地图边界的程序化生成，但是我不确定该如何实现，因为我会花点时间并实现MBDL的其他一些功能。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在第一次讨论带模式的转角处理时，我谈到了几种不同的方法。最后，我意识到了斜角，但是还有第二种选择：将图案停在拐角附近，如以下示例所示：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3b7/94d/01b/3b794d01b552c42ed9b8362f5405ff9d.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ee2/3a8/159/ee23a8159d81afd1f7c95c16a90bcdf7.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当边框图案是某种非对称图形，符文或其他不能旋转90度而又保持对齐的东西时，通常使用这种解决方案。但这显然适用于几何形状。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这可能是在生成边框之前选择的选项，但是如果从边框的一部分启用它，而在另一部分使用斜角，则可以增加一些灵活性。为此，我必须向MBDL添加新命令。我怀疑边界的不同部分可能还会出现其他选项，因此我将添加一个常规选项命令：</font></font><br><br><blockquote> <code><b>element -&gt; "O(MITER)"</b> <br> <b>element -&gt; "O(STOPPED)"</b> <br> <b>element -&gt; "O(STOPPED," number ")"</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（为清楚起见，这里再次省略了空格和其他一些细节。）到目前为止，唯一的选择是“ MITER”（斜角）用于斜角，而“ STOPPED”（停止）用于在拐角附近停止。</font><font style="vertical-align: inherit;">如果未停止发送任何值，则程序在距拐角的一段合理距离处停止模式。</font><font style="vertical-align: inherit;">如果传送了该值，则图案在距拐角的那个距离处停止。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果使用了STOPPED拐角，那么我将不再从拐角处绘制拐角图案。</font></font>看起来是这样的： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a8e/5df/49e/a8e5df49eecf2ebc5e94e571cb7d0ff8.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这里，我为黑白比例模式使用了MITER选项，因此它相对于角度是镜像的。</font><font style="vertical-align: inherit;">对于金线内的红色圆圈和黑色正方形的图案（以及边界外的圆圈图案），我使用了STOPPED。</font><font style="vertical-align: inherit;">您可以看到这两种模式在拐角处结束。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，有两个问题。首先，我们看到左边最靠近拐角的元素是一个黑色正方形，而上面是一个红色圆圈。发生这种情况是因为拐角的一侧在重复的起点附近，而在另一侧的重复的终点附近。但是看起来很奇怪。如果角是对称的，那会更好，即使为此我们必须在图案的末尾添加另一个元素。其次，您可以看到边框外的图案（半圆和黑点）也以一个重复出现在角上。但是，由于此重复的长度远小于红色圆圈/黑色正方形的长度，因此它们最终会出现在不同的位置。如果所有样式都停止在距拐角相同的距离处，那可能会更好。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">要解决第一个问题，您需要在边框的每一边的末尾添加另一个重复图案的第一个元素。</font><font style="vertical-align: inherit;">但这实际上有点复杂，因为我可以在图案内使用负的水平偏移量来重叠多个元素（如此处所示）。</font><font style="vertical-align: inherit;">您还需要向具有与第一个元素相同起点的模式的任何元素添加另一个重复。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c4/331/6fc/9c43316fcd44d79a0b2374401a46240a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，图案相对于角度是对称的，并且看起来更好。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接下来，我需要跟踪最长的STOPPED模式并在此距离处停止每个STOPPED模式：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a33/920/c6c/a33920c6cda9072bbda915544f1f4926.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 现在，更多地留出了白色圆圈的图案，但仍与红色圆圈的图案不对齐。 </font></font>怎么了<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">发生这种情况是因为白色圆圈图案距离地图的边缘更远，并且边框的长度比绘制红色圆圈图案的地方更长。</font><font style="vertical-align: inherit;">要解决此问题，您还需要移动图案，并考虑其相对于地图边缘的偏移量。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/70b/574/2c1/70b5742c1d4f404335b97128f09d6baf.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，所有内容都已完美对齐。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">角度的第二个选项是拐角处的正方形偏移，例如：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cac/37e/bac/cac37ebac81815955dfc940bacdc2eff.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实施起来会更加困难！</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，此选项的语法很简单，并使用Option操作码：</font></font><br><br><blockquote> <code><b>element -&gt; "O(SQOFFSET)"</b> <br> <b>element -&gt; "O(SQOFFSET," number ")"</b></code> </blockquote> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">数字表示地图边缘上元素的正方形位移的大小；</font><font style="vertical-align: inherit;">具有不同偏移量的元素必须相应对齐。</font><font style="vertical-align: inherit;">如果没有数字，程序将选择适当的偏移尺寸。</font><font style="vertical-align: inherit;">将数字清零将禁用平方偏移。</font><font style="vertical-align: inherit;">这使您可以创建边框，其中某些元素使用正方形偏移，而其他元素则不使用正方形偏移，例如此边框：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/97b/fd8/336/97bfd833697b9278660772c1bd04ee46.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我意识到的第一件事是，我将需要其他截断区域，因为我使用截断来处理边界改变方向的位置。</font><font style="vertical-align: inherit;">SQOFFSET将需要更复杂的截断区域；</font><font style="vertical-align: inherit;">启用和禁用SQOFFSET时，您还将需要用于不同项目的单独区域。</font><font style="vertical-align: inherit;">考虑到截断区域总会增加不需要的伪像，这似乎是太多的工作。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当我在上面的可停止模式上工作时，我实现了填充非对称模式以从模式的一端添加另一个重复。我还意识到，这将消除对斜角的需要。我将简单地沿边界顺时针绘制所有图案，在一个角开始该图案，在下一个角附近结束。这将使我摆脱截断区域。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这种新的转角处理方式中，最重要的是，图案的第一个元素不再“分为”两个侧面。如果您在上面的地图上查看黑白比例尺图案，您会发现有一个白色矩形穿过角落。现在，白色矩形将邻接角部：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ead/909/c83/ead909c83fa91ff80af290ab92ca9fae.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">地图是通过两种方式绘制的，但这不是很大的问题。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先，我实现了行的偏移量。</font><font style="vertical-align: inherit;">为此，只需相对于相应角度旋转线即可：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9c2/bf6/2fd/9c2bf62fdfec732f56361f4aa17fc19e.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 如您所知，我可以将角度与偏移量和规则角度结合起来，如上图所示： </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e0b/f5b/e02/e0bf5be02606044dd5fba4f82d3dad67.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当然，拐弯处的图案更加困难。</font><font style="vertical-align: inherit;">一般的想法是沿着边界从一个角到另一个角，依此类推，直到我们回到起点。</font><font style="vertical-align: inherit;">从理论上讲，仅绘制水平和垂直图案就足够了，并且所有内容都应精美对齐；</font><font style="vertical-align: inherit;">实际上跟踪所有这些都是沉闷的。</font><font style="vertical-align: inherit;">实际上，我必须完全重写两次代码，并写一堆纸，但我不会详细讨论。</font><font style="vertical-align: inherit;">只显示结果：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/912/35b/889/91235b889603c973fcfe094a1614a993.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">拐角处出现令人讨厌的视觉错觉-拐角元素似乎更不靠近拐角的外部居中。</font><font style="vertical-align: inherit;">实际上，事实并非如此，但事实并非如此，因为在靠近拐角内侧的地方，在视觉上有更多的空白空间。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于偏移角的段很短，因此在拐角处创建非平衡图案非常容易：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b1b/601/dff/b1b601dffc11782fb8cbe738a906b0e5.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有时看起来很丑。</font><font style="vertical-align: inherit;">这让我想起了一个老笑话：</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">病人：“医生，当我这样做时，会伤到我。” </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">医生：“那就别那样！”</font></font></blockquote><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，我将尽量不要这样做。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">通常，我不会沿着偏移角度绘制地图比例尺，但是如果需要，我将需要使用拉伸图案的选项，以使地图比例尺适合到角落，而矩形之间没有间隙：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/26f/a88/0da/26fa880da6d00d380afdae60c489dd9c.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">您可以看到，比例矩形的大小明显不同。</font><font style="vertical-align: inherit;">也就是说，这不是一个很好的选择。</font><font style="vertical-align: inherit;">（顺便说一句，偏移角度在圆形图案中也有一个bug。后来我修复了它，但是正如我所说，很难做到这一点。）</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果该图案太大而无法适合偏移角度的分段，则该算法会放弃：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b4d/044/b2d/b4d044b2dc2bf23cd670113476b9803d.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这远非理想，但正如我上面所说，“那就不要这样做。” </font><font style="vertical-align: inherit;">（如果需要，添加压缩或拉伸功能实际上并不难。）</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果同时使用偏角和将图案停在角前面的选项会发生什么情况？</font><font style="vertical-align: inherit;">在这种情况下，我只是在离偏移角不远处停了下来：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/170/d60/9c1/170d609c1b789359490e35741215ba04.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在我看来，这是一个合乎逻辑的决定。 </font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN444190/">https://habr.com/ru/post/zh-CN444190/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN444178/index.html">从单个开发人员创建独立游戏的9个技巧</a></li>
<li><a href="../zh-CN444182/index.html">前进条件及其奇数</a></li>
<li><a href="../zh-CN444184/index.html">关于预组装数据中心的前景</a></li>
<li><a href="../zh-CN444186/index.html">颤振1.2。 最新消息</a></li>
<li><a href="../zh-CN444188/index.html">CG Pods-可以使用的TWS耳机</a></li>
<li><a href="../zh-CN444192/index.html">API管理Mitap-IBM，Google，Yandex和Leroy Merlin的经验-可以记录</a></li>
<li><a href="../zh-CN444198/index.html">Dropbox限制同步：现在只有3台设备</a></li>
<li><a href="../zh-CN444200/index.html">问题解决会议</a></li>
<li><a href="../zh-CN444204/index.html">在Python中引入测试。 第三部分</a></li>
<li><a href="../zh-CN444206/index.html">3月27日，莫斯科-JavaScript MeetUP</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>