<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚚 👈🏽 📠 Restauración de fotos basada en IA 👇🏼 🎎 🙃</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola a todos! Soy ingeniero de investigación en el equipo de visión por computadora del Grupo Mail.ru. En este artículo, voy a contar una historia de ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Restauración de fotos basada en IA</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/459696/"><img src="https://habrastorage.org/webt/ya/mt/mm/yamtmmcino7skf3gyqzpsrgqla4.jpeg"><br><br>  Hola a todos!  Soy ingeniero de investigación en el equipo de visión por computadora del Grupo Mail.ru.  En este artículo, voy a contar una historia de cómo hemos creado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un proyecto de restauración de fotos basado en IA</a> para viejas fotos militares.  ¿Qué es la "restauración de fotos"?  Consta de tres pasos: <br><br><ul><li>  encontramos todos los defectos de la imagen: fracturas, rasguños, agujeros; <br></li><li>  pintamos los defectos descubiertos, en función de los valores de píxeles a su alrededor; <br></li><li>  Coloramos la imagen. <br></li></ul><br>  Además, describiré cada paso de la restauración de fotos y le diré cómo obtuvimos nuestros datos, qué redes capacitamos, qué logramos y qué errores cometimos. <br><a name="habracut"></a><br><h1>  Buscando defectos </h1><br>  Queremos encontrar todos los píxeles relacionados con defectos en una foto cargada.  Primero, tenemos que averiguar qué tipo de imágenes subirán las personas.  Hablamos con los fundadores del proyecto "Regimiento inmortal", una organización no comercial que almacena las fotos heredadas de la Segunda Guerra Mundial, quienes compartieron sus datos con nosotros.  Al analizarlo, notamos que las personas cargan principalmente retratos individuales o grupales con una cantidad moderada a gran cantidad de defectos. <br><br>  Luego tuvimos que recoger un conjunto de entrenamiento.  El conjunto de entrenamiento para una tarea de segmentación es una imagen y una máscara donde se marcan todos los defectos.  La forma más fácil de hacerlo es dejar que los asesores creen las máscaras de segmentación.  Por supuesto, la gente sabe muy bien cómo encontrar defectos, pero eso llevaría demasiado tiempo. <br><br><img src="https://habrastorage.org/webt/yg/6y/iu/yg6yiue75v7msnxyffapttyugs8.jpeg"><br><br>  Puede tomar una hora o todo el día laboral marcar los píxeles defectuosos en una foto.  Por lo tanto, no es fácil recopilar un conjunto de entrenamiento de más de 100 imágenes en unas pocas semanas.  Es por eso que tratamos de aumentar nuestros datos y crear nuestros propios defectos: tomamos una buena foto, agregamos defectos usando recorridos aleatorios en la imagen y terminamos con una máscara que muestra las partes de la imagen con los defectos.  Sin aumentos, tenemos 68 fotos etiquetadas manualmente en el conjunto de entrenamiento y 11 fotos en el conjunto de validación. <br><br>  El enfoque de segmentación más popular: tome Unet con codificador pre-entrenado y minimice la suma de BCE ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">entropía cruzada binaria</a> ) y DICE ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">coeficiente de Sørensen - Dice</a> ). <br><br>  ¿Qué problemas surgen cuando usamos este enfoque de segmentación para nuestra tarea? <br><br><ul><li>  Incluso si parece que hay toneladas de defectos en la foto, que es muy vieja y en mal estado, el área con defectos es mucho más pequeña que la que no está dañada.  Para resolver este problema, podemos aumentar el peso positivo de la clase en BCE;  un peso óptimo sería la proporción de píxeles limpios a los defectuosos. <br></li><li>  El segundo problema es que si usamos un Unet listo para usar con codificador pre-entrenado (Albunet-18, por ejemplo), perdemos muchos datos posicionales.  La primera capa de Albunet-18 consiste en una convolución con un núcleo 5 y una zancada que equivale a dos.  Permite que la red funcione rápido.  Cambiamos el tiempo de operación neto para tener una mejor localización de defectos: eliminamos la agrupación máxima después de la primera capa, disminuimos el paso a 1 y disminuimos el núcleo de convolución a 3. <br></li><li>  Si trabajamos con imágenes pequeñas comprimiéndolas, por ejemplo, a 256 x 256 o 512 x 512 píxeles, los pequeños defectos desaparecerán debido a la interpolación.  Por lo tanto, necesitamos trabajar con imágenes más grandes.  Actualmente estamos segmentando defectos en fotos de 1024 x 1024 en producción.  Es por eso que tuvimos que entrenar la red en cultivos de gran imagen.  Sin embargo, esto causa problemas con un tamaño de lote pequeño en una sola GPU. <br></li><li> Durante el entrenamiento, podemos colocar unas 20 imágenes en una GPU.  Debido a eso, terminamos con valores de desviación estándar y media inexactos en las capas BatchNorm.  Podemos resolver este problema utilizando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">In-place BatchNorm</a> , que, por un lado, ahorra espacio en la memoria y, por otro lado, tiene una versión BatchNorm sincronizada, que sincroniza las estadísticas en todas las GPU.  Ahora calculamos los valores de la media y la desviación estándar no para 20 imágenes en una sola GPU, sino para 80 imágenes de 4 GPU.  Esto mejora la convergencia neta. <br></li></ul><br>  Finalmente, al aumentar el peso de BCE, cambiar la arquitectura y usar In-place BatchNorm, mejoramos la segmentación.  Sin embargo, no costaría demasiado hacer algo aún mejor agregando Test Time Augmentation.  Podemos ejecutar la red una vez en una imagen de entrada, luego reflejarla y volver a ejecutar la red para encontrar todos los pequeños defectos. <br><br><img src="https://habrastorage.org/webt/3c/vj/g0/3cvjg04qc_nqsl8lop44jvtjfym.jpeg"><br><br>  La red converge en 18 horas en cuatro GeForce 1080Ti.  La inferencia toma 290 ms.  Es bastante largo, pero ese es el precio de nuestro rendimiento mejor que el predeterminado.  Validación DICE es igual a 0,35 y ROCAUC - 0,93. <br><br><h1>  Inpainting de imagen </h1><br>  Lo mismo con la tarea de segmentación que usamos Unet.  Para pintar, cargaríamos una imagen original y una máscara donde marcamos toda el área limpia con unos y con ceros, todos los píxeles que queremos pintar.  Así es como estábamos recopilando datos: para cualquier foto de un conjunto de datos de imagen de código abierto, por ejemplo, OpenImagesV4, agregamos los defectos similares a los que vemos en la vida real.  Luego habíamos entrenado la red para restaurar las partes faltantes. <br><br>  ¿Cómo podemos modificar Unet para esta tarea? <br><br>  Podemos usar convolución parcial en lugar de una original.  La idea es que cuando envolvemos un área con algo de kernel, no tomamos en cuenta los valores de píxeles defectuosos.  Esto hace que la pintura sea más precisa.  Le mostramos un ejemplo del reciente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documento de NVIDIA</a> .  Usaron Unet con una convolución bidimensional predeterminada en la imagen del medio y una convolución parcial, en la imagen de la derecha. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/ec1/5ba/bdb/ec15babdbf1cd219be4a5e3ffa4ae50f.jpg"><br><br>  Entrenamos la red durante cinco días.  El último día, congelamos BatchNorms para que los bordes de la parte pintada sean menos visibles. <br><br>  La red tarda 50 ms en procesar una imagen de 512 x 512.  Validación PSNR es igual a 26.4.  Sin embargo, no puede confiar totalmente en las métricas en esta tarea.  Para elegir el mejor modelo, ejecutamos varios buenos modelos en imágenes de valoración, anonimizamos los resultados y luego votamos por los que más nos gustaron.  Así es como elegimos nuestro modelo final. <br><br>  Mencioné anteriormente que agregamos artificialmente algunos defectos a las imágenes limpias.  Siempre debe realizar un seguimiento del tamaño máximo de defectos añadidos durante el entrenamiento;  en el caso de que alimente una imagen con un defecto muy grande en la red que nunca se trata en la etapa de entrenamiento, la red se volverá loca y producirá un resultado inaplicable.  Por lo tanto, si necesita reparar defectos grandes, aumente su conjunto de entrenamiento con ellos. <br><br>  Aquí está el ejemplo de cómo funciona nuestro algoritmo: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/c48/2cd/253/c482cd253865ee12a834475a2e30d619.jpg"><br><br><h1>  Coloración </h1><br>  Segmentamos los defectos y los pintamos;  El tercer paso: la reconstrucción del color.  Como dije antes, hay muchos retratos individuales y grupales entre las fotos del Regimiento Inmortal.  Queríamos que nuestra red funcionara bien con ellos.  Decidimos crear nuestra propia coloración ya que ninguno de los servicios existentes podía colorear los retratos de forma rápida y eficiente.  Queremos que nuestras fotos coloreadas sean más creíbles. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/cec/b9a/b6c/cecb9ab6c8e1b76b567f49eac1261957.jpg"><br><br>  GitHub tiene un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">repositorio</a> popular para la coloración de fotos.  Hace un buen trabajo pero aún tiene algunos problemas.  Por ejemplo, tiende a pintar la ropa de azul.  Por eso lo rechazamos también. <br><br>  Entonces, decidimos crear un algoritmo para la coloración de la imagen.  La idea más obvia: tomar una imagen en blanco y negro y predecir tres canales: rojo, verde y azul.  Sin embargo, podemos facilitar nuestro trabajo: no trabaje con la representación de color RGB, sino con la representación de color YCbCr.  El componente Y es brillo (luma).  Una imagen cargada en blanco y negro es el canal Y, y la vamos a reutilizar.  Ahora tenemos que predecir Cb y Cr: Cb es la diferencia de color azul y brillo y Cr, la diferencia de color rojo y brillo. <br><br><img src="https://habrastorage.org/webt/yo/au/zi/yoauzi06k3bd0uyod2rjnpxgvms.jpeg"><br><br>  ¿Por qué elegimos la representación de YCbCr?  Un ojo humano es más sensible a los cambios de brillo que a los cambios de color.  Es por eso que reutilizamos el componente Y (brillo) al cual el ojo humano es más sensible y predecimos Cb y Cr con los que podríamos cometer un error, ya que no podemos notar muy bien la falsedad del color.  Esta característica específica fue ampliamente utilizada en los albores de la televisión en color cuando la capacidad del canal no era suficiente para transmitir todos los colores.  La imagen se transmitió en YCbCr, sin cambios al componente Y, y Cb y Cr se redujeron a la mitad. <br><br><h1>  Cómo crear una línea base </h1><br>  Podemos tomar Unet con un codificador previamente entrenado y minimizar la pérdida de L1 entre los valores de CbCr existentes y los pronosticados.  Queremos colorear los retratos y, por lo tanto, además de las fotos de OpenImages, necesitamos más fotos específicas de la tarea. <br><br>  ¿Dónde podemos obtener fotos coloreadas de personas vestidas con un uniforme militar?  Hay personas en Internet que colorean fotos antiguas como un pasatiempo o por un precio.  Lo hacen con mucho cuidado, tratando de ser muy precisos.  Cuando colorean un uniforme, hombreras y medallas, se refieren a los materiales de archivo, por lo que los resultados de su trabajo son confiables.  Con todo, utilizamos 200 imágenes coloreadas manualmente con personas con uniforme militar. <br><br>  La otra fuente de datos útil es el sitio web del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ejército Rojo de los Trabajadores y Campesinos</a> .  A uno de sus fundadores se le tomó una foto en casi todos los uniformes soviéticos de la Segunda Guerra Mundial disponibles. <br><br><img src="https://habrastorage.org/webt/yh/b7/u7/yhb7u74fa3feihqo0k-jpqcyxgk.jpeg"><br><br>  En algunas fotos, imitaba las poses de personas de las famosas fotos de archivo.  Es bueno que sus imágenes tengan fondo blanco: nos permitió aumentar muy bien los datos al agregar varios objetos naturales en el fondo.  También utilizamos algunos retratos regulares, completándolos con insignias y otros atributos de tiempos de guerra. <br><br>  Entrenamos a AlbuNet-50: es una Unet que utiliza ResNet-50 previamente entrenado como codificador.  La red comenzó a dar resultados adecuados: la piel era rosada, los ojos - gris azulado, las hombreras - amarillentas.  Sin embargo, el problema fue que deja algunas áreas en la foto intactas.  Esto fue causado por el hecho de que, de acuerdo con el error, L1 encuentra un valor óptimo en el que es mejor no hacer nada que intentar predecir algo de color. <br><br><img src="https://habrastorage.org/webt/ov/zh/bn/ovzhbnv-6ch0nnoa4fdbh3nygym.jpeg"><br>  <i>Estamos comparando nuestro resultado con una foto de Ground Truth, una coloración manual realizada por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Klimbim</a></i> <br><br>  ¿Cómo podemos resolver este problema?  Necesitamos un discriminador: una red neuronal que reciba una imagen y nos diga si se ve realista o no.  Una de las imágenes a continuación está coloreada manualmente y la otra, por nuestro generador, AlbuNet-50.  ¿Cómo distingue el ser humano las fotos coloreadas manual y automáticamente?  Al mirar los detalles.  ¿Puedes decir dónde está la foto coloreada automáticamente por nuestra solución de referencia? <br><br><img src="https://habrastorage.org/webt/fk/er/n_/fkern_az5kgkgr2kwamcoxr_gtg.jpeg"><br><br><div class="spoiler">  <b class="spoiler_title">Respuesta</b> <div class="spoiler_text">  la imagen de la izquierda se colorea manualmente, a la derecha, automáticamente. </div></div><br>  Usamos el discriminador del documento <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">GAN de auto atención</a> .  Es una pequeña red de convolución con la llamada Auto-Atención construida en las capas superiores.  Nos permite "prestar más atención" a los detalles de la imagen.  También utilizamos la normalización espectral.  Puede encontrar más información en el documento mencionado anteriormente.  Hemos entrenado la red con una combinación de pérdida L1 y una pérdida del discriminador.  Ahora la red colorea mejor los detalles de la imagen y el fondo se ve más consistente.  Un ejemplo más: a la izquierda está el trabajo por red entrenado con pérdida L1 solamente;  a la derecha, con una combinación de pérdidas discriminatorias L1. <br><br><img src="https://habrastorage.org/webt/nd/3p/91/nd3p91aw1mzzoidhra1egef3zki.jpeg"><br><br>  El proceso de capacitación tomó dos días en cuatro GeForce 1080Ti.  La red tarda 30 ms en procesar una imagen de 512 x 512.  Validación MSE - 34.4.  Al igual que con la pintura, las métricas que no desea confiar en las métricas.  Es por eso que elegimos seis modelos con las mejores métricas de validación y votamos ciegamente por el mejor modelo. <br><br>  Cuando ya creamos un sistema de producción y lanzamos un sitio web, continuamos experimentando y llegamos a la conclusión de que es mejor minimizar no la pérdida L1 por píxel, sino la pérdida perceptiva.  Para calcularlo, alimentamos las predicciones netas y una foto de verdad real a la red VGG-16, tomamos los mapas de características en las capas inferiores y los comparamos con MSE.  Este enfoque pinta más áreas y da resultados más coloridos. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/676/9c8/b64/6769c8b64fdf00cb66dcd73edcd39e81.jpg"><br><br><h1>  Recapitulación </h1><br>  Unet es una modelo genial.  En la primera tarea de segmentación, enfrentamos un problema durante la capacitación y trabajamos con imágenes de alta resolución y es por eso que usamos In-Place BatchNorm.  En nuestra segunda tarea (Inpainting) usamos Convolución parcial en lugar de una predeterminada, y nos permitió obtener mejores resultados.  Al trabajar en la coloración, agregamos una pequeña red discriminadora que penalizaba al generador por imágenes poco realistas.  También usamos una pérdida perceptual. <br><br>  Segunda conclusión: los evaluadores son esenciales.  Y no solo durante la etapa de creación de máscaras de segmentación sino también para la validación del resultado final.  Al final, le damos al usuario tres fotos: una imagen original con defectos pintados, una foto coloreada con defectos pintados y una simplemente coloreada en caso de que el algoritmo para la búsqueda de defectos y la pintura se equivoque. <br><br>  Tomamos algunas fotos del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">proyecto War Album</a> y las procesamos en estas neuronas.  Aquí están los resultados que obtuvimos: <br><br><img src="https://habrastorage.org/webt/rm/4z/sb/rm4zsbvc0j_h_r2nobp4xj2p4ei.jpeg"><br><br>  Además, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aquí</a> puede ver más de cerca las imágenes originales y todas las etapas de procesamiento. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/459696/">https://habr.com/ru/post/459696/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459682/index.html">Calidad de datos en almacenamiento</a></li>
<li><a href="../459684/index.html">Mapa del metro de Moscú y el mundo entero para Android</a></li>
<li><a href="../459688/index.html">Urbanismo en China: menos inconformistas, más ciencia e informática</a></li>
<li><a href="../459692/index.html">Cómo descubrimos modificaciones materiales que contradicen los principios químicos establecidos</a></li>
<li><a href="../459694/index.html">Datos del museo Art. Desembale y lance Radio 86RK</a></li>
<li><a href="../459698/index.html">¿Cómo obligar a Oracle BI 12c a crear tantas variables de sesión como necesite un programador?</a></li>
<li><a href="../459704/index.html">LLVM IR y Go</a></li>
<li><a href="../459706/index.html">5 razones por las que debes olvidarte de Redux en las aplicaciones React</a></li>
<li><a href="../459708/index.html">Diseño de interfaz de juego. Brent Fox ¿De qué trata el libro?</a></li>
<li><a href="../459710/index.html">Sobrevive a una colisión frontal y por qué la amnesia no es lo que piensas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>