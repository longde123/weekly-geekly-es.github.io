<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏿‍🤝‍👨🏾 🔊 🏟️ Pensamento funcional. Parte 11: Final 👨‍👩‍👧‍👦 🐮 🍩</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hoje estamos finalizando nossa série de artigos sobre programação funcional. Acabou 11 partes. Eu acredito que isso é uma conquista. Neste artigo, imp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Pensamento funcional. Parte 11: Final</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/433412/"><p>  Hoje estamos finalizando nossa série de artigos sobre programação funcional.  Acabou 11 partes.  Eu acredito que isso é uma conquista.  Neste artigo, implementamos uma calculadora simples de pilha (também conhecida como "notação polonesa reversa").  A implementação é quase completamente construída em funções, com apenas um tipo especial e geralmente sem comparação com a amostra, portanto, este é um excelente campo de teste para os conceitos abordados em nossa série. </p><br><p><img src="https://habrastorage.org/webt/7j/cd/7x/7jcd7xzdvnhpyxuebjvbzb1uiqs.jpeg"></p><br><p>  Quero agradecer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>@kleidemos</em></a> separadamente.  Foi ele quem atuou como principal tradutor e gerente de toda a série de artigos.  Obrigada </p><br><ul><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Primeira parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Segunda parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Terceira parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Quarta parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Quinta parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sexta parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sétima parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Oitava parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Nona parte</a></strong> </li><li>  <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Décimo</a></strong> <a name="habracut"></a></li></ul><br><hr><br><p>  Se você não estiver familiarizado com essa calculadora, ela funcionará da seguinte maneira: números são empurrados para a pilha e operações, como adição e multiplicação, selecionam números da parte superior da pilha e, em seguida, retornam o resultado da operação. </p><br><p>  Esquema de computação simples na pilha: </p><br><br><p>  Antes de projetar esse sistema, considere como ele será usado.  Seguindo uma sintaxe semelhante à quarta, atribuiremos a cada ação um rótulo apropriado para que, no exemplo acima, você possa escrever algo como: </p><br><pre><code class="plaintext hljs">EMPTY ONE THREE ADD TWO MUL SHOW</code> </pre> <br><p>  Talvez seja impossível obter exatamente essa sintaxe, mas vamos tentar chegar o mais próximo possível disso. </p><br><h2>  Tipo de dados da pilha </h2><br><p>  Primeiro, você precisa definir a estrutura de dados para a pilha.  Para simplificar, você pode usar uma lista de números de ponto flutuante. </p><br><pre> <code class="plaintext hljs">type Stack = float list</code> </pre> <br><p>  Mas é melhor agrupá-lo em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tipo de união de caso único</a> para tornar o tipo mais visual, assim: </p><br><pre> <code class="plaintext hljs">type Stack = StackContents of float list</code> </pre> <br><p>  Por que é melhor fazer exatamente isso, você pode ler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui</a> . </p><br><p>  Agora crie uma nova pilha usando <code>StackContents</code> como construtor: </p><br><pre> <code class="plaintext hljs">let newStack = StackContents [1.0;2.0;3.0]</code> </pre> <br><p>  Para extrair conteúdo de uma pilha existente, use o padrão correspondente a <code>StackContents</code> : </p><br><pre> <code class="plaintext hljs">let (StackContents contents) = newStack //  "contents"   // float list = [1.0; 2.0; 3.0]</code> </pre> <br><h2>  Empurre a função </h2><br><p>  Em seguida, precisamos de uma maneira de colocar números nessa pilha.  Para fazer isso, basta adicionar um novo valor ao topo da lista usando " <code>::</code> ". </p><br><p>  Exemplo de função: </p><br><pre> <code class="plaintext hljs">let push x aStack = let (StackContents contents) = aStack let newContents = x::contents StackContents newContents</code> </pre> <br><p>  Esse recurso possui vários recursos que vale a pena discutir. </p><br><p>  Primeiro, você deve prestar atenção ao fato de que a estrutura da <code>list</code> é imutável, o que significa que a função deve pegar uma pilha existente e retornar uma nova.  Isso não é apenas uma alteração em uma pilha existente.  De fato, todas as funções neste exemplo terão um formato semelhante: </p><br><pre> <code class="plaintext hljs">Input: Stack   -  Output:  Stack</code> </pre> <br><p>  Em segundo lugar, por que os parâmetros estão nessa ordem?  Por que a pilha deve ir primeiro ou por último?  Na seção sobre o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">design de funções com aplicação parcial,</a> foi dito que o parâmetro de mudança mais frequente deveria durar.  Em breve será possível verificar se essas recomendações estão sendo seguidas. </p><br><p>  Finalmente, a função pode ser mais concisa, combinando com o padrão no próprio parâmetro da função, em vez de <code>let</code> o corpo da função. </p><br><p>  A versão reescrita: </p><br><pre> <code class="plaintext hljs">let push x (StackContents contents) = StackContents (x::contents)</code> </pre> <br><p>  Muito melhor! </p><br><p>  A propósito, veja sua assinatura graciosa: </p><br><pre> <code class="plaintext hljs">val push : float -&gt; Stack -&gt; Stack</code> </pre> <br><p>  Como mencionado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">anteriormente</a> , a assinatura nos diz muito. <br>  Nesse caso, eu poderia adivinhar o que essa função faz, apenas por sua assinatura, sem nem mesmo saber que é chamada de "push". <br>  Esse é outro motivo pelo qual foi uma boa idéia ter nomes de tipo explícitos.  Se a pilha fosse apenas uma lista de números de ponto flutuante, a função não seria tão auto-documentada. </p><br><p>  De uma forma ou de outra, verifique: </p><br><pre> <code class="plaintext hljs">let emptyStack = StackContents [] let stackWith1 = push 1.0 emptyStack let stackWith2 = push 2.0 stackWith1</code> </pre> <br><p>  Works great! </p><br><h2>  Empilhar sobrescrito superior usando push </h2><br><p>  Com esta função simples, você pode definir facilmente uma operação que envia um número específico à pilha. </p><br><pre> <code class="plaintext hljs">let ONE stack = push 1.0 stack let TWO stack = push 2.0 stack</code> </pre> <br><p>  Mas espere um minuto!  Você vê que o parâmetro da <code>stack</code> é mencionado nos dois lados da expressão?  De fato, não é necessário mencioná-lo duas vezes.  Em vez disso, você pode omitir o parâmetro e escrever uma função com aplicação parcial: </p><br><pre> <code class="plaintext hljs">let ONE = push 1.0 let TWO = push 2.0 let THREE = push 3.0 let FOUR = push 4.0 let FIVE = push 5.0</code> </pre> <br><p>  Agora é óbvio que, se a função <code>push</code> tivesse uma ordem diferente de parâmetros, a <code>stack</code> teria que ser mencionada duas vezes. </p><br><p>  Também vale a pena definir uma função que cria uma pilha vazia: </p><br><pre> <code class="plaintext hljs">let EMPTY = StackContents []</code> </pre> <br><p>  Verifique as funções recebidas: </p><br><pre> <code class="plaintext hljs">let stackWith1 = ONE EMPTY let stackWith2 = TWO stackWith1 let stackWith3 = THREE stackWith2</code> </pre> <br><p>  Essas pilhas intermediárias são irritantes?  É possível se livrar deles?  Claro!  Observe que as funções ONE, DOIS e TRÊS têm a mesma assinatura: </p><br><pre> <code class="plaintext hljs">Stack -&gt; Stack</code> </pre> <br><p>  Então, eles estão perfeitamente conectados!  A saída de uma função pode ser inserida no seguinte: </p><br><pre> <code class="plaintext hljs">let result123 = EMPTY |&gt; ONE |&gt; TWO |&gt; THREE let result312 = EMPTY |&gt; THREE |&gt; ONE |&gt; TWO</code> </pre> <br><h2>  Sair da pilha </h2><br><p>  Com a adição à pilha calculada, mas e a função <code>pop</code> ? </p><br><p>  Ao recuperar da pilha, é obviamente necessário retornar o topo da pilha, mas é exatamente isso? </p><br><p>  Em um estilo orientado a objetos, a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">resposta é sim</a> .  Mas, no caso de OOP, a pilha seria alterada nos bastidores, para que o item superior fosse removido. </p><br><p>  No entanto, em um estilo funcional, a pilha é imutável.  Há apenas uma maneira de remover o elemento superior - crie uma <em>nova pilha</em> sem esse elemento.  Para que o chamador tenha acesso à nova pilha reduzida, ela deve ser retornada junto com o elemento superior. </p><br><p>  Em outras palavras, a função <code>pop</code> deve retornar <em>dois</em> valores, o elemento top e a nova pilha.  A maneira mais simples de fazer isso no F # é simplesmente usar uma tupla. </p><br><p>  Implementação: </p><br><pre> <code class="plaintext hljs">///     ///          let pop (StackContents contents) = match contents with | top::rest -&gt; let newStack = StackContents rest (top,newStack)</code> </pre> <br><p>  A função resultante também é muito simples. </p><br><p>  Como antes, o <code>contents</code> extraído diretamente do parâmetro. </p><br><p>  Em seguida, o conteúdo do <code>contents</code> verificado usando a <code>match..with</code> com a expressão. </p><br><p>  Em seguida, o elemento superior é separado do restante da lista, uma nova pilha é criada com base nos elementos restantes e, finalmente, tudo isso é retornado como um par de tupla. </p><br><p>  Tente executar este código e veja o que acontece.  Você receberá um erro de compilação! <br>  O compilador detectou um caso que não foi resolvido - o que acontece se a pilha estiver vazia? </p><br><p>  Você tem que decidir como lidar com isso. </p><br><ul><li>  Opção 1: retorne o status especial "Sucesso" ou "Erro", como foi feito na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">postagem da série "por que usar F #?"</a>  . </li><li>  Opção 2: lançar uma exceção. </li></ul><br><p>  Normalmente, prefiro usar um estado especial para o erro, mas, nesse caso em particular, preferi lançar uma exceção.  Versão corrigida do <code>pop</code> com manipulação de caixa vazia: </p><br><pre> <code class="plaintext hljs">let pop (StackContents contents) = match contents with | top::rest -&gt; let newStack = StackContents rest (top,newStack) | [] -&gt; failwith "Stack underflow"</code> </pre> <br><p>  Verifique: </p><br><pre> <code class="plaintext hljs">let initialStack = EMPTY |&gt; ONE |&gt; TWO let popped1, poppedStack = pop initialStack let popped2, poppedStack2 = pop poppedStack</code> </pre> <br><p>  e teste de exceção: </p><br><pre> <code class="plaintext hljs">let _ = pop EMPTY</code> </pre> <br><h2>  Funções aritméticas </h2><br><p>  Agora que a adição e a exclusão estão em vigor, você pode começar a trabalhar com as funções "adicionar" e "multiplicar": </p><br><pre> <code class="plaintext hljs">let ADD stack = let x,s = pop stack //   let y,s2 = pop s //    let result = x + y //   push result s2 //     let MUL stack = let x,s = pop stack //   let y,s2 = pop s //    let result = x * y //   push result s2 //    </code> </pre> <br><p>  Teste on-line: </p><br><pre> <code class="plaintext hljs">let add1and2 = EMPTY |&gt; ONE |&gt; TWO |&gt; ADD let add2and3 = EMPTY |&gt; TWO |&gt; THREE |&gt; ADD let mult2and3 = EMPTY |&gt; TWO |&gt; THREE |&gt; MUL</code> </pre> <br><p>  Isso funciona! </p><br><h3>  Tempo de refatoração ... </h3><br><p>  Obviamente, uma quantidade significativa de código é duplicada nessas duas funções.  Como podemos consertar isso? </p><br><p>  Ambas as funções extraem dois valores da pilha, aplicam uma certa função binária a eles e empurram o resultado de volta para a pilha.  Você pode enviar o código geral para a função binária, que assume uma função matemática com dois parâmetros: </p><br><pre> <code class="plaintext hljs">let binary mathFn stack = //    let y,stack' = pop stack //     let x,stack'' = pop stack' //  let z = mathFn xy //      push z stack''</code> </pre> <br><p>  <em>Observe que nesta implementação, versões diferentes do objeto "mesmo" são marcadas com um número diferente de aspas.</em>  <em>Isso ocorre porque os sufixos numéricos podem facilmente causar confusão.</em> </p><br><p>  Pergunta: por que os parâmetros têm exatamente essa ordem, em vez de <code>mathFn</code> vir depois da <code>stack</code> ? </p><br><p>  Agora que você possui uma função <code>binary</code> , é muito mais fácil definir ADD e outras funções: </p><br><p>  Primeira tentativa de implementar o ADD usando <code>binary</code> : </p><br><pre> <code class="plaintext hljs">let ADD aStack = binary (fun xy -&gt; x + y) aStack</code> </pre> <br><p>  Mas você pode se livrar do lambda, porque  representa a definição <em>exata</em> da função <code>+</code> : </p><br><pre> <code class="plaintext hljs">let ADD aStack = binary (+) aStack</code> </pre> <br><p>  Novamente, um aplicativo parcial pode ser usado para ocultar o parâmetro da pilha.  Definição final: </p><br><pre> <code class="plaintext hljs">let ADD = binary (+)</code> </pre> <br><p>  Definição de outras funções matemáticas: </p><br><pre> <code class="plaintext hljs">let SUB = binary (-) let MUL = binary (*) let DIV = binary (../)</code> </pre> <br><p>  Experimente on-line: </p><br><pre> <code class="plaintext hljs">let div2by3 = EMPTY |&gt; THREE|&gt; TWO |&gt; DIV let sub2from5 = EMPTY |&gt; TWO |&gt; FIVE |&gt; SUB let add1and2thenSub3 = EMPTY |&gt; ONE |&gt; TWO |&gt; ADD |&gt; THREE |&gt; SUB</code> </pre> <br><p>  Da mesma forma, você pode criar uma função auxiliar para operações unárias </p><br><pre> <code class="plaintext hljs">let unary f stack = let x,stack' = pop stack push (fx) stack'</code> </pre> <br><p>  E defina algumas funções unárias: </p><br><pre> <code class="plaintext hljs">let NEG = unary (fun x -&gt; -x) let SQUARE = unary (fun x -&gt; x * x)</code> </pre> <br><p>  Modo interativo: </p><br><pre> <code class="plaintext hljs">let neg3 = EMPTY |&gt; THREE|&gt; NEG let square2 = EMPTY |&gt; TWO |&gt; SQUARE</code> </pre> <br><h2>  Juntando tudo |  Juntando tudo </h2><br><p>  Nos requisitos iniciais, foi mencionado que gostaríamos de poder mostrar os resultados, por isso vale a pena definir a função SHOW. </p><br><pre> <code class="plaintext hljs">let SHOW stack = let x,_ = pop stack printfn "The answer is %f" x stack //      </code> </pre> <br><p>  Observe que, neste caso, a nova versão da pilha recebida via <code>pop</code> é ignorada.  O resultado final é a pilha original, como se nunca tivesse mudado. </p><br><p>  Por fim, você pode escrever o exemplo a seguir nos requisitos originais </p><br><pre> <code class="plaintext hljs">EMPTY |&gt; ONE |&gt; THREE |&gt; ADD |&gt; TWO |&gt; MUL |&gt; SHOW</code> </pre> <br><h3>  Seguir em frente </h3><br><p>  É divertido, mas o que mais você pode fazer? </p><br><p>  Você pode definir várias funções adicionais: </p><br><pre> <code class="plaintext hljs">///      let DUP stack = //    let x,_ = pop stack //      push x stack ///      let SWAP stack = let x,s = pop stack let y,s' = pop s push y (push x s') ///    let START = EMPTY</code> </pre> <br><p>  Usando essas funções adicionais, você pode escrever alguns exemplos elegantes: </p><br><pre> <code class="plaintext hljs">START |&gt; ONE |&gt; TWO |&gt; SHOW START |&gt; ONE |&gt; TWO |&gt; ADD |&gt; SHOW |&gt; THREE |&gt; ADD |&gt; SHOW START |&gt; THREE |&gt; DUP |&gt; DUP |&gt; MUL |&gt; MUL // 27 START |&gt; ONE |&gt; TWO |&gt; ADD |&gt; SHOW // 3 |&gt; THREE |&gt; MUL |&gt; SHOW // 9 |&gt; TWO |&gt; SWAP |&gt; DIV |&gt; SHOW // 9 div 2 = 4.5</code> </pre> <br><h2>  Usando composição em vez de pipelining </h2><br><p>  Mas isso não é tudo.  De fato, existe outra maneira interessante de representar essas funções. </p><br><p>  Como observado anteriormente, todos eles têm a mesma assinatura: </p><br><pre> <code class="plaintext hljs">Stack -&gt; Stack</code> </pre> <br><p>  Como entrada e saída são do mesmo tipo, essas funções também podem ser combinadas usando o operador de composição <code>&gt;&gt;</code> , e não apenas através de operadores em pipeline. </p><br><p>  Alguns exemplos: </p><br><pre> <code class="plaintext hljs">//    let ONE_TWO_ADD = ONE &gt;&gt; TWO &gt;&gt; ADD START |&gt; ONE_TWO_ADD |&gt; SHOW //    let SQUARE = DUP &gt;&gt; MUL START |&gt; TWO |&gt; SQUARE |&gt; SHOW //     let CUBE = DUP &gt;&gt; DUP &gt;&gt; MUL &gt;&gt; MUL START |&gt; THREE |&gt; CUBE |&gt; SHOW //   let SUM_NUMBERS_UPTO = DUP // n &gt;&gt; ONE &gt;&gt; ADD // n+1 &gt;&gt; MUL // n(n+1) &gt;&gt; TWO &gt;&gt; SWAP &gt;&gt; DIV // n(n+1) / 2 START |&gt; THREE |&gt; SQUARE |&gt; SUM_NUMBERS_UPTO |&gt; SHOW</code> </pre> <br><p>  Em cada um desses exemplos, uma nova função é definida usando uma composição de outras funções.  Este é um bom exemplo de uma abordagem "combinatória" para criar funcionalidades. </p><br><h2>  Transportadores vs. Composição </h2><br><p>  Vimos duas maneiras diferentes de usar nosso modelo;  usando transportadores e composição.  Mas qual a diferença?  E por que um deve ser preferido em detrimento de outro? </p><br><p>  A diferença é que os pipelines são, em certo sentido, uma operação de "transformação em tempo real".  No momento do uso do pipeline, as operações são executadas imediatamente, através da transferência de uma pilha específica. </p><br><p>  Por outro lado, a composição é algo como um "plano" que queremos implementar, construindo funções a partir de um conjunto de componentes sem aplicação direta. </p><br><p>  Por exemplo, você pode criar um "plano" para calcular o quadrado de um número por meio de uma combinação de pequenas operações: </p><br><pre> <code class="plaintext hljs">let COMPOSED_SQUARE = DUP &gt;&gt; MUL</code> </pre> <br><p>  Não posso dar o equivalente com base em pipelines. </p><br><pre> <code class="plaintext hljs">let PIPED_SQUARE = DUP |&gt; MUL</code> </pre> <br><p>  Isso resultará em um erro de compilação.  Eu preciso de alguma instância de pilha específica para a expressão funcionar: </p><br><pre> <code class="plaintext hljs">let stackWith2 = EMPTY |&gt; TWO let twoSquared = stackWith2 |&gt; DUP |&gt; MUL</code> </pre> <br><p>  E mesmo neste caso, posso obter uma resposta apenas para essa entrada específica, e não um plano de cálculo generalizado com base em qualquer entrada, como no exemplo de <code>COMPOSED_SQUARE</code> . </p><br><p>  Outra maneira de criar um "plano" é passar explicitamente o lambda para funções mais primitivas: </p><br><pre> <code class="plaintext hljs">let LAMBDA_SQUARE = unary (fun x -&gt; x * x)</code> </pre> <br><p>  Essa é uma maneira mais explícita (e provavelmente mais rápida), mas todas as vantagens e clareza da abordagem composicional são perdidas. </p><br><p>  Em geral, se possível, você deve procurar uma abordagem de composição! </p><br><h2>  Código completo </h2><br><p>  Código completo para todos os exemplos acima: </p><br><pre> <code class="plaintext hljs">// ============================================== //  // ============================================== type Stack = StackContents of float list // ============================================== //   // ============================================== ///     let push x (StackContents contents) = StackContents (x::contents) ///        ///       let pop (StackContents contents) = match contents with | top::rest -&gt; let newStack = StackContents rest (top,newStack) | [] -&gt; failwith "Stack underflow" // ============================================== //  () // ============================================== //     //      //     let binary mathFn stack = let y,stack' = pop stack let x,stack'' = pop stack' let z = mathFn xy push z stack'' //    //      //     let unary f stack = let x,stack' = pop stack push (fx) stack' // ============================================== //  () // ============================================== ///      let SHOW stack = let x,_ = pop stack printfn "The answer is %f" x stack //      ///    let DUP stack = let x,s = pop stack push x (push xs) ///      let SWAP stack = let x,s = pop stack let y,s' = pop s push y (push x s') ///    let DROP stack = let _,s = pop stack //   s //   // ============================================== // ,    // ============================================== //  // ------------------------------- let EMPTY = StackContents [] let START = EMPTY //  // ------------------------------- let ONE = push 1.0 let TWO = push 2.0 let THREE = push 3.0 let FOUR = push 4.0 let FIVE = push 5.0 //   // ------------------------------- let ADD = binary (+) let SUB = binary (-) let MUL = binary (*) let DIV = binary (../) let NEG = unary (fun x -&gt; -x) // ============================================== // ,     // ============================================== let SQUARE = DUP &gt;&gt; MUL let CUBE = DUP &gt;&gt; DUP &gt;&gt; MUL &gt;&gt; MUL let SUM_NUMBERS_UPTO = DUP // n &gt;&gt; ONE &gt;&gt; ADD // n+1 &gt;&gt; MUL // n(n+1) &gt;&gt; TWO &gt;&gt; SWAP &gt;&gt; DIV // n(n+1) / 2</code> </pre> <br><h2>  Conclusão </h2><br><p>  Temos uma calculadora simples baseada em pilha.  Vimos como, começando com algumas operações primitivas ( <code>push</code> , <code>pop</code> , <code>binary</code> , <code>unary</code> ) e outras, é possível criar uma DSL completa, fácil de implementar e usar. </p><br><p>  Como você pode imaginar, este exemplo foi baseado na linguagem Forth.  Eu recomendo o livro gratuito <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Thinking Forth"</a> , que fala não apenas sobre a linguagem Forth, mas também sobre outros métodos ( <em>não</em> orientados a objetos!) Para decompor tarefas que são igualmente aplicáveis ​​à programação funcional em geral. </p><br><p>  Eu tive a idéia para este artigo no blog lindo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ashley Feniello</a> .  Se você quiser se aprofundar na emulação de uma linguagem baseada em pilha baseada em F #, comece com ela.  <em>Divirta-se!</em> </p><br><h1>  Recursos Adicionais </h1><br><p>  Existem muitos tutoriais para F #, incluindo materiais para quem vem com experiência em C # ou Java.  Os links a seguir podem ser úteis à medida que você avança no F #: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Guia F #</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">F # para diversão e lucro</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">F # Wiki</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Aprenda X em Y Minutos: F #</a> </li></ul><br><p>  Várias outras maneiras <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">de começar a aprender F #</a> também <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">são</a> descritas. </p><br><p>  Finalmente, a comunidade F # é muito amigável para iniciantes.  Há um bate-papo muito ativo no Slack, suportado pela F # Software Foundation, com salas para iniciantes nas quais você <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">pode participar livremente</a> .  É altamente recomendável que você faça isso! </p><br><p>  Não se esqueça de visitar o site da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">comunidade de língua russa F #</a> !  Se você tiver alguma dúvida sobre o aprendizado de um idioma, teremos prazer em discuti-los nas salas de bate-papo: </p><br><ul><li>  room <code>#ru_general</code> no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">F # Software Foundation Slack Chat</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">chat em telegrama</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">conversar em gitter</a> </li><li>  room #en_general no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">F # Software Foundation Slack Chat</a> </li></ul><br><h2>  Sobre autores de tradução </h2><br><p>  Traduzido por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>@kleidemos</em></a> <br><img src="https://habrastorage.org/getpro/habr/post_images/f95/c6d/92c/f95c6d92c5b1126b093792a43955aa43.png" width="56" height="56">  As mudanças de tradução e editoriais foram feitas pelos esforços da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">comunidade de desenvolvedores de F # de língua russa</a> .  Agradecemos também a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>@schvepsss</em></a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><em>@shwars</em></a> pela preparação deste artigo para publicação. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt433412/">https://habr.com/ru/post/pt433412/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt433402/index.html">Pensamento funcional. Parte 8</a></li>
<li><a href="../pt433404/index.html">Tutorial Reagir Parte 3: Arquivos de Componentes, Estrutura do Projeto</a></li>
<li><a href="../pt433406/index.html">Pensamento funcional. Parte 9</a></li>
<li><a href="../pt433408/index.html">Manipulação eficiente de memória no Node.js</a></li>
<li><a href="../pt433410/index.html">Pensamento funcional. Parte 10</a></li>
<li><a href="../pt433414/index.html">Testando o PRTG Network Monitor e comparação com o Zabbix</a></li>
<li><a href="../pt433420/index.html">Resultados ZeroNights 2018</a></li>
<li><a href="../pt433424/index.html">É possível carregar um nível intransitável no Super Mario Maker?</a></li>
<li><a href="../pt433428/index.html">De onde vem a criatividade: análise da atividade das ondas alfa do cérebro durante testes RAT</a></li>
<li><a href="../pt433430/index.html">Caixa Mecool KM9 para Android no novo SoC Amlogic S905X2 com 4 GB de RAM e Android TV 8.1 - entenda e perdoe</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>