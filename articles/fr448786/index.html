<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎀 👨🏿‍💼 🐘 Test Python avec pytest. CHAPITRE 3 Appareils pytest 🤯 ☕️ 😄</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Retour Suivant 


 Ce livre est le chapitre manquant qui manque dans tous les livres Python complets. 


 Frank ruiz 
 Ingénieur principal en fiabilit...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Test Python avec pytest. CHAPITRE 3 Appareils pytest</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448786/"><p><img src="https://habrastorage.org/webt/jl/jn/bb/jljnbbjr-ejh473xy_eccsmknpk.png">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Retour</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Suivant</a> <img src="https://habrastorage.org/webt/rw/dy/-g/rwdy-grsvbpcetjttrmecdkxtlk.png"></p><br><p>  Ce livre est le chapitre manquant qui manque dans tous les livres Python complets. </p><br><p>  Frank ruiz <br>  Ingénieur principal en fiabilité de site, Box, Inc. </p><br><p><img src="https://habrastorage.org/webt/hd/--/9w/hd--9w134j0rxhmxftrflbbdopy.png"></p><a name="habracut"></a><br><p>  Les exemples de ce livre sont écrits en utilisant Python 3.6 et pytest 3.2.  pytest 3.2 prend en charge Python 2.6, 2.7 et Python 3.3+ </p><br><blockquote> Le code source du projet Tâches, ainsi que pour tous les tests présentés dans ce livre, est disponible sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="https://pragprog.com/titles/bopytest/source_code">lien</a> sur la page Web du livre à <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="https://pragprog.com/titles/bopytest">pragprog.com</a> .  Vous n'avez pas besoin de télécharger le code source pour comprendre le code de test;  le code de test est présenté sous une forme pratique dans les exemples.  Mais pour suivre les tâches du projet ou adapter des exemples de test pour tester votre propre projet (vos mains ne sont pas liées!), Vous devez vous rendre sur la page Web du livre et télécharger le travail.  Là, sur la page Web du livre, il y a un lien pour les messages d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="https://pragprog.com/titles/bopytest/errata">erreur</a> et un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" title="https://forums.pragprog.com/forums/438">forum de discussion</a> . </blockquote><p>  Sous le spoiler se trouve une liste d'articles de cette série. </p><br><div class="spoiler">  <b class="spoiler_title">Table des matières</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>Présentation</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>Chapitre 1: Premiers pas avec Pytest</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>Chapitre 2: Écriture des fonctions de test</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>Chapitre 3: Appareils Pytest</strong></a> (Cet article) </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>Chapitre 4: Luminaires intégrés</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>Chapitre 5: Plugins</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>Chapitre 6: Configuration</strong></a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>Chapitre 7: Utilisation de pytest avec d'autres outils</strong></a> </li></ul></div></div><br><p>  Maintenant que vous avez vu les bases de pytest, tournons notre attention vers les fixtures, qui sont nécessaires pour structurer le code de test pour presque n'importe quel système logiciel non trivial.  Les luminaires sont des fonctions exécutées par pytest avant (et parfois après) les fonctions de test réelles.  Le code du luminaire peut faire tout ce dont vous avez besoin.  Vous pouvez utiliser Fixtures pour obtenir un ensemble de données à tester.  Vous pouvez utiliser des appareils pour obtenir le système dans un état connu avant d'exécuter le test.  Les appareils sont également utilisés pour obtenir des données pour plusieurs tests. </p><br><p>  Voici un exemple de luminaire simple qui renvoie un nombre: </p><br><blockquote> <strong>ch3 / <code>test_fixtures.py</code></strong> </blockquote><br><pre> <code class="plaintext hljs">import pytest @pytest.fixture() def some_data(): """Return answer to ultimate question.""" return 42 def test_some_data(some_data): """Use fixture return value in a test.""" assert some_data == 42</code> </pre> <br><p>  Le <code>@pytest.fixture()</code> est utilisé pour indiquer à pytest que la fonction est un appareil.  Lorsque vous incluez le nom du luminaire dans la liste des paramètres de la fonction de test, pytest sait comment l'exécuter avant d'exécuter le test.  Les appareils peuvent faire le travail ou renvoyer des données à une fonction de test. </p><br><p>  Le test <code>test_some_data()</code> a le nom du <code>test_some_data()</code> <code>some_data</code> comme paramètre.  pytest le détectera et trouvera un appareil portant ce nom.  Le nom est significatif dans pytest.  pytest recherchera un appareil portant ce nom dans le module de test.  Il cherchera également dans <em>conftest.py</em> s'il ne le trouve pas ici. </p><br><p>  Avant de commencer nos recherches sur les fixtures (et le fichier conftest.py), je dois considérer le fait que le terme fixture a de nombreuses significations dans la communauté de programmation et de test et même dans la communauté Python.  J'utilise de <code>fixture method</code> interchangeable les <code>fixture function</code> <code>fixture</code> , <code>fixture function</code> et <code>fixture method</code> faire référence aux fonctions <code>@pytest.fixture()</code> décrites dans ce chapitre.  Fixture peut également être utilisé pour indiquer une ressource référencée par une fonction fixture.  Les fonctions de fixture configurent ou récupèrent souvent certaines données avec lesquelles le test peut fonctionner.  Parfois, ces données sont considérées comme fixes.  Par exemple, la communauté Django utilise souvent des appareils pour indiquer certaines des données brutes qui sont chargées dans la base de données au début de l'application. </p><br><p>  Indépendamment d'autres significations, dans pytest et dans ce livre, les montages de test se réfèrent au mécanisme que pytest fournit pour séparer le code «se préparer pour» et «nettoyer après» de vos fonctions de test. </p><br><p>  Les luminaires pytest sont l'une des caractéristiques uniques qui élèvent le pytest par rapport aux autres environnements de test et sont la raison pour laquelle de nombreuses personnes respectées passent à ... et restent avec pytest.  Cependant, les appareils dans pytest sont différents des appareils dans Django et différents des procédures de configuration et de démontage trouvées dans unittest et nose.  Il existe de nombreuses fonctionnalités et nuances en ce qui concerne les luminaires.  Une fois que vous aurez un bon modèle mental de leur fonctionnement, vous vous sentirez mieux.  Cependant, vous devez jouer avec eux pendant un certain temps pour entrer, alors commençons. </p><br><h2 id="obmen-fixtures-cherez-conftestpy">  Partager des appareils via conftest.py </h2><br><p>  Vous pouvez placer des appareils dans des fichiers de test séparés, mais pour partager des appareils dans plusieurs fichiers de test, il est préférable d'utiliser le fichier <em>conftest.py</em> quelque part dans un endroit commun, de manière centralisée pour tous les tests.  Pour un projet de tâche, tous les appareils seront dans le <code>tasks_proj/tests/conftest.py</code> . </p><br><p>  De là, les appareils peuvent être partagés par n'importe quelle pâte.  Vous pouvez placer les appareils dans des fichiers de test distincts si vous souhaitez que l'appareil soit utilisé uniquement dans les tests de ce fichier.  De même, vous pouvez avoir d'autres fichiers <em>conftest.py</em> dans les sous-répertoires du répertoire de <em>tests supérieur</em> .  Si vous le faites, les appareils définis dans ces fichiers conftest.py de bas niveau seront disponibles pour les tests dans ce répertoire et sous-répertoires.  Cependant, jusqu'à présent, les appareils du projet Tâches ont été conçus pour n'importe quel test.  Par conséquent, l'utilisation de tous nos outils dans le fichier <em>conftest.py</em> à la racine du test, <code>tasks_proj/tests</code> , est la plus logique. </p><br><p>  Bien que conftest.py soit un module Python, il ne doit pas être importé par des fichiers de test.  N'importez pas conftest quand!  Le fichier conftest.py est lu par pytest et considéré comme un plug-in local, ce qui deviendra clair lorsque nous commencerons à parler des plug-ins dans le chapitre 5 "Plug-ins" à la page 95. Pour l'instant, considérez <code>tests/conftest.py</code> comme l'endroit où nous pouvons mettre des appareils à utiliser tous les tests dans le répertoire test.  <code>task_proj</code> ensuite certains de nos tests pour que <code>task_proj</code> utilise correctement les appareils. </p><br><h2 id="ispolzovanie--fixtures-dlya-setup-i-teardown">  Utilisation des appareils pour la configuration et le démontage </h2><br><p>  La plupart des tests du projet Tâches supposent que la base de données Tâches est déjà configurée, en cours d'exécution et prête.  Et nous devons supprimer certaines entrées à la fin, s'il y a un besoin de nettoyage.  Et vous devrez peut-être également vous déconnecter de la base de données.  Heureusement, la plupart de ces <code>tasks.start_tasks_db(&lt;directory to store db\&gt;, 'tiny' or 'mongo')</code> été pris en charge dans le code de tâche avec <code>tasks.start_tasks_db(&lt;directory to store db\&gt;, 'tiny' or 'mongo')</code> et <code>tasks.stop_tasks_db()</code> ;  nous avons juste besoin de les appeler au bon moment, et nous avons également besoin d'un répertoire temporaire. </p><br><p>  Heureusement, pytest comprend un excellent appareil appelé tmpdir.  Nous pouvons l'utiliser pour des tests et n'avons pas à nous soucier du nettoyage.  Ce n'est pas magique, juste une bonne pratique de codage des personnes les plus curieuses.  (Ne vous inquiétez pas, nous analyserons tmpdir et l'écrirons plus en détail à l'aide de tmpdir_factory dans la section «Utilisation de tmpdir et tmpdir_factory» à la page 71.) </p><br><p>  Compte tenu de tous ces composants, ce luminaire fonctionne très bien: </p><br><blockquote>  <strong>ch3 / a / <code>tasks_proj</code> /tests/conftest.py</strong> </blockquote><br><pre> <code class="plaintext hljs">import pytest import tasks from tasks import Task @pytest.fixture() def tasks_db(tmpdir): """    ,  .""" # Setup : start db tasks.start_tasks_db(str(tmpdir), 'tiny') yield #    # Teardown : stop db tasks.stop_tasks_db()</code> </pre> <br><p>  La valeur de <em>tmpdir n'est</em> pas une chaîne - c'est un objet qui représente un répertoire.  Cependant, il implémente <code>__str__</code> , nous pouvons donc utiliser <code>str()</code> pour obtenir la chaîne à passer à <code>start_tasks_db()</code> .  Pour l'instant, nous utilisons encore Tiny pour TinyDB. </p><br><p>  La fonction fixture est exécutée avant les tests qui l'utilisent.  Cependant, si la fonction a un <em>rendement</em> , elle s'arrêtera là, le contrôle sera passé aux tests et la ligne suivante après l'exécution du <em>rendement une</em> fois les tests terminés.  Par conséquent, considérez le code ci-dessus comme "setup" et le code après comme "démontage".  Le code après le «démontage» du <em>rendement</em> s'exécutera indépendamment de ce qui se passe pendant les tests.  Nous ne renvoyons pas de données avec sortie dans ce luminaire.  Mais tu peux. </p><br><p>  <code>tasks.add()</code> un de nos tests <code>tasks.add()</code> pour utiliser ce luminaire: </p><br><blockquote>  ch3 / a / <code>tasks_proj</code> / tests / func / <code>test_add</code> .py </blockquote><br><pre> <code class="plaintext hljs">import pytest import tasks from tasks import Task def test_add_returns_valid_id(tasks_db): """tasks.add(&lt;valid task&gt;)    .""" # GIVEN    # WHEN    # THEN  task_id  int new_task = Task('do something') task_id = tasks.add(new_task) assert isinstance(task_id, int)</code> </pre> <br><p>  Le principal changement ici est que le luminaire supplémentaire dans le fichier a été supprimé, et nous avons ajouté <code>tasks_db</code> à la liste des paramètres de test.  J'aime structurer les tests au format GIVEN <em>/ WHEN / THEN</em> (DANO / WHEN / AFTER), en utilisant des commentaires, surtout si ce n'est pas évident dans le code ce qui se passe.  Je pense que cela est utile dans ce cas.  Espérons que les tâches de base de données initialisées <code>tasks_db</code> aideront à découvrir pourquoi la <code>tasks_db</code> utilisée comme outil de test. </p><br><hr><br><p>  Assurez-vous que Tâches est installé. </p><br><hr><br><p>  Nous écrivons toujours des tests pour le projet Tâches dans ce chapitre, qui a d'abord été installé dans le chapitre 2. Si vous avez ignoré ce chapitre, assurez-vous d'installer les tâches avec le code cd;  <code>pip install ./tasks_proj/</code> . </p><br><hr><br><h2 id="trassirovka-fixture-execution-s-setup-show">  Exécution du dispositif de traçage avec –setup-show </h2><br><p>  Si vous exécutez le test à partir de la dernière section, vous ne verrez pas quels appareils fonctionnent: </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ $ pip install ./tasks_proj/ #      $ cd /path/to/code/ch3/a/tasks_proj/tests/func $ pytest -v test_add.py -k valid_id ===================== test session starts ====================== collected 3 items test_add.py::test_add_returns_valid_id PASSED ====================== 2 tests deselected ====================== ============ 1 passed, 2 deselected in 0.02 seconds ============</code> </pre> <br><p>  Quand je conçois des luminaires, j'ai besoin de voir ce qui fonctionne et quand.  Heureusement, pytest fournit un tel indicateur de ligne de commande, <code>-- setup-show</code> , qui fait exactement cela: </p><br><pre> <code class="plaintext hljs">$ pytest --setup-show test_add.py -k valid_id ============================= test session starts ============================= collected 3 items / 2 deselected test_add.py SETUP S tmpdir_factory SETUP F tmpdir (fixtures used: tmpdir_factory) SETUP F tasks_db (fixtures used: tmpdir) func/test_add.py::test_add_returns_valid_id (fixtures used: tasks_db, tmpdir, tmpdir_factory). TEARDOWN F tasks_db TEARDOWN F tmpdir TEARDOWN S tmpdir_factory =================== 1 passed, 2 deselected in 0.18 seconds ====================</code> </pre> <br><p>  Notre test est au milieu, et pytest a désigné la partie SETUP et TEARDOWN pour chaque appareil.  En commençant par <code>test_add_returns_valid_id</code> , vous voyez que <code>tmpdir</code> fonctionné avant le test.  Et avant cela, <code>tmpdir_factory</code> .  <code>tmpdir</code> semble <code>tmpdir</code> utiliser comme un appareil. </p><br><p>  <strong>F</strong> et <strong>S</strong> devant les noms des luminaires indiquent la zone.  <strong>F</strong> pour la portée et <strong>S</strong> pour la portée de la session.  Je vais couvrir la portée dans la section «Spécifications de la fixation de la portée» à la page 56. </p><br><h2 id="ispolzovanie-fixtures-dlya-test-data">  Utilisation d'appareils pour les données de test </h2><br><p>  Les appareils sont un excellent endroit pour stocker des données pour les tests.  Vous pouvez retourner n'importe quoi.  Voici un appareil qui renvoie un tuple de type mixte: </p><br><blockquote>  <strong>ch3 / test_fixtures.py</strong> </blockquote><br><pre> <code class="plaintext hljs">@pytest.fixture() def a_tuple(): """ -  """ return (1, 'foo', None, {'bar': 23}) def test_a_tuple(a_tuple): """Demo the a_tuple fixture.""" assert a_tuple[3]['bar'] == 32</code> </pre> <br><p>  Puisque <code>test_a_tuple()</code> devrait échouer <em>(23! = 32)</em> , nous verrons ce qui se passe lorsque le test du luminaire échoue: </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch3 $ pytest test_fixtures.py::test_a_tuple ============================= test session starts ============================= collected 1 item test_fixtures.py F [100%] ================================== FAILURES =================================== ________________________________ test_a_tuple _________________________________ a_tuple = (1, 'foo', None, {'bar': 23}) def test_a_tuple(a_tuple): """Demo the a_tuple fixture.""" &gt; assert a_tuple[3]['bar'] == 32 E assert 23 == 32 test_fixtures.py:38: AssertionError ========================== 1 failed in 0.17 seconds ===========================</code> </pre> <br><p>  Avec la section de trace de pile, pytest affiche les paramètres de valeur de la fonction qui a provoqué l'exception ou l'échec de l'assertion.  Dans le cas des tests, les appareils sont les paramètres du test, ils sont donc signalés à l'aide de la trace de pile.  Que se passe-t-il si l'assertion (ou l'exception) se produit dans le montage? </p><br><pre> <code class="plaintext hljs">$ pytest -v test_fixtures.py::test_other_data ============================= test session starts ============================= test_fixtures.py::test_other_data ERROR [100%] =================================== ERRORS ==================================== ______________________ ERROR at setup of test_other_data ______________________ @pytest.fixture() def some_other_data(): """Raise an exception from fixture.""" x = 43 &gt; assert x == 42 E assert 43 == 42 test_fixtures.py:21: AssertionError =========================== 1 error in 0.13 seconds ===========================</code> </pre> <br><p>  Deux ou trois choses se produisent.  La trace de pile montre correctement que l'assertion s'est produite dans la fonction de fixture.  De plus, <code>test_other_data</code> signalé non pas comme <strong>FAIL</strong> , mais comme <strong>ERROR</strong> .  C'est une différence majeure.  Si le test échoue soudainement, vous savez que la panne s'est produite dans le test lui-même et ne dépend pas d'un appareil. </p><br><p>  Mais qu'en est-il du projet Tâches?  Pour le projet Tâches, nous pourrions probablement utiliser certains appareils de données, éventuellement différentes listes de tâches avec différentes propriétés: </p><br><blockquote>  <strong>ch3 / a / tasks_proj / tests / conftest.py</strong> </blockquote><br><pre> <code class="plaintext hljs">#    Task constructor # Task(summary=None, owner=None, done=False, id=None) # summary    # owner  done   # id    @pytest.fixture() def tasks_just_a_few(): """    .""" return ( Task('Write some code', 'Brian', True), Task("Code review Brian's code", 'Katie', False), Task('Fix what Brian did', 'Michelle', False)) @pytest.fixture() def tasks_mult_per_owner(): """     .""" return ( Task('Make a cookie', 'Raphael'), Task('Use an emoji', 'Raphael'), Task('Move to Berlin', 'Raphael'), Task('Create', 'Michelle'), Task('Inspire', 'Michelle'), Task('Encourage', 'Michelle'), Task('Do a handstand', 'Daniel'), Task('Write some books', 'Daniel'), Task('Eat ice cream', 'Daniel'))</code> </pre> <br><p>  Vous pouvez les utiliser directement à partir de tests ou d'autres appareils.  Créons des bases de données non vides pour les tests avec leur aide. </p><br><h2 id="ispolzovanie-multiple-fixtures">  Utilisation de plusieurs appareils </h2><br><p>  Vous avez déjà vu que tmpdir utilise tmpdir_factory.  Et vous avez utilisé tmpdir dans notre appareil task_db.  Continuons la chaîne et ajoutons quelques appareils spécialisés pour les bases non vides du projet de tâches: </p><br><blockquote>  <strong>ch3 / a / tasks_proj / tests / conftest.py</strong> </blockquote><br><pre> <code class="plaintext hljs">@pytest.fixture() def db_with_3_tasks(tasks_db, tasks_just_a_few): """   3 ,  .""" for t in tasks_just_a_few: tasks.add(t) @pytest.fixture() def db_with_multi_per_owner(tasks_db, tasks_mult_per_owner): """   9 , 3 owners,  3   .""" for t in tasks_mult_per_owner: tasks.add(t)</code> </pre> <br><p>  Tous ces appareils incluent deux appareils dans leur liste de paramètres: <code>tasks_db</code> et ensemble de données.  Un jeu de données est utilisé pour ajouter des tâches à la base de données.  Les tests peuvent désormais les utiliser si vous souhaitez que le test démarre avec une base de données non vide, par exemple: </p><br><blockquote>  <strong>ch3 / a / tasks_proj / tests / func / test_add.py</strong> </blockquote><br><pre> <code class="plaintext hljs">def test_add_increases_count(db_with_3_tasks): """Test tasks.add()    tasks.count().""" # GIVEN db  3  # WHEN     tasks.add(Task('throw a party')) # THEN    1 assert tasks.count() == 4</code> </pre> <br><p>  Cela montre également l'une des principales raisons d'utiliser des appareils: pour concentrer le test sur ce que vous testez réellement, plutôt que sur ce que vous avez dû faire pour vous préparer au test.  J'aime utiliser les commentaires pour GIVEN / WHEN / THEN et essayer de pousser autant de données (GIVEN) que possible dans les appareils pour deux raisons.  Premièrement, cela rend le test plus lisible et donc plus facile à maintenir.  Deuxièmement, une assertion ou une exception dans un appareil entraîne une erreur (ERROR), tandis qu'une assertion ou une exception dans une fonction de test entraîne une erreur (FAIL).  Je ne veux pas que <code>test_add_increases_count()</code> si l'initialisation de la base de données a échoué.  C'est juste déroutant.  Je veux que l'échec (FAIL) de <code>test_add_increases_count()</code> soit possible que si <code>add ()</code> ne pouvait vraiment pas changer le compteur.  Courons et voyons comment fonctionnent tous les appareils: </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch3/a/tasks_proj/tests/func $ pytest --setup-show test_add.py::test_add_increases_count ============================= test session starts ============================= collected 1 item test_add.py SETUP S tmpdir_factory SETUP F tmpdir (fixtures used: tmpdir_factory) SETUP F tasks_db (fixtures used: tmpdir) SETUP F tasks_just_a_few SETUP F db_with_3_tasks (fixtures used: tasks_db, tasks_just_a_few) func/test_add.py::test_add_increases_count (fixtures used: db_with_3_tasks, tasks_db, tasks_just_a_few, tmpdir, tmpdir_factory). TEARDOWN F db_with_3_tasks TEARDOWN F tasks_just_a_few TEARDOWN F tasks_db TEARDOWN F tmpdir TEARDOWN S tmpdir_factory ========================== 1 passed in 0.20 seconds ===========================</code> </pre> <br><p>  Nous avons de nouveau obtenu un tas de F et de S pour la zone de fonction et de session.  Voyons voir ce que c'est. </p><br><h2 id="specifikaciya-oblasteyscope-fixture">  Spécifications de l'appareil de portée </h2><br><p>  Les appareils incluent un paramètre facultatif appelé <strong>scope</strong> , qui détermine la fréquence à laquelle les appareils reçoivent la configuration et le torndown.  Le paramètre de <em>portée</em> de <code>@ pytest.fixture()</code> peut avoir des valeurs de fonction, de classe, de module ou de session.  <em>La portée</em> est une fonction par défaut.  Les paramètres tasks_db et tous les appareils ne définissent pas encore de zone.  Ce sont donc des luminaires fonctionnels. </p><br><p>  Voici une brève description de chaque valeur d' <em>étendue</em> : </p><br><ul><li><p>  <em>scope = 'fonction'</em> </p><br><p>  Il est effectué une fois pour chaque fonction du test.  La partie configuration est exécutée avant chaque test à l'aide du luminaire.  La partie démontage démarre après chaque test à l'aide du luminaire.  Il s'agit de la zone par défaut si le paramètre d'étendue n'est pas spécifié. </p><br></li><li><p>  <em>scope = 'class'</em> </p><br><p>  Il est exécuté une fois pour chaque classe de test, quel que soit le nombre de méthodes de test dans la classe. </p><br></li><li><p>  <em>scope = 'module'</em> </p><br><p>  Il est exécuté une fois pour chaque module, quel que soit le nombre de fonctions ou de méthodes de test ou d'autres appareils utilisés lors de l'utilisation du module. </p><br></li><li><p>  <em>scope = 'session'</em> </p><br><p>  Il est effectué une fois par session.  Toutes les méthodes et fonctions de test qui utilisent des appareils de portée de session utilisent un seul appel de configuration et de démontage. </p><br></li></ul><br><p>  Voici à quoi ressemblent les valeurs de portée en action: </p><br><blockquote>  <strong>ch3 / test_scope.py</strong> </blockquote><br><pre> <code class="plaintext hljs">"""Demo fixture scope.""" import pytest @pytest.fixture(scope='function') def func_scope(): """A function scope fixture.""" @pytest.fixture(scope='module') def mod_scope(): """A module scope fixture.""" @pytest.fixture(scope='session') def sess_scope(): """A session scope fixture.""" @pytest.fixture(scope='class') def class_scope(): """A class scope fixture.""" def test_1(sess_scope, mod_scope, func_scope): """   ,   .""" def test_2(sess_scope, mod_scope, func_scope): """     .""" @pytest.mark.usefixtures('class_scope') class TestSomething(): """Demo class scope fixtures.""" def test_3(self): """Test using a class scope fixture.""" def test_4(self): """Again, multiple tests are more fun."""</code> </pre> <br><p>  Utilisons <code>--setup-show</code> pour démontrer que le nombre d'appels d'installation et de configuration associés à la suppression sont effectués en fonction de la zone: </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch3/ $ pytest --setup-show test_scope.py ============================= test session starts ============================= collected 4 items test_scope.py SETUP S sess_scope SETUP M mod_scope SETUP F func_scope test_scope.py::test_1 (fixtures used: func_scope, mod_scope, sess_scope). TEARDOWN F func_scope SETUP F func_scope test_scope.py::test_2 (fixtures used: func_scope, mod_scope, sess_scope). TEARDOWN F func_scope SETUP C class_scope test_scope.py::TestSomething::()::test_3 (fixtures used: class_scope). test_scope.py::TestSomething::()::test_4 (fixtures used: class_scope). TEARDOWN C class_scope TEARDOWN M mod_scope TEARDOWN S sess_scope ========================== 4 passed in 0.11 seconds ===========================</code> </pre> <br><p>  Vous pouvez maintenant voir non seulement <strong>F</strong> et <strong>S</strong> pour la fonction et la session, mais aussi <strong>C</strong> et <strong>M</strong> pour la classe et le module. </p><br><p>  La portée est définie à l'aide de luminaires.  Je sais que cela est évident dans le code, mais c'est un point important pour vous assurer que vous gémissez complètement. comprendre ").  La portée est définie dans la définition du luminaire, et non au lieu de son appel.  Les fonctions de test qui utilisent des appareils ne contrôlent pas la fréquence (SETUP) et les arrêts de l'appareil (TEARDOWN). </p><br><p>  Les appareils ne peuvent dépendre que d'autres appareils de la même portée ou d'une portée plus étendue.  Ainsi, le dispositif de portée de fonction peut dépendre d'un autre dispositif de portée de fonction (par défaut et est toujours utilisé dans le projet Tâches).  La portée de la fonction fixture peut également dépendre de la classe, du module et des fixtures de la zone de session, mais jamais dans l'ordre inverse. </p><br><h3 id="smena-scope-dlya-tasks-project-fixtures">  Modifier la portée des projets de tâches </h3><br><p>  Compte tenu de cette connaissance de la portée, modifions maintenant la portée de certains appareils du projet Task. </p><br><p>  Jusqu'à présent, nous n'avons eu aucun problème avec le temps de test.  Mais, vous devez admettre qu'il est inutile de créer un répertoire temporaire et une nouvelle connexion à la base de données pour chaque test.  Tant que nous pouvons fournir une base de données vide, lorsque cela est nécessaire, cela devrait suffire. </p><br><p>  Pour utiliser quelque chose comme <code>tasks_db</code> comme étendue de la session, vous devez utiliser <code>tmpdir_factory</code> , car <code>tmpdir</code> est l'étendue de la fonction et <code>tmpdir_factory</code> est l'étendue de la session.  Heureusement, ce n'est qu'une ligne de changement de code (enfin, deux si vous considérez <code>tmpdir-&gt;tmpdir_factory</code> dans la liste des paramètres): </p><br><blockquote>  <strong>ch3 / b / tasks_proj / tests / conftest.py</strong> </blockquote><br><pre> <code class="plaintext hljs">"""Define some fixtures to use in the project.""" import pytest import tasks from tasks import Task @pytest.fixture(scope='session') def tasks_db_session(tmpdir_factory): """Connect to db before tests, disconnect after.""" temp_dir = tmpdir_factory.mktemp('temp') tasks.start_tasks_db(str(temp_dir), 'tiny') yield tasks.stop_tasks_db() @pytest.fixture() def tasks_db(tasks_db_session): """An empty tasks db.""" tasks.delete_all()</code> </pre> <br><p>  Ici, nous avons modifié la <code>tasks_db</code> fonction de la <code>tasks_db_session</code> et nous avons supprimé toutes les entrées pour nous assurer qu'elle est vide.  Puisque nous n'avons pas changé son nom, aucun des appareils ou tests qui l'incluent déjà ne devrait changer. </p><br><p>  Les appareils de données renvoient simplement une valeur, il n'y a donc vraiment aucune raison pour qu'ils fonctionnent tout le temps.  Une fois par séance suffit: </p><br><blockquote>  <strong>ch3 / b / tasks_proj / tests / conftest.py</strong> </blockquote><br><pre> <code class="plaintext hljs"># Reminder of Task constructor interface # Task(summary=None, owner=None, done=False, id=None) # summary is required # owner and done are optional # id is set by database @pytest.fixture(scope='session') def tasks_just_a_few(): """All summaries and owners are unique.""" return ( Task('Write some code', 'Brian', True), Task("Code review Brian's code", 'Katie', False), Task('Fix what Brian did', 'Michelle', False)) @pytest.fixture(scope='session') def tasks_mult_per_owner(): """Several owners with several tasks each.""" return ( Task('Make a cookie', 'Raphael'), Task('Use an emoji', 'Raphael'), Task('Move to Berlin', 'Raphael'), Task('Create', 'Michelle'), Task('Inspire', 'Michelle'), Task('Encourage', 'Michelle'), Task('Do a handstand', 'Daniel'), Task('Write some books', 'Daniel'), Task('Eat ice cream', 'Daniel'))</code> </pre> <br><p>  Voyons maintenant si tous ces changements fonctionneront avec nos tests: </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch3/b/tasks_proj $ pytest ===================== test session starts ====================== collected 55 items tests/func/test_add.py ... tests/func/test_add_variety.py ............................ tests/func/test_add_variety2.py ............ tests/func/test_api_exceptions.py ....... tests/func/test_unique_id.py . tests/unit/test_task.py .... ================== 55 passed in 0.17 seconds ===================</code> </pre> <br><p>  Tout semble être en ordre.  Examinons les appareils pour un seul fichier de test pour voir comment différentes zones fonctionnent selon nos attentes: </p><br><pre> <code class="plaintext hljs">$ pytest --setup-show tests/func/test_add.py ============================= test session starts ============================= platform win32 -- Python 3.6.5, pytest-3.9.3, py-1.7.0, pluggy-0.8.0 rootdir: c:\_BOOKS_\pytest_si\bopytest-code\code\ch3\b\tasks_proj\tests, inifile: pytest.ini collected 3 items tests\func\test_add.py SETUP S tmpdir_factory SETUP S tasks_db_session (fixtures used: tmpdir_factory) SETUP F tasks_db (fixtures used: tasks_db_session) func/test_add.py::test_add_returns_valid_id (fixtures used: tasks_db, tasks_db_session, tmpdir_factory). TEARDOWN F tasks_db SETUP F tasks_db (fixtures used: tasks_db_session) func/test_add.py::test_added_task_has_id_set (fixtures used: tasks_db, tasks_db_session, tmpdir_factory). TEARDOWN F tasks_db SETUP S tasks_just_a_few SETUP F tasks_db (fixtures used: tasks_db_session) SETUP F db_with_3_tasks (fixtures used: tasks_db, tasks_just_a_few) func/test_add.py::test_add_increases_count (fixtures used: db_with_3_tasks, tasks_db, tasks_db_session, tasks_just_a_few, tmpdir_factory). TEARDOWN F db_with_3_tasks TEARDOWN F tasks_db TEARDOWN S tasks_db_session TEARDOWN S tmpdir_factory TEARDOWN S tasks_just_a_few ========================== 3 passed in 0.24 seconds ===========================</code> </pre> <br><p>  Ouais.  . <code>tasks_db_session</code>     ,    <code>task_db</code>        . </p><br><h3 id="specifying-fixtures-with-usefixtures"> Specifying Fixtures with usefixtures </h3><br><p>   ,   ,    ,       .  ,        <code>@pytest.mark.usefixtures('fixture1', 'fixture2')</code> . <em>usefixtures</em>  ,    ,  .          —     .       : </p><br><blockquote> <strong>ch3/test_scope.py</strong> </blockquote><br><pre> <code class="plaintext hljs">@pytest.mark.usefixtures('class_scope') class TestSomething(): """Demo class scope fixtures.""" def test_3(self): """Test using a class scope fixture.""" def test_4(self): """Again, multiple tests are more fun."""</code> </pre> <br><p>  <em>usefixtures</em>    ,         .     ,       ,       . ,   -  <em>usefixtures</em> ,      . </p><br><h2 id="ispolzovanie--autouse-dlya-fixtures-that-always-get-used-kotorye-ispolzuyutsya-nepreryvno">  autouse  Fixtures That Always Get Used (  ) </h2><br><p>        ,  ,    (  <em>usefixtures</em>     ).     <em>autouse=True</em> ,    .     ,       ,              .    : </p><br><blockquote> <strong>ch3/test_autouse.py</strong> </blockquote><br><pre> <code class="plaintext hljs">""" autouse fixtures.""" import pytest import time @pytest.fixture(autouse=True, scope='session') def footer_session_scope(): """    session().""" yield now = time.time() print('--') print('finished : {}'.format(time.strftime('%d %b %X', time.localtime(now)))) print('-----------------') @pytest.fixture(autouse=True) def footer_function_scope(): """     .""" start = time.time() yield stop = time.time() delta = stop - start print('\ntest duration : {:0.3} seconds'.format(delta)) def test_1(): """   .""" time.sleep(1) def test_2(): """    .""" time.sleep(1.23)</code> </pre> <br><p>         ,         .     : </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch3 $ pytest -v -s test_autouse.py ===================== test session starts ====================== collected 2 items test_autouse.py::test_1 PASSED test duration : 1.0 seconds test_autouse.py::test_2 PASSED test duration : 1.24 seconds -- finished : 25 Jul 16:18:27 ----------------- =================== 2 passed in 2.25 seconds ===================</code> </pre> <br><p>  <em>autouse</em>  .    ,  .    ,          . </p><br><p> ,    <em>autouse</em>  ,   ,       <code>tasks_db</code>   .   Tasks  ,     ,  ,      API   .      .      ,     . </p><br><h2 id="pereimenovanie-fixtures">  Fixtures </h2><br><p>  ,        ,  ,      . , <em>pytest</em>       name  <code>@pytest.fixture()</code> : </p><br><blockquote> <strong>ch3/ <code>test_rename_fixture.py</code></strong> </blockquote><br><pre> <code class="plaintext hljs">""" fixture renaming.""" import pytest @pytest.fixture(name='lue') def ultimate_answer_to_life_the_universe_and_everything(): """  .""" return 42 def test_everything(lue): """   .""" assert lue == 42</code> </pre> <br><p>  <em>lue</em>    <code>fixture</code> ,   <code>fixture_with_a_name_much_longer_than_lue</code> .    ,       <code>--setup-show</code> : </p><br><pre> <code class="plaintext hljs">$ pytest --setup-show test_rename_fixture.py ======================== test session starts ======================== collected 1 items test_rename_fixture.py SETUP F lue test_rename_fixture.py::test_everything (fixtures used: lue). TEARDOWN F lue ===================== 1 passed in 0.01 seconds ======================</code> </pre> <br><p>    ,   <em>lue</em> ,    pytest <code>--fixtures</code>       .     ,   ,    ,   : </p><br><pre> <code class="plaintext hljs">$ pytest --fixtures test_rename_fixture.py ======================== test session starts ======================= ... ------------------ fixtures defined from test_rename_fixture ------------------ lue Return ultimate answer. ================= no tests ran in 0.01 seconds =================</code> </pre> <br><p>      —   .  , ,   ,  ,   ,   .    ,    <em>lue</em> .      «Tasks»: </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch3/b/tasks_proj $ pytest --fixtures tests/func/test_add.py ======================== test session starts ======================== ... tmpdir_factory Return a TempdirFactory instance for the test session. tmpdir Return a temporary directory path object which is unique to each test function invocation, created as a sub directory of the base temporary directory. The returned object is a `py.path.local`_ path object. ----------------------- fixtures defined from conftest ------------------------ tasks_db An empty tasks db. tasks_just_a_few All summaries and owners are unique. tasks_mult_per_owner Several owners with several tasks each. db_with_3_tasks Connected db with 3 tasks, all unique. db_with_multi_per_owner Connected db with 9 tasks, 3 owners, all with 3 tasks. tasks_db_session Connect to db before tests, disconnect after. =================== no tests ran in 0.01 seconds ====================</code> </pre> <br><p>  Super!     <em>conftest.py</em> .        <code>tmpdir</code>  <code>tmpdir_factory</code> ,    . </p><br><h2 id="parametrizaciya-fikstur">   </h2><br><p>  [Parametrized Testing] ,  . 42,   .     .  -    ,      ,   : </p><br><blockquote> <code>ch3/b/tasks_proj/tests/func/test_add_variety2.py</code> <br> <br> """Test the tasks.add() API function.""" <br><br> import pytest <br> import tasks <br> from tasks import Task <br><br> tasks_to_try = (Task('sleep', done=True), <br> Task('wake', 'brian'), <br> Task('breathe', 'BRIAN', True), <br> Task('exercise', 'BrIaN', False)) <br><br> task_ids = ['Task({},{},{})'.format(t.summary, t.owner, t.done) <br> for t in tasks_to_try] <br><br> def equivalent(t1, t2): <br> """Check two tasks for equivalence.""" <br> return ((t1.summary == t2.summary) and <br> (t1.owner == t2.owner) and <br> (t1.done == t2.done)) </blockquote><p>  ,   ,      <code>a_task</code> : </p><br><blockquote> <strong>ch3/b/tasks_proj/tests/func/ <code>test_add_variety2.py</code></strong> <br><br> @pytest.fixture(params=tasks_to_try) <br> def a_task(request): <br> """ .""" <br> return request.param <br><br> def test_add_a(tasks_db, a_task): <br> """  a_task ( ids).""" <br> task_id = tasks.add(a_task) <br> t_from_db = tasks.get(task_id) <br> assert equivalent(t_from_db, a_task) </blockquote><p> ,    fixture,    ,    .      .    param,      ,  params  <code>@pytest.fixture(params=tasks_to_try)</code> . </p><br><p>  <code>a_task</code>   —    <code>request.param</code>     ,  .        ,     ,       : </p><br><pre> <code class="plaintext hljs">$ cd /path/to/code/ch3/b/tasks_proj/tests/func $ pytest -v test_add_variety2.py::test_add_a ===================== test session starts ====================== collected 4 items test_add_variety2.py::test_add_a[a_task0] PASSED test_add_variety2.py::test_add_a[a_task1] PASSED test_add_variety2.py::test_add_a[a_task2] PASSED test_add_variety2.py::test_add_a[a_task3] PASSED =================== 4 passed in 0.03 seconds ===================</code> </pre> <br><p>    ,  pytest   ,   ()   .        ,       : </p><br><blockquote> <strong>ch3/b/tasks_proj/tests/func/ <code>test_add_variety2.py</code></strong> <br><br> @pytest.fixture(params=tasks_to_try, ids=task_ids) <br> def b_task(request): <br> """  .""" <br> return request.param <br><br> def test_add_b(tasks_db, b_task): <br> """  b_task,  .""" <br> task_id = tasks.add(b_task) <br> t_from_db = tasks.get(task_id) <br> assert equivalent(t_from_db, b_task) </blockquote><p>      : </p><br><pre> <code class="plaintext hljs">$ pytest -v test_add_variety2.py::test_add_b ===================== test session starts ====================== collected 4 items test_add_variety2.py::test_add_b[Task(sleep,None,True)] PASSED test_add_variety2.py::test_add_b[Task(wake,brian,False)] PASSED test_add_variety2.py::test_add_b[Task(breathe,BRIAN,True)] PASSED test_add_variety2.py::test_add_b[Task(exercise,BrIaN,False)] PASSED =================== 4 passed in 0.04 seconds ===================</code> </pre> <br><p>      <code>ids</code>  ,   ,   .    ,       : </p><br><blockquote> <strong>ch3/b/tasks_proj/tests/func/ <code>test_add_variety2.py</code></strong> <br><br> def id_func(fixture_value): <br> """   .""" <br> t = fixture_value <br> return 'Task({},{},{})'.format(t.summary, t.owner, t.done) <br><br> @pytest.fixture(params=tasks_to_try, ids=id_func) <br> def c_task(request): <br> """  (id_func)   .""" <br> return request.param <br><br> def test_add_c(tasks_db, c_task): <br> """    .""" <br> task_id = tasks.add(c_task) <br> t_from_db = tasks.get(task_id) <br> assert equivalent(t_from_db, c_task) </blockquote><p>         .       Task, <code>id_func()</code>     <em>Task</em> ,       <em>namedtuple</em>      <em>Task</em>      <em>Task</em>  .   ,      ,   : </p><br><pre> <code class="plaintext hljs">$ pytest -v test_add_variety2.py::test_add_c ===================== test session starts ====================== collected 4 items test_add_variety2.py::test_add_c[Task(sleep,None,True)] PASSED test_add_variety2.py::test_add_c[Task(wake,brian,False)] PASSED test_add_variety2.py::test_add_c[Task(breathe,BRIAN,True)] PASSED test_add_variety2.py::test_add_c[Task(exercise,BrIaN,False)] PASSED =================== 4 passed in 0.04 seconds ===================</code> </pre> <br><p>          .       ,   ,    .    , ! </p><br><h3 id="parametrizaciya-fixtures-v-tasks-project">  Fixtures  Tasks Project </h3><br><p>   ,         Tasks.      <em>TinyDB</em>   .   ,        .   ,   ,   ,   ,     <em>TinyDB</em> ,    <em>MongoDB</em> . </p><br><p>  ( ),     ,    <code>start_tasks_db()</code>   <code>tasks_db_session</code> : </p><br><blockquote> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ch3/b/tasks_proj/tests/conftest.py</a> <br><br> """      .""" <br><br> import pytest <br> import tasks <br> from tasks import Task <br><br> @pytest.fixture(scope='session') <br> def tasks_db_session(tmpdir_factory): <br> """    ,  .""" <br> temp_dir = tmpdir_factory.mktemp('temp') <br> tasks.start_tasks_db(str(temp_dir), 'tiny') <br> yield <br> tasks.stop_tasks_db() <br><br> @pytest.fixture() <br> def tasks_db(tasks_db_session): <br> """   tasks.""" <br> tasks.delete_all() </blockquote><p>  <code>db_type</code>   <code>start_tasks_db()</code>   .      ,        : </p><br><blockquote> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>tasks_proj/src/tasks/api.py</strong></a> </blockquote><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">start_tasks_db</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(db_path, db_type)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-comment"><span class="hljs-comment"># type: (str, str) -None """  API  .""" if not isinstance(db_path, string_types): raise TypeError('db_path must be a string') global _tasksdb if db_type == 'tiny': import tasks.tasksdb_tinydb _tasksdb = tasks.tasksdb_tinydb.start_tasks_db(db_path) elif db_type == 'mongo': import tasks.tasksdb_pymongo _tasksdb = tasks.tasksdb_pymongo.start_tasks_db(db_path) else: raise ValueError("db_type   'tiny'  'mongo'")</span></span></code> </pre> <br><p>   MongoDB,       db_type  mongo.  : </p><br><blockquote> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><strong>ch3/c/tasks_proj/tests/conftest.py</strong></a> </blockquote><br><pre> <code class="python hljs"> <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> pytest <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> tasks <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> tasks <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Task <span class="hljs-comment"><span class="hljs-comment"># @pytest.fixture(scope='session', params=['tiny',]) @pytest.fixture(scope='session', params=['tiny', 'mongo']) def tasks_db_session(tmpdir_factory, request): """Connect to db before tests, disconnect after.""" temp_dir = tmpdir_factory.mktemp('temp') tasks.start_tasks_db(str(temp_dir), request.param) yield # this is where the testing happens tasks.stop_tasks_db() @pytest.fixture() def tasks_db(tasks_db_session): """An empty tasks db.""" tasks.delete_all()</span></span></code> </pre> <br><p>    params=['tiny',' mongo']  -.   <code>request</code>    <em>temp_db</em>   <em>db_type</em>  <code>request.param</code>  ,    "tiny"  "mongo". </p><br><p>   <code>--verbose</code>   <code>-v</code>    pytest     , pytest        .      ,   . </p><br><hr><br><p>  <strong>Installation de MongoDB</strong> </p><br><hr><br><p>    MongoDB, ,   MongoDB  <em>pymongo</em> .       MongoDB,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">https://www.mongodb.com/download-center</a> . pymongo   pip— <em>pip install pymongo</em> .   MongoDB       ;           <strong> 7</strong> . </p><br><hr><br><p>     : </p><br><pre> <code class="plaintext hljs"> $ cd /path/to/code/ch3/c/tasks_proj $ pip install pymongo $ pytest -v --tb=no ===================== test session starts ====================== collected 92 items test_add.py::test_add_returns_valid_id[tiny] PASSED test_add.py::test_added_task_has_id_set[tiny] PASSED test_add.py::test_add_increases_count[tiny] PASSED test_add_variety.py::test_add_1[tiny] PASSED test_add_variety.py::test_add_2[tiny-task0] PASSED test_add_variety.py::test_add_2[tiny-task1] PASSED ... test_add.py::test_add_returns_valid_id[mongo] FAILED test_add.py::test_added_task_has_id_set[mongo] FAILED test_add.py::test_add_increases_count[mongo] PASSED test_add_variety.py::test_add_1[mongo] FAILED test_add_variety.py::test_add_2[mongo-task0] FAILED ... ============= 42 failed, 50 passed in 4.94 seconds =============</code> </pre> <br><p>  Hm. . ,     ,     -   Mongo.  ,     pdb:   ,  . 125.        TinyDB. </p><br><h2 id="uprazhneniya">  Exercices </h2><br><ol><li>    <code>test_fixtures.py</code> . <br> 2.  fixtures—functions     <code>@pytest.fixture()</code> ,     . ,   ,  . </li><li>         ,   . </li><li>   ,       . </li><li>  <code>pytest --setup-show test_fixtures.py</code> .      ? </li><li>  <code>scope= 'module'</code>     4. </li><li>   <code>pytest --setup-show test_fixtures.py</code> .  Qu'est-ce qui a changé? </li><li>     6  <code>return &lt;data&gt;</code>  <code>yield &lt;data&gt;</code> . </li><li>       <code>yield</code> . </li><li>  <code>pytest -s -v test_fixtures.py</code> .    ? </li></ol><br><h2 id="chto-dalshe">  Et ensuite </h2><br><p>  pytest fixture  ,   ,   <em>building blocks</em> ,    <em>setup</em>  <em>teardown</em> ,        (,  Mongo  TinyDB).    ,      ,         . </p><br><p>       pytest,   ,    (builtin)  tmpdir  tmpdir_factory.        (builtin) . </p><br><p><img src="https://habrastorage.org/webt/jl/jn/bb/jljnbbjr-ejh473xy_eccsmknpk.png">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Retour</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Suivant</a> <img src="https://habrastorage.org/webt/rw/dy/-g/rwdy-grsvbpcetjttrmecdkxtlk.png"></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr448786/">https://habr.com/ru/post/fr448786/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr448776/index.html">RxVMS - Une architecture pratique pour les applications Flutter</a></li>
<li><a href="../fr448778/index.html">Présentation du débogage de voyage dans le temps pour Visual Studio Enterprise 2019</a></li>
<li><a href="../fr448780/index.html">Ce qui donne des logiciels pour recruter en argent</a></li>
<li><a href="../fr448782/index.html">Test Python avec pytest. Premiers pas avec pytest, Chapitre 1</a></li>
<li><a href="../fr448784/index.html">Nouvelles fonctionnalités pour les auteurs d'extensions dans Visual Studio 2019 version 16.1</a></li>
<li><a href="../fr448790/index.html">SpaceVIL - Framework GUI multiplateforme pour le développement sur .Net Core, .Net Standard et JVM</a></li>
<li><a href="../fr448792/index.html">Test Python avec pytest. Luminaires intégrés, Chapitre 4</a></li>
<li><a href="../fr448794/index.html">Test Python avec pytest. Plugins CHAPITRE 5</a></li>
<li><a href="../fr448796/index.html">Test Python avec pytest. Configuration, CHAPITRE 6</a></li>
<li><a href="../fr448798/index.html">Test Python avec pytest. Utilisation de pytest avec d'autres outils, CHAPITRE 7</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>