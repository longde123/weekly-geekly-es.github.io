<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💅🏻 💘 🤷🏼 Essayer de créer un analogue ASH pour PostgreSQL 🍊 👩🏾‍🔧 🏇</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Énoncé du problème 
 Pour optimiser les requêtes PostgreSQL, cela nécessite vraiment la capacité d'analyser l'historique de l'activité, en particulier...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Essayer de créer un analogue ASH pour PostgreSQL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467181/"><h1>  Énoncé du problème </h1><br>  Pour optimiser les requêtes PostgreSQL, cela nécessite vraiment la capacité d'analyser l'historique de l'activité, en particulier - les attentes, les verrous, les statistiques de table. <br><br><h1>  Options disponibles </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Outil d'analyse de charge historique ou "AWR pour Postgres"</a> : une solution très intéressante, mais il n'y a pas d'historique de pg_stat_activity et pg_locks. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Extension Pgsentinel</a> : <br>  " <i>Toutes les informations accumulées sont stockées uniquement dans la RAM, et la quantité de mémoire consommée est régulée par le nombre de derniers enregistrements stockés.</i> <i><br><br></i>  <i>Le champ queryid est ajouté - le même queryid de l'extension pg_stat_statements (une installation préliminaire est requise).</i>  " <br><br>  Cela aiderait certainement beaucoup, mais la nuisance même est le premier paragraphe, " <b>Toutes les informations accumulées sont stockées uniquement dans la RAM</b> ", c'est-à-dire  nous avons un impact sur la base cible.  De plus, il n'y a pas d'historique de verrouillage ni de statistiques de table.  C'est-à-dire  D'une manière générale, la solution est incomplète: « <b>Il n'y a pas encore de package prêt à installer.</b>  <b>Il est proposé de télécharger les sources et de construire la bibliothèque vous-même.</b>  <b>Tout d'abord, vous devez installer le package «devel» pour votre serveur et écrire le chemin d'accès à pg_config dans la variable PATH.</b>  " <br><br>  En général - beaucoup de bruit, et dans le cas de bases de données de production sérieuses, il n'y aura peut-être aucun moyen de faire quelque chose avec le serveur.  Encore une fois, vous devez trouver quelque chose qui vous appartient. <br><br><blockquote>  Avertissement <br>  En raison de la nouveauté du sujet et de l'inachèvement de la période de test, l'article est principalement à titre indicatif, plutôt comme un ensemble de résumés et de résultats intermédiaires. <br>  Un matériel plus détaillé sera préparé ultérieurement, en plusieurs parties. </blockquote><br><a name="habracut"></a><br><h1>  Décrire les exigences de la solution </h1><br>  Il est nécessaire de développer un outil pour stocker: <br><br>  <b>Pg_stat_activity afficher l'historique</b> <br>  <b>Historique des verrous de session à l'aide de la vue pg_locks</b> <br><br>  <b>La décision requise est de</b> minimiser l'impact sur la base de données cible. <br><br>  <b>L'idée générale</b> est que l'agent de collecte de données n'est pas lancé dans la base de données cible, mais dans la base de données de surveillance en tant que service systemd.  Oui, certaines pertes de données sont possibles, mais ce n'est pas critique pour les rapports, mais il n'y a aucun impact sur la base de données cible à partir de la mémoire et de l'espace disque.  Et dans le cas de l'utilisation d'un pool de connexions, l'impact sur les processus utilisateur est minime. <br><br><h1>  Étapes de mise en œuvre </h1><br><h1>  1. Tables de service </h1><br>  Pour le stockage des tables, un schéma distinct est utilisé afin de ne pas compliquer l'analyse des principales tables utilisées. <br><br><pre><code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SCHEMA</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> activity_hist ; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SCHEMA</span></span> activity_hist <span class="hljs-keyword"><span class="hljs-keyword">AUTHORIZATION</span></span> monitor ;</code> </pre> <br>  <b>Important: le schéma n'est pas créé dans la base de données cible, mais dans la base de données de surveillance.</b> <br><h2>  Pg_stat_activity afficher l'historique </h2><br>  Utilisez le tableau pour stocker les instantanés actuels de la vue pg_stat_activity <br><br><div class="spoiler">  <b class="spoiler_title">activity_hist.history_pg_stat_activity:</b> <div class="spoiler_text"><pre> <code class="pgsql hljs"><span class="hljs-comment"><span class="hljs-comment">--ACTIVITY_HIST.HISTORY_PG_STAT_ACTIVITY DROP TABLE IF EXISTS activity_hist.history_pg_stat_activity; CREATE TABLE activity_hist.history_pg_stat_activity ( timepoint timestamp without time zone , datid oid , datname name , pid integer, usesysid oid , usename name , application_name text , client_addr inet , client_hostname text , client_port integer, backend_start timestamp with time zone , xact_start timestamp with time zone , query_start timestamp with time zone , state_change timestamp with time zone , wait_event_type text , wait_event text , state text , backend_xid xid , backend_xmin xid , query text , backend_type text , queryid bigint );</span></span></code> </pre> </div></div><br>  Pour accélérer l'insertion - aucun index ni restriction. <br><br>  Pour stocker directement l'historique, une table partitionnée est utilisée: <br><br><div class="spoiler">  <b class="spoiler_title">activity_hist.archive_pg_stat_activity:</b> <div class="spoiler_text"><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> activity_hist.archive_pg_stat_activity; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> activity_hist.archive_pg_stat_activity ( timepoint <span class="hljs-type"><span class="hljs-type">timestamp</span></span> <span class="hljs-type"><span class="hljs-type">without time zone</span></span> , datid <span class="hljs-type"><span class="hljs-type">oid</span></span> , datname <span class="hljs-type"><span class="hljs-type">name</span></span> , pid <span class="hljs-type"><span class="hljs-type">integer</span></span>, usesysid <span class="hljs-type"><span class="hljs-type">oid</span></span> , usename <span class="hljs-type"><span class="hljs-type">name</span></span> , application_name <span class="hljs-type"><span class="hljs-type">text</span></span> , client_addr <span class="hljs-type"><span class="hljs-type">inet</span></span> , client_hostname <span class="hljs-type"><span class="hljs-type">text</span></span> , client_port <span class="hljs-type"><span class="hljs-type">integer</span></span>, backend_start <span class="hljs-type"><span class="hljs-type">timestamp</span></span> <span class="hljs-type"><span class="hljs-type">with time zone</span></span> , xact_start <span class="hljs-type"><span class="hljs-type">timestamp</span></span> <span class="hljs-type"><span class="hljs-type">with time zone</span></span> , query_start <span class="hljs-type"><span class="hljs-type">timestamp</span></span> <span class="hljs-type"><span class="hljs-type">with time zone</span></span> , state_change <span class="hljs-type"><span class="hljs-type">timestamp</span></span> <span class="hljs-type"><span class="hljs-type">with time zone</span></span> , wait_event_type <span class="hljs-type"><span class="hljs-type">text</span></span> , wait_event <span class="hljs-type"><span class="hljs-type">text</span></span> , state <span class="hljs-type"><span class="hljs-type">text</span></span> , backend_xid xid , backend_xmin xid , query <span class="hljs-type"><span class="hljs-type">text</span></span> , backend_type <span class="hljs-type"><span class="hljs-type">text</span></span> , queryid <span class="hljs-type"><span class="hljs-type">bigint</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">PARTITION BY RANGE</span></span> (timepoint);</code> </pre> </div></div><br>  Comme dans ce cas, il n'y a aucune exigence de vitesse d'insertion, certains index ont été créés pour accélérer la génération de rapports. <br><br><h2>  Historique de verrouillage de session </h2><br>  Pour stocker les instantanés de verrouillage de session en cours, utilisez le tableau: <br><br><div class="spoiler">  <b class="spoiler_title">activity_hist.history_locking:</b> <div class="spoiler_text"><pre> <code class="pgsql hljs"><span class="hljs-comment"><span class="hljs-comment">--ACTIVITY_HIST.HISTORY_LOCKING DROP TABLE IF EXISTS activity_hist.history_locking; CREATE TABLE activity_hist.history_locking ( timepoint timestamp without time zone , locktype text , relation oid , mode text , tid xid , vtid text , pid integer , blocking_pids integer[] , granted boolean );</span></span></code> </pre> </div></div><br>  Aussi, pour accélérer l'insertion - pas d'index ni de restrictions. <br><br>  Pour stocker directement l'historique, une table partitionnée est utilisée: <br><br><div class="spoiler">  <b class="spoiler_title">activity_hist.archive_locking:</b> <div class="spoiler_text"><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> activity_hist.archive_locking; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> activity_hist.archive_locking ( timepoint <span class="hljs-type"><span class="hljs-type">timestamp</span></span> <span class="hljs-type"><span class="hljs-type">without time zone</span></span> , locktype <span class="hljs-type"><span class="hljs-type">text</span></span> , relation <span class="hljs-type"><span class="hljs-type">oid</span></span> , mode <span class="hljs-type"><span class="hljs-type">text</span></span> , tid xid , vtid <span class="hljs-type"><span class="hljs-type">text</span></span> , pid <span class="hljs-type"><span class="hljs-type">integer</span></span> , blocking_pids <span class="hljs-type"><span class="hljs-type">integer</span></span>[] , granted <span class="hljs-type"><span class="hljs-type">boolean</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">PARTITION BY RANGE</span></span> (timepoint);</code> </pre> </div></div><br>  Comme dans ce cas, il n'y a aucune exigence de vitesse d'insertion, certains index ont été créés pour accélérer la génération de rapports. <br><br><h1>  2. Remplir l'historique actuel </h1><br>  Pour capturer directement des instantanés d'une vue, un script bash est utilisé qui exécute la fonction plpgsql. <br><br><div class="spoiler">  <b class="spoiler_title">get_current_activity.sh</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash ######################################################### #get_current_activity.sh ERROR_FILE='/home/demon/get_current_activity'$(date +%Y%m%d-)'T'$(date +%H)$(date +%M)$(date +%S) host=$1 s_name=$2 s_pass=$3 psql -A -t -q -v ON_ERROR_STOP=1 -c "SELECT activity_hist.get_current_activity( '$host' , '$s_name' , '$s_pass' )" &gt;/dev/null 2&gt;$ERROR_FILE line_count=`cat $ERROR_FILE | wc -l` if [[ $line_count != '0' ]]; then rm -f /home/demon/*.err &gt;/dev/null 2&gt;/dev/null cp $ERROR_FILE $ERROR_FILE'.err' &gt;/dev/null 2&gt;/dev/null fi rm $ERROR_FILE &gt;/dev/null 2&gt;/dev/null exit 0</span></span></code> </pre> </div></div><br>  <b>La</b> fonction <b>plpgsql dblink</b> accède aux vues de la base de données cible et insère des lignes dans les tables de service de la base de données de surveillance. <br><br><div class="spoiler">  <b class="spoiler_title">get_current_activity.sql</b> <div class="spoiler_text"><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> activity_hist.get_current_activity( current_host <span class="hljs-type"><span class="hljs-type">text</span></span> , current_s_name <span class="hljs-type"><span class="hljs-type">text</span></span> , current_s_pass <span class="hljs-type"><span class="hljs-type">text</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-type"><span class="hljs-type">BOOLEAN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="ruby"><span class="ruby"> DECLARE database_rec record; dblink_str text ; </span><span class="hljs-keyword"><span class="ruby"><span class="hljs-keyword">BEGIN</span></span></span><span class="ruby"> EXECUTE </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">'SELECT dblink_connect('</span></span></span><span class="hljs-string"><span class="ruby"><span class="hljs-string">'LINK1'</span></span></span><span class="hljs-string"><span class="ruby"><span class="hljs-string">','</span></span></span><span class="hljs-string"><span class="ruby"><span class="hljs-string">'host='</span></span></span><span class="hljs-params"><span class="ruby"><span class="hljs-params">||</span></span></span><span class="ruby">current_host</span><span class="hljs-params"><span class="ruby"><span class="hljs-params">||</span></span></span><span class="hljs-string"><span class="ruby"><span class="hljs-string">' port=5432 dbname=postgres'</span></span></span><span class="hljs-params"><span class="ruby"><span class="hljs-params">||</span></span></span><span class="ruby"> </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">' user='</span></span></span><span class="hljs-params"><span class="ruby"><span class="hljs-params">||</span></span></span><span class="ruby">current_s_name</span><span class="hljs-params"><span class="ruby"><span class="hljs-params">||</span></span></span><span class="hljs-string"><span class="ruby"><span class="hljs-string">' password='</span></span></span><span class="hljs-params"><span class="ruby"><span class="hljs-params">||</span></span></span><span class="ruby">current_s_pass</span><span class="hljs-params"><span class="ruby"><span class="hljs-params">||</span></span></span><span class="ruby"> </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">' '</span></span></span><span class="hljs-string"><span class="ruby"><span class="hljs-string">')'</span></span></span><span class="ruby">; -------------------------------------------------------------------- --GET pg_stat_activity stats INSERT INTO activity_hist.history_pg_stat_activity ( SELECT * FROM dblink(</span><span class="hljs-string"><span class="ruby"><span class="hljs-string">'LINK1'</span></span></span><span class="ruby">, </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">'SELECT now() , datid , datname , pid , usesysid , usename , application_name , client_addr , client_hostname , client_port , backend_start , xact_start , query_start , state_change , wait_event_type , wait_event , state , backend_xid , backend_xmin , query , backend_type FROM pg_stat_activity '</span></span></span><span class="ruby">) AS t ( timepoint timestamp without time zone , datid oid , datname name , pid integer, usesysid oid , usename name , application_name text , client_addr inet , client_hostname text , client_port integer, backend_start timestamp with time zone , xact_start timestamp with time zone , query_start timestamp with time zone , state_change timestamp with time zone , wait_event_type text , wait_event text , state text , backend_xid xid , backend_xmin xid , query text , backend_type text ) ); --------------------------------------- --ACTIVITY_HIST.HISTORY_LOCKING INSERT INTO activity_hist.history_locking ( SELECT * FROM dblink(</span><span class="hljs-string"><span class="ruby"><span class="hljs-string">'LINK1'</span></span></span><span class="ruby">, </span><span class="hljs-string"><span class="ruby"><span class="hljs-string">'SELECT now() , lock.locktype, lock.relation, lock.mode, lock.transactionid as tid, lock.virtualtransaction as vtid, lock.pid, pg_blocking_pids(lock.pid), lock.granted FROM pg_catalog.pg_locks lock LEFT JOIN pg_catalog.pg_database db ON db.oid = lock.database WHERE NOT lock.pid = pg_backend_pid() '</span></span></span><span class="ruby">) AS t ( timepoint timestamp without time zone , locktype text , relation oid , mode text , tid xid , vtid text , pid integer , blocking_pids integer[] , granted boolean ) ); PERFORM dblink_disconnect(</span><span class="hljs-string"><span class="ruby"><span class="hljs-string">'LINK1'</span></span></span><span class="ruby">); RETURN TRUE ; </span><span class="hljs-keyword"><span class="ruby"><span class="hljs-keyword">END</span></span></span><span class="ruby"> $$</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> plpgsql;</code> </pre> </div></div><br>  Pour collecter des instantanés de la vue, utilisez le service systemd et deux scripts: <br><br><div class="spoiler">  <b class="spoiler_title">pg_current_activity.service</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># /etc/systemd/system/pg_current_activity.service [Unit] Description=Collect history of pg_stat_activity , pg_locks Wants=pg_current_activity.timer [Service] Type=forking StartLimitIntervalSec=0 ExecStart=/home/postgres/pgutils/demon/get_current_activity.sh XXXX postgres postgres [Install] WantedBy=multi-user.target</span></span></code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">pg_current_activity.timer</b> <div class="spoiler_text"><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># /etc/systemd/system/pg_current_activity.timer [Unit] Description=Run pg_current_activity.sh every 1 second Requires=pg_current_activity.service [Timer] Unit=pg_current_activity.service OnCalendar=*:*:0/1 AccuracySec=1 [Install] WantedBy=timers.target</span></span></code> </pre> </div></div><br><br>  Attribuez des droits aux scripts: <br>  # chmod 755 pg_current_activity.timer <br>  # chmod 755 pg_current_activity.service <br><br>  Nous commençons le service: <br>  # systemctl daemon-reload <br>  # systemctl start pg_current_activity.service <br><br>  Ainsi, l'histoire des performances est collectée sous forme de prises de vue toutes les secondes.  Bien sûr, si tout est laissé tel quel, les tables augmenteront très rapidement de taille et un travail plus ou moins productif deviendra impossible. <br><br>  Il est nécessaire d'organiser l'archivage des données. <br><br><h1>  3.Archive histoire </h1><br>  Pour l'archivage, des tables partitionnées * sont utilisées. <br><br>  De nouvelles sections sont créées toutes les heures, tandis que les anciennes données des tables history * sont supprimées, de sorte que la taille des tables history * ne change pas beaucoup et que la vitesse d'insertion ne se dégrade pas avec le temps. <br><br>  La création de nouvelles sections est effectuée par la fonction plpgsql activity_hist.archive_current_activity.  L'algorithme de travail est très simple (en utilisant l'exemple de section pour la table archive_pg_stat_activity). <br><br><div class="spoiler">  <b class="spoiler_title">Créez et remplissez une nouvelle section</b> <div class="spoiler_text"><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> format( <span class="hljs-string"><span class="hljs-string">'CREATE TABLE '</span></span> || partition_name || <span class="hljs-string"><span class="hljs-string">' PARTITION OF activity_hist.archive_pg_stat_activity FOR VALUES FROM ( %L ) TO ( %L ) '</span></span> , to_char(date_trunc(<span class="hljs-string"><span class="hljs-string">'year'</span></span>, partition_min_range ),<span class="hljs-string"><span class="hljs-string">'YYYY'</span></span>)||<span class="hljs-string"><span class="hljs-string">'-'</span></span>|| to_char(date_trunc(<span class="hljs-string"><span class="hljs-string">'month'</span></span>, partition_min_range ),<span class="hljs-string"><span class="hljs-string">'MM'</span></span>)||<span class="hljs-string"><span class="hljs-string">'-'</span></span>|| to_char(date_trunc(<span class="hljs-string"><span class="hljs-string">'day'</span></span>, partition_min_range ),<span class="hljs-string"><span class="hljs-string">'DD'</span></span>)||<span class="hljs-string"><span class="hljs-string">' '</span></span>|| to_char(date_trunc(<span class="hljs-string"><span class="hljs-string">'hour'</span></span>, partition_min_range ),<span class="hljs-string"><span class="hljs-string">'HH24'</span></span>)||<span class="hljs-string"><span class="hljs-string">':00'</span></span>, to_char(date_trunc(<span class="hljs-string"><span class="hljs-string">'year'</span></span>, partition_max_range ),<span class="hljs-string"><span class="hljs-string">'YYYY'</span></span>)||<span class="hljs-string"><span class="hljs-string">'-'</span></span>|| to_char(date_trunc(<span class="hljs-string"><span class="hljs-string">'month'</span></span>, partition_max_range ),<span class="hljs-string"><span class="hljs-string">'MM'</span></span>)||<span class="hljs-string"><span class="hljs-string">'-'</span></span>|| to_char(date_trunc(<span class="hljs-string"><span class="hljs-string">'day'</span></span>, partition_max_range ),<span class="hljs-string"><span class="hljs-string">'DD'</span></span>)||<span class="hljs-string"><span class="hljs-string">' '</span></span>|| to_char(date_trunc(<span class="hljs-string"><span class="hljs-string">'hour'</span></span>, partition_max_range ),<span class="hljs-string"><span class="hljs-string">'HH24'</span></span>)||<span class="hljs-string"><span class="hljs-string">':00'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> activity_hist.archive_pg_stat_activity ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> activity_hist.history_pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> timepoint <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> partition_min_range <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> partition_max_range );</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Créer des index</b> <div class="spoiler_text"><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> format ( <span class="hljs-string"><span class="hljs-string">'CREATE INDEX '</span></span>||index_name|| <span class="hljs-string"><span class="hljs-string">' ON '</span></span>||partition_name||<span class="hljs-string"><span class="hljs-string">' ( wait_event_type , backend_type , timepoint )'</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> format (<span class="hljs-string"><span class="hljs-string">'CREATE INDEX '</span></span>||index_name|| <span class="hljs-string"><span class="hljs-string">' ON '</span></span>||partition_name||<span class="hljs-string"><span class="hljs-string">' ( wait_event_type , backend_type , timepoint , queryid )'</span></span> );</code> </pre> </div></div><br><div class="spoiler">  <b class="spoiler_title">Supprimer les anciennes données de la table history_pg_stat_activity</b> <div class="spoiler_text"><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> activity_hist.history_pg_stat_activity <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> timepoint &lt; partition_max_range;</code> </pre> </div></div><br>  Bien sûr, périodiquement, les anciennes sections sont supprimées car inutiles. <br><br><h1>  Rapports de base </h1><br>  En fait, pourquoi tout cela se fait-il.  Pour recevoir des rapports à très distance, rappelant à peu près Oracle AWR. <br><blockquote>  Il est important d'ajouter que pour recevoir des rapports, il est nécessaire de créer une relation entre les vues pg_stat_activity et pg_stat_statements.  Les tables sont liées en ajoutant la colonne 'queryid' aux tables 'history_pg_stat_activity', 'archive_pg_stat_activity'.  La façon d'ajouter une valeur de colonne dépasse le cadre de cet article et est décrite ici - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pg_stat_statements + pg_stat_activity + loq_query = pg_ash?</a>  . </blockquote><h2>  TEMPS TOTAL DU CPU POUR LES DEMANDES </h2><br><div class="spoiler">  <b class="spoiler_title">Demande:</b> <div class="spoiler_text"><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> hist <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> aa.query ,aa.queryid , count(*) * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 second'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> duration <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> activity_hist.archive_pg_stat_activity aa <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> timepoint <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> pg_stat_history_begin+(current_hour_diff * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 hour'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pg_stat_history_end+(current_hour_diff * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 hour'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> backend_type = <span class="hljs-string"><span class="hljs-string">'client backend'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> datname != <span class="hljs-string"><span class="hljs-string">'postgres'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ( aa.wait_event_type <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> ) ANDaa.state = <span class="hljs-string"><span class="hljs-string">'active'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> aa.wait_event_type , aa.wait_event , aa.query ,aa.queryid <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ha.query ,ha.queryid, count(*) * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 second'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> duration <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> activity_hist.history_pg_stat_activity_for_reports ha <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> timepoint <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> pg_stat_history_begin+(current_hour_diff * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 hour'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pg_stat_history_end+(current_hour_diff * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 hour'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> backend_type = <span class="hljs-string"><span class="hljs-string">'client backend'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> datname != <span class="hljs-string"><span class="hljs-string">'postgres'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ( ha.wait_event_type <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> )<span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ha.state = <span class="hljs-string"><span class="hljs-string">'active'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> ha.wait_event_type , ha.wait_event , ha.query ,ha.queryid ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> query , queryid , SUM( duration ) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> duration <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> hist <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> query , queryid <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span></code> intervalle ' <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> hist <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> aa.query ,aa.queryid , count(*) * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 second'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> duration <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> activity_hist.archive_pg_stat_activity aa <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> timepoint <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> pg_stat_history_begin+(current_hour_diff * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 hour'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pg_stat_history_end+(current_hour_diff * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 hour'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> backend_type = <span class="hljs-string"><span class="hljs-string">'client backend'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> datname != <span class="hljs-string"><span class="hljs-string">'postgres'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ( aa.wait_event_type <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> ) ANDaa.state = <span class="hljs-string"><span class="hljs-string">'active'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> aa.wait_event_type , aa.wait_event , aa.query ,aa.queryid <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ha.query ,ha.queryid, count(*) * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 second'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> duration <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> activity_hist.history_pg_stat_activity_for_reports ha <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> timepoint <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> pg_stat_history_begin+(current_hour_diff * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 hour'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pg_stat_history_end+(current_hour_diff * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 hour'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> backend_type = <span class="hljs-string"><span class="hljs-string">'client backend'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> datname != <span class="hljs-string"><span class="hljs-string">'postgres'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ( ha.wait_event_type <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> )<span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ha.state = <span class="hljs-string"><span class="hljs-string">'active'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> ha.wait_event_type , ha.wait_event , ha.query ,ha.queryid ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> query , queryid , SUM( duration ) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> duration <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> hist <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> query , queryid <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span></code> * intervalle' <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> hist <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> aa.query ,aa.queryid , count(*) * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 second'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> duration <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> activity_hist.archive_pg_stat_activity aa <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> timepoint <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> pg_stat_history_begin+(current_hour_diff * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 hour'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pg_stat_history_end+(current_hour_diff * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 hour'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> backend_type = <span class="hljs-string"><span class="hljs-string">'client backend'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> datname != <span class="hljs-string"><span class="hljs-string">'postgres'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ( aa.wait_event_type <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> ) ANDaa.state = <span class="hljs-string"><span class="hljs-string">'active'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> aa.wait_event_type , aa.wait_event , aa.query ,aa.queryid <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ha.query ,ha.queryid, count(*) * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 second'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> duration <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> activity_hist.history_pg_stat_activity_for_reports ha <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> timepoint <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> pg_stat_history_begin+(current_hour_diff * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 hour'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pg_stat_history_end+(current_hour_diff * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 hour'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> backend_type = <span class="hljs-string"><span class="hljs-string">'client backend'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> datname != <span class="hljs-string"><span class="hljs-string">'postgres'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ( ha.wait_event_type <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> )<span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ha.state = <span class="hljs-string"><span class="hljs-string">'active'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> ha.wait_event_type , ha.wait_event , ha.query ,ha.queryid ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> query , queryid , SUM( duration ) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> duration <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> hist <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> query , queryid <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span></code> backend' ET datname! = 'Postgres' ET (aa.wait_event_type IS NULL) = ANDaa.state <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> hist <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> aa.query ,aa.queryid , count(*) * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 second'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> duration <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> activity_hist.archive_pg_stat_activity aa <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> timepoint <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> pg_stat_history_begin+(current_hour_diff * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 hour'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pg_stat_history_end+(current_hour_diff * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 hour'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> backend_type = <span class="hljs-string"><span class="hljs-string">'client backend'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> datname != <span class="hljs-string"><span class="hljs-string">'postgres'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ( aa.wait_event_type <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> ) ANDaa.state = <span class="hljs-string"><span class="hljs-string">'active'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> aa.wait_event_type , aa.wait_event , aa.query ,aa.queryid <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ha.query ,ha.queryid, count(*) * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 second'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> duration <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> activity_hist.history_pg_stat_activity_for_reports ha <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> timepoint <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> pg_stat_history_begin+(current_hour_diff * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 hour'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pg_stat_history_end+(current_hour_diff * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 hour'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> backend_type = <span class="hljs-string"><span class="hljs-string">'client backend'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> datname != <span class="hljs-string"><span class="hljs-string">'postgres'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ( ha.wait_event_type <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> )<span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ha.state = <span class="hljs-string"><span class="hljs-string">'active'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> ha.wait_event_type , ha.wait_event , ha.query ,ha.queryid ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> query , queryid , SUM( duration ) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> duration <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> hist <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> query , queryid <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span></code> </pre> </div></div><br>  Un exemple: <br><pre> <code class="plaintext hljs">------------------------------------------------------------------- | TOTAL CPU TIME FOR QUERIES : 07:47:36 +----+----------------------------------------+-------------------- | #| queryid| duration +----+----------------------------------------+-------------------- | 1| 389015618226997618| 04:28:58 | 2| | 01:07:29 | 3| 1237430309438971376| 00:59:38 | 4| 4710212362688288619| 00:50:48 | 5| 28942442626229688| 00:15:50 | 6| 9150846928388977274| 00:04:46 | 7| -6572922443698419129| 00:00:06 | 8| | 00:00:01 +----+----------------------------------------+--------------------</code> </pre><br><br><h2>  TEMPS D'ATTENTE TOTAL POUR LES DEMANDES </h2><br><div class="spoiler">  <b class="spoiler_title">Demande:</b> <div class="spoiler_text"><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> hist <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> aa.query ,aa.queryid , count(*) * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 second'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> duration <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> activity_hist.archive_pg_stat_activity aa <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> timepoint <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> pg_stat_history_begin+(current_hour_diff * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 hour'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pg_stat_history_end+(current_hour_diff * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 hour'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> backend_type = <span class="hljs-string"><span class="hljs-string">'client backend'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> datname != <span class="hljs-string"><span class="hljs-string">'postgres'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ( aa.wait_event_type <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> aa.wait_event_type , aa.wait_event , aa.query ,aa.queryid <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ha.query ,ha.queryid, count(*) * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 second'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> duration <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> activity_hist.history_pg_stat_activity_for_reports ha <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> timepoint <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> pg_stat_history_begin+(current_hour_diff * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 hour'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pg_stat_history_end+(current_hour_diff * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 hour'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> backend_type = <span class="hljs-string"><span class="hljs-string">'client backend'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> datname != <span class="hljs-string"><span class="hljs-string">'postgres'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ( ha.wait_event_type <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> ha.wait_event_type , ha.wait_event , ha.query ,ha.queryid ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> query , queryid , SUM( duration ) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> duration <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> hist <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> query , queryid <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">DESC</span></span></code> </pre> </div></div><br>  <b>Un exemple:</b> <br><pre> <code class="plaintext hljs">------------------------------------------------------------------- | TOTAL WAITINGS TIME FOR QUERIES : 21:55:04 +----+----------------------------------------+-------------------- | #| queryid| duration +----+----------------------------------------+-------------------- | 1| 389015618226997618| 16:19:05 | 2| | 03:47:04 | 3| 8085340880788646241| 00:40:20 | 4| 4710212362688288619| 00:13:35 | 5| 9150846928388977274| 00:12:25 | 6| 28942442626229688| 00:11:32 | 7| 1237430309438971376| 00:09:45 | 8| 2649515222348904837| 00:09:37 | 9| | 00:03:45 | 10| 3167065002719415275| 00:02:20 | 11| 5731212217001535134| 00:02:13 | 12| 8304755792398128062| 00:01:31 | 13| 2649515222348904837| 00:00:59 | 14| 2649515222348904837| 00:00:22 | 15| | 00:00:12 | 16| 3422818749220588372| 00:00:08 | 17| -5730801771815999400| 00:00:03 | 18| -1473395109729441239| 00:00:02 | 19| 2404820632950544954| 00:00:02 | 20| -6572922443698419129| 00:00:02 | 21| 2369289265278398647| 00:00:01 | 22| 180077086776069052| 00:00:01 +----+----------------------------------------+--------------------</code> </pre><br><h2>  EN ATTENTE DE DEMANDES </h2><br><div class="spoiler">  <b class="spoiler_title">Demandes:</b> <div class="spoiler_text"><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> hist <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> aa.wait_event_type , aa.wait_event <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> activity_hist.archive_pg_stat_activity aa <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> timepoint <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> pg_stat_history_begin+(current_hour_diff * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 hour'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pg_stat_history_end+(current_hour_diff * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 hour'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> backend_type = <span class="hljs-string"><span class="hljs-string">'client backend'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> datname != <span class="hljs-string"><span class="hljs-string">'postgres'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> aa.wait_event <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> aa.wait_event_type , aa.wait_event <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> ha.wait_event_type , ha.wait_event <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> activity_hist.history_pg_stat_activity_for_reports ha <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> timepoint <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> pg_stat_history_begin+(current_hour_diff * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 hour'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pg_stat_history_end+(current_hour_diff * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 hour'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> backend_type = <span class="hljs-string"><span class="hljs-string">'client backend'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> datname != <span class="hljs-string"><span class="hljs-string">'postgres'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> ha.wait_event <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NULL</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> ha.wait_event_type , ha.wait_event ) <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> wait_event_type , wait_event <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> hist <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> wait_event_type , wait_event <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ASC</span></span> <span class="hljs-comment"><span class="hljs-comment">---------------------------------------------------------------------- WITH hist AS ( SELECT aa.wait_event_type , aa.wait_event , aa.query ,aa.queryid , count(*) * interval '1 second' AS duration FROM activity_hist.archive_pg_stat_activity aa WHERE timepoint BETWEEN pg_stat_history_begin+(current_hour_diff * interval '1 hour') AND pg_stat_history_end+(current_hour_diff * interval '1 hour') AND backend_type = 'client backend' AND datname != 'postgres' AND ( aa.wait_event_type = waitings_stat_rec.wait_event_type AND aa.wait_event = waitings_stat_rec.wait_event ) GROUP BY aa.wait_event_type , aa.wait_event , aa.query ,aa.queryid UNION SELECT ha.wait_event_type , ha.wait_event , ha.query ,ha.queryid, count(*) * interval '1 second' AS duration FROM activity_hist.history_pg_stat_activity_for_reports ha WHERE timepoint BETWEEN pg_stat_history_begin+(current_hour_diff * interval '1 hour') AND pg_stat_history_end+(current_hour_diff * interval '1 hour') AND backend_type = 'client backend' AND datname != 'postgres' AND ( ha.wait_event_type = waitings_stat_rec.wait_event_type AND ha.wait_event = waitings_stat_rec.wait_event ) GROUP BY ha.wait_event_type , ha.wait_event , ha.query ,ha.queryid ) SELECT query , queryid , SUM( duration ) as duration FROM hist GROUP BY query , queryid ORDER BY 3 DESC</span></span></code> </pre> </div></div><br>  <b>Un exemple:</b> <br><pre> <code class="plaintext hljs">------------------------------------------------ | WAITINGS FOR QUERIES +----------------------------------------------- | wait_event_type = Client| | wait_event = ClientRead| | Total time = 00:46:56| ------------------------------------------------ | #| queryid| duration +-----+--------------------+-------------------- | 1| 8085340880788646241| 00:40:20 | 2| | 00:03:45 | 3| 5731212217001535134| 00:01:53 | 4| | 00:00:12 | 5| 9150846928388977274| 00:00:09 | 6| 3422818749220588372| 00:00:08 | 7| 1237430309438971376| 00:00:06 | 8| 28942442626229688| 00:00:05 | 9| 4710212362688288619| 00:00:05 | 10|-5730801771815999400| 00:00:03 | 11| 8304755792398128062| 00:00:02 | 12|-6572922443698419129| 00:00:02 | 13|-1473395109729441239| 00:00:02 | 14| 2404820632950544954| 00:00:02 | 15| 180077086776069052| 00:00:01 | 16| 2369289265278398647| 00:00:01 +----------------------------------------------- | wait_event_type = IO| | wait_event = BufFileRead| | Total time = 00:00:38| ------------------------------------------------ | #| queryid| duration +-----+--------------------+-------------------- | 1| 28942442626229688| 00:00:38 +-----------------------------------------------</code> </pre><br><h2>  HISTORIQUE DES PROCESSUS VERROUILLÉS </h2><br><div class="spoiler">  <b class="spoiler_title">Demande:</b> <div class="spoiler_text"><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> MIN(date_trunc(<span class="hljs-string"><span class="hljs-string">'second'</span></span>,timepoint)) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> started , count(*) * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 second'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> duration , pid , blocking_pids , relation , mode , locktype <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> activity_hist.archive_locking al <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> timepoint <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> pg_stat_history_begin+(current_hour_diff * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 hour'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pg_stat_history_end+(current_hour_diff * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 hour'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> granted <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> locktype = <span class="hljs-string"><span class="hljs-string">'relation'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> pid , blocking_pids , relation , mode , locktype <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> MIN(date_trunc(<span class="hljs-string"><span class="hljs-string">'second'</span></span>,timepoint)) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> started , count(*) * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 second'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> duration , pid , blocking_pids , relation , mode , locktype <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> activity_hist.history_locking <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> timepoint <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> pg_stat_history_begin+(current_hour_diff * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 hour'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pg_stat_history_end+(current_hour_diff * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 hour'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> granted <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> locktype = <span class="hljs-string"><span class="hljs-string">'relation'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> pid , blocking_pids , relation , mode , locktype <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> </div></div><br>  <b>Un exemple:</b> <br><pre>  -------------------------------------------------- -------------------------------------------------- ---------------------------------
 |  HISTORIQUE DES PROCESSUS VERROUILLÉS
 + ----- + ---------- + -------------------- + ---------- + -------------------- + -------------------- + -------- ------------ + --------------------
 |  # |  pid |  commencé |  durée |  blocking_pids |  relation |  mode |  type de verrou
 + ----- + ---------- + -------------------- + ---------- + -------------------- + -------------------- + -------- ------------ + --------------------
 |  1 |  26224 |  2019-09-02 19: 32: 16 |  00: 01: 45 |  {26211} |  16541 |  AccessShareLock |  relation
 |  2 |  26390 |  2019-09-02 19: 34: 03 |  00: 00: 53 |  {26211} |  16541 |  AccessShareLock |  relation
 |  3 |  26391 |  2019-09-02 19: 34: 03 |  00: 00: 53 |  {26211} |  16541 |  AccessShareLock |  relation
 |  4 |  26531 |  2019-09-02 19: 35: 27 |  00: 00: 12 |  {26211} |  16541 |  AccessShareLock |  relation
 |  5 |  27284 |  2019-09-02 19: 44: 02 |  00: 00: 19 |  {27276} |  16541 |  AccessShareLock |  relation
 |  6 |  27283 |  2019-09-02 19: 44: 02 |  00: 00: 19 |  {27276} |  16541 |  AccessShareLock |  relation
 |  7 |  27286 |  2019-09-02 19: 44: 02 |  00: 00: 19 |  {27276} |  16541 |  AccessShareLock |  relation
 |  8 |  27423 |  2019-09-02 19:45:24 |  00: 00: 12 |  {27394} |  16541 |  AccessShareLock |  relation
 |  9 |  27648 |  2019-09-02 19: 48: 06 |  00: 00: 20 |  {27647} |  16541 |  AccessShareLock |  relation
 |  10 |  27650 |  2019-09-02 19: 48: 06 |  00: 00: 20 |  {27647} |  16541 |  AccessShareLock |  relation
 |  11 |  27735 |  2019-09-02 19: 49: 08 |  00: 00: 06 |  {27650} |  16541 |  AccessExclusiveLock |  relation
 |  12 |  28380 |  2019-09-02 19: 56: 03 |  00: 01: 56 |  {28379} |  16541 |  AccessShareLock |  relation
 |  13 |  28379 |  2019-09-02 19: 56: 03 |  00: 00: 01 |  28377 |  16541 |  AccessExclusiveLock |  relation
 |  |  |  |  |  28376 |  | 
</pre><br><h2>  HISTORIQUE DES PROCESSUS DE BLOCAGE </h2><br><div class="spoiler">  <b class="spoiler_title">Demandes:</b> <div class="spoiler_text"><pre> <code class="pgsql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> blocking_pids <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> activity_hist.archive_locking al <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> timepoint <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> pg_stat_history_begin+(current_hour_diff * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 hour'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pg_stat_history_end+(current_hour_diff * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 hour'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> granted <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> locktype = <span class="hljs-string"><span class="hljs-string">'relation'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> blocking_pids <span class="hljs-keyword"><span class="hljs-keyword">UNION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> blocking_pids <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> activity_hist.history_locking <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> timepoint <span class="hljs-keyword"><span class="hljs-keyword">BETWEEN</span></span> pg_stat_history_begin+(current_hour_diff * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 hour'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pg_stat_history_end+(current_hour_diff * <span class="hljs-type"><span class="hljs-type">interval</span></span> <span class="hljs-string"><span class="hljs-string">'1 hour'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">NOT</span></span> granted <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> locktype = <span class="hljs-string"><span class="hljs-string">'relation'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">GROUP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> blocking_pids <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">--------------------------------------------------------------- SELECT pid , usename , application_name , datname , MIN(date_trunc('second',timepoint)) as started , count(*) * interval '1 second' as duration , state , query FROM activity_hist.archive_pg_stat_activity WHERE pid= current_pid AND timepoint BETWEEN pg_stat_history_begin+(current_hour_diff * interval '1 hour') AND pg_stat_history_end+(current_hour_diff * interval '1 hour') GROUP BY pid , usename , application_name , datname , state_change, state , query UNION SELECT pid , usename , application_name , datname , MIN(date_trunc('second',timepoint)) as started , count(*) * interval '1 second' as duration , state , query FROM activity_hist.history_pg_stat_activity_for_reports WHERE pid= current_pid AND timepoint BETWEEN pg_stat_history_begin+(current_hour_diff * interval '1 hour') AND pg_stat_history_end+(current_hour_diff * interval '1 hour') GROUP BY pid , usename , application_name , datname , state_change, state , query ORDER BY 5 , 1</span></span></code> </pre> </div></div><br>  <b>Un exemple:</b> <br><pre>  -------------------------------------------------- -------------------------------------------------- -------------------------------------------------- -----------------------
 HISTORIQUE DES PROCESSUS DE BLOCAGE
 + ---- + ---------- + ---------- + -------------------- + - --------- + -------------------- + ------------------- - + ------------------------------ + ----------------- -----------------------
 |  # |  pid |  nom d'utilisateur |  nom_application |  datname |  commencé |  durée |  état |  interroger
 + ---- + ---------- + ---------- + -------------------- + - --------- + -------------------- + ------------------- - + ------------------------------ + ----------------- -----------------------
 |  1 |  26211 |  tuser |  psql |  tdb1 |  2019-09-02 19: 31: 54 |  00: 00: 04 |  inactif |
 |  2 |  26211 |  tuser |  psql |  tdb1 |  2019-09-02 19: 31: 58 |  00: 00: 06 |  inactif dans la transaction |  commencer;
 |  3 |  26211 |  tuser |  psql |  tdb1 |  2019-09-02 19: 32: 16 |  00: 01: 45 |  inactif dans la transaction |  table de verrouillage wafer_data;
 |  4 |  26211 |  tuser |  psql |  tdb1 |  2019-09-02 19: 35: 54 |  00: 01: 23 |  inactif |  commettre;
 |  5 |  26211 |  tuser |  psql |  tdb1 |  2019-09-02 19: 38: 46 |  00: 00: 02 |  inactif dans la transaction |  commencer;
 |  6 |  26211 |  tuser |  psql |  tdb1 |  2019-09-02 19: 38: 54 |  00: 00: 08 |  inactif dans la transaction |  table de verrouillage wafer_data;
 |  7 |  26211 |  tuser |  psql |  tdb1 |  2019-09-02 19: 39: 08 |  00: 42: 42 |  inactif |  commettre;
 |  8 |  26211 |  tuser |  psql |  tdb1 |  2019-09-03 07: 12: 07 |  00: 00: 52 |  actif |  sélectionnez test_del ();
</pre><br><br><h1>  Développement. </h1><br>  Les requêtes de base affichées et les rapports reçus simplifient déjà considérablement la vie lors de l'analyse des incidents de performances. <br>  Sur la base de requêtes de base, vous pouvez obtenir à distance un rapport qui rappelle approximativement Oracle AWR. <br><div class="spoiler">  <b class="spoiler_title">Exemple de rapport de synthèse</b> <div class="spoiler_text"><pre>  + ------------------------------------------------- -----------------------------------
 |  RAPPORT CONSOLIDÉ D'ACTIVITÉ ET D'ATTENTE.  DATETIME: 09/03/2019 14:08
 | ------------------------------------------------- -----------------------------------
 |  HÔTE: XXXX
 |  BEGIN_SNAPSHOT: 09/02/2019 14:08 END_SNAPSHOT: 09/03/2019 14:00
 | ------------------------------------------------- -----------------------------------
 |  TAILLE DES BASES DE DONNÉES ACTUELLES:
 |  BASE DE DONNÉES: moniteur
 |  TAILLE (MB): 1370.00
 | ------------------------------------------------- -----------------------------------
 |  TEMPS DU CPU CLUSTER: 19:44:22
 |  TEMPS D'ATTENTE DU CLUSTER: 78:49:16
 |
 |  SQL DBTIME: 65:53:09
 |  TEMPS DU CPU SQL: 19:05:21
 |  TEMPS D'ATTENTE SQL: 21:50:46
 |  SQL IOTIME: 20:53:00
 |  TEMPS DE LECTURE SQL: 20:52:55
 |  TEMPS D'ÉCRITURE SQL: 00:00:05
 |
 |  APPELS SQL: 311293
 -------------------------------------------------- -----------
 |  LECTURE DE BLOCS PARTAGÉS SQL: 13351563334
 |  HITS DE BLOCS PARTAGÉS SQL: 2775427045
 |  BLOCS PARTAGÉS SQL HITS / READS%: 20,79
 |  BLOCS PARTAGÉS SQL DIRTÉS: 21105
 |  BLOCS PARTAGÉS SQL ÉCRITS: 3656
 |
 |  LECTURES TEMPORAIRES DE BLOCS SQL: 7464932
 |  BLOCS TEMPORAIRES SQL ÉCRITS: 10176024
 -------------------------------------------------- -----------
 |
 |  ATTENTE STATIQUE
 |
 + ------------------------------------------------- -----------------------------------
 |  TOP 10 DES ATTENTES PAR TEMPS D'ATTENTE TOTAL POUR LES PROCESSUS SYSTÈME
 + ----- + ------------------------------ + ------------ -------- + --------------------
 |  # |  wait_event_type |  wait_event |  la durée
 + ----- + ------------------------------ + ------------ -------- + --------------------
 |  1 |  Activité |  LogicalLauncherMain |  11:21:01
 |  2 |  Activité |  CheckpointerMain |  11:20:35
 |  3 |  Activité |  AutoVacuumMain |  11:20:31
 |  4 |  Activité |  WalWriterMain |  11:19:35
 |  5 |  Activité |  BgWriterMain |  10:14:19
 |  6 |  Activité |  BgWriterHibernate |  01:06:04
 |  7 |  Activité |  WalSenderMain |  00:04:05
 |  8 |  Client |  ClientWrite |  00:04:00
 |  9 |  IO |  BufFileWrite |  00:02:45
 |  10 |  LWLock |  buffer_mapping |  00:02:14
 + ----- + ------------------------------ + ------------ -------- + --------------------
 |  TOP 10 DES ATTENTES PAR TEMPS D'ATTENTE TOTAL POUR LES PROCESSUS DES CLIENTS
 + ----- + ------------------------------ + ------------ -------- + -------------------- + ----------
 |  # |  wait_event_type |  wait_event |  durée |  % dbtime
 + ----- + ------------------------------ + ------------ -------- + -------------------- + ----------
 |  1 |  Lock |  transactionid |  11: 55: 37 |  18.1
 |  2 |  IO |  DataFileRead |  07: 19: 43 |  12/12
 |  3 |  Client |  ClientRead |  00: 46: 54 |  1.19
 |  4 |  Lock |  relation |  00: 40: 37 |  1.03
 |  5 |  LWLock |  buffer_mapping |  00: 31: 08 |  0,79
 |  6 |  LWLock |  buffer_io |  00: 22: 12 |  0,56
 |  7 |  Délai d'expiration |  PgSleep |  00: 10: 58 |  0,28
 |  8 |  Lock |  tuple |  00: 01: 30 |  0,04
 |  9 |  IO |  BufFileWrite |  00: 01: 16 |  0,03
 |  10 |  IO |  BufFileRead |  00: 00: 37 |  0,02
 + ----- + ------------------------------ + ------------ -------- + -------------------- + ----------
 |  TYPES D'ATTENTE PAR TEMPS D'ATTENTE TOTAL, POUR LES PROCESSUS SYSTÈME
 + ----- + ------------------------------ + ------------ --------
 |  # |  wait_event_type |  la durée
 + ----- + ------------------------------ + ------------ --------
 |  1 |  Activité |  56:46:10
 |  2 |  IO |  00:05:13
 |  3 |  Client |  00:04:00
 |  4 |  LWLock |  00:03:07
 + ----- + ------------------------------ + ------------ --------
 |  TYPES D'ATTENTE PAR TEMPS D'ATTENTE TOTAL, POUR LES PROCESSUS DES CLIENTS
 + ----- + ------------------------------ + ------------ -------- + --------------------
 |  # |  wait_event_type |  durée |  % dbtime
 + ----- + ------------------------------ + ------------ -------- + --------------------
 |  1 |  Lock |  12: 37: 44 |  19.17
 |  2 |  IO |  07: 21: 40 |  11.17
 |  3 |  LWLock |  00: 53: 26 |  1,35
 |  4 |  Client |  00: 46: 54 |  1.19
 |  5 |  Délai d'expiration |  00: 10: 58 |  0,28
 |  6 |  IPC |  00: 00: 04 |  0
 + ----- + ------------------------------ + ------------ -------- + --------------------
 |  ATTENTE DES PROCESSUS SYSTÈME
 + ----- + ----------------------------- + ---------- + - ------------------ + ---------------------- + -------- ------------
 |  # |  backend_type |  dbname |  wait_event_type |  wait_event |  la durée
 + ----- + ----------------------------- + ---------- + - ------------------ + ---------------------- + -------- ------------
 |  1 |  lanceur de réplication logique |  |  Activité |  LogicalLauncherMain |  11:21:01
 |  2 |  pointeur de contrôle |  |  Activité |  CheckpointerMain |  11:20:35
 |  3 |  lanceur autovacuum |  |  Activité |  AutoVacuumMain |  11:20:31
 |  4 |  walwriter |  |  Activité |  WalWriterMain |  11:19:35
 |  5 |  écrivain de fond |  |  Activité |  BgWriterMain |  10:14:19
 |  6 |  écrivain de fond |  |  Activité |  BgWriterHibernate |  01:06:04
 |  7 |  walsender |  |  Activité |  WalSenderMain |  00:04:05
 |  8 |  walsender |  |  Client |  ClientWrite |  00:04:00
 |  9 |  travailleur parallèle |  tdb1 |  IO |  BufFileWrite |  00:02:45
 |  10 |  travailleur parallèle |  tdb1 |  LWLock |  buffer_mapping |  00:02:05
 |  11 |  travailleur parallèle |  tdb1 |  IO |  DataFileRead |  00:01:10
 |  12 |  travailleur parallèle |  tdb1 |  IO |  BufFileRead |  00:01:05
 |  13 |  travailleur parallèle |  tdb1 |  LWLock |  buffer_io |  00:00:45
 |  14 |  travailleur autovacuum |  tdb1 |  LWLock |  buffer_mapping |  00:00:09
 |  15 |  walwriter |  |  IO |  WALWrite |  00:00:08
 |  16 |  walwriter |  |  LWLock |  WALWriteLock |  00:00:04
 |  17 |  écrivain de fond |  |  LWLock |  WALWriteLock |  00:00:03
 |  18 |  écrivain de fond |  |  IO |  WALWrite |  00:00:02
 |  19 |  écrivain de fond |  |  IO |  DataFileWrite |  00:00:02
 |  20 |  pointeur de contrôle |  |  IO |  ControlFileSyncUpdate |  00:00:01
 |  21 |  travailleur autovacuum |  tdb1 |  LWLock |  buffer_io |  00:00:01
 + ----- + ----------------------------- + ---------- + - ------------------ + ---------------------- + -------- ------------
 |  ATTENTE POUR SQL
 + ----- + ------------------------- + ---------- + ------ -------------- + -------------------- + -------------- ------ + ----------
 |  # |  queryid |  dbname |  wait_event_type |  wait_event |  durée |  % dbtime
 + ----- + ------------------------- + ---------- + ------ -------------- + -------------------- + -------------- ------ + ----------
 |  1 |  389015618226997618 |  tdb1 |  Lock |  transactionid |  09: 47: 43 |  14,87
 |  2 |  389015618226997618 |  tdb1 |  IO |  DataFileRead |  05: 47: 07 |  8.78
 |  3 |  |  tdb1 |  Lock |  transactionid |  02: 07: 54 |  3.24
 |  4 |  |  tdb1 |  IO |  DataFileRead |  01: 30: 24 |  2.29
 |  5 |  8085340880788646241 |  tdb1 |  Client |  ClientRead |  00: 40: 20 |  1.02
 |  6 |  389015618226997618 |  tdb1 |  LWLock |  buffer_mapping |  00: 20: 41 |  0,52
 |  7 |  389015618226997618 |  tdb1 |  LWLock |  buffer_io |  00: 17: 30 |  0,44
 |  8 |  2649515222348904837 |  tdb1 |  Délai d'expiration |  PgSleep |  00: 10: 58 |  0,28
 |  9 |  4710212362688288619 |  tdb1 |  Lock |  relation |  00: 10: 44 |  0,27
 |  10 |  9150846928388977274 |  tdb1 |  Lock |  relation |  00: 10: 24 |  0,26
 |  11 |  28942442626229688 |  tdb1 |  Lock |  relation |  00: 07: 48 |  0,2
 |  12 |  1237430309438971376 |  tdb1 |  Lock |  relation |  00: 07: 32 |  0,19
 |  13 |  |  tdb1 |  LWLock |  buffer_mapping |  00: 04: 32 |  0,11
 |  14 |  |  tdb1 |  LWLock |  buffer_io |  00: 04: 13 |  0,11
 |  15 |  |  tdb1 |  Client |  ClientRead |  00: 03: 57 |  0,1
 |  16 |  4710212362688288619 |  tdb1 |  LWLock |  buffer_mapping |  00: 02: 26 |  0,06
 |  17 |  3167065002719415275 |  tdb1 |  Lock |  relation |  00: 02: 20 |  0,06
 |  18 |  5731212217001535134 |  tdb1 |  Client |  ClientRead |  00: 01: 53 |  0,05
 |  19 |  1237430309438971376 |  tdb1 |  LWLock |  buffer_mapping |  00: 01: 42 |  0,04
 |  20 |  389015618226997618 |  tdb1 |  Lock |  tuple |  00: 01: 30 |  0,04
 |  21 |  8304755792398128062 |  tdb1 |  Lock |  relation |  00: 01: 29 |  0,04
 |  22 |  28942442626229688 |  tdb1 |  IO |  BufFileWrite |  00: 01: 16 |  0,03
 |  23 |  9150846928388977274 |  tdb1 |  IO |  DataFileRead |  00: 01: 07 |  0,03
 |  24 |  28942442626229688 |  tdb1 |  LWLock |  buffer_mapping |  00: 01: 03 |  0,03
 |  25 |  9150846928388977274 |  tdb1 |  LWLock |  buffer_mapping |  00: 00: 44 |  0,02
 |  26 |  28942442626229688 |  tdb1 |  IO |  BufFileRead |  00: 00: 37 |  0,02
 |  27 |  28942442626229688 |  tdb1 |  LWLock |  buffer_io |  00: 00: 25 |  0,01
 |  28 |  1237430309438971376 |  tdb1 |  IO |  DataFileRead |  00: 00: 24 |  0,01
 |  29 |  28942442626229688 |  tdb1 |  IO |  DataFileRead |  00: 00: 22 |  0,01
 |  30 |  5731212217001535134 |  tdb1 |  Lock |  relation |  00: 00: 20 |  0,01
 |  31 |  4710212362688288619 |  tdb1 |  IO |  DataFileRead |  00: 00: 19 |  0,01
 |  32 |  9150846928388977274 |  tdb1 |  Client |  ClientRead |  00: 00: 09 |  0
 |  33 |  3422818749220588372 |  tdb1 |  Client |  ClientRead |  00: 00: 08 |  0
 |  34 |  1237430309438971376 |  tdb1 |  Client |  ClientRead |  00: 00: 06 |  0
 |  35 |  389015618226997618 |  tdb1 |  LWLock |  buffer_content |  00: 00: 05 |  0
 |  36 |  4710212362688288619 |  tdb1 |  Client |  ClientRead |  00: 00: 05 |  0
 |  37 |  4710212362688288619 |  tdb1 |  LWLock |  buffer_io |  00: 00: 04 |  0
 |  38 |  28942442626229688 |  tdb1 |  Client |  ClientRead |  00: 00: 04 |  0
 |  39 |  28942442626229688 |  tdb1 |  IPC |  ParallelFinish |  00: 00: 03 |  0
 |  40 |  389015618226997618 |  tdb1 |  IO |  DataFileWrite |  00: 00: 02 |  0
 |  41 |  -5730801771815999400 |  tdb1 |  Client |  ClientRead |  00: 00: 02 |  0
 |  42 |  2404820632950544954 |  tdb1 |  Client |  ClientRead |  00: 00: 02 |  0
 |  43 |  -6572922443698419129 |  tdb1 |  Client |  ClientRead |  00: 00: 02 |  0
 |  44 |  8304755792398128062 |  tdb1 |  Client |  ClientRead |  00: 00: 02 |  0
 |  45 |  -1473395109729441239 |  tdb1 |  Client |  ClientRead |  00: 00: 02 |  0
 |  46 |  |  tdb1 |  LWLock |  buffer_content |  00: 00: 01 |  0
 |  47 |  180077086776069052 |  tdb1 |  Client |  ClientRead |  00: 00: 01 |  0
 |  48 |  |  tdb1 |  IO |  DataFileWrite |  00: 00: 01 |  0
 |  49 |  28942442626229688 |  tdb1 |  IPC |  MessageQueueReceive |  00: 00: 01 |  0
 |  50 |  2369289265278398647 |  tdb1 |  Client |  ClientRead |  00: 00: 01 |  0
 |  51 |  9150846928388977274 |  tdb1 |  IO |  DataFileWrite |  00: 00: 01 |  0
 + ----- + ------------------------- + ---------- + ------ -------------- + -------------------- + -------------- ------ + ----------
 |
 |  STATIQUE SQL CLIENT
 |
 + ------------------------------------------------- -----------------------------------
 |  CLIENT SQL ordonné par Elapsed Time
 + -------------------- + ---------- + ---------- + ------ ---- + ---------- + ---------- + --------------------
 |  temps écoulé |  appels |  % dbtime |  % CPU |  % IO |  dbname |  queryid
 + -------------------- + ---------- + ---------- + ------ ---- + ---------- + ---------- + --------------------
 |  06: 43: 19 |  36 |  10.2 |  85 septembre |  17,38 |  tdb1 |  389015618226997618
 |  02: 06: 53 |  715 |  3.21 |  0,85 |  0,06 |  tdb1 |  1237430309438971376
 |  01: 52: 07 |  720 |  2,84 |  1.19 |  0,08 |  tdb1 |  4710212362688288619
 |  00: 39: 03 |  357 |  0,99 |  1.02 |  0,33 |  tdb1 |  28942442626229688
 |  00: 22: 00 |  8 |  0,56 |  0,96 |  0 |  tdb1 |  2649515222348904837
 + -------------------- + ---------- + ---------- + ------ ---- + ---------- + ---------- + --------------------
 |  CLIENT SQL ordonné par CPU Time
 + -------------------- + ---------- + ---------- + ------ ---- + ---------- + ---------- + ---------- + ------------ --------
 |  temps processeur |  appels |  % dbtime | total_time |  % CPU |  % IO |  dbname |  queryid
 + -------------------- + ---------- + ---------- + ------ ---- + ---------- + ---------- + ---------- + ------------ --------
 |  16: 14: 38 |  36 |  10.2 |  06: 43: 19 |  85 septembre |  17,38 |  tdb1 |  389015618226997618
 |  00: 13: 38 |  720 |  2,84 |  01: 52: 07 |  1.19 |  0,08 |  tdb1 |  4710212362688288619
 |  00: 11: 39 |  357 |  0,99 |  00: 39: 03 |  1.02 |  0,33 |  tdb1 |  28942442626229688
 |  00: 10: 58 |  8 |  0,56 |  00: 22: 00 |  0,96 |  0 |  tdb1 |  2649515222348904837
 |  00: 09: 44 |  715 |  3.21 |  02: 06: 53 |  0,85 |  0,06 |  tdb1 |  1237430309438971376
 + -------------------- + ---------- + ---------- + ------ ---- + ---------- + ---------- + ---------- + ------------ --------
 |  CLIENT SQL ordonné par temps d'attente des E / S utilisateur
 + -------------------- + ---------- + ---------- + ------ ---- + ---------- + ---------- + ---------- + ------------ --------
 |  temps io_wait |  appels |  % dbtime | total_time |  % CPU |  % IO |  dbname |  queryid
 + -------------------- + ---------- + ---------- + ------ ---- + ---------- + ---------- + ---------- + ------------ --------
 |  05: 47: 09 |  36 |  10.2 |  06: 43: 19 |  85 septembre |  17,38 |  tdb1 |  389015618226997618
 |  00: 02: 15 |  357 |  0,99 |  00: 39: 03 |  1.02 |  0,33 |  tdb1 |  28942442626229688
 |  00: 00: 24 |  715 |  3.21 |  02: 06: 53 |  0,85 |  0,06 |  tdb1 |  1237430309438971376
 |  00: 00: 19 |  720 |  2,84 |  01: 52: 07 |  1.19 |  0,08 |  tdb1 |  4710212362688288619
 |  00: 00: 00 |  8 |  0,56 |  00: 22: 00 |  0,96 |  0 |  tdb1 |  2649515222348904837
 + -------------------- + ---------- + ---------- + ------ ---- + ---------- + ---------- + ---------- + ------------ --------
 |  CLIENT SQL ordonné par des lectures de tampons partagés
 + -------------------- + ---------- + ---------- + ------ ---- + ---------- + ---------- + ---------- + ------------ --------
 |  tampons lit |  appels |  % dbtime | total_time |  % CPU |  % IO |  dbname |  queryid
 + -------------------- + ---------- + ---------- + ------ ---- + ---------- + ---------- + ---------- + ------------ --------
 |  2562353244 |  36 |  10.2 |  06: 43: 19 |  85 septembre |  17,38 |  tdb1 |  389015618226997618
 |  11041689 |  357 |  0,99 |  00: 39: 03 |  1.02 |  0,33 |  tdb1 |  28942442626229688
 |  3303551 |  715 |  3.21 |  02: 06: 53 |  0,85 |  0,06 |  tdb1 |  1237430309438971376
 |  3242892 |  720 |  2,84 |  01: 52: 07 |  1.19 |  0,08 |  tdb1 |  4710212362688288619
 |  0 |  8 |  0,56 |  00: 22: 00 |  0,96 |  0 |  tdb1 |  2649515222348904837
 + -------------------- + ---------- + ---------- + ------ ---- + ---------- + ---------- + ---------- + ------------ --------
 |  CLIENT SQL ordonné par Disk Reads Time
 + -------------------- + ---------- + ---------- + ------ ---- + ---------- + ---------- + ---------- + ------------ --------
 |  temps de lecture |  appels |  % dbtime | total_time |  % CPU |  % IO |  dbname |  queryid
 + -------------------- + ---------- + ---------- + ------ ---- + ---------- + ---------- + ---------- + ------------ --------
 |  03: 37: 46 |  36 |  10.2 |  06: 43: 19 |  85 septembre |  17,38 |  tdb1 |  389015618226997618
 |  00: 04: 07 |  357 |  0,99 |  00: 39: 03 |  1.02 |  0,33 |  tdb1 |  28942442626229688
 |  00: 00: 59 |  720 |  2,84 |  01: 52: 07 |  1.19 |  0,08 |  tdb1 |  4710212362688288619
 |  00: 00: 42 |  715 |  3.21 |  02: 06: 53 |  0,85 |  0,06 |  tdb1 |  1237430309438971376
 |  00: 00: 00 |  8 |  0,56 |  00: 22: 00 |  0,96 |  0 |  tdb1 |  2649515222348904837
 + -------------------- + ---------- + ---------- + ------ ---- + ---------- + ---------- + ---------- + ------------ --------
 |  CLIENT SQL ordonné par Executions
 + -------------------- + ---------- + ---------- + ------ ---- + ---------- + ---------- + ---------- + ------------ --------
 |  appels |  lignes |  % dbtime | total_time |  % CPU |  % IO |  dbname |  queryid
 + -------------------- + ---------- + ---------- + ------ ---- + ---------- + ---------- + ---------- + ------------ --------
 |  720 |  720 |  2,84 |  01: 52: 07 |  1.19 |  0,08 |  tdb1 |  4710212362688288619
 |  715 |  715 |  3.21 |  02: 06: 53 |  0,85 |  0,06 |  tdb1 |  1237430309438971376
 |  357 |  0 |  0,99 |  00: 39: 03 |  1.02 |  0,33 |  tdb1 |  28942442626229688
 |  36 |  36 |  10.2 |  06: 43: 19 |  85 septembre |  17,38 |  tdb1 |  389015618226997618
 |  8 |  8 |  0,56 |  00: 22: 00 |  0,96 |  0 |  tdb1 |  2649515222348904837
 + -------------------- + ---------- + ---------- + ------ ---- + ---------- + ---------- + ---------- + ------------ --------
 |  Liste complète du texte SQL
 ----------------------------------------------
 ...
</pre></div></div><br>  À suivre.  L'étape suivante est la formation de l'historique des verrous (pg_stat_locks), une description plus détaillée du processus de remplissage des tables. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr467181/">https://habr.com/ru/post/fr467181/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr467171/index.html">Ce que j'ai appris en testant 200 000 lignes de code d'infrastructure</a></li>
<li><a href="../fr467173/index.html">Architecte de mise en œuvre sécurisée d'ERP</a></li>
<li><a href="../fr467175/index.html">Réfléchissez bien avant d'utiliser les moteurs de jeu</a></li>
<li><a href="../fr467177/index.html">Conseils marketing Tarantino: quel rôle jouent les pieds et pourquoi faire du savon Uma Thurman</a></li>
<li><a href="../fr467179/index.html">Samsung Compiler Bootcamp: apprenez à créer des "programmes de programmation"</a></li>
<li><a href="../fr467183/index.html">Étude des 50 meilleures plateformes de chat bot et assistants virtuels en 2019</a></li>
<li><a href="../fr467185/index.html">Descente en pente</a></li>
<li><a href="../fr467187/index.html">Créer la dernière bibliothèque technologique</a></li>
<li><a href="../fr467189/index.html">Échantillonnage de température</a></li>
<li><a href="../fr467191/index.html">Comment nous avons créé Vivaldi pour Android</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>