<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚑 🌠 👩‍💼 喷气飞机经销商ok.ru/music 🚭 👩🏾‍🌾 🅿️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="我在Odnoklassniki平台团队中工作，今天我将讨论音乐分发服务的体系结构，设计和实现细节。 

 本文是Joker 2018上该报告的笔录。 
 一些统计 
 首先，关于OK的几句话。 这是一项庞大的服务，已有超过7,000万用户使用。 它们由4个数据中心的7,000辆汽车提供服务。 最近，...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>喷气飞机经销商ok.ru/music</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/odnoklassniki/blog/434206/"><img src="https://habrastorage.org/webt/m8/yb/sn/m8ybsnu0c1bqakexungs-hkisui.png"><br><br> 我在Odnoklassniki平台团队中工作，今天我将讨论音乐分发服务的体系结构，设计和实现细节。 <br><a name="habracut"></a><br><blockquote> 本文是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Joker 2018</a>上该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">报告</a>的笔录。 </blockquote><br><h1> 一些统计 </h1><br> 首先，关于OK的几句话。 这是一项庞大的服务，已有超过7,000万用户使用。 它们由4个数据中心的7,000辆汽车提供服务。 最近，我们在不考虑众多CDN站点的情况下突破了2 Tb / s的流量标记。 我们最大限度地利用了硬件，负载最大的服务每秒可从四核节点处理多达100,000个请求。 而且，几乎所有服务都是用Java编写的。 <br><br>  OK中有很多部分，其中最受欢迎的部分是“音乐”。 在其中，用户可以上传曲目，购买和下载不同质量的音乐。 该部分有一个很棒的目录，推荐系统，广播等等。 但是，该服务的主要目的当然是播放音乐。 <br><br> 音乐发行人负责将数据传输到用户播放器和移动应用程序。 如果查看对musicd.mycdn.me域的请求，则可以在Web检查器中捕获它。 分发器API非常简单。 它响应<code>GET</code> HTTP请求并发出请求的跟踪范围。 <br><br><img src="https://habrastorage.org/webt/j9/va/ze/j9vazesvr2fuqtpvhec0uj7gbmq.png"><br><br> 高峰时，通过500万个连接，负载达到100 Gb / s。 实际上，音乐分发器是位于我们内部轨道存储库前面的缓存前端，该内部存储库基于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">One Blob存储</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">One Cold Storage</a>并包含PB级数据。 <br><br> 既然我已经讨论过缓存，那么让我们看一下回放统计信息。 我们看到了明显的TOP。 <br><br><img src="https://habrastorage.org/webt/q6/jv/pc/q6jvpcopw2t0xt29sl84lwp1gkg.png"><br><br> 每天大约有140首曲目覆盖全部播放的10％。 如果我们希望我们的缓存服务器的缓存命中率至少达到90％，那么我们就需要50万条轨道来容纳它。  95％-接近一百万首曲目。 <br><br><h1> 发行人要求 </h1><br> 在开发下一代发行版时，我们为自己设定了哪些目标？ <br><br> 我们希望一个节点能够容纳10万个连接。 这些都是缓慢的客户端连接：网络上速度不一的一堆浏览器和移动应用程序。 同时，与我们所有的系统一样，该服务必须是可扩展的并且具有容错能力。 <br><br> 首先，我们需要扩展群集的带宽，以跟上服务的日益普及并能够提供越来越多的流量。 还必须能够扩展群集缓存的总容量，因为缓存命中率和落入磁道存储中的请求百分比将直接取决于它。 <br><br> 如今，必须能够水平扩展任何分布式系统，即添加计算机和数据中心。 但是我们也想实现垂直扩展。 我们典型的现代服务器包含56个核心，0.5-1 TB的RAM，10或40 Gb的网络接口和十几个SSD磁盘。 <br><br> 说到水平可伸缩性，会产生一个有趣的效果：当您有成千上万的服务器和成千上万的磁盘时，某些东西会不断崩溃。 磁盘故障是很常见的事情，我们每周更换20-30件。 服务器故障不会使任何人感到惊讶；每天要更换2-3辆汽车。 我还必须处理数据中心故障，例如，在2018年发生了三起此类故障，这可能不是最后一次了。 <br><br> 我怎么都这样 设计任何系统时，我们都知道它们迟早会损坏。 因此，我们总是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">仔细研究</a>所有系统组件<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的</a>故障情况。 处理故障的主要方法是通过数据复制：数个数据副本存储在不同的节点上。 <br><br> 我们还保留网络带宽。 这很重要，因为如果系统的某个组件发生故障，则无法允许其余组件上的负载崩溃。 <br><br><h1> 平衡 </h1><br> 首先，您需要学习如何在数据中心之间平衡用户查询并自动进行。 这是在您需要进行网络工作或数据中心发生故障的情况下。 但是，数据中心内部也需要平衡。 而且我们希望在节点之间分配请求不是随机的，而是权重。 例如，当我们上载服务的新版本并希望平滑地输入新节点进行轮换时。 权重在压力测试中也有很大帮助：我们增加了权重并在节点上施加了更大的负载，以了解其功能的局限性。 当节点在负载下发生故障时，我们会迅速将重量归零，并使用平衡机制将其从旋转中移除。 <br><br> 从用户到节点的请求路径是什么样的，将考虑平衡的情况返回数据？ <br><br><img src="https://habrastorage.org/webt/uu/tz/uf/uutzuf3bnfpetnns91ca-rcf5mc.png"><br><br> 用户通过网站或移动应用程序登录并接收曲目的URL： <br><br> <code>musicd.mycdn.me/v0/stream?id=...</code> <br> <br> 为了从URL中的主机名获取IP地址，客户端与我们的GSLB DNS联系，该GSLB DNS知道我们所有的数据中心和CDN站点。  GSLB DNS为客户端提供数据中心之一的平衡器的IP地址，然后客户端与其建立连接。 平衡器了解数据中心内的所有节点及其权重。 它代表用户建立与节点之一的连接。 我们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">使用基于N4Ware的L4平衡器</a> 。  Noda绕过平衡器直接提供用户数据。 在像分销商这样的服务中，传出流量明显高于传入流量。 <br><br> 如果数据中心崩溃，则GSLB DNS会检测到该问题并迅速将其从循环中删除：它将不再向用户提供此数据中心平衡器的IP地址。 如果数据中心中的节点发生故障，则其权重将重置，数据中心内的平衡器将停止向其发送请求。 <br><br> 现在考虑按数据中心内的节点平衡轨道。 我们将数据中心视为独立的自治单位，即使其他所有中心都死亡，它们每个都可以生活和工作。 磁道需要在整个计算机上均匀地平衡，以确保没有负载失真，并将它们复制到不同的节点。 如果一个节点发生故障，则应在其余节点之间平均分配负载。 <br><br> 这个问题可以用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不同的方法解决</a> 。 我们决定采用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">一致的散列</a> 。 我们将轨道标识符的散列的整个可能范围包装在一个环中，然后将每个轨道显示在该环上的某个点。 然后，我们将环的范围或多或少均匀地分布在集群中的节点之间。 通过将磁道散列到环上的某个点并顺时针移动，可以选择将存储磁道的节点。 <br><br><img src="https://habrastorage.org/webt/qr/ty/xf/qrtyxfbchjhlp5taqfs0fbicnk0.jpeg"><br><br> 但是这种方案有一个缺点：例如，在节点N2发生故障的情况下，其整个负载将落在环中的下一个副本-N3上。 而且，如果它的性能没有双倍的余量-并且从经济上讲还不合理-那么第二个节点很可能也会遇到糟糕的时间。  N3出现的可能性很高，负载将达到N4，依此类推-整个环上都会发生级联故障。 <br><br> 可以通过增加副本数来解决此问题，但是环中群集的总可用容量会减少。 因此，我们不这样做。 在相同数量的节点的情况下，将环划分为大量随机分布在环周围的范围。 根据上述算法选择轨道的副本。 <br><br><img src="https://habrastorage.org/webt/kc/uf/5-/kcuf5-1mmekp60d5emkp5ckkgps.png"><br><br> 在上面的示例中，每个节点负责两个范围。 如果其中一个节点发生故障，则其整个负载将不会位于环网中的下一个节点上，而是会在群集的其他两个节点之间分配。 <br><br> 环是根据算法中的一小部分参数计算得出的，并在每个节点上确定。 也就是说，我们不将其存储在某种配置中。 我们在生产中有十万多个这样的范围，并且在任何节点发生故障的情况下，负载在所有其他活动节点之间绝对均匀地分布。 <br><br> 在具有一致哈希的系统中，返回给用户的轨迹是什么样的？ <br><br> 用户通过L4平衡器到达随机节点。 节点选择是随机的，因为平衡器对拓扑一无所知。 但是，集群中的每个副本都知道这一点。 收到请求的节点将确定它是否是所请求轨道的副本。 如果不是，它将使用其中一个副本切换到代理模式，并与其建立连接，然后在其本地存储中搜索数据。 如果轨道不存在，则副本将其从轨道存储中拉出，将其保存到本地存储中并提供代理，该代理会将数据重定向到用户。 <br><br><img src="https://habrastorage.org/webt/c5/pu/wl/c5puwlig-lfxy20leny4y4utqig.png"><br><br> 如果副本中的驱动器发生故障，则来自存储的数据将直接传输给用户。 如果该副本失败，则代理会知道该轨道的所有其他副本，它将与另一个活动副本建立连接并从中接收数据。 因此，我们保证，如果用户请求一个曲目并且至少有一个副本处于活动状态，那么他将收到响应。 <br><br><h1> 节点如何工作？ </h1><br><img src="https://habrastorage.org/webt/2m/up/ob/2mupob-rqyqsbic50lc-qn2xwqe.png"><br><br> 节点是用户请求经过的一组阶段中的管道。 首先，请求转到外部API（我们通过HTTPS发送所有内容）。 然后验证请求-验证签名。 然后，如有必要，例如在购买曲目时，将构造IDv3标签。 请求进入路由阶段，在此阶段根据群集拓扑确定如何返回数据：当前节点是该轨道的副本，还是我们将从另一个节点进行代理。 在第二种情况下，节点通过代理客户端通过内部HTTP API建立与副本的连接，而无需验证签名。 副本会在本地存储中搜索数据，如果找到了磁道，则会从磁盘上将其提供给副本。 如果没有，它将从存储中提取曲目，缓存并提供。 <br><br><h1> 节点负载 </h1><br> 让我们估计一个节点在此配置中应承担的负载。 让我们有三个分别有四个节点的数据中心。 <br><br><img src="https://habrastorage.org/webt/in/-z/nz/in-znz1gekgg217y9oxdlm5pv-g.png"><br><br> 整个服务应服务于120 Gbit / s，即每个数据中心40 Gbit / s。 假设网络管理员进行了操作或发生了事故，并且剩下两个数据中心DC1和DC3。 现在它们每个都应该提供60 Gbit / s。 但是，这取决于开发人员进行一些更新，在每个数据中心中还剩3个活动节点，每个活动节点应提供20 Gbit / s的速度。 <br><br><img src="https://habrastorage.org/webt/6q/tc/sz/6qtcszoeoi4w1zjxvh_o1u35vni.png"><br><br> 但是最初在每个数据中心中有4个节点。 如果我们在数据中心中存储两个副本，则概率为50％，接收到请求的节点将不是所请求轨道的副本，而是将代理数据。 也就是说，代理了数据中心内部一半的流量。 <br><br><img src="https://habrastorage.org/webt/yi/aj/tc/yiajtck3angspynaidxuar_t5gm.png"><br><br> 因此，一个节点应为用户提供20 Gb / s。 其中，它从数据中心的邻居那里拉出10 Gb / s。 但是该方案是对称的：节点向数据中心的邻居提供相同的10 Gb / s。 事实证明，有30 Gbit / s的数据从节点中流出，其中20 Gbit / s本身应提供服务，因为它是所请求数据的副本。 此外，数据将来自磁盘或RAM，RAM包含约5万条“热”磁道。 根据我们的播放统计信息，这使您可以从磁盘上删除60-70％的负载，并且将保持大约8 Gb / s的速度。 该线程有能力交付十几个SSD。 <br><br><h1> 节点上的数据存储 </h1><br> 如果将每个轨道放在单独的文件中，那么管理这些文件的开销将是巨大的。 即使重新启动节点并扫描磁盘上的数据，也要花费数分钟甚至数十分钟。 <br><br> 这种方案的局限性不太明显。 例如，您只能从一开始就加载曲目。 而且，如果用户要求从中间播放并丢失了缓存，那么在将数据从轨道存储库加载到所需位置之前，我们将无法发送单个字节。 而且，即使它们是在第三分钟内退出收听的巨型有声读物，我们也只能存储整个轨道。 它将继续使磁盘承受自重，浪费昂贵的空间并减少该节点的缓存命中率。 <br><br> 因此，我们以完全不同的方式执行此操作：将磁道分为256 KB的块，因为这与SSD中的块大小相关，并且我们已经在使用这些块。  1 TB的磁盘包含400万个块。 节点中的每个磁盘都是一个独立的存储，并且每个磁道的所有块都分布在所有磁盘上。 <br><br> 我们没有立即采用这种方案，起初，一个磁道的所有块都放在一个磁盘上。 但这导致磁盘之间的负载严重失真，因为如果流行磁道碰到了其中一个磁盘，则所有对其数据的请求都将到达一个磁盘。 为避免这种情况，我们将每个磁道的块分布在所有磁盘上，以平衡负载。 <br><br> 此外，我们不会忘记我们拥有大量的RAM，但是我们决定不进行语义缓存，因为我们在Linux中拥有出色的页面缓存。 <br><br> 如何在磁盘上存储块？ <br><br> 首先，我们决定获取一个只有磁盘大小的巨型XFS文件，并将所有块放入其中。 然后这个想法就可以直接与块设备一起使用。 我们实现了这两种选择，并进行了比较，结果表明，直接与块设备一起使用时，记录速度提高了1.5倍，响应时间降低了2-3倍，系统总负载降低了2倍。 <br><br><h1> 索引 </h1><br> 但这还不足以存储块；您需要维护从音乐曲目块到磁盘上块的索引。 <br><br><img src="https://habrastorage.org/webt/me/4y/0b/me4y0bk_xbwco9r_5y6smyhmxmc.png"><br><br> 事实证明，它非常紧凑，一个索引条目仅占用29个字节。 对于10 TB的存储，索引略大于1 GB。 <br><br> 这里有一个有趣的观点。 在每个这样的记录中，您必须存储整个轨道的总大小。 这是反规范化的经典示例。 原因是，根据HTTP范围响应中的规范，我们必须返回资源的总大小，并形成Content-length标头。 如果不是这样，那么一切将更加紧凑。 <br><br> 我们对索引提出了一些要求：要快速工作（最好存储在RAM中），要紧凑且不占用页面缓存空间。 另一个索引应该是持久的。 如果丢失它，我们将丢失有关磁盘上哪个位置存储了哪个磁道的信息，这无异于清洁磁盘。 总的来说，我希望以某种方式取代长时间未使用的旧街区，以便为更流行的曲目腾出空间。 我们选择了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">LRU拥挤策略</a> ：每分钟强制删除一次块，我们保留1％的空闲块。 当然，索引结构必须是线程安全的，因为每个节点有10万个连接。 从我们的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">one-nio</a>开源库中的<code>SharedMemoryFixedMap</code>可以理想地满足所有这些条件。 <br><br> 我们将索引放在<code>tmpfs</code> ，它可以快速运行，但是有细微差别。 机器重新启动时， <code>tmpfs</code>上的所有内容（包括索引）都将丢失。 另外，如果由于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code> sun.misc.Unsafe</code></a>而使我们的进程崩溃，则尚不清楚该索引处于什么状态。 因此，我们每小时进行一次演员表投放。 但这还不够：由于我们使用块拉伸，因此我们必须支持<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">WAL</a> ，在其中可以编写有关拉伸块的信息。 在恢复期间，需要以某种方式对有关强制转换和WAL中的块的条目进行排序。 为此，我们使用生成块。 它扮演全局事务计数器的角色，并在每次索引更改时递增。 让我们看一个例子。 <br><br> 取得一个包含三个条目的索引：两个磁道1块和一个磁道2块。 <br><br><img src="https://habrastorage.org/webt/l6/ux/51/l6ux512_lbpedki0bb3g0ouggau.png"><br><br> 创建索引的流被此索引唤醒和迭代：第一个和第二个元组落入该索引。 然后，拥挤的流程转向索引，意识到很长一段时间未访问第七个块，并决定将其用于其他用途。 该过程将阻止该块，并将记录写入WAL。 他进入第9街区，看到他已经很长时间没有联系了，并且还把他标记为拥挤。 用户在这里访问系统，发生缓存未命中-请求我们没有的跟踪。 我们将此轨道的块保存在我们的存储库中，覆盖块9。 在这种情况下，世代增加并等于22。接下来，创建模具的过程被激活，该过程尚未完成其工作，到达最后一条记录并将其写入模具。 结果，索引中有两个实时记录，演员表和WAL。 <br><br><img src="https://habrastorage.org/webt/sy/vj/0_/syvj0_-kknmn4i5pulf_p8bclc4.png"><br><br> 当前节点掉落时，它将恢复索引的初始状态，如下所示。 首先，扫描WAL并构建脏块图。 该卡存储从该块编号到该块被替换时的代的映射。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9p/g5/gn/9pg5gn-8atbixm4swmytkscxwpm.png" width="300"></div><br><br> 之后，我们开始使用地图作为过滤器遍历模具。 我们看一下演员表的第一条记录，它与3号区块有关。 肮脏的人中没有提到他，这意味着他还活着并进入了指数。 我们在第18代中到达了第7块，但是肮脏的块图告诉我们，仅在第18代中，该块就被挤出了。 因此，它不属于索引。 我们到达最后一条记录，该记录描述了22代的块9的内容。 脏块图中提到了此块，但之前已将其替换。 因此，它可用于新数据并进入索引。 目标已实现。 <br><br><h1> 最佳化 </h1><br> 但这还不是全部，我们会深入探讨。 <br><br> 让我们从页面缓存开始。 我们最初指望它，但是当我们开始对第一个版本进行负载测试时， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">事实</a>证明页面缓存命中率未达到20％。 他们建议先解决该问题：在服务一堆连接的同时，我们不存储文件，而是存储块，在这种配置下，使用磁盘的效率是随机的。 我们几乎从不顺序阅读任何内容。 幸运的是，在Linux中，有一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>posix_fadvise</code></a>调用可以让您告诉内核我们将如何使用文件描述符-特别是，我们可以说不需要传递<code>POSIX_FADV_RANDOM</code>标志来进行<code>POSIX_FADV_RANDOM</code>读。 该系统调用可通过<a href="">one-nio进行</a> 。 在操作中，我们的缓存命中率为70-80％。 从磁盘读取的物理数据减少了2倍以上，HTTP响应延迟减少了20％。 <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们走得更远。</font><font style="vertical-align: inherit;">该服务具有相当大的堆大小。</font><font style="vertical-align: inherit;">为了简化处理器的TLB缓存，我们决定在Java流程中加入“大页面”。</font><font style="vertical-align: inherit;">结果，我们在垃圾回收时间上获得了可观的利润（GC时间/安全点总时间减少了20-30％），内核加载变得更加均匀，但是对HTTP延迟图没有任何影响。</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 突发事件 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">服务启动后不久，发生了唯一（到目前为止）事件。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">工作日结束后的一个晚上，有关播放音乐的抱怨得到了支持。用户写道，他们包括了自己喜欢的曲目，但是每隔几秒钟就会听到其他时间和其他民族发出的奇怪音乐，而播放器告诉他们这首曲是他们喜欢的曲目。很快，搜索范围缩小到了一辆车，这给了它一些奇怪的东西。我们从日志中发现它是最近重新启动的。为简化起见，我们有两个磁盘和索引来描述块的内容。一个索引指出，Daft Punk轨道的第四个块位于sdc磁盘的第2块中，而Stas Mikhailov轨道的零块位于sdd磁盘的零个块中。</font></font><br><br><img src="https://habrastorage.org/webt/9q/pu/9g/9qpu9gxbc-uph2jp7tsjkup4b5a.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">事实证明，重新启动计算机后，驱动器名称更改了位置，并随之而来。</font><font style="vertical-align: inherit;">此问题在Linux中是</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">众所周知的</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">：如果服务器中有多个磁盘控制器，则不能保证磁盘的命名顺序。</font></font><br><br><img src="https://habrastorage.org/webt/3s/y-/vm/3sy-vmtyncu3miiwjhzyu0j9xi4.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">解决方法很简单。</font><font style="vertical-align: inherit;">磁盘有几种不同类型的永久性ID。</font><font style="vertical-align: inherit;">我们</font><font style="vertical-align: inherit;">根据磁盘的序列号</font><font style="vertical-align: inherit;">使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">WWN</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并使用它们来识别索引，快照和WAL。</font><font style="vertical-align: inherit;">这并不排除磁盘本身的改组，但是无论它们如何改组，都不会违反磁盘上的索引映射，并且我们将始终提供正确的数据。</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 事件分析 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这样的分布式系统中，问题的分析是困难的，因为用户请求经历了许多阶段并且跨越了节点的边界。对于CDN，一切都会变得更加复杂，因为对于CDN，上游是家庭数据中心。会有很多这样的希望。而且，该系统为数十万个用户连接提供服务。很难理解在哪个阶段处理特定用户的请求时会出现问题。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们这样简化了我们的生活。在登录时，我们用类似于</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Open Tracing</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">Zipkin</font></a><font style="vertical-align: inherit;">的标签标记所有请求</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">标签包括用户的标识符，请求和请求的轨道。</font><font style="vertical-align: inherit;">流水线内的此标记与所有与当前连接有关的数据和请求一起发送，并且在节点之间作为HTTP头发送，并由接收方恢复。</font><font style="vertical-align: inherit;">当我们需要解决问题时，我们将打开调试，记录标记，查找与特定用户相关的所有记录或进行跟踪，进行汇总并找出整个集群如何处理请求。</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 传送资料 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">考虑从磁盘向套接字发送数据的典型方案。</font><font style="vertical-align: inherit;">似乎没有什么复杂的事情：选择缓冲区，从磁盘读取缓冲区，然后将缓冲区发送到套接字。</font></font><br><br><pre> <code class="java hljs">ByteBuffer buffer = ByteBuffer.allocate(size); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> count = fileChannel.read(buffer, position); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count &lt;= <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// ... } buffer.flip(); socketChannel.write(buffer);</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 这种方法的问题之一是此处隐藏了两个隐藏的数据副本： </font></font><br><br><ul><li>       <code>FileChannel.read()</code>    kernel space  user space; </li><li>            <code>SocketChannel.write()</code> ,    user space  kernel space. </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">幸运的是，Linux </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>sendfile()</code></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">中</font><font style="vertical-align: inherit;">有一个调用</font><font style="vertical-align: inherit;">，使您可以要求内核直接从特定偏移量将文件中的数据发送到套接字，而无需复制到用户空间。当然，可以通过</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one-nio进行</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">此调用</font><font style="vertical-align: inherit;">。在负载测试中，我们在一个节点上启动了用户流量，并从相邻节点强制代理，它们仅通过以下方式发送数据：使用</font></font><code>sendfile()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">时10 Gb / s的处理器负载</font></font><code>sendfile()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接近于0，</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是对于用户空间SSL套接字，我们无法利用优势</font></font><code>sendfile()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我们别无选择，只能通过缓冲区从文件发送数据。在这里，我们还有另一个惊喜。如果您深入研究源</font></font><code>SocketChannel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font></font><code>FileChannel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，或使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Async Profiler</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而在这样的返回数据的过程poprofilirovat系统，迟早你到了类</font></font><code>sun.nio.ch.IOUtil</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，其归结所有呼叫</font></font><code>read()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并</font></font><code>write()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在这些通道上。这样的代码隐藏在那里。</font></font><br><br><pre> <code class="java hljs">ByteBuffer bb = Util.getTemporaryDirectBuffer(dst.remaining()); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> n = readIntoNativeBuffer(fd, bb, position, nd); bb.flip(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) dst.put(bb); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> n; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { Util.offerFirstTemporaryDirectBuffer(bb); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是本地缓冲区的池。</font><font style="vertical-align: inherit;">当从堆中的文件中</font></font><code>ByteBuffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">读取数据时，标准库首先从该池中获取一个缓冲区，将数据读入其中，然后将其复制到您的堆中</font></font><code>ByteBuffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，然后将本机缓冲区返回到该池中。</font><font style="vertical-align: inherit;">写入套接字时，会发生相同的事情。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">有争议的方案。</font><font style="vertical-align: inherit;">在这里，</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一位尼奥</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">再次来营救</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们创建一个分配器</font></font><code>MallocMT</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-实际上，这是一个内存池。</font><font style="vertical-align: inherit;">如果我们有SSL，并且我们被迫通过缓冲区发送数据，则选择Java堆之外的缓冲区，将其包装</font></font><code>ByteBuffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，从</font></font><code>FileChannel</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">该缓冲区</font><font style="vertical-align: inherit;">读取而不进行额外复制，</font><font style="vertical-align: inherit;">然后写入套接字。</font><font style="vertical-align: inherit;">然后，我们将缓冲区返回给分配器。</font></font><br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> Allocator allocator = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MallocMT(size, concurrency); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Socket socket)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (socket.getSslContext() != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> address = allocator.malloc(size); ByteBuffer buf = DirectMemory.wrap(address, size); <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> available = channel.read(buf, offset); socket.writeRaw(address, available, flags);</code> </pre><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 每个节点100,000个连接 </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，在较低级别上的合理实施并不能保证系统的成功。这里还有另一个问题。每个节点上的传送器最多可服务10万个同时连接。如何在这样的系统中组织计算？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">首先想到的是为每个客户端或连接创建执行线程，然后在其中依次执行管道阶段。如有必要，请阻塞，然后继续前进。但是，使用这种方案，上下文切换和流堆栈的成本将过高，因为我们正在谈论分发者，并且有很多流。因此，我们走了另一条路。</font></font><br><br><img src="https://habrastorage.org/webt/mt/vg/eo/mtvgeoszcpcv6zpc-qi_rbqeyhy.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为每个连接创建一个逻辑管道，该逻辑管道包括彼此异步交互的各个阶段。每个阶段都有一个转弯，用于存储传入的请求。对于阶段的执行，使用小型公共线程池。如果您需要处理请求队列中的消息，我们将从池中获取一个流，处理该消息，然后将流返回到池中。使用此方案，数据从存储推送到客户端。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是这样的方案并非没有缺陷。后端比用户连接快得多。当数据通过管道时，它以最慢的速度累积，即在将块写入客户端连接套接字的阶段。迟早，这将导致系统崩溃。如果您尝试在这些阶段限制队列，那么所有内容都会立即停止，因为到用户套接字的链中的管道将被阻塞。并且由于它们使用共享线程池，因此它们将阻塞其中的所有线程。需要背压。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为此，我们使用</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">喷射流</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。该方法的本质是订阅者使用需求来控制来自发布者的数据速度。需求是指订户准备处理多少数据以及已经发出信号的先前需求。发布者有权发送数据，但目前不超过已累积的总需求减去已发送的数据。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">因此，系统在推拉模式之间动态切换。</font><font style="vertical-align: inherit;">在推送模式下，订阅者比发布者快，这意味着发布者始终对订阅者的需求不满意，但没有数据。</font><font style="vertical-align: inherit;">数据一出现，他就立即将其发送给订户。</font><font style="vertical-align: inherit;">当发布者比订阅者快时，将出现拉模式。</font><font style="vertical-align: inherit;">也就是说，发布者乐于发送数据，只有需求为零。</font><font style="vertical-align: inherit;">订阅者说准备好进行更多处理后，发布者会立即向其发送一部分数据，作为需求的一部分。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们的输送机变成喷射流。</font><font style="vertical-align: inherit;">每个阶段都将成为上一个阶段的发布者和下一个阶段的订阅者。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">射流的界面看起来非常简单。</font></font><code>Publisher</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">让我们签名</font></font><code>Subscriber</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ，他只应实现四个处理程序： </font></font><br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Publisher</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscriber&lt;? </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">super</span></span></span></span><span class="hljs-function"><span class="hljs-params"> T&gt; s)</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscriber</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onSubscribe</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Subscription s)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onNext</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T t)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onError</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Throwable t)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onComplete</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Subscription</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cancel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre> <br> <code>Subscription</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 使您可以发出需求信号并取消订阅。 </font></font>没有地方比这容易。 <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作为数据元素，我们不传递字节数组，而是传递诸如块的抽象。</font><font style="vertical-align: inherit;">我们这样做是为了尽可能不拖出堆中的数据。</font><font style="vertical-align: inherit;">块是具有非常有限的接口的数据链接，仅允许您将数据读入</font></font><code>ByteBuffer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，写入套接字或文件。</font></font><br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Chunk</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ByteBuffer dst)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Socket socket)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(FileChannel channel, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset)</span></span></span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 块有许多实现： </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">最流行的一种实现是在top上，在发生高速缓存命中以及从磁盘发送数据时使用</font></font><code>RandomAccessFile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">块仅包含文件链接，此文件中的偏移量和数据大小。</font><font style="vertical-align: inherit;">它遍历整个管道，到达用户连接套接字，然后在那里变成call </font></font><code>sendfile()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">也就是说，根本不消耗内存。</font></font></li><li>   cache miss   :             .     , —  ,     , —      . </li><li> ,    -      heap.        <code>ByteBuffer</code> . </li></ul><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">尽管此API简单，但按规范它应该是线程安全的，并且大多数方法应该是非阻塞的。</font><font style="vertical-align: inherit;">我们</font><font style="vertical-align: inherit;">从</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">官方</font></a><font style="vertical-align: inherit;">演员</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">流</font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">存储库中的</font></a></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">示例中</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">汲取灵感，选择了类型演员模型的精神来选择这条道路</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">为了使方法调用成为非阻塞方法，在调用方法时，我们将获取所有参数，将其包装在消息中，将其放入队列中以执行，然后返回控制权。</font><font style="vertical-align: inherit;">来自队列的消息将严格按顺序处理。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">没有同步，代码简单明了。</font></font></b> <div class="spoiler_text"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">状态仅由三个字段描述。</font><font style="vertical-align: inherit;">每个发布者或订阅者都有一个收集传入消息的邮箱，以及一个在这种类型的所有阶段之间划分的执行程序。</font></font><code>AtomicBoolean</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">提供在连续的唤醒之间发生。</font></font><br><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// Incoming messages final Queue&lt;M&gt; mailbox; // Message processing works here final Executor executor; // To ensure HB relationship between runs final AtomicBoolean on = new AtomicBoolean();</span></span></code> </pre> <br>    : <br><br><pre> <code class="java hljs"><span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">request</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> n)</span></span></span><span class="hljs-function"> </span></span>{ enqueue(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Request(n)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">enqueue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">final</span></span></span></span><span class="hljs-function"><span class="hljs-params"> M message)</span></span></span><span class="hljs-function"> </span></span>{ mailbox.offer(message); tryScheduleToExecute(); }</code> </pre> <br>  <code>tryScheduleToExecute()</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (on.compareAndSet(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { executor.execute(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (Exception e) { ... } }</code> </pre> <br>  <code>run()</code> : <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (on.get()) <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { dequeueAndProcess(); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { on.set(<span class="hljs-keyword"><span class="hljs-keyword">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!messages.isEmpty()) { tryScheduleToExecute(); } } }</code> </pre> <br>  <code>dequeueAndProcess()</code> : <br><br><pre> <code class="java hljs">M message; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> ((message = mailbox.poll()) != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { <span class="hljs-comment"><span class="hljs-comment">// Pattern match if (message instanceof Request) { doRequest(((Request) message).n); } else { … } }</span></span></code> </pre> </div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们得到了一个完全非阻塞的实现。</font><font style="vertical-align: inherit;">代码简单而一致的，没有</font></font><code>volatile</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><code>Atomic*</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，争，等等。</font><font style="vertical-align: inherit;">在我们的整个系统中，总共有200个线程可以服务100,000个连接。</font></font><br><br><h1> 最后 </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在生产中，我们有12台机器，而带宽却超过了两倍。正常模式下，每台计算机通过数十万个连接可提供高达10 Gbit / s的速度。我们提供了可伸缩性和弹性。一切都用Java和</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">one-nio</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">编写</font><font style="vertical-align: inherit;">。</font></font><br><br><img src="https://habrastorage.org/webt/oa/pz/cq/oapzcqjf6y9ccxrnk1wzrpaigdy.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这是一个图形，直到从服务器端给用户的第一个字节为止。 99％小于20 ms。蓝色图是HTTPS数据返回给用户的信息。红色图是通过</font></font><code>sendfile()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">HTTP </font><font style="vertical-align: inherit;">从副本到代理的数据返回</font><font style="vertical-align: inherit;">。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">实际上，生产中的高速缓存命中率为97％，因此这些图描述了跟踪存储库的延迟，考虑到PB的数据量，在高速缓存未命中的情况下我们从中提取数据，这也不错。</font></font><br><br><img src="https://habrastorage.org/webt/xp/fd/eq/xpfdequddx6cnglrzrgdxtbspuc.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果从磁盘返回时查看第75个百分位数，则第一个字节将在1毫秒后飞向用户。</font><font style="vertical-align: inherit;">集群内部的副本以更高的速度通信-它们负责300μs。</font></font>即<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">代理成本为0.7毫秒。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在本文中，我们想演示如何构建可扩展的，高负载的系统，该系统既具有高速又具有出色的容错能力。</font><font style="vertical-align: inherit;">希望我们成功。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN434206/">https://habr.com/ru/post/zh-CN434206/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN434194/index.html">爱丽丝的技能发展。 语音界面经验，初学者提示</a></li>
<li><a href="../zh-CN434196/index.html">3CX v16 Alpha 2和新的计划</a></li>
<li><a href="../zh-CN434198/index.html">根据个人经验选择Web服务器操作模式</a></li>
<li><a href="../zh-CN434200/index.html">铁锈涂得这么可怕吗</a></li>
<li><a href="../zh-CN434202/index.html">关于如何不丢掉数据科学工作的4个秘诀</a></li>
<li><a href="../zh-CN434208/index.html">如何拯救我们的黑色星期五</a></li>
<li><a href="../zh-CN434210/index.html">HeadHunter站在Mobius 2018莫斯科的Android测验竞赛分析</a></li>
<li><a href="../zh-CN434212/index.html">特斯拉大厦。 雷电击中摩天大楼附近时，会发生什么？</a></li>
<li><a href="../zh-CN434214/index.html">Java动态代理：它是什么以及如何使用？</a></li>
<li><a href="../zh-CN434216/index.html">使用Kali Linux的暴力攻击</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>