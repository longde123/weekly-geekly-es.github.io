<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöè üöµüèº üîü OpenSceneGraph: Integration mit dem Qt Framework üòù üöâ üòá</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Einf√ºhrung 
 Einerseits verf√ºgt die OpenSceneGraph-Engine selbst √ºber ein erweitertes Subsystem zum Verwalten von Fenstern, zum Verarbeiten von Benutz...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenSceneGraph: Integration mit dem Qt Framework</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438654/"><img src="https://habrastorage.org/webt/py/ks/3w/pyks3wlvjf_zfef-sqocutbnimk.jpeg"><br><br><h1>  Einf√ºhrung </h1><br>  Einerseits verf√ºgt die OpenSceneGraph-Engine selbst √ºber ein erweitertes Subsystem zum Verwalten von Fenstern, zum Verarbeiten von Benutzereingabeereignissen sowie zum Senden und Empfangen von Benutzernachrichten.  Wir haben in fr√ºheren Artikeln dieser Reihe ausf√ºhrlich dar√ºber gesprochen.  Im Allgemeinen reicht dies zusammen mit den Funktionen von C ++ / STL v√∂llig aus, um beliebig komplexe Anwendungen zu entwickeln. <br><br>  <i>Ein Beispiel f√ºr die Integration von OSG in eine von QtDesigner entwickelte Anwendung.</i>  <i>Dieses Beispiel wird nachstehend ausf√ºhrlich erl√§utert.</i> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/1LWLSxAUWwU" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Um die Entwicklung in C ++ zu beschleunigen, werden sowohl Bibliotheken von Drittanbietern verwendet, die die Funktionen dieser Sprache erweitern (z. B. Boost), als auch ganze Frameworks, die die Entwicklung plattform√ºbergreifender Anwendungen mit breitem Funktionszweck vereinfachen.  Ein solches Framework ist das √§u√üerst beliebte Qt.  Unabh√§ngig davon, wie sie Qt f√ºr seinen Metaobjekt-Compiler und andere M√§ngel und Unannehmlichkeiten beschimpft haben, liegt die St√§rke von Qt in einer umfangreichen Klassenbibliothek, die alle denkbaren Aufgaben der plattform√ºbergreifenden Entwicklung l√∂st, sowie im Konzept der "Signale - Slots", die das Messaging-Subsystem zwischen Klassen implementieren.  Die Signale und Slots basieren auch auf den Interaktionsmethoden zwischen der Anwendung und dem Betriebssystem sowie auf der Interprozesskommunikation. <br><br>  Und zum Teufel, es w√§re sehr interessant, zwei Technologien zu kombinieren: Qt und OSG.  Mein Team musste ein √§hnliches Problem l√∂sen, √ºber das ich bereits in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einer meiner Ver√∂ffentlichungen geschrieben habe</a> .  Ich m√∂chte diese Frage jedoch etwas weiter √∂ffnen, und dieser Artikel wird sich mit diesem Thema befassen. <br><a name="habracut"></a><br>  Es gibt zwei M√∂glichkeiten, OSG und Qt zu integrieren: <br><br><ol><li>  Verwenden von Qt-Signalen und -Slots zum Interagieren von Objekten in einer OSG-Anwendung <br></li><li>  Integration des OSG-Viewers in eine in C ++ / Qt entwickelte grafische Oberfl√§che, einschlie√ülich der Verwendung des QtDesigner-Formulardesigners <br></li></ol><br>  Die erste Option ist anwendbar, wenn Sie die von Qt bereitgestellten GUI-Elemente nicht verwenden m√ºssen, aber die Interaktion von Anwendungskomponenten √ºber Signale und Slots sicherstellen m√∂chten.  Beispielsweise bestand f√ºr mich die Notwendigkeit, eine OSG-Anwendung mit einer Interprozess-Kommunikationsbibliothek √ºber TCP-Sockets unter Verwendung von Qt zu integrieren. <br><br>  Die zweite Option wird ben√∂tigt, wenn die Integration der OSG-Engine und eine mit Qt entwickelte grafische Anwendung erforderlich sind.  Signale und Slots stehen uns zur Verf√ºgung, und zus√§tzlich dazu die gesamte Palette standardisierter GUI-Elemente, die von Qt bereitgestellt werden. <br><br><h1>  1. Qt-Signale in einem OSG-Fenstersystem </h1><br>  Das erste Beispiel wird etwas synthetisch sein: Wir schreiben eine einfache OSG-Anwendung mit einer primitiven Szene;  Erstellen Sie zwei Klassen, von denen eine Tastenanschl√§ge verarbeitet und die andere der Konsole eine Meldung dar√ºber anzeigt, welche Taste gedr√ºckt wird.  In diesem Fall generiert der Handler ein Qt-Signal mit einer Meldung √ºber die gedr√ºckte Taste als Parameter. <br><br>  Um sich in Qt zu integrieren, reicht es aus, die folgenden drei Bedingungen zu erf√ºllen <br><br><ol><li>  Erben Sie interagierende Klassen von QObject <br></li><li>  Organisieren Sie eine Signalverarbeitungsschleife <br></li><li>  Erstellen Sie eine Instanz der Klasse QApplication (oder QCoreApplication), die w√§hrend des Anwendungsvorgangs im Speicher vorhanden ist <br></li></ol><br>  Den vollst√§ndigen Beispielcode finden Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">meinem OSG-Unterrichts-Repository</a> , das alle Lektionen f√ºr diesen Zyklus enth√§lt. <br><br>  Erstellen Sie zun√§chst eine Klasse, die die Signalverarbeitungswarteschlange "verdreht". <br><br>  <strong>qt-events.h</strong> <br><br><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> QT_EVENTS_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> QT_EVENTS_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgGA/GUIEventHandler&gt; #include &lt;QCoreApplication&gt; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class QtEventsHandler : public osgGA::GUIEventHandler { public: QtEventsHandler(); virtual bool handle(const osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa); protected: }; #endif // QT_EVENTS_H</span></span></span></span></code> </pre> <br>  <strong>qt-events.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"qt-events.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ QtEventsHandler::QtEventsHandler() { } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ bool QtEventsHandler::handle(const osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa) { Q_UNUSED(aa) switch (ea.getEventType()) { case osgGA::GUIEventAdapter::FRAME: { // Process qt signals and event QCoreApplication::processEvents(QEventLoop::AllEvents); break; } default: break; } return false; }</span></span></span></span></code> </pre><br>  Alles ist sehr einfach - diese Klasse ist ein Standard-OSG-Ereignishandler, der beim Rendern eines Frames die Verarbeitung der Qt-Signalwarteschlange durch Aufrufen initiiert <br><br><pre> <code class="cpp hljs">QCoreApplication::processEvents(QEventLoop::AllEvents);</code> </pre><br>  Erstellen wir nun eine Klasse, die die Tastatur erneut mithilfe des in OSG integrierten Mechanismus verarbeitet, aber dennoch ein Qt-Signal senden kann.  Zu diesem Zweck verwenden wir die k√ºrzlich anathematisierte Mehrfachvererbung <br><br>  <strong>keyhandler.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> KEY_HANDLER_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> KEY_HANDLER_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgGA/GUIEventHandler&gt; #include &lt;QObject&gt; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class KeyboardHandler : public QObject, public osgGA::GUIEventHandler { Q_OBJECT public: KeyboardHandler(QObject *parent = Q_NULLPTR) : QObject(parent) , osgGA::GUIEventHandler () { } bool handle(const osgGA::GUIEventAdapter &amp;ea, osgGA::GUIActionAdapter &amp;aa) { switch (ea.getEventType()) { case osgGA::GUIEventAdapter::KEYDOWN: emit sendMessage("Pressed key " + QString(ea.getKey())); break; default: break; } return false; } signals: void sendMessage(QString msg); private: }; #endif // KEY_HANDLER_H</span></span></span></span></code> </pre><br>  Die Klasse verarbeitet eine Nachricht √ºber eine gedr√ºckte Taste und sendet ein Signal mit einer Nachricht, die den Tastencode enth√§lt.  Dieses Signal wird von einer Klasse empfangen, die in keiner Weise mit OSG verbunden ist, einem Nachkommen von QObject, das einen einzelnen Steckplatz enth√§lt, der eine Nachricht an die Standardausgabe druckt <br><br>  <strong>Empf√§nger.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> RECEIVER_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> RECEIVER_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QObject&gt; #include &lt;iostream&gt; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class Receiver : public QObject { Q_OBJECT public: Receiver(QObject *parent = Q_NULLPTR) : QObject(parent) {} public slots: void printMessage(QString msg) { std::cout &lt;&lt; msg.toStdString() &lt;&lt; std::endl; } }; #endif // RECEIVER_H</span></span></span></span></code> </pre><br>  F√ºgen Sie nun alles zusammen, indem Sie eine OSG-Anwendung schreiben <br><br>  <strong>main.h</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAIN_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgViewer/Viewer&gt; #include &lt;osgDB/ReadFile&gt; #include &lt;QCoreApplication&gt; #include "qt-events.h" #include "keyhandler.h" #include "receiver.h" #endif</span></span></span></span></code> </pre><br>  <strong>main.cpp</strong> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"main.h"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ int main(int argc, char *argv[]) { QCoreApplication app(argc, argv); osg::ref_ptr&lt;osg::Node&gt; scene = osgDB::readNodeFile("../data/cessnafire.osg"); osgViewer::Viewer viewer; viewer.setSceneData(scene.get()); viewer.addEventHandler(new QtEventsHandler); viewer.setUpViewInWindow(0, 0, 1024, 768); KeyboardHandler *keyboardHandler = new KeyboardHandler; Receiver *receiver = new Receiver; QObject::connect(keyboardHandler, &amp;KeyboardHandler::sendMessage, receiver, &amp;Receiver::printMessage); viewer.addEventHandler(keyboardHandler); return viewer.run(); }</span></span></span></span></code> </pre><br>  Zun√§chst erstellen wir eine Instanz der QCoreApplication-Klasse. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">QCoreApplication </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">app</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(argc, argv)</span></span></span></span>;</code> </pre><br>  Dies ist erforderlich, damit die beschriebene Technologie funktioniert.  Die <em>QCoreApplication :: exec () -Methode wird jedoch nicht aufgerufen</em> !  Stattdessen dreht sich die Signalverarbeitungsschleife in unserer osgViewer :: Viewer :: run () -Schleife, f√ºr die wir den entsprechenden Handler erstellen und registrieren <br><br><pre> <code class="cpp hljs">viewer.addEventHandler(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QtEventsHandler);</code> </pre><br>  Wir erstellen Instanzen von Klassen, die √ºber Qt-Signale interagieren und das Signal der einen mit dem Schlitz der anderen verbinden <br><br><pre> <code class="cpp hljs">KeyboardHandler *keyboardHandler = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> KeyboardHandler; Receiver *receiver = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Receiver; QObject::connect(keyboardHandler, &amp;KeyboardHandler::sendMessage, receiver, &amp;Receiver::printMessage);</code> </pre><br>  Registrieren Sie den Tastaturhandler <br><br><pre> <code class="cpp hljs">viewer.addEventHandler(keyboardHandler);</code> </pre><br>  Alle f√ºhren den Viewer aus <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> viewer.run();</code> </pre><br>  und so ein Bild sehen <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/HKJJb0cMl7I" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Ja, das Beispiel ist etwas erfunden, aber es zeigt die Hauptprinzipien der Integration von Code mithilfe von Qt-Mechanismen in eine Anwendung mithilfe von OSG.  Diese Idee, die aus dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenSceneGraph 3.-Kochbuch stammt</a> , hat mir und meinem Entwicklungsteam viel Zeit und Nerven gespart und mir erm√∂glicht, ein Qt-basiertes Modul zu verwenden, das in unserer Codebasis in unserer Codebasis debuggt und standardisiert wurde. <br><br>  Aber was ist, wenn wir OSG weiterhin in einer Qt-GUI-Anwendung verwenden m√∂chten? <br><br><h1>  2. osgQt Bibliothek </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">osgQt</a> ist eine Integrationsbibliothek f√ºr: <br><br><ol><li>  Einbetten einer in OSG implementierten 3D-Szene in die grafische Oberfl√§che einer auf Qt entwickelten Anwendung </li><li>  Einbetten von Qt-Widgets in eine 3D-Geometrieoberfl√§che innerhalb einer OSG-Szene.  Ja, Sie haben richtig geh√∂rt - Qt-Widgets k√∂nnen in der virtuellen Welt leise arbeiten.  Eines Tages werde ich es definitiv demonstrieren </li></ol><br>  Es gab bestimmte Probleme mit dieser Bibliothek, die wir √ºberwinden konnten, indem wir die beigef√ºgten Beispiele sorgf√§ltig studierten und das bereits erw√§hnte <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenSceneGraph 3. Kochbuch</a> lasen <br><br>  Die Bibliothek sollte zusammengebaut werden, und dieser Vorgang √§hnelt dem Zusammenbau des Motors selbst, der im allerersten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel des Zyklus</a> ausf√ºhrlich beschrieben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wird</a> .  Die einzige Bemerkung ist, dass -DCMAKE_INSTALL_PREFIX mit demselben ausgew√§hlt werden sollte, der beim Erstellen der Engine angegeben wurde. Daher wird osgQt neben der Engine installiert und kann w√§hrend der Entwicklung bequem verwendet werden. <br><br><h1>  3. Integration von osgViewer :: Viewer in die Qt-GUI </h1><br>  Das folgende Beispiel ist sehr n√ºtzlich.  Wir werden einen Viewer schreiben, mit dem Sie Modelle im * .osg-Format mit Standard-Qt-Steuerelementen laden k√∂nnen.  Dar√ºber hinaus verwenden wir zur Entwicklung einer grafischen Oberfl√§che QtDeisgner. <br><br>  Lassen Sie uns ein neues Projekt wie "Qt Widgets Application" erstellen. <br><br><img src="https://habrastorage.org/webt/hk/t5/sj/hkt5sjllzcuqyfyfm08ugnag0bw.png"><br><br>  In diesem Fall wird das Hauptanwendungsfenster mit einer Men√ºleiste, einer Symbolleiste und einer Statusleiste generiert.  F√ºgen Sie in QtDesigner diesem Fenster eine QFrame-Komponente hinzu. <br><br> <a href=""><img src="https://habrastorage.org/webt/ek/4r/8c/ek4r8can5b5v63ex03jbw0v4czu.png"></a> <br><br>  Wir werden den OSG-Viewer in diesem Rahmen platzieren.  Der OSG-Viewer wird im Wesentlichen ein Qt-Widget sein. F√ºr seine Implementierung schreiben wir die QViewerWidget-Klasse.  Ich werde die vollst√§ndigen Quellen auf den Spoiler setzen, um die Pr√§sentation nicht mit Codebl√§ttern zu verwischen <br><br><div class="spoiler">  <b class="spoiler_title">qviewerwidget.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> QVIEWER_WIDGET_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> QVIEWER_WIDGET_H #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;QWidget&gt; #include &lt;osgViewer/Viewer&gt; #include &lt;osgQt/GraphicsWindowQt&gt; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ class QViewerWidget : public QWidget { public: QViewerWidget(const QRect &amp;geometry); virtual ~QViewerWidget(); osg::Group *getScene(); osgViewer::Viewer *getViewer(); protected: osg::ref_ptr&lt;osg::Group&gt; scene; osgViewer::Viewer viewer; private: osgQt::GraphicsWindowQt *createGraphicsWindow(const QRect &amp;geometry); void initCamera(const QRect &amp;geometry); void paintEvent(QPaintEvent *); }; #endif // QVIEWER_WIDGET_H</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">qviewerwidget.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs">include <span class="hljs-string"><span class="hljs-string">"qviewerwidget.h"</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgViewer/ViewerEventHandlers&gt; #include &lt;osgGA/TrackballManipulator&gt; #include &lt;QGridLayout&gt; //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ QViewerWidget::QViewerWidget(const QRect &amp;geometry) : QWidget() , scene(new osg::Group) { initCamera(geometry); viewer.setSceneData(scene); viewer.addEventHandler(new osgViewer::StatsHandler); viewer.setCameraManipulator(new osgGA::TrackballManipulator); viewer.setThreadingModel(osgViewer::Viewer::SingleThreaded); osgQt::GraphicsWindowQt *gw = static_cast&lt;osgQt::GraphicsWindowQt *&gt;(viewer.getCamera()-&gt;getGraphicsContext()); QGridLayout *layout = new QGridLayout; if (layout != Q_NULLPTR) { layout-&gt;addWidget(gw-&gt;getGLWidget()); this-&gt;setLayout(layout); } } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ QViewerWidget::~QViewerWidget() { } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osg::Group *QViewerWidget::getScene() { return scene.get(); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osgViewer::Viewer *QViewerWidget::getViewer() { return &amp;viewer; } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ osgQt::GraphicsWindowQt *QViewerWidget::createGraphicsWindow(const QRect &amp;geometry) { osg::DisplaySettings *ds = osg::DisplaySettings::instance().get(); osg::ref_ptr&lt;osg::GraphicsContext::Traits&gt; traits = new osg::GraphicsContext::Traits; traits-&gt;windowName = ""; traits-&gt;windowDecoration = false; traits-&gt;x = geometry.x(); traits-&gt;y = geometry.y(); traits-&gt;width = geometry.width(); traits-&gt;height = geometry.height(); if (traits-&gt;height == 0) traits-&gt;height = 1; traits-&gt;doubleBuffer = true; traits-&gt;alpha = ds-&gt;getMinimumNumAlphaBits(); traits-&gt;stencil = ds-&gt;getMinimumNumStencilBits(); traits-&gt;sampleBuffers = ds-&gt;getMultiSamples(); traits-&gt;samples = ds-&gt;getNumMultiSamples(); return new osgQt::GraphicsWindowQt(traits.get()); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void QViewerWidget::initCamera(const QRect &amp;geometry) { osg::Camera *camera = viewer.getCamera(); osg::ref_ptr&lt;osgQt::GraphicsWindowQt&gt; gw = createGraphicsWindow(geometry); gw-&gt;setTouchEventsEnabled(true); camera-&gt;setGraphicsContext(gw.get()); const osg::GraphicsContext::Traits *traits = gw-&gt;getTraits(); camera-&gt;setClearColor(osg::Vec4(0.7f, 0.7f, 0.7f, 1.0f)); camera-&gt;setViewport(0, 0, traits-&gt;width, traits-&gt;height); double aspect = static_cast&lt;double&gt;(traits-&gt;width) / static_cast&lt;double&gt;(traits-&gt;height); camera-&gt;setProjectionMatrixAsPerspective(30.0, aspect, 1.0, 1000.0); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void QViewerWidget::paintEvent(QPaintEvent *) { viewer.frame(); }</span></span></span></span></code> </pre><br></div></div><br>  Die Hauptidee der Implementierung ist die Verwendung der osgQt :: GraphicsWindow-Klasse, die ein Grafikfenster basierend auf der QGLWidget-Klasse erstellt.  Verwenden Sie die Methode, um dieses Fenster zu erstellen <br><br><pre> <code class="cpp hljs">osgQt::GraphicsWindowQt *QViewerWidget::createGraphicsWindow(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QRect &amp;geometry) { osg::DisplaySettings *ds = osg::DisplaySettings::instance().get(); osg::ref_ptr&lt;osg::GraphicsContext::Traits&gt; traits = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::GraphicsContext::Traits; traits-&gt;windowName = <span class="hljs-string"><span class="hljs-string">""</span></span>; traits-&gt;windowDecoration = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; traits-&gt;x = geometry.x(); traits-&gt;y = geometry.y(); traits-&gt;width = geometry.width(); traits-&gt;height = geometry.height(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (traits-&gt;height == <span class="hljs-number"><span class="hljs-number">0</span></span>) traits-&gt;height = <span class="hljs-number"><span class="hljs-number">1</span></span>; traits-&gt;doubleBuffer = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; traits-&gt;alpha = ds-&gt;getMinimumNumAlphaBits(); traits-&gt;stencil = ds-&gt;getMinimumNumStencilBits(); traits-&gt;sampleBuffers = ds-&gt;getMultiSamples(); traits-&gt;samples = ds-&gt;getNumMultiSamples(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osgQt::GraphicsWindowQt(traits.get()); }</code> </pre><br>  Das Fenster wird gem√§√ü den an die Eingabe √ºbertragenen Geometrieparametern und den erforderlichen Einstellungen des OSG 3D-Renderings konfiguriert.  Der zur√ºckgegebene Zeiger ist der OSG-Grafikkontext, der an die Kamera √ºbergeben werden soll.  Daher besteht der n√§chste Schritt darin, die Kamera zu initialisieren <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QViewerWidget::initCamera(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QRect &amp;geometry) { osg::Camera *camera = viewer.getCamera(); osg::ref_ptr&lt;osgQt::GraphicsWindowQt&gt; gw = createGraphicsWindow(geometry); gw-&gt;setTouchEventsEnabled(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); camera-&gt;setGraphicsContext(gw.get()); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> osg::GraphicsContext::Traits *traits = gw-&gt;getTraits(); camera-&gt;setClearColor(osg::Vec4(<span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">0.7f</span></span>, <span class="hljs-number"><span class="hljs-number">1.0f</span></span>)); camera-&gt;setViewport(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, traits-&gt;width, traits-&gt;height); <span class="hljs-keyword"><span class="hljs-keyword">double</span></span> aspect = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(traits-&gt;width) / <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;(traits-&gt;height); camera-&gt;setProjectionMatrixAsPerspective(<span class="hljs-number"><span class="hljs-number">30.0</span></span>, aspect, <span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">1000.0</span></span>); }</code> </pre><br>  Der eigentliche Anruf <br><br><pre> <code class="cpp hljs">camera-&gt;setGraphicsContext(gw.get());</code> </pre><br>  und √ºbergibt den gew√ºnschten Kontext, der dem QGLWidget-Widget zugeordnet ist, an die Kamera.  Wir haben die gesamte Widget-Routine in den Klassenkonstruktor eingef√ºgt <br><br><pre> <code class="cpp hljs">QViewerWidget::QViewerWidget(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> QRect &amp;geometry) : QWidget() , scene(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osg::Group) { initCamera(geometry); viewer.setSceneData(scene); viewer.addEventHandler(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osgViewer::StatsHandler); viewer.setCameraManipulator(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osgGA::TrackballManipulator); viewer.setThreadingModel(osgViewer::Viewer::SingleThreaded); osgQt::GraphicsWindowQt *gw = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osgQt::GraphicsWindowQt *&gt;(viewer.getCamera()-&gt;getGraphicsContext()); QGridLayout *layout = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QGridLayout; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (layout != Q_NULLPTR) { layout-&gt;addWidget(gw-&gt;getGLWidget()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;setLayout(layout); } }</code> </pre><br>  Hier konfigurieren wir den Viewer und achten besonders auf die Herausforderung <br><br><pre> <code class="cpp hljs">viewer.setThreadingModel(osgViewer::Viewer::SingleThreaded);</code> </pre><br>  Umschalten des Viewers in den Single-Threaded-Modus.  Dies ist eine notwendige Ma√ünahme bei der Integration von OSG in Qt, da das Programm bei einigen Linux-Distributionen abst√ºrzt, wenn das von OSG standardm√§√üig verwendete Multithread-Rendering verwendet wird.  Die Gr√ºnde hierf√ºr erfordern eine separate Nachbesprechung. Beachten Sie daher diesen Code <br><br><pre> <code class="cpp hljs">osgQt::GraphicsWindowQt *gw = <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;osgQt::GraphicsWindowQt *&gt;(viewer.getCamera()-&gt;getGraphicsContext()); QGridLayout *layout = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QGridLayout; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (layout != Q_NULLPTR) { layout-&gt;addWidget(gw-&gt;getGLWidget()); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;setLayout(layout); }</code> </pre><br>  In diesem Bereich erstellen wir eine Ebene, die ein vom Grafikkontext der Kamera zur√ºckgegebenes QGLWidget st√∂rt und in einen osgQt :: GraphicsWindows-Zeiger konvertiert wird.  Wir f√ºgen die erstellte Ebene unserem Widget QViewerWidget durch Aufrufen hinzu <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;setLayout(layout);</code> </pre><br>  Damit unser Widget und damit die Szene aktualisiert werden, wenn das Fenster aktualisiert wird, m√ºssen Sie den QPaintEvent-Ereignishandler neu definieren <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> QViewerWidget::paintEvent(QPaintEvent *) { viewer.frame(); }</code> </pre><br>  In diesem Fall initiieren wir das Rendern des Frames durch Aufrufen der Methode osgViewer :: Viewer :: frame (). <br><br>  Ok, der Code unseres Widgets ist fertig, jetzt binden wir ihn in einen Rahmen ein, der sich auf dem Formular befindet.  Dazu schreiben wir im Konstruktor der MainWindow-Klasse solchen Code <br><br><pre> <code class="cpp hljs">MainWindow::MainWindow(QWidget *parent) : QMainWindow(parent) , ui(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Ui::MainWindow) , qviewer(Q_NULLPTR) { ui-&gt;setupUi(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); QGridLayout *layout = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QGridLayout; qviewer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QViewerWidget(QRect(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, ui-&gt;frame-&gt;width(), ui-&gt;frame-&gt;height())); layout-&gt;addWidget(qviewer); ui-&gt;frame-&gt;setLayout(layout); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;setCentralWidget(ui-&gt;frame); connect(&amp;timer, &amp;QTimer::timeout, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;MainWindow::update); timer.start(<span class="hljs-number"><span class="hljs-number">40</span></span>); connect(ui-&gt;actionQuit, &amp;QAction::triggered, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;MainWindow::quit); connect(ui-&gt;actionClean, &amp;QAction::triggered, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;MainWindow::clean); connect(ui-&gt;actionOpen, &amp;QAction::triggered, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;MainWindow::open); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;setWindowTitle(<span class="hljs-string"><span class="hljs-string">"QViewerWidget example"</span></span>); }</code> </pre><br>  oder besser gesagt, wir sind immer noch an diesem Teil interessiert <br><br><pre> <code class="cpp hljs">QGridLayout *layout = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QGridLayout; qviewer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> QViewerWidget(QRect(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, ui-&gt;frame-&gt;width(), ui-&gt;frame-&gt;height())); layout-&gt;addWidget(qviewer); ui-&gt;frame-&gt;setLayout(layout); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;setCentralWidget(ui-&gt;frame);</code> </pre><br>  Wenn Sie eine Ebene erstellen, erstellen Sie unser Widget mit Abmessungen, die der Gr√∂√üe des Rahmens entsprechen, f√ºgen Sie das erstellte Widget der Ebene hinzu und h√§ngen Sie die Ebene an den Rahmen an.  Um das Layout in diesem Beispiel nicht zu beeintr√§chtigen, dehnen wir den Rahmen auf den gesamten Client-Bereich des Fensters aus und machen ihn zum zentralen Widget. <br><br>  Zum Rendern sollten Sie eine regelm√§√üige Fensteraktualisierung nach Timer veranlassen.  Erstellen Sie dazu einen Timer mit einem Intervall von 40 Millisekunden (25 Bilder pro Sekunde) und ordnen Sie das Zeitlimitsignal dem Fensteraktualisierungssteckplatz zu.  Ich mache es so mit Qt5-Syntax <br><br><pre> <code class="cpp hljs">connect(&amp;timer, &amp;QTimer::timeout, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, &amp;MainWindow::update); timer.start(<span class="hljs-number"><span class="hljs-number">40</span></span>);</code> </pre><br>  zuvor den Aktualisierungssteckplatz f√ºr die Fensterklasse auf diese Weise definiert haben <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MainWindow::update() { QMainWindow::update(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;geometry()); }</code> </pre><br>  Warum, weil Sie das Timer-Signal direkt mit dem QMainWindow :: Update-Slot verkn√ºpfen k√∂nnen, wie es die meisten osgQt-Beispiele zeigen <br><br><pre> <code class="plaintext hljs">connect(&amp;timer, SIGNAL(timeout), this, SLOT(update));</code> </pre><br>  Tatsache ist, dass die Syntax mit den Makros SIGNAL () und SLOT () veraltet ist und im Vorgriff auf den √úbergang zu Qt6 aufgegeben werden muss.  Gleichzeitig hat die QMainWindow-Klasse keine √úberladung des update () - Slots ohne Parameter, was zu einem Fehler beim Bind-Aufruf w√§hrend der Kompilierung f√ºhrt.  Dazu musste ich meinen update () - Slot ohne Parameter definieren, die Basis QMainWindow :: update () darin aufrufen und dort den Client-Bereich des Fensters √ºbergeben. <br><br>  Wenn Sie diesen Ort erg√§nzen und das Programm ausf√ºhren, erhalten Sie ein bestimmtes Ergebnis <br><br><img src="https://habrastorage.org/webt/s4/hb/h7/s4hbh78isikshkekfsbefaht8wg.png"><br><br>  Durch Dr√ºcken von "S" k√∂nnen wir den OSG-Statistikmonitor aktivieren und sicherstellen, dass unser Widget ordnungsgem√§√ü funktioniert und eine leere Szene zeichnet. <br><br><div class="spoiler">  <b class="spoiler_title">Welche Art von Statistikmonitor?</b> <div class="spoiler_text">  Um den Artikel nicht zu √ºberladen, werde ich hier dar√ºber schreiben.  OSG verf√ºgt √ºber einen integrierten Monitor, der Motorstatistiken in Echtzeit anzeigt.  Um es dem Viewer hinzuzuf√ºgen, f√ºgen wir die Header-Datei hinzu <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;osgViewer/ViewerEventHandlers&gt;</span></span></span></span></code> </pre><br>  und f√ºgen Sie dem Viewer einen Handler hinzu <br><br><pre> <code class="cpp hljs">viewer.addEventHandler(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> osgViewer::StatsHandler);</code> </pre><br>  dann jederzeit durch Dr√ºcken von "S", um viele n√ºtzliche Informationen anzuzeigen. <br></div></div><br><h1>  4. Beenden Sie unseren Viewer: F√ºgen Sie ein Men√º hinzu </h1><br>  Im Formular-Designer passen wir das Men√º mithilfe der "mausorientierten" Programmierung an (was mir gleichg√ºltig ist, aber ja, manchmal ist es praktisch).  Am Ende werden wir so etwas bekommen <br><br> <a href=""><img src="https://habrastorage.org/webt/5h/lg/4y/5hlg4ynz134k85tyg9gko_mzjlm.png"></a> <br><br>  Jetzt starten wir die entsprechenden Prozessor-Slots, sodass Sie das Modell √ºber den im Dialogfeld ausgew√§hlten Pfad laden, die Szene l√∂schen und die Anwendung beenden k√∂nnen <br><br><div class="spoiler">  <b class="spoiler_title">Men√º-Handler-Code</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void MainWindow::open() { osg::Group *scene = qviewer-&gt;getScene(); if (scene == nullptr) return; QString path = QFileDialog::getOpenFileName(Q_NULLPTR, tr("Open model file"), "./", tr("OpenSceneGraph (*.osg *.osgt *.osgb *.ivi)")); if (path.isEmpty()) return; scene-&gt;removeChildren(0, scene-&gt;getNumChildren()); osg::ref_ptr&lt;osg::Node&gt; model = osgDB::readNodeFile(path.toStdString()); scene-&gt;addChild(model.get()); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void MainWindow::clean() { osg::Group *scene = qviewer-&gt;getScene(); if (scene == nullptr) return; scene-&gt;removeChildren(0, scene-&gt;getNumChildren()); } //------------------------------------------------------------------------------ // //------------------------------------------------------------------------------ void MainWindow::quit() { QApplication::quit(); }</span></span></code> </pre><br></div></div><br>  Danach erhalten wir einen sehr praktischen Viewer f√ºr Modelle im * .osg-Format. <br><br><img src="https://habrastorage.org/webt/vj/ub/ml/vjubmllisl3w25nyca0dn90udv0.png"><br><br>  Eine Demonstration seiner Arbeit zeigt das Video am Anfang des Artikels.  Der vollst√§ndige Quellcode f√ºr dieses Beispiel ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier verf√ºgbar.</a> <br><br><h1>  Fazit </h1><br>  Wie wir gesehen haben, ist die Integration von OSG und Qt weder beim Verst√§ndnis noch bei der Implementierung besonders schwierig.  Dies ist eine gro√üe Hilfe beim Erstellen plattform√ºbergreifender Anwendungen f√ºr die technische Visualisierung und m√∂glicherweise f√ºr Spiele. <br><br>  Dieser Artikel er√∂ffnet eine Fortsetzung der OSG-Reihe, in der komplexe Entwicklungstechniken beschrieben werden.  Ich denke, sie ist erfolgreich herausgekommen.  Vielen Dank und bis bald! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438654/">https://habr.com/ru/post/de438654/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438644/index.html">Die Sicherheit von Algorithmen f√ºr maschinelles Lernen. Sch√ºtzen und Testen von Modellen mit Python</a></li>
<li><a href="../de438646/index.html">Informationen zum Erstellen von Budget-Stereobildern auf Fingern (Stereogramm, Anaglyphe, Stereoskop)</a></li>
<li><a href="../de438648/index.html">Vergleich von BI-Systemen (Tableau, Power BI, Oracle, Qlik)</a></li>
<li><a href="../de438650/index.html">Rakete 9M729. Ein paar Worte zum ‚ÄûVersto√ü‚Äú gegen den INF-Vertrag</a></li>
<li><a href="../de438652/index.html">Portabelization IDA</a></li>
<li><a href="../de438658/index.html">Wie man lernt zu lernen</a></li>
<li><a href="../de438662/index.html">Der Tag, an dem ich mich in Fuzzing verliebt habe</a></li>
<li><a href="../de438664/index.html">Schnelles Compiler-Ger√§t. Teil 2</a></li>
<li><a href="../de438666/index.html">Manager gegen Programmierer</a></li>
<li><a href="../de438668/index.html">‚ÄûSuchen Sie nach Geschichten, die vorantreiben‚Äú: Ein Podcast √ºber Podcasts, redaktionelle Arbeiten und Medienkarrieren</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>