<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚢 🛢️ 👴 切换到Next.js并加快歧管网站首页的加载7.5倍 🗂️ 💟 🏸</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="今天，我们正在发布一个故事的译文，该故事讲述了从React Boilerplate到Next.js （一个用于开发基于React的渐进式Web应用程序的框架）的过渡如何将歧管项目首页的加载速度提高了7.5倍。 没有对该项目进行任何其他更改，并且这种转换通常对于系统的其他部分来说是完全不可见的。 最终...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>切换到Next.js并加快歧管网站首页的加载7.5倍</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/442654/"> 今天，我们正在发布一个故事的译文，该故事讲述了从<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">React Boilerplate</a>到<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Next.js</a> （一个用于开发基于React的渐进式Web应用程序的框架）的过渡如何将歧管项目<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">首页</a>的加载速度提高了7.5倍。 没有对该项目进行任何其他更改，并且这种转换通常对于系统的其他部分来说是完全不可见的。 最终结果甚至比预期的要好。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/ci/bc/g5/cibcg5cgvkbkyimgtleiv21hmgy.png"></a> <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">结果概述</font> </h2><br> 实际上，我们可以说，向Next.js的过渡给我们带来了诸如“无处不在的项目生产率提高”之类的东西。 这是使用各种硬件资源和网络连接时项目加载时间的样子。 <br><table><tbody><tr><td> 连接方式 <br></td><td width="130"> 中央处理器 <br></td><td width="130"> 到秒 <br></td><td width="130"> 几秒钟后 <br></td><td width="130"> 改善百分比 <br></td></tr><tr><td> 快速（200 Mbps） <br></td><td> 快的 <br></td><td>  1.5 <br></td><td>  0.2 <br></td><td>  750 <br></td></tr><tr><td> 中（3G） <br></td><td> 快的 <br></td><td>  5.6 <br></td><td>  1.1 <br></td><td>  500 <br></td></tr><tr><td> 中（3G） <br></td><td> 中号 <br></td><td>  7.5 <br></td><td>  1.3 <br></td><td>  570 <br></td></tr><tr><td> 慢（3G连接慢） <br></td><td> 中号 <br></td><td>  22 <br></td><td>  4 <br></td><td>  550 <br></td></tr></tbody></table><br> 当使用快速连接和带有快速处理器的设备时，站点加载时间从1.5 s下降。 最高可达0.2 s。，即该指标提高了7.5倍。 在中等质量的连接上以及在具有平均性能的设备上，站点加载时间从7.5 s下降。 高达1.3秒 <br><br><h2>  <font color="#3AC1EF">用户单击URL后会发生什么？</font> </h2><br> 为了了解渐进式Web应用程序（Progressive Web App，PWA）的功能，您必须首先了解用户单击URL（在我们网站的地址）的那一刻到看到某物的那一刻之间发生的情况。在浏览器窗口（在本例中为我们的React应用程序）中。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8c6/f9b/060/8c6f9b060a4fd4ff13cd525b62c98477.jpg"></div><br>  <i><font color="#999999">应用阶段</font></i> <br><br> 考虑使用该应用程序的5个阶段，上面给出了其示意图。 <br><br><ol><li> 用户进入URL，系统使用DNS查找服务器地址并访问服务器。 所有这些操作都非常快地完成，通常花费不到100毫秒，但是此步骤需要一些时间，因此在这里提到它。 </li><li> 现在服务器返回页面的HTML代码，但是浏览器中的页面将保持空白，直到加载其显示所需的资源为止（除非资源是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">异步</a>加载的）。 实际上，此阶段正在采取的行动比图表中所示的要多，但是对所有这些过程的联合审核也将适合我们。 </li><li>加载HTML代码和最重要的资源后，浏览器开始显示其可以显示的内容，并继续在后台加载其他所有内容（例如图片）。 您是否曾经想过，为什么有时图像突然突然“弹出”在页面上的速度明显超过了必要，而有时却加载时间太长？ 这就是为什么发生这种情况。 这种方法使您可以快速创建完成的页面。 </li><li>  JavaScript代码只有在加载后才能解析和执行。 根据页面上使用的JS代码的大小（对于典型的React应用程序，如果代码打包在单个文件中，这可能会很大），可能要花费几秒钟甚至更长的时间（请注意，JS该代码不需要为了开始执行而等待所有其他资源的加载，尽管事实上它在图中看起来完全像这样）。 </li><li> 对于React应用程序，现在是代码修改DOM的时刻，这将导致浏览器重新绘制已经显示的页面。 然后另一个资源加载周期开始。 此步骤花费的时间将取决于页面的复杂程度。 </li></ol><br><h2>  <font color="#3AC1EF">越快越好。</font> </h2><br> 由于渐进式Web应用程序需要React代码并生成静态HTML和CSS代码，因此这意味着用户已经在上述方案的步骤3而非步骤5看到了React应用程序。在我们的测试中，这需要0.2到4秒的时间，这取决于用户连接到互联网及其设备的速度。 这比之前的1.5-22秒要好得多。 渐进式Web应用程序是将React应用程序更快地交付给用户的可靠方法。 <br><br> 渐进式Web应用程序和诸如Next.js之类的相关框架仍然不流行的原因是，传统上，JS框架在生成静态HTML代码方面并不是特别成功。 如今，由于React，Vue和Angular等框架对服务器端渲染提供了出色的支持，因此一切都发生了很大变化。 但是，要使用这些工具，您仍然需要深入了解捆绑器的工作功能和用于构建项目的工具。 处理所有这些并非没有问题。 <br><br> 由于进入门槛较低，并且由于使用这样的框架使PWA成为一项简单而令人愉快的任务，因此最近出现的Next.js和Gatsby之类的PWA框架（均于2016年底至2017年初出现）已成为迈向PWA广泛采用的重要一步。 <br><br> 尽管不是每个应用程序都可以转移到Next.js，但是对于许多React应用程序而言，这种过渡意味着我们在这里所谈论的“无处不在的性能”，并以更加有效的网络资源使用为补充。 <br><br><h2>  <font color="#3AC1EF">迁移到Next.js有多困难？</font> </h2><br> 通常，可以注意到将我们的主页转换为Next.js并不是很困难。 但是，我们遇到了一些由应用程序的体系结构功能引起的困难。 <br><br><h3>  <font color="#3AC1EF">▍拒绝反应路由器</font> </h3><br> 我们不得不放弃React路由器，因为Next.js拥有自己的内置路由器，最好将其与在PWA架构之上执行的有关代码分离的优化相结合。 这使该路由器能够比您从任何客户端路由器获得的页面加载速度快得多。 <br><br>  Next.js路由器有点像高速React路由器，但它仍然不是React路由器。 <br><br> 在实践中，由于我们没有利用React路由器提供的特别高级的功能，因此向我们过渡到Next.js路由器的方法是简单地将标准的React路由器组件替换为相应的Next.js组件： <br><br><pre><code class="plaintext hljs">/*   ( React) */ &lt;Link to="/my/page"&gt;  A link &lt;/Link&gt; /*   ( Next.js) */ &lt;Link href="/my/page" passHref&gt;  &lt;a&gt;    A link  &lt;/a&gt; &lt;/Link&gt;</code> </pre> <br> 总的来说，一切都还不错。 我们必须重命名该属性并添加标记以用于服务器渲染。 由于我们还使用了<code>styled-components</code>库，因此事实证明，在大多数情况下，我们需要添加<code>passHref</code>属性，以确保系统的行为方式是<code>href</code>始终指向生成的标记。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d7c/5dd/e79/d7c5dde797101c30c2cf0e6507e07881.png"></div><br>  <i><font color="#999999">Network对歧管的要求</font></i> <br><br> 为了用肉眼看到运行中的Next.js路由器的优化，请通过查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">歧管</a>页面来打开浏览器开发人员工具的“网络”选项卡，然后单击某些链接。 上图显示了单击<code>/services</code>链接的结果。 如您所见，它导致执行加载<code>services.js</code>的请求，而不是执行常规请求。 <br><br> 我不仅在谈论客户端路由； React路由器也适合解决此问题。 我说的是一段真实的JavaScript代码，该代码已从其余代码中提取并按要求加载。 这是使用标准的Next.js完成的。 这比我们以前拥有的要好得多。 即，我们正在谈论的是1.7 MB大小的大型JS代码包，客户端在看到之前必须下载并处理。 <br><br> 尽管此处介绍的解决方案并不完美，但它比上一个解决方案更接近于用户仅下载其查看页面的代码这一想法。 <br><br><h3>  <font color="#3AC1EF">Red使用Redux的功能</font> </h3><br> 继续讨论与向Next.js过渡相关的困难这一主题，可以注意到，Next.js对应用程序进行的所有有趣的优化都对该应用程序产生一定的影响。 即，因为Next.js执行页面级代码分离，所以它防止开发人员访问<code>React</code>根组件或<code>react-dom</code>库的<code>render()</code>方法。 如果您已经参与配置Redux，那么您可以注意到，所有这些都告诉我们，对于Redux的正常运行，我们需要解决问题，即不清楚在哪里寻找Redux。 <br><br>  Next.js提供了一个特殊的高阶组件<code>withRedux</code> ， <code>withRedux</code>每个页面上所有顶级组件的包装： <br><br><pre> <code class="plaintext hljs">export default withRedux(HomePage);</code> </pre> <br> 尽管这<code>createStore()</code>不错，但是如果您需要<code>createStore()</code>方法（例如，在使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">redux-reducer-injectors时）</a> ，则希望您需要更多的时间来调试包装器（顺便说一下，请不要尝试使用类似<code>redux-reducer-injectors</code>东西。 <br><br> 此外，由于Redux现在是一个“黑匣子”，因此使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">不可变</a>库会带来问题。 尽管Immutable可与Redux一起使用的事实似乎很明显，但我遇到了一个问题。 因此，要么顶层状态不是不可变的（ <code>get is not a function</code>错误），要么包装器组件试图使用点表示法而不是<code>.get()</code>方法来处理JS对象（ <code>Can't get catalog of undefined</code>错误的<code>Can't get catalog of undefined</code> ）。 要调试此问题，我必须参考源代码。 毕竟，Next.js出于某种原因强迫开发人员使用其自己的机制。 <br><br> 总的来说，可以注意到与Next.js相关的主要问题是，在这个框架中，很少有文件记载得很好。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">文档中</a>有许多示例，您可以在这些示例的基础上创建自己的东西，但是如果其中没有一个示例可以反映项目的功能，则只能祝您好运。 <br><br><h3>  <font color="#3AC1EF">etch获取拒绝</font> </h3><br> 我们使用了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">react-inlinesvg库</a> ，该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">库</a>为嵌入式SVG图像和查询缓存提供样式选项。 但是这里我们有一个问题：执行服务器渲染时，没有XHR请求之类的东西（至少不是Webpack生成的URL所期望的那样）。 尝试执行此类请求会干扰服务器渲染。 <br><br> 尽管还有其他用于处理支持SSR的嵌入式SVG数据的库，但我还是决定放弃此功能，因为SVG文件仍然很少使用。 如果在显示相应图像时不需要样式，则可以用普通图像， <code>&lt;img&gt;</code>标签替换它们，也可以将它们以React JSX的形式嵌入到代码中。 可能一切都变得更好了，因为当页面首次加载并且发送给客户端的JS捆绑包少了1个库时，JSX插图现在已经在浏览器中了。 <br><br> 如果您需要使用数据加载机制（我需要另一个库使用此功能），则可以使用<code>whatwg-fetch</code>和<code>node-fetch</code>与<code>next.config.js</code>进行配置： <br><br><pre> <code class="plaintext hljs">module.exports = { webpack: (config, options) =&gt;   Object.assign(config, {     plugins: config.plugins.concat([       new webpack.ProvidePlugin(         config.isServer           ? {}           : { fetch: 'imports-loader?this=&gt;global!exports-loader?global.fetch!whatwg-fetch' }       ),     ]),   resolve: Object.assign(config.resolve, {     alias: Object.assign(       config.resolve.alias,       config.isServer ? {} : { fetch: 'node-fetch' }     ),   }), }), };</code> </pre> <br><h3>  <font color="#3AC1EF">▍客户端和服务器JS</font> </h3><br> 我想在这里提到的Next.js的最后一个功能是，该框架被启动了两次-一次是针对服务器，另一次是针对客户端。 这会稍微模糊同一代码库中客户端JavaScript和Node.js代码之间的界线，从而在尝试利用客户端上的Node.js功能时导致<code>fs is undefined</code>类的异常错误。 <br><br> 结果，我们必须在<code>next.js.config</code>构造这样的构造： <br><br><pre> <code class="plaintext hljs">module.exports = { webpack: (config, options) =&gt;   Object.assign(config, {     node: config.isServer ? undefined : { fs: 'empty' },   }), };</code> </pre> <br> 如果您需要在不同的环境中运行相同的代码，Webpack中的<code>config.isServer</code>标志将是您最好的朋友。 <br><br> 此外，除了React组件生命周期的标准方法外，Next.js还支持<code>getInitialProps()</code>方法，该方法仅在代码以服务器模式<code>getInitialProps()</code>时才被调用： <br><br><pre> <code class="plaintext hljs">class HomePage extends React.Component { static getInitialProps() {   //         } componentDidMount() {   //     ,    } … }</code> </pre> <br> 是的，我们不要忘记，Node.js中没有组织好监听事件，确定浏览器窗口大小并提供许多有用功能的访问权限的好朋友<code>window</code>对象： <br><br><pre> <code class="plaintext hljs">if (typeof window !== 'undefined') { // ,     `window`      }</code> </pre> <br> 应该注意的是，即使Next.js也无法使开发人员免于解决与在服务器和客户端上执行相同代码相关的问题的需要。 但是在解决此类问题时， <code>config.isServer</code>和<code>getInitialProps()</code>非常有用。 <br><br><h2>  <font color="#3AC1EF">结果：Next.js之后会发生什么？</font> </h2><br> 短期而言，Next.js框架在性能，服务器渲染要求以及在禁用JavaScript的设备上查看网站的能力方面都可以完美匹配。 另外，现在，它允许您使用高级（丰富） <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">元标记</a> 。 <br><br> 也许将来，如果我们的应用程序需要服务器渲染和更复杂的服务器逻辑，我们将考虑其他选择（例如，我们研究了在岐管网和dashboard.manifold.co上实现单点登录技术的可能性） ） 但是在此之前，我们将使用Next.js，因为该框架耗时少，为我们带来了巨大的收益。 <br><br>  <b>亲爱的读者们！</b> 您在项目中使用Next.js吗？ <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN442654/">https://habr.com/ru/post/zh-CN442654/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN442644/index.html">大多数非编程技能可提高开发人员价值</a></li>
<li><a href="../zh-CN442646/index.html">Kubernetes网络：入口</a></li>
<li><a href="../zh-CN442648/index.html">去分配机制</a></li>
<li><a href="../zh-CN442650/index.html">React应用程序的分析和优化</a></li>
<li><a href="../zh-CN442652/index.html">使用Fastify和Preact快速原型化Web应用程序</a></li>
<li><a href="../zh-CN442658/index.html">使用CSS的8个技巧：视差，粘页脚等</a></li>
<li><a href="../zh-CN442660/index.html">调和牛顿与量子世界的数学</a></li>
<li><a href="../zh-CN442662/index.html">如何观看SDDL而不看分号</a></li>
<li><a href="../zh-CN442664/index.html">QIWI Kitchen 2月6日-现状如何+演讲者演讲</a></li>
<li><a href="../zh-CN442666/index.html">发布后，元元。 我们学习写在哈勃</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>