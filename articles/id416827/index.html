<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⛱️ 👋🏽 🎌 Kontainer Dewasa (Bagian 02): Panduan Praktis untuk Terminologi 🧤 🕗 👩🏾‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ada banyak templat pembuatan wadah. Wadah hanyalah versi yang dapat dieksekusi dari gambarnya sendiri. Oleh karena itu, cara membangun wadah terkait e...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Kontainer Dewasa (Bagian 02): Panduan Praktis untuk Terminologi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/416827/">  Ada banyak templat pembuatan wadah.  Wadah hanyalah versi yang dapat dieksekusi dari gambarnya sendiri.  Oleh karena itu, cara membangun wadah terkait erat dengan bagaimana wadah itu dimulai. <br><br>  Beberapa gambar kontainer berfungsi dengan baik tanpa hak istimewa, yang lain membutuhkan hak root.  Selain itu, gambar / wadah yang sama dapat menggabungkan beberapa pola konstruksi dan skenario penggunaan sekaligus. <br><br><img src="https://habrastorage.org/webt/vb/ka/oc/vbkaocfqfq-tdb_a97lu5sifqna.png" width="100%"><br><br>  Di bawah ini kami akan mempertimbangkan kasus penggunaan wadah yang paling umum. <br><br>  (Untuk pengantar terminologi wadah, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagian satu</a> ) <br><a name="habracut"></a><br><h3>  Skenario Penggunaan Kontainer </h3><br><h4>  Wadah aplikasi </h4><br>  Wadah aplikasi adalah jenis wadah yang paling umum.  Pengembang dan pemilik aplikasi menanganinya, dan mereka sendiri mengandung kode sumber, ditambah hal-hal seperti MySQL, Apache, MongoDB, dan Node.js. <br><br>  Ekosistem besar wadah aplikasi sedang dibentuk.  Proyek seperti Koleksi Perangkat Lunak menyediakan gambar wadah aplikasi yang aman dan didukung untuk Red Hat Enterprise Linux.  Pada saat yang sama, anggota komunitas Red Hat sedang mengembangkan dan mendukung wadah aplikasi inovatif. <br><br>  Di Red Hat, kami percaya bahwa wadah aplikasi biasanya tidak memerlukan hak khusus.  Namun, ketika membangun lingkungan produksi wadah, ada kebutuhan untuk wadah lain. <br><br><h4>  Wadah Sistem Operasi </h4><br>  Wadah dari sistem operasi adalah wadah yang jauh lebih menyerupai OS virtual penuh.  Kontainer seperti itu juga menggunakan kernel host, tetapi menjalankan sistem init penuh, yang memungkinkan mereka untuk dengan mudah menjalankan beberapa proses.  Contoh wadah sistem operasi adalah LXC dan LXD. <br><br>  Wadah dari sistem operasi dapat, pada prinsipnya, ditiru dengan menggunakan buruh pelabuhan / wadah OCI, asalkan Anda dapat menjalankan sistem di dalamnya sehingga pengguna akhir dapat menginstal perangkat lunak di dalam wadah tersebut dengan cara yang biasa dan menganggapnya sebagai OS virtual penuh. <br><br><pre><code class="hljs sql">yum <span class="hljs-keyword"><span class="hljs-keyword">install</span></span> mysql systemctl <span class="hljs-keyword"><span class="hljs-keyword">enable</span></span> mysql</code> </pre> <br>  Ini sangat menyederhanakan containerisasi aplikasi yang ada.  Red Hat bekerja keras untuk menyederhanakan wadah sistem operasi dengan memungkinkan systemd berjalan di dalam wadah dan menggunakan daemon mesin.  Meskipun banyak pelanggan belum siap untuk arsitektur microservice, transisi ke model pengiriman perangkat lunak berdasarkan gambar kontainer masih bisa memberi mereka banyak keuntungan. <br><br><h4>  Wadah hewan peliharaan </h4><br>  Meskipun Red Hat sangat merekomendasikan, mempromosikan, dan mendukung penggunaan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">templat berbasis cloud</a> ketika mengembangkan aplikasi baru, kami sangat menyadari bahwa tidak semua aplikasi yang ada akan ditulis ulang dengan cara ini.  Secara khusus, karena banyak dari mereka sangat unik dan tak dapat ditiru sehingga, dibandingkan dengan aplikasi standar, mereka terlihat seperti hewan peliharaan ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Hewan peliharaan</a> ) melawan kawanan sapi.  Untuk aplikasi seperti itu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wadah Pet</a> khusus dirancang. <br><br>  Pet container menggabungkan portabilitas dan kenyamanan infrastruktur container yang dibangun berdasarkan server registry, gambar container dan host container dengan fleksibilitas lingkungan TI tradisional, diimplementasikan di dalam container terpisah.  Idenya di sini adalah untuk menyederhanakan kontainerisasi aplikasi yang ada karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kemampuan yang</a> sama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">untuk menggunakan systemd di dalam wadah</a> untuk menggunakan alat otomatisasi yang ada, instalasi perangkat lunak dan alat-alat lain untuk dengan mudah membuat gambar siap wadah untuk diluncurkan. <br><br><h4>  Wadah Super Privilege </h4><br>  Ketika membangun infrastruktur kontainer berdasarkan host kontainer khusus seperti Red Hat Enterprise Linux Atomic Host, administrator sistem masih harus mengelola.  Dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Super Privileged Containers</a> (SPCs) terbukti sangat berguna dalam lingkungan terdistribusi seperti itu, baik itu Kubernetes, OpenShift, atau bahkan kontainer yang berdiri sendiri.  SPC bahkan dapat memuat modul kernel khusus, seperti systemtap. <br><br>  Dalam infrastruktur yang dibuat untuk menjalankan kontainer, administrator cenderung membutuhkan wadah SPC untuk melakukan tugas-tugas seperti pemantauan, pencadangan, dll. Penting untuk dipahami bahwa karena wadah SPC biasanya jauh lebih terhubung ke inti host, administrator harus Berikan perhatian khusus pada masalah keandalan dan standardisasi ketika memilih sistem operasi host, terutama di lingkungan yang luas dan terdistribusi yang membuat pemecahan masalah menjadi sulit.  Selain itu, administrator perlu memastikan bahwa ruang pengguna di dalam SPC kompatibel dengan inti host. <br><br><h4>  Alat dan perangkat lunak sistem </h4><br>  Distribusi Linux selalu menyediakan perangkat lunak sistem kepada pengguna, seperti Rsyslogd, SSSD, sadc, dll. Secara tradisional, perangkat lunak ini dipasang dalam bentuk paket RPM atau DEB, tetapi dengan munculnya format kemasan wadah, menjadi lebih mudah dan lebih mudah untuk menginstal menggunakan gambar wadah.  Secara khusus, Red Hat menawarkan hal-hal seperti wadah siap pakai seperti alat virtualisasi Red Hat, rsyslog, sssd, dan sadc. <br><br><h3>  Arsitektur wadah </h3><br>  Sebagai pengiriman perangkat lunak kemas mendapatkan momentum, pola desain wadah baru muncul.  Di bagian ini kita akan berbicara tentang beberapa di antaranya. <br><br>  Cara wadah disimpan ke disk (dengan kata lain, format gambar) dapat sangat memengaruhi cara dimulainya.  Sebagai contoh, sebuah wadah yang dirancang untuk menjalankan sssd harus memiliki hak istimewa setiap kali dimulai, jika tidak maka ia tidak akan dapat melakukan tugasnya.  Di bawah ini, kami secara singkat mempertimbangkan pola utama yang saat ini sedang menjalani tahap pembentukan aktif. <br><br><h4>  Gambar aplikasi </h4><br>  Ini dengan gambar-gambar ini yang menangani pengguna akhir.  Skenario untuk menggunakan gambar tersebut berkisar dari DBMS dan server web hingga aplikasi individual dan bus layanan.  Gambar-gambar ini dapat dibuat baik secara internal oleh organisasi atau disediakan oleh vendor perangkat lunak.  Oleh karena itu, pengguna akhir sering kali berhubungan dengan isi wadah otonom tersebut dengan hati-hati dan cermat.  Selain itu, meskipun ini adalah pilihan termudah untuk pengguna akhir wadah, gambar yang berdiri sendiri jauh lebih sulit untuk dirancang, dibuat, dan ditambal. <br><br><h4>  Gambar dasar </h4><br>  Gambar dasar adalah salah satu jenis gambar yang paling sederhana.  Namun, orang dapat menunjukkan istilah ini dengan berbagai hal, misalnya, rakitan perusahaan standar atau bahkan gambar aplikasi.  Meskipun, sebenarnya, ini bukan gambar dasar, tetapi menengah. <br>  Jadi cukup jelaskan bahwa gambar dasar adalah gambar yang tidak memiliki lapisan induk.  Gambar dasar biasanya berisi salinan OS yang bersih, serta alat yang diperlukan untuk menginstal paket perangkat lunak atau memperbarui gambar nanti (yum, rpm, apt-get, dnf, microdnf).  Gambar dasar dapat dikumpulkan secara manual oleh pengguna akhir, tetapi dalam praktiknya mereka biasanya dibuat dan dirilis oleh komunitas pengembangan (mis. Debian, Fedora atau CentOS) atau vendor perangkat lunak (mis. Red Hat).  Asal usul gambar dasar sangat penting untuk keamanan.  Kesimpulannya, tujuan utama dan satu-satunya gambar dasar adalah untuk memberikan dasar atas dasar di mana Anda dapat membuat gambar anak Anda.  Saat menggunakan dockerfile, pemilihan gambar dasar yang mendasarinya dilakukan secara eksplisit: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> registry.<span class="hljs-keyword"><span class="hljs-keyword">access</span></span>.redhat.com/rhel7-atomic</code> </pre> <br><h4>  Gambar pembangun </h4><br>  Ini adalah jenis gambar khusus berdasarkan gambar anak wadah aplikasi yang kemudian dibuat.  Gambar pembuat termasuk semua kecuali kode sumber yang ditulis oleh pengembang, yaitu pustaka OS, runtime bahasa, middleware, dan alat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sumber-ke-gambar</a> . <br><br>  Saat startup, gambar pembangun menarik kode sumber aplikasi yang ditulis oleh pengembang dan menciptakan citra anak dari wadah aplikasi yang siap diluncurkan, yang kemudian dapat dijalankan dalam lingkungan pengembangan atau produksi. <br><br>  Katakanlah pengembang telah menulis kode PHP untuk aplikasi dan ingin menjalankannya dalam wadah.  Untuk melakukan ini, mereka cukup mengambil gambar builder dari PHP dan meneruskannya URL di situs web GitHub, tempat kode mereka disimpan.  Akibatnya, pengembang mendapatkan gambar wadah aplikasi yang siap diluncurkan yang berisi Red Hat Enterprise Linux, PHP dari Koleksi Perangkat Lunak, dan, tentu saja, kode sumber PHP untuk aplikasi tersebut. <br><br>  Gambar pembangun adalah cara yang kuat, mudah, dan cepat untuk mengubah kode sumber menjadi wadah yang dibangun berdasarkan komponen tepercaya. <br><br><h4>  Komponen kemas </h4><br>  Wadah terutama dimaksudkan untuk digunakan sebagai komponen sistem perangkat lunak yang lebih besar, dan bukan sebagai unit mandiri.  Dan ada dua alasan utama untuk ini. <br><br>  Pertama, arsitektur layanan mikro meningkatkan kebebasan memilih komponen, dan juga mengarah pada peningkatan jumlah komponen dari mana aplikasi dan sistem perangkat lunak disusun.  Komponen kemas membantu menyebarkan sistem tersebut lebih cepat dan lebih mudah.  Sebagai contoh, gambar kontainer memudahkan untuk memecahkan masalah koeksistensi versi berbeda dari komponen yang sama.  Dan alat penentu aplikasi seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penyebaran yaml / json</a> di Kubernetes / OpenShift, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">broker layanan terbuka</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">OpenShift Templates</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Helm Charts</a> menyediakan penciptaan deskripsi aplikasi tingkat tinggi. <br><br>  Kedua, jauh dari selalu semua bagian dari sistem perangkat lunak dapat dengan mudah ditampung.  Oleh karena itu, masuk akal untuk melakukan kontainerisasi hanya untuk komponen individual yang paling cocok untuk ini atau yang paling menjanjikan dalam hal hasil.  Dalam aplikasi multiservice, satu bagian dari layanan dapat digunakan sebagai wadah, dan yang lainnya menggunakan metode tradisional, seperti RPM atau skrip instalasi, lihat wadah hewan peliharaan.  Selain itu, beberapa komponen mungkin sulit untuk ditampung, karena mereka dibagi menjadi beberapa komponen, atau terikat pada beberapa perangkat keras khusus, atau menggunakan panggilan API kernel tingkat rendah, dll. Oleh karena itu, dalam sistem perangkat lunak besar, kemungkinan besar akan ada bagian yang bisa kemas dan bagian yang tidak bisa kemas.  Komponen kemas adalah apa yang bisa kemas dan sudah kemas.  Komponen kemas dirancang untuk dijalankan sebagai bagian dari aplikasi spesifik, dan bukan dengan sendirinya.  Penting untuk dipahami bahwa mereka tidak dimaksudkan untuk operasi otonom, karena mereka berguna hanya sebagai bagian dari sistem perangkat lunak yang lebih besar dan dalam isolasi dari itu praktis tidak berguna. <br><br>  Misalnya, di OpenShift Enterprise 3.0, sebagian besar kode utama dikerahkan menggunakan RPM, tetapi setelah diinstal, administrator menggunakan router dan registri sebagai wadah.  OpenShift 3.1 memperkenalkan opsi penyebaran kemas untuk master, node, openvswitch, dan lain-lain, dan setelah diinstal, administrator juga dapat menggunakan elasticsearch, fluentd, dan kibana sebagai wadah. <br><br>  Meskipun penginstal OpenShift masih membuat perubahan pada sistem file server, semua komponen perangkat lunak utama sekarang dapat diinstal menggunakan gambar kontainer.  Oleh karena itu, komponen-komponen kemas ini, misalnya, sebuah instance dari gambar etcd yang disematkan di OpenShift, tidak boleh - dan tidak akan - digunakan untuk menyimpan kode sumber aplikasi yang bekerja dengan pelanggan Anda, hanya karena komponen-komponen kemas ini dimaksudkan untuk dijalankan sebagai bagian Platform Kontainer OpenShift. <br><br>  Dalam versi baru OpenShift, tren menuju kontainerisasi komponen hanya meningkat, dan pengembang perangkat lunak lainnya semakin menggunakan pendekatan ini. <br><br><h4>  Gambar penyebar </h4><br>  Gambar deployer adalah jenis wadah khusus yang, ketika diluncurkan, menyebarkan atau mengelola wadah lain.  Deployer memungkinkan Anda untuk menerapkan skema penempatan yang rumit, misalnya, meluncurkan wadah dalam urutan tertentu atau melakukan beberapa tindakan pada awal pertama, seperti membuat skema data atau mengisi awal basis data. <br><br>  Misalnya, di OpenShift, templat “image / container type” digunakan untuk menggunakan log dan metrik.  Menyebarkan komponen-komponen ini menggunakan gambar-gambar penyebaran memungkinkan para insinyur OpenShift untuk mengontrol urutan berbagai komponen berjalan dan memverifikasi bahwa mereka bekerja dengan benar. <br><br><h4>  Gambar menengah </h4><br>  Gambar perantara adalah gambar apa pun dari wadah yang bergantung pada gambar dasar.  Kumpulan kernel, middleware, dan runtimes bahasa biasanya diimplementasikan sebagai lapisan tambahan di atas gambar dasar dan kemudian ditentukan dalam arahan FROM dengan gambar dasar ini.  Gambar perantara biasanya tidak digunakan sendiri, tetapi sebagai blok bangunan dalam menciptakan gambar yang otonom. <br><br>  Lapisan gambar yang berbeda, biasanya, terlibat dalam kelompok spesialis yang berbeda.  Misalnya, administrator sistem bertanggung jawab atas lapisan rakitan kernel, dan pengembang untuk lapisan middleware.  Pada saat yang sama, lapisan dasar yang disiapkan oleh satu tim bertindak sebagai citra perantara bagi mereka yang bertanggung jawab atas lapisan pada tingkat yang lebih tinggi.  Meskipun kadang-kadang gambar menengah seperti itu dapat digunakan secara mandiri, terutama saat pengujian. <br><br><h4>  Gambar Serba Guna (Intermodal) </h4><br>  Gambar wadah multiguna adalah gambar dengan arsitektur hybrid.  Misalnya, banyak gambar di Red Hat Software Collections dapat digunakan dalam dua cara.  Pertama, sebagai wadah aplikasi reguler dengan Ruby penuh pada Rails dan server Apache.  Kedua, Anda dapat menggunakannya sebagai gambar pembangun untuk Platform OpenShift Container dan membuat gambar anak berdasarkan mereka yang mengandung Ruby on Rails, Apache, dan kode aplikasi yang Anda berikan ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sumber untuk</a> proses <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">gambar</a> ketika membangun gambar anak seperti itu. <br><br>  Perhatikan bahwa gambar multiguna semakin populer karena memungkinkan Anda menyelesaikan dua tugas yang berbeda secara mendasar menggunakan gambar yang sama. <br><br><h4>  Wadah sistem </h4><br>  Saat menggunakan perangkat lunak sistem dalam bentuk wadah, yang terakhir sering membutuhkan hak pengguna super.  Untuk menyederhanakan opsi penyebaran ini dan memastikan bahwa wadah seperti itu diluncurkan sebelum runtime wadah dan sistem orkestrasi diluncurkan, Red Hat telah mengembangkan templat khusus yang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">wadah sistem</a> .  Kontainer ini diluncurkan selama proses boot OS menggunakan systemd dan perintah atom, yang membuatnya independen dari runtime atau sistem orkestrasi container.  Hari ini, Red Hat menawarkan wadah sistem untuk rsyslog, kokpit, dll, dan flanneld dan akan memperluas daftar ini di masa depan. <br><br>  Wadah sistem sangat menyederhanakan penambahan selektif layanan ini ke Red Hat Enterprise Linux dan Atomic Host. <br><br><h3>  Kesimpulan </h3><br>  Kontainer tampaknya menjadi hal yang agak sederhana bagi konsumen akhir, tetapi banyak pertanyaan muncul ketika membangun lingkungan produksi wadah.  Untuk membahas arsitektur dan metode membangun lingkungan seperti itu, diperlukan terminologi yang seragam untuk semua peserta.  Semakin Anda mempelajari desain dan konstruksi lingkungan seperti itu, semakin banyak jebakan yang muncul.  Akhirnya, kami hanya mengingat beberapa dari mereka. <br><br>  Orang-orang sering tidak melihat perbedaan antara istilah "container image" dan "repository", terutama ketika mereka digunakan dalam perintah buruh pelabuhan.  Tetapi jika Anda dapat menggunakan perintah tanpa memahami perbedaan, maka ketika bekerja pada arsitektur lingkungan kontainer, Anda harus memahami dengan jelas bahwa repositori benar-benar struktur data utama. <br><br>  Cukup mudah untuk salah memahami perbedaan antara ruang nama, repositori, lapisan gambar, dan tag.  Masing-masing memiliki tujuan dalam arsitektur wadah.  Dan meskipun pemasok dan pengguna menggunakannya untuk berbagai tujuan, mereka hanyalah alat. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/du/gj/fh/dugjfhpr95u8484ca-bttbr-3no.png"></div><br><br>  Tujuan artikel ini adalah untuk membantu Anda memahami terminologi sehingga Anda dapat membuat arsitektur yang lebih maju.  Misalnya, bayangkan Anda baru saja ditugaskan untuk mengembangkan infrastruktur yang harus membatasi ketersediaan ruang nama, repositori, dan terlebih lagi, tag dan layer tergantung pada peran dan aturan bisnis.  Dan yang terakhir - ingat bahwa cara wadah disusun sebagian besar menentukan bagaimana mulainya (orkestrasi, hak istimewa, dll.). </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id416827/">https://habr.com/ru/post/id416827/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id416817/index.html">Posisi Ketiga dalam tahap kualifikasi DataScienceGame 2018</a></li>
<li><a href="../id416819/index.html">Perpisahan, microservices: dari seratus anak bermasalah hingga satu superstar</a></li>
<li><a href="../id416821/index.html">Cara Kerja JS: Komunikasi WebRTC dan P2P</a></li>
<li><a href="../id416823/index.html">Darah, Keringat, dan Piksel: Tentang Buku Jason Schreier</a></li>
<li><a href="../id416825/index.html">Bagaimana TIDAK menjadi pengembang biasa-biasa saja</a></li>
<li><a href="../id416829/index.html">Pola Model ABI v0.5.6 Beta</a></li>
<li><a href="../id416831/index.html">Routing eksternal dari lalu lintas domestik Rusia akan dikurangi menjadi 5%</a></li>
<li><a href="../id416833/index.html">Selamat datang di MskDotNet Meetup # 24</a></li>
<li><a href="../id416837/index.html"># Dashanalune 0</a></li>
<li><a href="../id416839/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 3: Buffer Overflows: Eksploitasi dan Perlindungan, Bagian 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>