<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ûó üíã ‚èÆÔ∏è El rendimiento incomprensible de la programaci√≥n m√∫ltiple üòû üîö üÜé</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bajo la escena, se propone un descifrado del informe de Stefan Karpinsky, uno de los desarrolladores clave del lenguaje Julia. En el informe, analiza ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>El rendimiento incomprensible de la programaci√≥n m√∫ltiple</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/468609/"><p>  Bajo la escena, se propone un descifrado del informe de Stefan Karpinsky, uno de los desarrolladores clave del lenguaje Julia.  En el informe, analiza los resultados inesperados del despacho m√∫ltiple conveniente y eficiente, tomado como el paradigma principal de Julia. </p><a name="habracut"></a><br><iframe width="560" height="315" src="https://www.youtube.com/embed/kc9HwsxE1OY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <em>De un traductor</em> : el t√≠tulo del informe hace referencia a un art√≠culo de Eugene Wigner, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"La eficacia incomprensible de las matem√°ticas en las ciencias naturales"</a> . </p><br><p> La programaci√≥n m√∫ltiple es un paradigma clave del lenguaje Julia, y durante su existencia, nosotros, los desarrolladores del lenguaje, notamos algo esperado, pero al mismo tiempo desconcertante.  Al menos no esper√°bamos esto en la medida en que lo vimos.  Esto es algo: un asombroso nivel de reutilizaci√≥n de c√≥digo en el ecosistema de Julia, que es mucho m√°s alto que en cualquier otro idioma que conozco. </p><br><p>  Constantemente vemos que algunas personas escriben c√≥digo generalizado, otra persona define un nuevo tipo de datos, estas personas no est√°n familiarizadas entre s√≠, y luego alguien aplica este c√≥digo a este tipo de datos inusual ... Y todo simplemente funciona.  Y esto sucede <em>sorprendentemente a menudo</em> . <br>  Siempre pens√© que ese comportamiento deber√≠a esperarse de la programaci√≥n orientada a objetos, pero utilic√© muchos lenguajes orientados a objetos, y resulta que generalmente no todo funciona en ellos.  Por lo tanto, en alg√∫n momento pens√©: ¬øpor qu√© Julia es un lenguaje tan efectivo en este sentido?  ¬øPor qu√© el nivel de reutilizaci√≥n del c√≥digo es tan alto all√≠?  Y tambi√©n: ¬øqu√© lecciones se pueden aprender de esto que otros idiomas podr√≠an tomar prestados de Julia para mejorar? </p><br><p>  A veces, cuando digo esto, el p√∫blico no me cree, pero usted ya est√° en JuliaCon, por lo que sabe lo que est√° sucediendo, por lo que me centrar√© en por qu√©, en mi opini√≥n, esto est√° sucediendo. </p><br><p>  Pero para empezar, uno de mis ejemplos favoritos. </p><br><p><img src="https://habrastorage.org/webt/mv/o0/i8/mvo0i8xjflhnxxuurnshmsfolbi.png"></p><br><p> En la diapositiva es el resultado del trabajo de Chris Rakaukas.  Escribe todo tipo de paquetes <em>muy generalizados</em> para resolver ecuaciones diferenciales.  Puedes alimentar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">n√∫meros duales</a> o BigFloat, lo que quieras.  Y de alguna manera decidi√≥ que quer√≠a ver el error del resultado de integraci√≥n.  Y hab√≠a un paquete de Mediciones que puede rastrear tanto el valor de una cantidad f√≠sica como la propagaci√≥n de un error a trav√©s de una secuencia de f√≥rmulas.  Este paquete tambi√©n admite una sintaxis elegante para valores de incertidumbre utilizando el car√°cter Unicode <code>¬±</code> .  Aqu√≠ en la diapositiva se muestra que la aceleraci√≥n de la gravedad, la longitud del p√©ndulo, la velocidad inicial, el √°ngulo de desviaci√≥n se conocen con alg√∫n tipo de error.  Entonces, usted define un p√©ndulo simple, pasa sus ecuaciones de movimiento a trav√©s del ODE solucionador y - <strong>¬°bam!</strong>  <em>Todo funciona</em> .  Y ves un gr√°fico con inexactitudes de bigote.  Y todav√≠a no demuestro que el c√≥digo para dibujar el gr√°fico tambi√©n est√° generalizado, y simplemente ingresas el valor con un error de Measurements.jl y obtienes un gr√°fico con errores. </p><br><p>  El nivel de compatibilidad de los diferentes paquetes y la generalizaci√≥n del c√≥digo es simplemente una carga de cerebro.  <em>¬øC√≥mo <strong>funciona</strong> ?</em>  Resulta que si. </p><br><p>  Bueno, no es <em>que</em> no esper√°ramos esto en absoluto.  Despu√©s de todo, incluimos el concepto de despacho m√∫ltiple en el lenguaje <em>precisamente</em> porque nos permite expresar algoritmos generalizados.  Entonces, todo lo anterior no es tan loco.  Pero una cosa es saber esto en teor√≠a y otra ver en la pr√°ctica que el enfoque realmente funciona.  Despu√©s de todo, el despacho √∫nico y la sobrecarga del operador en C ++ tambi√©n deber√≠an dar un resultado similar, pero en realidad a menudo no funcionan como les gustar√≠a. </p><br><p>  Adem√°s, estamos presenciando algo m√°s de lo que hab√≠amos previsto al desarrollar el lenguaje: no solo se est√° escribiendo un c√≥digo generalizado.  A continuaci√≥n, intentar√© decir qu√©, en mi opini√≥n, es m√°s. </p><br><p>  Entonces, hay dos tipos de reutilizaci√≥n de c√≥digo, y son bastante diferentes.  Uno es algoritmos generalizados, y esto es lo primero que recuerdan.  El segundo aspecto, menos obvio, pero que parece ser m√°s importante, es la simplicidad con la que Julia usa los mismos tipos de datos en una amplia variedad de paquetes.  Hasta cierto punto, esto sucede porque los m√©todos de tipo no se convierten en un obst√°culo para su uso: no es necesario estar de acuerdo con el autor del tipo sobre las interfaces y los m√©todos que hereda;  simplemente puede decir: "Oh, me gusta este tipo de RGB. Desarrollar√© mis propias operaciones, pero me gusta su estructura". </p><br><h3 id="predislovie-mnozhestvennaya-dispetcherizaciya-protiv-peregruzki-funkciy">  Pr√≥logo  Programaci√≥n m√∫ltiple versus sobrecarga de funciones </h3><br><p>  Ahora tengo que mencionar la sobrecarga de funciones en C ++ o Java, ya que constantemente me hacen preguntas sobre ellas.  A primera vista, no es diferente de la programaci√≥n m√∫ltiple.  ¬øCu√°l es la diferencia y por qu√© es peor la sobrecarga de funciones? </p><br><p>  Comenzar√© con un ejemplo sobre Julia: </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">abstract type</span></span> Pet <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Dog &lt;: Pet; name::<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> Cat &lt;: Pet; name::<span class="hljs-built_in"><span class="hljs-built_in">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> encounter(a::Pet, b::Pet) verb = meets(a, b) println(<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$(a.name)</span></span></span><span class="hljs-string"> meets </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">$(b.name)</span></span></span><span class="hljs-string"> and </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$verb</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> meets(a::Dog, b::Dog) = <span class="hljs-string"><span class="hljs-string">"sniffs"</span></span> meets(a::Dog, b::Cat) = <span class="hljs-string"><span class="hljs-string">"chases"</span></span> meets(a::Cat, b::Dog) = <span class="hljs-string"><span class="hljs-string">"hisses"</span></span> meets(a::Cat, b::Cat) = <span class="hljs-string"><span class="hljs-string">"slinks"</span></span></code> </pre> <br><p>  Definimos un tipo abstracto de <code>Pet</code> , le presentamos los subtipos de <code>Dog</code> y <code>Cat</code> , tienen un campo de nombre (el c√≥digo se repite un poco, pero es tolerable) y define una funci√≥n generalizada de "reuni√≥n" que toma dos objetos de tipo <code>Pet</code> argumentos.  En √©l, primero calculamos la "acci√≥n" determinada por el resultado de llamar a la funci√≥n generalizada <code>meet()</code> , y luego imprimimos la oraci√≥n que describe la reuni√≥n.  En la funci√≥n <code>meets()</code> , utilizamos el env√≠o m√∫ltiple para determinar la acci√≥n que realiza un animal cuando se encuentra con otro. </p><br><p>  Agregue un par de perros y un par de gatos y vea los resultados de la reuni√≥n: </p><br><pre> <code class="julia hljs">fido = Dog(<span class="hljs-string"><span class="hljs-string">"Fido"</span></span>) rex = Dog(<span class="hljs-string"><span class="hljs-string">"Rex"</span></span>) whiskers = Cat(<span class="hljs-string"><span class="hljs-string">"Whiskers"</span></span>) spots = Cat(<span class="hljs-string"><span class="hljs-string">"Spots"</span></span>) encounter(fido, rex) encounter(rex, whiskers) encounter(spots, fido) encounter(whiskers, spots)</code> </pre> <br><p>  Ahora "traduciremos" lo mismo a C ++ lo m√°s literalmente posible.  Defina la clase <code>Pet</code> con el campo de <code>name</code> : en C ++ podemos hacer esto (por cierto, una de las ventajas de C ++ es que los campos de datos pueden incluso agregarse a tipos abstractos. Luego definimos la funci√≥n de <code>meets()</code> , definir la funci√≥n de <code>encounter()</code> para dos objetos de tipo <code>Pet</code> y, Finalmente, defina las clases derivadas <code>Dog</code> y <code>Cat</code> y realice una sobrecarga para ellos <code>meets()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Pet</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> name; }; <span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">meets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Pet a, Pet b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"FALLBACK"</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encounter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Pet a, Pet b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> verb = meets(a, b); <span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; a.name &lt;&lt; <span class="hljs-string"><span class="hljs-string">" meets "</span></span> &lt;&lt; b. name &lt;&lt; <span class="hljs-string"><span class="hljs-string">" and "</span></span> &lt;&lt; verb &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Cat</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Pet {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Dog</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Pet {}; <span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">meets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Dog a, Dog b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"sniffs"</span></span>; } <span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">meets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Dog a, Cat b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"chases"</span></span>; } <span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">meets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cat a, Dog b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"hisses"</span></span>; } <span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">meets</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Cat a, Cat b)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"slinks"</span></span>; }</code> </pre> <br><p>  La funci√≥n <code>main()</code> , como en el c√≥digo de Julia, crea perros y gatos y los hace cumplir: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ Dog fido; fido.name = <span class="hljs-string"><span class="hljs-string">"Fido"</span></span>; Dog rex; rex.name = <span class="hljs-string"><span class="hljs-string">"Rex"</span></span>; Cat whiskers; whiskers.name = <span class="hljs-string"><span class="hljs-string">"Whiskers"</span></span>; Cat spots; spots.name = <span class="hljs-string"><span class="hljs-string">"Spots"</span></span>; encounter(fido, rex); encounter(rex, whiskers); encounter(spots, fido); encounter(whiskers, spots); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br><p>  Entonces, despacho m√∫ltiple contra sobrecarga de funciones.  Gong! </p><br><p><img src="https://habrastorage.org/webt/sj/6u/ob/sj6uobzsl8adbgqxjlxuibpcnpc.png"></p><br><p>  ¬øQu√© crees que devolver√° el c√≥digo con despacho m√∫ltiple? </p><br><div class="spoiler">  <b class="spoiler_title">$ julia pets.jl</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">Fido meets Rex and sniffs Rex meets Whiskers and chases Spots meets Fido and hisses Whiskers meets Spots and slinks</code> </pre> <br><p>  Los animales se encuentran, huelen, silban y se ponen al d√≠a, como se pretend√≠a. </p></div></div><br><div class="spoiler">  <b class="spoiler_title">$ g ++ -o mascotas pets.cpp &amp;&amp; ./pets</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">Fido meets Rex and FALLBACK Rex meets Whiskers and FALLBACK Spots meets Fido and FALLBACK Whiskers meets Spots and FALLBACK</code> </pre> <br><p>  En todos los casos, se devuelve la opci√≥n "reserva". </p><br><p>  Por qu√©  Porque as√≠ es como funciona la sobrecarga de funciones.  Si el despacho m√∫ltiple funcion√≥, entonces se <code>meets(a, b)</code> en el <code>encounter()</code> interno <code>encounter()</code> con los tipos espec√≠ficos que <code>a</code> y <code>b</code> ten√≠an en el momento de la llamada.  Pero se aplica una sobrecarga, por lo tanto, se llama a <code>meets()</code> para los tipos <em>est√°ticos</em> <code>b</code> , que en este caso son <code>Pet</code> . </p></div></div><br><p>  Entonces, en el enfoque de C ++, la "traducci√≥n" directa del c√≥digo gen√©rico de Julia no proporciona el comportamiento deseado debido al hecho de que el compilador utiliza tipos que se derivan est√°ticamente en la etapa de compilaci√≥n.  Y el punto es que queremos llamar a una funci√≥n basada en tipos concretos reales que las variables tienen en tiempo de ejecuci√≥n.  Las funciones de plantilla, aunque mejoran un poco la situaci√≥n, a√∫n requieren conocimiento de todos los tipos incluidos en la expresi√≥n est√°ticamente en tiempo de compilaci√≥n, y es f√°cil encontrar un ejemplo en el que esto ser√≠a imposible. </p><br><p>  Para m√≠, tales ejemplos muestran que el despacho m√∫ltiple hace lo correcto, y todos los dem√°s enfoques no son una muy buena aproximaci√≥n al resultado correcto. </p><br><p>  Ahora veamos una tabla as√≠.  Espero que lo encuentres significativo: </p><br><div class="scrollable-table"><table><thead><tr><th>  Tipo de programaci√≥n </th><th>  Sintaxis </th><th>  Argumentos de env√≠o </th><th>  Grado de expresividad </th><th>  Oportunidad expresiva </th></tr></thead><tbody><tr><td>  no </td><td>  f (x <sub>1</sub> , x <sub>2</sub> , ...) </td><td>  {} </td><td>  O (1) </td><td>  constante </td></tr><tr><td>  solitario </td><td>  x <sub>1</sub> .f (x <sub>2</sub> , ...) </td><td>  {x <sub>1</sub> } </td><td>  O (| X <sub>1</sub> |) </td><td>  lineal </td></tr><tr><td>  multiples </td><td>  f (x <sub>1</sub> , x <sub>2</sub> , ...) </td><td>  {x <sub>1</sub> , x <sub>2</sub> , ...} </td><td>  O (| X <sub>1</sub> | | X <sub>2</sub> | ...) </td><td>  exponencial </td></tr></tbody></table></div><br><p>  En lenguajes sin despacho, simplemente escribe <code>f(x, y, ...)</code> , los tipos de todos los argumentos son fijos, es decir  una llamada a <code>f()</code> es una llamada a una sola funci√≥n <code>f()</code> , que puede estar en el programa.  El grado de expresividad es constante: llamar a <code>f()</code> siempre hace una y solo una cosa.  El despacho √∫nico fue un gran avance en la transici√≥n a la OOP en los a√±os 90 y 2000.  La sintaxis de puntos generalmente se usa, lo que a la gente realmente le gusta.  Y aparece una oportunidad expresiva adicional: la llamada se despacha de acuerdo con el tipo de objeto x <sub>1</sub> .  Una oportunidad expresiva se caracteriza por el poder del conjunto | X <sub>1</sub> |  tipos que tienen el m√©todo <code>f()</code> .  Sin embargo, en el despacho m√∫ltiple, el n√∫mero de posibles opciones para la funci√≥n <code>f()</code> es igual a la potencia del producto cartesiano de conjuntos de tipos a los que pueden pertenecer los argumentos.  En realidad, por supuesto, casi nadie necesita tantas funciones diferentes en un solo programa.  Pero el punto clave aqu√≠ es que el programador recibe una forma simple y natural de usar cualquier elemento de esta variedad, y esto conduce a un crecimiento exponencial de oportunidades. </p><br><h3 id="chast-1-obobschyonnoe-programmirovanie">  Parte 1. Programaci√≥n general </h3><br><p>  Hablemos del c√≥digo generalizado, la caracter√≠stica principal del despacho m√∫ltiple. </p><br><p>  Aqu√≠ hay un ejemplo (completamente artificial) de c√≥digo gen√©rico: </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> LinearAlgebra <span class="hljs-keyword"><span class="hljs-keyword">function</span></span> inner_sum(A, vs) t = zero(eltype(A)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> v <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> vs t += inner(v, A, v) <span class="hljs-comment"><span class="hljs-comment">#  ! end return t end inner(v, A, w) = dot(v, A * w) #   </span></span></code> </pre> <br><p>  Aqu√≠ <code>A</code> es algo similar a una matriz (aunque no indiqu√© los tipos, y puedo adivinar algo por su nombre), <code>vs</code> es el vector de algunos elementos similares a vectores, y luego el producto escalar se considera a trav√©s de esta "matriz", para lo cual se da una definici√≥n generalizada sin especificar ning√∫n tipo.  La programaci√≥n generalizada aqu√≠ consiste en esta llamada de la funci√≥n <code>inner()</code> en un bucle (consejo profesional: si desea escribir c√≥digo generalizado, simplemente elimine cualquier restricci√≥n de tipo). </p><br><p>  Entonces, "mira, mam√°, funciona": </p><br><pre> <code class="julia hljs">julia&gt; A = rand(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-number"><span class="hljs-number">3</span></span>√ó<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>,<span class="hljs-number"><span class="hljs-number">2</span></span>}: <span class="hljs-number"><span class="hljs-number">0.934255</span></span> <span class="hljs-number"><span class="hljs-number">0.712883</span></span> <span class="hljs-number"><span class="hljs-number">0.734033</span></span> <span class="hljs-number"><span class="hljs-number">0.145575</span></span> <span class="hljs-number"><span class="hljs-number">0.148775</span></span> <span class="hljs-number"><span class="hljs-number">0.131786</span></span> <span class="hljs-number"><span class="hljs-number">0.631839</span></span> <span class="hljs-number"><span class="hljs-number">0.688701</span></span> <span class="hljs-number"><span class="hljs-number">0.632088</span></span> julia&gt; vs = [rand(<span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>] <span class="hljs-number"><span class="hljs-number">4</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Float64</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>},<span class="hljs-number"><span class="hljs-number">1</span></span>}: [<span class="hljs-number"><span class="hljs-number">0.424535</span></span>, <span class="hljs-number"><span class="hljs-number">0.536761</span></span>, <span class="hljs-number"><span class="hljs-number">0.854301</span></span>] [<span class="hljs-number"><span class="hljs-number">0.715483</span></span>, <span class="hljs-number"><span class="hljs-number">0.986452</span></span>, <span class="hljs-number"><span class="hljs-number">0.82681</span></span>] [<span class="hljs-number"><span class="hljs-number">0.487955</span></span>, <span class="hljs-number"><span class="hljs-number">0.43354</span></span>, <span class="hljs-number"><span class="hljs-number">0.634452</span></span>] [<span class="hljs-number"><span class="hljs-number">0.100029</span></span>, <span class="hljs-number"><span class="hljs-number">0.448316</span></span>, <span class="hljs-number"><span class="hljs-number">0.603441</span></span>] julia&gt; inner_sum(A, vs) <span class="hljs-number"><span class="hljs-number">6.825340887556694</span></span></code> </pre> <br><p>  Nada especial, calcula alg√∫n valor.  <em>Pero</em> , el c√≥digo est√° escrito en un estilo generalizado y funcionar√° para cualquier <code>A</code> y <code>vs</code> , si solo fuera posible realizar las operaciones correspondientes en ellos. </p><br><p>  En cuanto a la eficiencia en tipos de datos espec√≠ficos, qu√© suerte.  Quiero decir que para vectores y matrices densas este c√≥digo lo har√° "como deber√≠a", generar√° c√≥digo de m√°quina con la invocaci√≥n de operaciones BLAS, etc.  etc.  Si pasa matrices est√°ticas, el compilador lo tendr√° en cuenta, ampliar√° los ciclos, aplicar√° la vectorizaci√≥n: todo es como deber√≠a. </p><br><p>  Pero lo que es m√°s importante, el c√≥digo funcionar√° para nuevos tipos, ¬°y puede hacerlo no solo s√∫per eficiente, sino s√∫per eficiente!  Definamos un nuevo tipo (este es el tipo de datos real que se utiliza en el aprendizaje autom√°tico), un vector unitario (vector de un solo hot).  Este es un vector en el que uno de los componentes es 1, y todos los dem√°s son cero.  Puede imaginarlo de manera muy compacta: todo lo que necesita almacenarse es la longitud del vector y el n√∫mero del componente distinto de cero. </p><br><pre> <code class="julia hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Base: size, getindex, * <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> OneHotVector &lt;: <span class="hljs-built_in"><span class="hljs-built_in">AbstractVector</span></span>{<span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>} len :: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> ind :: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> size(v::OneHotVector) = (v.len,) getindex(v::OneHotVector, i::<span class="hljs-built_in"><span class="hljs-built_in">Integer</span></span>) = <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span>(i == v.ind)</code> </pre> <br><p>  De hecho, esta es realmente la definici√≥n de tipo completo del paquete que lo agrega.  Y con esta definici√≥n, <code>inner_sum()</code> tambi√©n funciona: </p><br><pre> <code class="julia hljs">julia&gt; vs = [OneHotVector(<span class="hljs-number"><span class="hljs-number">3</span></span>, rand(<span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">3</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>:<span class="hljs-number"><span class="hljs-number">4</span></span>] <span class="hljs-number"><span class="hljs-number">4</span></span>-element <span class="hljs-built_in"><span class="hljs-built_in">Array</span></span>{OneHotVector,<span class="hljs-number"><span class="hljs-number">1</span></span>}: [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>] [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>] [<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>] julia&gt; inner_sum(A, vs) <span class="hljs-number"><span class="hljs-number">2.6493739294755123</span></span></code> </pre> <br><p>  Pero para un producto escalar, aqu√≠ se usa una definici√≥n general: ¬°para este tipo de datos es lento, no genial! </p><br><p>  Entonces, las definiciones generales funcionan, pero no siempre de manera √≥ptima, y ‚Äã‚Äãocasionalmente puede encontrar esto cuando se usa a Julia: "bueno, se llama a una definici√≥n general, es por eso que este c√≥digo GPU ha estado funcionando durante la quinta hora ..." </p><br><p>  En <code>inner()</code> por defecto, se llama a la definici√≥n general del producto matricial por un vector, que cuando se multiplica por un vector unitario devuelve una copia de una de las columnas del tipo <code>Vector{Float64}</code> .  Luego, la definici√≥n general del producto escalar <code>dot()</code> se llama con el vector unitario y esta columna, que hace mucho trabajo innecesario.  De hecho, para cada componente est√° marcado "¬øeres igual a uno? ¬øY t√∫?"  etc. </p><br><p>  Podemos optimizar en gran medida este procedimiento.  Por ejemplo, reemplazando la multiplicaci√≥n de matrices con <code>OneHotVector</code> simplemente seleccionando una columna.  Bien, define este m√©todo, y eso es todo. </p><br><pre> <code class="julia hljs">*(A::<span class="hljs-built_in"><span class="hljs-built_in">AbstractMatrix</span></span>, v::OneHotVector) = A[:, v.ind]</code> </pre> <br><p>  Y aqu√≠ est√°, <strong>poder</strong> : decimos "queremos enviarnos <em>al segundo argumento</em> " <em>,</em> sin importar lo que haya en el primero.  Tal definici√≥n simplemente sacar√° la fila de la matriz y ser√° mucho m√°s r√°pido que el m√©todo general: se elimina la iteraci√≥n y la suma de columnas. </p><br><p>  Pero puede ir m√°s all√° y optimizar directamente <code>inner()</code> , porque multiplicar dos vectores unitarios a trav√©s de una matriz simplemente extrae un elemento de esta matriz: </p><br><pre> <code class="julia hljs">inner(v::OneHotVector, A, w::OneHotVector) = A[v.ind, w.ind]</code> </pre> <br><p>  Esa es la prometida eficiencia s√∫per duper.  Y todo lo que se necesita es definir este m√©todo <code>inner()</code> . </p><br><p>  Este ejemplo muestra una de las aplicaciones de la programaci√≥n m√∫ltiple: existe una definici√≥n general de una funci√≥n, pero para algunos tipos de datos no funciona de manera √≥ptima.  Y luego agregamos un m√©todo que preserva el <em>comportamiento</em> de la funci√≥n para estos tipos, pero funciona de manera mucho <em>m√°s eficiente</em> . </p><br><p>  Pero hay otra √°rea: cuando no hay una definici√≥n general de una funci√≥n, pero quiero agregar funcionalidad para algunos tipos.  Luego puede agregarlo con un m√≠nimo esfuerzo. </p><br><p>  Y la tercera opci√≥n: solo desea tener el mismo nombre de funci√≥n, pero con un comportamiento diferente para diferentes tipos de datos, por ejemplo, para que una funci√≥n se comporte de manera diferente cuando se trabaja con diccionarios y matrices. </p><br><p>  ¬øC√≥mo obtener un comportamiento similar en los idiomas de despacho √∫nico?  Es posible, pero dif√≠cil.  Problema: al sobrecargar la funci√≥n <code>*</code> era necesario despachar el segundo argumento y no el primero.  Puede hacer doble despacho: primero, despachar por el primer argumento y llamar al m√©todo <code>AbstractMatrix.*(v)</code> .  Y este m√©todo, a su vez, llama a algo como <code>v.__rmul__(A)</code> , es decir  El segundo argumento en la llamada original se ha convertido en el objeto cuyo m√©todo se llama realmente.  <code>__rmul__</code> toma <code>__rmul__</code> de Python, donde dicho comportamiento es un patr√≥n est√°ndar, pero parece funcionar solo para la suma y la multiplicaci√≥n.  Es decir  El problema del doble despacho se resuelve si queremos llamar a una funci√≥n llamada <code>+</code> o <code>*</code> , de lo contrario, por desgracia, no es nuestro d√≠a.  En C ++ y otros lenguajes, debes construir tu bicicleta. </p><br><p>  OK, ¬øqu√© hay de <code>inner()</code> ?  Ahora hay tres argumentos, y el despacho contin√∫a con el primero y el tercero.  Qu√© hacer en idiomas con despacho √∫nico no est√° claro.  "Triple despacho" que nunca conoc√≠ en vivo.  No hay buenas soluciones.  Por lo general, cuando surge una necesidad similar (y en los c√≥digos num√©ricos aparece con mucha frecuencia), las personas eventualmente implementan su sistema de despacho m√∫ltiple.  Si observa proyectos grandes para c√°lculos num√©ricos en Python, se sorprender√° de cu√°ntos de ellos van de esta manera.  Naturalmente, tales implementaciones funcionan situacionalmente, mal dise√±adas, llenas de errores y lentas ( <em>referencia a la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">d√©cima regla de Greenspan</a> - aprox. Transl.</em> ), Porque Jeff Besancon no trabaj√≥ en ninguno de estos proyectos (el <em>autor y jefe de desarrollo del sistema de despacho tipo en Julia - aprox. transl.</em> ). </p><br><h3 id="chast-2-obschie-tipy">  Parte 2. Tipos generales </h3><br><p>  Pasar√© al reverso del paradigma de Julia: los tipos generales.  Este, en mi opini√≥n, es el principal "caballo de batalla" del lenguaje, porque es en esta √°rea donde observo un alto nivel de reutilizaci√≥n de c√≥digo. </p><br><p>  Por ejemplo, suponga que tiene un tipo RGB, como lo que tiene ColorTypes.jl.  No hay nada complicado, solo se unen tres valores.  En aras de la simplicidad, suponemos que el tipo no es param√©trico (pero podr√≠a haber sido), y el autor defini√≥ varias operaciones b√°sicas para √©l que le resultaron √∫tiles.  Tomas este tipo y piensas: "Hmm, me gustar√≠a agregar m√°s operaciones en este tipo".  Por ejemplo, imagine RGB como un espacio vectorial (que, estrictamente hablando, es incorrecto, pero se reducir√° a una primera aproximaci√≥n).  En Julia, simplemente toma y agrega en su c√≥digo todas las operaciones que faltan. </p><br><p>  Surge la pregunta, ¬ø <em>y cho?</em>  ¬øPor qu√© me estoy centrando tanto en esto?  Resulta que en lenguajes orientados a objetos basados ‚Äã‚Äãen clases, este enfoque es sorprendentemente dif√≠cil de implementar.  Dado que las definiciones de m√©todos en estos lenguajes est√°n dentro de la definici√≥n de clase, solo hay dos formas de agregar un m√©todo: edite el c√≥digo de clase para agregar el comportamiento deseado o cree una clase heredera con los m√©todos necesarios. </p><br><p>  La primera opci√≥n infla la definici√≥n de la clase base y tambi√©n obliga al desarrollador de la clase base a cuidar el soporte de todos los m√©todos agregados al cambiar el c√≥digo.  ¬øQu√© podr√≠a alg√∫n d√≠a hacer que tal clase no sea compatible? </p><br><p>  La herencia es una opci√≥n cl√°sica "recomendada", pero no sin fallas.  Primero, debe cambiar el nombre de la clase; deje que ahora no sea <code>RGB</code> , sino <code>MyRGB</code> .  Adem√°s, los nuevos m√©todos ya no funcionar√°n para la clase <code>RGB</code> original;  si deseo aplicar mi nuevo m√©todo a un objeto <code>RGB</code> creado en el c√≥digo de otra persona, necesito convertirlo o envolverlo en <code>MyRGB</code> .  Pero esto no es lo peor.  Si hice una clase <code>MyRGB</code> con alguna funcionalidad adicional, alguien m√°s <code>OurRGB</code> , etc.  - entonces, si alguien quiere una clase que tenga todas las nuevas funcionalidades, debe usar herencia m√∫ltiple (¬°y esto es solo si el lenguaje de programaci√≥n lo permite!). </p><br><p>  Entonces, ambas opciones son m√°s o menos.  Sin embargo, hay otras soluciones: </p><br><ul><li>  Coloque lo funcional en una funci√≥n externa en lugar del m√©todo de clase: vaya a <code>f(x, y)</code> lugar de <code>xf(y)</code> .  Pero luego se pierde el comportamiento generalizado. </li><li>  Escupe sobre la reutilizaci√≥n del c√≥digo (y, me parece, en muchos casos esto sucede).  Simplemente copie una clase <code>RGB</code> alien√≠gena y agregue lo que falta. </li></ul><br><p>  La caracter√≠stica clave de Julia en t√©rminos de reutilizaci√≥n de c√≥digo se reduce casi por completo al hecho de que el <em>m√©todo se define fuera del tipo</em> .  Eso es todo.  Haga lo mismo en los idiomas de env√≠o √∫nico, y los tipos se pueden reutilizar con la misma facilidad.  Toda la historia con "hagamos que los m√©todos sean parte de la clase" es una idea regular, de hecho.  Es cierto que hay un buen punto: el uso de clases como espacios de nombres.  Si escribo <code>xf(y)</code> - no se requiere que <code>f()</code> est√© en el espacio de nombres actual, debe buscarse en el espacio de nombres <code>x</code> .  S√≠, esto es algo bueno, pero ¬øvale la pena todos los dem√°s problemas?  No lo se  En mi opini√≥n, no (aunque mi opini√≥n, como se puede adivinar, es ligeramente parcial). </p><br><h3 id="epilog-problema-vyrazheniya">  Ep√≠logo  El problema de la expresion </h3><br><p>  Hay un problema de programaci√≥n que se not√≥ en los a√±os 70.  Est√° relacionado en gran medida con la verificaci√≥n de tipos est√°ticos, porque apareci√≥ en dichos idiomas.  Es cierto, creo que no tiene nada que ver con la verificaci√≥n de tipos est√°ticos.  La esencia del problema es la siguiente: ¬øes posible cambiar el modelo de datos y el conjunto de operaciones en los datos al mismo tiempo, sin recurrir a t√©cnicas dudosas? </p><br><p>  El problema se puede reducir m√°s o menos a lo siguiente: </p><br><ol><li>  ¬øEs posible agregar f√°cilmente y sin errores <strong>nuevos tipos de datos</strong> a los que <strong>los m√©todos existentes son aplicables</strong> y </li><li>  ¬øEs posible <strong>agregar nuevas operaciones</strong> en <strong>los tipos existentes</strong> ? </li></ol><br><p>  (1) hecho f√°cilmente en lenguajes orientados a objetos y dif√≠cil en funcional, (2) - viceversa.  En este sentido, podemos hablar sobre el dualismo de los enfoques OOP y FP. </p><br><p>  En lenguajes de despacho m√∫ltiple, ambas operaciones son f√°ciles. (1)         , (2) ‚Äî      . <em>   </em> ,    .         ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://en.wikipedia.org/wiki/Expression_problem</a> ),           .     ?  ,   ,     .   , "  ,     " ‚Äî   "    "  .  "  ,     " ,       ,   . </p><br><p>            ,   .  ,  ,   ‚Äî      . </p><br><p>  ,   Julia    (     ),      .    . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/468609/">https://habr.com/ru/post/468609/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../468597/index.html">El hex√°gono de Saturno o c√≥mo reproducir en casa el experimento de cient√≠ficos de la Universidad de Oxford</a></li>
<li><a href="../468601/index.html">Estimaci√≥n del plazo del proyecto. ¬øPor qu√© es casi siempre muy discreto y qu√© hacer al respecto?</a></li>
<li><a href="../468603/index.html">Rutracker ha incluido eSNI. Fin de la era DPI y fin de las cerraduras</a></li>
<li><a href="../468605/index.html">Punteros constantes a punteros a punteros ...</a></li>
<li><a href="../468607/index.html">Android para el ingeniero de radio (segunda parte)</a></li>
<li><a href="../468611/index.html">Multiproceso .NET: cuando falta rendimiento</a></li>
<li><a href="../468615/index.html">Los 10 idiomas principales para la localizaci√≥n de aplicaciones</a></li>
<li><a href="../468621/index.html">Traducimos la red dom√©stica a DoH u otro clic en el filtro de nariz</a></li>
<li><a href="../468623/index.html">Quiero comentarios sobre Habr</a></li>
<li><a href="../468625/index.html">Sin servidor: 15% m√°s lento y ocho veces m√°s caro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>