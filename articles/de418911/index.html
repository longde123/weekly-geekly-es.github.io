<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö© üè• üó∫Ô∏è [DotNetBook] Span: Neuer .NET-Datentyp üöä ‚ôåÔ∏è üòó</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mit diesem Artikel ver√∂ffentliche ich weiterhin eine Reihe von Artikeln, deren Ergebnis ein Buch √ºber die Arbeit von .NET CLR und .NET im Allgemeinen ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>[DotNetBook] Span: Neuer .NET-Datentyp</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/418911/"><p><img width="350" src="https://habrastorage.org/webt/vh/7j/tq/vh7jtqhzbne4h3rjhprca2pruhu.png" align="left">  Mit diesem Artikel ver√∂ffentliche ich weiterhin eine Reihe von Artikeln, deren Ergebnis ein Buch √ºber die Arbeit von .NET CLR und .NET im Allgemeinen sein wird (ca. 200 Seiten des Buches sind bereits fertig, daher willkommen am Ende des Artikels f√ºr Links). </p><br><p>  Sowohl die Sprache als auch die Plattform gibt es schon seit vielen Jahren: und die ganze Zeit √ºber gab es viele Tools f√ºr die Arbeit mit nicht verwaltetem Code.  Warum kommt nun die n√§chste API f√ºr die Arbeit mit nicht verwaltetem Code heraus, wenn sie tats√§chlich seit vielen, vielen Jahren existiert?  Um diese Frage zu beantworten, reicht es zu verstehen, was vorher fehlte. </p><br><p> Die Entwickler der Plattform haben versucht, uns dabei zu helfen, den Entwicklungsalltag mit nicht verwalteten Ressourcen aufzuhellen: Dies sind automatische Wrapper f√ºr importierte Methoden.  Und Marshalling, das in den meisten F√§llen automatisch funktioniert.  Dies ist auch eine <code>stackallloc</code> Anweisung, die im Kapitel √ºber den Thread-Stack erl√§utert wird.  Wenn jedoch fr√ºhe Entwickler, die C # verwenden, aus der C ++ - Welt stammen (wie ich), kommen sie jetzt aus h√∂heren Sprachen (zum Beispiel kenne ich einen Entwickler, der aus JavaScript stammt).  Was bedeutet das?  Dies bedeutet, dass Menschen zunehmend misstrauisch gegen√ºber nicht verwalteten Ressourcen und Konstrukten sind, die C / C ++ und vor allem Assembler √§hneln. </p><br><blockquote><h3>  Hinweis </h3><br>  Das auf Habr√© ver√∂ffentlichte Kapitel ist nicht aktualisiert und wahrscheinlich bereits etwas veraltet.  Wenden Sie sich daher f√ºr einen neueren Text dem Original zu: <br><br><ul><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  CLR-Buch: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub, Inhaltsverzeichnis</a> </li><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  CLR-Buch: <a href="">GitHub, Kapitel</a> </li><li><img src="https://habrastorage.org/webt/eo/6g/eo/eo6geog0tg5ernqmv2lcmufefta.png">  Release 0.5.2 B√ºcher, PDF: <a href="">GitHub Release</a> </li></ul><br></blockquote><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/97f/1d3/cf0/97f1d3cf0e2a6bf007066eb60a789c31.png"></a> </p><a name="habracut"></a><br><p>  Infolge einer solchen Einstellung gibt es in Projekten immer weniger Inhalte von unsicherem Code und immer mehr Vertrauen in die API der Plattform selbst.  Dies l√§sst sich leicht anhand der Verwendung des <code>stackalloc</code> Konstrukts in offenen Repositorys √ºberpr√ºfen: Es ist vernachl√§ssigbar.  Aber wenn Sie einen Code nehmen, der ihn verwendet: </p><br><p>  <strong>Klasse Interop.ReadDir</strong> <br>  <a href="">/src/mscorlib/shared/Interop/Unix/System.Native/Interop.ReadDir.cs</a> </p><br><pre> <code class="plaintext hljs">unsafe { // s_readBufferSize is zero when the native implementation does not support reading into a buffer. byte* buffer = stackalloc byte[s_readBufferSize]; InternalDirectoryEntry temp; int ret = ReadDirR(dir.DangerousGetHandle(), buffer, s_readBufferSize, out temp); // We copy data into DirectoryEntry to ensure there are no dangling references. outputEntry = ret == 0 ? new DirectoryEntry() { InodeName = GetDirectoryEntryName(temp), InodeType = temp.InodeType } : default(DirectoryEntry); return ret; }</code> </pre> <br><p>  Der Grund f√ºr die Unbeliebtheit wird deutlich.  Schauen Sie, ohne den Code zu lesen, und beantworten Sie eine Frage f√ºr sich selbst: Vertrauen Sie ihm?  Ich kann davon ausgehen, dass die Antwort nein ist.  Dann antworte dem anderen: warum?  Die Antwort wird offensichtlich sein: Zus√§tzlich zum Wort <code>Dangerous</code> , das irgendwie darauf hindeutet, dass etwas schief gehen k√∂nnte, ist der zweite Faktor, der unsere Einstellung beeinflusst, das <code>byte* buffer = stackalloc byte[s_readBufferSize];</code>  und insbesondere <code>byte*</code> .  Diese Aufzeichnung ist ein Ausl√∂ser f√ºr jeden, so dass der Gedanke in meinem Kopf auftaucht: "Was k√∂nnte nicht anders gemacht werden oder was?".  Dann schauen wir uns die Psychoanalyse etwas genauer an: Warum k√∂nnte so ein Gedanke entstehen?  Einerseits verwenden wir Sprachkonstrukte, und die hier vorgeschlagene Syntax ist weit entfernt von beispielsweise C ++ / CLI, mit der Sie √ºberhaupt etwas tun k√∂nnen (einschlie√ülich Einf√ºgungen in reinen Assembler), und andererseits sieht sie ungew√∂hnlich aus. </p><br><p>  Was ist die Frage?  Wie k√∂nnen Entwickler wieder in den Kern des nicht verwalteten Codes zur√ºckkehren?  Es ist notwendig, ihnen ein Gef√ºhl der Ruhe zu geben, damit sie nicht versehentlich aus Unwissenheit einen Fehler machen k√∂nnen.  Warum werden die <code> Span&lt;T&gt;</code> und <code>Memory&lt;T&gt;</code> eingef√ºhrt? </p><br><h2 id="spant-readonlyspant">  Span [T], ReadOnlySpan [T] </h2><br><p>  Der <code>Span</code> Typ repr√§sentiert einen Teil eines bestimmten Datenarrays, einen Teilbereich seiner Werte.  Gleichzeitig k√∂nnen Sie wie im Fall eines Arrays mit Elementen dieses Bereichs sowohl zum Schreiben als auch zum Lesen arbeiten.  Zum √úbertakten und zum allgemeinen Verst√§ndnis vergleichen wir jedoch die Datentypen, f√ºr die eine Implementierung des <code>Span</code> Typs vorgenommen wird, und untersuchen die m√∂glichen Zwecke seiner Einf√ºhrung. </p><br><p>  Der erste Datentyp, √ºber den Sie sprechen m√∂chten, ist ein regul√§res Array.  Bei Arrays sieht die Arbeit mit Span folgenderma√üen aus: </p><br><pre> <code class="plaintext hljs"> var array = new [] {1,2,3,4,5,6}; var span = new Span&lt;int&gt;(array, 1, 3); var position = span.BinarySearch(3); Console.WriteLine(span[position]); // -&gt; 3</code> </pre> <br><p>  Wie wir in diesem Beispiel sehen, erstellen wir zun√§chst ein bestimmtes Datenarray.  Danach erstellen wir einen <code>Span</code> (oder eine Teilmenge), die es dem Code unter Bezugnahme auf das Array selbst erm√∂glicht, nur den Wertebereich zu verwenden, der w√§hrend der Initialisierung angegeben wurde. </p><br><p>  Hier sehen wir die erste Eigenschaft dieses Datentyps: Sie erstellt einen Kontext.  Lassen Sie uns unsere Idee mit Kontexten entwickeln: </p><br><pre> <code class="plaintext hljs">void Main() { var array = new [] {'1','2','3','4','5','6'}; var span = new Span&lt;char&gt;(array, 1, 3); if(TryParseInt32(span, out var res)) { Console.WriteLine(res); } else { Console.WriteLine("Failed to parse"); } } public bool TryParseInt32(Span&lt;char&gt; input, out int result) { result = 0; for (int i = 0; i &lt; input.Length; i++) { if(input[i] &lt; '0' || input[i] &gt; '9') return false; result = result * 10 + ((int)input[i] - '0'); } return true; } ----- 234</code> </pre> <br><p>  Wie wir sehen k√∂nnen, f√ºhrt <code>Span&lt;T&gt;</code> eine Abstraktion des Zugriffs auf ein bestimmtes Ged√§chtnis ein, sowohl zum Lesen als auch zum Schreiben.  Was gibt uns das?  Wenn wir uns daran erinnern, woraus <code>Span</code> sonst noch gemacht werden kann, erinnern wir uns sowohl an nicht verwaltete Ressourcen als auch an Zeilen: </p><br><pre> <code class="plaintext hljs">// Managed array var array = new[] { '1', '2', '3', '4', '5', '6' }; var arrSpan = new Span&lt;char&gt;(array, 1, 3); if (TryParseInt32(arrSpan, out var res1)) { Console.WriteLine(res1); } // String var srcString = "123456"; var strSpan = srcString.AsSpan().Slice(1, 3); if (TryParseInt32(strSpan, out var res2)) { Console.WriteLine(res2); } // void * Span&lt;char&gt; buf = stackalloc char[6]; buf[0] = '1'; buf[1] = '2'; buf[2] = '3'; buf[3] = '4'; buf[4] = '5'; buf[5] = '6'; if (TryParseInt32(buf.Slice(1, 3), out var res3)) { Console.WriteLine(res3); } ----- 234 234 234</code> </pre> <br><p>  Das hei√üt, es stellt sich heraus, dass <code>Span&lt;T&gt;</code> ein Mittel zur Vereinheitlichung beim Arbeiten mit Speicher ist: verwaltet und nicht verwaltet, was die Sicherheit beim Arbeiten mit dieser Art von Daten w√§hrend der Garbage Collection garantiert: Wenn sich Speicherbereiche mit verwalteten Arrays bewegen, dann f√ºr es wird f√ºr uns sicher sein. </p><br><p>  Lohnt es sich jedoch, sich so sehr zu freuen?  K√∂nnte dies alles schon einmal erreicht worden sein?  Wenn wir zum Beispiel √ºber verwaltete Arrays sprechen, gibt es keinen Zweifel: Wickeln Sie das Array einfach in eine andere Klasse ein und stellen Sie eine √§hnliche Schnittstelle bereit. Fertig.  Dar√ºber hinaus kann eine √§hnliche Operation mit Zeichenfolgen durchgef√ºhrt werden: Sie verf√ºgen √ºber die erforderlichen Methoden.  Wiederum wickeln Sie den String einfach in genau den gleichen Typ und stellen Sie Methoden f√ºr die Arbeit damit bereit.  Eine andere Sache ist, dass Sie, um eine Zeichenfolge, einen Puffer oder ein Array in einem Typ zu speichern, viel basteln m√ºssen, indem Sie Links zu jeder der m√∂glichen Optionen in einer einzigen Kopie speichern (nat√ºrlich ist nur eine aktiv): </p><br><pre> <code class="plaintext hljs">public readonly ref struct OurSpan&lt;T&gt; { private T[] _array; private string _str; private T * _buffer; // ... }</code> </pre> <br><p>  Wenn Sie von der Architektur ausgehen, f√ºhren Sie drei Typen aus, die eine einzelne Schnittstelle erben.  Es stellt sich heraus, dass es keine andere M√∂glichkeit als <code>Span&lt;T&gt;</code> gibt, um das Tool zu einer einheitlichen Schnittstelle zwischen diesen verwalteten Datentypen zu machen und gleichzeitig die maximale Leistung aufrechtzuerhalten. </p><br><p>  Was ist eine <code>ref struct</code> in Bezug auf <code>Span</code> , um die Diskussion fortzusetzen?  Dies sind genau die ‚ÄûStrukturen, sie sind nur auf dem Stapel‚Äú, von denen wir so oft in Interviews h√∂ren.  Dies bedeutet, dass dieser Datentyp nur den Stapel durchlaufen kann und nicht das Recht hat, zum Heap zu wechseln.  Daher ist <code>Span</code> als Referenzstruktur ein Kontextdatentyp, der Methoden, jedoch keine Objekte im Speicher bereitstellt.  Aus diesem Grund m√ºssen wir nach seinem Verst√§ndnis fortfahren. </p><br><p>  Von hier aus k√∂nnen wir eine Definition des Span-Typs und des damit verbundenen schreibgesch√ºtzten Typs ReadOnlySpan formulieren: </p><br><blockquote>  Span ist ein Datentyp, der eine einzige Schnittstelle f√ºr die Arbeit mit heterogenen Typen von Datenarrays sowie die M√∂glichkeit bietet, eine Teilmenge dieses Arrays auf eine andere Methode zu √ºbertragen, sodass die Zugriffsgeschwindigkeit auf das urspr√ºngliche Array unabh√§ngig von der Kontexttiefe konstant und so hoch wie m√∂glich ist. </blockquote><p>  Und wirklich: Wenn wir so etwas wie diesen Code haben: </p><br><pre> <code class="plaintext hljs">public void Method1(Span&lt;byte&gt; buffer) { buffer[0] = 0; Method2(buffer.Slice(1,2)); } Method2(Span&lt;byte&gt; buffer) { buffer[0] = 0; Method3(buffer.Slice(1,1)); } Method3(Span&lt;byte&gt; buffer) { buffer[0] = 0; }</code> </pre> <br><p>  Dann ist die Zugriffsgeschwindigkeit auf den Quellpuffer so hoch wie m√∂glich: Sie arbeiten nicht mit einem verwalteten Objekt, sondern mit einem verwalteten Zeiger.  Das hei√üt,  Nicht mit einem von .NET verwalteten Typ, sondern mit einem unsicheren Typ, der in eine verwaltete Shell eingeschlossen ist. </p><br><h3 id="spant-na-primerah">  Span [T] anhand von Beispielen </h3><br><p>  Eine Person ist so arrangiert, dass oft, bis sie eine bestimmte Erfahrung erh√§lt, ein endg√ºltiges Verst√§ndnis daf√ºr, warum ein Werkzeug ben√∂tigt wird, oft nicht kommt.  Da wir also einige Erfahrung ben√∂tigen, wenden wir uns Beispielen zu. </p><br><h4 id="valuestringbuilder">  ValueStringBuilder </h4><br><p>  Eines der algorithmisch interessantesten Beispiele ist der <code>ValueStringBuilder</code> Typ, der irgendwo im Darm von <code>mscorlib</code> und aus irgendeinem Grund wie viele andere interessante Datentypen mit dem <code>internal</code> Modifikator gekennzeichnet ist. Wenn es sich also nicht um das Studium des mscorlib-Quellcodes handelt, werden wir √ºber eine solch wunderbare Optimierungsmethode sprechen w√ºrde es nie erfahren. </p><br><p>  Was ist das Haupt-Minus des StringBuilder-Systemtyps?  Dies ist nat√ºrlich das Wesentliche: Sowohl er selbst als auch das, worauf er basiert (und dies ist eine Reihe von <code>char[]</code> -Zeichen), sind Referenztypen.  Und das bedeutet mindestens zwei Dinge: Wir laden immer noch (wenn auch ein wenig) eine Menge und die zweite - wir erh√∂hen die Wahrscheinlichkeit, dass Prozessor-Caches √ºbersehen werden. </p><br><p>  Eine andere Frage, die ich f√ºr StringBuilder hatte, war die Bildung kleiner Strings.  Das hei√üt,  Wenn die Ergebniszeile "Zahn geben" kurz ist: Zum Beispiel weniger als 100 Zeichen.  Bei relativ kurzer Formatierung treten Leistungsprobleme auf: </p><br><pre> <code class="plaintext hljs"> $"{x} is in range [{min};{max}]"</code> </pre> <br><p>  Wie viel schlimmer ist dieser Datensatz als die manuelle Generierung √ºber StringBuilder?  Die Antwort ist alles andere als immer offensichtlich: Alles h√§ngt vom Ort der Bildung ab: Wie oft wird diese Methode aufgerufen?  Schlie√ülich weist das erste <code>string.Format</code> dem internen <code>StringBuilder</code> Speicher zu, der ein Array von Zeichen (SourceString.Length + args.Length * 8) erstellt. Wenn sich bei der Bildung des Arrays herausstellt, dass die L√§nge nicht erraten wurde, wird ein weiterer <code>StringBuilder</code> erstellt, um die Fortsetzung zu bilden. wodurch eine einfach verbundene Liste gebildet wird.  Infolgedessen muss die generierte Zeile zur√ºckgegeben werden. Dies ist eine weitere Kopie.  Verschwenden und Verschwenden.  Wenn wir es nun schaffen w√ºrden, das erste Array des zu bildenden Strings auf dem Haufen zu platzieren, w√§re es wunderbar: Wir w√ºrden definitiv ein Problem loswerden. </p><br><p>  Schauen Sie sich den Typ aus dem Darm von <code>mscorlib</code> : </p><br><p>  <strong>Klasse ValueStringBuilder</strong> <br>  <a href="">/ src / mscorlib / shared / System / Text / ValueStringBuilder</a> </p><br><pre> <code class="plaintext hljs"> internal ref struct ValueStringBuilder { //           private char[] _arrayToReturnToPool; //     private Span&lt;char&gt; _chars; private int _pos; //    ,       public ValueStringBuilder(Span&lt;char&gt; initialBuffer) { _arrayToReturnToPool = null; _chars = initialBuffer; _pos = 0; } public int Length { get =&gt; _pos; set { int delta = value - _pos; if (delta &gt; 0) { Append('\0', delta); } else { _pos = value; } } } //   -       public override string ToString() { var s = new string(_chars.Slice(0, _pos)); Clear(); return s; } //       //     :   public void Insert(int index, char value, int count) { if (_pos &gt; _chars.Length - count) { Grow(count); } int remaining = _pos - index; _chars.Slice(index, remaining).CopyTo(_chars.Slice(index + count)); _chars.Slice(index, count).Fill(value); _pos += count; } [MethodImpl(MethodImplOptions.AggressiveInlining)] public void Append(char c) { int pos = _pos; if (pos &lt; _chars.Length) { _chars[pos] = c; _pos = pos + 1; } else { GrowAndAppend(c); } } [MethodImpl(MethodImplOptions.NoInlining)] private void GrowAndAppend(char c) { Grow(1); Append(c); } //   ,     //         //            //           [MethodImpl(MethodImplOptions.NoInlining)] private void Grow(int requiredAdditionalCapacity) { Debug.Assert(requiredAdditionalCapacity &gt; _chars.Length - _pos); char[] poolArray = ArrayPool&lt;char&gt;.Shared.Rent(Math.Max(_pos + requiredAdditionalCapacity, _chars.Length * 2)); _chars.CopyTo(poolArray); char[] toReturn = _arrayToReturnToPool; _chars = _arrayToReturnToPool = poolArray; if (toReturn != null) { ArrayPool&lt;char&gt;.Shared.Return(toReturn); } } [MethodImpl(MethodImplOptions.AggressiveInlining)] private void Clear() { char[] toReturn = _arrayToReturnToPool; this = default; // for safety, to avoid using pooled array if this instance is erroneously appended to again if (toReturn != null) { ArrayPool&lt;char&gt;.Shared.Return(toReturn); } } //  :       private void AppendSlow(string s); public bool TryCopyTo(Span&lt;char&gt; destination, out int charsWritten); public void Append(string s); public void Append(char c, int count); public unsafe void Append(char* value, int length); public Span&lt;char&gt; AppendSpan(int length); }</code> </pre> <br><p>  Diese Klasse √§hnelt in ihrer Funktionalit√§t ihrem √§lteren Bruder <code>StringBuilder</code> , hat jedoch eine interessante und sehr wichtige Funktion: Es handelt sich um einen bedeutenden Typ.  Das hei√üt,  vollst√§ndig nach Wert gespeichert und √ºbertragen.  Der neueste Modifikator f√ºr den <code>ref</code> Typ, der der Signatur der Typdeklaration zugewiesen ist, weist darauf hin, dass dieser Typ eine zus√§tzliche Einschr√§nkung aufweist: Er darf nur auf dem Stapel sein.  Das hei√üt,  Die Ausgabe seiner Instanzen in die Klassenfelder f√ºhrt zu einem Fehler.  Warum all diese Kniebeugen?  Um diese Frage zu beantworten, schauen Sie sich einfach die <code>StringBuilder</code> Klasse an, deren Kern wir gerade beschrieben haben: </p><br><p>  <strong>Klasse StringBuilder</strong> <a href="">/src/mscorlib/src/System/Text/StringBuilder.cs</a> </p><br><pre> <code class="plaintext hljs">public sealed class StringBuilder : ISerializable { // A StringBuilder is internally represented as a linked list of blocks each of which holds // a chunk of the string. It turns out string as a whole can also be represented as just a chunk, // so that is what we do. internal char[] m_ChunkChars; // The characters in this block internal StringBuilder m_ChunkPrevious; // Link to the block logically before this block internal int m_ChunkLength; // The index in m_ChunkChars that represent the end of the block internal int m_ChunkOffset; // The logical offset (sum of all characters in previous blocks) internal int m_MaxCapacity = 0; // ... internal const int DefaultCapacity = 16;</code> </pre> <br><p>  StringBuilder ist eine Klasse, in der eine Verkn√ºpfung zu einem Array von Zeichen besteht.  Das hei√üt,  Wenn Sie es erstellen, werden tats√§chlich mindestens zwei Objekte erstellt: der StringBuilder selbst und ein Array von Zeichen mit mindestens 16 Zeichen (√ºbrigens ist es deshalb so wichtig, die gesch√§tzte L√§nge des Strings anzugeben: Bei seiner Konstruktion wird eine einfach verbundene Liste von Arrays mit 16 Zeichen erstellt. )  Was bedeutet dies im Zusammenhang mit unserer Konversation √ºber den Typ ValueStringBuilder: Kapazit√§t fehlt standardm√§√üig, weil  Es nimmt Speicher von au√üen in Anspruch, ist selbst ein bedeutender Typ und zwingt den Benutzer, einen Puffer f√ºr Zeichen auf dem Stapel zuzuweisen.  Infolgedessen wird die gesamte Typinstanz zusammen mit ihrem Inhalt auf den Stapel verschoben, und das Optimierungsproblem wird hier behoben.  Keine Speicherzuordnung auf dem Heap?  Kein Problem mit Leistungseinbu√üen auf dem Haufen.  Aber Sie sagen mir: Warum nicht immer ValueStringBuilder (oder seine selbstgeschriebene Version: Ist es intern und f√ºr uns nicht zug√§nglich) verwenden?  Die Antwort lautet: Sie m√ºssen sich das Problem ansehen, das Sie l√∂sen.  Wird die resultierende Zeichenfolge eine bekannte Gr√∂√üe haben?  Wird es ein bestimmtes bekanntes Maximum an L√§nge haben?  Wenn die Antwort Ja lautet und die Zeichenfolgengr√∂√üe einige vern√ºnftige Grenzen nicht √ºberschreitet, k√∂nnen Sie eine aussagekr√§ftige Version von StringBuilder verwenden.  Wenn wir sonst lange Schlangen erwarten, wechseln wir zur regul√§ren Version. </p><br><h4 id="valuelistbuilder">  ValueListBuilder </h4><br><p>  Der zweite Datentyp, den ich besonders erw√§hnen m√∂chte, ist der <code>ValueListBuilder</code> Typ.  Es wurde f√ºr Situationen erstellt, in denen es erforderlich ist, f√ºr kurze Zeit eine Sammlung von Elementen zu erstellen und diese sofort einem Algorithmus zur Verarbeitung zu √ºbergeben. </p><br><p>  Zustimmen: Die Aufgabe ist der <code>ValueStringBuilder</code> Aufgabe sehr √§hnlich.  Ja, und es wurde auf sehr √§hnliche Weise gel√∂st: </p><br><p>  <strong>Datei <a href="">ValueListBuilder.cs</a></strong> </p><br><p>  Um es ganz klar auszudr√ºcken, solche Situationen sind ziemlich h√§ufig.  Bevor wir diese Frage jedoch auf andere Weise gel√∂st haben: Wir haben eine <code>List</code> , sie mit Daten gef√ºllt und den Link verloren.  Wenn die Methode h√§ufig genug aufgerufen wird, tritt eine traurige Situation auf: Viele Instanzen der <code>List</code> Klasse h√§ngen auf dem Heap, und mit ihnen h√§ngen die ihnen zugeordneten Arrays auf dem Heap.  Jetzt ist dieses Problem behoben: Es werden keine zus√§tzlichen Objekte erstellt.  Wie im Fall von <code>ValueStringBuilder</code> wurde es jedoch nur f√ºr Microsoft-Programmierer gel√∂st: Die Klasse verf√ºgt √ºber einen <code>internal</code> Modifikator. </p><br><h3 id="pravila-i-praktika-ispolzovaniya">  Nutzungsbedingungen </h3><br><p>  Um die Essenz des neuen Datentyps endlich zu verstehen, m√ºssen Sie damit ‚Äûherumspielen‚Äú, indem Sie ein paar Dinge oder besser mehr Methoden schreiben, die ihn verwenden.  Die Grundregeln k√∂nnen jetzt jedoch gelernt werden: </p><br><ul><li>  Wenn Ihre Methode einen eingehenden Datensatz verarbeitet, ohne dessen Gr√∂√üe zu √§ndern, k√∂nnen Sie versuchen, beim <code>Span</code> Typ anzuhalten.  Wenn dieser Puffer nicht <code>ReadOnlySpan</code> Typ <code>ReadOnlySpan</code> . </li><li>  Wenn Ihre Methode mit Zeichenfolgen arbeitet, Statistiken berechnet oder eine Zeichenfolge analysiert, <em>muss</em> Ihre Methode <code>ReadOnlySpan&lt;char&gt;</code> akzeptieren.  Es ist verpflichtet: Dies ist eine neue Regel.  Wenn Sie einen String akzeptieren, zwingen Sie schlie√ülich jemanden, einen Teilstring f√ºr Sie zu erstellen </li><li>  Wenn Sie im Rahmen der Arbeit der Methode ein relativ kurzes Array mit Daten (z. B. maximal 10 KB) erstellen m√ºssen, k√∂nnen Sie ein solches Array einfach mit <code>Span&lt;TType&gt; buf = stackalloc TType[size]</code> .  Nat√ºrlich sollte TType nur ein aussagekr√§ftiger Typ sein, da  <code>stackalloc</code> funktioniert nur mit aussagekr√§ftigen Typen. </li></ul><br><p>  In anderen F√§llen lohnt es sich, entweder den <code>Memory</code> oder die Verwendung klassischer Datentypen genauer zu betrachten. </p><br><h3 id="kak-rabotaet-span">  Wie Span funktioniert </h3><br><p>  Au√üerdem m√∂chte ich dar√ºber sprechen, wie Span funktioniert und was daran so bemerkenswert ist.  Und es gibt etwas zu besprechen: Der Datentyp selbst ist in zwei Versionen unterteilt: f√ºr .NET Core 2.0+ und f√ºr alle anderen. </p><br><p>  <strong><a href="">Span.Fast.cs, .NET Core 2.0-</a> Datei</strong> </p><br><pre> <code class="plaintext hljs">public readonly ref partial struct Span&lt;T&gt; { ///    .NET    internal readonly ByReference&lt;T&gt; _pointer; ///      private readonly int _length; // ... }</code> </pre> <br><p>  <strong>Datei ???</strong>  <strong>[dekompiliert]</strong> </p><br><pre> <code class="plaintext hljs">public ref readonly struct Span&lt;T&gt; { private readonly System.Pinnable&lt;T&gt; _pinnable; private readonly IntPtr _byteOffset; private readonly int _length; // ... }</code> </pre> <br><p>  Die Sache ist, dass das <em>gro√üe</em> .NET Framework und .NET Core 1. * keinen speziell modifizierten Garbage Collector haben (im Gegensatz zur Version von .NET Core 2.0+) und daher gezwungen sind, einen zus√§tzlichen Zeiger entlang zu ziehen: an den Anfang des Puffers, mit dem Arbeit.  Das hei√üt, es stellt sich heraus, dass <code>Span</code> intern mit verwalteten Objekten der .NET-Plattform als nicht verwaltet arbeitet.  Schauen Sie sich die Innenseiten der zweiten Version der Struktur an: Es gibt drei Felder.  Das erste Feld ist eine Referenz auf das verwaltete Objekt.  Der zweite ist der Versatz vom Anfang dieses Objekts in Bytes, um den Anfang des Datenpuffers zu erhalten (in Zeilen ist es ein Puffer mit Zeichen, in Arrays ein Puffer mit Arraydaten).  Und schlie√ülich ist das dritte Feld die Anzahl der Elemente dieses Puffers, die nacheinander gestapelt sind. </p><br><p>  Nehmen Sie zum Beispiel den <code>Span</code> Job f√ºr Strings: </p><br><p>  <strong>Datei <a href="">coreclr :: src / System.Private.CoreLib / shared / System / MemoryExtensions.Fast.cs</a></strong> </p><br><pre> <code class="plaintext hljs">public static ReadOnlySpan&lt;char&gt; AsSpan(this string text) { if (text == null) return default; return new ReadOnlySpan&lt;char&gt;(ref text.GetRawStringData(), text.Length); }</code> </pre> <br><p>  Wobei <code>string.GetRawStringData()</code> wie folgt lautet: </p><br><p>  <strong>Felddefinitionsdatei <a href="">coreclr :: src / System.Private.CoreLib / src / System / String.CoreCLR.cs</a></strong> </p><br><p>  <strong>GetRawStringData-Definitionsdatei <a href="">coreclr :: src / System.Private.CoreLib / shared / System / String.cs</a></strong> </p><br><pre> <code class="plaintext hljs">public sealed partial class String : IComparable, IEnumerable, IConvertible, IEnumerable&lt;char&gt;, IComparable&lt;string&gt;, IEquatable&lt;string&gt;, ICloneable { // // These fields map directly onto the fields in an EE StringObject. See object.h for the layout. // [NonSerialized] private int _stringLength; // For empty strings, this will be '\0' since // strings are both null-terminated and length prefixed [NonSerialized] private char _firstChar; internal ref char GetRawStringData() =&gt; ref _firstChar; }</code> </pre> <br><p>  Das hei√üt,  Es stellt sich heraus, dass die Methode direkt innerhalb der Linie verl√§uft und die <code>ref char</code> es Ihnen erm√∂glicht, die nicht verwaltete GC-Verbindung innerhalb der Linie zu verfolgen und sie w√§hrend des GC-Vorgangs zusammen mit der Linie zu verschieben. </p><br><p>  Die gleiche Geschichte passiert mit Arrays: Wenn <code>Span</code> erstellt wird, berechnet ein Code in der JIT den Versatz des Anfangs der Array-Daten und initialisiert den <code>Span</code> diesem Versatz.  Und wie man Offsets f√ºr Strings und Arrays berechnet, haben wir im Kapitel √ºber die Struktur von Objekten im Speicher gelernt. </p><br><h3 id="spant-kak-vozvraschaemoe-znachenie">  Spanne [T] als R√ºckgabewert </h3><br><p>    ,   <code>Span</code> ,    ,        .     : </p><br><pre> <code class="plaintext hljs">unsafe void Main() { var x = GetSpan(); } public Span&lt;byte&gt; GetSpan() { Span&lt;byte&gt; reff = new byte[100]; return reff; }</code> </pre> <br><p>       . ,     : </p><br><pre> <code class="plaintext hljs">unsafe void Main() { var x = GetSpan(); } public Span&lt;byte&gt; GetSpan() { Span&lt;byte&gt; reff = stackalloc byte[100]; return reff; }</code> </pre> <br><p>      .    , ,     ,       . </p><br><p> ,  ,   ,    ,      .  ,          .         ,   ,     ,       x[0.99]    . </p><br><p> ,  ,        ,     ,  : <code>CS8352 Cannot use local 'reff' in this context because it may expose referenced variables outside of their declaration scope</code>   :     ,   , ,                  . </p><br><h2 id="esli-poyavilis-voprosy">    </h2><br><p>   <code>Span&lt;T&gt;</code>  ,  .         ,    use cases    . </p><br><blockquote><h3>  Link zum ganzen Buch </h3><br><ul><li><img src="https://habrastorage.org/webt/3q/6g/qa/3q6gqaz40qx-jzscjf3jbxatxhg.png">  CLR-Buch: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub</a> </li><li><img src="https://habrastorage.org/webt/eo/6g/eo/eo6geog0tg5ernqmv2lcmufefta.png">  Release 0.5.0 B√ºcher, PDF: <a href="">GitHub Release</a> </li></ul><br></blockquote><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/getpro/habr/post_images/97f/1d3/cf0/97f1d3cf0e2a6bf007066eb60a789c31.png"></a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de418911/">https://habr.com/ru/post/de418911/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de418899/index.html">Erste Eindr√ºcke und Aktionen nach dem Upgrade von MySQL von Version 5.7 auf 8.0.11</a></li>
<li><a href="../de418901/index.html">Die Russen gewannen die Mehrheit der Goldmedaillen bei der Europ√§ischen Informatikolympiade eJOI 2018</a></li>
<li><a href="../de418903/index.html">Wissenschaftler: Es gibt nicht genug CO‚ÇÇ auf dem Mars, um die Atmosph√§re zu erw√§rmen. Polexplosion wird nicht helfen</a></li>
<li><a href="../de418907/index.html">So bringen Sie Zabbix bei, Problembenachrichtigungen direkt an den Desktop zu senden</a></li>
<li><a href="../de418909/index.html">Python f√ºhrt: Wer und warum verwendet es</a></li>
<li><a href="../de418913/index.html">UE4 | Inventar f√ºr Multiplayer # 1 | Data Warehouse auf DataAsset</a></li>
<li><a href="../de418915/index.html">Ausgleich des Datenverkehrs zwischen Webservern mithilfe von IP CEF auf Netzwerkger√§ten</a></li>
<li><a href="../de418917/index.html">Sicherheit beginnt mit einem Heimrouter</a></li>
<li><a href="../de418919/index.html">√úber das berufliche Wachstum des Designers und die Arbeit mit Stress. Und wie man in den schwierigsten Zeiten Kraft findet</a></li>
<li><a href="../de418921/index.html">4 Bibliotheken erleichtern einem React-Entwickler das Leben</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>