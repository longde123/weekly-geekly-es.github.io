<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü•â üë©üèæ ü§±üèº Comment nous avons chass√© pendant deux semaines le bogue NFS dans le noyau Linux üåØ üê§ ‚òùüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Une description d√©taill√©e des recherches de bogues de la t√¢che GitLab qui ont conduit au correctif pour le noyau Linux 


 Le 14 septembre, le support...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment nous avons chass√© pendant deux semaines le bogue NFS dans le noyau Linux</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/432922/"><h3 id="podrobnoe-opisanie-poiskov-baga-iz-zadachi-gitlab-kotorye-priveli-k-patchu-dlya-yadra-linux">  Une description d√©taill√©e des recherches de bogues de la t√¢che GitLab qui ont conduit au correctif pour le noyau Linux </h3><br><p> Le 14 septembre, le support GitLab a signal√© un probl√®me critique survenu √† l'un de nos clients: tout d'abord, GitLab fonctionne correctement, puis les utilisateurs obtiennent une erreur.  Ils ont essay√© de cloner certains r√©f√©rentiels via Git, et tout √† coup un message incompr√©hensible est apparu √† propos d'un fichier obsol√®te: <code>Stale file error</code> p√©rim√©.  L'erreur a persist√© pendant longtemps et n'a pas fonctionn√© jusqu'√† ce que l'administrateur syst√®me d√©marre manuellement <code>ls</code> dans le r√©pertoire lui-m√™me. </p><br><p>  J'ai d√ª √©tudier les m√©canismes internes de Git et le syst√®me de fichiers r√©seau NFS.  En cons√©quence, nous avons trouv√© un bogue dans le client NFS Linux v4.0, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Trond Myklebust a √©crit un correctif pour le noyau</a> , et depuis le 26 octobre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ce correctif est inclus dans le noyau Linux principal</a> . </p><br><p>  Dans cet article, je vais vous expliquer comment nous avons √©tudi√© le probl√®me, dans quelle direction nous avons pens√© et quels outils nous avons utilis√©s pour suivre le bug.  Nous avons √©t√© inspir√©s par l'excellent travail de d√©tective d'Oleg Dashevsky d√©crit dans le post <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">¬´Comment j'ai chass√© une fuite de m√©moire en Ruby pendant deux semaines¬ª</a> . </p><br><img src="https://habrastorage.org/webt/es/0f/-7/es0f-7dbqlnheksnnmxtlwawlic.jpeg"><a name="habracut"></a><br><p>  C'est √©galement un excellent exemple de la fa√ßon dont le d√©bogage open source est un sport d'√©quipe impliquant de nombreuses personnes, entreprises et pays.  La devise de GitLab, ¬´ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tout le monde peut contribuer</a> ¬ª, est vraie non seulement pour GitLab lui-m√™me, mais aussi pour d'autres projets open source, tels que le noyau Linux. </p><br><h3 id="vosproizvedenie-baga">  Reproduction d'insectes </h3><br><p>  Nous avons conserv√© NFS sur GitLab.com pendant de nombreuses ann√©es, mais avons ensuite cess√© de l'utiliser pour acc√©der aux donn√©es du r√©f√©rentiel sur les machines avec des applications.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Nous avons transf√©r√© tous les appels Git vers Gitaly</a> .  Nous prenons en charge NFS pour les clients qui g√®rent leurs installations sur GitLab mais n'ont jamais rencontr√© le m√™me probl√®me que le client susmentionn√©. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Le client a donn√© quelques conseils utiles</a> : </p><br><ol><li>  Texte d'erreur complet: <code>fatal: Couldn't read ./packed-refs: Stale file handle</code> . </li><li>  Apparemment, le probl√®me est survenu lorsque le client a d√©marr√© manuellement la r√©cup√©ration de place dans Git avec la commande <code>git gc</code> . </li><li>  L'erreur a disparu lorsque l'administrateur syst√®me a d√©marr√© l'utilitaire <code>ls</code> dans le r√©pertoire. </li><li>  L'erreur a disparu √† la fin du processus <code>git gc</code> . </li></ol><br><p>  Il est clair que les deux premiers points sont li√©s.  Lorsque vous soumettez des modifications √† la branche Git, Git cr√©e un lien faible - un nom de fichier long qui indique le nom de la branche pour la validation.  Par exemple, lors de l'envoi au <code>master</code> , un fichier appel√© <code>refs/heads/master</code> sera cr√©√© dans le r√©f√©rentiel: </p><br><pre> <code class="plaintext hljs">$ cat refs/heads/master 2e33a554576d06d9e71bfd6814ee9ba3a7838963</code> </pre> <br><p>  La commande <code>git gc</code> effectue plusieurs t√¢ches.  Par exemple, il collecte ces liens faibles (refs) et les regroupe dans un seul fichier appel√© <code>packed-refs</code> .  Cela acc√©l√®re un peu le travail, car la lecture d'un gros fichier est plus facile que de nombreux petits.  Par exemple, apr√®s avoir ex√©cut√© la commande <code>git gc</code> , le fichier <code>packed-refs</code> pourrait ressembler √† ceci: </p><br><pre> <code class="plaintext hljs"># pack-refs with: peeled fully-peeled sorted 564c3424d6f9175cf5f2d522e10d20d781511bf1 refs/heads/10-8-stable edb037cbc85225261e8ede5455be4aad771ba3bb refs/heads/11-0-stable 94b9323033693af247128c8648023fe5b53e80f9 refs/heads/11-1-stable 2e33a554576d06d9e71bfd6814ee9ba3a7838963 refs/heads/master</code> </pre> <br><p>  Comment le fichier <code>packed-refs</code> cr√©√©?  Pour le savoir, nous avons ex√©cut√© la commande <code>strace git gc</code> o√π nous avions un maillon faible.  Voici les lignes pertinentes: </p><br><pre> <code class="plaintext hljs">28705 open("/tmp/libgit2/.git/packed-refs.lock", O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC, 0666) = 3 28705 open(".git/packed-refs", O_RDONLY) = 3 28705 open("/tmp/libgit2/.git/packed-refs.new", O_RDWR|O_CREAT|O_EXCL|O_CLOEXEC, 0666) = 4 28705 rename("/tmp/libgit2/.git/packed-refs.new", "/tmp/libgit2/.git/packed-refs") = 0 28705 unlink("/tmp/libgit2/.git/packed-refs.lock") = 0</code> </pre> <br><p>  Les appels syst√®me ont montr√© que la commande <code>git gc</code> : </p><br><ol><li>  Ouvert <code>packed-refs.lock</code> .  Cela indique aux autres processus que le fichier <code>packed-refs</code> est verrouill√© et ne peut pas changer. </li><li>  Ouvert <code>packed-refs.new</code> . </li><li>  J'ai <code>packed-refs.new</code> maillons faibles dans <code>packed-refs.new</code> . </li><li>  Renomm√© <code>packed-refs.new</code> en <code>packed-refs</code> . </li><li>  Suppression de <code>packed-refs.lock</code> . </li><li>  Suppression des maillons faibles. </li></ol><br><p>  Le point cl√© ici est le quatri√®me, c'est-√†-dire le changement de nom, o√π Git introduit le fichier <code>packed-refs</code> .  <code>git gc</code> collecte non seulement les liens faibles, mais effectue √©galement une t√¢che beaucoup plus gourmande en ressources - il recherche et supprime les objets inutilis√©s.  Dans les grands r√©f√©rentiels, cela peut durer plus d'une heure. </p><br><p>  Et nous nous sommes demand√©: dans les grands r√©f√©rentiels, <code>git gc</code> garde-t-il le fichier ouvert pendant le nettoyage?  Nous avons √©tudi√© les journaux <code>strace</code> , lanc√© l'utilitaire <code>lsof</code> , et voici ce que nous avons appris sur le processus <code>git gc</code> : </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/493/51d/077/49351d077382c8b70317346789331c81.svg" alt="image"></p><br><p>  Comme vous pouvez le voir, le fichier <code>packed-refs</code> ferme √† la toute fin, apr√®s le processus potentiellement long des <code>Garbage collect objects</code> de <code>Garbage collect objects</code> . </p><br><p>  La question suivante s'est donc pos√©e: comment se comporte NFS lorsque le fichier <code>packed-refs</code> est ouvert sur un n≈ìud, et que l'autre le renomme √† ce moment-l√†? </p><br><p>  ¬´√Ä des fins scientifiques¬ª, nous avons demand√© au client de mener une exp√©rience sur deux machines diff√©rentes (Alice et Bob): <br>  1) Dans le volume partag√© NFS, cr√©ez deux fichiers: <code>test1.txt</code> et <code>test2.txt</code> avec des contenus diff√©rents, afin qu'ils soient plus faciles √† distinguer: </p><br><pre> <code class="plaintext hljs">alice $ echo "1 - Old file" &gt; /path/to/nfs/test1.txt alice $ echo "2 - New file" &gt; /path/to/nfs/test2.txt</code> </pre> <br><p>  2) Sur la machine d'Alice, le fichier <code>test1.txt</code> doit √™tre ouvert: </p><br><pre> <code class="plaintext hljs">alice $ irb irb(main):001:0&gt; File.open('/path/to/nfs/test1.txt')</code> </pre> <br><p>  3) Sur la machine d'Alice, affichez en continu le contenu de <code>test1.txt</code> : </p><br><pre> <code class="plaintext hljs">alice $ while true; do cat test1.txt; done</code> </pre> <br><p>  4) Ensuite, sur la machine de Bob, ex√©cutez la commande: </p><br><pre> <code class="plaintext hljs">bob $ mv -f test2.txt test1.txt</code> </pre> <br><p>  La derni√®re √©tape reproduit ce que <code>git gc</code> fait avec le fichier <code>packed-refs</code> lors du remplacement d'un fichier existant. <br>  Sur la machine du client, le r√©sultat ressemblait √† ceci: </p><br><pre> <code class="plaintext hljs">1 - Old file 1 - Old file 1 - Old file cat: test1.txt: Stale file handle</code> </pre> <br><p>  Voil√†!  Nous semblons avoir contr√¥l√© le probl√®me de mani√®re contr√¥l√©e.  Mais dans la m√™me exp√©rience sur un serveur Linux NFS, ce probl√®me ne s'est pas produit.  Le r√©sultat √©tait attendu - apr√®s avoir renomm√© le nouveau contenu a √©t√© accept√©: </p><br><pre> <code class="plaintext hljs">1 - Old file 1 - Old file 1 - Old file 2 - New file &lt;--- RENAME HAPPENED 2 - New file 2 - New file</code> </pre> <br><p>  D'o√π vient cette diff√©rence de comportement?  Il s'av√®re que le client a utilis√© le stockage <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Isilon NFS</a> , qui ne supportait que NFS v4.0.  Lorsque nous avons chang√© les param√®tres de connexion en v4.0 en utilisant le param√®tre <code>vers=4.0</code> dans <code>/etc/fstab</code> , le test a montr√© un r√©sultat diff√©rent pour le serveur NFS Linux: </p><br><pre> <code class="plaintext hljs">1 - Old file 1 - Old file 1 - Old file 1 - Old file &lt;--- RENAME HAPPENED 1 - Old file 1 - Old file</code> </pre> <br><p>  Au lieu du descripteur de <code>Stale file handle</code> obsol√®te <code>Stale file handle</code> p√©rim√© <code>Stale file handle</code> serveur Linux NFS v4.0 affiche un <em>contenu</em> obsol√®te.  Il s'av√®re que la diff√©rence de comportement peut √™tre expliqu√©e par les sp√©cifications NFS.  De <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RFC 3010</a> : </p><br><blockquote>  Le descripteur de fichier peut devenir obsol√®te ou expirer lorsqu'il est renomm√©, mais pas toujours.  Les impl√©menteurs de serveur sont invit√©s √† prendre des mesures pour garantir que les descripteurs de fichiers n'expirent pas et n'expirent pas de cette mani√®re. </blockquote><p>  En d'autres termes, les serveurs NFS peuvent choisir comment se comporter lorsqu'un fichier est renomm√©, et le serveur NFS renvoie assez raisonnablement une <code>Stale file error</code> dans de tels cas.  Nous avons sugg√©r√© que la cause du probl√®me est la m√™me, bien que les r√©sultats soient diff√©rents.  Nous pensions que c'√©tait une v√©rification du cache, car l'utilitaire <code>ls</code> dans le r√©pertoire a supprim√© l'erreur.  Nous avions maintenant un sc√©nario de test reproductible, et nous nous sommes tourn√©s vers des experts - les responsables Linux NFS. </p><br><h2 id="lozhnyy-sled-delegirovanie-na-nfs-servere">  False Trace: d√©l√©gation sur un serveur NFS </h2><br><p>  Lorsque nous avons r√©ussi √† reproduire l'erreur √©tape par √©tape, j'ai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©crit aux contacts Linux NFS √†</a> propos de ce que nous avions appris.  J'ai correspondu avec Bruce Fields, le mainteneur du serveur NFS Linux pendant une semaine, et il a sugg√©r√© que le bogue √©tait dans NFS et que j'avais besoin d'√©tudier le trafic r√©seau.  Il pensait que le probl√®me √©tait la d√©l√©gation de t√¢ches sur le serveur NFS. </p><br><h3 id="chto-takoe-delegirovanie-na-nfs-servere">  Qu'est-ce que la d√©l√©gation sur un serveur NFS? </h3><br><p>  En un mot, la version NFS v4 a une fonction de d√©l√©gation pour acc√©l√©rer l'acc√®s aux fichiers.  Le serveur peut d√©l√©guer l'acc√®s en lecture ou en √©criture au client afin que le client n'ait pas √† demander constamment au serveur si le fichier a √©t√© modifi√© par un autre client.  Autrement dit, d√©l√©guer un dossier, c'est comme pr√™ter √† quelqu'un son cahier et dire: ¬´Vous √©crivez ici, et je le prendrai quand je serai pr√™t.¬ª  Et une personne n'a pas besoin de demander un carnet chaque fois que vous devez √©crire quelque chose - elle a une totale libert√© d'action jusqu'√† ce que le carnet soit retir√©.  Dans NFS, une demande de retour d'un bloc-notes est appel√©e r√©vocation de d√©l√©gation. </p><br><p>  Un bogue dans la r√©vocation de la d√©l√©gation NFS pourrait expliquer le probl√®me de <code>Stale file handle</code> .  Rappelez-vous comment <code>test1.txt</code> √©t√© ouvert dans l' <code>test1.txt</code> d'Alice, puis <code>test2.txt</code> remplac√©.  Le serveur n'a peut-√™tre pas pu r√©voquer la d√©l√©gation pour <code>test1.txt</code> , ce qui a conduit √† un √©tat non valide.  Pour tester cette th√©orie, nous avons enregistr√© le trafic NFC avec l'utilitaire <code>tcpdump</code> et l'avons visualis√© √† l'aide de Wireshark. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Wireshark</a> est un excellent outil open source pour analyser le trafic r√©seau, en particulier pour explorer NFS en action.  Nous avons enregistr√© la trace √† l'aide de la commande suivante sur un serveur NFS: </p><br><pre> <code class="plaintext hljs">tcpdump -s 0 -w /tmp/nfs.pcap port 2049</code> </pre> <br><p>  Cette commande enregistre tout le trafic NFS qui passe g√©n√©ralement par le port TCP 2049. Comme notre exp√©rience a r√©ussi avec NFS v4.1, mais pas avec NFS v4.0, nous avons pu comparer le comportement de NFS dans le cas de travail et de non fonctionnement.  Avec Wireshark, nous avons constat√© le comportement suivant: </p><br><h3 id="nfs-v40-ustarevshiy-fayl">  NFS v4.0 (fichier obsol√®te) </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/6a1/0bb/e23/6a10bbe2304b155431010aa4ca577fa7.svg" alt="image"></p><br><p>  Ce diagramme montre qu'√† l'√©tape 1, Alice ouvre <code>test1.txt</code> et re√ßoit un descripteur de fichier NFS avec l'identifiant <code>stateid</code> 0x3000.  Lorsque Bob essaie de renommer le fichier, le serveur NFS demande de r√©essayer en envoyant le message <code>NFS4ERR_DELAY</code> , et il rappelle la d√©l√©gation d'Alice via le message <code>CB_RECALL</code> (√©tape 3).  Alice renvoie la d√©l√©gation (DELEGRETURN √† l'√©tape 4) et Bob essaie d'envoyer √† nouveau le message <code>RENAME</code> (√©tape 5).  <code>RENAME</code> est ex√©cut√© dans les deux cas, mais Alice continue de lire le fichier avec le m√™me descripteur. </p><br><h3 id="nfs-v41-rabochiy-sluchay">  NFS v4.1 (cas de travail) </h3><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f3d/1a3/d49/f3d1a3d49e803d73a4dd7f830e9b238a.svg" alt="image"></p><br><p>  Ici, la diff√©rence est visible √† l'√©tape 6. Dans NFS v4.0 (avec un fichier obsol√®te), Alice essaie √† nouveau d'utiliser le m√™me <code>stateid</code> .  Dans NFS v4.1 (cas de travail), Alice effectue des op√©rations <code>LOOKUP</code> et <code>OPEN</code> suppl√©mentaires, de sorte que le serveur renvoie un √©tat diff√©rent.  Dans la v4.0, il n'envoie aucun message suppl√©mentaire.  Cela explique pourquoi Alice voit un contenu obsol√®te - elle utilise un ancien descripteur. </p><br><p>  Pourquoi Alice d√©cide-t-elle soudainement d'une <code>LOOKUP</code> suppl√©mentaire?  Apparemment, le rappel de la d√©l√©gation a r√©ussi, mais il semble qu'un probl√®me subsiste.  Par exemple, l'√©tape d'invalidit√© est ignor√©e.  Pour v√©rifier cela, nous avons exclu la d√©l√©gation NFS sur le serveur NFS lui-m√™me avec cette commande: </p><br><pre> <code class="plaintext hljs">echo 0 &gt; /proc/sys/fs/leases-enable</code> </pre> <br><p>  Nous avons r√©p√©t√© l'exp√©rience, mais le probl√®me n'a pas disparu.  Nous nous sommes assur√©s que le probl√®me n'√©tait pas dans le serveur ou la d√©l√©gation NFS, et avons d√©cid√© de regarder le client NFS dans le noyau. </p><br><h2 id="kopaem-glubzhe-linux-nfs-klient">  Creuser plus profond√©ment: client NFS Linux </h2><br><p>  La premi√®re question √† laquelle nous avons d√ª r√©pondre aux responsables NFS √©tait: </p><br><h3 id="eta-problema-sohranyaetsya-v-posledney-versii-yadra">  Ce probl√®me persiste-t-il dans la derni√®re version du noyau? </h3><br><p>  Le probl√®me s'est produit dans les noyaux CentOS 7.2 et Ubuntu 16.04 avec les versions 3.10.0-862.11.6 et 4.4.0-130, respectivement.  Mais les deux c≈ìurs √©taient √† la tra√Æne de la derni√®re version, qui √©tait √† l'√©poque 4.19-rc2. </p><br><p>  Nous avons d√©ploy√© la nouvelle machine virtuelle Ubuntu 16.04 sur Google Cloud Platform (GCP), clon√© le dernier noyau Linux et configur√© l'environnement de d√©veloppement du noyau.  Nous avons cr√©√© le fichier <code>.config</code> √† l'aide de <code>menuconfig</code> et v√©rifi√© que: </p><br><ol><li>  Le pilote NFS est compil√© en tant que module ( <code>CONFIG_NFSD=m</code> ). </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Les param√®tres</a> corrects du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">noyau GCP</a> sont correctement sp√©cifi√©s. </li></ol><br><p>  La g√©n√©tique suit l'√©volution en temps r√©el par la drosophile, et avec le premier √©l√©ment, nous avons pu rapidement apporter des corrections au client NFS sans red√©marrer le noyau.  Le deuxi√®me point garantit que le noyau d√©marrera apr√®s l'installation.  Heureusement, nous √©tions satisfaits des param√®tres du noyau par d√©faut. </p><br><p>  Nous nous sommes assur√©s que le probl√®me du fichier obsol√®te ne disparaissait pas dans la derni√®re version du noyau.  Nous nous sommes demand√©: </p><br><ol><li>  O√π se pose exactement le probl√®me? </li><li>  Pourquoi cela se produit-il dans NFS v4.0, mais pas dans v4.1? </li></ol><br><p>  Pour r√©pondre √† ces questions, nous avons explor√© le code source NFS.  Nous n'avions pas de d√©bogueur de noyau, nous avons donc envoy√© deux types d'appels au code source: </p><br><ol><li>  <code>pr_info()</code> (c'√©tait <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>   printk</code></a> ). </li><li>  <code>dump_stack()</code> : il montre la trace de la pile pour l'appel de fonction en cours. </li></ol><br><p>  Par exemple, la premi√®re chose que nous avons faite a √©t√© de nous connecter √† la fonction <code>nfs4_file_open()</code> dans <code>fs/nfs/nfs4file.c</code> : </p><br><pre> <code class="plaintext hljs">static int nfs4_file_open(struct inode *inode, struct file *filp) { ... pr_info("nfs4_file_open start\n"); dump_stack();</code> </pre> <br><p>  Bien s√ªr, nous pouvions <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>  dprintk</code> avec le d√©bogage dynamique Linux</a> ou utiliser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><code>rpcdebug</code></a> , mais nous voulions ajouter nos propres messages pour v√©rifier les changements. </p><br><p>  Apr√®s chaque modification, nous avons recompil√© le module et l'avons r√©install√© dans le noyau en utilisant les commandes: </p><br><pre> <code class="plaintext hljs">make modules sudo umount /mnt/nfs-test sudo rmmod nfsv4 sudo rmmod nfs sudo insmod fs/nfs/nfs.ko sudo mount -a</code> </pre> <br><p>  Avec le module NFS, nous avons pu r√©p√©ter les exp√©riences et recevoir des messages pour comprendre le code NFS.  Par exemple, vous pouvez imm√©diatement voir ce qui se passe lorsque l'application appelle <code>open()</code> : </p><br><pre> <code class="plaintext hljs">Sep 24 20:20:38 test-kernel kernel: [ 1145.233460] Call Trace: Sep 24 20:20:38 test-kernel kernel: [ 1145.233462] dump_stack+0x8e/0xd5 Sep 24 20:20:38 test-kernel kernel: [ 1145.233480] nfs4_file_open+0x56/0x2a0 [nfsv4] Sep 24 20:20:38 test-kernel kernel: [ 1145.233488] ? nfs42_clone_file_range+0x1c0/0x1c0 [nfsv4] Sep 24 20:20:38 test-kernel kernel: [ 1145.233490] do_dentry_open+0x1f6/0x360 Sep 24 20:20:38 test-kernel kernel: [ 1145.233492] vfs_open+0x2f/0x40 Sep 24 20:20:38 test-kernel kernel: [ 1145.233493] path_openat+0x2e8/0x1690 Sep 24 20:20:38 test-kernel kernel: [ 1145.233496] ? mem_cgroup_try_charge+0x8b/0x190 Sep 24 20:20:38 test-kernel kernel: [ 1145.233497] do_filp_open+0x9b/0x110 Sep 24 20:20:38 test-kernel kernel: [ 1145.233499] ? __check_object_size+0xb8/0x1b0 Sep 24 20:20:38 test-kernel kernel: [ 1145.233501] ? __alloc_fd+0x46/0x170 Sep 24 20:20:38 test-kernel kernel: [ 1145.233503] do_sys_open+0x1ba/0x250 Sep 24 20:20:38 test-kernel kernel: [ 1145.233505] ? do_sys_open+0x1ba/0x250 Sep 24 20:20:38 test-kernel kernel: [ 1145.233507] __x64_sys_openat+0x20/0x30 Sep 24 20:20:38 test-kernel kernel: [ 1145.233508] do_syscall_64+0x65/0x130</code> </pre> <br><p>  Que sont ces <code>do_dentry_open</code> et <code>vfs_open</code> ?  Linux poss√®de un syst√®me de fichiers virtuel ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">VFS</a> ), une couche d'abstraction qui fournit une interface commune √† tous les syst√®mes de fichiers.  La documentation VFS indique: </p><br><blockquote>  VFS impl√©mente open (2), stat (2), chmod (2) et d'autres appels syst√®me.  Le syst√®me VFS utilise l'argument de nom de chemin qui leur est transmis pour rechercher dans le cache des entr√©es de r√©pertoire (cache dentry ou dcache).  Cela fournit un moteur de recherche tr√®s rapide qui convertit le nom du chemin (ou le nom du fichier) en dentisterie sp√©cifique.  Dentry r√©side dans la RAM et n'est jamais enregistr√© sur le disque - ils n'existent que pour les performances. </blockquote><br><h3 id="i-nas-osenilo--a-chto-esli-problema-v-dentry-keshe">  Et cela nous est apparu - que se passe-t-il si le probl√®me est dans la cache de la dentisterie? </h3><br><p>  Nous avons remarqu√© que le cache dentry est g√©n√©ralement v√©rifi√© dans <code>fs/nfs/dir.c</code>  Nous √©tions particuli√®rement int√©ress√©s par la fonction <code>nfs4_lookup_revalidate()</code> , et √† titre exp√©rimental, nous l'avons fait fonctionner plus t√¥t: </p><br><pre> <code class="plaintext hljs">diff --git a/fs/nfs/dir.cb/fs/nfs/dir.c index 8bfaa658b2c1..ad479bfeb669 100644 --- a/fs/nfs/dir.c +++ b/fs/nfs/dir.c @@ -1159,6 +1159,7 @@ static int nfs_lookup_revalidate(struct dentry *dentry, unsigned int flags) trace_nfs_lookup_revalidate_enter(dir, dentry, flags); error = NFS_PROTO(dir)-&gt;lookup(dir, &amp;dentry-&gt;d_name, fhandle, fattr, label); trace_nfs_lookup_revalidate_exit(dir, dentry, flags, error); + goto out_bad; if (error == -ESTALE || error == -ENOENT) goto out_bad; if (error)</code> </pre> <br><p>  Et dans cette exp√©rience, un probl√®me de fichier obsol√®te ne s'est pas produit!  Enfin, nous avons attaqu√© la piste. </p><br><p>  Pour d√©couvrir pourquoi le probl√®me ne s'est pas produit dans NFS v4.1, nous avons ajout√© des <code>pr_info()</code> √† chaque bloc <code>if</code> dans cette fonction.  Nous avons exp√©riment√© avec NFS v4.0 et v4.1 et trouv√© une condition sp√©ciale dans la version v4.1: </p><br><pre> <code class="plaintext hljs">if (NFS_SB(dentry-&gt;d_sb)-&gt;caps &amp; NFS_CAP_ATOMIC_OPEN_V1) { goto no_open; }</code> </pre> <br><p>  Qu'est-ce que <code>NFS_CAP_ATOMIC_OPEN_V1</code> ?  Ce <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">correctif du noyau</a> indique qu'il s'agit d'une fonctionnalit√© de NFS v4.1, et le code dans <code>fs/nfs/nfs4proc.c</code> confirm√© que ce param√®tre est dans v4.1 mais pas dans v4.0: </p><br><pre> <code class="plaintext hljs">static const struct nfs4_minor_version_ops nfs_v4_1_minor_ops = { .minor_version = 1, .init_caps = NFS_CAP_READDIRPLUS | NFS_CAP_ATOMIC_OPEN | NFS_CAP_POSIX_LOCK | NFS_CAP_STATEID_NFSV41 | NFS_CAP_ATOMIC_OPEN_V1</code> </pre> <br><p>  Par cons√©quent, les versions se sont comport√©es diff√©remment - dans la version 4.1, <code>goto no_open</code> appelle plus de v√©rifications dans la fonction <code>nfs_lookup_revalidate()</code> , et dans la version <code>nfs4_lookup_revalidate()</code> fonction <code>nfs4_lookup_revalidate()</code> renvoie plus t√¥t.  Et comment avons-nous r√©solu le probl√®me? </p><br><h2 id="reshenie">  Solution </h2><br><p>  J'ai parl√© de nos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">r√©sultats sur la liste de diffusion NFS</a> et sugg√©r√© un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">correctif primitif</a> .  Une semaine plus tard, Trond Myklebust a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">envoy√© une s√©rie de correctifs avec des corrections de bogues √† la liste de diffusion et a trouv√© un autre probl√®me connexe dans NFS v4.1</a> . </p><br><p>  Il s'av√®re que la correction du bogue NFS v4.0 √©tait plus profonde dans la base de code que nous ne le pensions.  Trond l'a bien d√©crit dans le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">patch</a> : </p><br><blockquote>  Il est n√©cessaire de s'assurer que l'inode et la dentisterie sont correctement rev√©rifi√©s lorsqu'un fichier d√©j√† ouvert est ouvert.  Pour le moment, nous ne v√©rifions pas non plus NFSv4.0, car le fichier ouvert est mis en cache.  Corrigeons cela et mettons en cache les fichiers ouverts uniquement dans des cas sp√©ciaux - pour restaurer les fichiers ouverts et renvoyer la d√©l√©gation. </blockquote><p>  Nous nous sommes assur√©s que ce correctif r√©solvait le probl√®me de fichier obsol√®te et envoyions des rapports de bogues aux √©quipes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ubuntu</a> et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">RedHat</a> . </p><br><p>  Nous avons bien compris que les changements ne seraient pas encore dans la version stable du noyau, nous avons donc ajout√© une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">solution temporaire √† ce probl√®me dans Gitaly</a> .  Nous avons exp√©riment√© et v√©rifi√© que l'appel de <code>stat()</code> dans le fichier <code>packed-refs</code> oblige le noyau √† rev√©rifier le fichier renomm√© dans le cache dentry.  Pour plus de simplicit√©, nous l'avons impl√©ment√© dans Gitaly pour tout syst√®me de fichiers, pas seulement NFS.  La validation n'est effectu√©e qu'une seule fois avant que Gitaly n'ouvre le r√©f√©rentiel, et pour d'autres fichiers, il existe d√©j√† d'autres appels <code>stat()</code> . </p><br><h2 id="chemu-my-nauchilis">  Qu'avons-nous appris </h2><br><p>  Un bogue peut se cacher dans n'importe quel coin de la pile logicielle, et parfois vous devez le rechercher en dehors de l'application.  Si vous avez des connexions utiles dans le monde open source, cela facilitera votre travail. </p><br><p>  Un grand merci √† Trond Myuklebust pour avoir r√©solu le probl√®me et √† Bruce Fields pour avoir r√©pondu √† nos questions et aid√© √† comprendre NFS.  C'est pour une telle r√©activit√© et professionnalisme que nous appr√©cions la communaut√© des d√©veloppeurs open source. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr432922/">https://habr.com/ru/post/fr432922/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr432910/index.html">Il est dangereux de consid√©rer la r√©alit√© virtuelle comme une machine d'empathie</a></li>
<li><a href="../fr432912/index.html">Comment obtenir un stage chez Google</a></li>
<li><a href="../fr432914/index.html">Un bot de chat tr√®s simple pour Telegram pour les plus petits</a></li>
<li><a href="../fr432918/index.html">D√©sol√©, j'ai cass√© votre recovery.conf</a></li>
<li><a href="../fr432920/index.html">Le facteur humain dans l'entreprise: est-ce dangereux?</a></li>
<li><a href="../fr432924/index.html">Run, Gecko, run: un m√©canisme de mouvement de l'eau hybride gecko</a></li>
<li><a href="../fr432926/index.html">24 recettes sur la fa√ßon dont une startup peut r√©ussir dans une grande exposition mondiale, en utilisant le Web Summit 2018 comme exemple</a></li>
<li><a href="../fr432928/index.html">Ce qui se passe chez Intel et pourquoi Amazon ne transf√®rera pas enti√®rement AWS sur ses puces malgr√© les gros titres</a></li>
<li><a href="../fr432930/index.html">Exploit mercredi d√©cembre 2018: pour tester les nouvelles plages de temps, ils ont roul√© ...</a></li>
<li><a href="../fr432932/index.html">√âcosyst√®me du monde de l'approvisionnement num√©rique (pour voler moins)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>