<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôç üï∏Ô∏è üè¨ Como encontrar um bug em um microprocessador lan√ßado h√° 35 anos üñï ‚ôëÔ∏è üß†</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="√â dif√≠cil de acreditar, mas √†s vezes os erros nos processadores vivem essencialmente mais do que os pr√≥prios processadores. Recentemente, fiquei conve...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como encontrar um bug em um microprocessador lan√ßado h√° 35 anos</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471020/"><p><img src="https://habrastorage.org/webt/zj/dz/om/zjdzomhyfadpxobr7ok9wppvvve.jpeg" alt="K1801VM1A"></p><br><p>  √â dif√≠cil de acreditar, mas √†s vezes os erros nos processadores vivem essencialmente mais do que os pr√≥prios processadores.  Recentemente, fiquei convencido disso pelo exemplo do microprocessador de 16 bits <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">1801BM1A</a> , com base no qual a fam√≠lia de computadores dom√©sticos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">BK-0010 / 11M</a> foi criada na URSS ao mesmo tempo.  Sobre esta fam√≠lia em Habr√© escreveu repetidamente. </p><a name="habracut"></a><br><p> O per√≠odo da vida ativa de BeKashek cai no final dos anos 80 - in√≠cio dos anos 90 do s√©culo passado.  Nestes anos, atrav√©s dos esfor√ßos de v√°rios entusiastas individuais, bem como de grupos de membros e cooperadores do c√≠rculo, foi desenvolvida a principal matriz de programas aplicativos BC: jogos, utilit√°rios, v√°rios "DOSs" (sistemas operacionais de disco).  Paralelamente ao desenvolvimento do software, foram criados perif√©ricos sob os quais o software do sistema foi gravado.  Em geral, o ecossistema desses computadores de 16 bits do tipo PDP foi desenvolvido de acordo com princ√≠pios semelhantes, como, por exemplo, as arquiteturas abertas de 8 bits anteriores baseadas nos barramentos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Intel 8080</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">S-100</a> desenvolvidos.  Mais tarde, √† medida que nos afastamos do papel utilit√°rio do CD, o foco na programa√ß√£o mudou para o demosceno. </p><br><p>  O volume de software para BC pode ser estimado visitando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sites</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">p√∫blicos</a> com <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">cole√ß√µes de</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">programas</a> .  Obviamente, em compara√ß√£o, por exemplo, com o ZX-Spectrum, esse volume √© muito mais modesto.  No entanto, mesmo esse volume, ao que parece, deveria ter sido suficiente para contornar todos os cantos e recantos conceb√≠veis do c√≥digo de m√°quina.  √â poss√≠vel encontrar algo incomum no comportamento do processador, ap√≥s mais de trinta anos de pr√°tica em us√°-lo?  Como se viu - sim!  Isso ser√° discutido abaixo. </p><br><p>  Talvez fa√ßa sentido contar essa hist√≥ria em ordem cronol√≥gica.  Antes de tudo, devo observar imediatamente que n√£o sou um ‚Äúprogramador com experi√™ncia‚Äù, nem por ocupa√ß√£o, nem por pertencer a um grupo de entusiastas do BC, sobre quem escrevi acima.  Eu vim para o BC de uma maneira indireta, em parte pela nostalgia dos hobbies da inf√¢ncia e da juventude (eletr√¥nica anal√≥gica e digital, a revista <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Young Technician</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">UT-88</a> e outros artesanatos e imperfei√ß√µes), e em parte pelo meu interesse no sistema de arquitetura e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">comando PDP-11</a> .  N√£o tenho o BK "no hardware" e normalmente executo programas para o BK e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">depuro-o</a> no emulador do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">bkemu</a> em um tablet para Android. </p><br><p>  H√° algum tempo, fiquei interessado no programa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Kaleidoscope, de</a> autoria de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Li-Chen Wang-a</a> .  O programa foi escrito em c√≥digo de m√°quina em 1976, para um microprocessador Intel 8080 como parte de um computador <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Altair 8800</a> com um adaptador gr√°fico <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cromemco Dazzler</a> .  Eu queria analisar o algoritmo Li-Chen Wang-a em detalhes e, ao mesmo tempo, port√°-lo para o BC.  Deve-se dizer que o desejo de portar o caleidosc√≥pio para BC foi expresso entre os demosceners anteriormente, e houve at√© tentativas de analisar o algoritmo, mas n√£o tiveram √™xito. </p><br><p>  No pr√≥ximo artigo, provavelmente analisarei esse algoritmo em detalhes (e para os impacientes, postarei um link para as fontes do caleidosc√≥pio de plataforma cruzada sob libSDL em C).  Para o futuro, ser√° suficiente indicar que o problema foi resolvido e o Caleidosc√≥pio foi transportado com sucesso para o BC.  Al√©m disso, a gera√ß√£o de som foi adicionada ao algoritmo no CD e, como a imagem e o som s√£o gerados pelo mesmo c√≥digo, podemos dizer que a imagem em si soa (toda a demonstra√ß√£o se encaixa em menos de 256 bytes de c√≥digo de m√°quina e, Espero que seja apresentado ao p√∫blico na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CAFe Demoparty 2019</a> em Kazan no final de outubro). </p><br><p>  Depois de terminar de escrever e depurar meu programa no emulador, virei-me para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Damir ("Adamych") Nasyrov</a> (ele √© um dos organizadores do CAFe Demoparty e uma pessoa muito conhecida entre os demosceners) com uma solicita√ß√£o para verificar a execu√ß√£o do programa em um BC real.  Eu estava especialmente interessado em reprodu√ß√£o de som, pois os tempos no emulador podiam diferir dos tempos no hardware real.  Imagine minha decep√ß√£o quando Damir me informou que existe uma imagem em um BC real, mas n√£o h√° som! </p><br><p>  As noites seguintes foram gastas tentando subtrair a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documenta√ß√£o</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sistema</a> no BK-0011M e o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">diagrama de circuitos</a> , onde poderia haver um erro no som.  O som no BC √© organizado de maneira simples: o sexto bit no registro de E / S com o endere√ßo octal 177716 (registro de controle do gravador) √© emitido atrav√©s de um buffer para um alto-falante piezoel√©trico (bip).  Al√©m da 6¬™ categoria, os bits 2 e 5 do mesmo registro s√£o conectados ao conversor digital-anal√≥gico mais simples com 4 resistores.  A partir da sa√≠da deste conversor, o som pode ir para o gravador.  Tudo √© excepcionalmente claro e l√≥gico, mas n√£o havia som teimoso em um BK real, independentemente das combina√ß√µes de m√°scaras de bits que tentei aplicar √† sa√≠da de dados desse registro.  Paralelamente, todos os emuladores BK que eu conhecia foram instalados e testados - e o som funcionou em todos! </p><br><p>  Em algum momento, eu quase consegui convencer Damir de que seu BK estava com defeito, mas o comportamento foi repetido em outro BK-0011M ao vivo e tamb√©m no BK-0010.  Fiquei sem id√©ias e os habitantes do canal de telegrama sobre o tema BC tamb√©m n√£o sabiam dizer nada ... No entanto, o incidente ajudou, como sempre.  No decorrer de um dos experimentos, Damir lan√ßou uma demo no emulador para garantir que haja som no emulador.  E aqui ele conseguiu notar que n√£o apenas h√° som no emulador, mas n√£o no BC, mas tamb√©m as imagens no emulador e no BC ao vivo s√£o diferentes!  Aqui, devo lembrar que no meu programa a imagem e o som s√£o gerados pelo mesmo c√≥digo.  Assim, durante todo esse tempo, procurei um motivo no lugar errado: o motivo estava no c√≥digo que gerava os dados para o conte√∫do da tela. </p><br><p>  Damir me enviou uma captura de tela, e ficou claro que o algoritmo produz bytes com zero conte√∫do dos 4 bits mais altos e, por coincid√™ncia, esses bits foram emitidos para o som (ou seja, sempre zeros).  No entanto, a raz√£o pela qual o algoritmo se comportou dessa maneira permaneceu vaga.  Este √© o local no c√≥digo ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">macro</a> do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">assembler11</a> do PDP-11, registra r0-r5 renomeado!): </p><br><pre><code class="plaintext hljs">; renamed registers a = %0 b = %1 c = %2 d = %3 e = %4 h = %5 ... ... asr b ; sets CF bic #177760, b bis b, c bis (h)+, c ; screen address in c movb (c), a ; get a byte from screen RAM bcc 1$ ; check CF bic #177760, a ; keep bits 0-3, clear rest bisb d, a ; fill bits 4-7 br 2$ 1$: bic #177417, a ; keep bits 4-7, clear rest bisb e, a ; fill bits 0-3 2$: ... ...</code> </pre> <br><p>  Por alguma raz√£o, em um BC real, sempre foi executado um salto condicional na marca de US $ 1.  Ou seja, a instru√ß√£o bcc sempre percebeu o sinalizador de transporte como redefinido, embora a instru√ß√£o de mudan√ßa do ASR possa configur√°-lo como 0 ou 1. Como pode ser isso porque, de acordo com a documenta√ß√£o do processador, nem o BIC, nem o BIS, nem o MOVB deve afetar a bandeira de transporte ?! </p><br><p>  Al√©m disso, em todos os emuladores (que foram escritos de acordo com a documenta√ß√£o do processador!) √â assim: estas instru√ß√µes n√£o tocam no sinalizador C. Tornou-se claro que o processador real 1801BM1A n√£o funciona nesse caso, de acordo com a documenta√ß√£o.  Resta confirmar isso. </p><br><p>  Para iniciantes, uma solu√ß√£o r√°pida √≥bvia: </p><br><pre> <code class="plaintext hljs"> ... asr b ; sets CF mfps -(sp) ; store PSW on stack bic #177760, b bis b, c bis (h)+, c ; screen address in c movb (c), a ; get a byte from screen RAM mtps (sp)+ ; restore PSW from stack bcc 1$ ; check CF ...</code> </pre> <br><p>  Salvar as bandeiras na pilha imediatamente ap√≥s a instru√ß√£o shift e restaur√°-las antes do salto condicional resolveu imediatamente o problema, o que mostrou que eu estava no caminho certo.  Resta restringir o "c√≠rculo de suspeitos".  Para testar a hip√≥tese, um teste sint√©tico foi escrito primeiro (os registros n√£o foram renomeados aqui; a inicializa√ß√£o foi omitida para n√£o confundir o c√≥digo; o emt 64 √© um programa interrompido para imprimir uma linha): </p><br><pre> <code class="plaintext hljs"> ... mov #1, r1 jsr pc, test clr r1 jsr pc, test halt test: mov #40000, r2 ; r2 points to screen RAM mov #dummy, r5 ; r5 points to dummy = 200 ; *** begin *** asr r1 ; affects CF bic #177760, r1 bis r1, r2 bis (r5)+, r2 movb (r2), r0 ; *** end *** jsr pc, prt rts pc prt: mov #msg1, r0 bcs l1 mov #msg2, r0 l1: emt 64 rts pc msg1: .asciz /Flag CF set/ msg2: .asciz /Flag CF clear/ dummy: .word 200 ...</code> </pre> <br><p>  E o teste ... n√£o funcionou!  Programa impresso na tela </p><br><p>  Marca CF set <br>  Marca CF limpar </p><br><p>  O que aconteceu?  Descobriu-se que a suposi√ß√£o inicial de que o fragmento de c√≥digo entre o <strong><em>in√≠cio</em></strong> e o <strong><em>final</em></strong> estraga o sinalizador C est√° errada e precisa ser esclarecida.  Qual √© a diferen√ßa entre este teste e o c√≥digo fonte?  E o fato de outras instru√ß√µes aparecerem entre o bloco de comandos "suspeitos" e o salto condicional.  N√£o afeta o sinalizador C, mas altera o estado interno do processador.  Portanto, o seguinte teste foi assim: </p><br><pre> <code class="plaintext hljs"> ... mov #1, r1 jsr pc, test clr r1 jsr pc, test halt test: mov #40000, r2 mov #dummy, r5 ; *** begin *** asr r1 ; affects CF bic #177760, r1 bis r1, r2 bis (r5)+, r2 movb (r2), r0 bcc l1 ; *** end *** mov #msg1, r0 emt 64 rts pc l1: mov #msg2, r0 emt 64 rts pc msg1: .asciz /Flag CF set/ msg2: .asciz /Flag CF clear/ dummy: .word 200 ...</code> </pre> <br><p>  E agora esse teste j√° foi impresso em um BK-0011M real: </p><br><p>  Marca CF limpar <br>  Marca CF limpar </p><br><p>  No emulador, como antes, </p><br><p>  Marca CF set <br>  Marca CF limpar </p><br><p>  Al√©m disso, √© uma quest√£o de tecnologia.  Por meio de simplifica√ß√µes graduais, foi obtido um teste m√≠nimo no qual um bug √© reproduzido (cito toda a fonte): </p><br><pre> <code class="plaintext hljs"> .title test .psect code .=.+1000 mov #15, r0 emt 63 sec jsr pc, test clc jsr pc, test halt test: movb r0, r0 bcc l1 mov #msg1, r0 emt 64 rts pc l1: mov #msg2, r0 emt 64 rts pc msg1: .asciz /Flag CF set/ msg2: .asciz /Flag CF clear/ .end</code> </pre> <br><p>  Em um BK-0011M real, este teste exibe </p><br><p>  Marca CF limpar <br>  Marca CF limpar </p><br><p>  Ou seja, a instru√ß√£o MOVB que estava diretamente √† frente da instru√ß√£o de ramifica√ß√£o condicional era a culpada, e a apar√™ncia do primeiro operando n√£o √© importante.  Se, por exemplo, NOP for inserido entre MOVB e BCC, o comportamento retornar√° ao documentado e o programa imprimir√° </p><br><p>  Marca CF set <br>  Marca CF limpar </p><br><p>  Isso tornou poss√≠vel formular uma hip√≥tese refinada (cito-me em um canal de telegrama): </p><br><blockquote>  ... Em rela√ß√£o ao bug: o comportamento parece ter esclarecido.  Como eu imagino, MOVB src, dst (a prop√≥sito, parece que os operandos n√£o s√£o importantes), devido a alguns recursos arquiteturais, estraga temporariamente a bandeira C dentro do processador, mas n√£o fatalmente, porque a porcentagem parece salvar uma c√≥pia dessa bandeira.  Como resultado, se entre o MOVB e a ramifica√ß√£o condicional houver outros comandos (que n√£o afetam C), por exemplo, NOP, o comportamento ser√° o descrito na documenta√ß√£o. </blockquote><p>  O que aconteceu depois?  Al√©m disso, colegas do canal ajudaram a trazer Vyacheslav (@ K1801BM1, o homem lend√°rio que anteriormente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">reverteu</a> esse processador no n√≠vel do transistor) para a discuss√£o.  A rea√ß√£o de Vyacheslav (Yuot) quando ele testou o comportamento em uma posi√ß√£o com um 1801BM1A real (ortografia e pontua√ß√£o preservadas): </p><br><blockquote>  <u>Stanislav Maslovski:</u> <br>  s√£o necess√°rios pelo menos dois comandos para reprodu√ß√£o <br>  movb e salto condicional em C <br>  Bem, antes disso, defina o sinalizador C para um estado conhecido <br><br>  <u>Yuot:</u> <br>  A bandeira sempre com reset √© obtida <br><br>  <u>Stanislav Maslovski:</u> <br>  sim <br>  agora insira nop <br><br>  <u>Yuot:</u> <br>  Agora nunca <br><br>  <u>Yuot:</u> <br>  Alternando 0 1 <br>  Isso √© uma vergonha </blockquote><p>  Com a ajuda de Vyacheslav, os detalhes foram descobertos, a saber, que o motivo do bug √© que no processador, al√©m do PSW, h√° outro registro de 4 bits, que normalmente armazena uma c√≥pia dos sinalizadores do PSW.  Este registro est√° conectado ao firmware autom√°tico e as transi√ß√µes condicionais recebem os valores do sinalizador.  Ao executar as instru√ß√µes MVB, SWAB, MFPS com o registrador receptor, devido √†s peculiaridades do processamento da extens√£o do sinal e devido a um erro no microc√≥digo, uma c√≥pia do sinalizador C nesse registro √© descartada e as transi√ß√µes condicionais usando esse sinalizador n√£o funcionam corretamente.  No entanto, seguindo as instru√ß√µes abaixo, o valor tempor√°rio do registro √© restaurado a partir do PSW.  Por isso, a inser√ß√£o de NOP restaura o comportamento correto. </p><br><p>  Para concluir, tamb√©m gostaria de agradecer aos assinantes do canal de telegrama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">BK0010 / 11M World</a> por participarem da discuss√£o sobre esse bug e pelos coment√°rios feitos no texto do artigo.  A foto-t√≠tulo do artigo √© cortesia de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Manwe_SandS</a> .  Mais interessante, Manwe estava perto de descobrir o mesmo bug, quase ao mesmo tempo em que Damir e eu est√°vamos lutando para resolver o problema de som! </p><br><p>  Agora cabe aos pequenos (apenas brincando) - alinhar todos os emuladores com o comportamento real do processador.  Afinal, o pr√≥prio processador, infelizmente, n√£o pode mais ser corrigido. </p><br><p>  <em>Sobre isso eu vou terminar.</em>  <em>Espero que tenha sido interessante.</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt471020/">https://habr.com/ru/post/pt471020/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt471010/index.html">Algoritmo de Grover e pesquisa de dados</a></li>
<li><a href="../pt471012/index.html">Abordagem de engenharia para desenvolvimento de software. Da teoria √† pr√°tica</a></li>
<li><a href="../pt471014/index.html">Estamos fazendo um drone de √°gua aut√¥nomo, ou como eu sonhava em ajudar Baikal, mas n√£o sou uma Gazprom. Parte 1</a></li>
<li><a href="../pt471016/index.html">Design de banco de dados. Melhores pr√°ticas</a></li>
<li><a href="../pt471018/index.html">Compara√ß√£o do desempenho de PC e smartphone, incluindo o iPhone 11</a></li>
<li><a href="../pt471022/index.html">Revelando um segredo de 140 anos em f√≠sica</a></li>
<li><a href="../pt471024/index.html">An√°lise: o que s√£o futuros e como us√°-los para investimentos em c√¢mbio</a></li>
<li><a href="../pt471026/index.html">TypeScript Poder nunca</a></li>
<li><a href="../pt471028/index.html">Carrinho de caminh√£o ROS. Parte 6. Odometria com codificadores de roda, mapa da sala, lidar</a></li>
<li><a href="../pt471032/index.html">Foto invis√≠vel</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>