<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ ğŸ€ âš’ï¸ Apa yang perlu Anda tunggu tentang menciptakan strategi untuk perdagangan di bursa: seberapa efisien pembelajaran mesin â›¹ğŸ» ğŸ› ğŸ¤¾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Di blog kami di HabrÃ©, kami menerbitkan terjemahan bahan yang disesuaikan dari blog The Financial Hacker, yang ditujukan untuk pertanyaan tentang menc...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Apa yang perlu Anda tunggu tentang menciptakan strategi untuk perdagangan di bursa: seberapa efisien pembelajaran mesin</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/iticapital/blog/412639/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/pq/lc/zm/pqlczmojlxuisfxberyvpnismeu.png"></a> <br><br>  Di blog kami di HabrÃ©, kami menerbitkan terjemahan bahan yang disesuaikan dari blog The Financial Hacker, yang ditujukan untuk pertanyaan tentang menciptakan strategi untuk perdagangan di bursa.  Sebelumnya, kami membahas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">pencarian inefisiensi pasar</a> , pembuatan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">model strategi perdagangan</a> , dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">prinsip</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">prinsip pemrograman mereka</a> .  Hari ini kita <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">akan fokus</a> pada penggunaan pendekatan pembelajaran mesin untuk meningkatkan efisiensi sistem perdagangan. <br><br>  Komputer pertama yang memenangkan Kejuaraan Catur Dunia adalah Deep Blue.  Itu pada tahun 1996, dan dua puluh tahun berlalu sebelum program lain, Alpha Go, berhasil mengalahkan pemain terbaik di Go.  Deep Blue adalah sistem berorientasi model dengan aturan catur tertanam.  AplhaGo adalah sistem penambangan data, jaringan saraf yang dalam, dilatih menggunakan ribuan game di Go.  Yaitu, untuk mengambil langkah dari kemenangan atas orang-orang yang menjadi juara dalam catur, untuk mendominasi pemain top di Go, itu perlu bukan sepotong besi yang ditingkatkan, tetapi sebuah terobosan di bidang perangkat lunak. <br><br>  Dalam artikel saat ini, kami akan mempertimbangkan penerapan pendekatan penambangan data untuk menciptakan strategi perdagangan.  Metode ini tidak memperhitungkan mekanisme pasar, melainkan hanya memindai kurva harga dan sumber data lainnya untuk mencari pola prediksi.  Pembelajaran mesin atau "kecerdasan buatan" tidak selalu diperlukan untuk ini.  Sebaliknya, sangat sering, metode yang paling populer dan menguntungkan dari pekerjaan penambangan data tanpa embel-embel dalam bentuk jaringan saraf atau dukungan untuk metode vektor. <a name="habracut"></a><br><br><h2>  Prinsip Pembelajaran Mesin </h2><br>  Algoritma yang terlatih diumpankan dengan sampel data, biasanya entah bagaimana diekstraksi dari harga pertukaran historis.  Setiap sampel terdiri dari n variabel x1 ... xn, yang biasanya disebut prediktor, fungsi, sinyal atau, lebih sederhana, memasukkan data.  Prediktor ini dapat berupa harga n bar terakhir pada grafik harga atau sekumpulan nilai indikator klasik, atau fungsi lain dari kurva harga (bahkan ada kasus ketika piksel individual dari grafik harga digunakan sebagai prediktor untuk jaringan saraf!).  Setiap sampel juga biasanya berisi variabel target tertentu y, misalnya, hasil dari transaksi berikutnya setelah menganalisis sampel atau pergerakan harga berikutnya. <br><br>  Dalam literatur, y sering disebut sebagai label atau tujuan.  Dalam proses pembelajaran, algoritma belajar untuk memprediksi target y berdasarkan pada prediksi x1 ... xn.  Apa yang â€œdiingatâ€ oleh sistem dalam proses disimpan dalam struktur data yang disebut model yang spesifik untuk algoritma tertentu (penting untuk tidak membingungkan konsep ini dengan model keuangan atau strategi berorientasi model).  Model pembelajaran mesin dapat berfungsi dengan aturan prediksi yang ditulis menggunakan kode C yang dihasilkan oleh proses pembelajaran.  Atau itu bisa berupa seperangkat bobot terkait jaringan saraf: <br><br><blockquote>  Pelatihan: x1 ... xn, y =&gt; model <br><br>  Prediksi: x1 ... xn, model =&gt; y <br></blockquote><br>  Prediktor, fungsi, atau apa pun yang Anda ingin menyebutnya, harus berisi informasi yang cukup untuk menghasilkan prediksi tentang nilai target y dengan akurasi tertentu.  Mereka juga harus memenuhi dua kriteria formal.  Pertama, semua nilai prediktor harus dalam kisaran yang sama, misalnya, -1 ... +1 (untuk sebagian besar algoritma pada R) atau -100 ... +100 (untuk algoritma dalam bahasa skrip Zorro atau TSSB).  Jadi sebelum mengirim data ke sistem, Anda harus menormalkannya.  Kedua, sampel harus seimbang, yaitu terdistribusi secara merata atas nilai-nilai variabel target.  Artinya, Anda harus memiliki jumlah sampel yang sama yang mengarah ke hasil positif, dan kehilangan set.  Jika kedua persyaratan ini tidak diikuti, maka hasil yang baik tidak akan berhasil. <br><br>  Algoritma regresi menghasilkan prediksi tentang nilai numerik, seperti magnitude atau tanda pergerakan harga berikutnya.  Algoritma klasifikasi memprediksi kelas kuantitatif sampel, misalnya, apakah mereka mendahului laba atau rugi dana.  Beberapa algoritma, seperti jaringan saraf, pohon keputusan, atau metode vektor dukungan, dapat dijalankan di kedua mode. <br><br>  Ada juga algoritma yang dapat belajar untuk mengekstrak dari sampel kelas tanpa perlu target y.  Ini disebut pembelajaran tanpa pengawasan, sebagai lawan dari pembelajaran yang diawasi.  Di antara dua metode ini terdapat â€œpenguatan pembelajaranâ€, di mana sistem melatih dengan menjalankan simulasi dengan fungsi yang ditentukan dan menggunakan hasilnya sebagai tujuan.  Seorang pengikut AlphaGo, sistem yang disebut AlphaZero menggunakan pembelajaran yang diperkuat, memainkan sejuta game Go dengan sendirinya.  Di bidang keuangan, sistem atau produk seperti itu yang menggunakan pembelajaran tanpa pengawasan sangat jarang.  99% sistem menggunakan pembelajaran terawasi. <br><br>  Sinyal apa pun yang kami gunakan untuk prediktor di bidang keuangan, dalam kebanyakan kasus, sinyal-sinyal itu akan mengandung banyak kebisingan dan sedikit informasi, dan selain itu mereka akan limbung.  Jadi prediksi keuangan adalah salah satu tugas paling sulit dari pembelajaran mesin.  Algoritma yang lebih kompleks di sini mencapai hasil yang lebih baik.  Pemilihan prediktor sangat penting untuk kesuksesan.  Tidak harus ada banyak dari mereka, karena ini mengarah pada pelatihan ulang dan kegagalan fungsi.  Oleh karena itu, strategi penambangan data sering menggunakan algoritma yang dipilih sebelumnya yang mengekstraksi sejumlah kecil prediktor dari kumpulan yang lebih luas.  Seleksi awal semacam itu mungkin didasarkan pada korelasi antara prediktor, signifikansi mereka, kekayaan informasi, atau hanya keberhasilan / kegagalan penggunaan rangkaian uji.  Eksperimen praktis dengan pemilihan target dapat ditemukan, misalnya, di blog <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kekayaan Robot</a> . <br><br>  Di bawah ini adalah daftar metode penambangan data yang paling populer digunakan di bidang keuangan. <br><br><h2>  1. Sup indikator </h2><br>  Sebagian besar sistem perdagangan tidak didasarkan pada model keuangan.  Seringkali pedagang hanya memerlukan sinyal perdagangan yang dihasilkan oleh indikator teknis tertentu, yang disaring oleh indikator lain dalam kombinasi dengan indikator teknis tambahan.  Ketika bertanya kepada seorang trader tentang bagaimana kecelakaan indikator semacam itu dapat menghasilkan semacam keuntungan, ia biasanya menjawab sesuatu seperti: "Percayalah, saya berdagang tangan saya dan semuanya berfungsi." <br><br>  Dan itu benar.  Setidaknya terkadang.  Meskipun sebagian besar sistem ini tidak akan lulus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tes WFA</a> (dan beberapa hanya menguji data historis), sejumlah besar sistem seperti itu pada akhirnya bekerja dan menghasilkan keuntungan.  Penulis blog Peretas Keuangan terlibat dalam pengembangan sistem perdagangan khusus, dan menceritakan kisah salah satu klien yang secara sistematis bereksperimen dengan indikator teknis hingga ia menemukan kombinasi yang berfungsi untuk jenis aset tertentu.  Metode trial and error ini adalah pendekatan klasik untuk penambangan data, untuk kesuksesan Anda hanya membutuhkannya, keberuntungan dan banyak uang untuk tes.  Akibatnya, terkadang Anda dapat mengandalkan sistem yang menguntungkan. <br><br><h2>  2. Pola kandil </h2><br>  Jangan dikelirukan dengan pola kandil yang telah ada selama ratusan tahun.  Setara modern dari pendekatan ini adalah perdagangan berdasarkan pergerakan harga.  Anda juga menganalisis indikator terbuka, tinggi, rendah dan dekat untuk setiap lilin di grafik.  Tapi sekarang Anda menggunakan data mining untuk menganalisis lilin kurva harga untuk menyoroti pola yang dapat digunakan untuk menghasilkan prediksi tentang arah pergerakan harga di masa depan. <br><br>  Ada seluruh paket perangkat lunak untuk tujuan ini.  Mereka mencari pola yang menguntungkan dalam hal kriteria yang ditentukan pengguna, dan menggunakannya untuk membangun fungsi deteksi pola.  Semua ini mungkin terlihat seperti ini: <br><br><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">detect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">* sig)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">4</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">0</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">5</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">10</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">11</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">11</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">7</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">7</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">8</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">8</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">9</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">9</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">6</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">4</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">1</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">1</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">2</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">5</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">3</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">7</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">8</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">10</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">6</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">6</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">11</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">11</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">9</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">4</span></span>] &amp;&amp; eqF(sig[<span class="hljs-number"><span class="hljs-number">4</span></span>]-sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]) &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">2</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">3</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">10</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">7</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">8</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">6</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">6</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">11</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">11</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">9</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">4</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">4</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">5</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">2</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">0</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">7</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">8</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">10</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">11</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">11</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">9</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">9</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">6</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">4</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">5</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">5</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">3</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">10</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">7</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">7</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">8</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">8</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">6</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">6</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">11</span></span>] &amp;&amp; sig[<span class="hljs-number"><span class="hljs-number">11</span></span>]&lt;sig[<span class="hljs-number"><span class="hljs-number">9</span></span>]) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; }</code> </pre> <br>  Fungsi C ini mengembalikan 1 ketika sinyal cocok dengan salah satu pola, jika tidak maka mengembalikan 0. Kode panjang tampaknya mengisyaratkan bahwa ini bukan cara tercepat untuk mencari pola.  Lebih baik menggunakan pendekatan di mana fungsi deteksi tidak perlu diekspor, tetapi dapat mengurutkan sinyal berdasarkan kepentingannya dan mengurutkannya.  Contoh dari sistem tersebut dapat ditemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di tautan</a> . <br><br>  Bisakah perdagangan dengan harga berhasil?  Seperti dalam kasus sebelumnya, metode ini tidak didasarkan pada model keuangan rasional apa pun.  Pada saat yang sama, semua orang memahami bahwa peristiwa tertentu di pasar dapat memengaruhi pesertanya, sebagai akibatnya pola prediksi jangka pendek muncul.  Tetapi jumlah pola seperti itu tidak bisa besar jika Anda hanya mempelajari urutan beberapa lilin berurutan pada grafik.  Maka Anda perlu membandingkan hasilnya dengan data lilin, yang tidak ada di dekatnya, tetapi, sebaliknya, dipilih secara acak dalam periode waktu yang lebih lama.  Dalam hal ini, Anda akan mendapatkan jumlah pola yang hampir tak terbatas - dan berhasil melepaskan diri dari konsep realitas dan rasionalitas.  Sulit membayangkan bagaimana harga di masa depan dapat diprediksi berdasarkan beberapa nilainya minggu lalu.  Meskipun demikian, banyak pedagang bekerja ke arah ini. <br><br><h2>  3. Regresi linier </h2><br>  Dasar sederhana untuk banyak algoritma pembelajaran mesin yang kompleks: untuk memprediksi variabel target y menggunakan kombinasi linear dari prediktor x1 ... xn. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3d0/230/0e1/3d02300e11bdf79ba483a647d5089421.png" alt="gambar"><br><br>  Odds - ini adalah model.  Mereka dihitung untuk meminimalkan jumlah penyimpangan kuadrat antara nilai-nilai y nyata, nilai-nilai pelatihan dan prediksi y sesuai dengan rumus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/bc7/06c/d46/bc706cd46620a7d8682eb18e16daeeda.png" alt="gambar"><br><br>  Untuk sampel yang terdistribusi normal, minimalisasi dimungkinkan menggunakan operasi matriks, sehingga iterasi tidak diperlukan.  Dalam kasus ketika n = 1 - dengan hanya satu prediktor x, rumus regresi dikurangi menjadi: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/adc/a79/e98/adca79e98f1193be9b631dbfe51dbc96.png" alt="gambar"><br><br>  - yaitu, sebelum regresi linier sederhana, dan ketika n&gt; 1 regresi linier akan multivarian.  Regresi linier sederhana tersedia di sebagian besar platform perdagangan, misalnya, indikator <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">LinReg</a> di TA-Lib.  Ketika y = harga dan x = waktu, itu dapat digunakan sebagai alternatif untuk moving average.  Dalam platform R, regresi tersebut diimplementasikan oleh fungsi pengiriman standar lm (..).  Itu juga dapat diwakili oleh regresi polinomial.  Seperti dalam kasus paling sederhana, di sini kita menggunakan satu variabel prediktif x, tetapi juga kuadrat dan derajat berikutnya, jadi xn == xn: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/248/b3c/bd4/248b3cbd40c637b1a15376d227432e81.png" alt="gambar"><br><br>  Jika n = 2 atau n = 3, regresi polinomial sering digunakan untuk memprediksi harga rata-rata berikutnya dari harga smoothed dari bar terakhir.  Untuk regresi polinomial, fungsi polyfit dari MatLab, R, Zorro dan banyak platform lainnya dapat digunakan. <br><br><h2>  4. Perceptron </h2><br>  Seringkali itu disebut jaringan saraf dengan hanya satu neuron.  Faktanya, perceptron adalah fungsi regresi, seperti dijelaskan di atas, tetapi dengan hasil biner, yang karenanya disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">regresi logistik</a> .  Meskipun, secara umum, ini bukan regresi, tetapi algoritma klasifikasi.  Misalnya, fungsi saran (PERCEPTRON, ...) dari kerangka kerja Zorro menghasilkan kode C yang mengembalikan 100 atau -100 tergantung pada apakah hasil yang diprediksi adalah ambang batas atau tidak: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">predict</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">* sig)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-number"><span class="hljs-number">-27.99</span></span>*sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] + <span class="hljs-number"><span class="hljs-number">1.24</span></span>*sig[<span class="hljs-number"><span class="hljs-number">1</span></span>] - <span class="hljs-number"><span class="hljs-number">3.54</span></span>*sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">-21.50</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">100</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-100</span></span>; }</code> </pre> <br>  Seperti yang Anda lihat, array sig setara dengan fungsi xn dalam rumus regresi, dan koefisien a adalah faktor digital. <br><br><h2>  5. Jaringan saraf </h2><br>  Regresi linier atau logistik hanya dapat menyelesaikan masalah linier.  Pada saat yang sama, tugas perdagangan seringkali tidak sesuai dengan kategori ini.  Contoh terkenal adalah prediksi output dari fungsi XOR sederhana.  Ini juga termasuk prediksi untung dari transaksi.  Jaringan saraf tiruan (JST) dapat memecahkan masalah non-linear.  Ini adalah seperangkat perceptrons yang terhubung ke array level yang berbeda.  Setiap perceptron adalah neuron jaringan.  Outputnya menjadi input ke neuron lain dari tingkat berikut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/050/d12/c5d/050d12c5da82f4f97fdd942d7777b8e4.png" alt="gambar"><br><br>  Seperti perceptron, jaringan saraf dilatih dengan menentukan koefisien yang meminimalkan kesalahan antara prediksi dan target dalam sampel.  Ini membutuhkan proses perkiraan, biasanya dengan propagasi kembali kesalahan dari output ke input dengan optimalisasi bobot di sepanjang jalan.  Proses ini memiliki dua keterbatasan.  Pertama, output neuron harus merupakan fungsi yang dapat dibedakan secara terus-menerus, bukan ambang sederhana untuk perceptron.  Kedua, jaringan seharusnya tidak terlalu dalam - keberadaan sejumlah besar level neuron yang tersembunyi antara input dan output hanya membahayakan data.  Batasan kedua ini membatasi kompleksitas masalah yang dapat diselesaikan oleh jaringan saraf standar. <br><br>  Saat menggunakan jaringan saraf untuk memprediksi transaksi, Anda akan memiliki banyak parameter yang dapat dimanipulasi, yang, jika dilakukan secara tidak akurat, dapat mengakibatkan munculnya bias seleksi: <br><br><ul><li>  jumlah level tersembunyi; </li><li>  jumlah neuron di setiap tingkat tersembunyi; </li><li>  jumlah siklus backpropagation - zaman; </li><li>  tingkat pelatihan, lebar langkah era; </li><li>  momentum, faktor kelembaman untuk adaptasi bobot; </li><li>  fungsi aktivasi. </li></ul><br>  Fungsi aktivasi mengemulasi ambang perceptron.  Untuk propagasi balik, Anda memerlukan fungsi yang dapat dibedakan secara konstan yang menghasilkan langkah lunak untuk nilai x tertentu.  Biasanya, fungsi sigmoid, tanh, atau softmax digunakan untuk ini.  Terkadang fungsi linear digunakan yang mengembalikan jumlah tertimbang dari semua data input.  Dalam hal ini, jaringan dapat digunakan untuk regresi, prediksi nilai numerik, bukan output biner. <br><br>  Jaringan saraf termasuk dalam pengiriman paket standar R (misalnya, nnet adalah jaringan dengan satu tingkat tersembunyi), serta dalam banyak paket lainnya (seperti RSNNS dan FCNN4R). <br><br><h2>  6. Pembelajaran yang mendalam </h2><br>  Metode pembelajaran mendalam menggunakan jaringan saraf dengan banyak level tersembunyi dan ribuan neuron yang tidak dapat dilatih secara efektif menggunakan propagasi balik sederhana.  Dalam beberapa tahun terakhir, beberapa metode telah menjadi populer untuk melatih jaringan besar tersebut.  Mereka biasanya melibatkan pra-pelatihan tingkat neuron tersembunyi untuk meningkatkan efektivitas pembelajaran dasar. <br><br>  Restricted Boltzmann Machine (RBM) adalah algoritma klasifikasi yang tidak terkontrol dengan struktur jaringan khusus di mana tidak ada koneksi antara neuron tersembunyi.  Sparse Auto Encoder (SAE) menggunakan struktur jaringan yang biasa, tetapi pra-melatih lapisan tersembunyi dengan cara tertentu, mereproduksi sinyal input pada tingkat output dengan sesedikit mungkin koneksi aktif.  Metode-metode ini memungkinkan Anda untuk menerapkan jaringan yang sangat kompleks untuk menyelesaikan masalah pembelajaran yang sangat kompleks.  Misalnya, tugas mengalahkan orang terbaik yang bermain Go. <br><br>  Jaringan deep learning termasuk dalam paket deepnet dan darch untuk R. Deepnet termasuk auto-encoder, dan darch termasuk mesin Boltzmann.  Di bawah ini adalah contoh kode yang menggunakan deepnet dengan tiga level tersembunyi untuk memproses sinyal perdagangan melalui fungsi neor () dari framework Zorro: <br><br><pre> <code class="cpp hljs">library(<span class="hljs-string"><span class="hljs-string">'deepnet'</span></span>, quietly = T) library(<span class="hljs-string"><span class="hljs-string">'caret'</span></span>, quietly = T) <span class="hljs-meta"><span class="hljs-meta"># called by Zorro for training neural.train = function(model,XY) { XY </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;- as.matrix(XY) X &lt;- XY[,-ncol(XY)] # predictors Y &lt;- XY[,ncol(XY)] # target Y &lt;- ifelse(Y &gt; 0,1,0) # convert -1..1 to 0..1 Models[[model]] &lt;&lt;- sae.dnn.train(X,Y, hidden = c(50,100,50), activationfun = "tanh", learningrate = 0.5, momentum = 0.5, learningrate_scale = 1.0, output = "sigm", sae_output = "linear", numepochs = 100, batchsize = 100, hidden_dropout = 0, visible_dropout = 0) } # called by Zorro for prediction neural.predict = function(model,X) { if(is.vector(X)) X &lt;- t(X) # transpose horizontal vector return(nn.predict(Models[[model]],X)) } # called by Zorro for saving the models neural.save = function(name) { save(Models,file=name) # save trained models } # called by Zorro for initialization neural.init = function() { set.seed(365) Models &lt;&lt;- vector("list") } # quick OOS test for experimenting with the settings Test = function() { neural.init() XY &lt;&lt;- read.csv('C:/Project/Zorro/Data/signals0.csv',header = F) splits &lt;- nrow(XY)*0.8 XY.tr &lt;&lt;- head(XY,splits) # training set XY.ts &lt;&lt;- tail(XY,-splits) # test set neural.train(1,XY.tr) X &lt;&lt;- XY.ts[,-ncol(XY.ts)] Y &lt;&lt;- XY.ts[,ncol(XY.ts)] Y.ob &lt;&lt;- ifelse(Y &gt; 0,1,0) Y &lt;&lt;- neural.predict(1,X) Y.pr &lt;&lt;- ifelse(Y &gt; 0.5,1,0) confusionMatrix(Y.pr,Y.ob) # display prediction accuracy }</span></span></span></span></code> </pre> <br><h2>  7. Mendukung vektor </h2><br>  Seperti halnya jaringan saraf, metode vektor dukungan adalah perpanjangan lain dari regresi linier.  Jika Anda melihat rumus regresi lagi: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/3d0/230/0e1/3d02300e11bdf79ba483a647d5089421.png" alt="gambar"><br><br>  Kemudian seseorang dapat menginterpretasikan fungsi xn sebagai koordinat ruang n-dimensi.  Menetapkan variabel target y ke nilai tetap akan menentukan bidang di ruang ini - itu akan disebut hyperplane, karena sebenarnya ia akan memiliki dua (bahkan n-1) ukuran.  Hyperplane memisahkan sampel dengan y&gt; 0 dari yang mana y &lt;0. Koefisien a dapat dihitung sebagai lintasan yang memisahkan pesawat dari sampel terdekat - vektor pendukungnya, dengan demikian nama algoritma.  Dengan demikian, kita mendapatkan classifier biner dengan pemisahan optimal dari sampel menang dan kalah. <br><br>  Masalah: biasanya sampel ini tidak dapat dibagi secara linear - mereka dikelompokkan secara acak dalam ruang fungsi.  Tidak mungkin untuk menggambar bidang yang halus antara opsi yang menang dan yang kalah, jika ini bisa dilakukan, maka untuk perhitungannya orang dapat menggunakan metode yang lebih sederhana seperti analisis diskriminan linier.  Namun dalam kasus umum, Anda dapat menggunakan trik ini: tambahkan lebih banyak ukuran ke ruang.  Dalam hal ini, algoritma vektor dukungan akan dapat menghasilkan lebih banyak parameter dengan fungsi nuklir yang menggabungkan dua prediktor - mirip dengan transisi dari regresi sederhana ke polinomial.  Semakin banyak ukuran yang Anda tambahkan, semakin mudah untuk membagi sampel dengan hyperplane.  Kemudian dapat dikonversi kembali ke ruang n-dimensi asli. <br><br>  Seperti jaringan saraf, vektor referensi dapat digunakan tidak hanya untuk klasifikasi, tetapi juga untuk regresi.  Mereka juga menawarkan sejumlah opsi untuk optimasi dan kemungkinan pelatihan ulang: <br><br><ul><li>  Fungsi kernel - kernel RBF (fungsi basis radial, kernel simetris) biasanya digunakan, tetapi kernel lain dapat dipilih, misalnya, sigmoid, polinom dan linear. </li><li>  Gamma - Lebar inti RBF. </li><li>  Parameter biaya C, â€œpenaltiâ€ untuk klasifikasi sampel pelatihan yang salah. </li></ul><br>  Perpustakaan libsvm sering digunakan, yang tersedia dalam paket e1071 untuk R. <br><br><h2>  8. Algoritma k-tetangga terdekat </h2><br>  Dibandingkan dengan JST dan SVM yang berat, ini adalah algoritma yang sederhana dan menyenangkan dengan properti yang unik: tidak perlu dilatih.  Sampel akan menjadi model.  Algoritma ini dapat digunakan untuk sistem perdagangan yang terus-menerus dilatih dengan menambahkan sampel baru.  Algoritma ini menghitung jarak dalam ruang fungsi dari nilai saat ini ke sampel k-terdekat.  Jarak dalam ruang n-dimensi antara dua set (x1 ... xn) dan (y1 ... yn) dihitung dengan rumus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/66e/322/2bc/66e3222bce4b5e79d460e20b612eadcb.png" alt="gambar"><br><br>  Algoritma hanya memprediksi target dari rata-rata variabel target k dari sampel terdekat, dibobot oleh jarak pengembaliannya.  Ini dapat digunakan untuk klasifikasi dan regresi.  Untuk memprediksi tetangga terdekat, Anda dapat memanggil fungsi knn di R atau menulis kode C sendiri untuk tujuan ini. <br><br><h2>  9. K-means </h2><br>  Ini adalah algoritma perkiraan untuk klasifikasi yang tidak terkontrol.  Ini agak mirip dengan algoritma sebelumnya.  Untuk mengklasifikasikan sampel, algoritma pertama menempatkan titik acak k dalam ruang fungsi.  Kemudian ia menetapkan ke salah satu titik ini semua sampel dengan jarak terkecil ke sana.  Kemudian titik tersebut bergeser ke tengah dari nilai-nilai terdekat ini.  Ini menghasilkan binding sampel baru, karena beberapa dari mereka sekarang akan lebih dekat ke titik lain.  Proses ini diulang sampai referensi ulang sebagai hasil dari pergeseran titik berhenti, yaitu, sampai setiap titik rata-rata untuk sampel terdekat.  Sekarang kita memiliki kelas sampel k, masing-masing terletak di sebelah titik-k. <br><br>  Algoritma sederhana ini dapat menghasilkan hasil yang sangat baik.  Dalam R, fungsi kmeans digunakan untuk mengimplementasikannya, contoh algoritma dapat ditemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">di tautan</a> . <br><br><h2>  10. Naif Bayes </h2><br>  Algoritma ini menggunakan teorema Bayesian untuk mengklasifikasikan sampel fungsi non-numerik (peristiwa), seperti pola lilin yang disebutkan di atas.  Misalkan peristiwa X (misalnya, parameter Buka bilah sebelumnya di bawah parameter Buka bilah saat ini) muncul di 80% dari sampel yang menang.  Lalu berapa kemungkinan memenangkan sampel di hadapan event X di dalamnya?  Ini bukan 0,8 seperti yang mungkin Anda pikirkan.  Probabilitas ini dihitung dengan rumus: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/727/e4e/7ab/727e4e7abb69e9b8ef5334558a753a70.png" alt="gambar"><br><br>  P (Y | X) adalah probabilitas bahwa peristiwa Y (laba) akan terjadi di semua sampel yang mengandung peristiwa X (dalam contoh kami, Buka (1) &lt;Buka (0)).  Sesuai dengan rumus, itu sama dengan probabilitas kemunculan peristiwa X di semua sampel pemenang (dalam kasus kami 0.8), dikalikan dengan probabilitas Y di semua sampel (sekitar 0,5 jika Anda mengikuti kiat menyeimbangkan sampel) dan dibagi dengan probabilitas kemunculan X di semua sampel. <br><br>  Jika kita naif dan menganggap bahwa semua peristiwa X tidak tergantung satu sama lain, maka kita dapat menghitung probabilitas total bahwa sampel akan menang dengan hanya mengalikan probabilitas P (X | menang) untuk setiap peristiwa X. Kemudian kita sampai pada rumus berikut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/7b0/c54/d51/7b0c54d515098b06b54e7446d9097954.png" alt="gambar"><br><br>  Dengan faktor penskalaan s.  Agar formula dapat berfungsi, fungsi harus dipilih sedemikian rupa sehingga dapat sebebas mungkin.  Ini akan menjadi hambatan untuk menggunakan Bayes yang naif untuk berdagang.  Misalnya, dua acara Tutup (1) &lt;Tutup (0) dan Buka (1) &lt;Buka (0) kemungkinan besar tidak saling terpisah.  Prediktor numerik dapat dikonversi ke acara dengan membagi angka menjadi rentang yang terpisah.  Naive Bayes tersedia dalam paket e1071 untuk R. <br><br><h2>  11. Pohon keputusan dan regresi </h2><br>  Pohon tersebut memprediksi hasil nilai numerik berdasarkan rantai keputusan dalam format ya / tidak dalam struktur cabang pohon.  Setiap keputusan mewakili ada atau tidak adanya peristiwa (dalam hal nilai non-numerik) atau perbandingan nilai dengan ambang batas yang ditetapkan.  Fungsi pohon yang khas, yang dihasilkan, misalnya, oleh kerangka kerja Zorro, terlihat seperti ini: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">tree</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">double</span></span></span></span><span class="hljs-function"><span class="hljs-params">* sig)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>] &lt;= <span class="hljs-number"><span class="hljs-number">12.938</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">0</span></span>] &lt;= <span class="hljs-number"><span class="hljs-number">0.953</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-70</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &lt;= <span class="hljs-number"><span class="hljs-number">43</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">25</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &lt;= <span class="hljs-number"><span class="hljs-number">0.962</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-67</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span>; } } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">3</span></span>] &lt;= <span class="hljs-number"><span class="hljs-number">0.732</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-71</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">1</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">30.61</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">27</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(sig[<span class="hljs-number"><span class="hljs-number">2</span></span>] &gt; <span class="hljs-number"><span class="hljs-number">46</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">80</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">-62</span></span>; } } } }</code> </pre> <br>  Bagaimana pohon seperti itu diperoleh dari serangkaian sampel?  Mungkin ada beberapa metode untuk ini, termasuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">entropi informasi Shannon</a> . <br><br>  Pohon keputusan dapat digunakan secara luas.  Sebagai contoh, mereka cocok untuk menghasilkan prediksi yang lebih akurat daripada yang dapat dicapai menggunakan jaringan saraf atau vektor referensi.  Namun, ini bukan solusi universal.  Algoritma yang paling dikenal dari jenis ini adalah C5.0, tersedia dalam paket C50 untuk R. <br><br>  Untuk lebih meningkatkan kualitas prediksi, Anda dapat menggunakan set pohon - mereka disebut hutan acak.  Algoritma ini tersedia dalam paket R yang disebut randomForest, ranger, dan Rborist. <br><br><h2>  Kesimpulan </h2><br>  Ada banyak metode penambangan data dan pembelajaran mesin.  Pertanyaan kritis di sini adalah ini: mana yang lebih baik, strategi berbasis model atau pembelajaran mesin?  Tidak ada keraguan bahwa pembelajaran mesin memiliki sejumlah keunggulan.  Misalnya, Anda tidak perlu peduli dengan mikrostruktur pasar, ekonomi, pertimbangkan filosofi pelaku pasar atau hal serupa lainnya.  Anda dapat berkonsentrasi pada matematika murni.  Pembelajaran mesin adalah cara yang jauh lebih elegan dan menarik untuk menciptakan sistem perdagangan.  Di pihaknya, semua keuntungan, kecuali satu - selain cerita di forum pedagang, keberhasilan metode ini dalam perdagangan nyata sulit dilacak. <br><br>  Hampir setiap minggu, artikel baru diterbitkan tentang perdagangan menggunakan pembelajaran mesin.  Materi seperti itu harus diambil dengan skeptisisme yang adil.  Beberapa penulis mengklaim tingkat kemenangan fantastis 70%, 80%, atau bahkan 85%.  Namun, beberapa orang mengatakan bahwa Anda dapat kehilangan uang bahkan jika prediksi itu menang.  Akurasi 85% biasanya diterjemahkan menjadi indikator profitabilitas di atas 5 - jika semuanya begitu sederhana, maka pencipta sistem seperti itu sudah akan menjadi miliarder.  Namun, untuk beberapa alasan, mereproduksi hasil yang sama hanya dengan mengulangi metode yang dijelaskan dalam artikel gagal. <br><br>  Dibandingkan dengan sistem berbasis model, ada beberapa sistem pembelajaran mesin yang sangat sukses.  Misalnya, mereka jarang digunakan oleh dana lindung nilai yang sukses.  Mungkin di masa depan, ketika kekuatan komputasi menjadi lebih mudah diakses, sesuatu akan berubah, tetapi untuk saat ini, algoritma pembelajaran yang mendalam tetap lebih merupakan hobi yang menarik bagi para geek daripada alat penghasil uang nyata di bursa. <br><br><h2>  Materi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terkait</a> pasar keuangan dan saham lainnya dari <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ITI Capital</a> : </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Analisis dan ulasan pasar</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kembali ke masa depan: memeriksa kinerja robot dagang menggunakan data historis</a> </li><li>  Event backtesting Python yang digerakkan oleh langkah demi langkah ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 4</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 5</a> ) </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id412639/">https://habr.com/ru/post/id412639/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id412625/index.html">Cara cepat menemukan dan tidak kehilangan spesialis AI dan Data Science</a></li>
<li><a href="../id412627/index.html">Pameran Internasional CMEF & ICMD 2018 Spring di Shanghai (Bagian 2)</a></li>
<li><a href="../id412629/index.html">Gelombang Adaptif untuk layanan audio Anda</a></li>
<li><a href="../id412633/index.html">Pengalaman mengkonfigurasi dan menggunakan WSL (Linux subsystem di Windows 10)</a></li>
<li><a href="../id412637/index.html">Untuk melakukan atau tidak mendesain ulang logo? Itu pertanyaannya</a></li>
<li><a href="../id412641/index.html">Apa kesamaan yang dimiliki pertambangan, Georgia dan Irkutsk?</a></li>
<li><a href="../id412643/index.html">Bagaimana kami mengintegrasikan sistem pembayaran ke dalam proyek Rusia</a></li>
<li><a href="../id412645/index.html">Obyek, properti, aktivitas: model dan metode konstruksi mereka</a></li>
<li><a href="../id412647/index.html">Bukti baru untuk keberadaan planet kesembilan</a></li>
<li><a href="../id412649/index.html">Cara membangun tim dan proses yang berfokus pada pertumbuhan yang cepat</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>