<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚒 🚣 🖊️ 1000维多维数据集：今天是否可以创建人类记忆的计算模型？ 💠 🎾 🚴🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="今天早上，在去伯克利大学校园的路上，我用手指沿着芬芳的灌木丛的叶子，然后吸入了熟悉的气味。 我每天都要这样做，而且每天脑海中浮现出第一个要招呼的词是鼠尾草 。 但是我知道这种植物不是鼠尾草，而是迷迭香，所以我命令鼠尾草镇定下来。 但是为时已晚。 经过迷迭香和鼠尾草之后，我无法停止在舞台上出现欧芹和百...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>1000维多维数据集：今天是否可以创建人类记忆的计算模型？</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/419147/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/hm/bf/hq/hmbfhq9wergzhrrb1fskxsurpsk.png" alt="图片"></div><br> 今天早上，在去伯克利大学校园的路上，我用手指沿着芬芳的灌木丛的叶子，然后吸入了熟悉的气味。 我每天都要这样做，而且每天脑海中浮现出第一个要招呼的词是<em>鼠尾草</em> 。 但是我知道这种植物不是鼠尾草，而是迷迭香，所以我命令<em>鼠尾草</em>镇定下来。 但是为时已晚。 经过<em>迷迭香</em>和<em>鼠尾草之后，</em>我无法停止在舞台上出现<em>欧芹</em>和<em>百里香</em> ，此后专辑的封面上出现了旋律和脸部的第一音符，现在我回到了1960年代中期，穿着衬衫用黄瓜。 同时， <em>迷迭香</em>在Rose Mary Woods的记忆中增加了13分钟的间隔（尽管<em>现在</em> ，在咨询了集体记忆之后，我知道应该是Rose Mary Woods和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">18分钟半的空间</a> ）。 从Watergate，我跳到主页上的故事。 然后我注意到在一个保存完好的花园里另一种植物是蓬松的灰绿色的叶子。 这也不是鼠尾草，而是清洁剂（小羊的耳朵）。 然而， <em>圣人</em>终于有了光荣的时刻。 从草丛开始，我转到了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Sage</a>数学软件，然后转到了称为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SAGE</a>的1950年代防空系统，即半自动地面环境，该系统由有史以来最大的计算机进行管理。 <br><br> 在心理学和文学中，这种精神上的徘徊被称为<em>意识流</em> （这个隐喻的作者是威廉·詹姆斯）。 但是我会选择一个不同的隐喻。 据我所知，我的意识不是从一个话题平稳地流向另一个话题，而是在思想的视域中飞舞，更像是蝴蝶而不是河流，时而钉在一朵花上，然后又钉在另一朵花上，时而被阵风吹走，时而来在同一地点一次又一次。 <br><a name="habracut"></a><br> 为了探索我自己的记忆结构，我尝试通过自由联想进行更悠闲的实验。 我从相同的花卉食谱开始-欧芹，鼠尾草，迷迭香和百里香-但是，在此练习中，我没有漫步过伯克利山丘的花园； 我坐在桌旁做笔记。 下图是重构我整个思想过程的最佳尝试。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nx/fp/e4/nxfpe47jmecnrrd9v1wju4k2xts.png"></div><br> 欧芹，鼠尾草，迷迭香，百里香-四种草药，以及西蒙（Simon）和加芬克尔（Garfunkel）的一首歌。 <br><br> 西蒙与加芬克尔（Paul Simon and Art Garfunkel），1960年代和70年代民间摇滚风格的歌手二重唱。 <br><br> 太太 罗宾逊（Robinson）是西蒙（Simon）和加芬克（Garfunkel）的歌曲，也是迈克·尼科尔斯（Mike Nichols）的电影《毕业生》中的角色。 <br><br>  “你去哪儿了，乔·迪马乔？”  -“夫人。 罗宾逊。 <br><br> 西蒙和舒斯特（Simon and Schuster）是由理查德·西蒙（Richard Simon）和马克斯·舒斯特（Max Schuster）于1924年（最初是为填字游戏出版）成立的一家出版社。 <br><br> 杰基·罗宾逊（Jackie Robinson）是传奇的布鲁克林道奇队球员。 <br><br> 鲁滨逊·克鲁索（Robinson Crusoe）-丹尼尔·笛福（Daniel Defoe）关于沉船的小说（1719）。 <br><br> 瑞士鲁宾逊一家-约翰·戴维·韦斯（Johan David Weiss）的小说《沉船》（1812）。 <br><br> 草药-芳香植物 <br><br> 先生 向导是唐·赫伯特（Don Herbert）主持的1950年代星期六针对儿童的科学表演。 <br><br>  Alpert-小号手Alpert的徽章。 <br><br> 塑料是毕业生提出的职业建议。 <br><br>  coo-coo-ca-choo-“ Mrs. 罗宾逊。 <br><br> 弗兰克·罗宾逊（Frank Robinson）是1970年代巴尔的摩金莺的外野手。 <br><br>  Greig Nettles是1970年代纽约洋基队的第三位棒球运动员。 <br><br> 达斯汀·霍夫曼（Dustin Hoffman）是在《毕业生》中饰演的演员。 <br><br> 艾比·霍夫曼（Abby Hoffman）-“爷爷！” <br><br> 莱明斯特（Leominster）是马萨诸塞州的一个城市，已经成为美国塑料制造业的摇篮。 <br><br> 布鲁克斯·罗宾逊（Brooks Robinson）是1970年代巴尔的摩金莺队的第三位棒球运动员。 <br><br> 巴比龙（The Moth）-1973年的电影，达斯汀·霍夫曼（Dustin Hoffman）扮演次要角色； 法语中的“ Papillon”是“蝴蝶”。 <br><br> 纳博科夫-弗拉基米尔·纳博科夫（Vladimir Nabokov），俄罗斯出生的作家，是研究蝴蝶的昆虫学家。 <br><br> 蝴蝶，Schmetterling，mariposa，farfalla-英语，德语，西班牙语和意大利语中的“蝴蝶”； 似乎所有这些人（还有法语单词）都是独立起源的。 <br><br> 蝴蝶用俄语叫什么-我不知道。 还是不知道这个问题何时出现。 <br><br>  “我是海象”是1967年甲壳虫乐队的歌曲，也有短语“ coo-coo-ca-choo”。 <br><br> 卡莉·西蒙（Carly Simon）是歌手。 与保罗·西蒙没有关系，但是理查·西蒙的女儿。 <br><br> 卡莉·西蒙（Carly Simon）演唱的一首歌《你真是徒劳》。 <br><br> 自上而下的图形以主题在大脑中弹出的顺序表示主题，但是节点之间的连接不会创建单个线性序列。 该结构类似于一棵树，树上有短链的连续关联，最后迅速返回到较早的节点，就好像我被拉长的橡皮筋拉回了原地。 这些中断在图表上用绿色箭头标记； 下面的红色X是我决定完成实验的地方。 <br><br> 对于1990年以后出生的人，我深表歉意，其中提到的许多主题对您来说似乎已经过时或神秘。 图表下方提供了说明，但我认为它们不会使关联更加清晰。 最后，记忆是个人的，它们生活在头脑中。 如果您想收集与自己的经历相关的想法，则只需要创建自己的免费关联时间表即可。 我强烈建议您这样做：您可能会发现自己不知道任何事情。 <br><br><hr><br> 我每天在伯克利（Berkeley）上山的目标是西蒙斯研究所（Simons Institute）和计算机理论课程（Computational Theory Course），在该课程中，我参加了为期一学期的大脑和计算课程。 这样的环境引起了思想的思考。 我开始反思：如何建立自由联想过程的计算模型？ 在人工智能提出的各种任务中，这一任务看起来非常简单。 不需要深入的合理化； 我们需要模拟的只是在云中做白日梦和徘徊-这是大脑在未加载时的行为。 这样的任务似乎很容易解决，不是吗？ <br><br> 关于这种计算模型的体系结构（至少是对<em>我的</em>头脑）的第一个想法是沿着数学图形或网络的随机运动。 网络节点是存储在内存中的元素-思想，事实，事件和通信是它们之间的各种关联。 例如， <em>蝴蝶</em>结可以与<em>飞蛾，毛毛虫，君主</em>和<em>珍珠母</em>相连<em>，</em>也可以与我的日程安排中提到的过渡相连，并且可能没有那么明显的联系，例如<em>澳大利亚爬行”，“虾”，“穆罕默德·阿里”，“佩拉格拉”，“窒息”</em>和<em>“舞台恐惧症”</em> 。 主机数据结构将包含指向所有这些相关主机的指针的列表。 指针可以从1到n进行编号； 程序将在此间隔内生成一个伪随机数，然后转到相应的节点，在该节点中，整个过程将再次开始。 <br><br> 该算法反映了自由关联的一些基本特征，但其中许多特征并未考虑在内。 该模型假定所有目标节点都是同等概率的，这似乎是不可行的。 考虑到概率差异，我们可以要求每个边 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mrow" id="MJXp-Span-2"><span class="MJXp-mo" id="MJXp-Span-3" style="margin-left: 0.278em; margin-right: 0.278em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我</font></font></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-1">我</script> 重量 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-4"><span class="MJXp-msubsup" id="MJXp-Span-5"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">W的</font></font></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-7" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我</font></font></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-2"> w_i </script>  ，然后使概率与权重成正比。 <br><br> 更重要的事实是，权重取决于上下文-取决于人类智力活动的最新历史。 如果我没有太太的组合 罗宾逊和杰基·罗宾逊，我会想到乔·迪·马吉欧吗？ 现在，当我写这篇文章时，乔尔丁·乔（绰号迪·马焦）回忆起玛丽莲·梦露，然后回忆起亚瑟·米勒，我再也无法阻止思想的流动。 为了在计算机模型中重现此效果，将需要根据最近访问过的其他节点来动态调整整个节点类别概率的某种机制。 <br><br> 您还应该考虑另一种新颖性的影响。 应该在模型中找到橡皮筋，不断将我拉回西蒙，加芬克尔和太太。 罗宾逊 大概，每个最近访问的站点都应添加到目标选项列表中，即使该站点没有以任何方式与当前站点连接。 另一方面，上瘾也是一种可能性：人们经常记住的想法变得无聊，因此应在模型中将其抑制。 <br><br> 另一个最终检验：某些记忆不是孤立的事实或观点，而是故事的一部分。 它们具有叙事结构，事件按时间顺序展开。 对于这种情节性回忆的节点，需要<em>下一个</em> （可能是<em>上</em> <em>一个）</em>边。 这样的肋骨将我们的一生团结在一起，包括您所记得的一切。 <br><br><hr><br> 相似的计算模型可以重现我的精神徘徊吗？ 收集这样一个模型的数据将是一个相当漫长的过程，这并不奇怪，因为我花了一辈子的时间来使我的头骨充满草药，纹章，西蒙斯，鲁滨逊和霍夫曼斯的交织。 除了数据量之外，我还关心图遍历算法的艰辛性。 说起来很容易：“根据加权概率集选择一个节点”，但是当我看一下执行此操作的肮脏细节时，我很难想象这样的事情会在大脑中发生。 <br><br> 这是我知道的用于随机加权选择的最简单算法。  （这不是这些算法中最有效的，但是方法更加混乱。Keith Schwartz撰写了一篇出色的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">教程并</a>对此主题进行了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">评论</a> 。）假设模拟网络节点的数据结构包括到其他节点的链接列表和相应的权重列表。 。 如下图所示，该程序生成许多累计的权重之和： <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-8"><span class="MJXp-mn" id="MJXp-Span-9"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 </font></font></span><span class="MJXp-mrow" id="MJXp-Span-10"><span class="MJXp-mo" id="MJXp-Span-11" style="margin-left: 0.278em; margin-right: 0.278em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></span></span><span class="MJXp-msubsup" id="MJXp-Span-12"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-13" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w </font></font></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-14" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span></span><span class="MJXp-mrow" id="MJXp-Span-15"><span class="MJXp-mo" id="MJXp-Span-16" style="margin-left: 0.278em; margin-right: 0.278em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></span></span><span class="MJXp-msubsup" id="MJXp-Span-17"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-18" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w </font></font></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-19" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span><span class="MJXp-mo" id="MJXp-Span-20" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font></span><span class="MJXp-msubsup" id="MJXp-Span-21"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-22" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w </font></font></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-23" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span></span><span class="MJXp-mrow" id="MJXp-Span-24"><span class="MJXp-mo" id="MJXp-Span-25" style="margin-left: 0.278em; margin-right: 0.278em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></span></span><span class="MJXp-msubsup" id="MJXp-Span-26"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-27" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w </font></font></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-28" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span><span class="MJXp-mo" id="MJXp-Span-29" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font></span><span class="MJXp-msubsup" id="MJXp-Span-30"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-31" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w </font></font></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-32" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></span></span><span class="MJXp-mo" id="MJXp-Span-33" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font></span><span class="MJXp-msubsup" id="MJXp-Span-34"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-35" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w </font></font></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-36" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 </font></font></span></span><span class="MJXp-mrow" id="MJXp-Span-37"><span class="MJXp-mo" id="MJXp-Span-38" style="margin-left: 0.278em; margin-right: 0.278em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></span></span><span class="MJXp-mtext" id="MJXp-Span-39" style="color: red;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> \点</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-3"> 0，w_1，w_1 + w_2，w_1 + w_2 + w_3，\点</script>  。 下一步是通过将每个数字除以权重的总和来标准化此系列。 现在我们有一系列数字 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-40"><span class="MJXp-msubsup" id="MJXp-Span-41"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-42" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p </font></font></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-43" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我</font></font></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-4"> p_i </script> 从零单调递增。 接下来，程序选择一个随机实数 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-44"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-45"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-5"> x </script> 从间隔 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-46"><span class="MJXp-mo" id="MJXp-Span-47" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[ </font></font></span><span class="MJXp-mn" id="MJXp-Span-48"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 </font></font></span><span class="MJXp-mrow" id="MJXp-Span-49"><span class="MJXp-mo" id="MJXp-Span-50" style="margin-left: 0.278em; margin-right: 0.278em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></span></span><span class="MJXp-mn" id="MJXp-Span-51"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1 </font></font></span><span class="MJXp-mrow" id="MJXp-Span-52"><span class="MJXp-mo" id="MJXp-Span-53" style="margin-left: 0.278em; margin-right: 0.278em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-6"> [0，1）</script>  ; <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-54"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-55"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-7"> x </script> 必须在标准化间隔之一内 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-56"><span class="MJXp-msubsup" id="MJXp-Span-57"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-58" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p </font></font></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-59" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我</font></font></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-8"> p_i </script>  ，并且这个值 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-60"><span class="MJXp-mrow" id="MJXp-Span-61"><span class="MJXp-mo" id="MJXp-Span-62" style="margin-left: 0.278em; margin-right: 0.278em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我</font></font></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9">我</script> 定义下一个可选节点。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fq/tb/lp/fqtblpodseuus5fug9ael204d7y.png"></div><br> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Julia编程语言</a>代码中<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，</a>节点选择过程如下所示： <br><br><pre><code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">select_next</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(links, weights)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">total</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(weights)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cum_weights</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cumsum</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(weights)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">probabilities</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cum_weights</span></span></span><span class="hljs-function"> / </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">total</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">rand</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">1</span></span></span><span class="hljs-function">:</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">length</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(probabilities)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">probabilities</span></span></span><span class="hljs-function">[</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-function">] &gt;= </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">x</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">i</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre> <br> 我如此缓慢地描述了累加的总和和伪随机数的这些无聊的细节，以这种方式强调，以使得该图遍历算法并不像乍看起来那样简单。 尽管我们的注意力从一个主题转移到另一个主题，但我们仍未考虑动态更改概率的主题。 <br><br> 理解学习过程甚至更加困难-向网络添加新的节点和边缘。 当我遇到一个我无法回答的问题时，我结束了自由协会的会议：俄语中的蝴蝶叫什么名字？ 但是<em>现在</em>我可以回答他。 下次我玩此游戏时，我会在列表中添加<em>babochka</em> 。 在计算模型中，为<em>babochka</em>单词插入节点是一个相当简单的任务，但是我们的新节点也应连接到所有现有的蝶形节点。 而且， <em>babochka</em>本身也增加了新的肋骨。 她在语音上接近<em>babushka</em> （祖母），这是我词典中几个俄语单词之一。 后缀<em>-ochka很小</em> ，因此必须与French- <em>ette</em>和Italian <em>-ini关联</em> 。  <em>babochka</em>一词的字面意思是“小灵魂”，这意味着更多的联想。 毕竟，学习一个新单词可能需要对整个知识树进行完全重新索引。 <br><br><hr><br> 让我们尝试另一种方法。 不用再随便从指针上遍历带有意大利面条的网络。 相反，让我们将所有类似的东西存储在附近。 从数字计算机存储库的角度来看，这意味着相似的事物将存储在相邻地址中。 这是一个以<em>狗</em>的概念为中心的假想记忆部分。 周围的地方被其他可能是由狗（ <em>狗</em> ）的想法引起的词语，概念和类别所占据：明显的<em>猫</em> （猫）和<em>小狗</em> （幼犬），不同品种的狗和几种特定的狗（Skippy是我们的家犬，在我的童年时期），以及可能更复杂的关联。 每个项目都有一个数字地址。 该地址没有任何深层含义，但是对所有存储单元进行顺序编号很重要。 <br><br><table><tbody><tr><th> 地址 </th><th> 内容 </th></tr><tr><td>  19216805 </td><td> 上帝 </td></tr><tr><td>  19216806 </td><td> 晚上没有吠叫的狗 </td></tr><tr><td>  19216807 </td><td> 轻率的 </td></tr><tr><td>  19216808 </td><td> 拉西 </td></tr><tr><td>  19216809 </td><td> 犬 </td></tr><tr><td>  19216810 </td><td> 猫 </td></tr><tr><td>  19216811 </td><td> 狗 </td></tr><tr><td>  19216812 </td><td> 小狗 </td></tr><tr><td>  19216813 </td><td> 狼 </td></tr><tr><td>  19216814 </td><td> 洞穴峡谷 </td></tr><tr><td>  19216815 </td><td> 贝塞猎狗 </td></tr><tr><td>  19216816 </td><td> 魏玛纳尔 </td></tr><tr><td>  19216817 </td><td> 教条的 </td></tr></tbody></table><br> 悠闲地在内存中徘徊的任务可能非常简单。 它可以随机遍历内存地址，但优点是小步长。 例如，可以通过从以当前位置为中心的正态分布中采样来确定下一个访问的地址。 这是朱莉娅的代码。  （ <code>randn()</code>函数返回从正态分布中获得的平均值的随机实数 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-63"><span class="MJXp-mtext" id="MJXp-Span-64" style="color: red;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\亩</font></font></span><span class="MJXp-mo" id="MJXp-Span-65" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mn" id="MJXp-Span-66"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-10"> \亩= 0 </script> 和标准偏差 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-67"><span class="MJXp-mtext" id="MJXp-Span-68">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-69"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-70"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-71"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">g </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-72"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-73"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font></span><span class="MJXp-mo" id="MJXp-Span-74" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mn" id="MJXp-Span-75"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-11"> \ sigma = 1 </script>  ） <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">gaussian_ramble</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(addr, sigma)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">randn</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sigma</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">addr</span></span></span><span class="hljs-function"> + </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">round</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Int, r)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre> <br> 这种方案具有吸引人的特征。 在选择其中一个目标节点之前，无需对所有可能的目标节点列表。 概率不存储为数字，而是由数组中的位置进行编码，并由参数进行调制 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-76"><span class="MJXp-mtext" id="MJXp-Span-77">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-78"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">š </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-79"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我</font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-80"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">克</font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-81"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">米</font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-82"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一个</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-12"> \ sigma </script>  ，它确定过程要在数组中移动的距离。 尽管程序仍执行算术运算以从正态分布进行采样，但此函数可能是更简单的解决方案。 <br><br> 但是，此过程仍然存在一个可怕的缺陷。  <em>与狗的</em>所有直接联系都被包围<em>了</em> ，我们没有留下<em>与狗</em>联系的空间。 狗的术语在它们自己的上下文中是好的，但是从列表中选择<em>猫</em>又如何呢？ 我们在哪里放<em>小猫</em> ， <em>老虎</em> ， <em>九个生命</em>和<em>菲利克斯</em> ？ 在一维数组中，无法将每个存储元素嵌入合适的环境中。 <br><br> 因此，让我们进入二维！ 将地址分为两个部分，我们定义了两个正交轴。 每个地址的前半部分成为坐标 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-83"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-84"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ÿ</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-13"> y </script> 和第二个坐标 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-85"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-86"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-14"> x </script>  。 现在， <em>猫和狗</em>仍然是近邻，但它们也有个人空间，可以与自己的“朋友”一起玩。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/if/kn/ef/ifknefmf6isjnhavuzpqj-q0epi.png"></div><br> 但是，两次测量也是不够的。 如果我们尝试填写与<em>“戴帽子的猫”</em>有关的所有元素，它们将不可避免地与<em>夜间没有吠叫的狗的</em>相关元素发生碰撞和冲突。 显然，我们需要更多的尺寸-更多。 <br><br><hr><br> 现在是承认的正确时机-我不是第一个考虑如何在内存中安排内存的人。 我的前辈的名单可以从柏拉图开始，柏拉图将记忆与小鸟进行了比较。 我们通过它们的羽毛来识别记忆，但是有时候，如果它们开始在我们的颅骨细胞中扑动，我们很难获得它们。  16世纪的耶稣会耶稣会士Matteo Ricci写道“记忆的殿堂”，我们在其中漫步，穿过各种房间和走廊，寻找过去的宝藏。 现代的记忆理论通常缺乏想象力，但更详尽，并且旨在从隐喻向机制的过渡。 我个人最喜欢的是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Pentti Canerva</a>在1980年代获得的数学模型，他现在在伯克利的红木理论神经科学中心工作。 他提出了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">稀疏分布式内存</a>的想法，我将其称为SDM。 它成功地应用了高维空间的惊人几何形状。 <br><br> 想象一个三维的立方体。 如果我们假设边的长度等于测量单位，则可以用三个二进制数的矢量表示八个矢量，从 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-87"><span class="MJXp-mn" id="MJXp-Span-88"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-15"> 000 </script> 和结束 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-89"><span class="MJXp-mn" id="MJXp-Span-90"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">111</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-16"> 111 </script>  。 在任何一个顶点上，更改向量的单个位都会使我们到达最接近的顶点。 更改两位将我们移到下一个最近的邻居，而替换所有三个位将导致立方体的相对角-到达最远的顶点。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ji/w0/zm/jiw0zmihd76v1dliq5ocpkmr7a0.png"></div><br> 三维立方体的工作方式类似- <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-91"><span class="MJXp-mn" id="MJXp-Span-92"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">16</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-17-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-17"> 16 </script> 顶点由包含二进制数字的所有组合的向量表示，从开始 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-93"><span class="MJXp-mn" id="MJXp-Span-94"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-18-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-18"> 0000 </script> 和结束 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-95"><span class="MJXp-mn" id="MJXp-Span-96"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1111</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-19"> 1111 </script>  。 该描述实际上被概括为 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-97"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-98"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ñ</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-20-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-20"> N </script> 每个顶点具有的尺寸 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-99"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-100"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ñ</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-21-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-21"> N </script> 位坐标向量。 如果我们根据曼哈顿度量标准来测量距离-始终沿着立方体的边缘移动而绝不沿着对角线切割-那么任何两个向量之间的距离就是两个坐标向量不同的位置数（也称为汉明距离）。  （对于异或，通常使用符号，有时也称为<em>bun</em> 。它将XOR操作显示为二进制加模2。Kanerva倾向于使用*或⊗，因为XOR在高维计算中的作用更像是乘法而不是加法。我决定通过使用符号＆veebar;来摆脱这种矛盾；这是逻辑学家之间熟悉的XOR替代写法。这是对∨-符号的修改，包括OR。在Julia程序中它也是XOR符号是很方便的。 距离测量是一位，距离计算是二进制异或运算符（XOR，＆veebar;）的任务，它为我们提供了不同位的值 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-101"><span class="MJXp-mn" id="MJXp-Span-102"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1个</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-22-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-22"> 1 </script>  ，并且对于相同的对-值 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-103"><span class="MJXp-mn" id="MJXp-Span-104"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-23-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-23"> 0 </script>  ： <br><br><pre> <code class="hljs 1c"><span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-meta"><span class="hljs-meta">&amp;veebar; 0 = 0 0 &amp;veebar; 1 = 1 1 &amp;veebar; 0 = 1 1 &amp;veebar; 1 = 0</span></span></code> </pre> <br>  Julia上用于测量顶点之间距离的函数将XOR函数应用于两个坐标矢量，并作为结果返回数量 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-105"><span class="MJXp-mn" id="MJXp-Span-106"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1个</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-24-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-24"> 1 </script>  。 <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">distance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(u, v)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">w</span></span></span><span class="hljs-function"> = </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">u</span></span></span><span class="hljs-function"> &amp;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">veebar</span></span></span><span class="hljs-function">; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">v</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">return</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">count_ones</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(w)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre> <br> 什么时候 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-107"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-108"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ñ</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-25-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-25"> N </script> 变得足够大，出现一些奇怪的属性 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-109"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-110"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ñ</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-26-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-26"> N </script>  -立方体。 考虑一下 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-111"><span class="MJXp-mn" id="MJXp-Span-112"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-27-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-27"> 1000 </script> 具有的三维立方体 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-113"><span class="MJXp-msubsup" id="MJXp-Span-114"><span class="MJXp-mn" id="MJXp-Span-115" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-116" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-117"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-28-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-28"> 2 ^ {1000} </script> 高峰。 如果我们随机选择它的两个顶点，那么它们之间的预期距离是多少？ 尽管这是一个有关距离的问题，但是我们可以在不深入了解几何的情况下回答它-这只是计算区分两个二进制矢量的位置的任务。 对于随机向量，每个位可能相等 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-118"><span class="MJXp-mn" id="MJXp-Span-119"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-29-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-29"> 0 </script> 或 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-120"><span class="MJXp-mn" id="MJXp-Span-121"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1个</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-30-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-30"> 1 </script> 因此，期望向量在位位置的一半上有所不同。 如果是 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-122"><span class="MJXp-mn" id="MJXp-Span-123"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-31-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-31"> 1000 </script> 位向量标准距离为 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-124"><span class="MJXp-mn" id="MJXp-Span-125"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">500</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-32-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-32"> 500 </script> 位。 这个结果并不令我们感到惊讶。 但是，值得注意的是，向量之间的所有距离都在平均值500附近紧密累积。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/d7/yv/cd/d7yvcdznrtlsgollbjvqf113jak.png"></div><br> 如果是 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-126"><span class="MJXp-mn" id="MJXp-Span-127"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-33-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-33"> 1000 </script> 位向量，几乎所有随机选择的对都与 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-128"><span class="MJXp-mn" id="MJXp-Span-129"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">450</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-34-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-34"> 450 </script> 之前 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-130"><span class="MJXp-mn" id="MJXp-Span-131"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">550</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-35-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-35"> 550 </script> 一点。 在一亿个随机对的样本中<em>（见上图），</em>没有一个比 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-132"><span class="MJXp-mn" id="MJXp-Span-133"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">400</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-36-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-36"> 400 </script> 一点或更远 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-134"><span class="MJXp-mn" id="MJXp-Span-135"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">600</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-37-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-37"> 600 </script> 一点。 在低分辨率空间中，我们的生活没有任何准备让我们为这样的平均距离概率积累做好准备。 在地球上，当几乎所有人都在我们几千公里之内时，我们可以找到一个完全孤独的地方。 但是，没有办法重新分配地球人口，以使<em>每个人都</em>同时处于这种状态。 但是在 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-136"><span class="MJXp-mn" id="MJXp-Span-137"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-38-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-38"> 1000 </script> 维空间的情况就是这样。 <br><br> 不用说，很难想象 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-138"><span class="MJXp-mn" id="MJXp-Span-139"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-39-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-39"> 1000 </script> 维立方体，但是至少对于五个维的示例，我们可以对几何有一点直观的了解。 下表是单位维度的五维立方体中的所有顶点坐标的表，根据距起点的汉明距离进行排列 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-140"><span class="MJXp-mn" id="MJXp-Span-141"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">00 </font></font></span><span class="MJXp-mo" id="MJXp-Span-142" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></span><span class="MJXp-mn" id="MJXp-Span-143"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-40-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-40"> 00,000 </script>  。 大多数峰值（32个中的20个）位于中等距离-2或3位。 该表格在任何其他起点处都具有相同的形状。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/bc/hj/yd/bchjydq4whfiksudz4grybvi7uy.png"></div><br> 严重反对所有这些讨论。 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-144"><span class="MJXp-mn" id="MJXp-Span-145"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-41-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-41"> 1000 </script>  -三维立方体是我们永远都无法建立这样的东西； 宇宙中没有足够的原子来构成 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-146"><span class="MJXp-msubsup" id="MJXp-Span-147"><span class="MJXp-mn" id="MJXp-Span-148" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-149" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-150"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-42-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-42"> 2 ^ {1000} </script> 零件。 但是Kanerva指出，我们需要空间来仅存储我们要存储的那些元素。 例如，我们可以设计用于随机抽样的设备 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-151"><span class="MJXp-msubsup" id="MJXp-Span-152"><span class="MJXp-mn" id="MJXp-Span-153" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 </font></font></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-154" style="vertical-align: 0.5em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-43-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-43"> 10 ^ 8 </script> 顶点（每个都有 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-155"><span class="MJXp-mn" id="MJXp-Span-156"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-44-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-44"> 1000 </script> 位地址），并将多维数据集的其余部分留给未完成的虚幻基础架构。  Kanerva称呼存在于“硬件” <em>硬单元（硬位置）</em>中的顶点的子集。 许多 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-157"><span class="MJXp-msubsup" id="MJXp-Span-158"><span class="MJXp-mn" id="MJXp-Span-159" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 </font></font></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-160" style="vertical-align: 0.5em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">8</font></font></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-45-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-45"> 10 ^ 8 </script> 随机实体单元仍将显示与完整立方体相同的压缩距离分布； 这正是上表中显示的内容。 <br><br> 大型多维数据集中每个顶点的相对隔离为我们提供了稀疏分布式内存的一个可能优势的暗示：存储的元素具有足够的空间，并且可以分布在广阔的区域中，而不会干扰其邻居。 这确实是SDM的突出功能，但还有其他功能。 <br><br><hr><br> 在传统的计算机内存中，地址和存储的数据元素是一对一映射的。 地址是固定范围的序数整数 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-161"><span class="MJXp-mo" id="MJXp-Span-162" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[ </font></font></span><span class="MJXp-mn" id="MJXp-Span-163"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 </font></font></span><span class="MJXp-mrow" id="MJXp-Span-164"><span class="MJXp-mo" id="MJXp-Span-165" style="margin-left: 0.278em; margin-right: 0.278em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></span></span><span class="MJXp-msubsup" id="MJXp-Span-166"><span class="MJXp-mn" id="MJXp-Span-167" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-168" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-169"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">64</font></font></span></span></span><span class="MJXp-mrow" id="MJXp-Span-170"><span class="MJXp-mo" id="MJXp-Span-171" style="margin-left: 0.278em; margin-right: 0.278em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）</font></font></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-46-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-46"> [0，2 ^ {64}）</script>  。 此范围内的每个整数定义内存中的单个单独位置，并且每个位置都与一个地址正好关联。 另外，在每个位置一次只存储一个值。 写入新值时，旧值将被覆盖。 <br><br>  SDM违反了所有这些规则。 它拥有巨大的地址空间-不少于 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-172"><span class="MJXp-msubsup" id="MJXp-Span-173"><span class="MJXp-mn" id="MJXp-Span-174" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-175" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-176"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-47-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-47"> 2 ^ {1000} </script>  -但是这些地方中只有很小一部分是随机存在的实体； 这就是为什么内存被称为<em>稀疏</em> 。 一条信息并不仅仅存储在内存中的一个地方； 许多副本分布在该区域中-因此它已<em>分布</em> 。 此外，在每个单独的地址中，可以同时存储几个数据元素。 即，信息被散布在广阔的区域中，并被压缩为一个点。 这种架构还模糊了存储器地址和存储器内容之间的区别。 在许多情况下，存储的位模式用作其自己的地址。 最终，存储器可以响应部分或近似地址，并且很有可能找到正确的项目。 传统内存是“精确匹配机制”，而SDM是“最佳匹配机制”，它返回与请求的最相似的元素。 <br><br>  Kanerva在其1988年的著作中对稀疏分布式内存的详细定量分析 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-177"><span class="MJXp-mn" id="MJXp-Span-178"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-48-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-48"> 1000 </script> 测量和 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-179"><span class="MJXp-mn" id="MJXp-Span-180"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-181" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></span><span class="MJXp-mn" id="MJXp-Span-182"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">000 </font></font></span><span class="MJXp-mo" id="MJXp-Span-183" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></span><span class="MJXp-mn" id="MJXp-Span-184"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-49-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-49"> 1,000,000 </script> 固体细胞。 固态单元是从整个空间中随机选择的。 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-185"><span class="MJXp-msubsup" id="MJXp-Span-186"><span class="MJXp-mn" id="MJXp-Span-187" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-188" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-189"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-50-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-50"> 2 ^ {1000} </script> 可能的地址向量。 每个固态电池都有多个存储空间 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-190"><span class="MJXp-mn" id="MJXp-Span-191"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-51-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-51"> 1000 </script> 位向量。 内存整体设计用于至少存储 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-192"><span class="MJXp-mn" id="MJXp-Span-193"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 </font></font></span><span class="MJXp-mo" id="MJXp-Span-194" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></span><span class="MJXp-mn" id="MJXp-Span-195"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-52-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-52"> 10,000 </script> 独特的模式。 下面，我将这种记忆视为典型的SDM模型，尽管事实上，按照哺乳动物的标准，这种记忆很小，并且在更新的工作中，Kanerva强调至少包含 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-196"><span class="MJXp-mn" id="MJXp-Span-197"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 </font></font></span><span class="MJXp-mo" id="MJXp-Span-198" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></span><span class="MJXp-mn" id="MJXp-Span-199"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-53-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-53"> 10,000 </script> 测量。 <br><br> 这就是内存在简单的计算机实现中的工作方式。  <code>store(X)</code>命令将向量写入内存 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-200"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-201"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-54-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-54"> X </script>  ，同时考虑地址和内容。 价值 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-202"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-203"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-55-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-55"> X </script> 储存在一定距离内的所有固态电池中 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-204"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-205"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-56-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-56"> X </script>  。 在规范模型中，此距离为451位。 它定义了一个“访问圈”，旨在将自身大致合并 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-206"><span class="MJXp-mn" id="MJXp-Span-207"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-57-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-57"> 1000 </script> 固体细胞 换句话说，每个向量大约存储在 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-208"><span class="MJXp-mn" id="MJXp-Span-209"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mrow" id="MJXp-Span-210"><span class="MJXp-mo" id="MJXp-Span-211" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mn" id="MJXp-Span-212"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-58-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-58"> 1/1000 </script> 一百万个固态细胞之一。 <br><br> 同样重要的是要注意存储的项目 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-213"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-214"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-59-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-59"> X </script> 不一定要选择 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-215"><span class="MJXp-mn" id="MJXp-Span-216"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mo" id="MJXp-Span-217" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></span><span class="MJXp-mn" id="MJXp-Span-218"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">000 </font></font></span><span class="MJXp-mo" id="MJXp-Span-219" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></span><span class="MJXp-mn" id="MJXp-Span-220"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-60-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-60"> 1,000,000 </script> 作为固态单元地址的二进制向量。 相反。 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-221"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-222"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-61-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-61"> X </script> 可能是 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-223"><span class="MJXp-msubsup" id="MJXp-Span-224"><span class="MJXp-mn" id="MJXp-Span-225" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2 </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-226" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-227"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-62-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-62"> 2 ^ {1000} </script> 可能的二进制模式。 <br><br> 假设已经将一千份副本写入SDM <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-228"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-229"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-63-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-63"> X </script>  ，之后会有一个新元素 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-230"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-231"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ÿ</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-64-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-64"> Y </script>  ，还需要将其存储在自己的数千个实体单元中。 在这两个集合之间可能有一个相交点- <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-232"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-233"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-65-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-65"> X </script> 和 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-234"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-235"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ÿ</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-66-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-66"> Y </script>  。 新值不会覆盖或替换前一个值； 两个值都被保存。 当内存已满时 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-236"><span class="MJXp-mn" id="MJXp-Span-237"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 </font></font></span><span class="MJXp-mo" id="MJXp-Span-238" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></span><span class="MJXp-mn" id="MJXp-Span-239"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-67-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-67"> 10,000 </script> 他们每个人都被保存 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-240"><span class="MJXp-mn" id="MJXp-Span-241"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-68-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-68"> 1000 </script> 时间，并且在典型的硬单元格中将存储副本 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-242"><span class="MJXp-mn" id="MJXp-Span-243"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-69-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-69"> 10 </script> 独特的模式。 <br><br> 现在的问题是：我们如何使用这种混合内存？ 特别是，我们如何获得正确的价值 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-244"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-245"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-70-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-70"> X </script> 不影响 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-246"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-247"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ÿ</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-71-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-71"> Y </script> 以及所有其他已累积在一个存储位置的物品？ <br><br> 读取算法将使用高维空间中距离的好奇分布特性。 即使 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-248"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-249"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-72-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-72"> X </script> 和 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-250"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-251"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ÿ</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-73-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-73"> Y </script> 是距离最近的邻居 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-252"><span class="MJXp-mn" id="MJXp-Span-253"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 </font></font></span><span class="MJXp-mo" id="MJXp-Span-254" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></span><span class="MJXp-mn" id="MJXp-Span-255"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-74-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-74"> 10,000 </script> 存储的模式，它们很可能相差420或430位； 因此，存储两个值的实体单元的数量非常少-通常为四个，五个或六个。 同样的情况适用于与 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-256"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-257"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-75-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-75"> X </script>  。 它们有成千上万种，但是在访问圈内，有影响力的模式中没有一种出现在多个副本中 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-258"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-259"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-76-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-76"> X </script>  。 <br><br>  <code>fetch(X)</code>命令应返回先前由<code>store(X)</code>命令写入的值。 重建值的第一步是收集存储在以451为中心的451位访问圈内的所有信息 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-260"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-261"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-77-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-77"> X </script>  。 由于 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-262"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-263"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-78-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-78"> X </script> 是以前在所有这些地方记录的，我们可以确定我们会收到 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-264"><span class="MJXp-mn" id="MJXp-Span-265"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-79-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-79"> 1000 </script> 他的副本。 我们还将获得 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-266"><span class="MJXp-mn" id="MJXp-Span-267"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 </font></font></span><span class="MJXp-mo" id="MJXp-Span-268" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></span><span class="MJXp-mn" id="MJXp-Span-269"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-80-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-80"> 10,000 </script> 存储在访问圆与圆相交的地方的<em>其他</em>向量的副本 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-270"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-271"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-81-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-81"> X </script>  。 但是，由于交点很小，因此这些向量中的每一个仅存在几个副本。 然后通常每个人 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-272"><span class="MJXp-mn" id="MJXp-Span-273"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-82-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-82"> 1000 </script> 同样有可能 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-274"><span class="MJXp-mn" id="MJXp-Span-275"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-83-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-83"> 0 </script> 或 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-276"><span class="MJXp-mn" id="MJXp-Span-277"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1个</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-84-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-84"> 1 </script>  。 如果我们将多数原理函数应用于在每个位位置收集的所有数据，则结果将由 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-278"><span class="MJXp-mn" id="MJXp-Span-279"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-85-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-85"> 1000 </script> 副本 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-280"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-281"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-86-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-86"> X </script>  。 变得与众不同的可能性 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-282"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-283"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-87-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-87"> X </script> 结果大致相等 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-284"><span class="MJXp-msubsup" id="MJXp-Span-285"><span class="MJXp-mn" id="MJXp-Span-286" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-287" style="vertical-align: 0.5em;"><span class="MJXp-mo" id="MJXp-Span-288"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mn" id="MJXp-Span-289"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">19</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-88-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-88"> 10 ^ {-19} </script>  。 <br><br> 下面以每个20位的五个数据向量的小示例为例，详细说明多数原则程序。 输出将是一个不同的向量，其每个位反映数据向量中的大多数对应位。  （如果数据向量的数量为偶数，则通过随机选择允许“绘制” <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-290"><span class="MJXp-mn" id="MJXp-Span-291"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-89-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-89"> 0 </script> 或 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-292"><span class="MJXp-mn" id="MJXp-Span-293"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1个</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-90-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-90"> 1 </script>  。）下面显示的替代读写方案拒绝单独存储所有模式。 相反，它存储位数。 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-294"><span class="MJXp-mn" id="MJXp-Span-295"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-91-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-91"> 0 </script> 和 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-296"><span class="MJXp-mn" id="MJXp-Span-297"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1个</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-92-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-92"> 1 </script> 在每个位置。 固态电池有 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-298"><span class="MJXp-mn" id="MJXp-Span-299"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-93-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-93"> 1000 </script> 位计数器由全零初始化。 将模式写入到位后，每个位计数器都会递增 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-300"><span class="MJXp-mn" id="MJXp-Span-301"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1个</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-94-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-94"> 1 </script> 或减少 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-302"><span class="MJXp-mn" id="MJXp-Span-303"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-95-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-95"> 0 </script>  。 读出算法只是查看每个位计数器的符号，然后返回 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-304"><span class="MJXp-mn" id="MJXp-Span-305"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1个</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-96-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-96"> 1 </script> 为正值， <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-306"><span class="MJXp-mn" id="MJXp-Span-307"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-97-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-97"> 0 </script> 当计数器位相等时为负值和随机值 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-308"><span class="MJXp-mn" id="MJXp-Span-309"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-98-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-98"> 0 </script>  。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f91/b82/967/f91b82967ddba26afa8e57373cc6091c.png"></div><br> 这两种存储方案可得出相同的结果。 <br><br><hr><br> 在计算方面，此版本的稀疏分布式内存看起来像是经过深思熟虑的笑话。 要记住 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-310"><span class="MJXp-mn" id="MJXp-Span-311"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 </font></font></span><span class="MJXp-mo" id="MJXp-Span-312" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></span><span class="MJXp-mn" id="MJXp-Span-313"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-99-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-99"> 10,000 </script> 元素，我们需要一百万个实体单元，其中每个模式将存储一千个冗余副本。 要从内存中仅检索一项，我们通过 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-314"><span class="MJXp-mn" id="MJXp-Span-315"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">11 </font></font></span><span class="MJXp-mo" id="MJXp-Span-316" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></span><span class="MJXp-mn" id="MJXp-Span-317"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-100-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-100"> 11,000 </script> 保存了模式并应用多数原则机制来解开它们。 而所有这些操作都是借助一堆杂技技巧来完成的，仅是获得我们已经拥有的向量。 传统内存的随机性要差得多：写和读都可以访问一个地方。 <br><br> 但是SDM可以做传统存储器无法做到的事情。 特别是，它可以基于部分或近似数据提取信息。 假设一个向量 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-318"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-319"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ž</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-101-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-101"> Z </script> 是损坏的版本 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-320"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-321"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-102-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-102"> X </script> 其中发生了变化 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-322"><span class="MJXp-mn" id="MJXp-Span-323"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-103-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-103"> 100 </script> 来自 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-324"><span class="MJXp-mn" id="MJXp-Span-325"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-104-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-104"> 1000 </script> 向量。 由于两个向量相似，因此<code>fetch(Z)</code>命令将访问许多相同的存储位置 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-326"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-327"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-105-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-105"> X </script>  。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 汉明距离为100，我们可以预期 </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-328"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-329"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-106-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-106"> X </script> 和 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-330"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-331"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将被大约300个实体单元共享。</font><font style="vertical-align: inherit;">多亏了这个大的交集，向量才返回</font><font style="vertical-align: inherit;">（我们称它为</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-107-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-107">Z</script><font style="vertical-align: inherit;"></font><code>fetch(Z)</code><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-332"><span class="MJXp-msubsup" id="MJXp-Span-333"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-334" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-335" style="vertical-align: 0.5em;"><span class="MJXp-mi" id="MJXp-Span-336"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">'</font></font></span></span></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）将更接近</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-108-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-108">Z^{\prime}</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-337"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-338"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">是什么</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-109-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-109"> X </script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-339"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-340"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ž</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-110-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-110">Z</script>  。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们可以与</font></font><code>fetch(Z′)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将返回结果</font><font style="vertical-align: inherit;">的团队重复此过程</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-341"><span class="MJXp-msubsup" id="MJXp-Span-342"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-343" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在Z </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-344" style="vertical-align: 0.5em;"><span class="MJXp-mi" id="MJXp-Span-345"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">“ </font></font></span><span class="MJXp-mi" id="MJXp-Span-346"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">”</font></font></span></span></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，但更接近</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-111-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-111">Z^{\prime\prime}</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-347"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-348"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-112-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-112"> X </script>  。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 只需几次迭代，该过程即可达到 </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-349"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-350"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-113-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-113"> X </script>  。 <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kanerva表明，如果初始模式离目标不太远，则递归读操作的收敛序列将几乎可以完全确定地成功。换句话说，存在一个临界半径：从临界圆内的某个位置开始的任何内存检查都将几乎完全收敛到中心，并且很快就会完成。还原存储在关键圆之外的元素的尝试将失败，因为递归调用过程将移动到平均距离。 Kanerv的分析表明，对于标准SDM，临界半径为209位。换句话说，如果我们知道大约80％的位，则可以重新创建整个模式。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 下图说明了源信号而非目标信号的递归存储器序列的演变。 </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-351"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-352"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-114-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-114"> X </script> 在 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-353"><span class="MJXp-mn" id="MJXp-Span-354"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 </font></font></span><span class="MJXp-mo" id="MJXp-Span-355" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></span><span class="MJXp-mn" id="MJXp-Span-356"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">5 </font></font></span><span class="MJXp-mo" id="MJXp-Span-357" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></span><span class="MJXp-mn" id="MJXp-Span-358"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10 </font></font></span><span class="MJXp-mo" id="MJXp-Span-359" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></span><span class="MJXp-mn" id="MJXp-Span-360"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">15 </font></font></span><span class="MJXp-mo" id="MJXp-Span-361" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... </font></font></span><span class="MJXp-mn" id="MJXp-Span-362"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-115-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-115">0, 5, 10, 15 \dots 1000</script>  。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在此实验中，所有序列均以距离开始 </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-363"><span class="MJXp-mn" id="MJXp-Span-364"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">205</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以下</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-116-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-116">205</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-365"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-366"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-117-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-117"> X </script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-367"><span class="MJXp-mn" id="MJXp-Span-368"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10次</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或更少的迭代</font><em><font style="vertical-align: inherit;">（蓝色轨迹）</font></em><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">从更大的初始距离开始的所有序列漫无目的地在广阔的空白空间中徘徊</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-118-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-118"> 10 </script><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-369"><span class="MJXp-mn" id="MJXp-Span-370"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">维多维数据集，可从任何地方保留大约500位。</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-119-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-119">1000</script><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ks/ox/sa/ksoxsaesutehnsikhkl5ofspzze.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从收敛路径到发散路径的过渡并不十分清楚，这在下面显示的破损图中很明显。</font><font style="vertical-align: inherit;">在这里，我们放大查看以偏移量开始的轨迹的命运</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-371"><span class="MJXp-mn" id="MJXp-Span-372"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">175 </font></font></span><span class="MJXp-mo" id="MJXp-Span-373" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></span><span class="MJXp-mn" id="MJXp-Span-374"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">176 </font></font></span><span class="MJXp-mo" id="MJXp-Span-375" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></span><span class="MJXp-mn" id="MJXp-Span-376"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">177 </font></font></span><span class="MJXp-mo" id="MJXp-Span-377" style="margin-left: 0em; margin-right: 0.222em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></span><span class="MJXp-mo" id="MJXp-Span-378" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">... </font></font></span><span class="MJXp-mn" id="MJXp-Span-379"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">225</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">位。</font><font style="vertical-align: inherit;">目标209位以内的所有起点均以蓝色表示；</font><font style="vertical-align: inherit;">从更长的距离开始是橙色的。</font><font style="vertical-align: inherit;">大多数蓝色路径会聚，迅速移至零距离，而大多数橙色路径则不会。</font><font style="vertical-align: inherit;">但是，接近临界距离时，有许多例外情况。</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-120-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-120">175, 176, 177, \dots 225</script><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lm/aj/rs/lmajrsq2z4z_tlzg5igefbjhwbu.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下图显示了距目标的初始距离如何影响收敛到正确的存储器地址的可能性的另一幅图。</font><font style="vertical-align: inherit;">距离</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-380"><span class="MJXp-mn" id="MJXp-Span-381"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">170</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-121-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-121">170</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">位几乎可以成功完成所有尝试；</font><font style="vertical-align: inherit;">在</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-382"><span class="MJXp-mn" id="MJXp-Span-383"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">240</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-122-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-122">240</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">几乎都不成功。</font><font style="vertical-align: inherit;">似乎交点（成功和失败的可能性均相等）大约在</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-384"><span class="MJXp-mn" id="MJXp-Span-385"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">203</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-123-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-123">203</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">位，稍低于Kanerva的结果，等于</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-386"><span class="MJXp-mn" id="MJXp-Span-387"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">209</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-124-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-124">209</script>  。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> （这种差异并没有什么神秘之处。在Kanerv的计算中，访问圈应该严格限制 </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-388"><span class="MJXp-mn" id="MJXp-Span-389"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000个</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-125-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-125">1000</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">固体细胞。</font><font style="vertical-align: inherit;">我的实验中包括该距离内的所有固体细胞。</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-390"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-391"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[R </font></font></span><span class="MJXp-mo" id="MJXp-Span-392" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">≤ </font></font></span><span class="MJXp-mn" id="MJXp-Span-393"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">451</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-126-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-126">r \le 451</script>  ;<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 平均那里 </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-394"><span class="MJXp-mn" id="MJXp-Span-395"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1070个</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-127-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-127">1070</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这样的地方。）</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ei/74/gc/ei74gcngwrfwrae1iwfle95ybg4.png"></div><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从部分信息中重建记忆的能力是人类生活中熟悉的元素。您在电视节目中注意到一个演员，并且了解到您曾经看过他，但不记得在哪里。几分钟后，它突然降临在你身上：这是</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">唐顿庄园的</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">贝茨先生</font><font style="vertical-align: inherit;">，但没有管家服装。高中毕业生会议：在房间另一侧看着一个秃顶的绅士，你能认出他是一个只在运动短裤时才认识的朋友吗？有时需要大量的精力来填补空白。我已经</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">写</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">了我自己的莫名其妙的“盲点”，以纪念紫藤的生长，我只能耐心地翻阅一类假气味：绣球，马鞭草和连翘来命名。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我们从不完整或嘈杂的输入中恢复记忆的能力是否可以像记住高维向量的递归过程那样起作用？这将是一个有吸引力的假设，但有理由对此保持警惕。例如，大脑似乎能够从更多微弱的信号中提取含义。我不需要听“第五交响曲”的五分之四来识别它，前四个音符就足够了。树木中闪烁的色彩使您立即回想起相应的鸟类-红衣主教，蓝鸟，黄雀。丝丝的粉笔味带我呼吸回到昏昏欲睡的教室，在教室里我画了半天。此类记忆是由代表它们的信息的极小部分触发的，远远少于80％。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kanerva提到了可以使用SDM建模的人类记忆的另一个功能：“舌尖上旋转”现象，其本质是您知道自己知道一些东西，尽管不能立即调用它。这种感觉相当神秘：如果找不到所需的内容，怎么知道它们全部存储在大脑中？ SDM的递归调用过程为我们提供了可能的答案。当从内存中检索到的连续模式彼此之间越来越近时，我们可以合理地确定它们甚至会在达到目标之前收敛。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">试图从记忆中提取一个顽固的事实时，许多人发现不断敲开同一扇门并不是明智的策略。而不是要求立即回答-命令您的大脑-通常最好将任务搁置一旁，散散步或小睡一下；答案可能好像是不请自来的。 SDM模型可以解释这种现象吗？也许至少是部分的。如果召回的模式的序列不收敛，则对其进一步的研究可能会徒劳无功。如果从存储空间中的相邻点重新开始，则可能会得到更好的结果。但是这里有一个谜：如何找到前景更好的新起点？您可能会认为，随机替换输入模式中的一些位非常简单，希望结果，他将更接近目标，但这的可能性很小。如果向量在</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-396"><span class="MJXp-mn" id="MJXp-Span-397"><font style="vertical-align: inherit;"></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">然后距离目标</font><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-396"><span class="MJXp-mn" id="MJXp-Span-397"><font style="vertical-align: inherit;"> 250</font></span></span></span><font style="vertical-align: inherit;">位</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-128-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-128">250</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-398"><span class="MJXp-mn" id="MJXp-Span-399"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">750</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">位是真实的（但我们不知道是</font><em><font style="vertical-align: inherit;">哪</font></em><font style="vertical-align: inherit;">一个</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-129-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-129">750</script><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-400"><span class="MJXp-mn" id="MJXp-Span-401"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">750</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">位）；</font><font style="vertical-align: inherit;">任何随机变化，我们都有</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-130-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-130">750</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-402"><span class="MJXp-mn" id="MJXp-Span-403"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">3 </font></font></span><span class="MJXp-mrow" id="MJXp-Span-404"><span class="MJXp-mo" id="MJXp-Span-405" style="margin-left: 0.111em; margin-right: 0.111em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">/</font></font></span></span><span class="MJXp-mn" id="MJXp-Span-406"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 4</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">接近和离开更进一步。</font><font style="vertical-align: inherit;">要取得进步，您需要知道朝哪个方向移动以及朝哪个方向移动。</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-131-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-131">3/4</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-407"><span class="MJXp-mn" id="MJXp-Span-408"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">维空间是一个难题。</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-132-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-132">1000</script><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">SDM体系结构的一个方面是，它似乎与重复或侦听内存的效果相对应。如果您多次重复这首诗或练习演奏一首音乐，您可以期望将来您会更轻松地记住它。计算模型应表现出相似的训练效果。但这在传统的计算机内存中是不可能的：在同一地址多次重写相同的值没有好处。另一方面，在SDM中，模式的每次重复都会向模式访问圈内的所有实体单元添加另一个副本。结果，相交图案的影响较小，并且临界召回半径增大。该效果具有显着的效果：当写入该模式的单个副本的内存时，临界半径从大约</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-409"><span class="MJXp-mn" id="MJXp-Span-410"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">200</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">位以上</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-133-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-133">200</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-411"><span class="MJXp-mn" id="MJXp-Span-412"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">300</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-134-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-134">300</script>  。 <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">同样，播放一种模式会使恢复其他模式变得困难。</font><font style="vertical-align: inherit;">这让人想起什么时候忘记了，当一个活跃的烙印图案填满其邻居并占领其部分领土时。</font><font style="vertical-align: inherit;">这种影响也极大地影响了SDM，以至于看起来甚至都不切实际。</font><font style="vertical-align: inherit;">看起来，存储了八到十次的向量会垄断大部分内存；</font><font style="vertical-align: inherit;">他变得痴迷，所有问题的答案。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">稀疏分布式内存的一个重要优点是它可以抵抗硬件故障或错误。</font><font style="vertical-align: inherit;">如果大脑中单个神经元的丢失在我的记忆中留下了一个洞，而我无法识别字母</font><em><font style="vertical-align: inherit;">g，</font></em><font style="vertical-align: inherit;">我会感到沮丧</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或记住如何系鞋带。</font><font style="vertical-align: inherit;">SDM不受此脆弱性的影响。</font><font style="vertical-align: inherit;">当每个存储的模式都有一千个副本时，没有一个地方很重要。</font><font style="vertical-align: inherit;">实际上，您可以擦除存储在60％的固态单元中的所有信息，并且仍然可以完美调用</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-413"><span class="MJXp-mn" id="MJXp-Span-414"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10000</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，如果我们假设我们正在传输一个绝对准确的地址作为信号。</font><font style="vertical-align: inherit;">对于部分信号，临界半径会随着丢失点的增加而缩小。</font><font style="vertical-align: inherit;">销毁60％的地点后，</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-135-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-135">10000</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-415"><span class="MJXp-mn" id="MJXp-Span-416"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">200 </font></font></span><span class="MJXp-mo" id="MJXp-Span-417" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">+</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">位左右</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-136-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-136">200+</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-418"><span class="MJXp-mn" id="MJXp-Span-419"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">150</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">位。在销毁80％的位置后，内存严重受损，但并未销毁。</font><font style="vertical-align: inherit;">漂浮在云中怎么样？我们能否在稀疏的分布式内存的草地上闲逛，从一种存储模式转移到另一种存储模式？我将回到这个问题。</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-137-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-137">150</script><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">以上大部分内容是在几周前写的。那时，我读到了各种相互竞争的记忆理论，并与西蒙斯研究所的同事们讨论了它们的优点。我写下了关于该主题的想法，但由于持续的怀疑而推迟了它们的发表：我是否正确地理解了稀疏分布式内存的数学原理？现在我很高兴我不着急。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">脑与计算计划于五月结束。它的参与者离开了：我回到了新英格兰，鼠尾草和迷迭香是小盆栽，而不是茂密的灌木丛挂在小径上。我早晨走到伯克利校园，每天反思记忆和学习性质的机会变成了存储在我脑海中某个地方的“记录”（但是，我仍然不知道该在哪里寻找它们）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，我没有放弃搜索。</font><font style="vertical-align: inherit;">离开伯克利后，我继续阅读有关记忆的理论。</font><font style="vertical-align: inherit;">我还编写了程序来研究Pentti Canerva的稀疏分布式内存及其对“超空间计算”的更广泛的理解。</font><font style="vertical-align: inherit;">即使这个项目无法向我揭示人类记忆的秘密，它也一定会教给我一些有关高维空间中导航的数学和计算艺术的知识。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">据我了解，下图显示了实现SDM的“正确”方法。</font><font style="vertical-align: inherit;">主要元素是交叉矩阵，其中各行对应于固态存储单元，各列承载模拟输入矢量各个位的信号。</font><font style="vertical-align: inherit;">规范内存中有一百万行，每行都是随机分配的</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-420"><span class="MJXp-mn" id="MJXp-Span-421"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">位地址，以及</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-138-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-138">1000</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-422"><span class="MJXp-mn" id="MJXp-Span-423"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">列 </font><font style="vertical-align: inherit;">该演示版本包含20行8列。</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-139-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-139">1000</script><font style="vertical-align: inherit;"></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/hm/bf/hq/hmbfhq9wergzhrrb1fskxsurpsk.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图中所示的过程包括将一个输入向量存储到空存储器中。</font><font style="vertical-align: inherit;">同时将八个输入位与实体单元的所有20个地址进行比较。</font><font style="vertical-align: inherit;">当输入位和地址位重合时（零与零或一与一），我们在行与列的交点处加一个点。</font><font style="vertical-align: inherit;">然后，我们计算每行中的点数，如果数量等于或超过阈值，则将输入向量写入与此行关联的寄存器中</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（蓝色字段）</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在我们的示例中，阈值为5，在20个地址中的8个中，至少有5个匹配项。</font></font>在 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-424"><span class="MJXp-mn" id="MJXp-Span-425"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">位内存阈值将相等</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-140-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-140">1000</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-426"><span class="MJXp-mn" id="MJXp-Span-427"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">451</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-141-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-141">451</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，将仅选择所有寄存器的千分之一。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这种架构的神奇之处在于，所有位比较（在规范模型中有十亿个）都是同时进行的。因此，用于读取和写入的访问时间不取决于实体单元的数量，并且可以非常小。这种通用安排被称为关联存储器或内容寻址存储器，用于某些计算领域，例如启用大型强子对撞机中的粒子检测器并通过Internet上的路由器传输数据包。电路图可以与某些大脑结构相关联。 Kanerva指出，小脑与这种基质非常相似。线是扁平的，扇形的浦肯野细胞，像书页一样收集；柱是平行纤维，延伸穿过所有浦肯野细胞。 （但是，小脑不是哺乳动物的大脑区域，被认为位于认知记忆的位置。）</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">基于这种跨架构构建SDM仿真将是非常不错的。</font><font style="vertical-align: inherit;">不幸的是，我不知道如何在我可以使用的计算机设备上实现它。</font><font style="vertical-align: inherit;">在传统处理器中，无法同时比较所有输入位和硬单元位。</font><font style="vertical-align: inherit;">相反，我必须依次遍历一百万个实体单元，并比较每个位置的数千个位。</font><font style="vertical-align: inherit;">对于存储或从内存中检索的每个元素，这相当于一百万位的比较。</font><font style="vertical-align: inherit;">再加上写入或读取一百万个位（数千个副本）的时间</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-428"><span class="MJXp-mn" id="MJXp-Span-429"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">位向量），您会得到一个相当缓慢的过程。</font><font style="vertical-align: inherit;">这是保存向量的代码：</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-142-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-142">1000</script><font style="vertical-align: inherit;"></font><br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">store</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v::BitVector)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">for</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loc</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">in</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SDM</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">hamming_distance</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(v, loc.address)</span></span></span><span class="hljs-function"> &lt;= </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">r</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">write_to_register</span></span></span><span class="hljs-function">!</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(loc.register, v)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">end</span></span></span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 此实现大约需要一个小时来清点内存 </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-430"><span class="MJXp-mn" id="MJXp-Span-431"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">10,000个</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">记忆模式。</font><font style="vertical-align: inherit;">（可以</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;">在GitHub上找到</font></a><font style="vertical-align: inherit;">Jupyter Notebook形式的完整程序</font><font style="vertical-align: inherit;">。）</font><font style="vertical-align: inherit;">是否有更好的算法在常规硬件上模拟SDM？</font><font style="vertical-align: inherit;">一种可能的策略可以避免在给定向量的访问圈内重复搜索一组实体单元；</font><font style="vertical-align: inherit;">取而代之的是，当将向量首次写入内存时，程序会存储指向存储该向量的数千个位置的指针。</font><font style="vertical-align: inherit;">将来，只要引用相同的向量，该程序就可以</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-143-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-143">10000</script><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-432"><span class="MJXp-mn" id="MJXp-Span-433"><font style="vertical-align: inherit;"></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">保存了</font><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-432"><span class="MJXp-mn" id="MJXp-Span-433"><font style="vertical-align: inherit;"> 1000个</font></span></span></span><font style="vertical-align: inherit;">指针，而不扫描一百万个固态单元格的整个阵列。</font><font style="vertical-align: inherit;">这种缓存方案的代价是需要将所有这些指针存储在其规范的SDM中</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-144-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-144">1000</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-434"><span class="MJXp-mn" id="MJXp-Span-435"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-145-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-145"> 10 </script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">千万 </font><font style="vertical-align: inherit;">这是很真实的，如果您只想存储和检索确切的已知值，那可能是值得的。</font><font style="vertical-align: inherit;">但是考虑一下在递归调用时响应近似内存请求会发生什么</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-436"><span class="MJXp-msubsup" id="MJXp-Span-437"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-438" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-439" style="vertical-align: 0.5em;"><span class="MJXp-mi" id="MJXp-Span-440"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">′</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-146-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-146">Z^{\prime}</script> 和 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-441"><span class="MJXp-msubsup" id="MJXp-Span-442"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-443" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-444" style="vertical-align: 0.5em;"><span class="MJXp-mi" id="MJXp-Span-445"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">′ </font></font></span><span class="MJXp-mi" id="MJXp-Span-446"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">′</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-147-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-147">Z^{\prime\prime}</script> 和 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-447"><span class="MJXp-msubsup" id="MJXp-Span-448"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-449" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Z </font></font></span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-450" style="vertical-align: 0.5em;"><span class="MJXp-mi" id="MJXp-Span-451"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">' </font></font></span><span class="MJXp-mi" id="MJXp-Span-452"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">' </font></font></span><span class="MJXp-mi" id="MJXp-Span-453"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">'</font></font></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-148-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-148">Z^{\prime\prime\prime}</script> 等等。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在缓存中找不到这些中间值，因此仍然需要对所有实体单元进行全面扫描。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">也许有一条更棘手的方法可以解决这一问题。</font><font style="vertical-align: inherit;">Alexander Andoni，Peter Indyk和Ilya Razenstein </font><font style="vertical-align: inherit;">在最近的评论文章“ </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">高维中的近似最近邻居搜索</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ”中提到了一种有趣的技术，称为局部敏感哈希（基于局部的哈希），但是到目前为止，我还不太了解如何使它适应SDM任务。</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">从部分信号中恢复内存的能力是计算模型的一个人为特征。</font><font style="vertical-align: inherit;">也许可以对其进行扩展，以提供一种在脑海中闲逛的合理机制，其中一种思想可以导致下一个思想。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">起初我以为我知道这可能如何工作。</font><font style="vertical-align: inherit;">SDM存储模式</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-454"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-455"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在其周围创建一个吸引区域，在该区域中，从临界半径开始的任何递归内存研究都收敛到</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-149-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-149"> X </script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-456"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-457"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">X</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-150-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-150"> X </script>  。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在 </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-458"><span class="MJXp-mn" id="MJXp-Span-459"><font style="vertical-align: inherit;"></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我可以想象有</font><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-458"><span class="MJXp-mn" id="MJXp-Span-459"><font style="vertical-align: inherit;"> 10,000个</font></span></span></span><font style="vertical-align: inherit;">这样的吸引子，它们如何将存储空间划分为各个模块的矩阵，例如大尺寸的肥皂泡泡沫。每个存储元素的区域占据一个单独的空间，在所有侧面上均被其他区域包围，并与它们邻接，相邻域之间具有清晰的边界。为了支持这一主张，我可以看到，将新内容添加到内存时，吸引区域的平均半径被压缩，就像气泡由于拥挤而被压缩一样。</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-151-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-151">10000</script><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对SDM内部流程的这种构想提出了一种从一个域移到另一个域的简单方法：您需要随机切换向量的足够数量的位，以将其从当前引力移到相邻域，然后应用递归调用算法。重复此过程将随机遍历存储在内存中的许多主题。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">唯一的问题是这种方法行不通。如果您检查它，它实际上会漫无目的地游荡于</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-460"><span class="MJXp-mn" id="MJXp-Span-461"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1000</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">维网格，但我们永远都找不到在那里存储的任何内容。</font><font style="vertical-align: inherit;">整个计划基于对SDM几何形状的错误直观理解。</font><font style="vertical-align: inherit;">所存储的向量及其吸引区域</font><em><font style="vertical-align: inherit;">没有</font></em><font style="vertical-align: inherit;">像肥皂泡那样紧密堆积；</font><font style="vertical-align: inherit;">相反，它们是孤立的星系，悬挂在广阔而自由的宇宙中，彼此之间被巨大的空白空间隔开。</font><font style="vertical-align: inherit;">简短的计算向我们展示了这种情况的真实性质。</font><font style="vertical-align: inherit;">在规范模型中，确定吸引区域的临界半径大约等于</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-152-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-152">1000</script><font style="vertical-align: inherit;"></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-462"><span class="MJXp-mn" id="MJXp-Span-463"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">200</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-153-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-153">200</script>  。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 单个区域的体积（以内部矢量的数量来衡量）为 </font></font><br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-464"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-465">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-466">u</span><span class="MJXp-msubsup" id="MJXp-Span-467"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-468" style="margin-right: 0.05em;">m</span><span class="MJXp-script-box" style="height: 1.86em; vertical-align: -0.64em;"><span class=" MJXp-script"><span><span style="margin-bottom: -0.25em;"><span class="MJXp-mrow" id="MJXp-Span-473"><span class="MJXp-mn" id="MJXp-Span-474">200</span></span></span></span></span><span class=" MJXp-script"><span><span style="margin-top: -0.85em;"><span class="MJXp-mrow" id="MJXp-Span-469"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-470">k</span><span class="MJXp-mo" id="MJXp-Span-471">=</span><span class="MJXp-mn" id="MJXp-Span-472">1</span></span></span></span></span></span></span><span class="MJXp-mrow" id="MJXp-Span-475"><span class="MJXp-TeXmathchoice" id="MJXp-Span-476"><span class="MJXp-mrow" id="MJXp-Span-477"><span class="MJXp-mo" id="MJXp-Span-478" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.319em;"><span class="MJXp-right MJXp-scale6" style="font-size: 2.274em; margin-left: -0.09em;">(</span></span></span></span><span class="MJXp-mfrac" id="MJXp-Span-479"><span class="MJXp-box"><span class="MJXp-mn" id="MJXp-Span-480">1000</span></span><span class="MJXp-box" style="margin-top: -0.7em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em;"></span></span><span><span class="MJXp-box"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-481">k</span></span></span></span></span></span><span class="MJXp-TeXmathchoice" id="MJXp-Span-482"><span class="MJXp-mrow" id="MJXp-Span-483"><span class="MJXp-mo" id="MJXp-Span-484" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.319em;"><span class="MJXp-right MJXp-scale6" style="font-size: 2.274em; margin-left: -0.09em;">)</span></span></span></span></span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-154-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-154">sum_{k = 1}^{200} \binom{1000}{k}</script></p><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 大约相等 </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-485"><span class="MJXp-msubsup" id="MJXp-Span-486"><span class="MJXp-mn" id="MJXp-Span-487" style="margin-right: 0.05em;">10</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-488" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-489">216</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-155-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-155">10^{216}</script>  。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 因此所有 </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-490"><span class="MJXp-mn" id="MJXp-Span-491">10000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-156-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-156">10000</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 占地体积 </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-492"><span class="MJXp-msubsup" id="MJXp-Span-493"><span class="MJXp-mn" id="MJXp-Span-494" style="margin-right: 0.05em;">10</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-495" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-496">220</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-157-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-157">10^{220}</script>  。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 这是一个很大的数目，但仍然只是很小的一部分 </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-497"><span class="MJXp-mn" id="MJXp-Span-498">1000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-158-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-158">1000</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">维立方体。</font><font style="vertical-align: inherit;">在立方体的所有顶点中，只有</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-499"><span class="MJXp-mn" id="MJXp-Span-500">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-159-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-159"> 1 </script> 来自 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-501"><span class="MJXp-msubsup" id="MJXp-Span-502"><span class="MJXp-mn" id="MJXp-Span-503" style="margin-right: 0.05em;">10</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-504" style="vertical-align: 0.5em;"><span class="MJXp-mn" id="MJXp-Span-505">80</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-160-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-160">10^{80}</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">位于已保存模式的200位内。您可以永远徘徊而不必踩踏任何这些区域。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（永远吗？哦，是的，是的，它可能不会永远存在。由于超立方体是有限的结构，因此通过它的任何方式都必须早晚变为周期性，或者落入一个永不离开的固定点，或者在重复循环中迷失存储的向量是固定点，此外，还有许多其他固定点不对应任何有效模式，正因为如此，在我使用SDM程序进行的所有实验中，我从未设法“偶然地”进入已保存的模式转）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">为了保存这个坏主意，我进行了更多的实验。</font><font style="vertical-align: inherit;">在一种情况下，我任意地将几个相关的概念保存到相邻地址（“相邻”，即</font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">200或300位以内）。</font><font style="vertical-align: inherit;">也许在这个集群中，我可以安全地从一个地方跳到另一个地方。</font><font style="vertical-align: inherit;">但是实际上，整个集群被浓缩成一个吸引人的区域，成为中心图案，这成为吸引所有同伴的黑洞。</font><font style="vertical-align: inherit;">我也尝试发挥价值</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-506"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-507">r</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-161-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-161">r</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（所有读取和写入操作的访问范围的半径）。</font><font style="vertical-align: inherit;">在规范模型中</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-508"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-509">r</span><span class="MJXp-mo" id="MJXp-Span-510" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-511">451</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-162-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-162">r = 451</script>  。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">我认为写到一个较小的圆圈或从一个较大的圆圈读取将为结果留出足够的随机性，但是这种希望也没有实现。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">所有这些尝试都是基于对高维向量空间的误解。试图在超立方体中找到相邻值的聚类是没有希望的。存储的模式在体积上间隔太大。密集创建簇的任意创建也是没有意义的，因为它破坏了使系统变得有趣的特性-从吸引区域中的任何位置收敛到存储元素的能力。如果我们想为SDM创建一个云漫游算法，那么我们需要提出其他方法。</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在寻找意识流的另一种机制时，您可以尝试向稀疏分布内存世界添加一些图论。</font><font style="vertical-align: inherit;">然后，我们可以退后一步，以围绕图形或网络的随机游走的形式回到心理游荡的原始思想。</font><font style="vertical-align: inherit;">事实证明，将此类图形嵌入SDM的关键元素是我们熟悉的工具：异或运算符。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如上所述，两个向量之间的汉明距离是通过对它们进行按位XOR运算并计算所得单位来计算的。</font><font style="vertical-align: inherit;">但是XOR运算不仅给出两个向量之间的距离，还给出其他信息。</font><font style="vertical-align: inherit;">它还确定连接它们的线的方向或方向。</font><font style="vertical-align: inherit;">特别是操作</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-515"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-516">u</span><span class="MJXp-mo" id="MJXp-Span-517" style="margin-left: 0.267em; margin-right: 0.267em;">⊻</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-518">v</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-163-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-163">u \veebar v</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 给出一个矢量，列出需要更改以进行转换的位 </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-519"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-520">u</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-164-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-164">u</script> 在 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-521"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-522">v</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-165-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-165">v</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">反之亦然。</font><font style="vertical-align: inherit;">也可以感知</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-523"><span class="MJXp-mn" id="MJXp-Span-524">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-166-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-166"> 1 </script> 和 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-525"><span class="MJXp-mn" id="MJXp-Span-526">0</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-167-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-167"> 0 </script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在XOR向量中，您需要遵循一系列方向来跟踪从 </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-527"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-528">u</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-168-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-168">u</script> 之前 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-529"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-530">v</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-169-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-169">v</script>  。 <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在所有布尔函数中，XOR一直是我的最爱。</font><font style="vertical-align: inherit;">这是一个差分运算符，但与减法不同，XOR是对称的：</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-531"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-532">u</span><span class="MJXp-mo" id="MJXp-Span-533" style="margin-left: 0.267em; margin-right: 0.267em;">⊻</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-534">v</span><span class="MJXp-mo" id="MJXp-Span-535" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-536">v</span><span class="MJXp-mo" id="MJXp-Span-537" style="margin-left: 0.267em; margin-right: 0.267em;">⊻</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-538">u</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-170-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-170">u \veebar v = v \veebar u</script>  。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">而且，XOR是它自己的逆函数。</font><font style="vertical-align: inherit;">带有单个参数的函数很容易理解这个概念：</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-539"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-540">f</span><span class="MJXp-mrow" id="MJXp-Span-541"><span class="MJXp-mo" id="MJXp-Span-542" style="margin-left: 0.278em; margin-right: 0.278em;">（</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-543">x</span><span class="MJXp-mrow" id="MJXp-Span-544"><span class="MJXp-mo" id="MJXp-Span-545" style="margin-left: 0.278em; margin-right: 0.278em;">）</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-171-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-171"> f（x）</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 是它自己的反函数，如果 </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-546"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-547">f</span><span class="MJXp-mo" id="MJXp-Span-548" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-549">f</span><span class="MJXp-mo" id="MJXp-Span-550" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-551">x</span><span class="MJXp-mo" id="MJXp-Span-552" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-553" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-554" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-555">x</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-172-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-172">f(f(x)) = x</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，也就是说，在两次应用该函数之后，我们可以返回到开始的地方。</font><font style="vertical-align: inherit;">对于具有两个自变量的函数（例如XOR），情况更为复杂，但是，重复执行两次相同的操作会还原原始状态，这仍然是正确的。</font><font style="vertical-align: inherit;">特别是如果</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-556"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-557">u</span><span class="MJXp-mo" id="MJXp-Span-558" style="margin-left: 0.267em; margin-right: 0.267em;">⊻</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-559">v</span><span class="MJXp-mo" id="MJXp-Span-560" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-561">w</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-173-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-173">u \veebar v = w</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 然后 </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-562"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-563">u</span><span class="MJXp-mo" id="MJXp-Span-564" style="margin-left: 0.267em; margin-right: 0.267em;">⊻</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-565">w</span><span class="MJXp-mo" id="MJXp-Span-566" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-567">v</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-174-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-174">u \veebar w = v</script> 和 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-568"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-569">v</span><span class="MJXp-mo" id="MJXp-Span-570" style="margin-left: 0.267em; margin-right: 0.267em;">⊻</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-571">w</span><span class="MJXp-mo" id="MJXp-Span-572" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-573">u</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-175-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-175">v \veebar w = u</script>  。<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 三个向量- </font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-574"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-575">u</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-176-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-176">u</script>  ， <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-576"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-577">v</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-177-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-177">v</script> 和 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-578"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-579">w</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-178-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-178">w</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">-创建一个微小的封闭宇宙。</font><font style="vertical-align: inherit;">您可以将XOR运算符应用于任意一对运算符，并获取集合的第三个元素。</font><font style="vertical-align: inherit;">以下是尝试说明此想法的尝试。</font><font style="vertical-align: inherit;">每个方块都模仿</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-580"><span class="MJXp-mn" id="MJXp-Span-581">10000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-179-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-179">10000</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">位向量排列为100 x 100的明暗像素表。</font><font style="vertical-align: inherit;">这三个模式似乎是随机的和独立的，但实际上，每个面板都是其他两个面板的异或。</font><font style="vertical-align: inherit;">例如，在最左边的正方形中，每个红色像素对应于绿色或蓝色，但从不对应于两者。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wd/xt/rc/wdxtrcs6sx8i6us8r7c7mwf9bn8.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">自我可逆性属性为我们提供了一种在SDM中组织信息的新方法。假设字</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">蝶</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，和他的法国同行</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">巴比</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">存储在任意的，随机向量。他们不会彼此靠近。它们之间的距离可能约为500位。现在我们计算这些</font><em><font style="vertical-align: inherit;">蝴蝶</font></em><font style="vertical-align: inherit;">向量的XOR</font></font><em><font style="vertical-align: inherit;"></font></em> <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-582"><span class="MJXp-mo" id="MJXp-Span-583" style="margin-left: 0.267em; margin-right: 0.267em;">⊻</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-180-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-180">\veebar</script> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">巴比龙</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ;结果是另一个向量，也可以将其保存在SDM中。这个新向量编码了</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">英法</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">连接</font><font style="vertical-align: inherit;">。现在我们有了翻译工具。有了</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">蝴蝶</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">的向量</font><font style="vertical-align: inherit;">，我们用向量</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">English-French</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">对它执行XOR运算</font><font style="vertical-align: inherit;">，得到</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">papillon</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。相同的技巧在相反的方向上起作用。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这对单词及其之间的联系形成了语义网络的核心。让我们增加一点。我们可以将</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">caterpillar</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">一词保存在任意地址中</font><font style="vertical-align: inherit;">，然后计算出</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">蝴蝶</font></font></em> <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-584"><span class="MJXp-mo" id="MJXp-Span-585" style="margin-left: 0.267em; margin-right: 0.267em;">⊻</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-181-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-181">\veebar</script> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">毛毛虫</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，并称这种新的</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">成年青年</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">关系</font><font style="vertical-align: inherit;">。</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">毛毛虫</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在法语中叫什么</font><font style="vertical-align: inherit;">？</font><font style="vertical-align: inherit;">法语中的毛毛虫是</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">雪尼尔</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">我们通过</font><font style="vertical-align: inherit;">在</font><em><font style="vertical-align: inherit;">毛毛虫上</font></em><font style="vertical-align: inherit;">存储</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">雪尼尔</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将这一事实添加到网络中</font></font><em><font style="vertical-align: inherit;"></font></em> <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-586"><span class="MJXp-mo" id="MJXp-Span-587" style="margin-left: 0.267em; margin-right: 0.267em;">⊻</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-182-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-182">\veebar</script> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">英法文</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">现在是魔术的时候了：如果我们服用</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">巴比龙</font></font></em> <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-588"><span class="MJXp-mo" id="MJXp-Span-589" style="margin-left: 0.267em; margin-right: 0.267em;">⊻</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-183-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-183">\veebar</script> <em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">雪尼尔</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，我们了解到这些词与</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">成人与青少年</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">之间的关系有关</font><font style="vertical-align: inherit;">，即使它们没有明确指出这一点。</font><font style="vertical-align: inherit;">这种限制是由结构本身的几何形状引起的。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ec/dx/-p/ecdx-przlx4rgh7wlp1z63ito-y.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">可以通过添加更多与英语-法语相关的单词（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dog-chien，horse-cheval</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）或更多成年-青年对</font><font style="vertical-align: inherit;">来扩展该图</font><font style="vertical-align: inherit;">：（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dog-puppy，tree-sapling</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。您还可以探索许多其他关系：同义词，反义词，同级，因果关系，捕食者－被捕者等等。通过简单地对节点的前任节点和后继节点的地址执行XOR，还有一种将多个事件按时间顺序连接的好方法。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">XOR的概念连接方式是几何和图论的混合体。</font><font style="vertical-align: inherit;">在普通图的数学理论中，距离和方向并不重要。</font><font style="vertical-align: inherit;">唯一重要的是节点之间是否存在连接边缘。</font><font style="vertical-align: inherit;">另一方面，在SDM中，代表节点之间连接的边是有限长度和方向性的向量。</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-590"><span class="MJXp-mn" id="MJXp-Span-591">1000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-184-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-184">1000</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">维空间。</font><font style="vertical-align: inherit;">对于给定的节点和链接，XOR操作将该节点“绑定”到超立方体中其他位置的特定位置。</font><font style="vertical-align: inherit;">最终的结构绝对是严格的-我们无法移动节点而不更改它所参与的所有连接。</font><font style="vertical-align: inherit;">在蝴蝶和毛毛虫的情况下，四个结的配置不可避免地变成了平行四边形，其中，相对两侧的对具有相同的长度和方向。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">与XOR操作相关的图的另一个独特特征是节点和边具有完全相同的表示。在大多数图论思想的计算机实现中，这两个实体有很大的不同。一个节点可以是一个属性列表，一个边缘可以是指向由它连接的节点的一对指针。在SDM中，节点和边都是可以以相同格式存储的高维向量。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当用作人类记忆的模型时，XOR绑定使我们能够通过我们可以想到的任何连接来连接任何两个概念。现实世界中的许多连接都是不对称的；它们不具有XOR所具有的自我可逆性。 XOR向量可以声明Edward和Victoria是父母和孩子，但不告诉他们谁是谁。更糟糕的是，XOR向量恰好连接两个节点，并且再也不会连接，因此几个孩子的父母将我们置于不愉快的位置。另一个困难是要保持大图的所有分支的完整性。我们不能随便添加节点和边。它们必须以正确的顺序附加到图形上。在蝴蝶和毛毛虫之间插入up阶段将需要重写大部分图案。您必须将几个节点移到超立方体内部的新位置，并重新计算连接它们的连接矢量，同时确保英语一侧的每个更改都能正确反映法语。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这些问题中的一些是通过Kanerva称为捆绑的另一种基于XOR的技术解决的。这个想法是创建某种数据库来存储属性值对。书籍条目可能具有诸如</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">作者</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">标题</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">和</font><em><font style="vertical-align: inherit;">出版者的</font></em><font style="vertical-align: inherit;">属性</font></font><em><font style="vertical-align: inherit;"></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，每个都与一个对应的值配对。</font><font style="vertical-align: inherit;">数据绑定的第一阶段是每个属性值对的单独XOR。</font><font style="vertical-align: inherit;">然后，使用与上述用于在固态SDM单元中存储多个矢量的算法相同的算法，将从这些操作获得的矢量进行组合，以创建单个汇总矢量。</font><font style="vertical-align: inherit;">使用此组合向量执行属性名称的XOR，我们获得了足够接近的近似值，可以通过递归调用方法来确定它。</font><font style="vertical-align: inherit;">在规范模型的实验中，我发现</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-592"><span class="MJXp-mn" id="MJXp-Span-593">1000</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-185-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-185">1000</script><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 位向量可以存储六或七个属性值对，而不会造成很大的混淆风险。 </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1988年的Kanerva书中没有提到绑定和捆绑，但是他在较新的文章中详细讨论了绑定和捆绑。 （请参见下面的“其他阅读”部分。）它表明，使用这两个算子，许多高维向量采用代数场的结构，或至少近似于一个场。一个字段的典型示例是一组实数，而不是加法和乘法运算以及它们的逆运算符。实数在这些操作下创建一个封闭集：任意两个实数的加，减，乘或除给出另一个实数（除以零的情况除外，该值始终是套牌中的一个小丑）。类似地，二进制向量的集合是封闭的，用于链接和捆绑，除了有时，为了恢复集合的成员，需要通过递归调用过程“清除”从条带向量中提取的结果。</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">链接和捆绑可以帮助我们获得一种云漫游算法吗？它们为我们提供了导航语义图的基本工具，包括执行随机遍历的能力。从连接的XOR图中的任何节点开始，随机遍历算法在此字符串中可用的所有链接中进行选择。通信向量的随机选择和对该向量与节点地址的XOR执行将我们引向可以重复该过程的另一个节点。类似地，在捆绑的“属性值”对中，随机选择的属性调用相应的值，该值成为正在调查的下一个节点。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">但是，算法如何知道哪些关系或哪些算法可供选择？关系和属性以向量的形式表示，并像其他任何对象一样存储在内存中，因此除非您知道它们的真正含义，否则没有显而易见的方法来获取这些向量。我们不能说“给我看所有的联系”。我们只能显示模式并询问“是否有这样的向量？您看到这样的东西了吗？”</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在传统的计算机内存中，我们可以获取内存转储：转到所有地址并显示在每个位置找到的值。但是对于分布式内存，没有这样的过程。这个令人沮丧的事实给了我困难。在构建SDM计算模型时，我设法变得足够好，可以在内存中存储数千个随机生成的模式。但是我无法提取它们，因为我不知道要请求什么。解决方案是在SDM本身之外创建一个单独的列表，将我保存的所有内容写入其中。但是，假设大脑会同时保留记忆和该记忆的索引似乎是牵强的。为什么不仅仅使用索引，因为它非常容易？</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">由于此限制，似乎稀疏的分布式内存可用于感官，但不能用于想象。它可以识别熟悉的模式，并保存新的模式，即使在信号不完整或损坏的情况下，也可以在以后的会议中识别它们。由于链接或捆绑，内存还可以跟踪成对存储的项目之间的链接。但是写入存储器的所有内容只能通过发送适当的信号来检索。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/441/531/686/4415316868403204d8d2df1f22201eeb.jpg"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">当我看</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">研究生</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">海报时</font><font style="vertical-align: inherit;">，我看到达斯汀·霍夫曼看着长袜里的安妮·班克罗夫特的腿。这种视觉刺激激发了大脑皮层神经元的子集，这与我对演员，角色，情节，配乐和1967年的回忆相对应。如果我们假设神经元的子集可以某种抽象形式表示为长随机二进制矢量，那么所有这些大脑活动都可以用SDM内存架构来解释。但是，不能简单地解释一个事实，那就是我可以在不看这张照片的情况下在大脑中引起所有相同的感觉。我如何从庞大的向量交织中专门提取这些长随机序列，而又不确切知道它们在哪里？</font></font><br><br><hr><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这结束了我的漫长旅程-充满疑问和失望。我没能真正掌握本质，这不足为奇。这是一个非常复杂的话题。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在西蒙斯研究所（Simons Institute）进行大脑和计算程序的第一天，致力于追踪老鼠大脑中的换向电路的杰夫·利希特曼（Jeff Lichtman）提出了一个问题：神经科学已经达到了沃森-克里克矩吗？在分子遗传学中，我们已经达到了可以从活细胞中去除DNA链并读取其中许多信息的地步。我们甚至可以记录自己的消息，然后将其重新插入正文中。神经科学的类似能力是研究大脑组织并读取其中存储的信息-知识，记忆，世界观。也许我们甚至可以直接将信息写入大脑。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">科学甚至没有实现许多人所喜悦的接近这一目标。包括我在内：我不希望我的想法通过电极或移液管从我的脑袋中吸出来，而被#fakenews取代。但是，我</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">真的</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">很想知道大脑是如何工作的。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">西蒙斯研究所的计划使我对神经科学的最新成就视而不见，但也使我意识到最严重的问题之一仍然没有得到解答。利希特曼（Lichtmann）和其他人的连接项目创建了数百万个神经元及其连接的详细地图。新的录音技术使我们能够聆听各个神经细胞发出的信号，并跟随大脑广阔区域的激发波。我们有相当全面的神经元类型目录，我们对它们的生理学和生化知识了解很多。这一切令人印象深刻，但仍然存在困惑。我们可以记录神经信号，但是在大多数情况下我们都不知道它们的含义。我们不知道信息是如何编码和存储在大脑中的。这类似于在不了解二进制算术和布尔逻辑的情况下尝试理解数字计算机的电路图。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pentti Canerva的稀疏分布式内存模型是填补其中一些空白的一种尝试。</font><font style="vertical-align: inherit;">这不是唯一的尝试。</font><font style="vertical-align: inherit;">约翰霍普菲尔德（John Hopfield）的方法是一个更广为人知的替代方法-神经网络作为动态系统的概念，采用的是能量最小化吸引子。</font><font style="vertical-align: inherit;">这两个想法具有共同的基本原理：信息分散在大量的神经元上，并且以外部观察者不知道的形式进行编码，即使他将获得对所有神经元以及通过它们的信号的访问权限。</font><font style="vertical-align: inherit;">类似的方案，本质上是数学的和计算的，在概念上位于高级心理学和低级神经工程之间的中间。</font><font style="vertical-align: inherit;">该层包含值。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">补充阅读</font></font></b> <div class="spoiler_text"> Hopfield, JJ (1982). Neural networks and physical systems with emergent collective computational abilities. <em>Proceedings of the National Academy of Sciences</em> 79(8):2554–2558. <br><br> Kanerva, Pentti. 1988. <em>Sparse Distributed Memory</em> . Cambridge, Mass.: MIT Press. <br><br> Kanerva, Pentti. 1996. Binary spatter-coding of ordered <em>K</em> -tuples. In C. von der Malsburg, W. von Seelen, JC Vorbruggen and B. Sendhoff, eds. <em>Artificial Neural Networks—ICANN 96 Proceedings</em> , pp. 869–873. Berlin: Springer. <br><br> Kanerva, Pentti. 2000. Large patterns make great symbols: An example of learning from example. In S. Wermter and R. Sun, eds. <em>Hybrid Neural Systems</em> , pp. 194–203. Heidelberg: Springer.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">聚甲醛</a> <br><br> Kanerva, Pentti. 2009. Hyperdimensional computing: An introduction to computing in distributed representation with high-dimensional random vectors. <em>Cognitive Computation</em> 1(2):139–159.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">聚甲醛</a> <br><br> Kanerva, Pentti. 2010. What we mean when we say “What's the Dollar of Mexico?”: Prototypes and mapping in concept space. Report FS-10-08-006, AAAI Fall Symposium on Quantum Informatics for Cognitive, Social, and Semantic Processes.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">聚甲醛</a> <br><br> Kanerva, Pentti. 2014. Computing with 10,000-bit words. Fifty-second Annual Allerton Conference, University of Illinois at Urbana-Champagne, October 2014. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">PDF</a> </div></div><br><p> Plate, Tony. 1995. Holographic reduced representations. IEEE Transactions on Neural Networks 6(3):623–641.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">聚甲醛</a> <br><br> Plate, Tony A. 2003. <em>Holographic Reduced Representation: Distributed Representation of Cognitive Structure</em> . Stanford, CA: CSLI Publications. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN419147/">https://habr.com/ru/post/zh-CN419147/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN419135/index.html">Friday JS：0行JS和CSS游戏</a></li>
<li><a href="../zh-CN419137/index.html">使用Web Beacon API进行活动记录</a></li>
<li><a href="../zh-CN419141/index.html">在美国，网上诱骗行为正日益兴起</a></li>
<li><a href="../zh-CN419143/index.html">创建一个模拟器街机。 第4部分</a></li>
<li><a href="../zh-CN419145/index.html">Apple的市值超过1万亿美元，人工智能帮助eBay增加了数十亿美元的收入</a></li>
<li><a href="../zh-CN419149/index.html">Mikrotik RoMON指南</a></li>
<li><a href="../zh-CN419151/index.html">智能家居：舒适和追求卓越的新维度。 第二部分</a></li>
<li><a href="../zh-CN419153/index.html">机器人权利备忘录</a></li>
<li><a href="../zh-CN419155/index.html">将JS移植到Elbrus</a></li>
<li><a href="../zh-CN419159/index.html">JS代码，罗马数字，几何谜语：我们如何加密年龄</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>