<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🈴 🤵 😣 旅程沙着色器探索 🧖🏾 📀 💃🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在过去十年发布的众多独立游戏中，我最喜欢的游戏之一肯定是《旅程》 。 得益于其令人惊叹的美学和优美的配乐， 《旅程》已成为几乎所有发展方面的卓越典范。 

 我是一名游戏开发人员和技术美术师，所以对沙子的渲染方式最着迷。 它不仅美观，而且与基本游戏玩法和整个游戏玩法直接相关。 旅程实际上是用沙子建造...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>旅程沙着色器探索</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/476448/"> 在过去十年发布的众多独立游戏中，我最喜欢的游戏之一肯定是<em>《旅程》</em> 。 得益于其令人惊叹的美学和优美的配乐， <em>《旅程》</em>已成为几乎所有发展方面的卓越典范。 <br><br> 我是一名游戏开发人员和技术美术师，所以对沙子的渲染方式最着迷。 它不仅美观，而且与基本游戏玩法和整个游戏玩法直接相关。  <em>旅程</em>实际上是用沙子建造的，没有这种惊人的效果，游戏本身根本就不存在。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/63f/be0/2a8/63fbe02a87ccac8101001a43d953776f.jpg"></div><br> 在这篇分为两篇文章的文章中，我将通过教您如何使用着色器重新创建完全相同的沙渲染来向<em>Journey</em>遗产致敬。 无论您的游戏中是否需要沙丘，本系列教程都将使您学习如何在自己的游戏中重现特定的美学。 如果要重新创建<em>Journey中</em>使用的漂亮的沙着色器，则首先需要了解它的构建方式。 尽管看起来非常复杂，但实际上它包含几个相对简单的效果。 为了成为一名成功的技术美术师，必须使用这种编写着色器的方法。 因此，我希望您能与我一起<em>经历</em>这一<em>旅程</em> ，我们不仅探索着色器的创建，而且学习如何将美学与游戏玩法结合起来。 <br><a name="habracut"></a><br><h1> 旅途中的沙尘分析 </h1><br> 与许多其他尝试重新创建<em>Journey</em>沙渲染一样，本文基于GDC的一份报告，该报告由游戏公司首席工程师John Edwards撰写，标题为“ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer">旅程中的沙渲染</a> ”。 在本次演讲中，约翰·爱德华兹（John Edwards）讨论了<em>旅程</em>岩石沙丘中添加的所有效果层，以实现正确的外观。 <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/wt2yYnBRD3U" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> 该报告非常有用，但是在本教程的上下文中，John Edwards所做的许多限制和决定并不重要。 我们将主要通过视觉参考来尝试重新创建沙色着色器，使人联想到<em>Journey</em>着色器。 <br><br> 让我们从一个完美光滑的沙丘的简单3D网格开始。 扬沙的信誉取决于两个方面：照明和纹理。 改良的<strong>照明模型</strong>提供了一种有趣的方式来反射沙子中的<strong>光线</strong> 。 在着色器编码的上下文中，光照模型根据模型的属性和场景的光照条件确定阴影和高光。 <br><br> 但是，所有这些还不足以引起现实主义的幻觉。 问题在于，沙子根本无法用平坦表面建模。 应该考虑沙粒。 这就是为什么有两个单独的效果直接作用<strong>于表面法线的原因</strong> ，可以用来模拟沙丘表面上的小沙粒。 <br><br> 下图显示了我们将在本教程中学习的所有效果。 从技术角度来看，通常在处理照明之前执行计算。 为了便于研究，将以不同顺序描述效果。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/373/0b9/8a1/3730b98a1670ef00cf68efb0af0cc08b.png"></div><br><h6> 漫反射色 </h6><br> 最简单的沙着色器效果是其<strong>漫反射色</strong> ，可以大致描述整体外观的<em>暗淡</em>成分。 漫反射颜色是根据对象的<em>真实</em>颜色和照明条件计算的。 用白色绘制的球体在任何地方都不会是完美的白色，因为漫反射的颜色取决于入射到其上的光。 使用近似于表面反射光的数学模型来计算漫反射的颜色。 感谢约翰·爱德华兹（John Edwards）和GDC的报告，我们确切地知道了所使用的方程，他称其为<strong>漫反差反射率</strong> 。 它基于著名的<strong>Lambert反射</strong>模型。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/509/4c1/65b/5094c165b5f2e1ba10696fec1641482c.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90f/9b4/73f/90f9b473f7d1eefcb6ca32871300fed8.png"></div><br>  <i>应用方程之前和之后</i> <br><br><h6> 沙正常 </h6><br> 原始几何图形完全平滑。 为了弥补这一点，可使用称为<strong>凹凸贴图</strong>的技术更改模型的<strong>表面法线</strong> 。 它允许您使用纹理来模拟更复杂的几何图形。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90f/9b4/73f/90f9b473f7d1eefcb6ca32871300fed8.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07a/739/06d/07a73906d58ed9d4c251340b4e92d7f5.png"></div><br><h6> 边缘照明 </h6><br> 每个<em>旅程</em>级别都使用有限的调色板。 因此，很难理解一个沙丘在哪里结束而另一沙丘在哪里开始。 为了提高可读性，使用了一种小的突出显示技术，该技术仅在沙丘的边缘可见。 它称为<strong>边缘照明</strong> ，并且有很多方法可以实现它。 在本教程中，我选择了一种基于<strong>菲涅耳</strong>反射的方法，该方法可以模拟抛光表面<strong>上的</strong>反射，即所谓的<em>入射角</em> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07a/739/06d/07a73906d58ed9d4c251340b4e92d7f5.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/864/285/818/8642858189235ff1d796378992523ceb.png"></div><br><h6> 海洋的镜面反射 </h6><br>  <em>旅程的</em>游戏中最令人愉快的方面之一是“冲浪”沙丘的能力。 这可能就是该游戏公司希望沙子感觉更像液体而不是固体的原因。 为此，使用了强烈的反射，通常可以在水着色器中找到它。  John Edwards将此效果称为<strong>海洋镜面反射</strong> ，在本教程中，我们使用<strong>Blinn-Fong反射</strong>实现了该效果。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/864/285/818/8642858189235ff1d796378992523ceb.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/716/d17/d2f/716d17d2f4d0d0796e51bee059ce39c2.png"></div><br><h6> 眩光反射 </h6><br> 向沙着色器添加海洋镜面反射分量会使它看起来更流畅。 但是，它仍然不允许传达沙子最重要的视觉方面之一：随机发生的反射。 在真正的沙丘中，发生这种效果的原因是，每粒沙粒都沿其方向反射光，并且这些反射射线中的一种经常进入我们的眼睛。 即使在没有直射阳光的地方也会发生这种<strong>闪光反射</strong> （反射反射）。 它补充了海洋镜面，并增强了信誉感。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/716/d17/d2f/716d17d2f4d0d0796e51bee059ce39c2.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/539/f3c/33c/539f3c33c6c12f5206540ff62ecf4102.png"></div><br><h6> 沙浪 </h6><br> 更改法线使我们可以模拟覆盖沙丘表面的小沙粒的影响。 在现实世界的沙丘上，经常会出现风起的波浪。 它们的形状根据每个沙丘相对于风向的倾斜度和位置而变化。 可能可以通过凹凸纹理创建此类图案，但是在这种情况下，不可能实时更改沙丘的形状。 约翰·爱德华兹（John Edwards）提出的解决方案类似于一种称为<strong>三面阴影</strong>的技术：它使用四种不同的纹理，根据每个沙丘的位置和坡度进行混合。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/539/f3c/33c/539f3c33c6c12f5206540ff62ecf4102.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/828/9b4/997/8289b49971bbe0046845f71284790124.png"></div><br><h1> 旅途沙着色器解剖 </h1><br>  Unity有许多着色器模板，可帮助您入门。 由于我们对可以接收照明和阴影的材质感兴趣，因此我们需要从<strong>曲面着色器</strong> （surface shader）开始。 <br><br> 所有<strong>表面着色器</strong>分两个阶段执行。 首先，称为<strong>表面函数</strong> ， <strong>该函数</strong>收集需要渲染的表面的属性，例如其<em>反照率</em> ， <em>粗糙度</em> ， <em>金属属性</em> ， <em>透明度</em>和<em>法线方向</em> 。 然后将所有这些属性转移到<strong>照明功能</strong> ，该<strong>功能</strong>考虑了外部光源的影响并计算阴影和照明。 <br><br><h2> 表面功能 </h2><br> 让我们从成为表面函数核心的内容开始，在下面的<code>surf</code>代码中进行调用。 我们需要设置的唯一属性是<em>沙子</em>的<em>颜色</em>和<strong>表面</strong>的<strong>法线</strong> 。  3D模型的法线是指示表面位置的向量。 照明功能使用法向矢量来计算光的反射方式。 它们通常是在导入网格时计算的。 但是，可以对其进行修改以模拟更复杂的几何形状。 正是在这里， <strong>沙质法线</strong>和<strong>砂</strong> <strong>波</strong> <strong>法线</strong>效果扭曲了沙模，以模拟其粗糙度。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span></span></span><span class="hljs-function"> </span></span>{ o.Albedo = _SandColor; o.Alpha = <span class="hljs-number"><span class="hljs-number">1</span></span>; float3 N = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); N = RipplesNormal(N); N = SandNormal (N); o.Normal = N; }</code> </pre> <br> 将法线写入<code>o.Normal</code>必须在<strong>切线空间中</strong>表示它们。 这意味着相对于3D模型的表面选择了矢量。 也就是说， <code>float3(0, 0, 1)</code>实际上意味着对普通3D模型实际上没有进行任何更改。 <br><br>  <code>RipplesNormal</code>和<code>SandNormal</code>两个函数<code>SandNormal</code>接收法线向量并对其进行修改。 稍后我们将看到如何做到这一点。 <br><br><h2> 照明功能 </h2><br> 所有其他效果都在照明功能中实现。 下面的代码显示了如何使用单独的函数（漫反射颜色，边缘照明，海洋镜面反射和闪光反射）计算每个单独的分量。 然后它们全部合并。 <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf Journey fullforwardshadows float4 LightingJourney (SurfaceOutput s, fixed3 viewDir, UnityGI gi) { float3 diffuseColor = DiffuseColor (); float3 rimColor = RimLighting (); float3 oceanColor = OceanSpecular (); float3 glitterColor = GlitterSpecular (); float3 specularColor = saturate(max(rimColor, oceanColor)); float3 color = diffuseColor + specularColor + glitterColor; return float4(color * s.Albedo, 1); }</span></span></code> </pre> <br> 组合组件的方法相当随意，可以让我们对其进行更改以研究艺术可能性。 <br><br> 通常，镜面反射会堆叠在漫反射的颜色上。 由于这里我们没有一个镜面反射，而是三个镜面反射（ <em>边缘光</em> ， <em>海洋镜面反射</em>和<em>闪光镜面反射</em> ），因此我们需要格外小心，以免使沙子<em>过于</em>闪烁。 由于边缘光和海洋镜面反射是同一效果的一部分，因此我们只能从中选择最大值。 单独添加闪光镜面反射，因为此组件会产生闪烁的沙子。 <br><br><h2> 第2部分。漫反射色 </h2><br> 在文章的第二部分，我们将重点介绍游戏中使用的照明模型以及该模型。 如何在Unity中重新创建它。 <br><br> 在上一部分中，我们为逐渐变成我们的Journey沙着色器版本奠定了基础。 如前所述，在<strong>表面着色器中</strong>使用<strong>了照明功能</strong>来计算照明效果，从而使阴影和高光出现在表面上。 我们发现，旅途有几种影响属于此类。 我们将从此着色器的核心中发现的最基本（最简单）的效果开始：其<strong>漫射照明</strong> （漫反射/漫射照明）。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/78f/166/71c/78f16671c754f05e619ce034fad81926.png"></div><br> 现在，我们忽略所有其他效果和组件，只着重于<strong>照亮沙子</strong> 。 <br><br> 我们在文章的前一部分“ <code>LightingJourney</code> <code>DiffuseColor</code>的光照函数只是将沙子的漫反射色的计算委托给一个名为<code>DiffuseColor</code>的函数。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">LightingJourney</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(SurfaceOutput s, fixed3 viewDir, UnityGI gi)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Lighting properties float3 L = gi.light.dir; float3 N = s.Normal; // Lighting calculation float3 diffuseColor = DiffuseColor(N, L); // Final color return float4(diffuseColor, 1); }</span></span></code> </pre> <br> 由于每个效果都是独立的并存储在其自己的函数中，因此我们的代码将更加模块化和简洁。 <br><br><h2> 兰伯特反射 </h2><br> 在“像在旅途中一样”创建漫射照明之前，很高兴了解“基本”漫射照明功能的外观。 遮罩材料最简单的着色技术称为<strong>朗伯反射率</strong> 。 该模型近似于大多数非发光和非金属表面的外观。 它以瑞士百科全书科学家<strong>约翰·海因里希·兰伯特</strong> （ <strong>Johann Heinrich Lambert</strong> ）的名字命名，后者于1760年提出了这一概念。 <br><br> 兰伯特的反射概念基于一个简单的想法： <em>表面</em>的<em>亮度取决于入射到其上的光量</em> 。 在几何上，这可以显示在下图中，其中球体由远程光源照明。 尽管球体的红色和绿色区域受到相同的照明量，但是它们的表面积却明显不同。 如果红色区域中的光分布在较大的区域，则意味着红色正方形的每个单元接收的光少于绿色。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2cf/d48/495/2cfd484953877a47fe5ba564b399ea35.png"></div><br> 从理论上讲，朗伯反射取决于<em>表面</em>和<em>入射光</em>之间的相对角度。 从数学的角度来看，我们说这是从<strong>法线到表面</strong>和<strong>照明方向的</strong>函数。 这些数量使用两个单位长度向量（称为<strong>单位向量</strong> ）表示 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.064ex" height="2.057ex" viewBox="0 -780.1 888.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMATHI-4E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-1"> N </script> 和 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-3"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4">L</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.583ex" height="2.057ex" viewBox="0 -780.1 681.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMATHI-4C" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-2"> L </script>  。 单矢量是在着色器编码的上下文中指定<em>方向</em>的标准方法。 <br><br><div class="spoiler">  <b class="spoiler_title">N和L的值</b> <div class="spoiler_text"> 垂直于表面 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-5"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ñ</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.064ex" height="2.074ex" viewBox="0 -772.3 888.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMATHI-4E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3"> N </script> 是<em>远离</em>表面本身定向的单位向量。 <br><br> 通过类推，我们可以假设<strong>照明方向</strong> <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-7"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-8"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">大号</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.583ex" height="2.074ex" viewBox="0 -772.3 681.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMATHI-4C" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-4"> L </script>  <em>从</em>光源指向的方向沿光的移动方向移动。 但是，事实并非如此：照明的方向是指向光入射<em>方向的</em>单个矢量。 <br><br> 这可能会造成混淆，特别是如果您不熟悉创建着色器。 但是，由于有了这种表示法，方程式变得更简单了。 </div></div><br><div class="spoiler">  <b class="spoiler_title">兰伯特在Unity中的反思</b> <div class="spoiler_text"> 在Unity 5 <strong>Standard Shader</strong>之前，Lambert反射是用于对照明表面进行着色的标准模型。 <br><br> 您仍然可以在Material Inspector中访问它：在<em>Legacy着色器中，</em>它称为<em>Diffuse</em> 。 <br><br> 如果您编写自己的表面着色器，则可以使用Lambert反射作为名为<code>Lambert</code>的照明功能： <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> surface surf Lambert fullforwardshadows</span></span></code> </pre> <br> 可以在<code>CGIncludes\Lighting.cginc</code>文件中定义的<code>LightingLambert</code>函数中找到其实现。 </div></div><br><div class="spoiler">  <b class="spoiler_title">兰伯特反射与气候</b> <div class="spoiler_text">  Lambert反射是一个相当古老的模型，但是它提供了对复杂概念（例如表面着色）的理解。 它也可以用来解释许多其他现象。 例如，同一张图解释了为什么在地球两极比在赤道更冷。 </div></div><br> 仔细观察后，我们可以看到表面的法线平行于照明方向时，该表面获得的照明量最大。 反之亦然：如果两个单位向量彼此垂直，则没有光。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0e1/d06/6c6/0e1d066c6ff998abda8ca5c7607e4c4e.png"></div><br> 显然， <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-9"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-10">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.064ex" height="2.057ex" viewBox="0 -780.1 888.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMATHI-4E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-5"> N </script> 和 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-11"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-12">L</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.583ex" height="2.057ex" viewBox="0 -780.1 681.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMATHI-4C" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-6"> L </script> 根据兰伯特的观点，反射至关重要。 而且，亮度最大，等于 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-13"><span class="MJXp-mn" id="MJXp-Span-14">100</span><span class="MJXp-mtext" id="MJXp-Span-15" style="color: red;">\％</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.578ex" height="2.66ex" viewBox="0 -832 2832 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-30" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-30" x="1001" y="0"></use><g fill="red" stroke="red" transform="translate(1501,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-5C"></use><g transform="translate(500,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">％</text></g></g></g></svg></span><script type="math/tex" id="MathJax-Element-7"> 100 \％</script> 当角度是 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-16"><span class="MJXp-mn" id="MJXp-Span-17">0</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-30" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-8"> 0 </script> 和最小（ <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-18"><span class="MJXp-mn" id="MJXp-Span-19">0</span><span class="MJXp-mtext" id="MJXp-Span-20" style="color: red;">\％</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.253ex" height="2.66ex" viewBox="0 -832 1831 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-30" x="0" y="0"></use><g fill="red" stroke="red" transform="translate(500,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-5C"></use><g transform="translate(500,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">％</text></g></g></g></svg></span><script type="math/tex" id="MathJax-Element-9"> 0 \％</script>  ）当角度趋于 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-21"><span class="MJXp-msubsup" id="MJXp-Span-22"><span class="MJXp-mn" id="MJXp-Span-23" style="margin-right: 0.05em;">90</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-24" style="vertical-align: 0.5em;"><span class="MJXp-mtext" id="MJXp-Span-25">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-26">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-27">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-28">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-29">c</span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.871ex" height="2.419ex" viewBox="0 -935.7 2527.6 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-39"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-30" x="500" y="0"></use><g transform="translate(1001,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMATHI-63" x="353" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMATHI-69" x="787" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMATHI-72" x="1132" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMATHI-63" x="1584" y="0"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-10"> 90 ^ {\ circ} </script>  。 如果您熟悉<em>矢量代数</em> ，则可以理解代表兰伯特反射的量 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-30"><span class="MJXp-mrow" id="MJXp-Span-31"><span class="MJXp-mo" id="MJXp-Span-32" style="margin-left: 0.278em; margin-right: 0.278em;">我</span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.928ex" height="2.298ex" viewBox="0 -780.1 830 989.6" role="img" focusable="false" style="vertical-align: -0.487ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">我</text></g></svg></span><script type="math/tex" id="MathJax-Element-11">我</script> 等于 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-33"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-34">N</span><span class="MJXp-mtext" id="MJXp-Span-35">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-36">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-37">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-38">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-39">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-40">L</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="8.417ex" height="2.057ex" viewBox="0 -780.1 3624 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMATHI-4E" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMATHI-63" x="1138" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMATHI-64" x="1572" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMATHI-6F" x="2095" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMATHI-74" x="2581" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMATHI-4C" x="2942" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-12"> N \ cdot L </script> 操作员在哪里 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-41"><span class="MJXp-mtext" id="MJXp-Span-42">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-43">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-44">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-45">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-46">t</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.771ex" height="2.057ex" viewBox="0 -780.1 2054 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMATHI-63" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMATHI-64" x="683" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMATHI-6F" x="1207" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMATHI-74" x="1692" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-13"> \ cdot </script> 称为<strong>标量产品</strong> 。 <br><br>  （1） <p><math> </math> $$ display $$ \开始{equation *} I = N \ cdot L \ end {equation *} $$ display $$ </p><br> 标量积是两个向量彼此相对“重合”的量度，并且与 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-53"><span class="MJXp-mo" id="MJXp-Span-54" style="margin-left: 0em; margin-right: 0.111em;">+</span><span class="MJXp-mn" id="MJXp-Span-55">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.971ex" height="2.057ex" viewBox="0 -728.2 1279 885.9" role="img" focusable="false" style="vertical-align: -0.366ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-2B" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-31" x="778" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-15"> + 1 </script>  （对于两个相同的向量） <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-56"><span class="MJXp-mo" id="MJXp-Span-57" style="margin-left: 0em; margin-right: 0.111em;">−</span><span class="MJXp-mn" id="MJXp-Span-58">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.971ex" height="2.057ex" viewBox="0 -728.2 1279 885.9" role="img" focusable="false" style="vertical-align: -0.366ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-2212" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-31" x="778" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-16"> -1 </script>  （针对两个相反的向量）。 标量产品是着色的基础，我在《 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">基于物理的渲染和照明模型》</a>教程中对此进行了详细研究。 <br><br><h3> 实作 </h3><br> 和 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-59"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-60">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-17-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.064ex" height="2.057ex" viewBox="0 -780.1 888.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMATHI-4E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-17"> N </script> 和 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-61"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-62">L</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-18-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.583ex" height="2.057ex" viewBox="0 -780.1 681.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMATHI-4C" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-18"> L </script> 您可以通过<code>s.Normal</code>和<code>gi.light.dirin</code>轻松访问曲面着色器照明功能。 为简单起见，我们将在着色器代码中将它们重命名为<code>N</code>和<code>L</code> <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DiffuseColor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 N, float3 L)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> NdotL = saturate( dot(N, L) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NdotL; }</code> </pre> <br>  <code>saturate</code>功能会限制 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-63"><span class="MJXp-mn" id="MJXp-Span-64">0</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-30" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-19"> 0 </script> 之前 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-65"><span class="MJXp-mn" id="MJXp-Span-66">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-20-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-31" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-20"> 1 </script>  。 但是，由于标量积在 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-67"><span class="MJXp-mo" id="MJXp-Span-68" style="margin-left: 0em; margin-right: 0.111em;">−</span><span class="MJXp-mn" id="MJXp-Span-69">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-21-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.971ex" height="2.057ex" viewBox="0 -728.2 1279 885.9" role="img" focusable="false" style="vertical-align: -0.366ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-2212" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-31" x="778" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-21"> -1 </script> 之前 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-70"><span class="MJXp-mo" id="MJXp-Span-71" style="margin-left: 0em; margin-right: 0.111em;">+</span><span class="MJXp-mn" id="MJXp-Span-72">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-22-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.971ex" height="2.057ex" viewBox="0 -728.2 1279 885.9" role="img" focusable="false" style="vertical-align: -0.366ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-2B" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-31" x="778" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-22"> + 1 </script>  ，我们将只需要使用其负值即可。 这就是为什么通常按以下方式实现Lambert反射的原因： <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> NdotL = max(<span class="hljs-number"><span class="hljs-number">0</span></span>, dot(N, L) );</code> </pre> <br><h2> 周围光线的对比反射 </h2><br> 尽管兰伯特的反射可以很好地遮盖大多数材料，但它的物理准确性和真实感均不高。 在较早的游戏中，Lambert着色器得到了广泛使用。 使用这种技术的游戏通常<em>看起来很</em>旧，因为它们可能会无意间重现旧游戏的美感。 如果您不为此而努力，则应避免进行Lambert反射，而应使用更现代的技术。 <br><br> 一个这样的模型就是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer">Oren-Nayyar反射模型</a> ，该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer">模型</a>最初在1994年由Michael Oren和Sri C. Nayyar发表<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer">的Lambert反射模型的</a>概述中概述。  Oren-Nayyar模型是Lambert反射的概括，是专门为粗糙表面设计的。 最初，Journey开发人员希望使用Oren-Nayyar反射作为其沙着色器的基础。 但是，由于计算成本高，这个想法被放弃了。 <br><br> 技术艺术家约翰·爱德华兹（John Edwards）在其2013年的报告中解释说，为旅程沙创建的反射模型是基于一系列的反复试验而开发的，开发人员的意图不是重现沙漠的逼真的渲染效果，而是将生命带入一种具体的，可立即识别的美学中。 <br><br> 据他介绍，生成的阴影模型对应于以下等式： <br><br>  （2） <p><math> </math> $$显示$$ \开始{等式*} I = 4 * \左（\左（N \ odot \左[1，0.3，1 \右] \右）\ cdot L \右）\结束{等式*} $$显示$$ </p><br> 在哪里 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-96"><span class="MJXp-mtext" id="MJXp-Span-97">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-98">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-99">d</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-100">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-101">t</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-24-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="4.891ex" height="2.057ex" viewBox="0 -780.1 2106 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMATHI-6F" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMATHI-64" x="735" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMATHI-6F" x="1259" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMATHI-74" x="1744" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-24"> \ odot </script>  - <strong>元素</strong> -两个向量的<strong>明智积</strong> 。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DiffuseColor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 N, float3 L)</span></span></span><span class="hljs-function"> </span></span>{ Ny *= <span class="hljs-number"><span class="hljs-number">0.3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> NdotL = saturate(<span class="hljs-number"><span class="hljs-number">4</span></span> * dot(N, L)); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> NdotL; }</code> </pre> <br> 反射模型（2）约翰·爱德华兹（John Edwards）称其为<strong>漫反射</strong> ，因此我们将在整个教程中使用该名称。 <br><br> 下面的动画显示了Lambert阴影（左）和“旅程”（Journey）的漫反射（右）的差异。 <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/q-hQiDA71Yg" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><div class="spoiler">  <b class="spoiler_title">4和0.3是什么意思？</b> <div class="spoiler_text"> 尽管漫射对比度的设计并非物理上准确，但我们仍然可以尝试了解它的作用。 <br><br> 它的核心仍然使用Lambert反射。 第一个明显的区别是，总结果乘以 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-102"><span class="MJXp-mn" id="MJXp-Span-103"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-25-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="2.074ex" viewBox="0 -772.3 500.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-34" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-25"> 4 </script>  。 这意味着正常接收的所有像素 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-104"><span class="MJXp-mn" id="MJXp-Span-105"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">25 </font></font></span><span class="MJXp-mtext" id="MJXp-Span-106" style="color: red;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\％</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-26-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.414ex" height="2.762ex" viewBox="0 -831.5 2331 1189" role="img" focusable="false" style="vertical-align: -0.83ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-32"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-35" x="500" y="0"></use><g fill="red" stroke="red" transform="translate(1001,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-5C"></use><g transform="translate(500,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(59.251) matrix(1 0 0 -1 0 0)">％</text></g></g></g></svg></span><script type="math/tex" id="MathJax-Element-26"> 25 \％</script> 照明会像接收 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-107"><span class="MJXp-mn" id="MJXp-Span-108"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">100 </font></font></span><span class="MJXp-mtext" id="MJXp-Span-109" style="color: red;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\％</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-27-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="6.576ex" height="2.762ex" viewBox="0 -831.5 2831.5 1189" role="img" focusable="false" style="vertical-align: -0.83ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-31"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-30" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-30" x="1001" y="0"></use><g fill="red" stroke="red" transform="translate(1501,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-5C"></use><g transform="translate(500,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(59.251) matrix(1 0 0 -1 0 0)">％</text></g></g></g></svg></span><script type="math/tex" id="MathJax-Element-27"> 100 \％</script> 照明。 通过乘以一切 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-110"><span class="MJXp-mn" id="MJXp-Span-111"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">4</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-28-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="2.074ex" viewBox="0 -772.3 500.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-34" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-28"> 4 </script> 根据Lambert的说法，弱阴影会变得更强，而黑暗和明亮之间的过渡区域会更小。 在这种情况下，阴影会变得更加清晰。 <br><br>  <code>y</code>分量相乘对法线方向的影响 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-112"><span class="MJXp-mn" id="MJXp-Span-113"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0.3</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-29-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.972ex" height="2.074ex" viewBox="0 -772.3 1279.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-30"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-2E" x="500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-33" x="779" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-29"> 0.3 </script> 解释要困难得多。 随着矢量分量的变化，其指向的大致方向也发生变化。 降低<code>y</code>分量的价值 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-114"><span class="MJXp-mn" id="MJXp-Span-115"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">30 </font></font></span><span class="MJXp-mtext" id="MJXp-Span-116" style="color: red;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\％</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-30-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="5.414ex" height="2.762ex" viewBox="0 -831.5 2331 1189" role="img" focusable="false" style="vertical-align: -0.83ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-33"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-30" x="500" y="0"></use><g fill="red" stroke="red" transform="translate(1001,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-5C"></use><g transform="translate(500,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(59.251) matrix(1 0 0 -1 0 0)">％</text></g></g></g></svg></span><script type="math/tex" id="MathJax-Element-30"> 30 \％</script> 从其原始值开始，漫反射的反射会导致阴影变得更加垂直。 <br><br> 注意：标量乘积仅在两个向量都具有长度时才直接测量它们之间的角度 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-117"><span class="MJXp-mn" id="MJXp-Span-118"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1个</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-31-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="2.074ex" viewBox="0 -772.3 500.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-31" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-31"> 1 </script>  。 所做的更改减少了正常长度 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-119"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-120"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ñ</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-32-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.064ex" height="2.074ex" viewBox="0 -772.3 888.5 892.8" role="img" focusable="false" style="vertical-align: -0.28ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMATHI-4E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-32"> N </script> 不再是单位向量。 </div></div><br><h2> 从灰色到彩色 </h2><br> 上面显示的所有动画都有灰色阴影，因为它们显示了反射模型的值，从 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-121"><span class="MJXp-mn" id="MJXp-Span-122">0</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-33-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-30" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-33"> 0 </script> 之前 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-123"><span class="MJXp-mn" id="MJXp-Span-124">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-34-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="1.162ex" height="1.937ex" viewBox="0 -728.2 500.5 834" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-31" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-34"> 1 </script>  “我们可以通过使用<code>NdotL</code>作为两种颜色之间的插值系数来轻松添加颜色：一种用于完全着色，另一种用于完全照亮的沙子。 <br><br><pre> <code class="cpp hljs">float3 _TerrainColor; float3 _ShadowColor; <span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DiffuseColor</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 N, float3 L)</span></span></span><span class="hljs-function"> </span></span>{ Ny *= <span class="hljs-number"><span class="hljs-number">0.3</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> NdotL = saturate(<span class="hljs-number"><span class="hljs-number">4</span></span> * dot(N, L)); float3 color = lerp(_ShadowColor, _TerrainColor, NdotL); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> color; }</code> </pre> <br><h2> 第3部分。普通砂 </h2><br> 在第三部分中，我们将专注于创建将平滑3D模型转换为沙丘的法线贴图。 <br><br> 在本教程的前一部分中，我们实现了Journey沙的漫反射照明。 仅使用此效果时，沙漠沙丘看起来会很平坦且无聊。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8cb/dd6/9a8/8cbdd69a8a92614469132400c0979c79.png"></div><br> 旅程最吸引人的效果之一是沙粒感。 查看任何屏幕截图，在我们看来，沙丘不是光滑均匀的，而是由数百万个细微的沙粒产生的。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e93/307/efc/e93307efce359d4830f5894dde30c9e6.jpg"></div><br> 可以使用一种称为“ <strong>凹凸贴图”</strong>的技术来实现此效果，该技术可以使光从平面反弹，就好像它更复杂一样。 查看此效果如何更改渲染的外观： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/90f/9b4/73f/90f9b473f7d1eefcb6ca32871300fed8.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/07a/739/06d/07a73906d58ed9d4c251340b4e92d7f5.png"></div><br> 随着增加，可以看到小的差异： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ea7/3d5/b3f/ea73d5b3fb56c941c9b61f022dcb8699.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f8/efa/5c4/2f8efa5c4926a0de947b8ff91e114498.png"></div><br><h2> 我们处理法线贴图 </h2><br> 沙子由无数的沙粒组成，每种沙粒都有自己的形状和成分（请参见下文）。 每个单独的粒子在潜在的随机方向上反射照明。 实现此效果的一种方法是创建一个包含所有这些微观沙粒的3D模型。 但是由于所需的多边形数量惊人，这种方法不可行。 <br><br> 但是，与真实的3D模型相比，还有另一种解决方案通常用于模拟更复杂的几何图形。  3D模型的每个顶点或面都与一个称为其<strong>法线方向</strong>的参数相关联。 这是一个单位长度向量，用于计算3D模型表面上的光反射。 也就是说，要模拟沙子，您需要模拟这种看似随机的沙粒分布，并因此模拟它们如何影响表面法线。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/413/bc4/cc3/413bc4cc3466b827a1a1d86559d54054.jpg"></div><br> 这可以以无数种方式完成。 最简单的方法是创建一个更改沙丘模型原始法线方向的纹理。 <br><br>  <strong>垂直于表面</strong> <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-125"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-126">N</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-35-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="2.064ex" height="2.057ex" viewBox="0 -780.1 888.5 885.9" role="img" focusable="false" style="vertical-align: -0.246ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMATHI-4E" x="0" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-35"> N </script> 在一般情况下，它是根据3D模型的几何形状计算的。 但是，您可以使用<strong>法线贴图</strong>对其进行修改。 法线贴图是一种纹理，可通过更改法线相对于曲面的局部方向来模拟更复杂的几何形状。 这种技术通常称为<strong>凹凸贴图</strong> 。 <br><br> 更改法线是一个相当简单的任务，可以在<strong>曲面着色器</strong>的<code>surf</code>功能中执行。 此函数有两个参数，其中一个是名为<code>SurfaceOutput</code>的<code>struct</code> 。 它包含渲染3D模型一部分所需的所有属性，从其颜色（ <code>o.Albedo</code> ）到透明度（ <code>o.Alpha</code> ）。 它包含的另一个参数是法线方向（ <code>o.Normal</code> ），可以对其进行重写以更改光在模型上的反射方式。 <br><br> 根据有关<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer">Surface Shaders</a>的Unity文档，所有写入<code>o.Normal</code>结构的法线必须在<strong>切线空间中</strong>表示： <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SurfaceOutput</span></span></span><span class="hljs-class"> {</span></span> fixed3 Albedo; <span class="hljs-comment"><span class="hljs-comment">// diffuse color fixed3 Normal; // tangent space normal, if written fixed3 Emission; half Specular; // specular power in 0..1 range fixed Gloss; // specular intensity fixed Alpha; // alpha for transparencies };</span></span></code> </pre> <br> 因此，我们可以报告必须在相对于网格法线的坐标系中表示单位矢量。 例如，当写入<code>o.Normal</code> <code>float3(0, 0, 1)</code> normal的值将保持不变。 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span></span></span><span class="hljs-function"> </span></span>{ o.Albedo = _SandColor; o.Alpha = <span class="hljs-number"><span class="hljs-number">1</span></span>; o.Normal = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); }</code> </pre> <br> 这是因为向量<code>float3(0, 0, 1)</code>实际上是相对于3D模型的几何形状表示的法向向量。 <br><br> 因此，要更改<strong>表面着色器中</strong>表面的法线，我们只需要在<code>o.Normal</code>中<strong>的表面函数</strong>中编写一个新向量： <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span></span></span><span class="hljs-function"> </span></span>{ o.Albedo = _SandColor; o.Alpha = <span class="hljs-number"><span class="hljs-number">1</span></span>; o.Normal = ... <span class="hljs-comment"><span class="hljs-comment">// change the normal here }</span></span></code> </pre> <br> 在文章的其余部分，我们将创建初始近似值，并将在本教程的第六部分中使之复杂化。 <br><br><h2> 沙正常 </h2><br> 最具问题的部分是了解沙粒<em>如何</em>垂直于表面变化。 尽管每个沙粒都可以单独将光散射到任何方向，但总的来说，还是会发生其他情况。 任何物理上准确的方法都应研究砂表面法线向量的分布并对其进行数学建模。 这样的模型确实存在，但是本教程中介绍的解决方案要简单得多，同时非常有效。 <br><br> 在模型的每个点上，从纹理中采样一个<strong>随机单位向量</strong> 。 然后，表面法线向此向量倾斜一定量。 通过正确创建随机纹理并选择适当的混合量，我们可以将法线移动到表面，从而营造出颗粒感，而不会丢失沙丘的整体曲率。 <br><br> 可以使用填充有随机颜色的纹理对随机值进行采样。 每个像素的分量R，G和B用作法线向量的分量X，Y和Z。 颜色成分在范围内 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-127"><span class="MJXp-mtext" id="MJXp-Span-128" style="color: red;">\左</span><span class="MJXp-mo" id="MJXp-Span-129" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mn" id="MJXp-Span-130">0</span><span class="MJXp-mrow" id="MJXp-Span-131"><span class="MJXp-mo" id="MJXp-Span-132" style="margin-left: 0.278em; margin-right: 0.278em;">，</span></span><span class="MJXp-mn" id="MJXp-Span-133">1</span><span class="MJXp-mtext" id="MJXp-Span-134" style="color: red;">\右</span><span class="MJXp-mo" id="MJXp-Span-135" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-36-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="11.727ex" height="2.66ex" viewBox="0 -832 5049 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g fill="red" stroke="red"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-5C"></use><g transform="translate(500,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">左</text></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-5B" x="1330" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-30" x="1608" y="0"></use><g transform="translate(2109,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">，</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-31" x="2939" y="0"></use><g fill="red" stroke="red" transform="translate(3439,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-5C"></use><g transform="translate(500,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">右</text></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-5D" x="4770" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-36"> \左[0，1 \右] </script>  ，因此需要将它们转换为间隔 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-136"><span class="MJXp-mtext" id="MJXp-Span-137" style="color: red;">\左</span><span class="MJXp-mo" id="MJXp-Span-138" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mo" id="MJXp-Span-139" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mn" id="MJXp-Span-140">1</span><span class="MJXp-mrow" id="MJXp-Span-141"><span class="MJXp-mo" id="MJXp-Span-142" style="margin-left: 0.278em; margin-right: 0.278em;">，</span></span><span class="MJXp-mo" id="MJXp-Span-143" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mn" id="MJXp-Span-144">1</span><span class="MJXp-mtext" id="MJXp-Span-145" style="color: red;">\右</span><span class="MJXp-mo" id="MJXp-Span-146" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-37-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="16.375ex" height="2.66ex" viewBox="0 -832 7050.4 1145.2" role="img" focusable="false" style="vertical-align: -0.728ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g fill="red" stroke="red"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-5C"></use><g transform="translate(500,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">左</text></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-5B" x="1330" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-2212" x="1608" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-31" x="2387" y="0"></use><g transform="translate(2887,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">，</text></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-2B" x="3940" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-31" x="4940" y="0"></use><g fill="red" stroke="red" transform="translate(5441,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-5C"></use><g transform="translate(500,0)"><text font-family="STIXGeneral,'Arial Unicode MS',serif" stroke="none" transform="scale(51.874) matrix(1 0 0 -1 0 0)">右</text></g></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=https://habr.com/ru/post/476448/&amp;usg=ALkJrhg52na2A849RkbvIKZDCyXteucC-g#MJMAIN-5D" x="6771" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-37"> \左[-1，+ 1 \右] </script>  。 然后将所得向量归一化，使其长度等于 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-147"><span class="MJXp-mn" id="MJXp-Span-148">1</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-38-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-38"> 1 </script>  。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0d2/c95/03d/0d2c9503d98fd2463e7e3682743736bd.png"></div><br><div class="spoiler">  <b class="spoiler_title">创建随机纹理</b> <div class="spoiler_text"> 有很多方法可以生成随机纹理。 为了获得理想的效果，最重要的是可以从纹理中采样的随机向量的一般分布。 <br><br> 在上图中，每个像素都是完全随机的。 纹理中没有占主导地位的方向（颜色），因为每个值与其他所有值具有相同的概率。 这种纹理给我们提供了一种可以在所有方向散射光的沙子。 <br><br> 在GDC演讲中，约翰·爱德华兹（John Edwards）明确指出，《旅途》中沙子的随机纹理是由高斯分布生成的。 这样可以确保主要方向与曲面的法线重合。 </div></div><br><div class="spoiler">  <b class="spoiler_title">是否需要对随机向量进行归一化？</b> <div class="spoiler_text"> 我用来采样随机向量的图像是使用完全随机的过程生成的。 不仅每个像素都是单独生成的：一个像素的分量R，G和B也彼此独立。 也就是说，在一般情况下，不能保证从该纹理采样的向量的长度等于 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-149"><span class="MJXp-mn" id="MJXp-Span-150"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1个</font></font></span></span></span><script type="math/tex" id="MathJax-Element-39"> 1 </script>  。 <br><br> 当然，您可以生成一个纹理，其中 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-151"><span class="MJXp-mtext" id="MJXp-Span-152" style="color: red;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\左</font></font></span><span class="MJXp-mo" id="MJXp-Span-153" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[ </font></font></span><span class="MJXp-mn" id="MJXp-Span-154"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 </font></font></span><span class="MJXp-mrow" id="MJXp-Span-155"><span class="MJXp-mo" id="MJXp-Span-156" style="margin-left: 0.278em; margin-right: 0.278em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></span></span><span class="MJXp-mn" id="MJXp-Span-157"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 1 </font></font></span><span class="MJXp-mtext" id="MJXp-Span-158" style="color: red;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\右</font></font></span><span class="MJXp-mo" id="MJXp-Span-159" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">]</font></font></span></span></span><script type="math/tex" id="MathJax-Element-40"> \左[0，1 \右] </script> 在 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-160"><span class="MJXp-mtext" id="MJXp-Span-161" style="color: red;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\左</font></font></span><span class="MJXp-mo" id="MJXp-Span-162" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[ </font></font></span><span class="MJXp-mo" id="MJXp-Span-163" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mn" id="MJXp-Span-164"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mrow" id="MJXp-Span-165"><span class="MJXp-mo" id="MJXp-Span-166" style="margin-left: 0.278em; margin-right: 0.278em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，</font></font></span></span><span class="MJXp-mo" id="MJXp-Span-167" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> + </font></font></span><span class="MJXp-mn" id="MJXp-Span-168"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><span class="MJXp-mtext" id="MJXp-Span-169" style="color: red;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">\右</font></font></span><span class="MJXp-mo" id="MJXp-Span-170" style="margin-left: 0em; margin-right: 0em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">]</font></font></span></span></span><script type="math/tex" id="MathJax-Element-41"> \左[-1，+ 1 \右] </script> 而且实际上必须要有一定的长度 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-171"><span class="MJXp-mn" id="MJXp-Span-172"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1个</font></font></span></span></span><script type="math/tex" id="MathJax-Element-42"> 1 </script>  。 但是，这里出现两个问题。 <br><br> ,             . -,    <em> </em>   mip-,             . <br><br>   ,    . </div></div><br><h2> 实作 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在教程的上半部分，我们介绍了“法线贴图”的概念，它出现在</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">曲面函数的</font></font></strong> <font style="vertical-align: inherit;"><font style="vertical-align: inherit;">第一个轮廓</font><strong><font style="vertical-align: inherit;">中</font></strong></font><code>surf</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。回顾本文开头显示的图，您可以看到需要两个效果来重新创建Journey sand的渲染。第一次（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">正常砂</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">），我们考虑在文章的这一部分，而第二（</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">沙浪</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）检查第六部分。</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">surf</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Input IN, inout SurfaceOutput o)</span></span></span><span class="hljs-function"> </span></span>{ o.Albedo = _SandColor; o.Alpha = <span class="hljs-number"><span class="hljs-number">1</span></span>; float3 N = float3(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); N = RipplesNormal(N); <span class="hljs-comment"><span class="hljs-comment">// Covered in Journey Sand Shader #6 N = SandNormal (N); // Covered in this article o.Normal = N; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">在上一节中，我们介绍了凹凸贴图的概念，该概念向我们展示了部分效果将需要对纹理进行采样（在代码中称为</font></font><code>uv_SandTex</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上面的代码的问题是，对于计算，您需要知道我们要绘制的点的真实位置。实际上，您需要一个</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">UV坐标</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">来对纹理进行采样</font><font style="vertical-align: inherit;">，从而确定要读取的像素。如果我们使用的3D模型相对平坦并且具有UV转换，则可以使用其UV采样随机纹理。</font></font><br><br><pre> <code class="cpp hljs">N = WavesNormal(IN.uv_SandTex.xy, N); N = SandNormal (IN.uv_SandTex.xy, N);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或者，您也可以使用</font></font><code>IN.worldPos</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">渲染点</font><font style="vertical-align: inherit;">在世界（</font><font style="vertical-align: inherit;">）中的位置。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">现在，我们终于可以集中精力</font></font><code>SandNormal</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">执行它了。</font><font style="vertical-align: inherit;">如本部分前面所述，其思想是从随机纹理中采样像素并将其（转换为单位矢量后）用作新法线。</font></font><br><br><pre> <code class="cpp hljs">sampler2D_float _SandTex; <span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SandNormal</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 uv, float3 N)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Random vector float3 random = tex2D(_SandTex, uv).rgb; // Random direction // [0,1]-&gt;[-1,+1] float3 S = normalize(random * 2 - 1); return S; }</span></span></code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如何缩放随机纹理？</font></font></b> <div class="spoiler_text">    UV- 3D-      ,   .      ,       . <br><br>   ,  Unity   .   ,        <code>_SandText_ST</code> . Unity       (  ) <code>_SandTex</code> . <br><br>  <code>_SandText_ST</code>    :     .        ,          <em>Tiling</em>  <em>Offset</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f29/a84/059/f29a84059ab970f412217f09c87fcf6f.png"></div><br>       ,     <code>TRANSFORM_TEX</code> : <br><br><pre> <code class="cpp hljs">sampler2D_float _SandTex; float4 _SandTex_ST; <span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SandNormal</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 uv, float3 N)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Random vector float3 random = tex2D(_SandTex, TRANSFORM_TEX(uv, _SandTex)).rgb; // Random direction // [0,1]-&gt;[-1,+1] float3 S = normalize(random * 2 - 1); return S; }</span></span></code> </pre> </div></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 倾斜法线 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">上面显示的代码段有效，但效果不佳。原因很简单：如果我们只返回完全随机的法线，但实际上会失去曲率的感觉。实际上，法线方向用于计算光应如何从表面反射，其主要目的是根据模型的曲率对模型进行着色。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">差异可以在下面的图片中看到。在上面，沙丘的法线是完全随机的，并且不可能理解一个结束而另一个开始的位置。从下面开始，仅使用模型的法线，因此我们得到的表面过于光滑。</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/620/9cb/acb/6209cbacb616db15bee5f95e314779c8.png"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/476/f0a/f25/476f0af2535dc2d552ce4b01a1d7751a.png"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两种解决方案都不适合我们。</font><font style="vertical-align: inherit;">我们之间需要一些东西。</font><font style="vertical-align: inherit;">从纹理采样的随机方向应用于</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">将</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">法线</font><em><font style="vertical-align: inherit;">倾斜</font></em><font style="vertical-align: inherit;">一定量，如下所示：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/929/dfb/7e6/929dfb7e6d4712b7c69a403d0733c25b.png" width="239" height="240"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">图中描述的操作称为</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">slerp</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，代表</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">球面线性插值</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（球面线性插值）。</font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Slerp的</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">工作原理与lerp完全相同，但有一个例外-它可用于在单位向量之间安全地插值，并且运算的结果将是其他单位向量。</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">不幸的是，slerp的正确实现非常昂贵。</font><font style="vertical-align: inherit;">为了获得效果，至少基于偶然性，使用它是不合逻辑的。</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">给我看slerp方程</font></font></b> <div class="spoiler_text">    , <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-173"><span class="MJXp-msubsup" id="MJXp-Span-174"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-175" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-176" style="vertical-align: -0.4em;">0</span></span></span></span><script type="math/tex" id="MathJax-Element-43">p_0</script> 和 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-177"><span class="MJXp-msubsup" id="MJXp-Span-178"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-179" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-180" style="vertical-align: -0.4em;">1</span></span></span></span><script type="math/tex" id="MathJax-Element-44">p_1</script>   ,       . 然后 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-181"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-182">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-183">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-184">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-185">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-186">p</span></span></span><script type="math/tex" id="MathJax-Element-45">slerp</script>    : <br><br> (1) <p><math> <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-187"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-188">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-189">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-190">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-191">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-192">p</span><span class="MJXp-mrow" id="MJXp-Span-193"><span class="MJXp-mo" id="MJXp-Span-194" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.244em;"><span class="MJXp-right MJXp-scale7" style="font-size: 1.978em; margin-left: -0.05em;">(</span></span><span class="MJXp-msubsup" id="MJXp-Span-195"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-196" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-197" style="vertical-align: -0.4em;">0</span></span><span class="MJXp-mo" id="MJXp-Span-198" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-msubsup" id="MJXp-Span-199"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-200" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-201" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-202" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-203">t</span><span class="MJXp-mo" id="MJXp-Span-204" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.244em;"><span class="MJXp-right MJXp-scale7" style="font-size: 1.978em; margin-left: -0.05em;">)</span></span></span><span class="MJXp-mo" id="MJXp-Span-205" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mfrac" id="MJXp-Span-206" style="vertical-align: 0.25em;"><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-207">sin</span><span class="MJXp-mo" id="MJXp-Span-208" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mrow" id="MJXp-Span-209"><span class="MJXp-mo" id="MJXp-Span-210" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mrow" id="MJXp-Span-211"><span class="MJXp-mo" id="MJXp-Span-212" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mn" id="MJXp-Span-213">1</span><span class="MJXp-mo" id="MJXp-Span-214" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-215">t</span><span class="MJXp-mo" id="MJXp-Span-216" style="margin-left: 0em; margin-right: 0em;">)</span></span><span class="MJXp-mi" id="MJXp-Span-217">Ω</span><span class="MJXp-mo" id="MJXp-Span-218" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-219">sin</span><span class="MJXp-mo" id="MJXp-Span-220" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mrow" id="MJXp-Span-221"><span class="MJXp-mo" id="MJXp-Span-222" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi" id="MJXp-Span-223">Ω</span><span class="MJXp-mo" id="MJXp-Span-224" style="margin-left: 0em; margin-right: 0em;">)</span></span></span></span></span></span></span><span class="MJXp-msubsup" id="MJXp-Span-225"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-226" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-227" style="vertical-align: -0.4em;">0</span></span><span class="MJXp-mo" id="MJXp-Span-228" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mfrac" id="MJXp-Span-229" style="vertical-align: 0.25em;"><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-230">sin</span><span class="MJXp-mo" id="MJXp-Span-231" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mrow" id="MJXp-Span-232"><span class="MJXp-mo" id="MJXp-Span-233" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-234">t</span><span class="MJXp-mi" id="MJXp-Span-235">Ω</span><span class="MJXp-mo" id="MJXp-Span-236" style="margin-left: 0em; margin-right: 0em;">)</span></span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-237">sin</span><span class="MJXp-mo" id="MJXp-Span-238" style="margin-left: 0em; margin-right: 0em;"></span><span class="MJXp-mrow" id="MJXp-Span-239"><span class="MJXp-mo" id="MJXp-Span-240" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi" id="MJXp-Span-241">Ω</span><span class="MJXp-mo" id="MJXp-Span-242" style="margin-left: 0em; margin-right: 0em;">)</span></span></span></span></span></span></span><span class="MJXp-msubsup" id="MJXp-Span-243"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-244" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-245" style="vertical-align: -0.4em;">1</span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-46">\begin{equation*} slerp\left(p_0, p_1, t\right) = \frac{\sin\left[\left(1-t\right)\Omega\right]}{\sin\left(\Omega\right)}p_0 + \frac{\sin\left(t\Omega\right)}{\sin\left(\Omega\right)} p_1 \end{equation*}</script> </math></p><br>  <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-246"><span class="MJXp-mi" id="MJXp-Span-247">Ω</span></span></span><script type="math/tex" id="MathJax-Element-47">\Omega</script> —     <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-248"><span class="MJXp-msubsup" id="MJXp-Span-249"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-250" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-251" style="vertical-align: -0.4em;">0</span></span></span></span><script type="math/tex" id="MathJax-Element-48">p_0</script> 和 <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-252"><span class="MJXp-msubsup" id="MJXp-Span-253"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-254" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-255" style="vertical-align: -0.4em;">1</span></span></span></span><script type="math/tex" id="MathJax-Element-49">p_1</script> ,       : <br><br> (2) <p><math> <span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-256"><span class="MJXp-mi" id="MJXp-Span-257">Ω</span><span class="MJXp-mo" id="MJXp-Span-258" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-259">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-260">o</span><span class="MJXp-msubsup" id="MJXp-Span-261"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-262" style="margin-right: 0.05em;">s</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-263" style="vertical-align: 0.5em;"><span class="MJXp-mo" id="MJXp-Span-264">−</span><span class="MJXp-mn" id="MJXp-Span-265">1</span></span></span><span class="MJXp-mrow" id="MJXp-Span-266"><span class="MJXp-mo" id="MJXp-Span-267" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.244em;"><span class="MJXp-right MJXp-scale7" style="font-size: 1.978em; margin-left: -0.05em;">(</span></span><span class="MJXp-msubsup" id="MJXp-Span-268"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-269" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-270" style="vertical-align: -0.4em;">0</span></span><span class="MJXp-mo" id="MJXp-Span-271" style="margin-left: 0.267em; margin-right: 0.267em;">⋅</span><span class="MJXp-msubsup" id="MJXp-Span-272"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-273" style="margin-right: 0.05em;">p</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-274" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-275" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.244em;"><span class="MJXp-right MJXp-scale7" style="font-size: 1.978em; margin-left: -0.05em;">)</span></span></span></span></span><script type="math/tex; mode=display" id="MathJax-Element-50">\begin{equation*} \Omega=cos^{-1} \left(p_0 \cdot p_1 \right) \end{equation*}</script> </math></p><br></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">重要的是要注意，如果我们使用传统的</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">线性插值</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">，则结果向量将看起来非常不同：</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/eef/5e1/42f/eef5e142f1c8c05cac9b3d4f18d8e097.png" width="239" height="240"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">两个单独的单位向量之间的Lerp操作并不总是创建其他单位向量。</font><font style="vertical-align: inherit;">实际上，除非系数为</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-276"><span class="MJXp-mn" id="MJXp-Span-277"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">或</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-51-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-51">1</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-278"><span class="MJXp-mn" id="MJXp-Span-279"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-52-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-52">0</script>  。 <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 尽管如此，对lerp结果进行归一化实际上会导致单位向量出奇地接近slerp生成的结果： </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nlerp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float3 n1, float3 n2, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> t)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> normalize(lerp(n1, n2, t)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">这种称为</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">nlerp的</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">技术</font><font style="vertical-align: inherit;">提供了slerp的近似值。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;">证人</font></a><font style="vertical-align: inherit;">的开发商之一</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">凯西•穆拉托里</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">（</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;">Casey Muratori</font></a><font style="vertical-align: inherit;">）推广了它的使用</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">如果您有兴趣了解有关此主题的更多信息，建议阅读</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;">了解Slerp的文章。</font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;">然后，</font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;">Jonathan Blow</font></a><font style="vertical-align: inherit;">和</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;">Math Magician-Lerp，Slerp和Nlerp </font></a><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;">不使用它</font></a><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">多亏了nlerp，我们现在可以有效地将法线向量倾斜到一个随机面，该样本取自</font><font style="vertical-align: inherit;">：</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"></font></a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><code>_SandTex</code><font style="vertical-align: inherit;"></font><br><br><pre> <code class="cpp hljs">sampler2D_float _SandTex; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> _SandStrength; <span class="hljs-function"><span class="hljs-function">float3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SandNormal</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(float2 uv, float3 N)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Random vector float3 random = tex2D(_SandTex, uv).rgb; // Random direction // [0,1]-&gt;[-1,+1] float3 S = normalize(random * 2 - 1); // Rotates N towards Ns based on _SandStrength float3 Ns = nlerp(N, S, _SandStrength); return Ns; }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 结果如下所示： </font></font><br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/rddUAStRjZ8" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><br><h2> 接下来是什么 </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 在下一部分中，我们将考虑闪烁的反射，由于这些反射，沙丘将像海洋一样​​。 </font></font><br><br><h3> 致谢 </h3><br><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Journey</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">视频游戏</font><font style="vertical-align: inherit;">由</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Thatgamecompany</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">开发，</font><font style="vertical-align: inherit;">并由</font></font><strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sony Computer Entertainment发行</font></font></strong><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它可用于PC（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Epic Store</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）和PS4（</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PS Store</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">）。</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;">邓佳迪</font></a></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">创建沙丘背景和照明选项的3D模型</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">在（现已关闭）FacePunch论坛上找到了旅程角色的3D模型。</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><br><br><font style="vertical-align: inherit;"></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Unity包 </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">如果要重新创建此效果，则可以从</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="noopener noreferrer"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patreon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">下载完整的Unity包</font><font style="vertical-align: inherit;">。</font><font style="vertical-align: inherit;">它涵盖了您所需的一切，从着色器到3D模型。</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN476448/">https://habr.com/ru/post/zh-CN476448/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN476434/index.html">我们为废弃设备编写USB驱动程序</a></li>
<li><a href="../zh-CN476436/index.html">俄罗斯第一次机器人开发者会议上有关机器人操作系统的报告</a></li>
<li><a href="../zh-CN476442/index.html">给一些空间或微控制器，例如频率计</a></li>
<li><a href="../zh-CN476444/index.html">量子计算原理的神秘化</a></li>
<li><a href="../zh-CN476446/index.html">Jira Plugins：成功发明自行车的一些例子</a></li>
<li><a href="../zh-CN476450/index.html">cPanel概述-基于Web的控制台，用于管理站点和托管</a></li>
<li><a href="../zh-CN476452/index.html">键值存储，或者我们的应用程序变得更加便捷</a></li>
<li><a href="../zh-CN476454/index.html">5G即将到来：哪些公司将确保在2020年引入新技术</a></li>
<li><a href="../zh-CN476456/index.html">首先，中国的社会信用体系不是公民评估体系，而是庞大的API</a></li>
<li><a href="../zh-CN476460/index.html">互联网上第一个命中的文件格式不是MP3，而是MIDI</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>