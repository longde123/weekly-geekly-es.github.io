<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧠 🙆🏻 🧚🏿 Berjuang untuk sumber daya, bagian 4: Hebat ♊️ 🤧 🔔</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kami akan berurusan dengan regulator dari subsistem penyimpanan data dan melihat apa yang mereka izinkan Anda lakukan dalam arti blok I / O. 



 Yang...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Berjuang untuk sumber daya, bagian 4: Hebat</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/redhatrussia/blog/427413/">  Kami akan berurusan dengan regulator dari subsistem penyimpanan data dan melihat apa yang mereka izinkan Anda lakukan dalam arti blok I / O. <br><br><img src="https://habrastorage.org/webt/ny/q2/o8/nyq2o86wb7aywvoh0rovttforg4.png" width="100%"><br><br>  Yang sangat menarik di sini adalah bahwa kita memasuki wilayah di mana perubahan pada pengaturan yang dibuat setelah sistem diluncurkan jauh lebih tidak penting daripada keputusan yang dibuat bahkan sebelum penyebarannya. <br><a name="habracut"></a><br>  Lihatlah gambar di bawah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3t/ej/ka/3tejkahztgr18y5jt0dshicg7_w.png"></div><br><br>  Ini menyajikan empat sumber daya utama bahwa komputer modern perlu berfungsi dengan baik.  Penyelarasan kinerja adalah seni mendistribusikan sumber daya ini secara optimal di antara proses aplikasi.  Selain itu, semua sumber daya ini tidak terbatas dan tidak setara dalam hal dampak terhadap produktivitas. <br><br>  Kinerja subsistem penyimpanan direduksi menjadi kinerja teknologi penyimpanan yang digunakan di dalamnya: hard drive, SSD, SAN, NAS - mereka dapat sangat bervariasi dalam kecepatan akses dan throughput.  Dan prosesor yang kuat dan banyak memori tidak akan menyelamatkan situasi jika perangkat penyimpanan tidak memenuhi persyaratan tugas yang diselesaikan. <br><br>  Jika Anda, sebagai spesialis Linux, dapat memengaruhi keputusan perangkat keras, cobalah memastikan organisasi Anda memiliki platform penyimpanan yang memadai (atau lebih unggul).  Ini akan menghemat banyak masalah di masa depan. <br><br>  Sekarang mari kita lihat apa yang dapat dilakukan dengan bantuan kontrol input / output (I / O). <br><br><h3>  Ini semua tentang perangkat penyimpanan </h3><br>  Secara resmi, pengontrol I / O disebut blkio, tetapi dalam suasana hati yang baik, ia merespons ke Blocky.  Seperti pengontrol CPU, Blocky memiliki dua mode operasi: <br><br><ul><li> Penyesuaian menggunakan bola I / O relatif (saham), yang memungkinkan Anda untuk mengontrol kinerja di tingkat semua atau perangkat penyimpanan blok yang dipilih dengan menetapkan nilai dalam kisaran dari 10 hingga 1000. Secara default, 1000 digunakan, sehingga setiap perubahan hanya mengurangi bola I / O Pengguna atau layanan yang dipilih.  Mengapa 1000, bukan 1024, seperti dalam kasus CPU?  Pertanyaan yang bagus  Rupanya, ini adalah kasus ketika sifat terbuka Linux tidak baik untuknya. </li><li>  Penyesuaian bandwidth absolut untuk membatasi kecepatan baca dan / atau tulis untuk pengguna atau layanan tertentu.  Secara default, mode ini dinonaktifkan. </li></ul><br>  Tangkapan layar di bawah ini menunjukkan parameter yang dapat disesuaikan menggunakan perintah systemctl.  Di sini kami menggunakan keajaiban konfirmasi otomatis pada tombol Tab untuk menampilkan daftar opsi.  Ini disebut penyelesaian-bash, dan jika Anda masih tidak menggunakan fungsi ini, saatnya untuk menginstal PRM yang sesuai. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/if/ab/56/ifab56zoa8luqgywwlnw8igkdug.png"></div><br><br>  Bola I / O relatif dikontrol oleh parameter BlockIODeviceWeight dan BlockIOWeight.  Sebelum bermain dengan pengontrol ini, Anda perlu memahami ini: mereka hanya berfungsi jika Penjadwal I / O CFQ diaktifkan untuk perangkat penyimpanan. <br><br>  Apa itu penjadwal I / O?  Mari kita mulai dari jauh dan ingat bahwa kernel Linux bertanggung jawab untuk memastikan bahwa semua komponen perangkat keras komputer saling berkomunikasi dengan benar.  Dan karena semua komponen ini pada saat yang sama menginginkan hal yang berbeda, seseorang tidak dapat melakukannya tanpa memesan.  Nah, bagaimana kita, misalnya, mengatur hidup kita, menyusunnya untuk pekerjaan, istirahat, tidur, dan sebagainya. <br><br>  Jika kita berbicara tentang perangkat penyimpanan, maka penjadwal I / O bertanggung jawab untuk mengatur pekerjaan mereka di dalam kernel.  Ini hanya kode program yang mendefinisikan cara untuk mengontrol aliran data untuk perangkat blok, mulai dari USB flash drive dan hard drive ke disk virtual, yang sebenarnya file di suatu tempat di perangkat ISCI di SAN. <br><br>  Dan di atas semua perangkat ini yang dapat digunakan di Linux, ada berbagai tugas yang harus dilakukan komputer.  Selain itu, dalam kehidupan nyata, ada apa yang kami di Red Hat sebut "kasus penggunaan."  Itulah sebabnya ada berbagai perencana yang berfokus pada skenario yang berbeda.  Penjadwal ini disebut noop, deadline dan cfq.  Singkatnya, masing-masing dapat dijelaskan sebagai berikut: <br><br><ul><li>  Noop - cocok untuk perangkat penyimpanan blok yang tidak memiliki bagian yang berputar (flash, SSD, dll.). </li><li>  Tenggat adalah penjadwal ringan yang berfokus pada meminimalkan penundaan.  Secara default, ini mengutamakan membaca dengan mengorbankan penulisan, karena sebagian besar aplikasi gagal membaca. </li><li>  Cfq - berfokus pada distribusi bandwidth I / O yang adil pada tingkat sistem-lebar.  Dan seperti yang kami katakan di atas, ini adalah satu-satunya penjadwal yang mendukung opsi I / O relatif untuk cgroup. </li></ul><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://access.redhat.com/documentation/en-US/Red_Hat_Enterprise_Linux/7/html/Performance_Tuning_Guide/chap-Red_Hat_Enterprise_Linux-Performance_Tuning_Guide-Storage_and_File_Systems.html&amp;usg=ALkJrhj4T7JCxqPOQU5eMVsHA8Zs7-duIA#sect-Red_Hat_Enterprise_Linux-Performance_Tuning_Guide-Considerations-IO_Schedulers">Untuk informasi lebih lanjut tentang penjadwal</a> , lihat Panduan Penyesuaian Kinerja Red Hat Enterprise Linux 7. <br><br>  Apa semua diskusi tentang perencana ini?  Selain itu, pada kebanyakan komputer cfq TIDAK DIGUNAKAN secara default jika mereka tidak memiliki drive SATA.  Tanpa mengetahui hal ini, Anda dapat mengubah BlockIOWeight hingga Anda membiru tanpa efek apa pun.  Sayangnya, systemd tidak akan memberi tahu Anda: "Maaf, Anda mencoba mengubah parameter ini dengan sia-sia.  Ini tidak akan berfungsi karena perangkat menggunakan penjadwal yang salah. " <br><br>  Jadi bagaimana Anda bisa mengetahui tentang fitur "menarik" ini?  Seperti biasa, dari dokumentasi cgroup yang kami tulis di posting sebelumnya.  Itu selalu berguna untuk membiasakan diri dengan itu sebelum menggunakan ini atau regulator itu. <br><br><h3>  Kami lolos ke use case </h3><br><img src="https://habrastorage.org/webt/pn/2m/si/pn2msiycznzmeo8psaxktweeasu.jpeg" width="15%" align="right">  Sekali lagi kami beralih dari kata-kata umum ke spesifik: izinkan saya memperkenalkan Anda kepada Mr. Kryakin. <br><br>  Dia terlibat dalam katering, dan dia memiliki dua database di server aplikasi untuk melacak pesanan.  Bpk. Kryakin bersikeras bahwa basis data pesanan untuk hidangan bebek jauh lebih penting daripada basis untuk hidangan angsa, karena angsa adalah penipu di atas takhta unggas air. <br><br>  Kedua database dikonfigurasikan sebagai layanan, dan file unitnya terlihat seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dq/ad/ln/dqadlntguvbtnxbuyo4hubhk45e.png"></div><br><br>  Sebenarnya, skrip yang dipanggil (duck.sh dan angsa.sh) tidak melakukan pekerjaan nyata dalam database, tetapi hanya mensimulasikan membaca dan menulis menggunakan loop perintah dd.  Kedua skrip menggunakan sistem file / database, yang terletak pada disk virtualnya. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/yl/xc/zl/ylxczlywf_mf0hs4lyvwcytxzha.png"></div><br><br>  Mari kita lari bebek dan angsa dan melihat di mana mereka mendarat di hierarki cgroup: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ix/so/9i/ixso9ibunr1mx_fjsue7vmadg3g.png"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fv/mu/gn/fvmugnyyeapdmz2aftsdghnaloa.png"></div><br><br>  Dan sekarang, karena kita tahu PID dari proses dd, mari kita beralih ke perintah iotop untuk melihat apa yang terjadi di subsistem penyimpanan: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/c3/_1/9j/c3_19j2ttaybrv8thbpaf2qgchk.png"></div><br><br>  Ya, 12-14 MB / s ... tidak cepat.  Tampaknya Pak Kryakin tidak berinvestasi banyak dalam sistem penyimpanan data.  Meskipun kami sudah memiliki pertanyaan tentang kecukupannya, jadi tidak ada yang lebih mengejutkan. <br><br>  Sekarang kita melihat dua tugas kita: PID 3301 (angsa) dan PID 3300 (bebek).  Masing-masing menggunakan I / O di suatu tempat sekitar 6 MB / s.  Layar di atas adalah angka yang agak berbeda, tetapi dalam kenyataannya mereka terus-menerus melompat, dan rata-rata, kedua tugas ini sama-sama berbagi bandwidth perangkat penyimpanan. <br><br>  Tn. Kryakin ingin bebek memiliki bandwidth I / O setidaknya 5 kali lebih banyak daripada angsa, sehingga pesanan bebek selalu diproses terlebih dahulu.  Mari kita coba gunakan parameter BlockIOWeight untuk ini dengan perintah berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oo/3j/s8/oo3js8swjoqootxnzfdvpkc7aim.png"></div><br><br>  Kami melihat iotop dan melihat bahwa itu tidak berfungsi: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/kn/--/1z/kn--1zpltg4zia0utrxiqgyx4vm.png"></div><br><br>  Mari kita periksa penjadwal I / O untuk perangkat / dev / vdb: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/8e/fe/gj/8efegj18edawjsbs_u28rij2vta.png"></div><br><br>  Menarik ... Kami mencoba mengubah scheduler menjadi cfq dan tidak ada hasilnya.  Mengapa <br><br>  Faktanya adalah bahwa sistem kami berjalan pada mesin virtual KVM, dan ternyata mulai dari versi 7.1, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">penjadwal</a> tidak lagi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dapat diubah</a> di Red Hat Enterprise Linux.  Dan ini bukan bug, tetapi fitur yang berkaitan dengan peningkatan mekanisme untuk bekerja dengan perangkat I / O tervirtualisasi. <br><br>  Tapi jangan putus asa.  Kami memiliki dua parameter lagi yang dapat diubah: BlockIOReadBandwidth dan BlockIOWriteBandwidth beroperasi pada level perangkat blok dan mengabaikan penjadwal I / O.  Karena kita mengetahui bandwidth perangkat / dev / vdb (sekitar 14 MB / s untuk penerimaan dan untuk output), membatasi angsa menjadi 2 MB / s, kita tampaknya dapat memenuhi keinginan Tuan Kryakin.  Mari kita coba: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/3m/_g/_e/3m_g_eqnb7ninoyxp45yd1axjhw.png"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/48/_c/d4/48_cd4_nuqjq24heto7runam-io.png"></div><br><br>  Kita melihat: PID 3426, alias angsa, sekarang menggunakan I / O di suatu tempat sekitar 2 MB / s, dan PID 3425, yaitu, bebek, untuk hampir semua 14! <br><br>  Hore, kami melakukan apa yang diinginkan pelanggan, yang berarti kami menyelamatkan tidak hanya sejumlah angsa, tetapi juga reputasi kami sebagai guru Linux. <br><br><ul><li>  Bagian 1 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr.com/company/redhatrussia/blog/423051</a> </li><li>  Bagian 2 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr.com/company/redhatrussia/blog/424367</a> </li><li>  Bagian 3 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr.com/company/redhatrussia/blog/425803</a> </li><li>  Bagian 5 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr.com/company/redhatrussia/blog/429064</a> </li><li>  Bagian 6 - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">habr.com/company/redhatrussia/blog/430748</a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id427413/">https://habr.com/ru/post/id427413/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id427401/index.html">Shades Pembubaran dan Eksplorasi Dunia</a></li>
<li><a href="../id427403/index.html">API ReportingObserver: lihat kode halaman web dari perspektif baru</a></li>
<li><a href="../id427405/index.html">ES2018 - metode akhirnya menjanjikan</a></li>
<li><a href="../id427407/index.html">Meta-clustering dengan minimisasi kesalahan, dan mengapa saya pikir otak bekerja seperti ini</a></li>
<li><a href="../id427409/index.html">Buku "The Brilliant Agile. Manajemen proyek yang fleksibel dengan Agile, Scrum dan Kanban »</a></li>
<li><a href="../id427415/index.html">Kami menggunakan Node.js untuk bekerja dengan file besar dan set data mentah.</a></li>
<li><a href="../id427417/index.html">Dengan humor sekitar 8-inch floppy disk (di tahun 70-an hanya ada seperti itu)</a></li>
<li><a href="../id427419/index.html">Apa yang harus dilakukan ketika prosesor tidak ada hubungannya?</a></li>
<li><a href="../id427421/index.html">Bagaimana situs silsilah membuatnya lebih mudah untuk menangkap pembunuh</a></li>
<li><a href="../id427423/index.html">City2Share: e- dan mobil otonom di pusat logistik Munich</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>