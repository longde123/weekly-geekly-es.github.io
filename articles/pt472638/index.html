<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏻‍🤝‍👨🏼 🤾🏿 🛀🏽 Construa um andador de ferro fundido no Spring Boot e no AppCDS 🕌 👂🏾 😉</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Compartilhamento de dados de classe de aplicativo (AppCDS) - recurso JVM para acelerar a inicialização e economizar memória. Tendo aparecido em sua in...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Construa um andador de ferro fundido no Spring Boot e no AppCDS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/472638/"><p><img src="https://habrastorage.org/webt/se/py/8z/sepy8zdhkojsr-xiqs-lwdtyegy.jpeg"></p><br><p> <strong>Compartilhamento de dados de classe de aplicativo (AppCDS)</strong> - recurso JVM para acelerar a inicialização e economizar memória.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Tendo aparecido</a> em sua infância no HotSpot em JDK 1.5 (2004), <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">permaneceu por</a> muito tempo muito limitado e até parcialmente comercial.  Somente com o OpenJDK 10 (2018) ele foi disponibilizado a meros mortais, ao mesmo tempo em que ampliava o escopo.  E o Java 13, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">lançado</a> recentemente, tentou tornar esse aplicativo mais simples. </p><br><p>  A idéia do AppCDS é "compartilhar" uma vez carregadas as classes entre instâncias da mesma JVM no mesmo host.  Parece que isso deve ser ótimo para microsserviços, especialmente os "broilers" no Spring Boot com milhares de classes de bibliotecas, porque agora essas classes não precisam ser carregadas (analisadas e verificadas) a cada início de cada instância da JVM e não serão duplicadas na memória.  Isso significa que o lançamento deve se tornar mais rápido e o consumo de memória deve ser menor.  Maravilhoso, não é? </p><br><p>  Tudo é assim, tudo é assim.  Mas se você, o odnokhabryanin, costumava acreditar não nos sinais da avenida, mas em números e exemplos específicos, então seja bem-vindo ao kat - vamos tentar descobrir como realmente é ... </p><a name="habracut"></a><br><h2 id="vmesto-disclaimera">  Em vez de isenção de responsabilidade </h2><br><p>  Antes você não é um guia para usar o AppCDS, mas um resumo dos resultados de um pequeno estudo.  Eu estava interessado em entender como essa função da JVM é aplicável em meu projeto de trabalho e tentei avaliá-la da perspectiva de um desenvolvedor corporativo, estabelecendo o resultado neste artigo.  Isso não incluiu tópicos como o uso do AppCDS no caminho do módulo, a implementação do AppCDS em outras máquinas virtuais (não o HotSpot) e os meandros do uso de contêineres.  Mas há uma parte teórica para explorar o tópico, bem como uma parte experimental escrita para que você possa repetir a experiência por conta própria.  Nenhum dos resultados ainda foi aplicado na produção, mas quem sabe como será o amanhã ... </p><br><h2 id="teoriya">  Teoria </h2><br><h3 id="kratkoe-vvedenie-v-appcds">  Uma breve introdução ao AppCDS </h3><br><p>  O conhecimento deste tópico pode ter ocorrido a você em várias fontes, por exemplo: </p><br><ul><li>  em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> de Nikolai Parlog (incluindo Java 13 pães, mas sem Spring Boot) </li><li>  em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">relatório</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> de Volker Simonis (sem Java 13, mas com detalhes) </li><li>  em um <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">relatório do</a> autor dessas linhas (sem Java 13, mas com ênfase no Spring Boot) </li></ul><br><p>  Para não participar da recontagem, destacarei apenas alguns pontos importantes para este artigo. </p><br><p>  Em primeiro lugar, o AppCDS é uma extensão do recurso CDS que aparece há muito tempo no HotSpot, cuja essência é a seguinte: </p><br><p><img src="https://habrastorage.org/webt/gi/kg/ro/gikgrobp0s_hbnr5ox8z6d1ziqc.png"></p><br><p>  Para dar vida às duas idéias, faça o seguinte (em termos gerais): </p><br><ol><li>  Obtenha uma lista de classes que você deseja compartilhar entre instâncias de aplicativos </li><li>  Mesclar essas classes em um arquivo adequado para mapeamento de memória </li><li>  Conecte o arquivo morto a cada instância do aplicativo na inicialização </li></ol><br><p>  Parece que o algoritmo tem apenas 3 etapas - pegue e faça.  Mas aqui as notícias começam, todo tipo de coisa. </p><br><p>  O ruim é que, na pior das hipóteses, cada um desses itens se transforma em pelo menos um lançamento da JVM com suas próprias opções específicas, o que significa que todo o algoritmo é um malabarismo sutil do mesmo tipo de opções e arquivos.  Isso não parece muito promissor, não é? </p><br><p>  Mas há boas notícias: o trabalho para melhorar esse algoritmo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">está em andamento</a> e, a cada versão do Java, seu aplicativo se torna mais fácil.  Então, por exemplo: </p><br><ul><li> No OpenJDK <strong>10 e 11,</strong> você pode pular a etapa <strong>1</strong> se desejar compartilhar apenas as principais classes JDK, pois elas já foram compiladas para nós e colocadas em <code>$JAVA_HOME\lib\classlist</code> (≈1200 unidades.). </li><li>  No OpenJDK <strong>12,</strong> você pode pular a <strong>etapa 2</strong> porque, junto com a lista de classes, o arquivo de distribuição também inclui um arquivo pronto, que é usado imediatamente e não requer uma conexão explícita. </li><li>  Caso você queira compartilhar todo o resto (e geralmente apenas deseja) <br>  O OpenJDK <strong>13</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">fornece</a> arquivos Dynamic CDS - arquivos que são coletados durante a operação do aplicativo e salvos quando ele é ocupado.  Isso permite recolher os <strong>pontos 1 e 2</strong> em um ponto não muito confuso (embora nem tudo seja tão simples, mas mais adiante). </li></ul><br><p>  Portanto, não importa qual seja o processo de preparação do AppCDS, as três etapas listadas acima estão sempre por trás, apenas em alguns casos elas são veladas. </p><br><p>  Como você provavelmente notou, com o advento do AppCDS, muitas classes de aplicativos começam uma vida dupla: elas vivem simultaneamente em seus lugares anteriores (na maioria das vezes, arquivos JAR) e em um novo arquivo compartilhado.  Ao mesmo tempo, o desenvolvedor continua a alterá-los / removê-los / suplementá-los no mesmo local, e a JVM os retira do novo quando estão trabalhando.  Não é preciso ser um adivinho para ver o perigo de tal situação: se nada for feito, mais cedo ou mais tarde cópias das classes vão corroer, e teremos muitos encantos do típico "inferno JAR".  É claro que a JVM não pode impedir alterações de classe, mas deve ser capaz de detectar uma discrepância no tempo.  No entanto, fazer isso comparando classes aos pares, mesmo por somas de verificação, é uma idéia;  pode negar o restante dos ganhos de produtividade.  Provavelmente, é por isso que os engenheiros da JVM não selecionaram as classes individuais como objeto de comparação, mas o caminho de classe inteiro e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">declararam</a> na documentação do AppCDS: “O caminho de classe ao criar um archive compartilhado deve ser o mesmo (ou pelo menos um prefixo) das ativações subsequentes do aplicativo”. </p><br><blockquote>  Observe que o caminho de classe usado no momento da criação do arquivo morto deve ser o mesmo (ou um prefixo) do caminho de classe usado no tempo de execução. </blockquote><p>  Mas essa não é uma afirmação inequívoca, porque, como você se lembra, um caminho de classe pode ser formado de diferentes maneiras, como: </p><br><ul><li>  lendo arquivos <code>.class</code> de diretórios de pacotes compilados, <br>  por exemplo, <code>java com.example.Main</code> </li><li>  varrendo diretórios com arquivos JAR ao usar curinga, <br>  por exemplo, <code>java -cp mydir/* com.example.Main</code> </li><li>  lista explícita de arquivos JAR e / ou ZIP, <br>  por exemplo, <code>java -cp lib1.jar;lib2.jar com.example.Main</code> </li></ul><br><p>  (isso não inclui o fato de que o caminho da classe também pode ser configurado de maneira diferente, por exemplo, pelas opções da JVM <code>-cp/-classpath/--class-path</code> , pela variável de ambiente <code>CLASSPATH</code> ou pelo atributo do arquivo JAR do <code>Class-Path</code> da <code>Class-Path</code> a ser ativado) </p><br><p>  Desses métodos, apenas um é suportado no AppCDS - enumeração explícita de arquivos JAR.  Aparentemente, os engenheiros da HotSpot JVM achavam que comparar caminhos de classe no arquivo AppCDS e no aplicativo iniciado seria rápido o suficiente e confiável apenas se fossem especificados da maneira <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">mais</a> clara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">possível</a> - com uma lista exaustiva usual. </p><br><blockquote>  O CDS / AppCDS suporta classes de arquivamento apenas de arquivos JAR. </blockquote><p>  É importante observar aqui que esta afirmação não é recursiva, ou seja,  não se aplica a arquivos JAR dentro de arquivos JAR (a menos que se trate de CDS dinâmico, veja abaixo).  Isso significa que os bonecos JAR habituais emitidos pelo Spring Boot não funcionarão exatamente como no AppCDS comum; você precisará se sentar. </p><br><p>  Outro problema no trabalho do CDS é que os arquivos compartilhados são projetados na memória com endereços fixos (geralmente começando em <code>0x800000000</code> ).  Isso por si só não é ruim, mas como a ASLR (Address Space Layout Randomization) é ativada por padrão na maioria dos sistemas operacionais, o intervalo de memória necessário pode estar parcialmente ocupado.  O que a JVM do HotSpot faz nesse caso é a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">opção</a> especial <code>-Xshare</code> que suporta três valores: </p><br><ul><li>  <code>-Xshare:on</code> CDS / AppCDS <code>-Xshare:on</code> vigor;  se o intervalo estiver ocupado, a JVM sairá com um erro.  Este modo <strong>não</strong> é <strong>recomendado para uso em produção</strong> , pois isso pode causar falhas esporádicas ao iniciar aplicativos. </li><li>  <code>-Xshare:off</code> - (você) alterna o CDS / AppCDS;  desativa completamente o uso de dados compartilhados (incluindo arquivos incorporados) </li><li>  <code>-Xshare:auto</code> - o comportamento padrão da JVM quando, em caso de impossibilidade de alocar o intervalo de memória necessário, se entrega silenciosamente e carrega as classes normalmente. </li></ul><br><p>  No momento da redação deste artigo, a Oracle estava <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">trabalhando</a> apenas para amenizar esses problemas, mas um número de release ainda não foi atribuído. </p><br><p>  Essas opções são parcialmente úteis para nós mais tarde, mas, por enquanto, vejamos ... </p><br><h3 id="varianty-primeneniya-appcds">  Aplicativos AppCDS </h3><br><p>  Existem várias maneiras de usar o AppCDS. <del>  arruinar sua vida </del>  otimizar o trabalho dos microsserviços.  Eles variam muito em complexidade e lucro potencial, por isso é importante decidir imediatamente qual deles será discutido mais tarde. </p><br><p>  O mais simples é usar nem mesmo o AppCDS, mas apenas o CDS - é quando apenas as classes da plataforma entram no arquivo compartilhado (consulte "Uma Breve Introdução ao AppCDS").  Excluiremos essa opção imediatamente porque, quando aplicada a microsserviços no Spring Boot, ela gera muito pouco lucro.  Isso pode ser visto pela proporção do número de classes compartilhadas em sua distribuição geral usando o exemplo de um microsserviço real (consulte o segmento verde): </p><br><p><img src="https://habrastorage.org/webt/lz/7x/9l/lz7x9lodfzwv4ihwjjifjyxsf_a.png"></p><br><p>  Mais complexo, mas promissor, é o uso do AppCDS completo, ou seja, a inclusão de classes de biblioteca e aplicativo no mesmo arquivo.  Essa é uma família inteira de opções derivada de combinações do número de aplicativos participantes e do número de instâncias.  A seguir, são apresentadas avaliações subjetivas dos autores sobre os benefícios e dificuldades de várias aplicações do AppCDS. </p><br><div class="scrollable-table"><table><thead><tr><th>  Não. </th><th>  Aplicações </th><th>  Instâncias </th><th>  Lucro da CPU </th><th>  Lucro RAM </th><th>  Dificuldade </th></tr></thead><tbody><tr><td>  1 </td><td>  Um </td><td>  Um </td><td>  + </td><td>  ± </td><td>  Baixo </td></tr><tr><td>  <strong>2</strong> </td><td>  <strong>Um</strong> </td><td>  <strong>Alguns</strong> </td><td>  <strong>++</strong> </td><td>  <strong>++</strong> </td><td>  <strong>Baixo</strong> </td></tr><tr><td>  3 </td><td>  Alguns </td><td>  Um de cada vez </td><td>  ++ </td><td>  ++ </td><td>  Alta </td></tr><tr><td>  4 </td><td>  Alguns </td><td>  Alguns </td><td>  +++ </td><td>  +++ </td><td>  Alta </td></tr></tbody></table></div><br><p>  Preste atenção: </p><br><ul><li>  No aplicativo para um aplicativo em uma instância (Nº 1), o lucro da memória pode ser zero ou até negativo (especialmente ao medir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no Windows</a> ) </li><li>  Criar o arquivo compartilhado correto requer ações, cuja complexidade não depende de quantas cópias o aplicativo será iniciado (compare pares de opções nºs 1-2 e 3-4) </li><li>  Ao mesmo tempo, a transição de uma instância para várias, obviamente, aumenta o lucro para ambos os indicadores, mas não afeta a complexidade da preparação. </li></ul><br><p>  Neste artigo, <strong>alcançaremos apenas a opção n ° 2</strong> (até o n ° 1), uma vez que é simples o suficiente para um conhecimento próximo do AppCDS e, somente para isso, sem truques extras, podemos usar os recentemente lançados <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JEP-350</a> Dynamic CDS Archives, que quero sentir em ação. </p><br><h3 id="dynamic-cds-archives">  Arquivos CDS dinâmicos </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Os</a> arquivos Dynamic CDS do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JEP-350</a> , uma das principais inovações do Java 13, foram projetados para simplificar o uso do AppCDS.  Para sentir a simplificação, você deve primeiro entender a complexidade.  Deixe-me lembrá-lo de que o algoritmo clássico de aplicativo “limpo” do AppCDS consiste em 3 etapas: (1) obtenha uma lista de classes compartilhadas, (2) crie um arquivo a partir delas e (3) execute o aplicativo com o arquivo conectado.  Destas etapas, apenas a terceira é realmente útil, o restante é apenas uma preparação para isso.  E embora a obtenção de uma lista de classes (etapa 1) possa parecer muito simples (em alguns casos, é opcional), na verdade, ao trabalhar com aplicativos não triviais, acaba sendo a mais difícil, especialmente no que diz respeito ao Spring Boot.  Portanto, o JEP-350 é necessário apenas para eliminar essa etapa, ou melhor, automatizá-la.  A idéia é que a própria JVM elabore uma lista das classes de que o aplicativo precisa e, em seguida, forme a partir delas o chamado arquivo “dinâmico”.  Concordo, parece bom.  Mas o problema é que agora fica claro em que ponto parar de acumular classes e continuar a colocá-las no arquivo.  Anteriormente, no AppCDS clássico, escolhemos esse momento por conta própria e podemos até alternar entre essas ações para alterar algo na lista de classes antes de transformá-lo em um arquivo.  Agora, isso está acontecendo automaticamente e apenas em um momento, para o qual os engenheiros da JVM escolheram, talvez, a única opção de comprometimento - o desligamento regular da JVM.  Isso significa que o arquivo morto não será criado até que o aplicativo pare.  Esta solução tem algumas consequências importantes: </p><br><ul><li>  No caso de uma falha na JVM, o archive não será criado, por mais maravilhosa que seja a lista de classes acumuladas até então (não é possível extraí-la posteriormente usando meios regulares). </li><li>  O arquivo morto será criado apenas a partir das classes que conseguiram carregar durante a sessão do aplicativo.  Para aplicativos da Web, isso significa que a criação de um arquivo morto iniciando e parando não é correta, pois muitas classes importantes não serão inseridas no arquivo morto.  É necessário executar pelo menos uma solicitação HTTP no aplicativo (e é melhor executá-lo adequadamente em todos os cenários) para que todas as classes que ele realmente usa sejam carregadas. </li></ul><br><p>  Uma diferença importante entre os arquivos estáticos e dinâmicos é que eles sempre constituem um "complemento" sobre os arquivos estáticos básicos, que podem ser arquivos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">embutidos</a> no kit de distribuição Java ou criados separadamente, em uma maneira clássica de três etapas. </p><br><p>  Sintaticamente, o uso de Dynamic CDS Archives se resume a dois lançamentos da JVM com duas opções: </p><br><ol><li>  Execução de avaliação com a opção <code>-XX:ArchiveClassesAtExit=archive.jsa</code> , no final do qual um archive dinâmico será criado (você pode especificar qualquer caminho e nome) </li><li>  Lançamento útil com a opção <code>-XX:SharedArchiveFile=archive.jsa</code> , que usará o archive criado anteriormente </li></ol><br><p>  A segunda opção não é diferente de conectar um arquivo estático regular.  Mas se de repente o arquivo estático básico não estiver no local padrão (dentro do JDK), essa opção também poderá incluir uma indicação do caminho para ele, por exemplo: </p><br><pre> <code class="bash hljs">-XX:SharedArchiveFile=base.jsa:dynamic.jsa</code> </pre> <br><p>  <em>(no Windows, o separador de caminho deve ser o caractere ";")</em> </p><br><p>  Agora você conhece o AppCDS o suficiente para poder vê-lo em ação. </p><br><h2 id="praktika">  Prática </h2><br><h3 id="podopytnyy-krolik">  Coelho experimental </h3><br><p>  Para que nossa aplicação do AppCDS na prática não se limite a um HelloWorld típico, tomaremos como base a aplicação real no Spring Boot.  Meus colegas e eu geralmente temos que assistir logs de aplicativos em servidores de teste remotos e assistir ao vivo, exatamente como eles são gravados.  Para usar isso, um agregador de logs completo (como o ELK) geralmente não é apropriado;  baixar arquivos de log infinitamente - por um longo tempo, e olhar para a saída cinza do console é deprimente.  Portanto, criei um aplicativo da web que pode gerar quaisquer logs em tempo real diretamente para o navegador, colorir linhas por nível de importância (ao mesmo tempo em que formata XML), agregar vários logs em um e outros truques.  É chamado <strong>ANALOG</strong> (como um "analisador de log", embora isso não seja verdade) e está <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">no GitHub</a> .  Clique na imagem para ampliar: </p><br><p> <a href=""><img src="https://habrastorage.org/webt/q3/lo/m_/q3lom_x6c9wghlerm1g9oa9-yfw.png"></a> </p><br><p>  Tecnicamente, esse é um aplicativo no Spring Boot + Spring Integration, sob o capô do qual <code>tail</code> , <code>docker</code> e <code>kubectl</code> (para oferecer suporte a logs de arquivos, contêineres do Docker e recursos do Kubernetes, respectivamente).  Ele vem na forma do arquivo JAR clássico "grosso" do Spring Boot.  No tempo de execução, <strong>as classes de K10K estão suspensas</strong> na memória do aplicativo, das quais a grande maioria são classes Spring e JDK.  Obviamente, essas classes mudam muito raramente, o que significa que podem ser colocadas em um arquivo compartilhado e reutilizadas em todas as instâncias do aplicativo, economizando memória e CPU. </p><br><h3 id="odinochnyy-eksperiment">  Experiência única </h3><br><p>  Agora vamos aplicar o conhecimento existente do Dynamic AppCDS ao coelho experimental.  Como tudo é conhecido em comparação, precisaremos de um ponto de referência - o estado do programa com o qual compararemos os resultados obtidos durante o experimento. </p><br><h4 id="vvodnye-zamechaniya">  Observações introdutórias </h4><br><ul><li>  Todos os comandos adicionais são para Linux.  As diferenças para Windows e macOS não são fundamentais. </li><li>  A compilação JIT pode afetar visivelmente os resultados e, em teoria, pela pureza do experimento, ele pode ser desativado (com a opção <code>-Xint</code> , como foi feito no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">artigo</a> mencionado), mas por uma questão de máxima credibilidade, decidiu-se não fazer isso. </li><li>  Os seguintes números sobre a hora de início foram obtidos em um servidor de teste rápido.  Em máquinas de trabalho, números semelhantes, em regra, são mais modestos, mas como não estamos interessados ​​em valores absolutos, mas em incrementos percentuais, consideramos essa diferença insignificante. </li><li>  Para não entrar prematuramente na complexidade de medir a memória compartilhada, por enquanto, omitiremos obter leituras precisas em bytes.  Em vez disso, introduzimos o conceito de " <strong>potencial CDS</strong> " <strong>,</strong> expresso como uma porcentagem do número de classes compartilhadas no número total de classes carregadas.  É claro que isso é uma quantidade abstrata, mas, por outro lado, afeta diretamente o consumo real de memória;  além disso, sua definição não depende do sistema operacional e, para seu cálculo, apenas os logs são suficientes. </li></ul><br><h4 id="referentnaya-tochka">  Ponto de referência </h4><br><p>  Deixe este ponto ser o estado de um aplicativo baixado recentemente, ou seja,  sem o uso explícito de qualquer AppCDS'ov e outros.  Para avaliá-lo, precisamos de: </p><br><ol><li><p>  Instale o OpenJDK 13 (por exemplo, a distribuição doméstica do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Liberica</a> , mas não a versão lite). <br>  Ele também precisa ser incluído na variável de ambiente PATH ou em <code>JAVA_HOME</code> , por exemplo, assim: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> JAVA_HOME=~/tools/jdk-13</code> </pre> <br></li><li><p>  <a href="">Faça o download do</a> ANALOG (no momento da redação, a versão mais recente era a v0.12.1). </p><br><p>  Se necessário, você pode especificar no arquivo <code>config/application.yaml</code> no parâmetro <code>server.address</code> o nome do host externo para acessar o aplicativo (por padrão, <code>localhost</code> é especificado lá). </p><br></li><li><p>  Ative o log de carregamento de classe da JVM. <br>  Para fazer isso, você pode <code>JAVA_OPTS</code> a variável de ambiente <code>JAVA_OPTS</code> com este valor: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> JAVA_OPTS=-Xlog:class+load=info:file=<span class="hljs-built_in"><span class="hljs-built_in">log</span></span>/class-load.log</code> </pre> <br><p>  Essa opção será passada para a JVM e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">instruirá a</a> fonte de cada classe. </p><br></li><li><p>  Execute um teste: </p><br><ol><li>  Execute o aplicativo com o script <code>bin/analog</code> </li><li>  Abra <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http: // localhost: 8083</a> no navegador, aperte botões e daws </li><li>  Pare o aplicativo pressionando <code>Ctrl+C</code> no console de scripts <code>bin/analog</code> </li></ol><br></li><li><p>  Pegue o resultado (dos arquivos no diretório <code>log/</code> ) </p><br><ul><li><p>  Número total de classes carregadas (por <code>class-load.log</code> ): </p><br><pre> <code class="bash hljs">cat class-load.log | wc -l 10463</code> </pre> <br></li><li><p>  Quantos deles são baixados de um arquivo compartilhado (de acordo com ele): </p><br><pre> <code class="bash hljs">grep -o <span class="hljs-string"><span class="hljs-string">'source: shared'</span></span> - class-load.log 1146</code> </pre> <br></li><li><p>  Tempo médio de início (após várias séries; por <code>analog.log</code> ): </p><br><pre> <code class="bash hljs">grep -oE <span class="hljs-string"><span class="hljs-string">'\(JVM running for .+\)'</span></span> analog.log | grep -oE <span class="hljs-string"><span class="hljs-string">'[0-9]\.[0-9]+'</span></span> | awk <span class="hljs-string"><span class="hljs-string">'{ total += $1; count++ } END { print total/count }'</span></span> 4.5225</code> </pre> <br></li></ul><br></li></ol><br><p>  Portanto, nesta etapa, o potencial do CDS era <code>1146/10463=0,1095</code> <strong>± 11%</strong> .  Se você está surpreso de onde vieram as classes compartilhadas (afinal, ainda não incluímos nenhum AppCDS), lembro que a partir da 12ª versão, o JDK <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">inclui o</a> arquivo final do CDS <code>$JAVA_HOME/lib/server/classes.jsa</code> , construído por não menos do que lista pronta de classes: </p><br><pre> <code class="bash hljs">cat <span class="hljs-variable"><span class="hljs-variable">$JAVA_HOME</span></span>/lib/classlist | wc -l 1170</code> </pre> <br><p>  Agora, depois de avaliar o estado inicial do aplicativo, podemos aplicar o AppCDS a ele e, por comparação, entender o que isso oferece. </p><br><h4 id="osnovnoy-opyt">  Experiência central </h4><br><p>  Como a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">documentação</a> nos foi fornecida, para criar um archive dinâmico do AppCDS, você precisa executar apenas uma execução de avaliação do aplicativo com a opção <code>-XX:ArchiveClassesAtExit</code> .  A partir do próximo lançamento, o arquivo pode ser usado e obter lucro.  Para verificar isso no mesmo coelho experimental (AnaLog), você precisa: </p><br><ol><li><p>  Adicione a opção especificada ao comando run: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> JAVA_OPTS=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$JAVA_OPTS</span></span></span><span class="hljs-string"> -XX:ArchiveClassesAtExit=work/classes.jsa"</span></span></code> </pre> <br></li><li><p>  Estender o log: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> JAVA_OPTS=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$JAVA_OPTS</span></span></span><span class="hljs-string"> -Xlog:cds=debug:file=log/cds.log"</span></span></code> </pre><br><p>  Esta opção forçará o processo de construção de um arquivo CDS a ser registrado quando o aplicativo for parado. </p><br></li><li><p>  Execute o mesmo teste que o ponto de referência: </p><br><ol><li>  Execute o aplicativo com o script <code>bin/analog</code> </li><li>  Abra <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http: // localhost: 8083</a> no navegador, aperte botões e daws </li><li>  Pare o aplicativo pressionando <code>Ctrl+C</code> no console de scripts <code>bin/analog</code> <br>  Depois disso, um tremendo calçado com todos os tipos de aviso deve cair no console e o <code>log/cds.log</code> deve ser preenchido com detalhes;  eles ainda não nos interessam. </li></ol><br></li><li><p>  Alterne o modo de inicialização de teste para útil: </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> JAVA_OPTS=<span class="hljs-string"><span class="hljs-string">"-XX:SharedArchiveFile=work/classes.jsa -Xlog:class+load=info:file=log/class-load.log -Xlog:class+path=debug:file=log/class-path.log"</span></span></code> </pre><br><p>  Aqui não suplementamos a variável <code>JAVA_OPTS</code> , mas a apagamos com novos valores que incluem (1) usando um arquivo compartilhado, (2) fontes de classe de log e (3) verificação de caminho de classe de log. </p><br></li><li><p>  Execute um lançamento útil do aplicativo de acordo com o esquema do parágrafo 3. </p><br></li><li><p>  Pegue o resultado (dos arquivos no diretório <code>log/</code> ) </p><br><ul><li><p>  Verificando se o AppCDS realmente foi aplicado (pelo <code>class-path.log</code> ): </p><br><pre> <code class="plaintext hljs">[0.011s][info][class,path] type=BOOT [0.011s][info][class,path] Expecting BOOT path=/home/upc/tools/jdk-13/lib/modules [0.011s][info][class,path] ok [0.011s][info][class,path] type=APP [0.011s][info][class,path] Expecting -Djava.class.path=/home/upc/tmp/analog/lib/analog.jar [0.011s][info][class,path] ok</code> </pre><br><p>  As marcas <code>ok</code> após as linhas <code>type=BOOT</code> e <code>type=APP</code> indicam a abertura, verificação e carregamento bem-sucedidos dos arquivos CDS embutidos e aplicados, respectivamente. </p><br></li><li><p>  Número total de classes carregadas (por <code>class-load.log</code> ): </p><br><pre> <code class="bash hljs">cat class-load.log | wc -l 10403</code> </pre><br></li><li><p>  Quantos deles são baixados de um arquivo compartilhado (de acordo com ele): </p><br><pre> <code class="bash hljs">grep -o <span class="hljs-string"><span class="hljs-string">'source: shared'</span></span> -c class-load.log 6910</code> </pre><br></li><li><p>  Tempo médio de início (após várias séries; por arquivo <code>analog.log</code> ): </p><br><pre> <code class="bash hljs">grep -oE <span class="hljs-string"><span class="hljs-string">'\(JVM running for .+\)'</span></span> analog.log | grep -oE <span class="hljs-string"><span class="hljs-string">'[0-9]\.[0-9]+'</span></span> | awk <span class="hljs-string"><span class="hljs-string">'{ total += $1; count++ } END { print total/count }'</span></span> 4.04167</code> </pre><br></li></ul><br></li></ol><br><p>  Mas nesta etapa, o potencial do CDS já era <code>6910/10403≈0,66</code> <strong>= 66%</strong> , ou seja, aumentou <strong>55% em</strong> comparação com o ponto de referência.  Ao mesmo tempo, o tempo médio de inicialização foi reduzido em <code>(4,5225-4,04167)=0,48</code> segundos, ou seja,  O início é mais rápido em <strong>± 10,6%</strong> do valor inicial. </p><br><h4 id="analiz-rezultatov">  Análise de Resultados </h4><br><p>  <em>O título de trabalho do item é: "Por que tão pouco?"</em> </p><br><p>  Fizemos tudo de acordo com as instruções, mas nem todas as classes estavam no arquivo.  O número deles afeta o tempo de lançamento não menos que o poder computacional da máquina do experimentador, portanto, nos concentraremos nesse número. </p><br><p>  Se você se lembra, <code>log/cds.log</code> arquivo <code>log/cds.log</code> criado durante a parada do aplicativo experimental após a execução da avaliação.  Nesse arquivo HotSpot, a JVM gentilmente notava classes de aviso para cada classe que não aparecia no arquivo CDS.  Aqui está o número total de tais marcas: </p><br><pre> <code class="bash hljs">grep -o <span class="hljs-string"><span class="hljs-string">'[warning]'</span></span> cds.log -c 3591</code> </pre><br><p>  Considerando que apenas 10K + classes são mencionadas no log de <code>class-load.log</code> e 66% delas são carregadas do archive, não é difícil entender que as 3600 classes listadas no <code>cds.log</code> são os 44% "ausentes" do potencial do CDS.  Agora você precisa descobrir por que eles foram ignorados. </p><br><p>  Se você olhar para o log cds.log, verifica-se que existem apenas 4 razões exclusivas para ignorar as classes.  Aqui estão exemplos de cada um deles: </p><br><pre> <code class="plaintext hljs">Skipping org/springframework/web/client/HttpClientErrorException: Not linked Pre JDK 6 class not supported by CDS: 49.0 org/jrobin/core/RrdUpdater Skipping java/util/stream/Collectors$$Lambda$554: Unsafe anonymous class Skipping ch/qos/logback/classic/LoggerContext: interface org/slf4j/ILoggerFactory is excluded</code> </pre><br><p>  Entre todas as 3591 aulas perdidas, esses motivos são encontrados aqui com tanta frequência: </p><br><p><img src="https://habrastorage.org/webt/sp/f6/6k/spf66kzmkajvdxki1xdiwjyx9lg.png"></p><br><p>  Dê uma olhada neles: </p><br><ul><li><p> <code>Unsafe anonymous class</code> <br>   JVM   “”   ,       -,         . </p><br></li><li><p> <code>Not linked</code> <br>      , “”     ,  ,   .      ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">StackOverflow </a>    . , ,       “” () JAR-  ,   AppCDS.       ,     (  ). </p><br></li><li><p> <code>Pre JDK 6 class</code> <br>  ,   CDS    Java 5.        class-   ,   CDS    .    ,    ,  6,  Java,       .       -   ,      runtime- (, slf4j). </p><br></li><li><p> <code>Skipping ... : super class/interface ... is excluded</code> <br>   ,  “”     .          CDS',    .  Por exemplo: </p><br><pre> <code class="plaintext hljs">[warning][cds] Pre JDK 6 class not supported by CDS: 49.0 org/slf4j/spi/MDCAdapter [warning][cds] Skipping ch/qos/logback/classic/util/LogbackMDCAdapter: interface org/slf4j/spi/MDCAdapter is excluded</code> </pre><br></li></ul><br><p>  <strong>Conclusão</strong> </p><br><blockquote>  CDS       100%. </blockquote><p> ,     ,  ,         ,  ,     .      . </p><br><h3 id="mnozhestvennyy-eksperiment">   </h3><br><p>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JEP-310</a> , AppCDS                         JDK.   .       ,     .    CDS (, ,     )       . </p><br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para clonar o coelho experimental (execute o AnaLog em várias instâncias), precisamos alterar algo nas configurações; </font><font style="vertical-align: inherit;">isso permitirá que os processos levantados não "cotovelem". </font><font style="vertical-align: inherit;">Graças ao Spring Boot, você pode fazer isso sem editar ou copiar nenhum arquivo; </font><font style="vertical-align: inherit;">quaisquer configurações podem ser substituídas pelas opções da JVM. </font><font style="vertical-align: inherit;">O encaminhamento dessas opções a partir de uma variável de ambiente </font></font><code>ANALOG_OPTS</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fornece um script de inicialização, gentilmente gerado por Gradle.</font></font></p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> ANALOG_OPTS=<span class="hljs-string"><span class="hljs-string">"-Djavamelody.enabled=false -Dlogging.config=classpath:logging/logback-console.xml"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> ANALOG_OPTS=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ANALOG_OPTS</span></span></span><span class="hljs-string"> -Dnodes.this.agentPort=7801 -Dserver.port=8091"</span></span></code> </pre><br><p>      JavaMelody,             ,        ,       .     TCP-    ;       . </p><br><p>  ,    ,   JVM      AppCDS    .         <code>JAVA_OPTS</code>    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">JVM Unified Logging Framework</a> : </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> JAVA_OPTS=<span class="hljs-string"><span class="hljs-string">"-Xlog:class+load=info:file=log/class-load-%p.log -Xlog:class+path=debug:file=log/class-path-%p.log"</span></span> <span class="hljs-built_in"><span class="hljs-built_in">export</span></span> JAVA_OPTS=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$JAVA_OPTS</span></span></span><span class="hljs-string"> -XX:SharedArchiveFile=work/classes.jsa"</span></span></code> </pre><br><p>        <code>%p</code> ,    JVM      (PID).   AppCDS  ,     (         ). </p></div></div><br><h4 id="osnovnoy-opyt-1">   </h4><br><p>  ,          .                  .     : </p><br><ol><li><p>      <code>server.port</code>  <code>nodes.this.agentPort</code> ,      : </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">export</span></span> ANALOG_OPTS=<span class="hljs-string"><span class="hljs-string">"</span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$ANALOG_OPTS</span></span></span><span class="hljs-string"> -Dnodes.this.agentPort=7801 -Dserver.port=8091"</span></span></code> </pre><br><p> ,       (    ). </p><br></li><li><p>    <code>bin/analog</code> </p><br><p> <em>()</em>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">http://localhost:8091</a>  ,     </p><br></li><li><p>  PID  (  ), : </p><br><pre> <code class="bash hljs">pgrep -f analog 13792</code> </pre><br></li><li><p>      <code>pmap</code> (    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="> </a> ): </p><br><pre> <code class="bash hljs">pmap -XX 13792 | sed -n -e <span class="hljs-string"><span class="hljs-string">'2p;$p'</span></span> Address Perm Offset Device Inode Size KernelPageSize MMUPageSize Rss Pss Shared_Clean Shared_Dirty Private_Clean Private_Dirty Referenced Anonymous LazyFree AnonHugePages ShmemPmdMapped Shared_Hugetlb Private_Hugetlb Swap SwapPss Locked ProtectionKey VmFlagsMapping 3186952 1548 1548 328132 325183 3256 0 10848 314028 212620 314024 0 0 0 0 0 0 0 325183 0 KB</code> </pre><br><p>           ;   . </p><br></li><li><p>   1-4     (,  ). </p><br></li></ol><br><h4 id="analiz-rezultatov-1">   </h4><br><p>    <code>pmap</code>             .        CDS'    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">   </a> .    ,  ,        PSS: </p><br><blockquote> The "proportional set size" (PSS) of a process is the count of pages it has in memory, where each page is divided by the number of processes sharing it. So if a process has 1000 pages all to itself, and 1000 shared with one other process, its PSS will be 1500. </blockquote><p>  ,   ,  “ ” .        ,      . </p><br><p>    PSS       ,    : </p><br><div class="scrollable-table"><table><thead><tr><th> Iteration: </th><th>  1 </th><th>  2 </th><th>  3 </th><th>  4 </th><th>  5 </th></tr></thead><tbody><tr><td> PSS of inst#1: </td><td> 339 088 </td><td> 313 778 </td><td> 305 517 </td><td> 301 153 </td><td> 298 604 </td></tr><tr><td> PSS of inst#2: </td><td></td><td> 314 904 </td><td> 306 567 </td><td> 302 555 </td><td> 299 919 </td></tr><tr><td> PSS of inst#3: </td><td></td><td></td><td> 314 914 </td><td> 311 008 </td><td> 308 691 </td></tr><tr><td> PSS of inst#4: </td><td></td><td></td><td></td><td> 306 563 </td><td> 304 495 </td></tr><tr><td> PSS of inst#5: </td><td></td><td></td><td></td><td></td><td> 294 686 </td></tr><tr><td> <em>Average:</em> </td><td> 339 088 </td><td> 314 341 </td><td> 308 999 </td><td> 305 320 </td><td> 301 279 </td></tr></tbody></table></div><br><p>         ,      - : </p><br><ul><li>        “”  </li><li>     , PSS   </li><li>  “” ,     PSS      </li></ul><br><p>    ,      .         AppCDS.        ,       <code>-XX:SharedArchiveFile=work/classes.jsa</code>   <code>-Xshare:off</code> ,    CDS .              ,    . </p><br><p><img src="https://habrastorage.org/webt/vq/4s/n6/vq4sn66zppmcyl5aovqj6xpkwyq.png"></p><br><p>       : </p><br><ul><li><p>  PSS  AppCDS      CDS. <br>          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a> .  ,  ,    HelloWorld- JVM   CDS   2   ,   CDS.      PSS            CDS,     .        : </p><br></li><li><p>    PSS   AppCDS    2-  ; 3-      . <br>        ,      ,    ,     .  ,        AppCDS,   ,   ,      3-    . <br>  :    ,    CDS?      : </p><br></li><li><p>    CDS/AppCDS  JVM      ,  PSS       .  ,    ,      <code>pmap</code> ,   “”   <code>sed</code> '.              : </p><br><pre> <code class="bash hljs">pmap -X `pgrep -f analog` 14981: <span class="hljs-comment"><span class="hljs-comment"># ... Address Perm Offset Device Inode Size Rss Pss ... Mapping # ... ... 7faf5e31a000 r-xp 00000000 08:03 269427 17944 14200 14200 ... libjvm.so # ... ... 7faf5f7f9000 r-xp 00000000 08:03 1447189 1948 1756 25 ... libc-2.27.so</span></span></code> </pre><br><p>       ( <code>Mapping</code> )  , “”      .       JVM  ( <code>libjvm.so</code>   ),     ( <code>libc-2.27.so</code>  ).    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="></a>        : </p><br><blockquote> For the Java VM, the read-only parts of the loaded shared libraries (ie <code>libjvm.so</code> ) can be shared between all the VM instances running at the same time. This explains why, taking together, the two VM's consume less memory (ie have a smaller memory footprint) than the simple sum of their single resident set sizes when running alone. </blockquote><br></li></ul><br><p>           .     ,  , .  ,          ,         JVM     ,    Java-    .       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">  </a>  GeekOut: </p><br><p><img src="https://habrastorage.org/webt/wp/ia/qo/wpiaqom-2teiw_iegjacskkt3sm.png"></p><br><p> , , ,      AppCDS    , ..     Java-.   ,             JVM,  , -      . </p><br><p>       VisualVM      Metaspace    AppCDS  ,      : </p><br><p> <strong> AppCDS</strong> </p><br><p><img src="https://habrastorage.org/webt/pt/wv/6r/ptwv6rmyk8j7f7yzgxrjkqrsvww.png"></p><br><p> <strong> AppCDS</strong> </p><br><p><img src="https://habrastorage.org/webt/dt/jn/0m/dtjn0mdpcgykbfynjbwdma2vmqm.png"></p><br><p>   ,         128     Metaspace   AppCDS    <code>64.2 MiB / 8.96 MiB</code> <strong>≈7,2  </strong> ,   CDS .            (.  )       <code>66.4 MiB / 13.9 MiB</code> <strong>≈4,8 </strong> .      ,    AppCDS      ,       Metaspace.            Metaspace,    ,    CDS . </p><br><h2 id="vmesto-zaklyucheniya">  Em vez de uma conclusão </h2><br><p>            Spring Boot  AppCDS –  JVM,        . </p><br><ul><li>            JEP-350 Dynamic CDS Archives –    JDK 13. </li><li>    Spring Boot  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ó</a>          CDS (  ). ,           100%   -   <strong>66%</strong> .      ,      <strong>≈11%</strong> (    15%,      ). </li><li>     ,       5-     PSS (      ).  ,  AppCDS     ,   <strong>  </strong>           , <strong> 8%</strong> (PSS).       ,    CDS,     ,     .        AppCDS  <strong> </strong> . </li><li>          Metaspace,  ,         AppCDS  <strong> 5  </strong> ,   CDS. </li></ul><br><p> ,    , AppCDS,  ,    “killer feature”.           Spring Boot.   ,   ,    AppCDS      .  , ,        AppCDS   <em></em>   Spring Boot.              ,      … </p><br><p> <em>  by <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Nick Fewings</a> on <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Unsplash</a></em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt472638/">https://habr.com/ru/post/pt472638/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt472620/index.html">Museum DataArt. Inspeção do terminal de vídeo Mera CM 7209</a></li>
<li><a href="../pt472622/index.html">Plano de nivelamento para a profissão Data Engineer</a></li>
<li><a href="../pt472626/index.html">Análise da placa-mãe ASRock Z390 Phantom Gaming 7: preparação para 9900KS</a></li>
<li><a href="../pt472628/index.html">Codificações, shift cipher, hashes brutos e criação de imagens usando python PIL. Solução de problemas com o r0ot-mi Cryto. Parte 1</a></li>
<li><a href="../pt472636/index.html">Visão geral do programa DotNext 2019 em Moscou: quem lhe dirá o quê?</a></li>
<li><a href="../pt472640/index.html">O que aprendi em 6 anos ajudando startups a crescer</a></li>
<li><a href="../pt472642/index.html">Webdev freelance - como e com quem você NÃO deve trabalhar</a></li>
<li><a href="../pt472644/index.html">Estágios em empresas internacionais: como não preencher a entrevista e receber a cobiçada oferta</a></li>
<li><a href="../pt472650/index.html">Medo, dor e ódio ao suporte técnico</a></li>
<li><a href="../pt472658/index.html">Quase tudo sobre o futuro HolyJS 2019 Moscow</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>