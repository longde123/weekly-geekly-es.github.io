<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙍 📻 👆🏽 SQL指南：如何更好地编写查询（第2部分） 🎩 🤮 🛶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="续篇文章SQL指南：如何更好地编写查询（第1部分） 

 从请求到执行计划 
 知道反模式不是一成不变的，并且随着您作为SQL开发人员的成长而发展，并且在考虑替代方案时要记住很多事情，这也意味着避免反模式和重写查询可能非常困难。任务。 任何帮助都可以派上用场，这就是为什么使用某些工具来结构化查询优化...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>SQL指南：如何更好地编写查询（第2部分）</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/465975/"> 续篇文章<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SQL指南：如何更好地编写查询（第1部分）</a> <br><br><h2> 从请求到执行计划 </h2><br><img width="40%" align="left" src="https://habrastorage.org/webt/0i/6s/ac/0i6sacyjz9j7pwvkqhfnr6ryjby.jpeg"> 知道反模式不是一成不变的，并且随着您作为SQL开发人员的成长而发展，并且在考虑替代方案时要记住很多事情，这也意味着避免反模式和重写查询可能非常困难。任务。 任何帮助都可以派上用场，这就是为什么使用某些工具来结构化查询优化的方法可能最有效。 <br><br> 还应该注意的是，上一节中提到的某些反模式源自性能问题，例如<code>AND</code> ， <code>OR</code>和<code>NOT</code>运算符，以及它们在使用索引时的缺失。 关于性能的思考不仅需要更结构化的方法，而且还需要更深层次的方法。 <br><br> 但是，这种结构化且深入的方法将主要基于查询计划，您记得，查询计划是将查询首先解析为“解析树”或“解析树”并确定哪种算法的结果。用于每个操作以及如何协调它们的执行。 <br><a name="habracut"></a><br><h2> 查询优化 </h2><br> 在阅读简介时，您可能需要检查并设置由优化程序手动编译的计划。 在这种情况下，您将需要通过查看请求计划来再次分析您的请求。 <br><br> 要访问此计划，必须使用数据库管理系统提供的工具。 您可以使用以下工具： <br><br><ul><li> 一些软件包包含生成查询计划的图形表示的工具。 考虑以下示例： <br><br><img src="https://habrastorage.org/webt/1y/ff/wa/1yffwafdtmxfgdeanejdy5wjelo.gif"><br></li><li> 其他工具将提供查询计划的文字描述。 一个示例是Oracle中的<code>EXPLAIN PLAN</code>语句，但是指令的名称取决于您使用的DBMS。 在其他地方，您可以找到<code>EXPLAIN</code> （MySQL，PostgreSQL）或<code>EXPLAIN QUERY PLAN</code> （SQLite）。 </li></ul><br>  <b>请注意</b> ，在使用PostgreSQL时，您可以在<code>EXPLAIN</code>之间进行区分，在<code>EXPLAIN</code> ，您仅获得描述，告诉您计划者打算如何执行查询而不执行查询，而<code>EXPLAIN ANALYZE</code>实际上执行查询并返回分析预期和实际的请求计划。 一般而言，实际执行计划是实际执行请求的计划，而评估执行计划确定在不满足请求的情况下将执行的操作。 尽管从逻辑上讲这是等效的，但是实际执行计划更为有用，因为它包含有关执行请求时实际发生情况的其他信息和统计信息。 <br><br> 在本节的其余部分，您将了解有关<code>EXPLAIN</code>和<code>ANALYZE</code>更多信息，以及如何使用它们来获取有关查询计划及其可能的性能的更多信息。 为此，请从几个示例开始，在其中将使用两个表： <code>one_million</code>和<code>half_million</code> 。 <br><br> 您可以使用<code>EXPLAIN</code>从<code>one_million</code>表中获取当前信息； 确保将其直接放置在请求上方，执行之后，它将向您返回查询计划： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> one_million; QUERY PLAN ____________________________________________________ Seq Scan on one_million (cost=0.00..18584.82 rows=1025082 width=36) (1 row)</code> </pre> <br> 在这种情况下，您看到请求的成本为<code>0.00..18584.82</code> ，并且行数为<code>1025082</code> 。 列数的宽度是<code>36</code> 。 <br><br> 另外，您可以使用<code>ANALYZE</code>更新统计信息。 <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> one_million; <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> one_million; QUERY PLAN ____________________________________________________ Seq Scan on one_million (cost=0.00..18334.00 rows=1000000 width=37) (1 row)</code> </pre> <br> 除了<code>EXPLAIN</code>和<code>ANALYZE</code> ，您还可以使用<code>EXPLAIN ANALYZE</code>获得实际的运行时： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> one_million; QUERY PLAN ___________________________________________________________ Seq Scan on one_million (cost=0.00..18334.00 rows=1000000 width=37) (actual time=0.015..1207.019 rows=1000000 loops=1) Total runtime: 2320.146 ms (2 rows)</code> </pre> <br> 使用<code>EXPLAIN ANALYZE</code>的缺点是查询实际上是在执行的，因此要小心！ <br><br> 到目前为止，您所看到的所有算法都是<code>Seq Scan</code> （顺序扫描）或全表扫描：这是在数据库中执行的扫描，其中扫描表的每一行都是按顺序读取的，并检查找到的列是否存在是否符合条件。 在性能方面，顺序扫描绝对不是最佳的执行计划，因为您仍在进行全表扫描。 但是，当表不能容纳在内存中时，这并不是很糟糕：即使在慢速磁盘上，顺序读取也相当快。 <br><br> 稍后当我们讨论索引扫描时，您将学到更多有关此的知识。 <br><br> 但是，还有其他算法。 例如，以下关于连接的查询计划： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> one_million <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> half_million <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (one_million.counter=half_million.counter); QUERY PLAN _________________________________________________________________ Hash Join (cost=15417.00..68831.00 rows=500000 width=42) (actual time=1241.471..5912.553 rows=500000 loops=1) Hash Cond: (one_million.counter = half_million.counter) -&gt; Seq Scan on one_million (cost=0.00..18334.00 rows=1000000 width=37) (actual time=0.007..1254.027 rows=1000000 loops=1) -&gt; Hash (cost=7213.00..7213.00 rows=500000 width=5) (actual time=1241.251..1241.251 rows=500000 loops=1) Buckets: 4096 Batches: 16 Memory Usage: 770kB -&gt; Seq Scan on half_million (cost=0.00..7213.00 rows=500000 width=5) (actual time=0.008..601.128 rows=500000 loops=1) Total runtime: 6468.337 ms</code> </pre> <br> 您会看到查询优化器在这里选择了<code>Hash Join</code> ！ 请记住此操作，因为您需要它来评估请求的时间复杂度。 现在，请注意， <code>half_million.counter</code>没有索引，我们在以下示例中添加该索引： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> half_million(counter); <span class="hljs-keyword"><span class="hljs-keyword">EXPLAIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ANALYZE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> one_million <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> half_million <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> (one_million.counter=half_million.counter); QUERY PLAN ________________________________________________________________ <span class="hljs-keyword"><span class="hljs-keyword">Merge</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Join</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">4.12</span></span>.<span class="hljs-number"><span class="hljs-number">.37650</span></span><span class="hljs-number"><span class="hljs-number">.65</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">500000</span></span> width=<span class="hljs-number"><span class="hljs-number">42</span></span>) (actual <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>=<span class="hljs-number"><span class="hljs-number">0.033</span></span>.<span class="hljs-number"><span class="hljs-number">.3272</span></span><span class="hljs-number"><span class="hljs-number">.940</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">500000</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">Merge</span></span> Cond: (one_million.counter = half_million.counter) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Scan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> one_million_counter_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> one_million (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">0.00</span></span>.<span class="hljs-number"><span class="hljs-number">.32129</span></span><span class="hljs-number"><span class="hljs-number">.34</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">1000000</span></span> width=<span class="hljs-number"><span class="hljs-number">37</span></span>) (actual <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>=<span class="hljs-number"><span class="hljs-number">0.011</span></span>.<span class="hljs-number"><span class="hljs-number">.694</span></span><span class="hljs-number"><span class="hljs-number">.466</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">500001</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">Index</span></span> <span class="hljs-keyword"><span class="hljs-keyword">Scan</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> half_million_counter_idx <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> half_million (<span class="hljs-keyword"><span class="hljs-keyword">cost</span></span>=<span class="hljs-number"><span class="hljs-number">0.00</span></span>.<span class="hljs-number"><span class="hljs-number">.14120</span></span><span class="hljs-number"><span class="hljs-number">.29</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">500000</span></span> width=<span class="hljs-number"><span class="hljs-number">5</span></span>) (actual <span class="hljs-built_in"><span class="hljs-built_in">time</span></span>=<span class="hljs-number"><span class="hljs-number">0.010</span></span>.<span class="hljs-number"><span class="hljs-number">.683</span></span><span class="hljs-number"><span class="hljs-number">.674</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>=<span class="hljs-number"><span class="hljs-number">500000</span></span> loops=<span class="hljs-number"><span class="hljs-number">1</span></span>) Total runtime: <span class="hljs-number"><span class="hljs-number">3833.310</span></span> ms (<span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">rows</span></span>)</code> </pre> <br> 您会看到，通过创建索引，查询优化器现在决定在扫描“ <code>Index Scan</code>索引时使用<code>Merge join</code> 。 <br><br>  <b>请注意</b>索引扫描与全表扫描或顺序扫描之间的区别：第一个（也称为“表扫描”）扫描数据或索引页以找到相应的记录，而第二个扫描表的每一行。 <br><br> 您会看到总体运行时间有所减少，性能应该会更好，但是有两次索引扫描，这使得内存在这里尤为重要，尤其是在表不适合其中的情况下。 在这种情况下，您必须首先执行全索引扫描，这是使用快速顺序读取执行的，这不是问题，但是随后您将执行许多随机读取操作，以按索引值选择行。 这些是随机读取操作，通常比顺序读取要慢几个数量级。 在这些情况下，全表扫描确实比全索引扫描更快。 <br><br>  <b>提示：</b>如果您想了解更多有关EXPLAIN的信息或更详细地考虑示例，请考虑阅读Guillaume Lelarge的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">《理解说明》</a> 。 <br><br><h2> 时间复杂度和大O </h2><br> 现在，您已经简要回顾了查询计划，可以开始使用计算复杂性理论更深入地研究并以更正式的术语考虑性能。 这是理论计算机科学领域，除其他事项外，它着重于根据计算问题的复杂性进行分类。 这些计算问题可能是算法，也可能是查询。 <br><br> 但是，对于查询，不一定根据其复杂性对它们进行分类，而是取决于完成查询和获得结果所需的时间。 这称为时间复杂度，您可以使用大号O表示法来表示或测量这种类型的复杂度。 <br><br> 使用大O表示，您可以根据输入随心所欲地相对于输入的增长速度来表示运行时间。 大号O表示法排除系数和低阶成员，因此您可以专注于查询执行时间的重要部分：其增长率。 当以这种方式表示时，丢弃低阶的系数和项，他们说时间复杂度是渐近描述的。 这意味着输入大小将变为无穷大。 <br><br> 在数据库语言中，复杂度决定了随着数据表的大小以及数据库的增长，完成查询所花费的时间。 <br><br>  <b>请注意</b> ，数据库的大小不仅因表中数据量的增加而增加，而且存在索引的事实也对大小起作用。 <br><br> 估算查询计划的时间复杂度 <br><br> 如您先前所见，执行计划除其他事项外，确定用于每个操作的算法，这使您可以根据查询计划中包含的表的大小来逻辑表示每个查询的执行时间，这称为复杂度函数。 换句话说，您可以使用大O表示法和执行计划来评估查询的复杂性和性能。 <br><br> 在以下各节中，您将概述四种类型的时间复杂度，并看到一些示例，这些示例说明了查询的时间复杂度如何根据执行上下文的不同而变化。 <br><br> 提示：索引是这个故事的一部分！ <br><br>  <b>但是，应该注意的</b>是，对于不同的数据库，索引的类型不同，执行计划不同，实现方式也不同，因此下面列出的临时困难非常普遍，可能会因具体设置而异。 <br><br><h3>  O（1）：恒定时间 </h3><br> 他们说，如果算法需要相同的时间量，则无论输入数据的大小如何，算法都将在恒定时间内工作。 对于查询，无论表的大小如何，如果需要相同的时间量，它将在固定时间内执行。 <br><br> 这种查询并不是很常见，但是下面是一个这样的示例： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> TOP <span class="hljs-number"><span class="hljs-number">1</span></span> t.* <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t</code> </pre> <br> 由于从表中选择了任意一行，因此时间复杂度是恒定的。 因此，时间长度不应取决于表的大小。 <br><br><h3> 线性时间：O（n） </h3><br> 他们说，如果算法的执行时间与输入数据的大小成正比，则该算法以线性时间工作，也就是说，时间随输入数据的大小线性增加。 对于数据库，这意味着执行时间将与表的大小成正比：随着表中行数的增加，查询的执行时间会增加。 <br><br> 一个示例是使用<code>WHERE</code>查询未索引的列：将需要全表扫描或<code>Seq Scan</code> ，这将导致O（n）时间复杂度。 这意味着必须阅读每一行才能找到具有所需标识符（ID）的行。 您根本没有任何限制，因此即使第一行符合条件，您也需要对每一行进行计数。 <br><br> 还考虑以下查询示例，如果<code>i_id</code>字段上没有索引，则查询示例的复杂度为O（n）： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> i_id <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> item;</code> </pre> <br><ul><li> 前面的内容还意味着其他查询，例如计算<code>COUNT (*) FROM TABLE;</code>的行数的查询<code>COUNT (*) FROM TABLE;</code> 将具有<i>O（n）的</i>时间复杂度，因为由于尚未保存表的总行数，因此需要进行全表扫描。 否则，时间复杂度将类似于<i>O（1）</i> 。 <br></li></ul><br> 线性运行时间与具有表联接的计划的运行时间密切相关。 以下是一些示例： <br><br><ul><li> 哈希联接的预期复杂度为O（M + N），用于内部联接两个表的经典哈希联接算法首先准备较小表的哈希表。 哈希表条目由连接属性及其字符串组成。 通过将哈希函数应用于连接属性来访问哈希表。 构建哈希表后，将扫描大型表，并通过搜索哈希表找到较小表中的相应行。 </li><li> 合并联接通常具有O（M + N）复杂度，但是它在很大程度上取决于联接列索引，如果没有索引，则是否根据联接中使用的键对行进行排序： <ul><li> 如果两个表均根据联接中使用的键进行排序，则查询的时间复杂度为O（M + N）。 </li><li> 如果两个表都具有连接列的索引，则索引已经按顺序支持了这些列，并且不需要排序。 难度为O（M + N）。 </li><li> 如果没有一个表在连接的列上有索引，则必须首先对两个表进行排序，以使复杂度看起来像O（M log M + N log N）。 </li><li> 如果只有一个表在连接的列上具有索引，则在连接步骤发生之前仅必须对没有索引的表进行排序，以使复杂度看起来像O（M + N log N）。 </li></ul></li><li> 对于嵌套联接，复杂度通常为O（MN）。 当一个或两个表都非常小（例如，少于10条记录）时，此联接有效。在评估查询时，这是很常见的情况，因为某些子查询被编写为仅返回一行。 </li></ul><br>  <b>请记住：</b>嵌套联接是将一个表中的每个记录与另一个表中的每个记录进行比较的联接。 <br><br><h3> 对数时间：O（log（n）） </h3><br> 据说，如果算法的执行时间与输入大小的对数成正比，则该算法以对数时间工作； 对于查询，这意味着如果执行时间与数据库大小的对数成正比，则将执行查询。 <br><br> 此对数时间复杂度对于<code>Index Scan</code>或聚集索引的查询计划有效。 聚集索引是一个索引，其中最终索引级别包含表的实际行。 聚集索引与任何其他索引相似：它在一个或多个列中定义。 它们形成索引键。 聚簇键是聚簇索引的键列。 扫描聚簇索引基本上是从DBMS中读取聚簇索引中从上到下的一行或多行的操作。 <br><br> 考虑以下查询示例，其中有一个<code>i_id</code>索引，通常会导致O（log（n））复杂度： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> i_stock <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> item <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> i_id = N;</code> </pre> <br> 注意，没有索引，时间复杂度将为O（n）。 <br><br><h3> 二次时间：O（n ^ 2） </h3><br> 如果算法的执行时间与输入大小的平方成正比，则可以认为算法以二次时间执行。 同样，对于数据库，这意味着查询执行时间与数据库大小的平方成正比。 <br><br> 二次时间复杂度查询的一个可能示例如下： <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> item, author <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> item.i_a_id=author.a_id</code> </pre> <br> 基于连接属性的索引信息，最小复杂度可以是O（n log（n）），但是最大复杂度可以是O（n ^ 2）。 <br><br> 总而言之，您还可以查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">以下备忘单</a> ，根据其时间复杂度和有效性来评估查询性能： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/dk/cq/fh/dkcqfhsmh_fxl7gorardyts9ptu.png"></div><br><h2>  SQL调优 </h2><br> 给定查询执行计划和时间复杂度，您可以进一步自定义SQL查询。 您可以从以下几点开始： <br><br><ul><li> 用索引扫描代替不必要的全表扫描； </li><li> 确保应用了最佳加入顺序。 </li><li> 确保最佳使用索引。 和 </li><li> 使用小表的全文本扫描的缓存（缓存小表的全表扫描。）。 </li></ul><br><h2> 进一步使用SQL </h2><br> 恭喜你！ 您已经到了本文的结尾，这里只是简要介绍了SQL查询的性能。 希望您了解有关反模式，查询优化器以及可用于分析，评估和解释查询计划的复杂性的工具的更多信息。 但是，您仍有很多发现！ 如果您想了解更多信息，请阅读R. Ramakrishnan和J. Gehrke撰写的“数据库管理系统”一书。 <br><br> 最后，我不想在这句话中拒绝您的StackOverflow： <br><blockquote> 我最喜欢的反模式不会检查您的请求。 <br><br> 但是，它适用于以下情况： <br><br><ul><li> 您的查询提供多个表。 </li><li> 您认为您已经为请求设计了最佳的产品，但是不要尝试验证您的假设。 </li><li> 您接受第一个工作请求，却不知道它与最佳请求有多接近。 </li></ul></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN465975/">https://habr.com/ru/post/zh-CN465975/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN465959/index.html">git里面的家谱</a></li>
<li><a href="../zh-CN465961/index.html">自行学习互联网营销：超过50门免费课程</a></li>
<li><a href="../zh-CN465963/index.html">德国的工资简历2019</a></li>
<li><a href="../zh-CN465969/index.html">政治正确性通过针对非初学者的SystemVerilog设计芯片书籍渗透俄罗斯</a></li>
<li><a href="../zh-CN465973/index.html">来自404fest 2018的10个最受欢迎的视频报告</a></li>
<li><a href="../zh-CN465977/index.html">培训Cisco 200-125 CCNA v3.0。 第31天。CDP，系统日志和NTP</a></li>
<li><a href="../zh-CN465979/index.html">记住所有^ W就是您所需要的。 体验使用Anki。 第1部分（入门级，倒数第二级）</a></li>
<li><a href="../zh-CN465981/index.html">与1C一起使用时，我的IBM DB2 Express-C管理经验：企业</a></li>
<li><a href="../zh-CN465983/index.html">英特尔Comet Lake：第十代仅14 nm</a></li>
<li><a href="../zh-CN465985/index.html">我们不仅使用概率数据结构来加速大型图的分布式处理</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>