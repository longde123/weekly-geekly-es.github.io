<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍅 🧜🏽 🐤 React组件的十诫 🚇 🧑🏾‍🤝‍🧑🏾 👨🏻‍💻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="由Kristofer Selbekk与Caroline Odden合作撰写。 基于2019年6月在奥斯陆举行的ReactJS会议上同名同人的演讲。 

 从翻译者那里看， 《十个组件诫命》的原始名称没有提到React，但是大多数示例和建议都专门涉及到React，此外，本文被放置在react标签下，并...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>React组件的十诫</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460559/"><p><img src="https://habrastorage.org/getpro/habr/post_images/adf/1cf/5da/adf1cf5da0c04102046e8b6e8c12322e.jpg" alt="十诫"></p><br><blockquote> 由<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Kristofer Selbekk</a>与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Caroline Odden</a>合作撰写。 基于2019年6月在奥斯陆举行的ReactJS会议上同名同人的演讲。 </blockquote><p>  <em>从翻译者那里看， <strong>《十个组件诫命》</strong>的原始名称没有提到React，但是大多数示例和建议都专门涉及到React，此外，本文被放置在react标签下，并且开发人员编写了react</em> 。 </p><br><p> 创建许多开发人员将要使用的组件并不容易。 如果这些道具是公共API的一部分，则必须仔细考虑要使用哪些道具。 </p><br><p>在本文中，我们将简要介绍一些用于整体开发API的最佳实践，并形成<strong>十个</strong>可用于创建开发人员乐于使用的组件的命令。 </p><a name="habracut"></a><br><p><img src="https://habrastorage.org/getpro/habr/post_images/eb9/35b/750/eb935b750f7a08ad9116ecd5a115f81e.jpg" alt="api"></p><br><h2 id="chto-takoe-api"> 什么是API？ </h2><br><p>  API（或应用程序编程接口）是两个代码相遇的地方。 这是<em>您的代码</em>与世界其他地方之间的接触面。 我们称此表面为界面。 这是可以与之交互的一组特定的操作或数据点。 </p><br><p> 该类与调用该类的代码之间的接口也是API。 您可以调用该类的方法来接收数据或运行其中包含的函数。 </p><br><p> 遵循相同的原则， <strong>您的组件接受</strong>的<strong>道具，这就是它的API</strong> 。 这是开发人员与您的组件进行交互的方式。 </p><br><h2 id="nekotorye-luchshie-praktiki-proektirovaniya-api"> 一些最佳的API设计实践 </h2><br><p> 那么，开发API时应遵循哪些规则和注意事项？ 好吧，我们进行了一些研究，结果发现，在这个问题上有很多宝贵的资源。 我们选择了两个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">-Josh Tauberer-</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">“什么才是好的API？”</a> 和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">罗恩·库里尔</a> （ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Ron Kurir）的同名</a>文章-谈到了这四种做法。 </p><br><h3 id="stabilnye-versii"> 稳定版本 </h3><br><p> 创建API时要考虑的最重要的事情之一就是使其保持尽可能的稳定。 关键更改的数量应最少。 如果必须进行重大更改，请确保编写详细的更新指南，并在可能的情况下，编写对开发人员而言可自动执行此过程的mod代码。 </p><br><h3 id="opisatelnye-soobscheniya-ob-oshibkah"> 描述性错误消息 </h3><br><p> 每当在调用API时发生错误时，您都应该尽一切可能解释发生了什么问题以及如何解决。 如果您用“滥用”之类的消息责骂用户，并且不给出任何解释，则您的API会留下不好的印象。 </p><br><p> 而是编写描述性错误，以帮助用户修复他们如何使用您的API。 </p><br><h3 id="minimizirovat-syurprizy-dlya-razrabotchikov"> 减少开发人员的意外 </h3><br><p> 开发人员是脆弱的生物，当他们使用您的API时，您不应惊吓它们。 换句话说，使您的API尽可能直观。 如果遵循最佳做法和现有的命名约定，则将实现此目的。 </p><br><p>另外，您的代码应始终保持一致。 如果在一个位置使用<code>is</code>或<code>has</code>的属性的逻辑名称，但将其进一步跳过，则会使人们<code>is</code>困惑。 </p><br><h3 id="minimizirovat-poverhnost-api"> 最小化API表面 </h3><br><p> 您的API也需要最小化。 许多功能都很棒，但是API的表面（API表面）越小，开发人员就必须对其进行研究以开始进行高效生产的工作就越少。 因此，您的API将被视为易于使用！ </p><br><p> 总有一种控制API大小的方法。 其中之一是从旧版本重构新的API。 </p><br><h2 id="desyat-zapovedey-dlya-veb-komponentov">  Web组件的十诫 </h2><br><p><img src="https://habrastorage.org/getpro/habr/post_images/15e/2c7/33c/15e2c733cf1d3b5e5916c17692a6df5a.jpg" alt="十诫"></p><br><p> 因此，这四个黄金规则对于REST API和Pascal上的旧程序非常有效-但是如何将它们转移到React的现代世界中？ </p><br><p> 如前所述，组件具有自己的API。 我们称它们为<code>props</code> ，正是在他们的帮助下，数据才被传输到组件。 我们如何构造道具以免违反上述任何规则？ </p><br><p> 我们创建了此<strong>十个黄金规则的</strong>列表，在创建组件时最好遵循这些<strong>规则</strong> 。 我们希望它们对您有用。 </p><br><h3 id="1-dokumentiruyte-ispolzovanie-komponentov">  1.记录组件的使用 </h3><br><p> 如果未记录您要使用组件的方式，则此组件无用。 好吧，几乎没有用，您总是可以看一下它的实现，但是很少有人喜欢这样做。 </p><br><p> 有多种方法来记录组件，但是我们建议您注意以下三种： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">故事书</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Styleguidist</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">多茨</a> </li></ul><br><p> 前两个为您提供了开发组件时的工作空间，第三个使您可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">MDX</a>以自由格式编写文档 </p><br><p> 无论您选择什么，都必须同时记录API本身以及应<strong>如何以及何时使用组件的</strong>文档。 最后一部分对于通用库至关重要-人们可以在给定的上下文中正确使用按钮或布局网格。 </p><br><h3 id="2-razreshite-kontekstnuyu-semantiku">  2.启用上下文语义 </h3><br><p>  HTML是一种用于以语义方式构造信息的语言。 仅在这里，我们的大多数组件都由<code>&lt;div /&gt;</code>标记组成。 这是有道理的-通用组件无法预先知道它们将是什么，可能是<code>&lt;article /&gt;</code>或<code>&lt;section /&gt;</code>或<code>&lt;aside /&gt;</code> -但是这种情况远非理想。 </p><br><p> 还有另一种选择，只是让您的组件接受prop <code>as</code> ，从而确定将呈现哪个DOM元素。 这是如何实现此示例： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Grid</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ as: Element, ...props }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Element</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"grid"</span></span></span></span><span class="xml"><span class="hljs-tag"> {</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">...props</span></span></span></span><span class="xml"><span class="hljs-tag">} /&gt;</span></span></span><span class="xml"> } Grid.defaultProps = { as: 'div', };</span></span></code> </pre> <br><p> 我们将prop重命名<code>as</code> <code>Element</code>变量，并在我们的JSX中使用它。 如果没有更多的语义HTML标记可以传递，我们将提供一个通用的默认<code>div</code>值。 </p><br><p> 当需要使用<code>&lt;Grid /&gt;</code>组件时，您只需传递正确的标签即可： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">App</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Grid</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">as</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"main"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">MoreContent</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Grid</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); }</code> </pre> <br><p> 这也适用于React组件。 例如，如果您希望<code>&lt;Button /&gt;</code>组件呈现React Router <code>&lt;Link /&gt;</code> ： </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">as</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">{Link}</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">to</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"/profile"</span></span></span><span class="hljs-tag">&gt;</span></span> Go to Profile <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><h3 id="3-izbegayte-logicheskih-boolean-propsov">  3.避免布尔道具 </h3><br><p> 逻辑道具是个好主意。 它们可以毫无价值地使用，因此看起来非常优雅： </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">large</span></span></span><span class="hljs-tag">&gt;</span></span>BUY NOW!<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p> 但是，尽管看起来不错，但逻辑属性仅允许两种可能性。 开启或关闭 可见或隐藏。  1或0。 </p><br><p> 每当您开始为大小，选项，颜色或除二进制选择之外的任何其他内容引入逻辑属性时，都会遇到问题。 </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">large</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">small</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">primary</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">disabled</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">secondary</span></span></span><span class="hljs-tag">&gt;</span></span>   ?? <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p> 换句话说，逻辑属性通常不会随需求的变化而扩展。 取而代之的是，对于可能成为二进制选择之外的值的情况，最好使用枚举值，例如字符串。 </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">variant</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"primary"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">size</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"large"</span></span></span><span class="hljs-tag">&gt;</span></span>     <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p> 这并不意味着完全不能使用逻辑属性。 可以！ 我上面列出的<code>disabled</code>道具应该仍然合乎逻辑-因为开和关之间没有中间状态。 仅保留布尔属性仅用于真正的二进制选择。 </p><br><h3 id="4-ispolzuyte-propschildren">  4.使用<code>props.children</code> </h3><br><p>  React具有一些特殊的属性，这些属性与其他属性有所不同。 需要使用这些<code>key</code>来跟踪列表项的顺序。 另一个这样的特殊道具是<code>children</code> 。 </p><br><p> 您放置在组件的开始标记和结束标记之间的所有内容都放在<code>props.children</code>内部。 并且您应该尽可能经常地使用它。 </p><br><p> 怎么了 因为这比为内容或仅需简单值（例如文本）的<code>content</code>提供道具<code>content</code>要容易得多。 </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TableCell</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">content</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Some text"</span></span></span><span class="hljs-tag"> /&gt;</span></span> //  <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TableCell</span></span></span><span class="hljs-tag">&gt;</span></span>Some text<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TableCell</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p> 使用<code>props.children</code>有几个优点。 首先，这类似于常规HTML的工作方式。 其次，您可以随意转让任何东西！ 无需在组件中添加诸如<code>leftIcon</code>和<code>rightIcon</code>类的道具-只需将它们作为<code>props.children</code>一部分传递<code>props.children</code> ： </p><br><pre> <code class="xml hljs"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TableCell</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ImportantIcon</span></span></span><span class="hljs-tag"> /&gt;</span></span> Some text <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TableCell</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p> 您可能会争辩说，您的组件仅需要呈现纯文本，在某些情况下是这样。 直到某个时候。 使用<code>props.children</code> ，您可以确保您的API可以满足不断变化的需求。 </p><br><h3 id="5-pozvolte-roditelyu-ceplyatsya-za-vnutrennyuyu-logiku">  5.让父母坚持内部逻辑 </h3><br><p> 有时，我们创建具有很多内部逻辑和状态的组件-例如，自动完成或交互式图表。 </p><br><p> 这样的组件经常遭受过多的API的困扰，其原因之一是随着项目的发展而积累了大量的不同用例。 </p><br><p> 但是，如果我们只提供一个标准化的道具，使开发人员可以控制，响应或简单地更改组件的默认行为，该怎么办？ </p><br><p> 肯特·多德斯（Kent Dodds）写了一篇关于状态简化器概念的出色文章。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">这里是有关概念本身的文章</a> ，也是关于如何在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">React钩子中实现这一</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">概念</a>的文章。 </p><br><p> 简而言之，这是到组件的状态减少器功能转移模式，这将使开发人员可以访问在组件内部执行的所有操作。 您可以更改状态，甚至引起副作用。 这是<strong>无需任何道具</strong>即可提供<strong>高水平定制</strong>的好方法。 </p><br><p> 可能是这样的： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyCustomDropdown</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> stateReducer = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">state, action</span></span></span><span class="hljs-function">) =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (action.type === Dropdown.actions.CLOSE) { buttonRef.current.focus(); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( &lt;&gt; &lt;Dropdown stateReducer={stateReducer} {...props} /&gt; &lt;Button ref={buttonRef}&gt;Open&lt;/Button&gt; &lt;/&gt; }</code> </pre> <br><p> 顺便说一句，您可以创建更简单的方式来响应事件。 在上一个示例中使用<code>onClose</code>可能会使使用该组件更加方便。 必要时使用“状态减少器”模式。 </p><br><h3 id="6-ispolzuyte-operator-troetochie-spread-dlya-ostavshihsya-propsov">  6.对其余道具使用价差运算符 </h3><br><p> 每次创建新组件时，请确保将省略号应用于其余道具，并将其发送到有意义的元素。 </p><br><p> 您无需继续向组件添加道具，只需将其传递给基本组件或元素即可。 这将使您的API更加稳定，在下一位开发人员需要新的事件侦听器或ARIA标签时，无需进行许多小版本错误。 </p><br><p> 您可以这样做： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToolTip</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ isVisible, ...rest }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> isVisible ? <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">role</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"tooltip"</span></span></span></span><span class="xml"><span class="hljs-tag"> {</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">...rest</span></span></span></span><span class="xml"><span class="hljs-tag">} /&gt;</span></span></span><span class="xml"> : null; }</span></span></code> </pre> <br><p> 每当您的组件将prop传递给实现时（例如类名或<code>onClick</code>处理程序），请确保其他开发人员可以执行相同的操作。 对于类，您可以简单地使用方便的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">npm classnames库</a> （或者只是字符串连接）添加prop类： </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> classNames <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'classnames'</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToolTip</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">span</span></span></span></span><span class="xml"><span class="hljs-tag"> {</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">...props</span></span></span></span><span class="xml"><span class="hljs-tag">} </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">className</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{classNames(</span></span></span></span><span class="xml"><span class="hljs-tag">'</span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">tooltip</span></span></span></span><span class="xml"><span class="hljs-tag">', </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">props.tooltip</span></span></span></span><span class="xml"><span class="hljs-tag">)} /&gt;</span></span></span><span class="xml"> }</span></span></code> </pre> <br><p> 对于单击处理程序和其他回调，可以使用一个小的实用程序将它们组合为一个函数。 这是执行此操作的一种方法： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">combine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...functions</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">...args</span></span></span><span class="hljs-function">) =&gt;</span></span> functions .filter(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span> func === <span class="hljs-string"><span class="hljs-string">'function'</span></span>) .forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">func</span></span></span><span class="hljs-function"> =&gt;</span></span> func(...args)); }</code> </pre> <br><p> 在这里，我们创建一个函数，该函数接受用于组合它们的函数列表。 它返回一个新的回调，该回调使用相同的参数依次调用它们。 </p><br><p> 此功能可以通过以下方式使用： </p><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToolTip</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [isVisible, setVisible] = React.useState(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> &lt;span {...props} className={classNames(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'tooltip'</span></span></span></span><span class="hljs-function"><span class="hljs-params">, props.className</span></span></span><span class="hljs-function">)} </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">onMouseIn</span></span></span><span class="hljs-function">={</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">combine</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span></span><span class="hljs-function">) =&gt;</span></span> setVisible(<span class="hljs-literal"><span class="hljs-literal">true</span></span>), props.onMouseIn)} onMouseOut={combine(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> setVisible(<span class="hljs-literal"><span class="hljs-literal">false</span></span>), props.onMouseOut)} /&gt; ); }</code> </pre> <br><h3 id="7-ispolzuyte-znacheniya-po-umolchaniyu">  7.使用默认值 </h3><br><p> 确保为道具提供足够的默认值（默认值）。 因此，您将减少强制性道具的数量。 这将大大简化您的API。 </p><br><p> 以<code>onClick</code>处理程序为例。 如果您的代码不需要此处理程序，请使用空函数（noop-function）作为默认属性。 这样，您就可以像始终传递代码一样在代码中调用它。 </p><br><p> 另一个示例可能是用户输入。 除非另外指定，否则假定输入字符串为空字符串。 这将使您确保始终处理字符串对象，而不是未定义或为null的对象。 </p><br><h3 id="8-ne-nado-pereimenovyvat-atributy-html">  8.无需重命名HTML属性 </h3><br><p>  HTML作为一种语言有其自己的道具或属性，它本身就是HTML元素的API。 那么，为什么不继续使用此API呢？ </p><br><p> 如前所述，最小化API表面及其直观性是改善组件API的有用方法。 因此，为什么不使用现有的<code>aria-label</code>而不是创建自己的<code>screenReaderLabel</code>道具？ </p><br><p>  <strong>不要</strong>为了自己的“易用性”而<strong>将任何现有的HTML属性重命名</strong> 。 您甚至不必替换现有的API，只需在其之上添加自己的API。 人们仍然可以将<code>aria-label</code>与screenReaderLabel属性一起传递-那么最终值应该是多少？ </p><br><p> 另外，请确保不要在组件中覆盖HTML属性。 一个很好的例子是<code>&lt;button /&gt;</code>元素的<code>type</code>属性。 可以<code>submit</code> （默认）， <code>button</code>或<code>reset</code> 。 但是，许多开发人员重新定义了此道具以表示按钮的视觉类型（ <code>primary</code> ， <code>cta</code>等）。 </p><br><p> 如果要使用这样的道具，则需要为true <code>type</code>属性添加替代。 这将导致开发人员的困惑，怀疑和烦恼。 </p><br><p> 相信我-我一次又一次犯了这个错误-如果您犯了这个错误，那么您将不得不长时间解决它。 </p><br><h3 id="9-pishite-tipy-propsov-ili-prosto-tipy">  9.写出道具的类型（或只是类型） </h3><br><p> 没有任何文档能比您代码中包含的文档更好。  React提供了一种使用<code>prop-types</code>包声明API的好方法。 使用它。 </p><br><p> 您可以为强制性和可选道具指定任何格式要求，并可以使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">JSDoc comments</a>对其进行改进。 </p><br><p> 如果您未指定强制性道具或传递无效或意外值，则在运行时，您将在控制台中收到警告。 这在开发过程中有很大帮助，可以从生产中删除。 </p><br><p> 如果您使用TypeScript或使用Flow编写React应用程序，则会获得API文档作为语言功能。 这进一步增强了开发工具的支持并简化了工作。 </p><br><p> 如果您自己不使用类型化的JavaScript，则仍应考虑向使用它的开发人员提供类型定义。 这样一来，他们使用您的组件将变得更加容易。 </p><br><h3 id="10-proektiruyte-dlya-razrabotchikov">  10.为开发人员设计 </h3><br><p> 最后，要遵循的最重要的规则。 确保为使用API​​的开发人员优化了API和与组件一起使用。 </p><br><p> 简化开发人员工作的一种方法是向他提供有关不当使用的反馈。 仅在开发过程中，使用错误消息进行警告，并且仅在开发过程中执行此操作，并发出警告，指出存在使用组件的更有效方法。 </p><br><p> 编写错误和警告时，请提供文档链接或显示简单的代码示例。 开发人员越快地了解问题所在以及如何解决问题，组件工作起来就越方便。 </p><br><p> 令人难以置信的是，但事实证明，所有这些长错误警告的存在并不影响最终包装的大小。 由于消除了死代码的奇迹，所有这些文本和错误代码都可以在生产中的组装过程中删除。 </p><br><p> 可提供令人难以置信的良好反馈的库之一是React本身。 忘记为列表项指定键，写错生命周期方法，忘记扩展基类或以不确定的方式调用钩子都没关系-无论如何，您将在控制台中收到大量的错误消息。 为什么使用您的组件的开发人员对您的期望会更低？ </p><br><p> 因此，为您的未来用户设计。 为未来设计。 为不幸的人设计，这些人在离开时必须维护您的代码！ 为开发人员设计。 </p><br><h3 id="itogo"> 合计 </h3><br><p> 我们可以从经典的API方法中学到很多东西。 遵循本文的提示，技巧，规则和诫命，您可以创建易于使用，易于维护，直观并且在必要时非常灵活的组件。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN460559/">https://habr.com/ru/post/zh-CN460559/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN460547/index.html">上古物品：Psion 5MX和退休生活</a></li>
<li><a href="../zh-CN460551/index.html">葡萄牙 每年最好的海滩和一千家创业公司</a></li>
<li><a href="../zh-CN460553/index.html">技术，外包和思维方式：我们如何在Lamoda的德国办事处实施Microsoft Dynamics 365</a></li>
<li><a href="../zh-CN460555/index.html">PyDaCon聚会在Mail.ru集团的报告，6月22日</a></li>
<li><a href="../zh-CN460557/index.html">数据处理的一些工作示例</a></li>
<li><a href="../zh-CN460561/index.html">如何使用Unity开发另一个平台游戏。 另一个教程，第2部分</a></li>
<li><a href="../zh-CN460565/index.html">为帐户而战。 杰弗里咖啡网络的创始人在VKontakte上提起诉讼</a></li>
<li><a href="../zh-CN460567/index.html">React Native：创建一个可拖动和可滑动的列表</a></li>
<li><a href="../zh-CN460569/index.html">编写具有客户端服务器实用程序Windows功能的软件，第01部分</a></li>
<li><a href="../zh-CN460573/index.html">Google声明“ reCAPTCHA”不会滥用用户数据。 值得值得相信吗？</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>