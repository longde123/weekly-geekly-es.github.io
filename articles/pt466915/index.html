<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöÑ üôãüèª üë®üèº‚Äçüíª Como tornar a SFINAE elegante e confi√°vel üë©‚Äç‚ù§Ô∏è‚Äçüë© üßùüèæ üë∑</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ol√° novamente. Estamos compartilhando com voc√™ um artigo interessante, cuja tradu√ß√£o foi preparada especificamente para os alunos do curso "Desenvolve...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Como tornar a SFINAE elegante e confi√°vel</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/466915/">  <i>Ol√° novamente.</i>  <i>Estamos compartilhando com voc√™ um artigo interessante, cuja tradu√ß√£o foi preparada especificamente para os alunos do curso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">"Desenvolvedor C ++"</a> .</i> <br><br><img src="https://habrastorage.org/webt/i1/cn/mm/i1cnmmt1eyhcbyi9exnawbo2vgq.png"><br><br><hr><br>  Hoje temos uma postagem de convidado de d√°m Bal√°zs.  Adam √© engenheiro de software da Verizon Smart Communities Hungary e desenvolve an√°lise de v√≠deo para sistemas embarcados.  Uma de suas paix√µes √© a otimiza√ß√£o do tempo de compila√ß√£o, ent√£o ele imediatamente concordou em escrever um post sobre este t√≥pico.  Voc√™ pode encontrar Adam online no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">LinkedIn</a> . <a name="habracut"></a><br><br>  Em uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">s√©rie de artigos sobre como tornar o SFINAE elegante</a> , vimos como tornar nosso modelo SFINAE bastante <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">conciso e expressivo</a> . <br><br>  Basta dar uma olhada em sua forma original: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyClass</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; x)</span></span></span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_ = T&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> f(T&amp;&amp; x, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::enable_if&lt;!<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_reference&lt;T_&gt;::value, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">nullptr_t</span></span>&gt;::type = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>){} };</code> </pre> <br><br>  E compare-o com esta forma mais expressiva: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> IsNotReference = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt;!<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_reference_v&lt;T&gt;&gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params">&amp; x)</span></span></span></span>{} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T_ = T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = IsNotReference &lt;T_&gt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> f(T&amp;&amp; x){} };</code> </pre> <br>  Podemos razoavelmente acreditar que j√° √© poss√≠vel relaxar e come√ßar a us√°-lo na produ√ß√£o.  Poder√≠amos, funciona na maioria dos casos, mas - como falamos sobre interfaces - nosso c√≥digo deve ser seguro e confi√°vel.  √â isso mesmo?  Vamos tentar hackear! <br><br><h2>  Falha # 1: SFINAE pode ser contornado </h2><br>  Normalmente, o SFINAE √© usado para desativar parte do c√≥digo, dependendo da condi√ß√£o.  Isso pode ser muito √∫til se precisarmos implementar, por exemplo, a fun√ß√£o definida pelo usu√°rio abs por qualquer motivo (classe aritm√©tica definida pelo usu√°rio, otimiza√ß√£o para um equipamento espec√≠fico, para fins de treinamento etc.): <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myAbs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( T val )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( ( val &lt;= <span class="hljs-number"><span class="hljs-number">-1</span></span> ) ? -val : val ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &gt;::max() }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"a: "</span></span> &lt;&lt; a &lt;&lt; <span class="hljs-string"><span class="hljs-string">" myAbs( a ): "</span></span> &lt;&lt; myAbs( a ) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br>  Este programa exibe o seguinte, que parece bastante normal: <br><br><pre> <code class="cpp hljs">a: <span class="hljs-number"><span class="hljs-number">2147483647</span></span> myAbs( a ): <span class="hljs-number"><span class="hljs-number">2147483647</span></span></code> </pre> <br>  Mas podemos chamar nossa fun√ß√£o <code>abs</code> com argumentos n√£o assinados <code>T</code> , e o efeito ser√° catastr√≥fico: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">nt </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &gt;::max() }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">cout</span></span> &lt;&lt; <span class="hljs-string"><span class="hljs-string">"a: "</span></span> &lt;&lt; a &lt;&lt; <span class="hljs-string"><span class="hljs-string">" myAbs( a ): "</span></span> &lt;&lt; myAbs( a ) &lt;&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">endl</span></span>; }</code> </pre> <br>  De fato, agora o programa exibe: <br><br> <code>a: 4294967295 myAbs( a ): 1</code> <br> <br>  Nossa fun√ß√£o n√£o foi projetada para trabalhar com argumentos n√£o assinados, portanto, devemos limitar o conjunto poss√≠vel de <code>T</code> com SFINAE: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> IsSigned = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_signed_v&lt; T &gt; &gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = IsSigned&lt; T &gt; &gt; T myAbs( T val ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( ( val &lt;= <span class="hljs-number"><span class="hljs-number">-1</span></span> ) ? -val : val ); }</code> </pre> <br>  O c√≥digo funciona conforme o esperado: uma chamada para myAbs com um tipo n√£o assinado causa um erro em tempo de compila√ß√£o: <br><br> <code><code>candidate template ignored: requirement 'std::is_signed_v&lt;</code> unsigned int&gt;' was not satisfied [with T = unsigned int]</code> <br> <br><h3>  Hacking SFINAE State </h3><br>  Ent√£o, o que h√° de errado com essa fun√ß√£o?  Para responder a essa pergunta, precisamos verificar como o myAbs implementa o SFINAE. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = IsSigned&lt;T&gt; &gt; T myAbs( T val );</code> </pre> <br>  <code>myAbs</code> √© um modelo de fun√ß√£o com dois tipos de par√¢metros de modelo de entrada.  O primeiro √© o tipo real do argumento da fun√ß√£o, o segundo √© o <code><code>IsSigned &lt;</code> T <code>&gt;</code></code> padr√£o (caso contr√°rio, <code><code>std::enable_if_t &lt;</code> std::is_signed_v <code>&lt;</code> T <code>&gt;</code> &gt;</code> ou ent√£o <code><code>std::enable_if &lt;</code> std::is_signed_v <code>&lt;</code> T&gt;, void&gt;::type</code> , que √© <code>void</code> ou falhou na substitui√ß√£o). <br><br>  Como podemos chamar <code>myAbs</code> ?  Existem 3 maneiras: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a{ myAbs( <span class="hljs-number"><span class="hljs-number">-5</span></span> ) }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b{ myAbs&lt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &gt;( <span class="hljs-number"><span class="hljs-number">-5</span></span> ) }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> c{ myAbs&lt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> &gt;( <span class="hljs-number"><span class="hljs-number">-5</span></span> ) };</code> </pre> <br>  A primeira e a segunda chamadas s√£o diretas, mas a terceira √© interessante: qual √© o argumento do modelo de <code>void</code> ? <br><br>  O segundo par√¢metro do modelo √© an√¥nimo, tem um tipo padr√£o, mas ainda √© um par√¢metro do modelo, para que voc√™ possa especific√°-lo explicitamente.  Isso √© um problema?  Nesse caso, esse √© realmente um grande problema.  Podemos usar o terceiro formul√°rio para contornar nossa verifica√ß√£o do SFINAE: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> d{ myAbs&lt; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> &gt;( <span class="hljs-number"><span class="hljs-number">5u</span></span> ) }; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> e{ myAbs&lt; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> &gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::numeric_limits&lt; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &gt;::max() ) };</code> </pre> <br>  Esse c√≥digo compila bem, mas leva a resultados desastrosos, para evitar o que usamos SFINAE: <br><br><pre> <code class="cpp hljs">a: <span class="hljs-number"><span class="hljs-number">4294967295</span></span> myAbs( a ): <span class="hljs-number"><span class="hljs-number">1</span></span></code> </pre> <br>  Vamos resolver esse problema - mas primeiro: existem outras desvantagens?  Bem ... <br><br><h2>  Falha # 2: n√£o podemos ter implementa√ß√µes espec√≠ficas </h2><br>  Outro uso comum do SFINAE √© fornecer implementa√ß√µes espec√≠ficas para condi√ß√µes espec√≠ficas de tempo de compila√ß√£o.  E se n√£o quisermos banir completamente a chamada de <code>myAbs</code> com valores <code>myAbs</code> e fornecer uma implementa√ß√£o trivial para esses casos?  Podemos usar if constexpr no C ++ 17 (discutiremos isso mais tarde) ou podemos: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> IsSigned = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_signed_v&lt; T &gt; &gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> IsUnsigned = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_unsigned_v&lt; T &gt; &gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = IsSigned&lt; T &gt; &gt; T myAbs( T val ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( ( val &lt;= <span class="hljs-number"><span class="hljs-number">-1</span></span> ) ? -val : val ); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = IsUnsigned&lt; T &gt; &gt; T myAbs( T val ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; }</code> </pre> <br>  Mas o que √© isso? <br><br><pre> <code class="cpp hljs">error: <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> parameter redefines <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> argument <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = IsUnsigned&lt; T &gt; &gt; note: previous <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> argument defined here <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = IsSigned&lt; T &gt; &gt;</code> </pre> <br>  <i><b>Ah, o padr√£o C ++ (C ++ 17; ¬ß17.1.16) declara o seguinte</b> :</i> <br><br><blockquote>  "Os argumentos padr√£o n√£o devem ser fornecidos ao par√¢metro do modelo por duas declara√ß√µes diferentes no mesmo escopo." </blockquote><br>  Opa, foi exatamente isso que fizemos ... <br><br><h3>  Por que n√£o usar regularmente se? </h3><br>  Poder√≠amos apenas usar se em tempo de execu√ß√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myAbs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( T val )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_signed_v&lt; T &gt; ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( ( val &lt;= <span class="hljs-number"><span class="hljs-number">-1</span></span> ) ? -val : val ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; } }</code> </pre> <br>  O compilador otimizaria a condi√ß√£o porque <code><code>if (std::is_signed_v &lt;</code> T&gt;)</code> se <code><code>if (std::is_signed_v &lt; T&gt;)</code></code> <code>if (true)</code> ou <code>if (false)</code> ap√≥s a cria√ß√£o do modelo.  Sim, com nossa implementa√ß√£o atual de <code>myAbs</code> isso funcionar√°.  Mas, no geral, isso imp√µe uma limita√ß√£o enorme: as <code>else</code> <code>if</code> e <code>else</code> devem ser v√°lidas para cada <code>T</code>  E se mudarmos um pouco a nossa implementa√ß√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myAbs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( T val )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_signed_v&lt; T &gt; ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>( val ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a{ myAbs( <span class="hljs-number"><span class="hljs-number">5u</span></span> ) }; }</code> </pre> <br>  Nosso c√≥digo falhar√° imediatamente: <br><br><pre> <code class="cpp hljs">error: call of overloaded <span class="hljs-string"><span class="hljs-string">'abs(unsigned int&amp;)'</span></span> is ambiguous</code> </pre> <br>  Essa restri√ß√£o √© o que o SFINAE elimina: podemos escrever um c√≥digo v√°lido apenas para um subconjunto de T (em myAbs √© v√°lido apenas para tipos n√£o assinados ou v√°lido apenas para tipos assinados). <br><br><h3>  Solu√ß√£o: outro formul√°rio para SFINAE </h3><br>  O que podemos fazer para superar essas defici√™ncias?  Para o primeiro problema, devemos for√ßar nossa verifica√ß√£o SFINAE, independentemente de como os usu√°rios invocam nossa fun√ß√£o.  Atualmente, nosso teste pode ser contornado quando o compilador n√£o precisa do tipo padr√£o para o segundo par√¢metro do modelo. <br><br>  E se usarmos nosso c√≥digo SFINAE para declarar um tipo de par√¢metro de modelo em vez de fornecer um tipo padr√£o?  Vamos tentar: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> IsSigned = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">enable_if_t</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_signed_v&lt; T &gt;, <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> &gt;; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, IsSigned&lt; T &gt; = <span class="hljs-literal"><span class="hljs-literal">true</span></span> &gt; T myAbs( T val ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( ( val &lt;= <span class="hljs-number"><span class="hljs-number">-1</span></span> ) ? -val : val ); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//int a{ myAbs( 5u ) }; int b{ myAbs&lt; int &gt;( 5u ) }; //int c{ myAbs&lt; unsigned int, true &gt;( 5u ) }; }</span></span></code> </pre> <br>  Precisamos que IsSigned seja um tipo diferente de nulo em casos v√°lidos, porque queremos fornecer um valor padr√£o para esse tipo.  N√£o h√° valor para o tipo void; portanto, devemos usar outra coisa: bool, int, enum, nullptr_t, etc. Normalmente, eu uso bool - nesse caso, as express√µes parecem significativas: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, IsSigned&lt; T &gt; = <span class="hljs-literal"><span class="hljs-literal">true</span></span> &gt;</code> </pre> <br>  Isso funciona!  Para <code>myAbs (5u)</code> compilador gera um erro, como antes: <br><br><pre> <code class="cpp hljs">candidate <span class="hljs-keyword"><span class="hljs-keyword">template</span></span> ignored: requirement <span class="hljs-string"><span class="hljs-string">'std::is_signed_v&lt;unsigned int&gt;'</span></span> was <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> satisfied [with T = <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span></code> </pre> <br>  A segunda chamada, <code><code>myAbs &lt;</code> int&gt; (5u)</code> ainda √© v√°lida, dizemos explicitamente ao tipo <code>T</code> do compilador, portanto ele converte <code>5u</code> em <code>int</code> . <br><br>  Finalmente, n√£o podemos mais rastrear <code>myAbs</code> no dedo: <code><code>myAbs &lt;</code> unsigned int, true&gt; (5u)</code> gera um erro.  N√£o importa se fornecemos ou n√£o um valor padr√£o na chamada, parte da express√£o SFINAE √© avaliada de qualquer maneira, porque o compilador precisa de um tipo de argumento com um valor de modelo an√¥nimo. <br><br>  Podemos avan√ßar para o pr√≥ximo problema - mas espere um minuto!  Acho que n√£o substitu√≠mos o argumento padr√£o do mesmo par√¢metro de modelo.Qual era a situa√ß√£o original? <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = IsUnsigned&lt; T &gt; &gt; T myAbs( T val ); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> = IsSigned&lt; T &gt; &gt; T myAbs( T val );</code> </pre> <br>  Mas agora com o c√≥digo atual: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, IsUnsigned&lt; T &gt; = <span class="hljs-literal"><span class="hljs-literal">true</span></span> &gt; T myAbs( T val ); <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, IsSigned&lt; T &gt; = <span class="hljs-literal"><span class="hljs-literal">true</span></span> &gt; T myAbs( T val );</code> </pre> <br>  Parece muito semelhante ao c√≥digo anterior, portanto, podemos pensar que isso tamb√©m n√£o funcionar√°, mas, na verdade, esse c√≥digo n√£o tem o mesmo problema.  O que √© <code><code>IsUnsigned &lt;</code> T&gt;</code> ?  Pesquisa booliana ou com falha.  E o que √© <code><code>IsSigned &lt;</code> T&gt;</code> ?  A mesma coisa, mas se um deles √© Bool, o outro √© uma falha na pesquisa. <br><br>  Isso significa que n√£o substitu√≠mos os argumentos padr√£o, uma vez que existe apenas uma fun√ß√£o com o argumento bool do modelo, a outra √© uma substitui√ß√£o com falha e, portanto, ela n√£o existe. <br><br><h3>  A√ß√∫car sint√°tico </h3><br>  <i><b>UPD</b></i>  <i>Este par√°grafo foi exclu√≠do pelo autor devido a erros encontrados nele.</i> <br><br><h3>  Vers√µes antigas do C ++ </h3><br>  Todas as op√ß√µes acima funcionam com o C ++ 11, a √∫nica diferen√ßa √© a verbosidade das defini√ß√µes de restri√ß√µes entre as vers√µes padr√£o: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//C++11 template&lt; typename T &gt; using IsSigned = typename std::enable_if&lt; std::is_signed&lt; T &gt;::value, bool &gt;::type; //C++14 - std::enable_if_t template&lt; typename T &gt; using IsSigned = std::enable_if_t&lt; std::is_signed&lt; T &gt;::value, bool &gt;; //C++17 - std::is_signed_v template&lt; typename T &gt; using IsSigned = std::enable_if_t&lt; std::is_signed_v&lt; T &gt;, bool &gt;;</span></span></code> </pre> <br>  Mas o modelo permanece o mesmo: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, IsSigned&lt; T &gt; = <span class="hljs-literal"><span class="hljs-literal">true</span></span> &gt;</code> </pre> <br>  No bom e velho C ++ 98, n√£o h√° aliases de modelo; al√©m disso, os modelos de fun√ß√£o n√£o podem ter tipos ou valores padr√£o.  Podemos inserir nosso c√≥digo SFINAE no tipo de resultado ou apenas na lista de par√¢metros de fun√ß√£o.  A segunda op√ß√£o √© recomendada porque os construtores n√£o t√™m tipos de resultado.  O melhor que podemos fazer √© algo assim: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myAbs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( T val, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> my_enable_if&lt; my_is_signed&lt; T &gt;::value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">bool</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &gt;::type = </span></span><span class="hljs-literal"><span class="hljs-function"><span class="hljs-params"><span class="hljs-literal">true</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( ( val &lt;= <span class="hljs-number"><span class="hljs-number">-1</span></span> ) ? -val : val ); }</code> </pre> <br>  Apenas para compara√ß√£o - a vers√£o moderna do C ++: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T, IsSigned&lt; T &gt; = <span class="hljs-literal"><span class="hljs-literal">true</span></span> &gt; T myAbs( T val ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( ( val &lt;= <span class="hljs-number"><span class="hljs-number">-1</span></span> ) ? -val : val ); }</code> </pre> <br>  A vers√£o do C ++ 98 √© feia, apresenta um par√¢metro sem sentido, mas funciona - voc√™ pode us√°-lo se for absolutamente necess√°rio.  E sim: <code>my_enable_if</code> e <code>my_is_signed</code> devem ser implementados ( <code>std :: enable_if  std :: is_signed</code> eram novos no C ++ 11). <br><br><h3>  Estado atual </h3><br>  O C ++ 17 introduziu <code>if constexpr</code> , um m√©todo para descartar c√≥digos com base em condi√ß√µes em tempo de compila√ß√£o.  As instru√ß√µes if e else devem estar sintaticamente corretas, mas a condi√ß√£o ser√° avaliada em tempo de compila√ß√£o. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myAbs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( T val )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::is_signed_v&lt; T &gt; )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( ( val &lt;= <span class="hljs-number"><span class="hljs-number">-1</span></span> ) ? -val : val ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_unsigned_v&lt; T &gt; ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; } <span class="hljs-comment"><span class="hljs-comment">/*else { static_assert( false, "T must be signed or unsigned arithmetic type." ); }*/</span></span> } }</code> </pre> <br>  Como podemos ver, nossa fun√ß√£o abs tornou-se mais compacta e f√°cil de ler.  No entanto, o manuseio de tipos n√£o conformes n√£o √© simples.  O <code>static_assert</code> e incondicional torna essa afirma√ß√£o pouco consistente, o que √© proibido pelo padr√£o, independentemente de ser descartado ou n√£o. <br><br>  Felizmente, existe uma brecha: nos objetos de modelo, os operadores descartados n√£o s√£o criados se a condi√ß√£o for independente do valor.  √ìtimo! <br><br>  Portanto, o √∫nico problema com o nosso c√≥digo √© que ele falha durante a defini√ß√£o do modelo.  Se pud√©ssemos adiar a avalia√ß√£o de <code>static_assert</code> at√© o momento em que o modelo foi criado, o problema seria resolvido: ele seria criado se e somente se todas as nossas condi√ß√µes forem falsas.  Mas como podemos adiar <code>static_assert</code> at√© que o modelo seja criado?  Torne sua condi√ß√£o dependente do tipo! <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> &gt; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> dependent_false_v{ <span class="hljs-literal"><span class="hljs-literal">false</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-function"><span class="hljs-function">T </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myAbs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( T val )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::is_signed_v&lt; T &gt; )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( ( val &lt;= <span class="hljs-number"><span class="hljs-number">-1</span></span> ) ? -val : val ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_unsigned_v&lt; T &gt; ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( dependent_false_v&lt; T &gt;, <span class="hljs-string"><span class="hljs-string">"Unsupported type"</span></span> ); } } }</code> </pre> <br><h3>  Sobre o futuro </h3><br>  J√° estamos realmente pr√≥ximos, mas precisamos esperar um pouco at√© o C ++ 20 trazer a solu√ß√£o final: conceitos!  Isso mudar√° completamente a maneira como os modelos (e SFINAE) s√£o usados. <br><br>  Em poucas palavras: conceitos podem ser usados ‚Äã‚Äãpara limitar o conjunto de argumentos que s√£o aceitos para os par√¢metros do modelo.  Para nossa fun√ß√£o abs, poder√≠amos usar o seguinte conceito: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-function"><span class="hljs-function">concept </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Arithmetic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_arithmetic_v&lt; T &gt;; }</code> </pre> <br>  E como podemos usar conceitos?  Existem tr√™s maneiras: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//   template&lt; typename T &gt; requires Arithmetic&lt; T &gt;() T myAbs( T val ); //   template&lt; Arithmetic T &gt; T myAbs( T val ); //  Arithmetic myAbs( Arithmetic val );</span></span></code> </pre> <br>  Observe que o terceiro formul√°rio ainda declara uma fun√ß√£o de modelo!  Aqui est√° a implementa√ß√£o completa de myAbs em C ++ 20: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> T &gt; <span class="hljs-function"><span class="hljs-function">concept </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Arithmetic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::is_arithmetic_v&lt; T &gt;; } <span class="hljs-function"><span class="hljs-function">Arithmetic </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">myAbs</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( Arithmetic val )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::is_signed_v&lt; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">decltype</span></span></span></span><span class="hljs-function"><span class="hljs-params">( val ) &gt; )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>( ( val &lt;= <span class="hljs-number"><span class="hljs-number">-1</span></span> ) ? -val : val ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> val; } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a{ myAbs( <span class="hljs-number"><span class="hljs-number">5u</span></span> ) }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b{ myAbs&lt; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &gt;( <span class="hljs-number"><span class="hljs-number">5u</span></span> ) }; <span class="hljs-comment"><span class="hljs-comment">//std::string c{ myAbs( "d" ) }; }</span></span></code> </pre> <br>  Uma chamada comentada fornece o seguinte erro: <br><br><pre> <code class="cpp hljs">error: cannot call function <span class="hljs-string"><span class="hljs-string">'auto myAbs(auto:1) [with auto:1 = const char*]'</span></span> constraints <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> satisfied within <span class="hljs-string"><span class="hljs-string">'template&lt;class T&gt; concept bool Arithmetic() [with T = const char*]'</span></span> <span class="hljs-function"><span class="hljs-function">concept </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Arithmetic</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>{ ^~~~~~~~~~ <span class="hljs-string"><span class="hljs-string">'std::is_arithmetic_v'</span></span> evaluated to <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre> <br>  Pe√ßo a todos que ousadamente usem esses m√©todos no c√≥digo de produ√ß√£o; o tempo de compila√ß√£o √© mais barato que o tempo de execu√ß√£o.  Feliz SFINAEing! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt466915/">https://habr.com/ru/post/pt466915/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt466899/index.html">Por que largar tudo e aprender Swift e Kotlin agora</a></li>
<li><a href="../pt466903/index.html">Sempre apresente seu trabalho</a></li>
<li><a href="../pt466905/index.html">Para a quest√£o do U-Boot</a></li>
<li><a href="../pt466907/index.html">5G e WiFi 6: quando duas tecnologias de rede s√£o melhores que uma</a></li>
<li><a href="../pt466911/index.html">O tribunal dos EUA legalizou totalmente a raspagem de sites e proibiu-o de obstruir tecnicamente</a></li>
<li><a href="../pt466917/index.html">Quando o padr√£o HTTP n√£o √© suficiente. Confirma√ß√£o de micronauta</a></li>
<li><a href="../pt466921/index.html">5 problemas de qualquer empresa de servi√ßos e sua solu√ß√£o usando a plataforma de automa√ß√£o</a></li>
<li><a href="../pt466923/index.html">Como profissionais de TI em um banco estrangeiro para provar a origem dos fundos</a></li>
<li><a href="../pt466925/index.html">Como executar o VDS Hi-CPU para Bitrix, dispersar papagaios e n√£o quebrar</a></li>
<li><a href="../pt466929/index.html">Adicionar token de atualiza√ß√£o</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>