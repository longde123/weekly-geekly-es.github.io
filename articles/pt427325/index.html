<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏀 🐣 🥣 Início rápido com o WPF. Parte 1. Ligação, INotifyPropertyChanged e MVVM 👐🏻 🎅🏾 💆</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Olá pessoal! 


 Por várias razões, a maioria de nós usa aplicativos de área de trabalho, pelo menos um navegador :) E alguns de nós precisam escrever...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Início rápido com o WPF. Parte 1. Ligação, INotifyPropertyChanged e MVVM</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/427325/"><p>  Olá pessoal! </p><br><p> Por várias razões, a maioria de nós usa aplicativos de área de trabalho, pelo menos um navegador :) E alguns de nós precisam escrever nossos próprios.  Neste artigo, desejo examinar o processo de desenvolvimento de um aplicativo de desktop simples usando a tecnologia <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Windows Presentation Foundation (WPF)</a> e aplicando o padrão MVVM.  Aqueles que desejam continuar lendo, por favor, abaixo do gato. <a name="habracut"></a></p><br><p>  Acho que não é necessário dizer que o WPF é o desenvolvimento da Microsoft :) Essa tecnologia foi projetada para desenvolver aplicativos de desktop para Windows, começando com o Windows XP.  Porque assim?  Isso ocorre pelo fato de o WPF ser executado na plataforma .NET, cujos requisitos mínimos são o Windows XP e posterior.  Infelizmente, o WPF não funciona em outras plataformas, embora haja chances de que isso mude no futuro próximo: a estrutura <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Avalonia</a> baseada no WPF está <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">em desenvolvimento</a> . </p><br><h4 id="v-chyom-osobennost-wpf">  O que há de especial no WPF? </h4><br><p>  Duas principais diferenças entre o WPF e outras ferramentas de criação de desktops: </p><br><ul><li>  A linguagem de marcação XAML para marcar a própria interface da janela. </li><li>  Renderização através do DirectX, aceleração gráfica de hardware. </li></ul><br><p>  Eu não vou entrar em detalhes, porque  este não é exatamente o tópico do artigo.  Se estiver interessado, pesquise no Google XAML, renderização WPF, milcore.dll e DirectX :) </p><br><h4 id="o-chyom-eta-statya">  Sobre o que é este artigo? </h4><br><p>  Este artigo contém um aplicativo de exemplo criado na tecnologia WPF: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Interface MVVM e INotifyPropertyChanged.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Cópia do texto.</a> </li></ul><br><p>  Tentarei orientar o material do artigo em uma direção prática, no estilo de "repita comigo", com explicações. </p><br><h4 id="chto-nam-ponadobitsya-dlya-povtoreniya-stati">  O que precisamos para repetir o artigo? </h4><br><p>  Pouca experiência em desenvolvimento em C # :) No mínimo, você precisa entender bem a sintaxe da linguagem.  Você também precisará de uma máquina Windows (Win 10 nos exemplos) com o Visual Studio instalado (nos exemplos em 2017, há uma versão gratuita da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Comunidade</a> ).  Ao instalar o VS, você precisará ativar o suporte ao desenvolvimento de área de trabalho para a plataforma .NET </p><br><p><img src="https://habrastorage.org/webt/g2/uf/ea/g2ufeaboqvhjvklpzn29cx45w3c.png" alt="imagem"></p><br><p>  Também nesta seção, descreverei a criação de um projeto. </p><br><p>  Lançamos o VS, criamos um novo projeto, selecionamos o tipo de aplicativo WPF App (.NET Framework) (você pode inseri-lo na barra de pesquisa no canto superior direito) e nomeie o que for. </p><br><p><img src="https://habrastorage.org/webt/jb/mo/gu/jbmoguoemuje0em1g2gbofodsns.png" alt="imagem"></p><br><p>  Depois de criar um novo projeto, a janela do editor de interface é aberta, fica assim para mim </p><br><p><img src="https://habrastorage.org/webt/2d/tn/do/2dtndo0yii6z78g-1avlkglqoew.jpeg" alt="imagem"></p><br><p>  Na parte inferior, há um editor de layout; na parte superior, há uma visualização da interface da janela, mas você pode alterar a localização relativa do editor de código e a visualização da interface para que eles fiquem na ordem horizontal usando esses botões (à direita da borda das duas áreas): </p><br><p><img src="https://habrastorage.org/webt/m8/xl/fo/m8xlfoleczsfra-w8yskkxg9ko4.png" alt="imagem"></p><br><h4 id="pered-tem-kak-nachat">  Antes de começar </h4><br><p>  Os elementos da janela (também chamados de controles da palavra <strong>Controle</strong> ) devem ser colocados dentro do contêiner ou dentro de outro elemento do tipo ContentControl.  <strong>Um contêiner</strong> é um controle especial que permite colocar vários controles filho dentro e organizar seu arranjo mútuo.  Exemplos de recipientes: </p><br><ul><li>  <strong>Grade</strong> - permite organizar elementos por colunas e linhas, a largura de cada coluna ou linha é configurada individualmente. </li><li>  <strong>StackPanel</strong> - permite organizar filhos em uma única linha ou coluna. </li></ul><br><p>  Existem outros recipientes.  Como o contêiner também é um controle, dentro dele, pode haver contêineres aninhados contendo contêineres aninhados e assim por diante.  Isso permite que você organize de maneira flexível os controles entre si.  Além disso, com a ajuda de contêineres, não podemos controlar com menos flexibilidade o comportamento de controles aninhados ao redimensionar uma janela. </p><br><h4 id="mvvm-i-interfeys-inotifypropertychanged-kopiya-teksta">  Interface MVVM e INotifyPropertyChanged.  Cópia do texto. </h4><br><p>  <em>O resultado deste exemplo será um aplicativo com dois controles, em um dos quais você pode editar o texto e na outra apenas visualização.</em>  <em>Alterações de uma para outra serão transferidas de forma síncrona sem cópia explícita do texto usando a <strong>ligação</strong> .</em> </p><br><p>  Portanto, temos um projeto recém-criado ( <strong>chamei</strong> -o de <strong>Ex1</strong> ), vá para o editor de layout e primeiro substitua o contêiner padrão ( <strong>&lt;Grid&gt; &lt;/Grid&gt;</strong> ) por <strong>&lt;StackPanel&gt; &lt;/StackPanel&gt;</strong> .  Este contêiner será suficiente, porque  precisaremos colocar apenas dois controles um acima do outro.  Especificamos explicitamente como os componentes serão organizados adicionando a propriedade <strong>Orientation = "Vertical"</strong> .  Adicione alguns elementos dentro da pilha do painel: um campo para inserir texto e um campo para exibir texto.  Como esses controles não contêm código incorporado, você pode descrevê-los com uma tag de fechamento automático (consulte o código abaixo).  Após todos os procedimentos acima, o código de descrição do contêiner e os controles aninhados devem assumir o seguinte formato: </p><br><pre><code class="hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">StackPanel</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">Orientation</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"Vertical"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TextBox</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">TextBlock</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">StackPanel</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  Agora vamos nos concentrar no objetivo deste exemplo.  Queremos que, ao digitar na caixa de texto, o mesmo texto seja exibido de forma síncrona no bloco de texto, evitando a operação de cópia explícita.  Precisamos de algum tipo de entidade conectora, e aqui chegamos a algo <strong>vinculativo</strong> , que foi mencionado acima.  A ligação na terminologia WPF é um mecanismo que permite associar algumas propriedades dos controles a algumas propriedades de um objeto da classe C # e atualizar mutuamente essas propriedades quando uma das partes do pacote é alterada (isso pode funcionar em uma, na outra ou nas duas direções ao mesmo tempo).  Para aqueles que estão familiarizados com o Qt, você pode desenhar uma analogia de slots e sinais.  Para não esticar o tempo, vamos para o código. </p><br><p>  Portanto, para organizar a ligação, você precisa das propriedades dos controles e de alguma propriedade de uma determinada classe C #.  Primeiro, vamos descobrir o código XAML.  O texto dos dois controles é armazenado na propriedade Text, portanto, adicione uma ligação para essas propriedades.  É feito assim: </p><br><pre> <code class="hljs pgsql">&lt;TextBox <span class="hljs-type"><span class="hljs-type">Text</span></span>="{Binding}"/&gt; &lt;TextBlock <span class="hljs-type"><span class="hljs-type">Text</span></span>="{Binding}"/&gt;</code> </pre> <br><p>  Criamos uma ligação, mas, por enquanto, não está claro o porquê :) Precisamos de um objeto de alguma classe e alguma propriedade nesse objeto à qual a ligação será feita (como eles dizem, à qual você deve se ligar). </p><br><p>  Então, o que é essa aula?  Essa classe é chamada de modelo de visualização e serve como um link entre a visualização (a interface ou suas partes) e o modelo (modelo, ou seja, as partes do código responsáveis ​​pela lógica do aplicativo. Isso permite separar (até certo ponto) ) a lógica do aplicativo a partir da interface (exibição, exibição) é denominada <strong>padrão MVVM (Model-View-ViewModel) .No</strong> WPF, essa classe também é chamada <strong>DataContext</strong> . </p><br><p>  No entanto, apenas escrever uma classe de modelo de exibição não é suficiente.  É necessário informar de alguma forma o mecanismo de ligação que a propriedade do modelo de exibição ou a propriedade de exibição foi alterada.  Para fazer isso, existe uma interface especial <strong>INotifyPropertyChanged</strong> , que contém o evento <strong>PropertyChanged</strong> .  Implementamos essa interface na estrutura da classe base <strong>BaseViewModel</strong> .  No futuro, herdaremos todos os nossos modelos de exibição dessa classe base para não duplicar a implementação da interface.  Portanto, adicione o diretório <em>ViewModels</em> ao projeto e adicione o arquivo <em>BaseViewModel.cs</em> a esse diretório.  Temos a seguinte estrutura de projeto: </p><br><p><img src="https://habrastorage.org/webt/va/yi/sn/vayisnwyoe4gndnwxyp9zip12b4.png" alt="imagem"></p><br><p>  Código de implementação para o modelo de vista base: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.ComponentModel; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Ex1.ViewModels</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">BaseViewModel</span></span> : <span class="hljs-title"><span class="hljs-title">INotifyPropertyChanged</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">event</span></span> PropertyChangedEventHandler PropertyChanged; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnPropertyChanged</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> propertyName = </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">""</span></span></span></span></span><span class="hljs-function">)</span></span> { PropertyChanged?.Invoke(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> PropertyChangedEventArgs(propertyName)); } } }</code> </pre> <br><p>  Vamos criar nosso viewmodel para nossa classe <strong>MainWindow</strong> , herdando da classe base.  Para fazer isso, no mesmo diretório <em>ViewModels</em> , crie o arquivo <em>MainWindowViewModel.cs</em> , dentro do qual haverá esse código: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Ex1.ViewModels</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MainWindowViewModel</span></span> : <span class="hljs-title"><span class="hljs-title">BaseViewModel</span></span> { } }</code> </pre> <br><p>  Ótimo!  Agora precisamos adicionar uma propriedade a esse modelo de exibição, na qual vincularemos o texto de nossos controles.  Como este é um texto, o tipo dessa propriedade deve ser <em>string</em> : </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> SynchronizedText { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br><p>  Como resultado, obtemos esse código </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Ex1.ViewModels</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MainWindowViewModel</span></span> : <span class="hljs-title"><span class="hljs-title">BaseViewModel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> SynchronizedText { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } } }</code> </pre> <br><p>  Então, ao que parece, eles fizeram isso.  Resta vincular essa propriedade a partir da visualização e está pronto.  Vamos fazer agora: </p><br><pre> <code class="hljs pgsql">&lt;TextBox <span class="hljs-type"><span class="hljs-type">Text</span></span>="{Binding Path=SynchronizedText}"/&gt; &lt;TextBlock <span class="hljs-type"><span class="hljs-type">Text</span></span>="{Binding Path=SynchronizedText}"/&gt;</code> </pre> <br><p>  Nishtyak, começamos o projeto, digitamos na caixa de texto iiiii ... nada acontece))) Bem, tudo bem, na verdade, estamos indo no caminho certo, apenas não chegamos ao ponto certo. </p><br><p>  Proponho parar por um momento e pensar no que estamos perdendo.  Nós temos uma visão.  Viewmodel também.  Propriedades como zabindili.  A interface desejada é implementada.  Fizemos muito trabalho para copiar uma linha de texto patética, por que precisamos disso ???!?! 111 </p><br><p>  Ok, brincadeiras à parte.  Esquecemos de criar um objeto de modelo de exibição e outra coisa (mais sobre isso mais tarde).  Descrevemos a própria classe, mas isso não significa nada, porque não temos objetos dessa classe.  Ok, onde você precisa armazenar um link para esse objeto?  Mais perto do início do exemplo, mencionei um certo <em>DataContext</em> usado no WPF.  Portanto, qualquer visualização tem uma propriedade <strong>DataContext</strong> à qual podemos atribuir um link ao nosso modelo de visualização.  Vamos fazer isso.  Para fazer isso, abra o arquivo <em>MainWindow.xaml</em> e pressione F7 para abrir o código para esta exibição.  Está quase vazio, apenas possui um construtor de classe de janela.  Adicione a criação do nosso modelo de exibição a ele e coloque-o no <strong>DataContext da</strong> janela (não se esqueça de adicionar usando o espaço de nome desejado): </p><br><pre> <code class="hljs cs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MainWindow</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { InitializeComponent(); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.DataContext = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MainWindowViewModel(); }</code> </pre> <br><p>  Era simples, mas ainda não o suficiente.  Ainda assim, quando o aplicativo inicia, nenhuma sincronização de texto ocorre.  O que mais precisa ser feito? </p><br><p>  Você precisa aumentar o evento <strong>PropertyChanged</strong> quando a propriedade <strong>SynchronizedText for</strong> alterada e informar à exibição que ele deve monitorar esse evento.  Portanto, para acionar o evento, modifique o código do modelo de exibição: </p><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MainWindowViewModel</span></span> : <span class="hljs-title"><span class="hljs-title">BaseViewModel</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> _synchronizedText; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> SynchronizedText { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; _synchronizedText; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { _synchronizedText = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; OnPropertyChanged(<span class="hljs-keyword"><span class="hljs-keyword">nameof</span></span>(SynchronizedText)); } } }</code> </pre> <br><p>  O que fizemos aqui?  Adicionamos um campo oculto para armazenar texto, agrupamos-o em uma propriedade existente e, ao alterar essa propriedade, não apenas alteramos o campo oculto, mas também chamamos o método <strong>OnPropertyChanged</strong> definido no modelo de vista base e aumentamos o evento <strong>PropertyChanged</strong> declarado na interface <strong>INotifyPropertyChanged</strong> , também implementada na base ver modelos.  Acontece que, toda vez que o texto é alterado, ocorre o evento <strong>PropertyChanged</strong> , para o qual o nome da propriedade do modelo de exibição que foi alterado é passado. </p><br><p>  Bem, quase tudo, a linha de chegada!  Resta especificar a exibição que deve ouvir o evento <strong>PropertyChanged</strong> : </p><br><pre> <code class="hljs pgsql">&lt;TextBox <span class="hljs-type"><span class="hljs-type">Text</span></span>="{Binding Path=SynchronizedText, UpdateSourceTrigger=PropertyChanged, Mode=OneWayToSource}"/&gt; &lt;TextBlock <span class="hljs-type"><span class="hljs-type">Text</span></span>="{Binding Path=SynchronizedText, UpdateSourceTrigger=PropertyChanged, Mode=OneWay}"/&gt;</code> </pre> <br><p>  Além do fato de indicarmos por qual acionador a atualização deve ocorrer, também indicamos em que direção essa atualização está sendo rastreada: de vista para ver modelo ou vice-versa.  Como <strong>inserimos</strong> texto na caixa de texto, estamos interessados ​​apenas nas alterações na exibição; portanto, selecionamos o modo <strong>OneWayToSource</strong> .  No caso do bloco de texto, tudo é exatamente o oposto: estamos interessados ​​em alterações no modelo de exibição para exibi-las na exibição, portanto, selecionamos o modo <strong>OneWay</strong> .  Se quiséssemos rastrear as alterações nas duas direções, não poderíamos especificar o <strong>Modo</strong> , nem especificar o <strong>TwoWay</strong> explicitamente. </p><br><p>  Então, execute o programa, digite o texto e voi-la!  O texto muda de forma síncrona e não copiamos nada em lugar nenhum! </p><br><p><img src="https://habrastorage.org/webt/pu/69/jw/pu69jwasrfi2bs43obsaj026rlw.png" alt="imagem"></p><br><p>  Obrigado por sua atenção, para continuar.  Lidaremos com o DataTemplate e o padrão de comando. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt427325/">https://habr.com/ru/post/pt427325/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt427315/index.html">Sala de leitura Izba ou uma seleção de literatura profissional</a></li>
<li><a href="../pt427317/index.html">Para ter sucesso no campo da TI ou o que mata a TI'shnikov?</a></li>
<li><a href="../pt427319/index.html">Programador de recrutamento de cavalheiros UE4, parte 1</a></li>
<li><a href="../pt427321/index.html">Fone de ouvido Neuro para todos os dias - como é feito, por que é necessário e o que nos transformará em</a></li>
<li><a href="../pt427323/index.html">Infraestrutura para microsserviços. K8s e tudo-tudo-tudo</a></li>
<li><a href="../pt427327/index.html">Arquitetura MVVM em aplicativos móveis Flutter</a></li>
<li><a href="../pt427329/index.html">IBM supera marco de 7 nanômetros usando grafeno para colocar nanomateriais em substratos</a></li>
<li><a href="../pt427331/index.html">Revisão da versão internacional do smartphone Xiaomi Mi Max 3 - meu tamanho</a></li>
<li><a href="../pt427333/index.html">Converter temperatura de cor (K) em RGB: algoritmo e exemplo de código</a></li>
<li><a href="../pt427335/index.html">Leia dados de um disco rígido MiniScribe antigo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>