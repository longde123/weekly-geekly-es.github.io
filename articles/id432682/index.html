<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ’ƒğŸ½ ğŸ‘†ğŸ¼ ğŸ‘¨ğŸ»â€ğŸ¨ Rahasia membangun dan meneruskan SSH ke Docker 09/18 ğŸ³ â¹ï¸ ğŸ‘¨â€ğŸ‘¨â€ğŸ‘§â€ğŸ‘¦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Menggunakan Dockerfile, selalu sulit untuk mengakses sumber daya pribadi. Tidak ada solusi yang baik. Tidak baik menggunakan variabel lingkungan atau ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rahasia membangun dan meneruskan SSH ke Docker 09/18</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/southbridge/blog/432682/"><img src="https://habrastorage.org/getpro/habr/post_images/51a/244/e44/51a244e44066ef74933b2e3fbb5a005b.jpg" alt="gambar"><br><p>  Menggunakan Dockerfile, selalu sulit untuk mengakses sumber daya pribadi.  Tidak ada solusi yang baik.  Tidak baik menggunakan variabel lingkungan atau hanya menghapus file rahasia setelah digunakan: mereka tetap dalam metadata gambar.  Pengguna kadang-kadang pergi ke trik: mereka membuat majelis multi-tahap, namun, sangat hati-hati harus diambil sehingga tidak ada nilai rahasia pada tahap akhir, dan file rahasia disimpan dalam cache perakitan lokal hingga kliping. </p><br><p>  Tim pembuat Docker 18 September menyertakan banyak pembaruan.  Fitur utamanya adalah versi implementasi server sisi yang sepenuhnya baru telah muncul, ditawarkan sebagai bagian dari proyek Moby BuildKit.  Aplikasi server BuildKit telah memperoleh fitur-fitur baru, termasuk dukungan untuk rahasia build Dockerfile. </p><a name="habracut"></a><br><h3 id="ispolzovanie-sekretov">  Menggunakan Rahasia </h3><br><p> Pertama-tama, Anda harus mengaktifkan sisi server BuildKit.  BuildKit dalam versi <code>18.09</code> adalah fungsi seleksi yang dapat diaktifkan menggunakan <code>DOCKER_BUILDKIT=1</code> variabel lingkungan sebelum meluncurkan <code>docker build</code> .  Dalam versi berikutnya, direncanakan untuk membuat BuildKit bagian server secara default. </p><br><pre> <code class="plaintext hljs">export DOCKER_BUILDKIT=1</code> </pre> <br><p>  Menerapkan rahasia pembuatan didasarkan pada dua fitur BuildKit baru.  Salah satunya adalah kemampuan untuk menggunakan antarmuka pengguna yang diambil dari gambar dalam registri;  yang kedua adalah kemampuan untuk menggunakan titik pemasangan pada perintah <code>RUN</code> untuk Dockerfile.  Untuk menggunakan fungsi implementasi yang mendukung rahasia (alih-alih yang standar), tentukan gambar penghubung menggunakan arahan sintaks di baris pertama Dockerfile - menunjukkan gambar wadah yang ingin Anda gunakan.  Sejauh ini, rahasia di saluran stabil Dockerfiles eksternal tidak tersedia: Anda akan memerlukan salah satu versi di saluran eksperimental, misalnya, <code>docker/dockerfile:experimental</code> atau <code>docker/dockerfile/1.0.0-experimental</code> . </p><br><pre> <code class="plaintext hljs"># syntax=docker/dockerfile:1.0.0-experimental</code> </pre> <br><p>  Jika Anda, sebagai penulis Dockerfile, tahu bahwa perintah <code>RUN</code> dipasang di Dockerfile membutuhkan nilai rahasia, gunakan label <code>--mount</code> untuk itu, yang menunjukkan rahasia yang dibutuhkan perintah dan di mana harus memasangnya.  Label <code>--mount</code> menerima struktur yang dipisahkan koma sebagai dalam <code>--mount</code> untuk <code>docker run</code> . </p><br><pre> <code class="plaintext hljs"># syntax=docker/dockerfile:1.0.0-experimental FROM alpine RUN --mount=type=secret,id=mysite.key command-to-run</code> </pre> <br><p>  Label ini menunjukkan bahwa selama operasi perintah memiliki akses ke file rahasia di sepanjang jalur / <code>/run/secrets/mysite.key</code> .  Rahasianya hanya tersedia untuk tim dengan label pemasangan, dan tidak untuk bagian lain dari majelis.  Data dalam file ini diunduh dari toko rahasia berdasarkan pada pengidentifikasi yang ditentukan "mysite.key".  Antarmuka baris perintah Docker saat ini mendukung pengungkapan rahasia dari file klien lokal menggunakan tag <code>--secret</code> . </p><br><pre> <code class="plaintext hljs">docker build --secret id=mysite.key,src=path/to/mysite.key .</code> </pre> <br><p>  Seperti dijelaskan di atas, rahasia ditetapkan secara default di <code>/run/secrets</code> , namun, Anda dapat menentukan jalur apa pun menggunakan kunci "target".  Jika "target" ditentukan, tetapi "id" tidak, maka "id" secara default menjadi nama dasar dari jalur tujuan. </p><br><p>  Tidak perlu dibatasi pada satu rahasia.  Anda dapat menggunakan nomor apa saja, yang menunjukkan pengidentifikasi yang berbeda. </p><br><p>  Jika penulis Dockerfile menunjukkan bahwa instruksi <code>RUN</code> dapat menggunakan rahasia, dan pengguna yang memanggil majelis tidak menyediakannya, maka rahasianya diabaikan dan tidak ada file yang diinstal pada jalur yang ditentukan.  Jika situasi ini tidak diinginkan, gunakan kunci "wajib": ini akan menunjukkan bahwa tanpa nilai perakitan akan gagal. </p><br><pre> <code class="plaintext hljs"># syntax=docker/dockerfile:1.0.0-experimental FROM alpine RUN --mount=type=secret,id=mysite.key,required &lt;command-to-run&gt;</code> </pre> <br><h3 id="realizaciya">  Implementasi </h3><br><p>  File rahasia secara otomatis diinstal hanya dalam sistem file tmpfs terpisah untuk mencegah kebocoran pada gambar akhir atau perintah berikutnya, dan sehingga tidak disimpan dalam cache build lokal. </p><br><p>  Nilai-nilai rahasia juga dikecualikan dari membangun penghitungan cache sehingga cache metadata tidak dapat digunakan. </p><br><h3 id="ssh">  Ssh </h3><br><p>  Paling sering, mereka mungkin mencoba mengakses repositori pribadi melalui protokol SSH.  Ya, Anda dapat menggunakan elemen rahasia untuk mengungkapkan kunci pribadi SSH untuk perakitan, tetapi ada solusi yang lebih baik.  Protokol SSH menggunakan kriptografi kunci publik, dan berkat desain ini, Anda tidak perlu mengungkapkan kunci pribadi Anda kepada siapa pun.  Misalnya, jika Anda menggunakan beberapa komputer dengan SSH, Anda tidak perlu mentransfer kunci Anda - cukup sediakan koneksi melalui protokol <code>ssh-A</code> . </p><br><p>  Kami menambahkan fitur serupa di <code>docker build</code> , di mana Anda dapat menggunakan label <code>--ssh</code> untuk mengarahkan koneksi agen SSH yang ada atau kunci ke linker.  Alih-alih mengirimkan informasi utama, Docker hanya memberi tahu tautan bahwa itu tersedia.  Jika tautan perlu mengakses server jarak jauh melalui SSH, ia akan menghubungi klien dan meminta konfirmasi permintaan spesifik yang diperlukan untuk koneksi.  Kuncinya sendiri tidak meninggalkan program klien, dan setelah menyelesaikan program yang membutuhkan akses, tidak ada data yang tersisa dari tautan untuk menyambung kembali koneksi jarak jauh. </p><br><p>  Akses ke transfer file melalui protokol SSH hanya diberikan untuk perintah di Dockerfile yang secara langsung meminta akses ke SSH dengan menentukan blok <code>type=ssh</code> .  Perintah lain tidak memiliki data pada agen SSH yang tersedia. </p><br><p>  Perlu juga dicatat aspek lain dari SSH - penggunaan model keamanan TOFU.  Saat menyambungkan ke server SSH untuk pertama kalinya, ia akan meminta informasi tentang host yang tidak dikenal, karena ia tidak memiliki kunci publik yang tersedia secara lokal untuk server ini dan, karenanya, tidak dapat memeriksa apakah kunci publik yang disediakan oleh pihak jarak jauh valid untuk alamat ini. </p><br><p>  Ketika merakit dengan Dockerfile, kebenaran permintaan ini tidak dapat diverifikasi, dan karenanya, kunci publik dari server harus sudah ada dalam wadah yang mencoba menggunakan SSH.  Ada beberapa cara untuk mendapatkan kunci publik ini.  Misalnya, gambar dasar akan menyediakannya, atau Anda akan menyalinnya dari konteks pembuatan.  Jika Anda menginginkan solusi yang lebih sederhana, jalankan program <code>sshâ€“keyscan</code> sebagai bagian dari rakitan - ini akan memuat kunci publik host saat ini. </p><br><p>  Untuk meminta akses SSH ke perintah <code>RUN</code> di Dockerfile, Anda harus menentukan blok jenis "ssh".  Kemudian, selama proses berlangsung, soket akan dipasang dengan akses hanya baca ke agen SSH.  Ini juga akan mengatur variabel lingkungan <code>SSH_AUTH_SOCK</code> sehingga program yang menggunakan protokol SSH secara otomatis menggunakan soket ini. </p><br><pre> <code class="plaintext hljs"># syntax=docker/dockerfile:experimental FROM alpine # install ssh client and git RUN apk add --no-cache openssh-client git # download public key for github.com RUN mkdir -p -m 0600 ~/.ssh &amp;&amp; ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts # clone our private repository RUN --mount=type=ssh git clone git@github.com:myorg/myproject.git myproject</code> </pre> <br><p>  Di sisi klien Docker, gunakan label <code>--ssh</code> menunjukkan bahwa penerusan SSH diperbolehkan untuk unit ini. </p><br><pre> <code class="plaintext hljs">docker build --ssh default .</code> </pre> <br><p>  Label menerima sepasang nilai kunci yang menentukan lokasi soket agen SSH lokal atau kunci pribadi.  Jika Anda ingin menggunakan nilai <code>default=$SSH_AUTH_SOCK</code> , Anda dapat membiarkan jalur soket kosong. </p><br><p>  Di blok Dockerfile, Anda juga dapat menggunakan kunci id untuk memisahkan berbagai server dalam rakitan yang sama.  Misalnya, akses ke berbagai repositori di Dockerfile dapat diperoleh dengan kunci penggunaan yang berbeda.  Dalam hal ini, di Dockerfile Anda akan menggunakan: </p><br><pre> <code class="plaintext hljs">â€¦ RUN --mount=type=ssh,id=projecta git clone projecta â€¦ RUN --mount=type=ssh,id=projectb git clone projectb â€¦</code> </pre> <br><p>  dan perluas data klien dengan docker build <code>--ssh projecta=./projecta.pem --ssh projectb=./projectb.pem</code> .  Perhatikan bahwa bahkan jika Anda menentukan kunci yang sebenarnya, hanya koneksi agen yang dikirim ke tautan, bukan konten sebenarnya dari kunci pribadi ini. </p><br><p>  Dengan ini, peninjauan fitur baru rahasia pembuatan di Docker 18.09 selesai.  Saya berharap bahwa fitur-fitur baru akan membantu untuk memanfaatkan lebih besar kemampuan Dockerfile dalam proyek-proyek dan memberikan tingkat keamanan yang lebih tinggi untuk jalur perakitan. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id432682/">https://habr.com/ru/post/id432682/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id432672/index.html">Apa yang kami cari pengembang untuk mengembangkan platform 1C: Enterprise</a></li>
<li><a href="../id432674/index.html">Pengalaman pertama dengan Yandex Dialogs. Kami sedang menunggu inovasi</a></li>
<li><a href="../id432676/index.html">Check Point Pengaturan Keamanan Checklist</a></li>
<li><a href="../id432678/index.html">Pertemuan frontend musim dingin di OZON</a></li>
<li><a href="../id432680/index.html">Perusahaan Internet mana pun harus secara diam-diam mengubah kode program atas permintaan pihak berwenang</a></li>
<li><a href="../id432686/index.html">Apakah WireGuard VPN Luar Biasa untuk Masa Depan?</a></li>
<li><a href="../id432688/index.html">Acara digital di Moskow dari 10 hingga 16 Desember</a></li>
<li><a href="../id432692/index.html">Meluncurkan proyek pembersihan lautan terbesar</a></li>
<li><a href="../id432696/index.html">nomoregoogle.com - kompilasi baru alternatif untuk layanan raksasa teknologi</a></li>
<li><a href="../id432698/index.html">Timlids yang fantastis dan di mana mereka tinggal</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>