<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📨 👩🏻‍🤝‍👨🏽 👟 PowerShell, dump dari pengalaman saya 👳🏿 🔟 👩‍👧‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pendahuluan 


 Artikel ini ditujukan kepada mereka yang sudah terbiasa dengan dasar-dasar PowerShell, menjalankan beberapa skrip dengan stackexchange...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>PowerShell, dump dari pengalaman saya</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443256/"><h2 id="vvedenie">  Pendahuluan </h2><br><p>  Artikel ini ditujukan kepada mereka yang sudah terbiasa dengan dasar-dasar PowerShell, menjalankan beberapa skrip dengan stackexchange dan mungkin memiliki file teks mereka sendiri dengan berbagai potongan untuk memudahkan pekerjaan sehari-hari.  Tujuan penulisan ini adalah untuk mengurangi entropi, meningkatkan keterbacaan dan pemeliharaan kode PowerShell yang digunakan di perusahaan Anda, dan, sebagai akibatnya, meningkatkan produktivitas administrator yang bekerja dengannya. </p><br><p><img src="https://habrastorage.org/webt/go/9u/yw/go9uywfoytxpgrxmggcvf2bfi8e.png" alt="kdpv"></p><br><p>  Di tempat kerja saya sebelumnya, karena spesifik tugas dan ketidaksempurnaan dunia, saya sangat memompa keterampilan bekerja dengan PowerShell.  Setelah pergantian pekerjaan, banyak dari jenis ini menurun secara signifikan dan segala sesuatu yang berada di ujung jari mulai tenggelam lebih dalam dan lebih dalam di bawah pengalaman memecahkan masalah baru dengan teknologi baru.  Dari sini, artikel ini mengklaim hanya apa yang dinyatakannya sendiri, mengungkapkan daftar topik yang, menurut pendapat saya, akan berguna bagi saya sendiri sekitar 7 tahun yang lalu, ketika kenalan saya dengan alat ini baru saja dimulai. </p><a name="habracut"></a><br><p>  Jika Anda tidak mengerti mengapa PowerShell adalah shell berorientasi objek, bonus seperti apa yang datang dan mengapa itu diperlukan, saya akan memberi tahu Anda, terlepas dari para pembenci, sebuah buku bagus yang dengan cepat memperkenalkan inti dari lingkungan ini - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Andrei Popov, Pengantar Windows PowerShell</a> .  Ya, ini tentang versi lama PS, ya, bahasanya telah mendapatkan beberapa ekstensi dan peningkatan, tetapi buku ini bagus karena ketika menggambarkan tahap awal pengembangan lingkungan ini, tanpa disadari hanya menekankan hal-hal mendasar.  Gula sintaksis yang telah ditumbuhi oleh lingkungan, saya pikir, Anda dengan cepat merasakannya tanpa memahami bagaimana konsep itu bekerja.  Membaca buku ini hanya akan membawa Anda beberapa malam, kembali setelah membaca. </p><br><p><img src="https://habrastorage.org/webt/g9/ea/h9/g9eah9nfoao7gukeochjqasi2ne.jpeg" alt="popov"></p><br><p>  Buku ini juga tersedia di situs web penulis, meskipun saya tidak yakin bagaimana lisensi penggunaan ini: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://andpop.ru/courses/winscript/books/posh_popov.pdf</a> </p><br><h2 id="stayl-gaydy">  Panduan gaya </h2><br><p>  Merancang skrip menurut styleguides adalah praktik yang baik dalam semua kasus penerapannya, hampir tidak ada dua pendapat.  Beberapa ekosistem telah mengatasi hal ini pada level penyetelan asli, pep8 di komunitas Python dan pergi di Golang menjadi jelas.  Ini adalah alat penghemat waktu yang sangat berharga, yang, sayangnya, tidak ada dalam paket PowerShell standar, dan karenanya mentransfer masalah ke kepala kami.  Saat ini, satu-satunya cara untuk memecahkan masalah pemformatan kode seragam adalah dengan mengembangkan refleks dengan berulang kali menulis kode yang memenuhi panduan gaya (pada kenyataannya, tidak). </p><br><p>  Panduan gaya karena kurangnya resmi disetujui dan dijelaskan secara rinci oleh Microsoft lahir di komunitas selama masa PowerShell v3 dan sejak itu mereka telah mengembangkan dalam bentuk terbuka di github: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PowerShellPracticeAndStyle</a> .  Ini adalah repositori penting bagi siapa saja yang pernah menggunakan tombol "Simpan" di PowerShell. </p><br><p>  Jika Anda mencoba memeras, itu mungkin akan turun ke poin-poin berikut: </p><br><ul><li>  PowerShell menggunakan PascalCase untuk menamai variabel, cmdlet, nama modul, dan hampir semuanya kecuali operator; </li><li> Operator bahasa seperti <code>if</code> , <code>switch</code> , <code>break</code> , <code>process</code> , <code>-match</code> ditulis dalam huruf yang sangat kecil; </li><li>  Kurung keriting ditempatkan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satu</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satunya cara yang benar</a> , sebaliknya juga disebut gaya Kernigan dan Richie, memimpin ceritanya dari buku <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">The C Programming Language</a> ; </li><li>  Jangan gunakan alias di mana pun selain sesi konsol interaktif, jangan menulis <code>ps | ? processname -eq firefox | %{$ws=0}{$ws+=$_.workingset}{$ws/1MB}</code> file skrip <code>ps | ? processname -eq firefox | %{$ws=0}{$ws+=$_.workingset}{$ws/1MB}</code> <code>ps | ? processname -eq firefox | %{$ws=0}{$ws+=$_.workingset}{$ws/1MB}</code>  <code>ps | ? processname -eq firefox | %{$ws=0}{$ws+=$_.workingset}{$ws/1MB}</code> ; </li><li>  Tunjukkan nama parameter eksplisit, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perilaku cmdlet dan tanda tangannya dapat berubah</a> , ditambah ini menambahkan konteks untuk orang yang tidak terbiasa dengan cmdlet tertentu; </li><li>  Rancang parameter untuk skrip panggilan, dan jangan menulis fungsi di dalam skrip dan baris terakhir memanggil fungsi ini dengan kebutuhan untuk mengubah nilai variabel global alih-alih menentukan parameter; </li><li>  Tentukan [CmdletBinding ()] - ini akan memberikan cmdlet Anda flag <code>-Debug</code> dan <code>-Debug</code> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">banyak fitur berguna lainnya</a> .  Terlepas dari posisi kuat beberapa purist dalam komunitas, saya bukan pendukung yang menunjukkan atribut ini dalam fungsi inline sederhana dan filter yang terdiri dari beberapa baris literal; </li><li>  Tulis bantuan berbasis komentar: satu kalimat, tautan tiket, contoh panggilan; </li><li>  Tentukan versi PowerShell yang diperlukan di bagian <code>#requires</code> ; </li><li>  Gunakan <code>Set-StrictMode -Version Latest</code> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini akan membantu Anda menghindari masalah yang dijelaskan di bawah ini</a> ; </li><li>  Menangani kesalahan; </li><li>  Jangan buru-buru menulis ulang semuanya di PowerShell.  PowerShell pada dasarnya adalah sebuah shell dan memanggil binari adalah tugas langsungnya.  Tidak ada yang salah dengan menggunakan robocopy dalam sebuah skrip, tentu saja ini bukan rsync, tetapi juga sangat bagus. </li></ul><br><h2 id="comment-based-help">  Bantuan Berbasis Komentar </h2><br><p>  Di bawah ini adalah contoh cara mendapatkan skrip bantuan.  Script membingkai gambar yang membawanya ke kotak dan melakukan perubahan ukuran, saya pikir Anda memiliki tugas membuat avatar untuk pengguna (kecuali mungkin rotasi menurut data exif).  Ada contoh penggunaan di bagian <code>.EXAMPLE</code> , cobalah.  Karena PowerShell dijalankan oleh runtime bahasa umum, sama seperti bahasa dotnet lainnya, PowerShell memiliki kemampuan untuk menggunakan kekuatan penuh dari perpustakaan dotnet: </p><br><pre> <code class="plaintext hljs">&lt;# .SYNOPSIS Resize-Image resizes an image file .DESCRIPTION This function uses the native .NET API to crop a square and resize an image file .PARAMETER InputFile Specify the path to the image .PARAMETER OutputFile Specify the path to the resized image .PARAMETER SquareHeight Define the size of the side of the square of the cropped image. .PARAMETER Quality Jpeg compression ratio .EXAMPLE Resize the image to a specific size: .\Resize-Image.ps1 -InputFile "C:\userpic.jpg" -OutputFile "C:\userpic-400.jpg"-SquareHeight 400 #&gt; # requires -version 3 [CmdletBinding()] Param( [Parameter( Mandatory )] [string]$InputFile, [Parameter( Mandatory )] [string]$OutputFile, [Parameter( Mandatory )] [int32]$SquareHeight, [ValidateRange( 1, 100 )] [int]$Quality = 85 ) # Add System.Drawing assembly Add-Type -AssemblyName System.Drawing # Open image file $Image = [System.Drawing.Image]::FromFile( $InputFile ) # Calculate the offset for centering the image $SquareSide = if ( $Image.Height -lt $Image.Width ) { $Image.Height $Offset = 0 } else { $Image.Width $Offset = ( $Image.Height - $Image.Width ) / 2 } # Create empty square canvas for the new image $SquareImage = New-Object System.Drawing.Bitmap( $SquareSide, $SquareSide ) $SquareImage.SetResolution( $Image.HorizontalResolution, $Image.VerticalResolution ) # Draw new image on the empty canvas $Canvas = [System.Drawing.Graphics]::FromImage( $SquareImage ) $Canvas.DrawImage( $Image, 0, -$Offset ) # Resize image $ResultImage = New-Object System.Drawing.Bitmap( $SquareHeight, $SquareHeight ) $Canvas = [System.Drawing.Graphics]::FromImage( $ResultImage ) $Canvas.DrawImage( $SquareImage, 0, 0, $SquareHeight, $SquareHeight ) $ImageCodecInfo = [System.Drawing.Imaging.ImageCodecInfo]::GetImageEncoders() | Where-Object MimeType -eq 'image/jpeg' # https://msdn.microsoft.com/ru-ru/library/hwkztaft(v=vs.110).aspx $EncoderQuality = [System.Drawing.Imaging.Encoder]::Quality $EncoderParameters = New-Object System.Drawing.Imaging.EncoderParameters( 1 ) $EncoderParameters.Param[0] = New-Object System.Drawing.Imaging.EncoderParameter( $EncoderQuality, $Quality ) # Save the image $ResultImage.Save( $OutputFile, $ImageCodecInfo, $EncoderParameters )</code> </pre> <br><p>  Skrip di atas dimulai dengan komentar multi-baris <code>&lt;# ... #&gt;</code> , jika komentar ini didahulukan dan berisi kata kunci tertentu, PowerShell akan secara otomatis membangun bantuan untuk skrip.  Jenis bantuan ini secara harfiah disebut - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bantuan berdasarkan komentar</a> : </p><br><p><img src="https://habrastorage.org/webt/9y/tw/d3/9ytwd3hlr6yb5nsobqqor_bjshw.png" alt="bantuan"></p><br><p>  Selain itu, ketika skrip dipanggil, tooltips untuk parameter akan berfungsi, apakah itu konsol PowerShell atau editor kode: </p><br><p><img src="https://habrastorage.org/webt/tr/ha/qg/trhaqga49fwvjphbl6i_cporowa.png" alt="bantuan sebaris"></p><br><p>  Sekali lagi saya menarik perhatian pada fakta bahwa dia tidak boleh diabaikan.  Jika Anda tidak tahu apa yang harus ditulis di sana, tulis sesuatu, pergi ke pendingin dan setelah kembali Anda pasti akan memiliki pemahaman tentang apa yang perlu diubah dalam tulisan.  Itu bekerja.  Tidak layak secara fanatik mengisi semua kata kunci, PowerShell dirancang untuk mendokumentasikan diri sendiri dan jika Anda memberi nama yang bermakna dan lengkap ke parameter, kalimat pendek di bagian <code>.SYNOPIS</code> dan satu contoh sudah cukup. </p><br><h2 id="strict-mode">  Mode yang ketat </h2><br><p>  PowerShell, seperti banyak bahasa skrip lainnya, memiliki pengetikan dinamis.  Jenis pengetikan ini memiliki banyak pendukung: menulis logika tingkat tinggi yang sederhana namun kuat adalah masalah beberapa menit, tetapi ketika keputusan Anda mulai mencapai ribuan baris, Anda pasti akan menghadapi kerapuhan pendekatan ini. </p><br><p>  Secara otomatis menghasilkan tipe yang selalu pada tahap pengujian, yang membentuk sebuah array di tempat Anda selalu menerima set elemen, pasti akan meletakkan babi jika Anda mendapatkan satu elemen dan dalam kondisi berikut, alih-alih memeriksa jumlah elemen, Anda akan mendapatkan jumlah karakter atau atribut lain, tergantung pada jenis barang.  Logika skrip akan pecah, dan runtime akan berpura-pura bahwa semuanya baik-baik saja. </p><br><p>  Menetapkan mode ketat membantu menghindari beberapa masalah seperti ini, tetapi juga memerlukan sedikit lebih banyak kode dari Anda, seperti menginisialisasi variabel dan melakukan casting secara eksplisit. </p><br><p>  Mode ini diaktifkan oleh cmdlet <code>Set-StrictMode -Version Latest</code> , meskipun ada opsi lain untuk "rigor", pilihan saya adalah menggunakan yang terakhir. </p><br><p>  Pada contoh di bawah ini, mode ketat menangkap panggilan ke properti yang tidak ada.  Karena hanya ada satu elemen di dalam folder, jenis variabel <code>$Input</code> sebagai hasil eksekusi akan menjadi <code>FileInfo</code> , dan bukan array yang diharapkan dari elemen yang sesuai: </p><br><p><img src="https://habrastorage.org/webt/fk/q-/jk/fkq-jkrdldogwcwyiwkwspskseq.png" alt="ketat"></p><br><p>  Untuk menghindari masalah seperti itu, Anda harus secara eksplisit membuang hasil cmdlet ke array: </p><br><pre> <code class="plaintext hljs">$Items = @( Get-ChildItem C:\Users\snd3r\Nextcloud )</code> </pre> <br><p>  Buat aturan untuk selalu mengatur mode ketat, ini akan memungkinkan Anda untuk menghindari hasil yang tidak terduga dari menjalankan skrip Anda. </p><br><h2 id="obrabotka-oshibok">  Menangani kesalahan </h2><br><h3 id="erroractionpreference">  ErrorActionPreference </h3><br><p>  Ketika melihat skrip orang lain, misalnya, di github, saya sering melihat mengabaikan mekanisme penanganan kesalahan, atau secara eksplisit mengaktifkan mode melanjutkan diam jika terjadi kesalahan.  Masalah penanganan kesalahan tentu bukan yang paling mudah untuk diprogram pada umumnya dan dalam skrip pada khususnya, tetapi jelas tidak layak untuk diabaikan.  Secara default, PowerShell jika ada kesalahan yang menampilkannya dan terus bekerja (saya sedikit menyederhanakan konsepnya, tetapi di bawah ini adalah tautan ke buku git tentang topik ini).  Ini nyaman jika Anda sangat perlu mendistribusikan pembaruan program yang banyak digunakan di domain ke semua mesin, tanpa menunggu hingga menyebar ke semua titik penyebaran SCM atau menyebar dengan cara lain yang digunakan oleh Anda.  Tidak menyenangkan mengganggu dan memulai ulang proses jika salah satu mesin dimatikan, ini benar. </p><br><p>  Di sisi lain, jika Anda membuat cadangan kompleks dari suatu sistem yang terdiri dari lebih dari satu file data lebih dari satu bagian dari sistem informasi, Anda perlu memastikan bahwa cadangan Anda konsisten dan bahwa semua set data yang diperlukan disalin tanpa kesalahan. </p><br><p>  Untuk mengubah perilaku cmdlet jika terjadi kesalahan, ada variabel global <code>$ErrorActionPreference</code> , dengan daftar nilai-nilai yang mungkin berikut: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Stop, Enquire, Continue, Suspend, SilentlyContinue</a> . </p><br><p>  Saya sarankan Anda selalu menggunakan nilai <code>Stop</code> ketika jumlah skrip atau kerumitannya berhenti disimpan di tumpukan di kepala Anda, lebih baik untuk memastikan bahwa dalam situasi yang tidak terduga, skrip akan menghentikan pekerjaannya, dan tidak mematahkan kayu bakar “dengan tenang”, menyelesaikan eksekusi “dengan sukses”. </p><br><p>  Selain menghentikan skrip jika terjadi kesalahan, ada prasyarat lain untuk penggunaannya - menangani situasi luar biasa.  Ada konstruksi <code>try/catch</code> untuk ini, tetapi hanya berfungsi jika kesalahan menyebabkan eksekusi berhenti.  Tidak perlu berhenti harus diaktifkan di tingkat seluruh skrip, <code>ErrorAction</code> dapat diatur pada tingkat cmdlet dengan parameter: </p><br><pre> <code class="plaintext hljs">Get-ChildItem 'C:\System Volume Information\' -ErrorAction 'Stop'</code> </pre> <br><p>  Sebenarnya, kemungkinan ini mendefinisikan dua strategi logis: menyelesaikan semua kesalahan "secara default" dan mengatur <code>ErrorAction</code> hanya untuk tempat-tempat kritis di mana untuk menanganinya;  aktifkan di tingkat keseluruhan skrip dengan menetapkan nilai variabel global dan pengaturan <code>-ErrorAction 'Continue'</code> pada operasi yang tidak kritis.  Saya selalu memilih opsi kedua, saya tidak terburu-buru untuk memaksakannya pada Anda, saya sarankan hanya sekali untuk memahami masalah ini dan menggunakan alat yang bermanfaat ini. </p><br><h3 id="trycatch">  coba / tangkap </h3><br><p>  Di penangan kesalahan, Anda dapat mencocokkan dengan jenis pengecualian dan beroperasi dengan utas eksekusi atau, misalnya, menambahkan sedikit informasi lebih lanjut.  Terlepas dari kenyataan bahwa dengan menggunakan operator <code>try/catch/throw/trap</code> Anda dapat membangun seluruh alur eksekusi skrip, Anda harus menghindari ini secara kategoris, karena metode operasi dengan eksekusi seperti itu tidak hanya dianggap sebagai antipater ekstrim dari kategori "goto-mie", jadi juga menguras kinerja secara drastis. </p><br><pre> <code class="plaintext hljs">#requires -version 3 $ErrorActionPreference = 'Stop' #   ,    , #          $Logger = Get-Logger "$PSScriptRoot\Log.txt" #    trap { $Logger.AddErrorRecord( $_ ) exit 1 } #    $count = 1; while ( $true ) { try { #   $StorageServers = @( Get-ADGroupMember -Identity StorageServers | Select-Object -Expand Name ) } catch [System.Management.Automation.CommandNotFoundException] { #      ,         throw " Get-ADGroupMember ,    Active Directory module for PowerShell; $( $_.Exception.Message )" } catch [System.TimeoutException] { #             if ( $count -le 3 ) { $count++; Start-Sleep -S 10; continue } #             throw "     -   ,   $count ; $( $_.Exception.Message )" } #         break }</code> </pre> <br><p>  Perlu dicatat bahwa operator <code>trap</code> adalah perangkap kesalahan global.  Ia menangkap semua yang belum diproses pada level yang lebih rendah, atau dikeluarkan dari handler pengecualian karena ketidakmungkinan untuk memperbaiki situasi secara independen. </p><br><p>  Selain pendekatan berorientasi objek pengecualian yang dijelaskan di atas, PowerShell juga menyediakan konsep yang lebih akrab yang kompatibel dengan shell "klasik" lainnya, seperti stream kesalahan, kode kembali, dan variabel akumulasi kesalahan.  Semua ini tentu saja nyaman, kadang-kadang tanpa alternatif, tetapi melampaui ruang lingkup ini, secara keseluruhan, topik ikhtisar.  Untungnya ada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">buku terbuka yang bagus tentang github</a> tentang hal ini. </p><br><p>  Kode logger yang saya gunakan ketika tidak ada kepastian bahwa sistem akan memiliki PowerShell 5 (di mana Anda dapat menggambarkan kelas logger lebih mudah), cobalah, ini dapat berguna bagi Anda karena kesederhanaan dan singkatnya, Anda pasti akan menambahkan metode tambahan tanpa kesulitan. : </p><br><pre> <code class="plaintext hljs">#   " ",   PowerShell v3 function Get-Logger { [CmdletBinding()] param ( [Parameter( Mandatory = $true )] [string] $LogPath, [string] $TimeFormat = 'yyyy-MM-dd HH:mm:ss' ) $LogsDir = [System.IO.Path]::GetDirectoryName( $LogPath ) New-Item $LogsDir -ItemType Directory -Force | Out-Null New-Item $LogPath -ItemType File -Force | Out-Null $Logger = [PSCustomObject]@{ LogPath = $LogPath TimeFormat = $TimeFormat } Add-Member -InputObject $Logger -MemberType ScriptMethod AddErrorRecord -Value { param( [Parameter( Mandatory = $true )] [string]$String ) "$( Get-Date -Format 'yyyy-MM-dd HH:mm:ss' ) [Error] $String" | Out-File $this.LogPath -Append } return $Logger }</code> </pre> <br><p>  Saya ulangi gagasan itu - jangan abaikan penanganan kesalahan.  Ini akan menghemat waktu dan saraf Anda dalam jangka panjang. <br>  Jangan berpikir bahwa menjalankan skrip tidak peduli apa yang baik.  Bagus - saatnya jatuh tanpa merusak kayu bakar. </p><br><h2 id="instrumenty">  Alat-alatnya </h2><br><p>  Penting untuk mulai meningkatkan alat untuk bekerja dengan PowerShell dari konsol emulator.  Saya sering mendengar dari pendukung tawon alternatif bahwa konsol di windows buruk dan bahwa ini bukan konsol sama sekali, tetapi dos dan sebagainya.  Hanya sedikit yang dapat merumuskan klaim mereka tentang masalah ini secara memadai, tetapi jika seseorang berhasil, maka pada kenyataannya ternyata semua masalah dapat diselesaikan.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sudah</a> ada lebih banyak informasi tentang terminal dan konsol baru di windows pada hub, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">semuanya lebih dari ok di sana</a> . </p><br><p>  Langkah pertama adalah menginstal Conemu atau rakitan Cmdernya, yang tidak terlalu penting, karena menurut saya itu layak dijalankan melalui pengaturan.  Saya biasanya memilih cmder dalam konfigurasi minimal, tanpa gita dan binari lain, yang saya atur sendiri, meskipun selama beberapa tahun saya menyetel konfigurasi saya untuk Conemu murni.  Ini benar-benar emulator terminal terbaik untuk windows, memungkinkan Anda untuk membagi layar (untuk tmux / pecinta layar), membuat tab dan mengaktifkan mode konsol gaya gempa: </p><br><h3 id="conemu">  Conemu </h3><br><p><img src="https://habrastorage.org/webt/ag/2w/hy/ag2whyp2okkhyroygpuzjkdamis.png" alt="cmder"></p><br><p>  Langkah selanjutnya saya sarankan untuk meletakkan modul: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">oh-my-posh</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posh-git</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PSReadLine</a> .  Dua yang pertama akan membuat prom lebih menyenangkan dengan menambahkan informasi tentang sesi saat ini, status perintah yang terakhir dieksekusi, indikator hak istimewa dan status repositori git di lokasi saat ini.  PSReadLine sangat meningkatkan promt, menambahkan misalnya pencarian pada sejarah perintah yang dimasukkan (CRTL + R) dan tips mudah untuk cmdlet pada CRTL + Space: </p><br><p><img src="https://habrastorage.org/webt/eg/w6/f2/egw6f2sa43hgi3dhwn_hhgxbesa.gif" alt="readline"></p><br><p>  Dan ya, sekarang konsol dapat dihapus dengan CTRL + L, dan lupakan <code>cls</code> . </p><br><h3 id="visual-studio-code">  Kode studio visual </h3><br><p>  Editor.  Semua hal terburuk yang dapat saya katakan tentang PowerShell adalah murni PowerShell ISE, mereka yang melihat versi pertama dengan tiga panel tidak mungkin melupakan pengalaman ini.  Pengkodean terminal yang berbeda, kurangnya fitur editor dasar, seperti lekukan otomatis, tanda kurung tutup otomatis, pemformatan kode, dan seluruh rangkaian antipattern yang dihasilkan olehnya tentang hal yang tidak akan saya beri tahu (hanya untuk berjaga-jaga) - ini semua tentang ISE. </p><br><p>  Jangan menggunakannya, gunakan Visual Studio Code dengan ekstensi PowerShell - ada segala sesuatu yang tidak Anda inginkan (tentu saja dalam batas yang wajar).  Dan jangan lupa bahwa dalam PoweShell hingga versi keenam (PowerShell Core 6.0) pengkodean untuk skrip adalah UTF8 BOM, jika tidak bahasa Rusia akan pecah. </p><br><p><img src="https://habrastorage.org/webt/dd/c0/pa/ddc0paj-xbx5tysllsrmzlxnugi.png" alt="vscode"></p><br><p>  Selain penyorotan sintaks, tip alat dan kemampuan debugging skrip, plugin memasang linter yang juga akan membantu Anda mengikuti praktik yang telah ada di komunitas, misalnya, memperluas pintasan dengan satu klik (pada bola lampu).  Bahkan, ini adalah modul reguler yang dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diinstal</a> secara independen, misalnya, tambahkan ke skrip penandatanganan pipa Anda: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">PSScriptAnalyzer</a> </p><br><p><img src="https://habrastorage.org/webt/mj/x7/ov/mjx7ovrtephqcdctuiptdu_tff4.png" alt="PSScriptAnalyzer"></p><br><p>  Anda dapat mengatur parameter pemformatan kode dalam pengaturan ekstensi, untuk semua pengaturan (baik editor dan ekstensi) ada pencarian: <code>File - Preferences - Settings</code> : </p><br><p><img src="https://habrastorage.org/webt/ia/xr/km/iaxrkmgjcpcf4wck1ocb7kfp9ym.png" alt="Otb"></p><br><p>  Untuk mendapatkan konsol conpty baru Anda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">harus mengatur bendera di pengaturan</a> , nanti, mungkin, saran ini tidak akan relevan. </p><br><p>  Patut diingat bahwa tindakan apa pun dalam Kode VS dapat dilakukan dari pusat kontrol, yang disebut oleh CTRL + Shift + P. Memformat sepotong kode yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dimasukkan dari obrolan</a> , mengurutkan menurut abjad, mengubah indentasi dari spasi ke tab, dan seterusnya, semua di pusat kontrol. </p><br><p>  Misalnya, aktifkan layar penuh dan pusat editor: </p><br><p><img src="https://habrastorage.org/webt/3z/w9/-a/3zw9-avzniwjgooxfa1dvzi9kfc.png" alt="tata letak"></p><br><h3 id="source-control-git-svn">  Kontrol sumber  Git, SVN </h3><br><p>  Seringkali, administrator sistem Windows memiliki fobia resolusi konflik dalam sistem kontrol versi, mungkin karena jika seorang perwakilan dari himpunan ini menggunakan git, maka seringkali seseorang tidak mengalami masalah seperti ini.  Dengan vscode, resolusi konflik berkurang menjadi klik mouse pada bagian-bagian kode yang perlu dibiarkan atau diganti. </p><br><p><img src="https://habrastorage.org/webt/ft/fd/8f/ftfd8f1ylxofsckzu6v1uujok1e.png" alt="bergabung"></p><br><p>  Label-label antara garis 303 dan 304 ini dapat diklik, perlu mengklik semua yang muncul dalam dokumen jika terjadi konflik, komit melakukan perubahan dan mengirimkan perubahan ke server.  U - Kenyamanan. </p><br><p>  Tentang cara bekerja dengan sistem kontrol versi tersedia dan dengan gambar-gambar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">yang ditulis di dok vscode</a> , buka mata Anda di sana secara singkat dan baik. </p><br><h3 id="snippets">  Cuplikan </h3><br><p>  <a href="">Cuplikan</a> adalah sejenis makro / templat yang memungkinkan Anda mempercepat penulisan kode.  Pasti harus melihat. </p><br><p>  Pembuatan objek cepat: </p><br><p><img src="https://habrastorage.org/webt/yi/wp/om/yiwpomlohxird5oovnutj4hc7ec.gif" alt="objek khusus"></p><br><p>  Ikan untuk bantuan berbasis komentar: </p><br><p><img src="https://habrastorage.org/webt/ol/jn/37/oljn37jxzabxa9h4yqquuh98s9i.gif" alt="bantuan"></p><br><p>  Jika cmdlet perlu melewati sejumlah besar parameter, masuk akal untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menggunakan splatting</a> . <br>  Ini cuplikan untuknya: </p><br><p><img src="https://habrastorage.org/webt/lx/y_/ek/lxy_ekyxsjsuiad66yzqqfoxzta.gif" alt="menampar"></p><br><p>  Lihat semua cuplikan yang tersedia yang tersedia oleh Ctrl + Alt + J: </p><br><p><img src="https://habrastorage.org/webt/0p/jm/k_/0pjmk_nms2ejlugtcsxvp1vjhea.gif" alt="cuplikan"></p><br><p>  Jika setelah itu Anda memiliki keinginan untuk terus meningkatkan lingkungan Anda, tetapi Anda belum pernah mendengar tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tab tawon, maka di sinilah Anda sekarang</a> .  Juga, jika Anda memiliki set ekstensi Anda sendiri yang berguna bagi Anda saat menulis skrip PowerShell, saya akan senang melihat daftar mereka di komentar. </p><br><h2 id="proizvoditelnost">  Performa </h2><br><p>  Topik kinerja tidak sesederhana yang tampak pada pandangan pertama.  Di satu sisi, optimasi prematur dapat sangat mengurangi keterbacaan dan pemeliharaan kode, menghemat 300ms waktu eksekusi skrip, waktu run yang biasa dapat sepuluh menit, penggunaannya dalam kasus ini jelas merusak.  Di sisi lain, ada beberapa trik yang cukup sederhana yang meningkatkan keterbacaan kode dan kecepatannya, yang cukup tepat untuk digunakan secara berkelanjutan.  Di bawah ini saya akan berbicara tentang beberapa dari mereka, jika kinerja adalah segalanya untuk Anda, dan keterbacaan berjalan di sisi karena batas waktu yang ketat dari downtime layanan selama pemeliharaan, saya sarankan Anda merujuk pada literatur yang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">relevan</a> . </p><br><h3 id="pipeline-i-foreach">  Pipeline dan foreach </h3><br><p>  Cara termudah dan selalu bekerja untuk meningkatkan produktivitas adalah menghindari penggunaan pipa.  Karena jenis keamanan dan kenyamanan demi kekuatan, elemen melewati PowerShell melalui pipa membungkus mereka masing-masing dalam suatu objek.  Dalam bahasa dotnet, perilaku <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini disebut tinju</a> .  Boxing itu bagus, ia menjamin keamanan, tetapi memiliki harga sendiri, yang terkadang tidak masuk akal untuk dibayar. </p><br><p>  Langkah pertama adalah meningkatkan kinerja dan, menurut saya, meningkatkan keterbacaan dengan menghapus semua aplikasi <code>Foreach-Object</code> dan menggantinya dengan pernyataan foreach.  Anda mungkin malu dengan fakta bahwa ini sebenarnya adalah dua entitas yang berbeda, karena <code>foreach</code> adalah alias untuk <code>Foreach-Object</code> - dalam praktiknya, perbedaan utama adalah bahwa <code>foreach</code> tidak menerima nilai dari sebuah pipa, tetapi ia bekerja berdasarkan pengalaman hingga tiga kali lebih cepat. </p><br><p>  :        -  , ,          : </p><br><pre> <code class="plaintext hljs">Get-Content D:\temp\SomeHeavy.log | Select-String '328117'</code> </pre> <br><p>        —       ,      .         — ,        ,    <code>Get-Content</code> .                  <code>string</code>  ,    ,            .    —      ,         : </p><br><blockquote> When reading from and writing to binary files, use the AsByteStream parameter and a value of 0 for the ReadCount parameter. A ReadCount value of 0 reads the entire file in a single read operation. The default ReadCount value, 1, reads one byte in each read operation and converts each byte into a separate object, which causes errors when you use the Set-Content cmdlet to write the bytes to a file unless you use AsByteStream <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://docs.microsoft.com/en-us/powershell/module/microsoft.powershell.management/get-content</a> </blockquote><br><pre> <code class="plaintext hljs">Get-Content D:\temp\SomeHeavy.log -ReadCount 0 | Select-String '328117'</code> </pre> <br><p>                : </p><br><p><img src="https://habrastorage.org/webt/t2/bg/hw/t2bghwyeop1gofgu_tapyqimp3o.png" alt="readcount"></p><br><p>        ,          .    <code>Select-String</code>          —       .                ,          <code>Select-String</code> .      ,      <code>Select-String</code>       ,        ,             : </p><br><pre> <code class="plaintext hljs">foreach ( $line in ( Get-Content D:\temp\SomeHeavy.log -ReadCount 0 )) { if ( $line -match '328117' ) { $line } }</code> </pre> <br><p>        30 , -   30%,           ,         ,        , - ,   (     ;-).      ,     .         ,    <code>-match</code> ;   —     .                ,      —               —   -   ,    . </p><br><p>   — -   ,   " "              : </p><br><pre> <code class="plaintext hljs">foreach ( $line in ( Get-Content D:\temp\SomeHeavy.log -ReadCount 0 )) { if ( $line -match '328117' ) { "$( Get-Date -UFormat '%d.%m.%Y %H:%M:%S') $line" | Out-File D:\temp\Result.log -Append } }</code> </pre> <br><p>     <code>Measure-Command</code> : </p><br><pre> <code class="plaintext hljs">Hours : 2 Minutes : 20 Seconds : 9 Milliseconds : 101</code> </pre> <br><p>   .   ,           ,          ,      .    ,    PowerShell           ,    ,       —        .         ,    ,            — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">StringBuilder</a> .                 ,            ,           .          ,                     . </p><br><pre> <code class="plaintext hljs">$StringBuilder = New-Object System.Text.StringBuilder foreach ( $line in ( Get-Content D:\temp\SomeHeavy.log -ReadCount 0 )) { if ( $line -match '328117' ) { $null = $StringBuilder.AppendLine( "$( Get-Date -UFormat '%d.%m.%Y %H:%M:%S') $line" ) } } Out-File -InputObject $StringBuilder.ToString() -FilePath D:\temp\Result.log -Append -Encoding UTF8</code> </pre> <br><p>      5 ,      : </p><br><pre> <code class="plaintext hljs">Hours : 0 Minutes : 5 Seconds : 37 Milliseconds : 150</code> </pre> <br><p>    <code>Out-File -InputObject</code> ,    ,       .          —        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">   </a>    .              —  <code>Get-Help</code>     <code>-Full</code> ,         <code>Accept pipeline input? true (ByValue)</code> : </p><br><pre> <code class="plaintext hljs">-InputObject &lt;psobject&gt; Required? false Position? Named Accept pipeline input? true (ByValue) Parameter set name (All) Aliases None Dynamic? false</code> </pre> <br><p>    PowerShell     : </p><br><p><img src="https://habrastorage.org/webt/8d/zl/r-/8dzlr-yjpt13avpi_wjibzdpnxs.png" alt="taskmgr"></p><br><p>    <code>StringBuilder</code>                           : </p><br><p><img src="https://habrastorage.org/webt/lc/4j/1c/lc4j1c3-um9jozjohlauurwzo3a.png" alt="stringbuilder alloc"></p><br><p>    ,    ,  3  3.        dotnet-      — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">StreamReader</a> . </p><br><pre> <code class="plaintext hljs">$StringBuilder = New-Object System.Text.StringBuilder $StreamReader = New-Object System.IO.StreamReader 'D:\temp\SomeHeavy.log' while ( $line = $StreamReader.ReadLine()) { if ( $line -match '328117' ) { $null = $StringBuilder.AppendLine( "$( Get-Date -UFormat '%d.%m.%Y %H:%M:%S') $line" ) } } $StreamReader.Dispose() Out-File -InputObject $StringBuilder.ToString() -FilePath C:\temp\Result.log -Append -Encoding UTF8</code> </pre> <br><pre> <code class="plaintext hljs">Hours : 0 Minutes : 5 Seconds : 33 Milliseconds : 657</code> </pre> <br><p>      ,       .               ,     ,       ,    ,          2.        ,          : </p><br><p><img src="https://habrastorage.org/webt/wr/ka/_w/wrka_wcvj1idodxx_37ka8wnhmm.png" alt="streamreader"></p><br><p>        —      "",   —  <code>StringBuilder</code> — ""       .   ,      (  100)           .       —       90%    (        ,     ): </p><br><pre> <code class="plaintext hljs">$BufferSize = 104857600 $StringBuilder = New-Object System.Text.StringBuilder $BufferSize $StreamReader = New-Object System.IO.StreamReader 'C:\temp\SomeHeavy.log' while ( $line = $StreamReader.ReadLine()) { if ( $line -match '1443' ) { #      if ( $StringBuilder.Length -gt ( $BufferSize - ( $BufferSize * 0.1 ))) { Out-File -InputObject $StringBuilder.ToString() -FilePath C:\temp\Result.log -Append -Encoding UTF8 $StringBuilder.Clear() } $null = $StringBuilder.AppendLine( "$( Get-Date -UFormat '%d.%m.%Y %H:%M:%S') $line" ) } } Out-File -InputObject $StringBuilder.ToString() -FilePath C:\temp\Result.log -Append -Encoding UTF8 $StreamReader.Dispose()</code> </pre> <br><pre> <code class="plaintext hljs">Hours : 0 Minutes : 5 Seconds : 53 Milliseconds : 417</code> </pre> <br><p>     1      : </p><br><p><img src="https://habrastorage.org/webt/rg/ro/f6/rgrof6lxdcrx96urvmxuflcbdbc.png" alt="streamreader with dump"></p><br><p>              ,                 .     ,      ,        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">StreamWriter</a> ,   ,   ;-)      ,        ,    . </p><br><p> -     —     ,        .    ,     —  .  <code>Select-String</code>  <code>Out-File</code>    ,        <code>OutOfMemoryException</code> ,    —    . </p><br><h3 id="nativnye-binarniki">   </h3><br><p> ,      PowerShell         ,         — ,  : PowerShell —          ,     . </p><br><p>  ,       <code>StringBuilder</code>     <code>dir</code> —          (  ).          : </p><br><pre> <code class="plaintext hljs">$CurrentPath = ( Get-Location ).Path + '\' $StringBuilder = New-Object System.Text.StringBuilder foreach ( $Line in ( &amp;cmd /c dir /b /s /ad )) { $null = $StringBuilder.AppendLine( $Line.Replace( $CurrentPath, '.' )) } $StringBuilder.ToString()</code> </pre> <br><pre> <code class="plaintext hljs">Hours : 0 Minutes : 0 Seconds : 3 Milliseconds : 9</code> </pre> <br><pre> <code class="plaintext hljs">$StringBuilder = New-Object System.Text.StringBuilder foreach ( $Line in ( Get-ChildItem -File -Recurse | Resolve-Path -Relative )) { $null = $StringBuilder.AppendLine( $Line ) } $StringBuilder.ToString()</code> </pre> <br><pre> <code class="plaintext hljs">Hours : 0 Minutes : 0 Seconds : 16 Milliseconds : 337</code> </pre> <br><p>     $null —     .  ,    —    <code>Out-Null</code> ;  ,    (   <code>$null</code> )     ,   . </p><br><pre> <code class="plaintext hljs"># : $null = $StringBuilder.AppendLine( $Line ) # : $StringBuilder.AppendLine( $Line ) | Out-Null</code> </pre> <br><p>           ,          ,  .      <code>Compare-Object</code> ,      ,      ,       .            robocopy.exe,      (   PowerShell 5),      : </p><br><pre> <code class="plaintext hljs">class Robocopy { [String]$RobocopyPath Robocopy () { $this.RobocopyPath = Join-Path $env:SystemRoot 'System32\Robocopy.exe' if ( -not ( Test-Path $this.RobocopyPath -PathType Leaf )) { throw '    ' } } [void]CopyFile ( [String]$SourceFile, [String]$DestinationFolder ) { $this.CopyFile( $SourceFile, $DestinationFolder, $false ) } [void]CopyFile ( [String]$SourceFile, [String]$DestinationFolder, [bool]$Archive ) { $FileName = [IO.Path]::GetFileName( $SourceFile ) $FolderName = [IO.Path]::GetDirectoryName( $SourceFile ) $Arguments = @( '/R:0', '/NP', '/NC', '/NS', '/NJH', '/NJS', '/NDL' ) if ( $Archive ) { $Arguments += $( '/A+:a' ) } $ErrorFlag = $false &amp;$this.RobocopyPath $FolderName $DestinationFolder $FileName $Arguments | Foreach-Object { if ( $ErrorFlag ) { $ErrorFlag = $false throw "$_ $ErrorString" } else { if ( $_ -match '(?&lt;=\(0x[\da-f]{8}\))(?&lt;text&gt;(.+$))' ) { $ErrorFlag = $true $ErrorString = $matches.text } else { $Logger.AddRecord( $_.Trim()) } } } if ( $LASTEXITCODE -eq 8 ) { throw 'Some files or directories could not be copied' } if ( $LASTEXITCODE -eq 16 ) { throw 'Robocopy did not copy any files. Check the command line parameters and verify that Robocopy has enough rights to write to the destination folder.' } } [void]SyncFolders ( [String]$SourceFolder, [String]$DestinationFolder ) { $this.SyncFolders( $SourceFolder, $DestinationFolder, '*.*', '', $false ) } [void]SyncFolders ( [String]$SourceFolder, [String]$DestinationFolder, [Bool]$Archive ) { $this.SyncFolders( $SourceFolder, $DestinationFolder, '*.*', '', $Archive ) } [void]SyncFolders ( [String]$SourceFolder, [String]$DestinationFolder, [String]$Include ) { $this.SyncFolders( $SourceFolder, $DestinationFolder, $Include, '', $false ) } [void]SyncFolders ( [String]$SourceFolder, [String]$DestinationFolder, [String]$Include, [Bool]$Archive ) { $this.SyncFolders( $SourceFolder, $DestinationFolder, $Include, '', $Archive ) } [void]SyncFolders ( [String]$SourceFolder, [String]$DestinationFolder, [String]$Include, [String]$Exclude ) { $this.SyncFolders( $SourceFolder, $DestinationFolder, $Include, $Exclude, $false ) } [void]SyncFolders ( [String]$SourceFolder, [String]$DestinationFolder, [String]$Include, [String]$Exclude, [Bool]$Archive ) { $Arguments = @( '/MIR', '/R:0', '/NP', '/NC', '/NS', '/NJH', '/NJS', '/NDL' ) if ( $Exclude ) { $Arguments += $( '/XF' ) $Arguments += $Exclude.Split(' ') } if ( $Archive ) { $Arguments += $( '/A+:a' ) } $ErrorFlag = $false &amp;$this.RobocopyPath $SourceFolder $DestinationFolder $Include $Arguments | Foreach-Object { if ( $ErrorFlag ) { $ErrorFlag = $false throw "$_ $ErrorString" } else { if ( $_ -match '(?&lt;=\(0x[\da-f]{8}\))(?&lt;text&gt;(.+$))' ) { $ErrorFlag = $true $ErrorString = $matches.text } else { $Logger.AddRecord( $_.Trim()) } } } if ( $LASTEXITCODE -eq 8 ) { throw 'Some files or directories could not be copied' } if ( $LASTEXITCODE -eq 16 ) { throw 'Robocopy did not copy any files. Check the command line parameters and verify that Robocopy has enough rights to write to the destination folder.' } } }</code> </pre> <br><p>                ,             (      ),         —    . </p><br><p>   ,   :        <code>Foreach-Object</code> !?  ,             :    <code>foreach</code> ,  <code>Foreach-Object</code>          —   ,   , ,   ,      .       . </p><br><p>       ,     : </p><br><pre> <code class="plaintext hljs">$Robocopy = New-Object Robocopy #    $Robocopy.CopyFile( $Source, $Dest ) #   $Robocopy.SyncFolders( $SourceDir, $DestDir ) #    .xml     $Robocopy.SyncFolders( $SourceDir, $DestDir , '*.xml', $true ) #     *.zip *.tmp *.log     $Robocopy.SyncFolders( $SourceDir, $DestDir, '*.*', '*.zip *.tmp *.log', $true )</code> </pre> <br><h3 id="poslevkusie">  </h3><br><p>        —           ,       ,            ;   ,        ,   ,     : </p><br><ul><li><p>   <code>foreach</code>   <code>Foreach-Object</code>  ; </p><br></li><li><p>   ; </p><br></li><li><p> /  ,   ; </p><br></li><li><p>  <code>StringBuilder</code>    ; </p><br></li><li><p>      ,   - ; </p><br></li><li><p>      ( ""    ); </p><br></li></ul><br><p>     :    -   ,     . </p><br><h2 id="jobs"> Jobs </h2><br><p>  ,     ,        ,    ,      ,        ,     .            .      ,      IO,               . </p><br><div class="spoiler"> <b class="spoiler_title">    ssd</b> <div class="spoiler_text"><p>       Windows Server 2019  Hyper-V  ssd (    hdd): </p><br><p><img src="https://habrastorage.org/webt/mo/eu/jf/moeujfnupkxphhi7uso_hjbzsys.jpeg" alt="2019ssd"></p></div></div><br><p>    PowerShell       ( <code>Get-Command *-Job</code> ),    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> . </p><br><p>      ,  ,  ,     : </p><br><pre> <code class="plaintext hljs">$Job = Start-Job -ScriptBlock { Write-Output 'Good night' Start-Sleep -S 10 Write-Output 'Good morning' } $Job | Wait-Job | Receive-Job Remove-Job $Job</code> </pre> <br><p>          ,         —       ,    .             <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">     </a> . </p><br><p>      ,      : </p><br><p><img src="https://habrastorage.org/webt/gc/um/r-/gcumr-9xsk2fh5c5m7epk1eozqg.png" alt="jobs"><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://xaegr.wordpress.com/2011/07/12/threadping/</a> </p><br><p> ,      ,   —     ,                 .  , ,     (50  —  50 ): </p><br><p><img src="https://habrastorage.org/webt/3f/pg/xg/3fpgxg51u9augjj9iua05wm6fgi.png" alt="job dies"></p><br><p>           .    ,  —            ,        .     —           ,    . </p><br><p>   ,           , ,              - . </p><br><h2 id="runspaces"> Runspaces </h2><br><p>                  — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Beginning Use of PowerShell Runspaces: Part 1</a> . ,  —    PowerShell        ,        .             (,    PowerShell ),       :      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">       (  )</a>       .        ,            . </p><br><p>          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">WPF </a> ,              PowerShell,     .      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="> </a> —      ,   .    —            ,         "" .     . </p><br><p>       ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">           </a> . </p><br><p><img src="https://habrastorage.org/webt/cx/pp/7v/cxpp7vozkcxdsl_ibdyva0_z3wi.gif" alt="wpf"></p><br><pre> <code class="plaintext hljs">#     $GUISyncHash = [hashtable]::Synchronized(@{}) &lt;# WPF  #&gt; $GUISyncHash.FormXAML = [xml](@" &lt;Window xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation" xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml" Title="Sample WPF Form" Height="510" Width="410" ResizeMode="NoResize"&gt; &lt;Grid&gt; &lt;Label Content=" " HorizontalAlignment="Left" Margin="10,10,0,0" VerticalAlignment="Top" Height="37" Width="374" FontSize="18"/&gt; &lt;Label Content="" HorizontalAlignment="Left" Margin="16,64,0,0" VerticalAlignment="Top" Height="26" Width="48"/&gt; &lt;TextBox x:Name="BackupPath" HorizontalAlignment="Left" Height="23" Margin="69,68,0,0" TextWrapping="Wrap" Text="" VerticalAlignment="Top" Width="300"/&gt; &lt;Label Content="" HorizontalAlignment="Left" Margin="16,103,0,0" VerticalAlignment="Top" Height="26" Width="35"/&gt; &lt;TextBox x:Name="RestorePath" HorizontalAlignment="Left" Height="23" Margin="69,107,0,0" TextWrapping="Wrap" Text="" VerticalAlignment="Top" Width="300"/&gt; &lt;Button x:Name="FirstButton" Content="√" HorizontalAlignment="Left" Margin="357,68,0,0" VerticalAlignment="Top" Width="23" Height="23"/&gt; &lt;Button x:Name="SecondButton" Content="√" HorizontalAlignment="Left" Margin="357,107,0,0" VerticalAlignment="Top" Width="23" Height="23"/&gt; &lt;CheckBox x:Name="Check" Content="  " HorizontalAlignment="Left" Margin="16,146,0,0" VerticalAlignment="Top" RenderTransformOrigin="-0.113,-0.267" Width="172"/&gt; &lt;Button x:Name="Go" Content="Go" HorizontalAlignment="Left" Margin="298,173,0,0" VerticalAlignment="Top" Width="82" Height="26"/&gt; &lt;ComboBox x:Name="Droplist" HorizontalAlignment="Left" Margin="16,173,0,0" VerticalAlignment="Top" Width="172" Height="26"/&gt; &lt;ListBox x:Name="ListBox" HorizontalAlignment="Left" Height="250" Margin="16,210,0,0" VerticalAlignment="Top" Width="364"/&gt; &lt;/Grid&gt; &lt;/Window&gt; "@) &lt;#   #&gt; $GUISyncHash.GUIThread = { $GUISyncHash.Window = [Windows.Markup.XamlReader]::Load(( New-Object System.Xml.XmlNodeReader $GUISyncHash.FormXAML )) $GUISyncHash.Check = $GUISyncHash.Window.FindName( "Check" ) $GUISyncHash.GO = $GUISyncHash.Window.FindName( "Go" ) $GUISyncHash.ListBox = $GUISyncHash.Window.FindName( "ListBox" ) $GUISyncHash.BackupPath = $GUISyncHash.Window.FindName( "BackupPath" ) $GUISyncHash.RestorePath = $GUISyncHash.Window.FindName( "RestorePath" ) $GUISyncHash.FirstButton = $GUISyncHash.Window.FindName( "FirstButton" ) $GUISyncHash.SecondButton = $GUISyncHash.Window.FindName( "SecondButton" ) $GUISyncHash.Droplist = $GUISyncHash.Window.FindName( "Droplist" ) $GUISyncHash.Window.Add_SourceInitialized({ $GUISyncHash.GO.IsEnabled = $true }) $GUISyncHash.FirstButton.Add_Click( { $GUISyncHash.ListBox.Items.Add( 'Click FirstButton' ) }) $GUISyncHash.SecondButton.Add_Click( { $GUISyncHash.ListBox.Items.Add( 'Click SecondButton' ) }) $GUISyncHash.GO.Add_Click( { $GUISyncHash.ListBox.Items.Add( 'Click GO' ) }) $GUISyncHash.Window.Add_Closed( { Stop-Process -Id $PID -Force }) $null = $GUISyncHash.Window.ShowDialog() } $Runspace = @{} $Runspace.Runspace = [RunspaceFactory]::CreateRunspace() $Runspace.Runspace.ApartmentState = "STA" $Runspace.Runspace.ThreadOptions = "ReuseThread" $Runspace.Runspace.Open() $Runspace.psCmd = { Add-Type -AssemblyName PresentationCore, PresentationFramework, WindowsBase }.GetPowerShell() $Runspace.Runspace.SessionStateProxy.SetVariable( 'GUISyncHash', $GUISyncHash ) $Runspace.psCmd.Runspace = $Runspace.Runspace $Runspace.Handle = $Runspace.psCmd.AddScript( $GUISyncHash.GUIThread ).BeginInvoke() Start-Sleep -S 1 $GUISyncHash.ListBox.Dispatcher.Invoke( "Normal", [action] { $GUISyncHash.ListBox.Items.Add( '' ) }) $GUISyncHash.ListBox.Dispatcher.Invoke( "Normal", [action] { $GUISyncHash.ListBox.Items.Add( '  ' ) }) foreach ( $item in 1..5 ) { $GUISyncHash.Droplist.Dispatcher.Invoke( "Normal", [action] { $GUISyncHash.Droplist.Items.Add( $item ) $GUISyncHash.Droplist.SelectedIndex = 0 }) } $GUISyncHash.ListBox.Dispatcher.Invoke( "Normal", [action] { $GUISyncHash.ListBox.Items.Add( 'While ( $true ) { Start-Sleep -S 10 }' ) }) while ( $true ) { Start-Sleep -S 10 }</code> </pre> <br><p>      WPF       github,       ,       smart : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/snd3r/GetDiskSmart/</a> .          ,    MVVM: </p><br><p><img src="https://habrastorage.org/webt/ke/-1/mb/ke-1mbcf2zuyg6crqt70zx4aoqw.png" alt="binging"></p><br><p>        Visual Studio,            Community Edition                 ,          xaml-  wpf — <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/punker76/kaxaml</a> </p><br><p><img src="https://habrastorage.org/webt/wf/wd/j1/wfwdj1mhk_f8bml8clv3n6sv02a.png" alt="kaxaml"></p><br><h2 id="vmesto-zaklyucheniya">  Alih-alih sebuah kesimpulan </h2><br><p> PowerShell —        Windows-.   ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  </a> ,           ,            . </p><br><p>      ,                ,   "PowerShell,  ",   .           ,        —     ,      .                 .          ,  -    , -                . </p><br><p>          —    . </p><br><p><img src="https://habrastorage.org/webt/fd/qg/_1/fdqg_1uamuh8rc66ahep2utydeo.png" alt="calm"></p><br><p> PS <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">Boomburum</a> ,    2019   powershell —  . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id443256/">https://habr.com/ru/post/id443256/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id443246/index.html">Bagaimana kami menciptakan kembali Askozia IP PBX setelah proyek dijual dan ditutup oleh pengembang</a></li>
<li><a href="../id443248/index.html">Protokol reservasi mulus PRP dan HSR</a></li>
<li><a href="../id443250/index.html">Pengumpul Sampah Homemade untuk OpenJDK</a></li>
<li><a href="../id443252/index.html">Bot Ant Modular dengan Memori</a></li>
<li><a href="../id443254/index.html">Triton adalah virus paling mematikan</a></li>
<li><a href="../id443258/index.html">Gotify - proyek sumber terbuka untuk mengirimkan pemberitahuan dan mengirim pesan ke server</a></li>
<li><a href="../id443260/index.html">Bermigrasi ke Zimbra tanpa mempertaruhkan bisnis dengan domain umum</a></li>
<li><a href="../id443262/index.html">Saran buruk: bagaimana cara menulis dokumentasi teknis? Bagian Tiga dan Terakhir</a></li>
<li><a href="../id443264/index.html">Dia berbicara dan menunjukkan: apakah retorika politisi Ukraina populer berbeda?</a></li>
<li><a href="../id443266/index.html">Bagaimana kami membantu mengubah pekerjaan akuntansi di perusahaan energi besar</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>