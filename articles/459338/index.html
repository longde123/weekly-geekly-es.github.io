<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游눇 游땺 游꼰 Usar el verificador como un medio para modelar r치pidamente proyectos RTL. Introducci칩n a UVM 游 游꿅 游띏游낖</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este art칤culo describir치 la instalaci칩n y el uso de software gratuito para modelar circuitos l칩gicos digitales en Verilog como una alternativa a los p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Usar el verificador como un medio para modelar r치pidamente proyectos RTL. Introducci칩n a UVM</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459338/">  Este art칤culo describir치 la instalaci칩n y el uso de software gratuito para modelar circuitos l칩gicos digitales en Verilog como una alternativa a los productos comerciales Incisve de Cadense y ModelSim de MentorGraphics.  Comparaci칩n de simulaciones en ModelSim y Verilator.  Tambi칠n se considerar치 una metodolog칤a de verificaci칩n universal, UVM. <br><br><h2>  Instalaci칩n del software SystemC UVM </h2><br><h3>  1. El verilador </h3><br>  Uno de los lenguajes de descripci칩n de hardware es verilog.  Puedes escribir un m칩dulo en este idioma. <br><br>  Por ejemplo, hay un esquema de contador: <br><br><img src="https://habrastorage.org/webt/s6/a7/9i/s6a79i89t6vzfl-a6dqeiwi5fh8.png" alt="imagen"><br><br>  Su c칩digo se ver치 as칤: <br><br><pre><code class="cpp hljs">reg [<span class="hljs-number"><span class="hljs-number">3</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]counter; always @(posedge clk <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> posedge reset)   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(reset)    counter &lt;= <span class="hljs-number"><span class="hljs-number">4'</span></span>d0;   <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>    counter &lt;= counter + <span class="hljs-number"><span class="hljs-number">1'</span></span>d1;</code> </pre> <br>  Despu칠s de la simulaci칩n, obtenemos las formas de onda: <br><br><img src="https://habrastorage.org/webt/m5/-o/mg/m5-omg9r-4_fzvo1momfxt7wq-8.png" alt="imagen"><br><br>  Se puede ver que el siguiente valor, uno m치s que el anterior, se escribir치 en los registros del contador a lo largo del frente de la frecuencia del reloj. <br><br>  Un m칩dulo escrito puede tener una estructura m치s compleja, que ser치 dif칤cil de verificar manualmente todos los estados de.  Necesitaremos pruebas automatizadas.  Para esto, es necesario desarrollar un entorno de prueba en uno de los lenguajes de programaci칩n.  El entorno de prueba nos dar치 la oportunidad de realizar una verificaci칩n funcional completa del dispositivo. <br><br>  Para probar el c칩digo del proyecto, adem치s de lenguajes como Verilog, SystemVerilog, Python (para escribir modelos), puede usar el lenguaje <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SystemC</a> .  SystemC es un lenguaje de dise침o y verificaci칩n a nivel de sistema para modelos a nivel de sistema implementado como una biblioteca C ++ de c칩digo abierto. <br><br>  Una forma de verificar los m칩dulos Verilog usando SystemC es traducir los archivos Verilog a C ++.  Ay칰danos con este verilador. <br><br>  Verilator es el simulador HDL Verilog gratuito m치s r치pido que supera la mayor칤a de los simuladores comerciales.  Verilator compila SystemVerilog sintetizado (por lo general, este no es el c칩digo del banco de pruebas), as칤 como algunas declaraciones de SystemVerilog y Synthesis en c칩digo C ++ o SystemC de subproceso 칰nico o multiproceso.  Verilator fue dise침ado para grandes proyectos donde el rendimiento de la simulaci칩n es primordial y es particularmente adecuado para generar modelos de procesadores ejecutables para equipos de desarrollo de software embebido.  Verilator se utiliza para simular muchos dise침os de puerta de enlace multimillonarios muy grandes con miles de m칩dulos y es compatible con muchos proveedores de tecnolog칤a IP, incluida la IP de Arm y todos los famosos proveedores de IP RISC-V. <br><a name="habracut"></a><br>  Verilator puede no ser la mejor opci칩n si espera un reemplazo completo para NC-Verilog, VCS u otro simulador comercial de Verilog, o el simulador de comportamiento Verilog para un proyecto muy peque침o.  Sin embargo, si est치 buscando una forma de portar Verilog sintetizado a C ++ o SystemC, y su equipo es libre de escribir solo c칩digo C ++, este es un compilador de Verilog gratuito para usted. <br><br>  Para instalar la 칰ltima versi칩n en Ubuntu: descargue el archivo <a href="">desde el enlace desde el sitio oficial</a> . <br><br>  Instalar: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#sudo apt-get install make autoconf g++ flex bison # Prerequisites unsetenv VERILATOR_ROOT # For csh; ignore error if on bash unset VERILATOR_ROOT # For bash tar xvzf verilator*.t*gz cd verilator* ./configure make sudo make install</span></span></code> </pre> <br><h3>  2. GTK Wave </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/adc/de9/6c3/adcde96c392048d083337f797505b1fc.gif" alt="imagen"><br>  GTKWave es un visor de forma de onda con todas las funciones y tambi칠n le permite convertir archivos de formato vcd a fst, m치s conveniente y m치s r치pido. <br><br>  Instalar: <br><br><pre> <code class="bash hljs">sudo apt-get install gtkwave</code> </pre> <br><h3>  3. SYSTEMC </h3><br>  Un lenguaje para dise침ar y verificar modelos a nivel de sistema implementados en forma de una biblioteca C ++ de c칩digo abierto. <br><br>  Como se mencion칩 anteriormente, verilator es compatible con systemc, por lo que debe crear un proyecto en el que el punto de referencia de prueba se describir치 en systemc y los archivos de origen en verilog sintetizado.  Para hacer esto, necesitamos las bibliotecas del compilador g ++ proporcionadas por Accelera.  Accellera Systems Initiative es una organizaci칩n independiente y sin fines de lucro dedicada a crear, respaldar, promover y promover est치ndares de dise침o, simulaci칩n y verificaci칩n a nivel de sistema para su uso en la industria electr칩nica mundial. <br><br>  Descargar el archivo: <br>  <a href="">http://accellera.org/images/downloads/standards/systemc/systemc-2.3.1a.tar.gz</a> <br><br>  Instalar: <br><br><pre> <code class="bash hljs">tar -xvf systemc-2.3.1a.tar.gz <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> systemc-2.3.1a mkdir objdir sudo ./configure --prefix=/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/systemc-2.3.1a/ sudo make sudo make install <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ../</code> </pre> <br><h3>  4. UVM para SYSTEMC </h3><br>  Este art칤culo revisar치 un proyecto que implementa herramientas de verificaci칩n UVM.  La verificaci칩n es una confirmaci칩n de la conformidad del producto final con los requisitos de referencia predefinidos.  Una de sus herramientas de verificaci칩n pueden ser las pruebas.  Para ejecutar secuencias de prueba en modelos de dispositivos reales al nivel de descripciones RTL, es necesario desarrollar un entorno de prueba. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">UVM</a> - (Metodolog칤a de verificaci칩n universal) es una metodolog칤a de verificaci칩n universal, un est치ndar que permite el desarrollo eficiente y la reutilizaci칩n de entornos de validaci칩n de bloque de IP.  UVM es una metodolog칤a de verificaci칩n cuyas tareas incluyen organizar un entorno efectivo alrededor de la unidad bajo prueba.  Sus ventajas: <br><br><ul><li>  estructura clara en forma de bloques dedicados que deciden espec칤ficos </li><li>  tareas </li><li>  la capacidad de reutilizar bloques en proyectos posteriores; </li><li>  la m치xima automatizaci칩n posible de la verificaci칩n; </li><li>  la informaci칩n de informes m치s completa que permite, cuando ocurre un error, identificar sus causas de la manera m치s r치pida y precisa posible y sugerir soluciones. </li></ul><br>  Las metodolog칤as UVM constan de dos partes: un conjunto de reglas para construir un entorno de prueba y una biblioteca de bloques en blanco para verificaci칩n, por ejemplo, un generador de texto, un colector de estad칤sticas, etc.  La principal ventaja de UVM es su versatilidad y compatibilidad con entornos de terceros. <br><br>  Como systemc admite la metodolog칤a UVM, pasemos a instalar las bibliotecas necesarias. <br><br>  Descargar el archivo: <br><br>  <a href="">https://www.accellera.org/images/downloads/drafts-review/uvm-systemc-1.0-beta2.tar.gz</a> <br><br>  Instalar: <br><br><pre> <code class="bash hljs">tar -xvf uvm-systemc-1.0-beta2.tar.gz <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> uvm-systemc-1.0-beta2/ mkdir objdir sudo ./configure --prefix=/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/systemc_uvm/ --with-systemc=/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/systemc-2.3.1a sudo make sudo make install</code> </pre><br>  Creamos una alianza: <br><br><pre> <code class="bash hljs">sudo mkdir /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/uvm_systemc_aliance</code> </pre> <br>  Copie el contenido de las carpetas / usr / local / uvm_systemc_aliance / y /usr/local/systemc-2.3.1/ a esta carpeta <br><br>  Descargue el proyecto terminado en el enlace: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/paprikun/SYSTEMC/</a> <br><br>  Abra la carpeta de ejemplos de verilator. <br>  La carpeta rtl contiene una descripci칩n del dispositivo.  En este ejemplo, es un controlador PWM. <br>  En el archivo makefile de la carpeta sim para construir el proyecto. <br>  En la carpeta tb est치 el c칩digo para el verificador.  La carpeta tb / uvm contiene un ejemplo de entorno uvm.  El archivo principal es un punto de entrada en las pruebas; conecta el dispositivo bajo prueba con el entorno uvm. <br>  Intentamos construir el proyecto desde la carpeta sim con el comando make all.  Vemos un error: <br><br><pre> <code class="bash hljs">/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/uvm_systemc_aliance//include/systemc.h:120:16: error: <span class="hljs-string"><span class="hljs-string">'std::gets'</span></span> has not been declared using std::gets;</code> </pre> <br>  Lo arreglamos reemplazando la l칤nea 120: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(__cplusplus) &amp;&amp; (__cplusplus &lt; 201103L) using std::gets; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br>  Una vez m치s, intentamos ejecutar el banco de pruebas y tropezar con la advertencia: <br><br><pre> <code class="bash hljs">/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/uvm_systemc_aliance//include/sysc/packages/boost/get_pointer.hpp:21:40: warning: <span class="hljs-string"><span class="hljs-string">'template&lt;class&gt; class std::auto_ptr'</span></span> is deprecated [-Wdeprecated-declarations] template&lt;class T&gt; T * get_pointer(std::auto_ptr&lt;T&gt; const&amp; p)</code> </pre> <br>  Cambia auto_ptr a unique_ptr. <br><br><h2>  Proyecto de montaje y simulaci칩n </h2><br>  Ahora que las bibliotecas est치n instaladas y funcionando, estamos construyendo el proyecto: hacer todo.  El archivo ejecutable simu debe aparecer en la carpeta sim.  Este es un objeto creado por el compilador.  Comenzamos con el equipo ./simu.  Deber칤a aparecer lo siguiente: <br><br><pre> <code class="bash hljs">SystemC 2.3.1-Accellera --- Jun 28 2019 11:39:29 Copyright (c) 1996-2014 by all Contributors, ALL RIGHTS RESERVED Universal Verification Methodology <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> SystemC (UVM-SystemC) Version: 1.0-beta2 Date: 2018-10-24 Copyright (c) 2006 - 2018 by all Contributors See NOTICE file <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> all Contributors ALL RIGHTS RESERVED Licensed under the Apache License, Version 2.0 UVM_INFO @ 0 s: reporter [RNTST] Running <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> ... simulation real time = 9 sec UVM_INFO uvm_default_report_server.cpp(666) @ 179490249010 ps: reporter [UVM/REPORT/SERVER] --- UVM Report Summary --- ** Report counts by severity UVM_INFO : 1 UVM_WARNING : 0 UVM_ERROR : 0 UVM_FATAL : 0 ** Report counts by id [RNTST] 1 UVM_INFO @ 179490249010 ps: reporter [FINISH] UVM-SystemC phasing completed; simulation finished</code> </pre><br>  Cuando finaliza la simulaci칩n, finaliza la grabaci칩n en forma de onda.  El archivo simu.vcd se puede abrir con gtkwave: <br><br><img src="https://habrastorage.org/webt/xv/9m/ka/xv9mkaqsrcrvfczarjl5rz29i88.png"><br><br>  Para mostrar las se침ales a la izquierda, seleccione SystemC, luego manteniendo presionada la tecla May칰s, seleccione cualquier se침al y haga clic en Anexar.  La informaci칩n sobre herramientas aparece en la barra de herramientas cuando pasa el mouse por encima.  El desplazamiento del mouse funciona, debe mantener presionada la tecla May칰s o Ctrl. <br><br>  Tambi칠n hay formas de convertir este archivo a otro m치s peque침o. <br><br>  Si hay modelosim har치 la conversi칩n.  En la terminal, ingrese el comando vsim.  En el terminal modelsim: <br><br><pre> <code class="bash hljs">vcd2wlf simu.vcd simu.wlf</code> </pre> <br>  O usando gtkwave en la terminal de Linux: <br><pre> <code class="bash hljs">vcd2lxt simu.vcd simu.lxt vcd2lxt2 simu.vcd simu.lxt2</code> </pre> <br>  Para comparar el tiempo de simulaci칩n, se cre칩 un proyecto similar, pero ya para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Modelsim</a> .  Modelos de carpetasim_example.  Del mismo modo creado entorno UVM.  La sintaxis es similar a pesar del hecho de que hay diferentes idiomas.  Si instal칩 Modelsim con soporte para uvm, puede ejecutar el comando make all. <br><br>  Adem치s del entorno en ambos proyectos, se tom칩 una simulaci칩n en tiempo real de las mediciones. <br><br>  Con el tiempo, la diferencia result칩: <br><div class="scrollable-table"><table><tbody><tr><td>  Miercoles </td><td>  forma de onda </td><td>  comando para ejecutar </td><td>  tiempo de simulaci칩n (seg.) </td></tr><tr><td>  Modelsim </td><td>  si </td><td>  hacer sim TRACE = 1 </td><td>  18 a침os </td></tr><tr><td>  Verilator </td><td>  si </td><td>  hacer sim TRACE = 1 </td><td>  9 9 </td></tr><tr><td>  Modelsim </td><td>  no </td><td>  hacer sim TRACE = 0 </td><td>  10 </td></tr><tr><td>  Verilator </td><td>  no </td><td>  hacer sim TRACE = 0 </td><td>  4 4 </td></tr></tbody></table></div><br>  Como puede ver en la tabla, el verilador tiene una ventaja.  Los datos se presentan para una PC con 8GB de RAM, un procesador de 8 n칰cleos, 800 MHz, cargando un n칰cleo. <br><br>  Compare el tama침o del archivo: <br><div class="scrollable-table"><table><tbody><tr><td>  simu.vcd </td><td>  807,7 MB </td></tr><tr><td>  simu.wlf (conversi칩n creada en Verilator) </td><td>  41 MB </td></tr><tr><td>  simu.wlf (creado en modelsim) </td><td>  9.3 MB </td></tr><tr><td>  simu.lxt </td><td>  128 MB </td></tr><tr><td>  simu.lxt2 </td><td>  162 MB </td></tr></tbody></table></div><br>  Aqu칤 el verificador pierde, pero puede experimentar creando formas de onda y trazar profundidad, el per칤odo de grabaci칩n (el comienzo y el final de la grabaci칩n de forma de onda se pueden cambiar).  Con qu칠 archivo trabajar depende de usted. <br><br>  Durante las pruebas, adem치s del tiempo de la simulaci칩n en s칤, se encontr칩 una discrepancia en la lectura de los datos de entrada del bus.  Si los datos del bus en el bus cambian durante el frente clk, Modelsim lee los datos despu칠s del frente, verificador antes: <br><br><pre> <code class="cpp hljs">input clk; input [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] in; reg [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] in_last_ ; ... always @(posedge clk) begin ... in_last_ &lt;= in; ... end</code> </pre><br><img src="https://habrastorage.org/webt/nc/ky/9r/ncky9rwjfvckf6hetlogg-futqa.png" alt="imagen"><br><br>  Durante las pruebas, este punto debe tenerse en cuenta, ya que parte del entorno de prueba para diferentes simuladores funcionar치 de manera diferente. <br><br>  Adem치s, el verificador no tiene en cuenta el estado "x" de la se침al y traduce todo a "0"; <br><br><h2>  BANCO DE PRUEBA UVM </h2><br>  Considere el entorno de prueba, la carpeta tb / uvm. <br><br>  El banco de pruebas UVM es el entorno sobre el dispositivo.  En este ejemplo, el dispositivo es un controlador PWM.  Diagrama del entorno UVM: <br><br><img src="https://habrastorage.org/webt/94/tp/ox/94tpox5qii7r4qqaaakc_fbqrd4.png" alt="imagen"><br><br>  Como puede ver en el diagrama, UVM consiste en bloques (clases).  Cada bloque realiza sus funciones.  El ejemplo muestra uno de los posibles dise침os del entorno de prueba.  El nombre y la funcionalidad de cada clase corresponde a la clase de la que se hereda.  Consideremos cada clase con m치s detalle. <br><br>  Archivo de entorno env.h o env.svh.  Esta es una clase que puede contener una o m치s clases de agente, en las que se conectan tres clases: secuenciador, controlador, monitor.  No hay agente en el ejemplo, pero su funci칩n se implementa en la clase env.  Para la prueba necesitamos escribir alguna secuencia de acciones: secuenciaci칩n. <br><br>  Pasemos al c칩digo de inicio de secuenciaci칩n: <br><br><pre> <code class="cpp hljs">sequence_[n]-&gt;start(sqr, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre> <br>  Secuenciador (secuenciador) - archivo sequncer.h.  En el sistema verilog, result칩 utilizar el secuenciador predeterminado.  Una clase que contiene una o m치s secuencias (secuencia) (archivos secuencia_a.h, secuencia_a.svh).  Cada secuencia es una cadena de acciones.  Una de estas acciones puede ser enviar una transacci칩n.  Transacci칩n: transferir datos de una clase a otra.  La clase en la que se describen las transacciones es bus_trans.  A continuaci칩n se muestra una descripci칩n de dos clases, cada una de las cuales ideol칩gicamente tiene sus propias funciones espec칤ficas: controlador y monitor. <br><br>  Controlador: archivo drv.h, drv.svh.  Una clase que recibe transacciones de un secuenciador y las traduce en se침ales.  El conductor sirve como asistente de secuenciador en un nivel inferior.  Considere enviar un paquete. <br><br>  La secuencia abre una ventana de transacci칩n, el controlador detecta este evento y comienza a recibir datos.  La secuencia est치 esperando una respuesta del conductor.  El controlador simula las se침ales para el dispositivo, luego le indica al secuenciador que la ventana se puede cerrar.  La idea es que el secuenciador funcione a un nivel alto y el controlador a un nivel inferior. <br><br>  Las se침ales se conectan a trav칠s del bus de interfaz al dispositivo.  La interfaz se describe en los archivos vip_if.h, vip_if.svh. <br><br>  A continuaci칩n, debe verificar si las se침ales de salida coinciden con las esperadas.  Hay dos soluciones: <br><br><ul><li>  Escribir un modelo para un dispositivo </li><li>  Verificaci칩n de se침al a trav칠s del agente UVM </li></ul><br>  En el ejemplo, se considera la segunda opci칩n.  Para probar el dispositivo a nivel funcional, es necesario comparar la salida con la esperada.  El requisito para el dispositivo era la correcci칩n del ciclo de trabajo dado de la se침al y el per칤odo de la se침al.  Para monitorear las se침ales de salida, se escribe una nueva clase: Monitor (archivo monitor.h, monitor.svh).  Por lo general, en un entorno de prueba, el monitor transfiere las se침ales en la transacci칩n (a un nivel superior) y se env칤a a la clase de comparaci칩n: cuadro de indicadores. <br><br>  En este ejemplo, las se침ales se verifican de inmediato.  En caso de discrepancia entre el valor esperado y el medido, la prueba se detiene. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/459338/">https://habr.com/ru/post/459338/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459326/index.html">Autoescalado y gesti칩n de recursos en Kubernetes (revisi칩n e informe de video)</a></li>
<li><a href="../459328/index.html">La mejor relaci칩n calidad-precio - Mpow A5 (059)</a></li>
<li><a href="../459330/index.html">Bitrix para programador y gerente: amor y odio</a></li>
<li><a href="../459334/index.html">YouTrack 2019.2: un banner de todo el sistema, mejoras en la p치gina de lista de tareas, nuevas opciones de b칰squeda y m치s</a></li>
<li><a href="../459336/index.html">Vive y aprende. Parte 1. Orientaci칩n escolar y profesional</a></li>
<li><a href="../459340/index.html">Organizar un proyecto de ML con Ocean</a></li>
<li><a href="../459342/index.html">Cach칠 remoto para iOS, alternancia de funciones, temas oscuros y una carrera de desarrollador: informe con Avito iOS Meetup # 7</a></li>
<li><a href="../459344/index.html">M칠tricas de DevOps: d칩nde obtener datos para los c치lculos</a></li>
<li><a href="../459346/index.html">La vuelta al mundo con un libro electr칩nico: ONYX BOOX James Cook 2 Review</a></li>
<li><a href="../459348/index.html">Otro bypass de autenticaci칩n en redes wifi p칰blicas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>