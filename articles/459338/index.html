<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💄 😴 🍥 Usar el verificador como un medio para modelar rápidamente proyectos RTL. Introducción a UVM 👀 🎎 🛌🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este artículo describirá la instalación y el uso de software gratuito para modelar circuitos lógicos digitales en Verilog como una alternativa a los p...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Usar el verificador como un medio para modelar rápidamente proyectos RTL. Introducción a UVM</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459338/">  Este artículo describirá la instalación y el uso de software gratuito para modelar circuitos lógicos digitales en Verilog como una alternativa a los productos comerciales Incisve de Cadense y ModelSim de MentorGraphics.  Comparación de simulaciones en ModelSim y Verilator.  También se considerará una metodología de verificación universal, UVM. <br><br><h2>  Instalación del software SystemC UVM </h2><br><h3>  1. El verilador </h3><br>  Uno de los lenguajes de descripción de hardware es verilog.  Puedes escribir un módulo en este idioma. <br><br>  Por ejemplo, hay un esquema de contador: <br><br><img src="https://habrastorage.org/webt/s6/a7/9i/s6a79i89t6vzfl-a6dqeiwi5fh8.png" alt="imagen"><br><br>  Su código se verá así: <br><br><pre><code class="cpp hljs">reg [<span class="hljs-number"><span class="hljs-number">3</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>]counter; always @(posedge clk <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> posedge reset)   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(reset)    counter &lt;= <span class="hljs-number"><span class="hljs-number">4'</span></span>d0;   <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>    counter &lt;= counter + <span class="hljs-number"><span class="hljs-number">1'</span></span>d1;</code> </pre> <br>  Después de la simulación, obtenemos las formas de onda: <br><br><img src="https://habrastorage.org/webt/m5/-o/mg/m5-omg9r-4_fzvo1momfxt7wq-8.png" alt="imagen"><br><br>  Se puede ver que el siguiente valor, uno más que el anterior, se escribirá en los registros del contador a lo largo del frente de la frecuencia del reloj. <br><br>  Un módulo escrito puede tener una estructura más compleja, que será difícil de verificar manualmente todos los estados de.  Necesitaremos pruebas automatizadas.  Para esto, es necesario desarrollar un entorno de prueba en uno de los lenguajes de programación.  El entorno de prueba nos dará la oportunidad de realizar una verificación funcional completa del dispositivo. <br><br>  Para probar el código del proyecto, además de lenguajes como Verilog, SystemVerilog, Python (para escribir modelos), puede usar el lenguaje <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">SystemC</a> .  SystemC es un lenguaje de diseño y verificación a nivel de sistema para modelos a nivel de sistema implementado como una biblioteca C ++ de código abierto. <br><br>  Una forma de verificar los módulos Verilog usando SystemC es traducir los archivos Verilog a C ++.  Ayúdanos con este verilador. <br><br>  Verilator es el simulador HDL Verilog gratuito más rápido que supera la mayoría de los simuladores comerciales.  Verilator compila SystemVerilog sintetizado (por lo general, este no es el código del banco de pruebas), así como algunas declaraciones de SystemVerilog y Synthesis en código C ++ o SystemC de subproceso único o multiproceso.  Verilator fue diseñado para grandes proyectos donde el rendimiento de la simulación es primordial y es particularmente adecuado para generar modelos de procesadores ejecutables para equipos de desarrollo de software embebido.  Verilator se utiliza para simular muchos diseños de puerta de enlace multimillonarios muy grandes con miles de módulos y es compatible con muchos proveedores de tecnología IP, incluida la IP de Arm y todos los famosos proveedores de IP RISC-V. <br><a name="habracut"></a><br>  Verilator puede no ser la mejor opción si espera un reemplazo completo para NC-Verilog, VCS u otro simulador comercial de Verilog, o el simulador de comportamiento Verilog para un proyecto muy pequeño.  Sin embargo, si está buscando una forma de portar Verilog sintetizado a C ++ o SystemC, y su equipo es libre de escribir solo código C ++, este es un compilador de Verilog gratuito para usted. <br><br>  Para instalar la última versión en Ubuntu: descargue el archivo <a href="">desde el enlace desde el sitio oficial</a> . <br><br>  Instalar: <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#sudo apt-get install make autoconf g++ flex bison # Prerequisites unsetenv VERILATOR_ROOT # For csh; ignore error if on bash unset VERILATOR_ROOT # For bash tar xvzf verilator*.t*gz cd verilator* ./configure make sudo make install</span></span></code> </pre> <br><h3>  2. GTK Wave </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/adc/de9/6c3/adcde96c392048d083337f797505b1fc.gif" alt="imagen"><br>  GTKWave es un visor de forma de onda con todas las funciones y también le permite convertir archivos de formato vcd a fst, más conveniente y más rápido. <br><br>  Instalar: <br><br><pre> <code class="bash hljs">sudo apt-get install gtkwave</code> </pre> <br><h3>  3. SYSTEMC </h3><br>  Un lenguaje para diseñar y verificar modelos a nivel de sistema implementados en forma de una biblioteca C ++ de código abierto. <br><br>  Como se mencionó anteriormente, verilator es compatible con systemc, por lo que debe crear un proyecto en el que el punto de referencia de prueba se describirá en systemc y los archivos de origen en verilog sintetizado.  Para hacer esto, necesitamos las bibliotecas del compilador g ++ proporcionadas por Accelera.  Accellera Systems Initiative es una organización independiente y sin fines de lucro dedicada a crear, respaldar, promover y promover estándares de diseño, simulación y verificación a nivel de sistema para su uso en la industria electrónica mundial. <br><br>  Descargar el archivo: <br>  <a href="">http://accellera.org/images/downloads/standards/systemc/systemc-2.3.1a.tar.gz</a> <br><br>  Instalar: <br><br><pre> <code class="bash hljs">tar -xvf systemc-2.3.1a.tar.gz <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> systemc-2.3.1a mkdir objdir sudo ./configure --prefix=/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/systemc-2.3.1a/ sudo make sudo make install <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ../</code> </pre> <br><h3>  4. UVM para SYSTEMC </h3><br>  Este artículo revisará un proyecto que implementa herramientas de verificación UVM.  La verificación es una confirmación de la conformidad del producto final con los requisitos de referencia predefinidos.  Una de sus herramientas de verificación pueden ser las pruebas.  Para ejecutar secuencias de prueba en modelos de dispositivos reales al nivel de descripciones RTL, es necesario desarrollar un entorno de prueba. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">UVM</a> - (Metodología de verificación universal) es una metodología de verificación universal, un estándar que permite el desarrollo eficiente y la reutilización de entornos de validación de bloque de IP.  UVM es una metodología de verificación cuyas tareas incluyen organizar un entorno efectivo alrededor de la unidad bajo prueba.  Sus ventajas: <br><br><ul><li>  estructura clara en forma de bloques dedicados que deciden específicos </li><li>  tareas </li><li>  la capacidad de reutilizar bloques en proyectos posteriores; </li><li>  la máxima automatización posible de la verificación; </li><li>  la información de informes más completa que permite, cuando ocurre un error, identificar sus causas de la manera más rápida y precisa posible y sugerir soluciones. </li></ul><br>  Las metodologías UVM constan de dos partes: un conjunto de reglas para construir un entorno de prueba y una biblioteca de bloques en blanco para verificación, por ejemplo, un generador de texto, un colector de estadísticas, etc.  La principal ventaja de UVM es su versatilidad y compatibilidad con entornos de terceros. <br><br>  Como systemc admite la metodología UVM, pasemos a instalar las bibliotecas necesarias. <br><br>  Descargar el archivo: <br><br>  <a href="">https://www.accellera.org/images/downloads/drafts-review/uvm-systemc-1.0-beta2.tar.gz</a> <br><br>  Instalar: <br><br><pre> <code class="bash hljs">tar -xvf uvm-systemc-1.0-beta2.tar.gz <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> uvm-systemc-1.0-beta2/ mkdir objdir sudo ./configure --prefix=/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/systemc_uvm/ --with-systemc=/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/systemc-2.3.1a sudo make sudo make install</code> </pre><br>  Creamos una alianza: <br><br><pre> <code class="bash hljs">sudo mkdir /usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/uvm_systemc_aliance</code> </pre> <br>  Copie el contenido de las carpetas / usr / local / uvm_systemc_aliance / y /usr/local/systemc-2.3.1/ a esta carpeta <br><br>  Descargue el proyecto terminado en el enlace: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/paprikun/SYSTEMC/</a> <br><br>  Abra la carpeta de ejemplos de verilator. <br>  La carpeta rtl contiene una descripción del dispositivo.  En este ejemplo, es un controlador PWM. <br>  En el archivo makefile de la carpeta sim para construir el proyecto. <br>  En la carpeta tb está el código para el verificador.  La carpeta tb / uvm contiene un ejemplo de entorno uvm.  El archivo principal es un punto de entrada en las pruebas; conecta el dispositivo bajo prueba con el entorno uvm. <br>  Intentamos construir el proyecto desde la carpeta sim con el comando make all.  Vemos un error: <br><br><pre> <code class="bash hljs">/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/uvm_systemc_aliance//include/systemc.h:120:16: error: <span class="hljs-string"><span class="hljs-string">'std::gets'</span></span> has not been declared using std::gets;</code> </pre> <br>  Lo arreglamos reemplazando la línea 120: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> defined(__cplusplus) &amp;&amp; (__cplusplus &lt; 201103L) using std::gets; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span></span></code> </pre> <br>  Una vez más, intentamos ejecutar el banco de pruebas y tropezar con la advertencia: <br><br><pre> <code class="bash hljs">/usr/<span class="hljs-built_in"><span class="hljs-built_in">local</span></span>/uvm_systemc_aliance//include/sysc/packages/boost/get_pointer.hpp:21:40: warning: <span class="hljs-string"><span class="hljs-string">'template&lt;class&gt; class std::auto_ptr'</span></span> is deprecated [-Wdeprecated-declarations] template&lt;class T&gt; T * get_pointer(std::auto_ptr&lt;T&gt; const&amp; p)</code> </pre> <br>  Cambia auto_ptr a unique_ptr. <br><br><h2>  Proyecto de montaje y simulación </h2><br>  Ahora que las bibliotecas están instaladas y funcionando, estamos construyendo el proyecto: hacer todo.  El archivo ejecutable simu debe aparecer en la carpeta sim.  Este es un objeto creado por el compilador.  Comenzamos con el equipo ./simu.  Debería aparecer lo siguiente: <br><br><pre> <code class="bash hljs">SystemC 2.3.1-Accellera --- Jun 28 2019 11:39:29 Copyright (c) 1996-2014 by all Contributors, ALL RIGHTS RESERVED Universal Verification Methodology <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> SystemC (UVM-SystemC) Version: 1.0-beta2 Date: 2018-10-24 Copyright (c) 2006 - 2018 by all Contributors See NOTICE file <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> all Contributors ALL RIGHTS RESERVED Licensed under the Apache License, Version 2.0 UVM_INFO @ 0 s: reporter [RNTST] Running <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> ... simulation real time = 9 sec UVM_INFO uvm_default_report_server.cpp(666) @ 179490249010 ps: reporter [UVM/REPORT/SERVER] --- UVM Report Summary --- ** Report counts by severity UVM_INFO : 1 UVM_WARNING : 0 UVM_ERROR : 0 UVM_FATAL : 0 ** Report counts by id [RNTST] 1 UVM_INFO @ 179490249010 ps: reporter [FINISH] UVM-SystemC phasing completed; simulation finished</code> </pre><br>  Cuando finaliza la simulación, finaliza la grabación en forma de onda.  El archivo simu.vcd se puede abrir con gtkwave: <br><br><img src="https://habrastorage.org/webt/xv/9m/ka/xv9mkaqsrcrvfczarjl5rz29i88.png"><br><br>  Para mostrar las señales a la izquierda, seleccione SystemC, luego manteniendo presionada la tecla Mayús, seleccione cualquier señal y haga clic en Anexar.  La información sobre herramientas aparece en la barra de herramientas cuando pasa el mouse por encima.  El desplazamiento del mouse funciona, debe mantener presionada la tecla Mayús o Ctrl. <br><br>  También hay formas de convertir este archivo a otro más pequeño. <br><br>  Si hay modelosim hará la conversión.  En la terminal, ingrese el comando vsim.  En el terminal modelsim: <br><br><pre> <code class="bash hljs">vcd2wlf simu.vcd simu.wlf</code> </pre> <br>  O usando gtkwave en la terminal de Linux: <br><pre> <code class="bash hljs">vcd2lxt simu.vcd simu.lxt vcd2lxt2 simu.vcd simu.lxt2</code> </pre> <br>  Para comparar el tiempo de simulación, se creó un proyecto similar, pero ya para <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Modelsim</a> .  Modelos de carpetasim_example.  Del mismo modo creado entorno UVM.  La sintaxis es similar a pesar del hecho de que hay diferentes idiomas.  Si instaló Modelsim con soporte para uvm, puede ejecutar el comando make all. <br><br>  Además del entorno en ambos proyectos, se tomó una simulación en tiempo real de las mediciones. <br><br>  Con el tiempo, la diferencia resultó: <br><div class="scrollable-table"><table><tbody><tr><td>  Miercoles </td><td>  forma de onda </td><td>  comando para ejecutar </td><td>  tiempo de simulación (seg.) </td></tr><tr><td>  Modelsim </td><td>  si </td><td>  hacer sim TRACE = 1 </td><td>  18 años </td></tr><tr><td>  Verilator </td><td>  si </td><td>  hacer sim TRACE = 1 </td><td>  9 9 </td></tr><tr><td>  Modelsim </td><td>  no </td><td>  hacer sim TRACE = 0 </td><td>  10 </td></tr><tr><td>  Verilator </td><td>  no </td><td>  hacer sim TRACE = 0 </td><td>  4 4 </td></tr></tbody></table></div><br>  Como puede ver en la tabla, el verilador tiene una ventaja.  Los datos se presentan para una PC con 8GB de RAM, un procesador de 8 núcleos, 800 MHz, cargando un núcleo. <br><br>  Compare el tamaño del archivo: <br><div class="scrollable-table"><table><tbody><tr><td>  simu.vcd </td><td>  807,7 MB </td></tr><tr><td>  simu.wlf (conversión creada en Verilator) </td><td>  41 MB </td></tr><tr><td>  simu.wlf (creado en modelsim) </td><td>  9.3 MB </td></tr><tr><td>  simu.lxt </td><td>  128 MB </td></tr><tr><td>  simu.lxt2 </td><td>  162 MB </td></tr></tbody></table></div><br>  Aquí el verificador pierde, pero puede experimentar creando formas de onda y trazar profundidad, el período de grabación (el comienzo y el final de la grabación de forma de onda se pueden cambiar).  Con qué archivo trabajar depende de usted. <br><br>  Durante las pruebas, además del tiempo de la simulación en sí, se encontró una discrepancia en la lectura de los datos de entrada del bus.  Si los datos del bus en el bus cambian durante el frente clk, Modelsim lee los datos después del frente, verificador antes: <br><br><pre> <code class="cpp hljs">input clk; input [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] in; reg [<span class="hljs-number"><span class="hljs-number">7</span></span>:<span class="hljs-number"><span class="hljs-number">0</span></span>] in_last_ ; ... always @(posedge clk) begin ... in_last_ &lt;= in; ... end</code> </pre><br><img src="https://habrastorage.org/webt/nc/ky/9r/ncky9rwjfvckf6hetlogg-futqa.png" alt="imagen"><br><br>  Durante las pruebas, este punto debe tenerse en cuenta, ya que parte del entorno de prueba para diferentes simuladores funcionará de manera diferente. <br><br>  Además, el verificador no tiene en cuenta el estado "x" de la señal y traduce todo a "0"; <br><br><h2>  BANCO DE PRUEBA UVM </h2><br>  Considere el entorno de prueba, la carpeta tb / uvm. <br><br>  El banco de pruebas UVM es el entorno sobre el dispositivo.  En este ejemplo, el dispositivo es un controlador PWM.  Diagrama del entorno UVM: <br><br><img src="https://habrastorage.org/webt/94/tp/ox/94tpox5qii7r4qqaaakc_fbqrd4.png" alt="imagen"><br><br>  Como puede ver en el diagrama, UVM consiste en bloques (clases).  Cada bloque realiza sus funciones.  El ejemplo muestra uno de los posibles diseños del entorno de prueba.  El nombre y la funcionalidad de cada clase corresponde a la clase de la que se hereda.  Consideremos cada clase con más detalle. <br><br>  Archivo de entorno env.h o env.svh.  Esta es una clase que puede contener una o más clases de agente, en las que se conectan tres clases: secuenciador, controlador, monitor.  No hay agente en el ejemplo, pero su función se implementa en la clase env.  Para la prueba necesitamos escribir alguna secuencia de acciones: secuenciación. <br><br>  Pasemos al código de inicio de secuenciación: <br><br><pre> <code class="cpp hljs">sequence_[n]-&gt;start(sqr, <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>);</code> </pre> <br>  Secuenciador (secuenciador) - archivo sequncer.h.  En el sistema verilog, resultó utilizar el secuenciador predeterminado.  Una clase que contiene una o más secuencias (secuencia) (archivos secuencia_a.h, secuencia_a.svh).  Cada secuencia es una cadena de acciones.  Una de estas acciones puede ser enviar una transacción.  Transacción: transferir datos de una clase a otra.  La clase en la que se describen las transacciones es bus_trans.  A continuación se muestra una descripción de dos clases, cada una de las cuales ideológicamente tiene sus propias funciones específicas: controlador y monitor. <br><br>  Controlador: archivo drv.h, drv.svh.  Una clase que recibe transacciones de un secuenciador y las traduce en señales.  El conductor sirve como asistente de secuenciador en un nivel inferior.  Considere enviar un paquete. <br><br>  La secuencia abre una ventana de transacción, el controlador detecta este evento y comienza a recibir datos.  La secuencia está esperando una respuesta del conductor.  El controlador simula las señales para el dispositivo, luego le indica al secuenciador que la ventana se puede cerrar.  La idea es que el secuenciador funcione a un nivel alto y el controlador a un nivel inferior. <br><br>  Las señales se conectan a través del bus de interfaz al dispositivo.  La interfaz se describe en los archivos vip_if.h, vip_if.svh. <br><br>  A continuación, debe verificar si las señales de salida coinciden con las esperadas.  Hay dos soluciones: <br><br><ul><li>  Escribir un modelo para un dispositivo </li><li>  Verificación de señal a través del agente UVM </li></ul><br>  En el ejemplo, se considera la segunda opción.  Para probar el dispositivo a nivel funcional, es necesario comparar la salida con la esperada.  El requisito para el dispositivo era la corrección del ciclo de trabajo dado de la señal y el período de la señal.  Para monitorear las señales de salida, se escribe una nueva clase: Monitor (archivo monitor.h, monitor.svh).  Por lo general, en un entorno de prueba, el monitor transfiere las señales en la transacción (a un nivel superior) y se envía a la clase de comparación: cuadro de indicadores. <br><br>  En este ejemplo, las señales se verifican de inmediato.  En caso de discrepancia entre el valor esperado y el medido, la prueba se detiene. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/459338/">https://habr.com/ru/post/459338/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../459326/index.html">Autoescalado y gestión de recursos en Kubernetes (revisión e informe de video)</a></li>
<li><a href="../459328/index.html">La mejor relación calidad-precio - Mpow A5 (059)</a></li>
<li><a href="../459330/index.html">Bitrix para programador y gerente: amor y odio</a></li>
<li><a href="../459334/index.html">YouTrack 2019.2: un banner de todo el sistema, mejoras en la página de lista de tareas, nuevas opciones de búsqueda y más</a></li>
<li><a href="../459336/index.html">Vive y aprende. Parte 1. Orientación escolar y profesional</a></li>
<li><a href="../459340/index.html">Organizar un proyecto de ML con Ocean</a></li>
<li><a href="../459342/index.html">Caché remoto para iOS, alternancia de funciones, temas oscuros y una carrera de desarrollador: informe con Avito iOS Meetup # 7</a></li>
<li><a href="../459344/index.html">Métricas de DevOps: dónde obtener datos para los cálculos</a></li>
<li><a href="../459346/index.html">La vuelta al mundo con un libro electrónico: ONYX BOOX James Cook 2 Review</a></li>
<li><a href="../459348/index.html">Otro bypass de autenticación en redes wifi públicas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>