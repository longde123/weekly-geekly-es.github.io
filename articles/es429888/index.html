<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>游눩游낖 游띗 游뱡游낗 Calculadora basada en pila en la placa FPGA Cyclone IV 游꿘 游꼝 游꼯</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Introduccion 
 Como estudiantes de primer a침o de la Universidad de Innopolis, tuvimos la oportunidad de hacer nuestro propio proyecto en arquitectura ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Calculadora basada en pila en la placa FPGA Cyclone IV</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/429888/"><h2>  Introduccion </h2><br>  Como estudiantes de primer a침o de la Universidad de Innopolis, tuvimos la oportunidad de hacer nuestro propio proyecto en arquitectura de computadoras.  University nos sugiri칩 varios proyectos y hemos optado por hacer una calculadora basada en pila con notaci칩n de pulido inverso.  Uno de los requisitos para el proyecto es utilizar el tablero FPGA provisto por la universidad. <br><br><img src="https://habrastorage.org/webt/c2/qu/2i/c2qu2ixnazu7mac6eghy6bka4j0.jpeg"><br><br>  Como nuestra junta, hemos elegido Cyclon IV.  Por lo tanto, tuvimos que escribir c칩digo en el lenguaje de descripci칩n de hardware.  En el curso hemos estudiado Verilog, por lo que lo hemos elegido.  Adem치s, la universidad tiene m칩dulos adicionales para FPGA, como el teclado num칠rico, por lo que decidimos usarlo en nuestro proyecto. <br><br>  En este art칤culo, queremos compartir nuestro conocimiento sobre FPGA y Verilog, tambi칠n le ofrecemos un tutorial para repetir nuestro proyecto. <br><a name="habracut"></a><br><h2>  Dise침o b치sico </h2><br>  Formamos un grupo de dos personas y organizamos nuestra primera reuni칩n.  All칤 hemos discutido el dise침o b치sico, dividido nuestras responsabilidades y hemos hecho un plan corto con plazos.  Esto es lo que se nos ocurre.  Necesitamos: <br><br><ul><li>  Implementar pila en el Verilog </li><li>  Aprende a trabajar con el teclado num칠rico </li><li>  Implemente la salida a trav칠s de la pantalla de 8 segmentos ubicada en la placa FPGA </li><li>  Haga un m칩dulo principal que conecte todos los m칩dulos juntos </li></ul><br><img src="https://habrastorage.org/webt/oj/iq/cy/ojiqcysqck8cqbhyx73hcdh1hwo.png"><br><br>  Cada miembro del equipo ha elegido un m칩dulo para escribir.  La tarea de primer orden fue implementar pila, salida y entrada.  Como se determin칩, hemos comenzado a trabajar. <br><br><h2>  Pila </h2><br>  En la pila, almacenamos todos nuestros operandos.  Para almacenarlos, dedicamos 32 palabras de memoria. <br><br><div class="spoiler">  <b class="spoiler_title">C칩digo de m칩dulo de pila</b> <div class="spoiler_text"><pre><code class="plaintext hljs">module stack( //Just 50 MHz clock input clock, //Reset signal input reset, //PUSH operation control signal input push, //POP operation control signal input pop, //SWAP operation control signal input swap, //UPDATE operation control signal input write, //Value to write input [31:0] value, //Top element output [31:0] top, //Second element from stack top output [31:0] next, //Total elements count output [5:0] count, //Stack overflow error output error ); //Stack memory for 32 words reg [31:0] memory [0:31]; //Stack pointer on top element, indexing from 0 reg [5:0] pointer = 0; //First element by default is 0 initial memory[0] = 0; //Top stack element assign top = memory[pointer]; //Second element if such exists, 0 otherwise assign next = pointer == 0 ? 0 : memory[pointer - 1]; //Stack elements count assign count = pointer[4:0] + 1; //Stack overflow signal assign error = pointer[5]; always @(posedge clock) begin //Reseting if (reset) begin memory[0] &lt;= 0; pointer &lt;= 0; end //Remove one element form stack if (pop) pointer &lt;= pointer - 1; //Swaps top and next elements if (swap) begin memory[pointer] &lt;= memory[pointer - 1]; memory[pointer - 1] &lt;= memory[pointer]; end //Update top element if (write) memory[pointer - pop] &lt;= value; //Push new zero element on top if (push) begin pointer &lt;= pointer + 1; //Here pointer is still not updated, so +1 memory[pointer + 1] &lt;= 0; end end endmodule</code> </pre> <br></div></div><br>  Es solo una pila normal.  Si se introduce un nuevo valor, solo aumenta el puntero y coloca este valor en la parte superior de la pila.  Si un valor sale de la pila, disminuye el puntero y actualiza el elemento superior. <br><br><img src="https://habrastorage.org/webt/78/ld/r1/78ldr1cqr4k5oa8-si_25tpxy5o.png"><br><br>  Para mayor comodidad, agregamos un bot칩n de reinicio para tener la oportunidad de reiniciar nuestro programa durante la ejecuci칩n.  Adem치s, para la depuraci칩n se agreg칩 la oportunidad de detectar el error de desbordamiento de la pila. <br><br><h2>  Display </h2><br>  En este m칩dulo, implementamos toda la funcionalidad de la pantalla.  Es capaz de mostrar din치micamente los resultados de nuestros c치lculos y tambi칠n los valores de entrada. <br><br><img src="https://habrastorage.org/webt/2a/br/rl/2abrrlowazjts_uygpqxcyrrlno.png"><br><br><div class="spoiler">  <b class="spoiler_title">Aqu칤 est치 el c칩digo para la pantalla</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module display_bcd ( //Just 50 MHz clock input clock, //Switching hexademical and decimal representations input show_in_hex, //Asserted if something is going wrong, displaing error message input error, //Value to be displayed in binary format input [31:0] value, //Segments of display output [7:0] control, //LEDs of one segment output [7:0] leds ); // ###0### // # # // # # // 5 1 // # # // # # // ###6### // # # // # # // 4 2 // # # ### // # # #7# // ###3### ### //All representation of used symbols parameter D_0 = 8'b00111111; parameter D_1 = 8'b00000110; parameter D_2 = 8'b01011011; parameter D_3 = 8'b01001111; parameter D_4 = 8'b01100110; parameter D_5 = 8'b01101101; parameter D_6 = 8'b01111101; parameter D_7 = 8'b00000111; parameter D_8 = 8'b01111111; parameter D_9 = 8'b01101111; parameter D_DOT = 8'b10000000; parameter D_A = 8'b01110111; parameter D_B = 8'b01111100; parameter D_C = 8'b01011000; parameter D_D = 8'b01011110; parameter D_E = 8'b01111001; parameter D_F = 8'b01110001; parameter D_R = 8'b01010000; parameter D_O = 8'b01011100; parameter D_MINUS = 8'b01000000; parameter D_EMPTY = 8'b00000000; parameter D_E_CODE = 14; parameter D_R_CODE = 16; parameter D_O_CODE = 17; parameter D_MINUS_CODE = 18; parameter D_EMPTY_CODE = 31; //Delay counter, delaying 8192 clock cycles ~ 0.16 ms reg [12:0] counter = 0; //Saved Binary-Coded Decimal reg [31:0] r_bcd; //Number of segment that is active on current iteration reg [2:0] ctrl = 0; //Current digit shown on the current segment reg [4:0] digit; //Asserted for 1 cycle when conversion to Binary-Coded Decimal is done wire converted; //Intermediate Binary-Coded decimal value wire [31:0] bcd; //Decoded number digits wire [31:0] digits; //Number sign wire sign; //Digits from unsigned numbers wire [31:0] unsigned_number; bcd_convert #(32, 8) bcd_convert( .i_Clock(clock), .i_Binary(unsigned_number), .i_Start(1'b1), .o_BCD(bcd), .o_DV(converted)); //Get number sign assign sign = value[31]; //Get unsigned number assign unsigned_number = sign ? -value : value; //Switching final number representation assign digits = show_in_hex ? unsigned_number : r_bcd; //Constolling segments assign control = ~(1 &lt;&lt; ctrl); reg [7:0] r_leds; //Controlling LEDs assign leds = ~r_leds; always @(posedge clock) begin case (digit) 0: r_leds &lt;= D_0; 1: r_leds &lt;= D_1; 2: r_leds &lt;= D_2; 3: r_leds &lt;= D_3; 4: r_leds &lt;= D_4; 5: r_leds &lt;= D_5; 6: r_leds &lt;= D_6; 7: r_leds &lt;= D_7; 8: r_leds &lt;= D_8; 9: r_leds &lt;= D_9; 10: r_leds &lt;= D_A; 11: r_leds &lt;= D_B; 12: r_leds &lt;= D_C; 13: r_leds &lt;= D_D; 14: r_leds &lt;= D_E; 15: r_leds &lt;= D_F; 16: r_leds &lt;= D_R; 17: r_leds &lt;= D_O; 18: r_leds &lt;= D_MINUS; default: r_leds &lt;= D_EMPTY; endcase if (error) //Display error message case(ctrl) 0: digit &lt;= D_R_CODE; 1: digit &lt;= D_O_CODE; 2: digit &lt;= D_R_CODE; 3: digit &lt;= D_R_CODE; 4: digit &lt;= D_E_CODE; 5: digit &lt;= D_EMPTY_CODE; 6: digit &lt;= D_EMPTY_CODE; 7: digit &lt;= D_EMPTY_CODE; endcase else //Select current digit case(ctrl) 0: digit &lt;= digits[3:0]; 1: digit &lt;= digits[31:4] ? digits[7:4] : D_EMPTY_CODE; 2: digit &lt;= digits[31:8] ? digits[11:8] : D_EMPTY_CODE; 3: digit &lt;= digits[31:12] ? digits[15:12] : D_EMPTY_CODE; 4: digit &lt;= digits[31:16] ? digits[19:16] : D_EMPTY_CODE; 5: digit &lt;= digits[31:20] ? digits[23:20] : D_EMPTY_CODE; 6: digit &lt;= digits[31:24] ? digits[27:24] : D_EMPTY_CODE; 7: digit &lt;= sign ? D_MINUS_CODE : (digits[31:28] ? digits[31:28] : D_EMPTY_CODE); endcase //Increase current delay counter &lt;= counter + 1; //Delay is done, increase segment number if (counter == 13'b1000000000000) ctrl &lt;= ctrl + 1; //Save converted Binary-Coded Decimal if (converted) r_bcd &lt;= bcd; end endmodule</code> </pre><br></div></div><br>  El cicl칩n IV tiene ocho pantallas de ocho segmentos.  Est치n controlados por 16 pines.  Ocho pines controlan segmentos en cada pantalla (llam칠moslo led) y otros ocho pines controlan qu칠 pantalla estar치 activa (solo ll치melo control).  Por ejemplo, si necesitamos mostrar el d칤gito 5 en la tercera pantalla, el control deber칤a ser 00000100 y el led deber칤a ser 01101101 (de acuerdo con el esquema en el c칩digo).  Para mostrar varios d칤gitos diferentes en diferentes pantallas, necesitamos iluminar peri칩dicamente cada pantalla.  Entonces, cada 8192 ciclos de reloj, nos movemos l칩gicamente a la izquierda en 1 bit nuestra salida de control, que inicialmente es igual a 00000001. Cuando lo movemos, cambiamos el n칰mero que se mostrar치 actualmente.  Sucede tan r치pido que nuestro ojo no puede ver los cambios, por lo tanto, podemos mostrar diferentes d칤gitos en cada pantalla. <br><br><img src="https://habrastorage.org/webt/ig/kj/7r/igkj7rrnyqmnsbhlovybm1nilmq.png"><br><br>  A medida que pasamos al n칰mero binario de este m칩dulo, debemos representarlo de alguna manera como d칤gitos separados.  Para este prop칩sito, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">encontramos</a> un m칩dulo que lo hace, usando un algoritmo de doble oscilaci칩n.  Toma como entrada nuestro n칰mero binario y lo devuelve como un decimal codificado en binario (4 bits por d칤gito). <br><br><div class="spoiler">  <b class="spoiler_title">Aqu칤 est치 el c칩digo para ello.</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module bcd_convert #(parameter INPUT_WIDTH, parameter DECIMAL_DIGITS) ( input i_Clock, input [INPUT_WIDTH-1:0] i_Binary, input i_Start, // output [DECIMAL_DIGITS*4-1:0] o_BCD, output o_DV ); parameter s_IDLE = 3'b000; parameter s_SHIFT = 3'b001; parameter s_CHECK_SHIFT_INDEX = 3'b010; parameter s_ADD = 3'b011; parameter s_CHECK_DIGIT_INDEX = 3'b100; parameter s_BCD_DONE = 3'b101; reg [2:0] r_SM_Main = s_IDLE; // The vector that contains the output BCD reg [DECIMAL_DIGITS*4-1:0] r_BCD = 0; // The vector that contains the input binary value being shifted. reg [INPUT_WIDTH-1:0] r_Binary = 0; // Keeps track of which Decimal Digit we are indexing reg [DECIMAL_DIGITS-1:0] r_Digit_Index = 0; // Keeps track of which loop iteration we are on. // Number of loops performed = INPUT_WIDTH reg [7:0] r_Loop_Count = 0; wire [3:0] w_BCD_Digit; reg r_DV = 1'b0; always @(posedge i_Clock) begin case (r_SM_Main) // Stay in this state until i_Start comes along s_IDLE : begin r_DV &lt;= 1'b0; if (i_Start == 1'b1) begin r_Binary &lt;= i_Binary; r_SM_Main &lt;= s_SHIFT; r_BCD &lt;= 0; end else r_SM_Main &lt;= s_IDLE; end // Always shift the BCD Vector until we have shifted all bits through // Shift the most significant bit of r_Binary into r_BCD lowest bit. s_SHIFT : begin r_BCD &lt;= r_BCD &lt;&lt; 1; r_BCD[0] &lt;= r_Binary[INPUT_WIDTH-1]; r_Binary &lt;= r_Binary &lt;&lt; 1; r_SM_Main &lt;= s_CHECK_SHIFT_INDEX; end // Check if we are done with shifting in r_Binary vector s_CHECK_SHIFT_INDEX : begin if (r_Loop_Count == INPUT_WIDTH-1) begin r_Loop_Count &lt;= 0; r_SM_Main &lt;= s_BCD_DONE; end else begin r_Loop_Count &lt;= r_Loop_Count + 1; r_SM_Main &lt;= s_ADD; end end // Break down each BCD Digit individually. Check them one-by-one to // see if they are greater than 4. If they are, increment by 3. // Put the result back into r_BCD Vector. s_ADD : begin if (w_BCD_Digit &gt; 4) begin r_BCD[(r_Digit_Index*4)+:4] &lt;= w_BCD_Digit + 3; end r_SM_Main &lt;= s_CHECK_DIGIT_INDEX; end // Check if we are done incrementing all of the BCD Digits s_CHECK_DIGIT_INDEX : begin if (r_Digit_Index == DECIMAL_DIGITS-1) begin r_Digit_Index &lt;= 0; r_SM_Main &lt;= s_SHIFT; end else begin r_Digit_Index &lt;= r_Digit_Index + 1; r_SM_Main &lt;= s_ADD; end end s_BCD_DONE : begin r_DV &lt;= 1'b1; r_SM_Main &lt;= s_IDLE; end default : r_SM_Main &lt;= s_IDLE; endcase end // always @ (posedge i_Clock) assign w_BCD_Digit = r_BCD[r_Digit_Index*4 +: 4]; assign o_BCD = r_BCD; assign o_DV = r_DV; endmodule // Binary_to_BCD</code> </pre> <br></div></div><br>  Este m칩dulo funciona con un algoritmo muy interesante.  Desplaza todos los bits del n칰mero a la izquierda uno por uno y, si los primeros 4 bits son mayores que 4 en decimal, les agrega el decimal 3. <br><br><img src="https://habrastorage.org/webt/hu/so/xu/husoxuhrlym4_ug5oydgc6dxvhs.png"><br><br><h2>  Teclado num칠rico </h2><br>  Este m칩dulo funciona con el teclado num칠rico.  Lee el valor del teclado num칠rico y lo pasa al m칩dulo principal.  Tenemos dos estados del teclado.  Se pueden cambiar presionando uno de los botones en el fpga. <br><br>  El teclado principal se ve as칤: <br><br><img src="https://habrastorage.org/webt/wa/js/7g/wajs7gjogc7lsvrgraritwe1sdq.png"><br><br>  Y la alternativa as칤: <br><br><img src="https://habrastorage.org/webt/js/yv/rx/jsyvrx09ssqm7-sorcbrglxovj4.png"><br><br><div class="spoiler">  <b class="spoiler_title">El c칩digo del teclado num칠rico</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module numpad ( //Just 50 MHz clock input clock, //Alternative keyboard input alt_key, //Alternative keyboard indicator output alt_led, //Numpad rows input [3:0] rows, //Numpad columns output [3:0] columns, //State change description [5:5] - is_changed, [4:4] - keyboard, [3:0] - button output [5:0] value ); // col 0 col 1 col 2 col 3 // // ############################# // # # # # # // # 1(0) # 2(4) # 3(8) # A(12)# row 0 // # # # # # // ############################# // # # # # # // # 4(1) # 5(5) # 6(9) # B(13)# row 1 // # # # # # // ############################# // # # # # # // # 7(2) # 8(6) # 9(10)# C(14)# row 2 // # # # # # // ############################# // # # # # # // # 0(3) # F(7) # E(11)# D(15)# row 3 // # # # # # // ############################# parameter BTN_EMPTY = 6'b000000; //Previous pressed button reg [5:0] prev = 0; //Current pressed button reg [5:0] cur = 0; //Current column number reg [1:0] col = 0; //Counter for delay reg [8:0] counter = 0; //Rows pressed flags reg [3:0] pressed = 0; //Is alternative keyboard reg is_alt = 0; //Alt key on prev clock cycle reg prev_alt_key = 0; //Controlling column assign columns = ~(1 &lt;&lt; col); assign alt_led = ~is_alt; always @(posedge clock) begin //Increase counter counter &lt;= counter + 1; //Evaluating alternative keyboard signal if (value != BTN_EMPTY) is_alt &lt;= 0; else is_alt &lt;= (alt_key == 1 &amp;&amp; prev_alt_key == 0) ? ~is_alt : is_alt; prev_alt_key &lt;= alt_key; if (counter == 9'b1111111111) begin //Evaluating current button case(~rows) 4'b0001: begin pressed[col] &lt;= 1; cur &lt;= {1'b1, ~is_alt, col, 2'b00}; end 4'b0010: begin pressed[col] &lt;= 1; cur &lt;= {1'b1, ~is_alt, col, 2'b01}; end 4'b0100: begin pressed[col] &lt;= 1; cur &lt;= {1'b1, ~is_alt, col, 2'b10}; end 4'b1000: begin pressed[col] &lt;= 1; cur &lt;= {1'b1, ~is_alt, col, 2'b11}; end default: begin pressed[col] &lt;= 0; cur &lt;= pressed ? cur : BTN_EMPTY; end endcase end //increase column number when counter is 9'011111111, using different edges of counter[8] to let counter pass through zero, to assert wire value if need if (counter == 9'b011111111) begin //Saving previous button every 4 iterations if (&amp;col) prev &lt;= cur; col &lt;= col + 1; end end //Evaluating state change //Comparing current and previous states without keyboard bit assign value = (counter == 9'b000000000 &amp;&amp; col == 2'b11 &amp;&amp; {prev[5], prev[3:0]} != {cur[5], cur[3:0]}) ? cur : BTN_EMPTY; endmodule</code> </pre><br></div></div><br>  Entonces, el teclado num칠rico es un esquema que contiene 16 botones (4 filas y 4 columnas).  Para obtener el n칰mero del bot칩n que se presion칩, necesitamos 4 salidas (sean columnas) y 4 entradas (filas).  Pasamos el voltaje a cada columna peri칩dicamente y si se presiona el bot칩n, el circuito se cierra y cierta fila se vuelve verdadera como entrada.  La combinaci칩n del n칰mero de la columna y el n칰mero de la fila determina de forma exclusiva nuestro bot칩n. <br><br><img src="https://habrastorage.org/webt/9u/oq/i8/9uoqi8mnzmhqqfff2w3-4vd5kra.png"><br><br>  Si usamos el teclado principal en el ejemplo anterior, obtendremos el n칰mero 5 como entrada. <br><br><h2>  M칩dulo principal </h2><br>  El m칩dulo principal conecta todas las partes y realmente hace c치lculos. <br><br><div class="spoiler">  <b class="spoiler_title">El m칩dulo principal aqu칤</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">module main( //Just 50 MHz clock input clock, //Reset signal input reset, //Representation switch input show_in_hex, //Show stack elements count switch input show_count, //Button, switches to operations keyboard input alt_numpad_key, //Alternative keyboard indicator output alt_numpad_led, //Numpad rows and columns input [3:0] numpad_rows, output [3:0] numpad_columns, //Display and display control output [7:0] display_leds, output [7:0] display_control ); // 1 2 3 C // 4 5 6 PUSH // 7 8 9 POP // 0 +- CE SWAP parameter BTN_0 = 6'b110011; parameter BTN_1 = 6'b110000; parameter BTN_2 = 6'b110100; parameter BTN_3 = 6'b111000; parameter BTN_4 = 6'b110001; parameter BTN_5 = 6'b110101; parameter BTN_6 = 6'b111001; parameter BTN_7 = 6'b110010; parameter BTN_8 = 6'b110110; parameter BTN_9 = 6'b111010; parameter BTN_CLEAR_DIGIT = 6'b111100; parameter BTN_PUSH = 6'b111101; parameter BTN_POP = 6'b111110; parameter BTN_SWAP = 6'b111111; parameter BTN_CLEAR_NUMBER = 6'b111011; parameter BTN_UNARY_MINUS = 6'b110111; // + - * / // sqr cbe inc dec parameter BTN_ADDITION = 6'b100000; parameter BTN_SUBTRACTION = 6'b100100; parameter BTN_MULTIPLICATION = 6'b101000; parameter BTN_DIVISION = 6'b101100; parameter BTN_SQUARE = 6'b100001; parameter BTN_CUBE = 6'b100101; parameter BTN_INCREMENT = 6'b101001; parameter BTN_DECREMENT = 6'b101101; //Numpad state wire [5:0] pressed; //Stack elements count wire [5:0] count; //First and second stack elements wire [31:0] top, next; wire stack_error; //Evaluated new value reg [31:0] new_value; //Stack control signals reg write, push, pop, swap; reg arithmetic_error = 0; numpad numpad( .clock (clock), .alt_key (~alt_numpad_key), .alt_led (alt_numpad_led), .rows (numpad_rows), .columns (numpad_columns), .value (pressed) ); stack stack( .clock (clock), .reset (~reset), .push (push), .pop (pop), .swap (swap), .write (write), .value (new_value), .top (top), .next (next), .count (count), .error (stack_error) ); display_bcd display( .clock (clock), .error (stack_error || arithmetic_error), .show_in_hex (show_in_hex), .value (show_count ? count : top), .control (display_control), .leds (display_leds) ); // Division result wire [31:0] res; assign res = ((next[31] ? -next : next) / (top[31] ? -top : top)); always @(posedge clock) begin //Reseting arithmetic error if (~reset) arithmetic_error &lt;= 0; case (pressed) BTN_0: begin write &lt;= 1; new_value &lt;= top * 10; end BTN_1: begin write &lt;= 1; new_value &lt;= top * 10 + (top[31] ? -1 : 1); end BTN_2: begin write &lt;= 1; new_value &lt;= top * 10 + (top[31] ? -2 : 2); end BTN_3: begin write &lt;= 1; new_value &lt;= top * 10 + (top[31] ? -3 : 3); end BTN_4: begin write &lt;= 1; new_value &lt;= top * 10 + (top[31] ? -4 : 4); end BTN_5: begin write &lt;= 1; new_value &lt;= top * 10 + (top[31] ? -5 : 5); end BTN_6: begin write &lt;= 1; new_value &lt;= top * 10 + (top[31] ? -6 : 6); end BTN_7: begin write &lt;= 1; new_value &lt;= top * 10 + (top[31] ? -7 : 7); end BTN_8: begin write &lt;= 1; new_value &lt;= top * 10 + (top[31] ? -8 : 8); end BTN_9: begin write &lt;= 1; new_value &lt;= top * 10 + (top[31] ? -9 : 9); end BTN_CLEAR_DIGIT: begin write &lt;= 1; new_value &lt;= top / 10; end BTN_CLEAR_NUMBER: begin write &lt;= 1; new_value &lt;= 0; end BTN_PUSH: begin push &lt;= 1; end BTN_POP: begin pop &lt;= 1; end BTN_SWAP: begin swap &lt;= 1; end BTN_UNARY_MINUS: begin write &lt;= 1; new_value &lt;= -top; end BTN_ADDITION: begin pop &lt;= 1; write &lt;= 1; new_value &lt;= next + top; end BTN_SUBTRACTION: begin pop &lt;= 1; write &lt;= 1; new_value &lt;= next - top; end BTN_MULTIPLICATION: begin pop &lt;= 1; write &lt;= 1; new_value &lt;= next * top; end BTN_DIVISION: begin pop &lt;= 1; write &lt;= 1; new_value &lt;= (next[31] ^ top[31] ? -res : res); arithmetic_error &lt;= ~(|top); end BTN_SQUARE: begin write &lt;= 1; new_value &lt;= top * top; end BTN_CUBE: begin write &lt;= 1; new_value &lt;= top * top * top; end BTN_INCREMENT: begin write &lt;= 1; new_value &lt;= top + 1; end BTN_DECREMENT: begin write &lt;= 1; new_value &lt;= top - 1; end default: // Nothing usefull is pressed begin write &lt;= 0; push &lt;= 0; pop &lt;= 0; swap &lt;= 0; end endcase end endmodule</code> </pre> <br></div></div><br>  El bloque "siempre" contiene una declaraci칩n de caso que elige la operaci칩n seg칰n el bot칩n del teclado num칠rico que se presiona.  Si un bot칩n con el d칤gito presionado, este d칤gito va a la parte superior de la pila.  Si necesitamos ingresar el n칰mero que tiene m치s de un d칤gito, entonces el n칰mero superior en la pila se multiplica por 10 y este valor multiplicado va a la parte superior de la pila.  Si se presiona el bot칩n con una operaci칩n, esta operaci칩n se aplica a los primeros dos n칰meros en la pila. <br><br><img src="https://habrastorage.org/webt/95/kg/d0/95kgd0wwrkcwswl6m7cnpdu8xui.png"><br><br>  Durante las pruebas, encontramos algo interesante sobre la divisi칩n en Verilog.  Por alguna extra침a raz칩n, si intentamos dividir dos n칰meros negativos, la operaci칩n producir치 un cero como resultado.  Entonces, para solucionarlo, tuvimos que agregar una rama para procesar este caso expl칤citamente. <br><br><h2>  Conclusi칩n </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Aqu칤</a> est치 el video, que demuestra el trabajo de la calculadora.  Adem치s, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu칤</a> est치 el github de nuestro proyecto. <br><br>  Estudiar Verilog aument칩 dr치sticamente nuestra comprensi칩n de la arquitectura de la computadora.  Adem치s, trabajar en equipo nos ha ayudado a desarrollar habilidades b치sicas para el trabajo en equipo. <br><br>  Autores: Fedoseev Kirill, Yuloskov Artem. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es429888/">https://habr.com/ru/post/es429888/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es429876/index.html">Los investigadores superaron a los bloqueadores de anuncios m치s potentes, se acerca la guerra de formatos</a></li>
<li><a href="../es429878/index.html">쯇or qu칠 con el crecimiento de la empresa, los desarrolladores que estaban a la vanguardia est치n "por la borda"</a></li>
<li><a href="../es429880/index.html">Pix4D: de fotos a medidas</a></li>
<li><a href="../es429882/index.html">Control de LED RGB a trav칠s de microcontroladores Cypress UDB PSoC</a></li>
<li><a href="../es429884/index.html">Conferencia PROSTOR 2018: preguntas y respuestas sobre el futuro del almacenamiento</a></li>
<li><a href="../es429890/index.html">Webinar abierto "Redes de confrontaci칩n generativas"</a></li>
<li><a href="../es429892/index.html">xonsh - python como reemplazo de shell</a></li>
<li><a href="../es429894/index.html">Usando un ojo de pez en una Raspberry Pi 3 con ROS - Parte 2</a></li>
<li><a href="../es429898/index.html">DMS (Sistema de gesti칩n de concesionarios): implementaci칩n de los ecosistemas de informaci칩n para la gesti칩n de redes de concesionarios</a></li>
<li><a href="../es429902/index.html">Page Rank en la era de la Web 2.0 - Parte 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>