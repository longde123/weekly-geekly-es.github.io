<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üêé üëì üà∑Ô∏è Seguran√ßa do DHCP no Windows 10: Explorando a vulnerabilidade cr√≠tica CVE-2019-0726 üë©üèΩ‚Äçüé® üêá üßëüèº‚Äçü§ù‚Äçüßëüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Imagem: Pexels 

 Com o lan√ßamento das atualiza√ß√µes de janeiro para o Windows, as not√≠cias da vulnerabilidade criticamente perigosa CVE-2019-0547 nos ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Seguran√ßa do DHCP no Windows 10: Explorando a vulnerabilidade cr√≠tica CVE-2019-0726</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pt/blog/448378/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/sw/gb/5n/swgb5nnwlka74q3klyp10gk-ofu.jpeg"></a> <br><br>  <i>Imagem: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Pexels</a></i> <br><br>  Com o lan√ßamento das atualiza√ß√µes de janeiro para o Windows, as not√≠cias da vulnerabilidade criticamente perigosa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CVE-2019-0547</a> nos clientes DHCP despertaram o p√∫blico.  A alta classifica√ß√£o CVSS e o fato de a Microsoft n√£o publicar imediatamente a avalia√ß√£o de desempenho, o que dificultava a decis√£o dos usu√°rios sobre uma atualiza√ß√£o urgente do sistema, despertou o interesse.  Algumas publica√ß√µes at√© sugeriram que a falta de um √≠ndice pode ser interpretada como evid√™ncia de que uma explora√ß√£o em funcionamento aparecer√° em um futuro pr√≥ximo. <a name="habracut"></a><br><br>  Solu√ß√µes como o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">MaxPatrol 8</a> podem identificar computadores na rede vulner√°veis ‚Äã‚Äãa ataques espec√≠ficos.  Outras solu√ß√µes, como o PT NAD, detectam esses ataques eles mesmos.  Para tornar isso poss√≠vel, √© necess√°rio descrever as regras para detectar vulnerabilidades em produtos e as regras para detectar ataques a esses produtos.  Por sua vez, para tornar isso poss√≠vel, √© necess√°rio que cada vulnerabilidade individual descubra o vetor, o m√©todo e as condi√ß√µes de sua opera√ß√£o, ou seja, literalmente todos os detalhes e nuances associados √† opera√ß√£o.  √â necess√°rio um entendimento muito mais completo e profundo do que o que geralmente pode ser compilado a partir de descri√ß√µes em sites de fornecedores ou no CVE, como: <br><br><blockquote>  A vulnerabilidade se manifesta porque o sistema operacional processa incorretamente objetos na mem√≥ria. </blockquote><br>  Portanto, para adicionar aos produtos da empresa as regras para detectar ataques a uma vulnerabilidade rec√©m-criada no DHCP, bem como as regras para identificar dispositivos afetados por ela, voc√™ deve entender os detalhes.  No caso de vulnerabilidades bin√°rias, o patch-diff √© frequentemente usado para obter informa√ß√µes sobre os erros subjacentes, ou seja, uma compara√ß√£o das altera√ß√µes feitas no c√≥digo bin√°rio de um aplicativo, biblioteca ou kernel do sistema operacional com um patch espec√≠fico, uma atualiza√ß√£o que corrige esse erro.  Mas o primeiro est√°gio √© sempre o reconhecimento. <br><br>  <b>Nota</b> : <i>Para ir diretamente para a descri√ß√£o da vulnerabilidade, ignorando os conceitos subjacentes do DHCP, voc√™ pode pular as primeiras p√°ginas e ir diretamente para a se√ß√£o "Fun√ß√£o DecodeDomainSearchListData".</i> <br><br><h2>  Reconhecimento </h2><br>  Voltamos ao mecanismo de pesquisa e visualizamos todos os detalhes de vulnerabilidade atualmente conhecidos.  Desta vez, h√° um m√≠nimo de detalhes e todos eles s√£o prociss√µes gratuitas das informa√ß√µes coletadas da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">publica√ß√£o original</a> no site do MSRC.  Essa situa√ß√£o √© bastante t√≠pica para erros descobertos pela Microsoft durante uma auditoria interna. <br><br>  Descobrimos pela publica√ß√£o que estamos diante de uma vulnerabilidade do tipo corrup√ß√£o de mem√≥ria contida nos sistemas cliente e servidor do Windows 10 vers√£o 1803 e que se manifesta no momento em que um invasor envia respostas especialmente criadas para um cliente DHCP.  Ap√≥s alguns dias a partir desse momento na p√°gina, os √≠ndices de desempenho tamb√©m aparecer√£o: <br><br><img src="https://habrastorage.org/webt/oi/kr/ha/oikrhaavmkrvqdgzpfxqp4oquiy.png"><br><br>  Como voc√™ pode ver, o MSRC classificou "2 - Explora√ß√£o como menos prov√°vel".  Isso significa que um erro com alta probabilidade ou n√£o √© operacional, ou a opera√ß√£o est√° repleta de tais dificuldades, cuja supera√ß√£o exigir√° custos trabalhistas muito altos.  √â certo que a Microsoft n√£o costuma subestimar essas estimativas.  Isso √© parcialmente influenciado pelo risco de perda de reputa√ß√£o e parcialmente por alguma independ√™ncia do centro de resposta dentro da empresa.  Portanto, suponha: como a amea√ßa de explora√ß√£o √© indicada no relat√≥rio como improv√°vel, certamente √©.  Na verdade, isso poderia ter conclu√≠do a an√°lise, mas n√£o seria sup√©rfluo verificar novamente e pelo menos descobrir qual era a vulnerabilidade.  Por fim, apesar de toda a personalidade ineg√°vel, os erros tendem a se repetir e a se manifestar em outros lugares. <br><br>  Na mesma p√°gina, baixamos o patch (atualiza√ß√£o de seguran√ßa) fornecido na forma de um arquivo .msu, descompacte-o e procure por arquivos provavelmente relacionados ao processamento de respostas DHCP no lado do cliente.  Recentemente, tornou-se muito mais dif√≠cil fazer isso, pois as atualiza√ß√µes come√ßaram a ser entregues n√£o na forma de pacotes separados que corrigem erros espec√≠ficos, mas como um √∫nico pacote cumulativo que inclui todas as corre√ß√µes mensais.  Isso aumentou bastante o excesso de ru√≠do, ou seja, altera√ß√µes n√£o relacionadas √† nossa tarefa. <br><br>  Entre todo o conjunto de arquivos, a pesquisa encontra v√°rias bibliotecas adequadas para o filtro, que comparamos com suas vers√µes em um sistema sem patch.  A biblioteca dhcpcore.dll parece a mais promissora.  Nesse caso, o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">BinDiff</a> produz altera√ß√µes m√≠nimas: <br><br> <a href=""><img src="https://habrastorage.org/webt/vr/ml/oe/vrmloeuvnuyeqib2f8rarowqnri.png"></a> <br><br>  Na verdade, al√©m das altera√ß√µes cosm√©ticas feitas em uma √∫nica fun√ß√£o - DecodeDomainSearchListData.  Se voc√™ conhece bem o protocolo DHCP e suas op√ß√µes que n√£o s√£o usadas com muita frequ√™ncia, j√° pode assumir que esta fun√ß√£o processa a lista.  Caso contr√°rio, passe para o segundo est√°gio - o estudo do protocolo. <br><br><h2>  DHCP e suas op√ß√µes </h2><br>  O DHCP ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RFC 2131</a> | <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">wiki</a> ) √© um protocolo extens√≠vel cujos recursos de reposi√ß√£o s√£o fornecidos pelo campo de op√ß√µes.  Cada op√ß√£o √© descrita por uma tag exclusiva (n√∫mero, identificador), o tamanho ocupado pelos dados contidos na op√ß√£o e os pr√≥prios dados.  Essa pr√°tica √© t√≠pica dos protocolos de rede e uma das op√ß√µes "implantadas" no protocolo √© a op√ß√£o de pesquisa de dom√≠nio descrita na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RFC 3397</a> .  Ele permite que o servidor DHCP defina as termina√ß√µes de nomes de dom√≠nio padr√£o nos clientes, que ser√£o usadas como sufixos DNS para a conex√£o configurada dessa maneira. <br><br>  Vamos, por exemplo, definir os seguintes finais de nome em nosso cliente: <br><br><pre><code class="bash hljs">.microsoft.com .wikipedia.org</code> </pre> <br><img src="https://habrastorage.org/webt/_a/7o/ag/_a7oag6njc0p-kdww7o32ggatxc.png"><br><br>  Em seguida, em qualquer tentativa de determinar o endere√ßo pelo nome de dom√≠nio, as consultas DNS substituir√£o os sufixos dessa lista at√© que uma exibi√ß√£o bem-sucedida seja encontrada.  Por exemplo, se o usu√°rio digitou ru na barra de endere√ßos do navegador, as consultas DNS ser√£o geradas primeiro para ru.microsoft.com e depois para ru.wikipedia.org: <br><br><img src="https://habrastorage.org/webt/qu/8v/kz/qu8vkzddg_pkqvt1o4dwstz2eho.png"><br><br>  De fato, os navegadores modernos s√£o muito inteligentes e, portanto, respondem aos redirecionamentos para o mecanismo de pesquisa para nomes que n√£o s√£o semelhantes ao FQDN.  Portanto, abaixo, apresentamos a conclus√£o de utilidades menos deterioradas: <br><br><img src="https://habrastorage.org/webt/ke/tq/f3/ketqf3pyckb-rp2en-dygbswtrq.png"><br><br>  Pode parecer ao leitor que essa √© a vulnerabilidade, porque a mera possibilidade de substituir sufixos DNS por um servidor DHCP, com o qual qualquer dispositivo da rede pode se identificar, representa uma amea√ßa para os clientes que solicitam par√¢metros de rede via DHCP .  Mas n√£o: como segue a RFC, isso √© considerado um comportamento documentado e bastante leg√≠timo.  Na verdade, o servidor DHCP √© inerentemente um daqueles componentes confi√°veis ‚Äã‚Äãque podem ter um forte impacto nos dispositivos que os acessam. <br><br><h2>  Op√ß√£o de pesquisa de dom√≠nio </h2><br>  A op√ß√£o de pesquisa de dom√≠nio tem o n√∫mero 0x77 (119).  Como todas as op√ß√µes, ele √© codificado com uma tag de byte √∫nico com o n√∫mero da op√ß√£o.  Como a maioria das outras op√ß√µes, imediatamente ap√≥s a tag h√° um tamanho de byte √∫nico dos dados ap√≥s o tamanho.  Inst√¢ncias de op√ß√£o podem estar presentes na mensagem DHCP mais de uma vez.  Nesse caso, os dados de todas essas se√ß√µes s√£o concatenados na sequ√™ncia em que aparecem na mensagem. <br><br><img src="https://habrastorage.org/webt/cp/dg/yz/cpdgyzwd_4zxdxiujznhojbfczk.png"><br><br>  No exemplo apresentado, extra√≠do da <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RFC 3397</a> , os dados s√£o divididos em tr√™s se√ß√µes, cada uma com 9 bytes.  Como voc√™ pode ver na figura, os nomes de subdom√≠nios no nome de dom√≠nio totalmente qualificado s√£o codificados com um comprimento de byte √∫nico, seguido imediatamente pelo pr√≥prio nome.  A codifica√ß√£o do nome de dom√≠nio totalmente qualificado termina com um byte nulo (ou seja, um nome de subdom√≠nio de tamanho nulo). <br><br>  Al√©m disso, a op√ß√£o usa o m√©todo mais simples de compacta√ß√£o de dados, ou melhor, apenas pontos de nova an√°lise.  Em vez do tamanho do nome do dom√≠nio, o campo pode conter o valor 0xc0.  O pr√≥ximo byte define o deslocamento em rela√ß√£o ao in√≠cio dos dados da op√ß√£o, que deve ser usado para procurar o final do nome do dom√≠nio. <br><br>  Assim, neste exemplo, uma lista de dois sufixos de dom√≠nio √© codificada: <br><br><pre> <code class="bash hljs">.eng.apple.com .marketing.apple.com</code> </pre><br><h2>  Fun√ß√£o DecodeDomainSearchListData </h2><br>  Portanto, a op√ß√£o de n√∫mero de DHCP 0x77 (119) permite que o servidor configure sufixos DNS nos clientes.  Mas n√£o em m√°quinas com sistemas operacionais Windows.  Os sistemas Microsoft tradicionalmente ignoraram essa op√ß√£o; portanto, historicamente, o final dos nomes DNS, se necess√°rio, era revertido pelas pol√≠ticas de grupo.  Isso continuou at√© recentemente, quando a pr√≥xima vers√£o do Windows 10, vers√£o 1803, adicionou processamento √† op√ß√£o de pesquisa de dom√≠nio.  A julgar pelo nome da fun√ß√£o no dhcpcore.dll, no qual as altera√ß√µes foram feitas, √© no manipulador adicionado que est√° o erro em quest√£o. <br><br>  Come√ßando a trabalhar.  Combinamos um pouco o c√≥digo e descobrimos o seguinte.  O procedimento DecodeDomainSearchListData, de acordo com o nome, decodifica os dados da op√ß√£o de pesquisa de dom√≠nio da mensagem recebida do servidor.  Na entrada, ele recebe uma matriz de dados compactada da maneira descrita no par√°grafo anterior e, na sa√≠da, gera uma sequ√™ncia terminada em nulo contendo uma lista de termina√ß√µes de nomes de dom√≠nio, separadas por v√≠rgulas.  Por exemplo, esta fun√ß√£o converte os dados do exemplo acima em uma sequ√™ncia: <br><br><pre> <code class="bash hljs"> eng.apple.com,marketing.apple.com</code> </pre> <br>  DecodeDomainSearchListData √© chamado no procedimento UpdateDomainSearchOption, que define a lista retornada para o valor "DhcpDomainSearchList" da chave do registro: <br> <code>HKLM\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\Interfaces\{INTERFACE_GUID}\</code> <br>  armazenando os principais par√¢metros de uma interface de rede espec√≠fica. <br><br><img src="https://habrastorage.org/webt/po/cq/zk/pocqzkd8ldtqb8ecrh_oyiajgba.png"><br><br>  A fun√ß√£o DecodeDomainSearchListData cumpre em duas passagens.  Na primeira passagem, ele executa todas as a√ß√µes, exceto a grava√ß√£o no buffer de sa√≠da.  Assim, a primeira passagem √© dedicada ao c√°lculo do tamanho da mem√≥ria necess√°ria para acomodar os dados retornados.  Na segunda passagem, a mem√≥ria j√° est√° alocada para esses dados e a mem√≥ria alocada √© preenchida.  A fun√ß√£o √© bastante pequena, com cerca de 250 instru√ß√µes, e sua principal tarefa √© processar cada uma das tr√™s op√ß√µes poss√≠veis para o caractere representado no fluxo de entrada: 1) 0x00, 2) 0xc0 ou 3) todos os outros valores.  A corre√ß√£o hipot√©tica do erro relacionado ao DHCP basicamente se resume em adicionar uma verifica√ß√£o do tamanho do buffer resultante no in√≠cio da segunda passagem.  Se esse tamanho for zero, a mem√≥ria n√£o ser√° alocada para o buffer e a fun√ß√£o imediatamente encerrar√° a execu√ß√£o e retornar√° um erro: <br><br><img src="https://habrastorage.org/webt/fn/ym/4g/fnym4gbsu66h64bn03lwrqttxlm.png"><br><br>  Acontece que a vulnerabilidade se manifesta nos casos em que o tamanho do buffer de destino √© zero.  Ao mesmo tempo, no in√≠cio da execu√ß√£o, a fun√ß√£o verifica os dados de entrada, cujo tamanho n√£o pode ser inferior a dois bytes.  Portanto, para a opera√ß√£o, √© necess√°rio selecionar uma op√ß√£o n√£o vazia de sufixos de dom√≠nio de forma que o tamanho do buffer de sa√≠da seja zero. <br><br><h2>  Opera√ß√£o </h2><br>  A primeira coisa que vem √† mente √© que voc√™ pode usar os pontos de nova an√°lise descritos anteriormente para que dados de entrada n√£o vazios gerem uma linha de sa√≠da vazia: <br><br><img src="https://habrastorage.org/webt/fz/px/vp/fzpxvpozmhgp7sbxoavng5hork8.png"><br><br>  Um servidor configurado para enviar uma op√ß√£o com esse conte√∫do na resposta realmente causar√° viola√ß√£o de acesso em clientes n√£o atualizados.  Isso acontece pelo seguinte motivo.  A cada etapa, quando a fun√ß√£o analisa parte do nome de dom√≠nio totalmente qualificado, ela a copia para o buffer de destino e coloca um ponto ap√≥s ele.  No exemplo do RFC, os dados ser√£o copiados para o buffer na seguinte ordem: <br><br><pre> <code class="bash hljs">1). eng. 2). eng.apple. 3). eng.apple.com.</code> </pre> <br>  Em seguida, quando o dom√≠nio contiver tamanho zero, a fun√ß√£o substituir√° o caractere anterior do buffer de destino por uma v√≠rgula: <br><br><pre> <code class="bash hljs">4). eng.apple.com,</code> </pre> <br>  e continua analisando: <br><br><pre> <code class="bash hljs">5). eng.apple.com,marketing. 6). eng.apple.com,marketing.apple. 7). eng.apple.com,marketing.apple.com. 8). eng.apple.com,marketing.apple.com,</code> </pre> <br>  No final da entrada, resta apenas substituir a √∫ltima v√≠rgula por um caractere zero e voc√™ prepara uma linha para gravar no registro: <br><br><pre> <code class="bash hljs">9). eng.apple.com,marketing.apple.com</code> </pre> <br>  O que acontece quando um invasor envia um buffer formado da maneira descrita?  Se voc√™ observar o exemplo, poder√° ver que a lista contida nele consiste em um elemento - uma sequ√™ncia vazia.  Na primeira passagem, a fun√ß√£o calcula o tamanho dos dados de sa√≠da.  Como os dados n√£o cont√™m um √∫nico nome de dom√≠nio diferente de zero, o tamanho √© zero. <br><br>  Na segunda passagem, um bloco de mem√≥ria din√¢mica √© alocado para colocar dados nele e copiar os dados em si.  Mas a fun√ß√£o de an√°lise encontra imediatamente um caractere nulo, significando o final do nome de dom√≠nio e, portanto, como foi dito, substitui o caractere anterior de um ponto para uma v√≠rgula.  E aqui estamos diante de um problema.  O iterador de buffer de destino est√° na posi√ß√£o zero.  N√£o existe um personagem anterior.  O caractere anterior pertence ao cabe√ßalho do bloco de mem√≥ria din√¢mica.  E esse mesmo caractere ser√° substitu√≠do por 0x2c, ou seja, por uma v√≠rgula. <br><br>  No entanto, isso acontece apenas em sistemas de 32 bits.  O uso de unsigned int para armazenar a posi√ß√£o atual do iterador de buffer de destino introduz ajustes no processamento em sistemas x64.  Vamos prestar mais aten√ß√£o ao trecho de c√≥digo respons√°vel por escrever uma v√≠rgula no buffer: <br><br><img src="https://habrastorage.org/webt/cv/wr/da/cvwrdacd4nzbpec5skyyqubd5sg.png"><br><br>  A unidade √© subtra√≠da da posi√ß√£o atual usando o registro eax de 32 bits, enquanto ao endere√ßar o buffer, o c√≥digo acessa o registro rax completo de 64 bits.  Na arquitetura AMD64, qualquer opera√ß√£o com registradores de 32 bits anula a parte superior do registrador.  Isso significa que no registro rax, que anteriormente continha zero, ap√≥s a subtra√ß√£o, n√£o o valor ‚Äì1, mas 0xffffffff ser√° armazenado.  Portanto, em sistemas de 64 bits, o valor 0x2c ser√° gravado no endere√ßo buf [0xffffffff], ou seja, muito al√©m dos limites da mem√≥ria alocada para o buffer. <br><br>  Os dados obtidos est√£o de acordo com a avalia√ß√£o de desempenho da Microsoft, pois, para explorar essa vulnerabilidade, um invasor precisa aprender a executar remotamente a pulveriza√ß√£o de heap em um cliente DHCP e, ao mesmo tempo, ter controle suficiente sobre a aloca√ß√£o de mem√≥ria din√¢mica para registrar valores predefinidos, como v√≠rgula e zero byte, produzido no endere√ßo preparado e levou a consequ√™ncias negativas controladas.  Caso contr√°rio, a grava√ß√£o de dados em um endere√ßo n√£o verificado resultar√° em uma queda no processo svchost.exe, junto com todos os servi√ßos atualmente hospedados nele e em uma reinicializa√ß√£o adicional desses servi√ßos pelo sistema operacional.  Um fato que atacantes em determinadas condi√ß√µes tamb√©m podem usar para seu pr√≥prio benef√≠cio. <br><br>  Isso parece ser tudo o que pode ser dito sobre o erro sob investiga√ß√£o.  Resta apenas a sensa√ß√£o de que isso est√° longe do fim.  Como se n√£o consider√°ssemos todas as op√ß√µes.  Deve haver algo mais que est√° oculto nessas linhas. <br><br><h2>  CVE-2019-0726 </h2><br>  Provavelmente do jeito que est√°.  Se voc√™ observar atentamente o tipo de dados que est√° causando o erro e compar√°-lo com a forma exata com que esse erro ocorre, notar√° que a lista de nomes de dom√≠nio pode ser alterada de forma que o buffer resultante seja de tamanho diferente de zero, mas uma tentativa de gravar fora dele √© o mesmo ser√° feito.  Para fazer isso, o primeiro elemento da lista deve ser uma sequ√™ncia vazia e todos os outros podem conter termina√ß√µes de dom√≠nio normais.  Por exemplo: <br><br><img src="https://habrastorage.org/webt/b2/me/mx/b2memx0tuctb6b7oozdlqwykubw.png"><br><br>  A op√ß√£o apresentada inclui dois elementos.  O sufixo do primeiro dom√≠nio est√° vazio, termina imediatamente com um byte zero.  O segundo sufixo √© .ru.  O tamanho da linha calculada na sa√≠da ser√° igual a tr√™s bytes, o que permitir√° superar a verifica√ß√£o imposta pela atualiza√ß√£o de janeiro sobre o vazio do buffer de destino.  Ao mesmo tempo, zero no in√≠cio dos dados for√ßar√° a fun√ß√£o a escrever uma v√≠rgula com o caractere anterior na sequ√™ncia resultante, mas como a posi√ß√£o atual do iterador na sequ√™ncia √© zero, como no caso considerado acima, a grava√ß√£o ocorrer√° novamente fora do buffer alocado. <br><br>  Agora √© necess√°rio confirmar os resultados te√≥ricos obtidos na pr√°tica.  Simulamos uma situa√ß√£o na qual o servidor DHCP envia uma mensagem com a op√ß√£o apresentada em resposta a uma solicita√ß√£o do cliente e captamos imediatamente uma exce√ß√£o ao tentar escrever uma v√≠rgula na posi√ß√£o 0xffffffff alocada na linha de buffer resultante: <br><br><img src="https://habrastorage.org/webt/o3/zk/us/o3zkus_tpdsnpbtff_rqnlu1cdw.png"><br><br>  Aqui, o registro r8 cont√©m um ponteiro para as op√ß√µes recebidas, rdi √© o endere√ßo do buffer de destino selecionado e rax √© a posi√ß√£o nesse buffer em que o caractere deve ser gravado.  Obtivemos esses resultados em um sistema completamente atualizado (a partir de janeiro de 2019). <br><br>  Escrevemos sobre o problema descoberto na Microsoft e ... eles perdem a carta.  Sim, isso √†s vezes acontece mesmo com fornecedores respeit√°veis.  Nenhum sistema √© perfeito e, nesse caso, voc√™ deve procurar outras formas de comunica√ß√£o.  Portanto, uma semana depois, mesmo sem receber uma resposta autom√°tica nesse per√≠odo, contatamos o gerente diretamente via Twitter e, de acordo com os resultados de v√°rios dias de an√°lise do aplicativo, descobrimos que os detalhes enviados n√£o t√™m nada a ver com o CVE-2019-0547 e representam uma vulnerabilidade independente pela qual novo identificador CVE.  Um m√™s depois, em mar√ßo, a corre√ß√£o correspondente √© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">lan√ßada</a> e o erro recebe o n√∫mero <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">CVE-2019-0726</a> . <br><br>  √â assim que √†s vezes voc√™ pode tentar descobrir os detalhes da vulnerabilidade de 1 dia para descobrir acidentalmente o dia 0 simplesmente confiando na sua intui√ß√£o. <br><br>  <b>Postado por</b> Mikhail Tsvetkov, especialista em an√°lise de aplicativos da Positive Technologies. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt448378/">https://habr.com/ru/post/pt448378/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt448366/index.html">Rust 1.34 Release</a></li>
<li><a href="../pt448368/index.html">SQL: a tarefa do tempo de trabalho</a></li>
<li><a href="../pt448372/index.html">Pare de rejeitar grandes candidatos a emprego com suas perguntas erradas.</a></li>
<li><a href="../pt448374/index.html">Novas evid√™ncias de atividade vulc√¢nica, que causaram a extin√ß√£o mais maci√ßa da hist√≥ria, s√£o recebidas.</a></li>
<li><a href="../pt448376/index.html">Matem√°tica dizendo √†s c√©lulas o que elas deveriam ser</a></li>
<li><a href="../pt448382/index.html">Como avaliamos a qualidade da documenta√ß√£o</a></li>
<li><a href="../pt448386/index.html">9 maneiras incrivelmente simples de fazer as pessoas responderem √†s suas mensagens</a></li>
<li><a href="../pt448388/index.html">Ditado digital ser√° realizado pela primeira vez na R√∫ssia</a></li>
<li><a href="../pt448390/index.html">Como fazer um rel√≥gio para a Ilona Mask</a></li>
<li><a href="../pt448392/index.html">Duas abordagens para estruturar um gr√°fico de atividades</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>