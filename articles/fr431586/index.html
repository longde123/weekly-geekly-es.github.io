<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧛🏾 🙌🏼 🍐 Comment gérer plus rapidement les erreurs sur la JVM 👨🏽‍✈️ 👓 👨🏻‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il existe différentes manières de gérer les erreurs dans les langages de programmation: 


- exceptions standard pour de nombreux langages (Java, Scal...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Comment gérer plus rapidement les erreurs sur la JVM</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/431586/"><p>  Il existe différentes manières de gérer les erreurs dans les langages de programmation: </p><br><ul><li>  exceptions standard pour de nombreux langages (Java, Scala et autres JVM, python et bien d'autres) </li><li>  codes d'état ou drapeaux (Go, bash) </li><li>  diverses structures de données algébriques, dont les valeurs peuvent être à la fois des résultats réussis et des descriptions d'erreurs (Scala, haskell et autres langages fonctionnels) </li></ul><br><p>  Les exceptions sont très largement utilisées, en revanche elles sont souvent dites lentes.  Mais les opposants à une approche fonctionnelle font souvent appel à la performance. </p><br><p>  Récemment, j'ai travaillé avec Scala, où je peux également utiliser à la fois des exceptions et divers types de données pour la gestion des erreurs, je me demande donc quelle approche sera plus pratique et plus rapide. </p><br><p> Nous éliminerons immédiatement l'utilisation de codes et de drapeaux, car cette approche n'est pas acceptée dans les langages JVM et, à mon avis, est trop sujette aux erreurs (je suis désolé pour le jeu de mots).  Par conséquent, nous comparerons les exceptions et les différents types d'ADT.  De plus, l'ADT peut être considéré comme l'utilisation de codes d'erreur dans un style fonctionnel. </p><br><p>  <strong>MISE À JOUR</strong> : des exceptions sans traces de pile sont ajoutées à la comparaison </p><a name="habracut"></a><br><h3 id="konkursanty">  Concurrents </h3><br><div class="spoiler">  <b class="spoiler_title">Un peu plus sur les types de données algébriques</b> <div class="spoiler_text"><p>  Pour ceux qui ne connaissent pas trop l'ADT ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ADT</a> ) - un type algébrique se compose de plusieurs valeurs possibles, chacune pouvant être une valeur composite (structure, enregistrement). </p><br><p> Un exemple est le type <code>Option[T] = Some(value: T) | None</code>  <code>Option[T] = Some(value: T) | None</code> , qui est utilisé à la place de nulls: une valeur de ce type peut être <code>Some(t)</code> s'il existe une valeur, ou <code>None</code> si elle ne l'est pas. </p><br><p>  Un autre exemple serait <code>Try[T] = Success(value: T) | Failure(exception: Throwable)</code>  <code>Try[T] = Success(value: T) | Failure(exception: Throwable)</code> , qui décrit le résultat d'un calcul qui pourrait se terminer avec succès ou avec une erreur. </p><br><p>  Alors nos concurrents: </p></div></div><br><ul><li>  <em>Bonnes</em> vieilles exceptions </li><li>  Exceptions sans trace de pile, car remplir une trace de pile est une opération très lente </li><li> <code>Try[T] = Success(value: T) | Failure(exception: Throwable)</code>  <code>Try[T] = Success(value: T) | Failure(exception: Throwable)</code> - les mêmes exceptions, mais dans un wrapper fonctionnel </li><li> <code>Either[String, T] = Left(error: String) | Right(value: T)</code>  <code>Either[String, T] = Left(error: String) | Right(value: T)</code> - un type contenant soit le résultat, soit une description de l'erreur </li><li> <code>ValidatedNec[String, T] = Valid(value: T) | Invalid(errors: List[String])</code>  <code>ValidatedNec[String, T] = Valid(value: T) | Invalid(errors: List[String])</code> - un type de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">la bibliothèque Cats</a> qui, en cas d'erreur, peut contenir plusieurs messages sur différentes erreurs (pas tout à fait <code>List</code> utilisé ici, mais cela n'a pas d'importance) </li></ul><br><p>  <strong>NOTE</strong> en substance, les exceptions sont comparées à la trace de pile, sans et ATD, mais plusieurs types sont sélectionnés, car Scala n'a pas d'approche unique et il est intéressant d'en comparer plusieurs. </p><br><p>  En plus des exceptions, des chaînes sont utilisées pour décrire les erreurs, mais avec le même succès dans une situation réelle, différentes classes seraient utilisées ( <code>Either[Failure, T]</code> ). </p><br><h3 id="problema">  Le problème </h3><br><p>  Pour tester la gestion des erreurs, nous prenons le problème de l'analyse et de la validation des données: </p><br><pre> <code class="scala hljs"><span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class">(</span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">name: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-class"><span class="hljs-params">, age: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Int</span></span></span></span><span class="hljs-class"><span class="hljs-params">, isMale: </span></span><span class="hljs-type"><span class="hljs-class"><span class="hljs-params"><span class="hljs-type">Boolean</span></span></span></span></span><span class="hljs-class">) </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">type</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Result</span></span></span><span class="hljs-class">[</span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">T</span></span></span><span class="hljs-class">] </span></span>= <span class="hljs-type"><span class="hljs-type">Either</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">T</span></span>] <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">trait</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">PersonParser</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse</span></span></span></span>(data: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Result</span></span>[<span class="hljs-type"><span class="hljs-type">Person</span></span>] }</code> </pre> <br><p>  c'est-à-dire  ayant une <code>Map[String, String]</code> données brutes <code>Map[String, String]</code> vous devez obtenir <code>Person</code> ou une erreur si les données ne sont pas valides. </p><br><h4 id="throw">  Jeter </h4><br><p>  Une solution <em>au front en</em> utilisant des exceptions (ci-après je ne donnerai que la fonction <code>person</code> , vous pouvez voir le code complet sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github</a> ): <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Throwparser.scala</a> </p><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span></span>(data: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Person</span></span> = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name = string(data.getOrElse(<span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> age = integer(data.getOrElse(<span class="hljs-string"><span class="hljs-string">"age"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isMale = boolean(data.getOrElse(<span class="hljs-string"><span class="hljs-string">"isMale"</span></span>, <span class="hljs-literal"><span class="hljs-literal">null</span></span>)) require(name.nonEmpty, <span class="hljs-string"><span class="hljs-string">"name should not be empty"</span></span>) require(age &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"age should be positive"</span></span>) <span class="hljs-type"><span class="hljs-type">Person</span></span>(name, age, isMale) }</code> </pre> <br><p>  ici <code>string</code> , <code>integer</code> et <code>boolean</code> valident la présence et le format des types simples et effectuent la conversion. <br>  En général, c'est assez simple et compréhensible. </p><br><h4 id="thrownst-no-stack-trace">  ThrowNST (aucune trace de pile) </h4><br><p>  Le code est le même que dans le cas précédent, mais les exceptions sont utilisées sans trace de pile dans la mesure du possible: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ThrowNSTParser.scala</a> </p><br><h4 id="try">  Essayez </h4><br><p>  La solution intercepte les exceptions plus tôt et permet de combiner les résultats via <code>for</code> (à ne pas confondre avec les boucles dans d'autres langues): <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TryParser.scala</a> </p><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span></span>(data: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Try</span></span>[<span class="hljs-type"><span class="hljs-type">Person</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { name &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)) age &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"age"</span></span>)) flatMap integer isMale &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"isMale"</span></span>)) flatMap boolean _ &lt;- require(name.nonEmpty, <span class="hljs-string"><span class="hljs-string">"name should not be empty"</span></span>) _ &lt;- require(age &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"age should be positive"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-type"><span class="hljs-type">Person</span></span>(name, age, isMale)</code> </pre> <br><p>  un peu plus inhabituel pour un œil fragile, mais en raison de l'utilisation de <code>for</code> , il est très similaire à la version avec des exceptions, de plus, la validation de la présence d'un champ et l'analyse du type souhaité se produisent séparément ( <code>flatMap</code> peut être lu ici <code>and then</code> ) </p><br><h4 id="either">  Soit </h4><br><p>  Ici, le type <code>Either</code> est caché derrière l'alias de <code>Result</code> puisque le type d'erreur est fixe: <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">EitherParser.scala</a> </p><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span></span>(data: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Result</span></span>[<span class="hljs-type"><span class="hljs-type">Person</span></span>] = <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { name &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)) age &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"age"</span></span>)) flatMap integer isMale &lt;- required(data.get(<span class="hljs-string"><span class="hljs-string">"isMale"</span></span>)) flatMap boolean _ &lt;- require(name.nonEmpty, <span class="hljs-string"><span class="hljs-string">"name should not be empty"</span></span>) _ &lt;- require(age &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-string"><span class="hljs-string">"age should be positive"</span></span>) } <span class="hljs-keyword"><span class="hljs-keyword">yield</span></span> <span class="hljs-type"><span class="hljs-type">Person</span></span>(name, age, isMale)</code> </pre> <br><p>  Puisque le standard <code>Either</code> comme <code>Try</code> forme une monade dans Scala, le code est exactement le même, la différence ici est que la chaîne apparaît ici comme une erreur et que les exceptions sont utilisées de manière minimale (uniquement pour gérer les erreurs lors de l'analyse d'un nombre) </p><br><h4 id="validated">  Validée </h4><br><p>  Ici, la bibliothèque Cats est utilisée pour obtenir non pas la première chose qui s'est produite, mais autant que possible (par exemple, si plusieurs champs n'étaient pas valides, le résultat contiendra des erreurs d'analyse pour tous ces champs) <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ValidatedParser.scala</a> </p><br><pre> <code class="scala hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">person</span></span></span></span>(data: <span class="hljs-type"><span class="hljs-type">Map</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>, <span class="hljs-type"><span class="hljs-type">String</span></span>]): <span class="hljs-type"><span class="hljs-type">Validated</span></span>[<span class="hljs-type"><span class="hljs-type">Person</span></span>] = { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> name: <span class="hljs-type"><span class="hljs-type">Validated</span></span>[<span class="hljs-type"><span class="hljs-type">String</span></span>] = required(data.get(<span class="hljs-string"><span class="hljs-string">"name"</span></span>)) .ensure(one(<span class="hljs-string"><span class="hljs-string">"name should not be empty"</span></span>))(_.nonEmpty) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> age: <span class="hljs-type"><span class="hljs-type">Validated</span></span>[<span class="hljs-type"><span class="hljs-type">Int</span></span>] = required(data.get(<span class="hljs-string"><span class="hljs-string">"age"</span></span>)) .andThen(integer) .ensure(one(<span class="hljs-string"><span class="hljs-string">"age should be positive"</span></span>))(_ &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isMale: <span class="hljs-type"><span class="hljs-type">Validated</span></span>[<span class="hljs-type"><span class="hljs-type">Boolean</span></span>] = required(data.get(<span class="hljs-string"><span class="hljs-string">"isMale"</span></span>)) .andThen(boolean) (name, age, isMale).mapN(<span class="hljs-type"><span class="hljs-type">Person</span></span>) }</code> </pre> <br><p>  ce code est déjà moins similaire à la version originale avec des exceptions, mais la vérification des restrictions supplémentaires n'est pas dissociée des champs d'analyse et nous obtenons toujours plusieurs erreurs au lieu d'une, ça vaut le coup! </p><br><h3 id="testirovanie">  Test </h3><br><p>  Pour les tests, un ensemble de données a été généré avec un pourcentage d'erreurs différent et analysé dans chacune des manières. </p><br><p>  Résultat sur tous les pourcentages d'erreurs: <br><img src="https://habrastorage.org/webt/hj/la/-8/hjla-8vnb-pa7jgyiwghmhwwhxk.png"></p><br><p>  Plus en détail, avec un faible pourcentage d'erreurs (le temps est différent ici car <em>un</em> plus grand échantillon a été utilisé): <br><img src="https://habrastorage.org/webt/4s/8r/ca/4s8rcaqkm4gke5o_2fim1dxx9y0.png"></p><br><p>  Si une partie des erreurs est toujours une exception avec la trace de pile (dans notre cas, l'erreur d'analyse du nombre sera une exception que nous ne contrôlons pas), alors bien sûr, les performances des méthodes de gestion des erreurs «rapides» se détérioreront considérablement.  <code>Validated</code> particulièrement affecté, car il collecte toutes les erreurs et, par conséquent, reçoit une exception lente plus que les autres: <br><img src="https://habrastorage.org/webt/gy/x-/ve/gyx-veyf2w3kexn4oa56vrbfuvw.png"></p><br><h3 id="vyvody">  Conclusions </h3><br><p>  Comme l'expérience l'a montré, les exceptions avec des traces de pile sont vraiment très lentes (100% des erreurs font la différence entre <code>Throw</code> et <code>Either</code> plus de 50 fois!), Et quand il n'y a pratiquement aucune exception, l'utilisation d'ADT a un prix.  Cependant, l'utilisation d'exceptions sans traces de pile est aussi rapide (et avec un faible pourcentage d'erreurs plus rapide) que ADT, cependant, si ces exceptions vont au-delà de la même validation, le suivi de leur source ne sera pas facile. </p><br><p>  Au total, si la probabilité d'une exception est supérieure à 1%, les exceptions sans traces de pile fonctionnent plus rapidement, <code>Validated</code> ou régulières. Les <code>Either</code> presque aussi rapides.  Avec un grand nombre d'erreurs, l'une <code>Either</code> peut être un peu plus rapide que <code>Validated</code> uniquement en raison d'une sémantique rapide. </p><br><p>  L'utilisation d'ADT pour la gestion des erreurs offre un autre avantage par rapport aux exceptions: la possibilité d'une erreur est câblée dans le type lui-même et il est plus difficile à manquer, comme lors de l'utilisation d' <code>Option</code> au lieu de null. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr431586/">https://habr.com/ru/post/fr431586/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr431572/index.html">Comment rédiger les exigences fonctionnelles</a></li>
<li><a href="../fr431574/index.html">Les interfaces neuro aujourd'hui</a></li>
<li><a href="../fr431576/index.html">Contexte: Observatoire spatial Kepler - fer, communication avec la Terre, logiciel et résultats</a></li>
<li><a href="../fr431582/index.html">Histoire de la protection des données personnelles: comment est né le RGPD?</a></li>
<li><a href="../fr431584/index.html">Espace et test: mélanger, mais ne pas secouer</a></li>
<li><a href="../fr431588/index.html">Loi sur les travailleurs indépendants. Informations à considérer</a></li>
<li><a href="../fr431590/index.html">La modernisation des parcs éoliens britanniques obsolètes augmentera la production d'énergie de 171%</a></li>
<li><a href="../fr431596/index.html">Test de charge de sauvegarde et de réplication Veeam</a></li>
<li><a href="../fr431598/index.html">Nous apportons à Internet une machine virtuelle publique QEMU sans carte réseau et essayons d'exploiter</a></li>
<li><a href="../fr431600/index.html">Augmenter IDS / NMS: Mikrotik et Suricata avec une interface Web</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>