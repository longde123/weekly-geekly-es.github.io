<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèº‚Äçü§ù‚Äçüë®üèæ üõÄüèª üçª Crear un complemento para Clang Static Analyzer para buscar desbordamientos de enteros ‚úãüèº üí™üèæ üë®‚Äçüëß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Autor del art√≠culo: 0x64rem 
 Entrada 


 Hace un a√±o y medio, tuve la idea de realizar mi phaser como parte de la tesis en la universidad. Comenc√© a ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Crear un complemento para Clang Static Analyzer para buscar desbordamientos de enteros</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/dsec/blog/473412/"><p><img src="https://habrastorage.org/getpro/habr/post_images/e69/d01/efb/e69d01efbeff395f19dbb543055a5493.jpg" title="fig. 1"></p><br><p>  <em>Autor del art√≠culo: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">0x64rem</a></em> </p><br><h2 id="vstuplenie">  Entrada </h2><br><p>  Hace un a√±o y medio, tuve la idea de realizar mi phaser como parte de la tesis en la universidad.  Comenc√© a estudiar materiales sobre gr√°ficos de flujo de control, gr√°ficos de flujo de datos, ejecuci√≥n simb√≥lica, etc.  Luego vino la b√∫squeda de herramientas, una muestra de diferentes bibliotecas (Angr, Triton, Pin, Z3).  Al final no sucedi√≥ nada concreto, hasta que este verano fui al programa Summer of Hack 2019 de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Digital Security</a> , donde me ofrecieron la extensi√≥n del Analizador est√°tico de Clang como tema para el proyecto.  Me pareci√≥ que este tema me ayudar√≠a a poner mi conocimiento te√≥rico en los estantes, comenzar a implementar algo sustancial y obtener recomendaciones de mentores experimentados.  A continuaci√≥n, te contar√© c√≥mo fue el proceso de escribir el complemento y describir√© el curso de mis pensamientos durante el mes de pasant√≠a. </p><a name="habracut"></a><br><h2 id="clang-static-analyzer">  Analizador est√°tico de Clang </h2><br><p>  Para el desarrollo, Clang ofrece tres opciones de interfaz para la interacci√≥n: </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LibClang</a> es una interfaz C de alto nivel que le permite interactuar con AST, pero no completamente.  Una buena opci√≥n si necesita interacci√≥n con otro idioma (por ejemplo, la implementaci√≥n de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">enlaces</a> ) o una interfaz estable. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Complementos de Clang</a> : bibliotecas din√°micas llamadas en tiempo de compilaci√≥n.  Le permite manipular completamente el AST. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">LibTooling</a> : una biblioteca para crear herramientas separadas basadas en Clang.  Tambi√©n da acceso completo a la interacci√≥n con AST.  El c√≥digo resultante se puede ejecutar fuera del entorno de compilaci√≥n del proyecto verificado. </li></ul><br><p>  Como vamos a ampliar las capacidades de Clang Static Analyzer, elegimos la implementaci√≥n del complemento.  Puede escribir c√≥digo para el complemento en C ++ o Python. </p><br><p>  Para este √∫ltimo, hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">carpetas</a> que le permiten analizar el c√≥digo fuente, iterar sobre los nodos del √°rbol de sintaxis abstracta resultante, tambi√©n tienen acceso a las propiedades de los nodos y pueden asignar el nodo a la l√≠nea del c√≥digo fuente.  Tal conjunto es adecuado para un simple corrector.  Vea <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">el repositorio llvm para</a> m√°s detalles. </p><br><p>  Mi tarea requiere un an√°lisis detallado del c√≥digo, por lo que se eligi√≥ C ++ para el desarrollo.  Lo siguiente es una introducci√≥n a la herramienta. </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Clang Staic Analyzer</a> (en adelante CSA) es una herramienta para el an√°lisis est√°tico de c√≥digo C / C ++ / Objective-C basado en la ejecuci√≥n simb√≥lica.  Se puede llamar al analizador a trav√©s de la interfaz de Clang agregando los indicadores -cc1 y -analyze al comando de compilaci√≥n, o mediante un binario de exploraci√≥n-compilaci√≥n separado.  Adem√°s del an√°lisis en s√≠, CSA hace posible generar informes visuales html. </p><br><pre><code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment"># ,      clang' clang -cc1 --help #  CSA  ‚Ññ1 clang++ -cc1 -x c++ -load path/to/Checker.so -analyze -analyzer-checker=test.Me -analyzer-config $BUILD_OPTIONS Checker.cpp</span></span></code> </pre> <br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#  CSA  ‚Ññ2 scan-build -load-plugin path/to/Checker.so -enable-checker test.Me $BUILD_COMMAND</span></span></code> </pre> <br><pre> <code class="bash hljs"> <span class="hljs-comment"><span class="hljs-comment">#       DivideZero clang++ -cc1 -analyze -analyzer-checker=core.DivideZero -o reports div-by-zero-test.cpp</span></span></code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/6dd/b8e/302/6ddb8e302c62b6cc58c4533a894d49e9.jpg" alt=" " title="fig. 2"></p><br><p>  CSA tiene una excelente biblioteca para analizar el c√≥digo fuente usando AST (Abstract Syntax Tree), CFG (Control Flow Graph).  Desde las estructuras puede ver m√°s lejos las declaraciones de variables, sus tipos, el uso de operadores binarios y unarios, puede obtener expresiones simb√≥licas, etc.  Mi complemento utilizar√° la funcionalidad de las clases AST, esta elecci√≥n se justificar√° a√∫n m√°s.  La siguiente es una lista de clases que se utiliz√≥ en la implementaci√≥n del complemento, la lista ayudar√° a obtener una comprensi√≥n primaria de las caracter√≠sticas de CSA: </p><br><ul><li><p>  Stmt: esto incluye operaciones binarias. </p><br></li><li><p>  Decl - declaraci√≥n de variables. </p><br></li><li><p>  Expr: almacena las partes izquierda, derecha de las expresiones, su tipo. </p><br></li><li><p>  ASTContext: informaci√≥n sobre el √°rbol, el nodo actual. </p><br></li><li><p>  Administrador de origen: informaci√≥n sobre el c√≥digo real que corresponde a la parte del √°rbol. </p><br></li><li><p>  RecursiveASTVisitor, ASTMatcher: clases para atravesar un √°rbol. </p><br><p>  Repito que CSA brinda al desarrollador la oportunidad de examinar en detalle la estructura del c√≥digo, y las clases enumeradas anteriormente son solo una peque√±a parte de las disponibles.  Definitivamente recomiendo consultar la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n de</a> su versi√≥n de Clang si no sabe c√≥mo extraer datos;  muy probablemente, algo adecuado ya ha sido escrito. </p><br></li></ul><br><h2 id="poisk-celochislennyh-perepolneniy">  B√∫squeda de desbordamiento de enteros </h2><br><p>  Para comenzar a implementar el complemento, debe elegir la tarea que resolver√°.  Para este caso, el sitio web llvm proporciona <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">listas de posibles inspectores</a> ; tambi√©n puede modificar los comprobadores <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">estables</a> o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">alfa</a> existentes.  Durante la revisi√≥n del c√≥digo de los verificadores disponibles, qued√≥ claro que para un desarrollo m√°s exitoso de libclang es mejor escribir su verificador desde cero, por lo que la elecci√≥n se realiz√≥ a partir de una lista de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ideas no realizadas</a> .  Como resultado, se eligi√≥ la opci√≥n para crear un verificador para la detecci√≥n de desbordamiento de enteros.  Clang ya tiene funcionalidad para prevenir esta vulnerabilidad (las banderas -ftrapv, -fwrapv y similares est√°n indicadas para su uso), est√° integrado en el compilador, y ese escape se vierte en advertencias, y no se suele mirar all√≠.  Todav√≠a hay <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">UBSan</a> , pero estos son desinfectantes, no todos los usan, y este m√©todo trata de identificar problemas en tiempo de ejecuci√≥n, y el complemento CSA funciona en tiempo de compilaci√≥n, analizando las fuentes. </p><br><p>  Lo siguiente es la recopilaci√≥n de material sobre la vulnerabilidad seleccionada.  El desbordamiento de enteros sol√≠a ser algo simple y no serio.  De hecho, la vulnerabilidad es entretenida y puede tener consecuencias impresionantes. <br>  Los desbordamientos de enteros son un tipo de vulnerabilidad que podr√≠a provocar que los datos de tipo entero en el c√≥digo tomen valores inesperados.  Desbordamiento: si la variable se ha vuelto m√°s grande de lo previsto, Desbordamiento: menos que su tipo original.  Dichos errores pueden aparecer tanto por el programador como por el compilador. </p><br><p>  En C ++, durante una operaci√≥n de comparaci√≥n aritm√©tica, los valores enteros se convierten al mismo tipo, m√°s a menudo a uno m√°s grande en t√©rminos de profundidad de bits.  Y tales fantasmas ocurren en todas partes y constantemente, pueden ser expl√≠citos o impl√≠citos.  Hay varias reglas por las cuales ocurren los fantasmas [1]: </p><br><ul><li>  Conversi√≥n de un tipo firmado a un tipo con un bit firmado pero m√°s grande: simplemente agregue el orden superior. </li><li>  Convertir un entero con signo en un entero sin signo de la misma capacidad: lo negativo se convierte en positivo y adquiere un nuevo significado.  Un ejemplo de un error similar en DirectFB es <a href="">CVE-2014-2977</a> . </li><li>  Convertir un entero con signo en un entero sin signo de mayor capacidad de bits: primero, la capacidad de bits se expandir√°, luego, si el n√∫mero es negativo, entonces cambiar√° incorrectamente el valor.  Por ejemplo: 0xff (-1) se convierte en 0xffffffff. </li><li>  Un entero sin signo con un signo de la misma capacidad de bit: un n√∫mero puede cambiar el valor, dependiendo del valor del bit alto. </li><li>  Un entero sin signo con un entero con un signo de mayor capacidad: primero, aumenta la capacidad de un n√∫mero sin signo, luego la conversi√≥n a uno con signo. </li><li>  Conversi√≥n descendente: los bits simplemente se truncan.  Esto puede hacer que los valores sin signo sean negativos, etc.  Un ejemplo de tal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">vulnerabilidad en PHP</a> . </li></ul><br><p>  Es decir  El desencadenante de la vulnerabilidad puede ser una entrada insegura del usuario, aritm√©tica incorrecta, conversi√≥n de tipo incorrecta causada por un programador o compilador durante la optimizaci√≥n.  La opci√≥n de bomba de tiempo tambi√©n es posible, cuando un c√≥digo es inofensivo con una versi√≥n del compilador, pero con el lanzamiento de un nuevo algoritmo de optimizaci√≥n "explota" y causa un comportamiento inesperado.  En la historia, ya ha habido un caso as√≠ con la clase SafeInt (muy ir√≥nico) [5, 6.5.2]. </p><br><p>  Los desbordamientos de enteros abren un vector ancho: es posible forzar la ejecuci√≥n para que tome una ruta diferente (si el desbordamiento afecta las declaraciones condicionales), se produce un desbordamiento del b√∫fer.  Para mayor claridad, puede familiarizarse con CVE espec√≠ficos, ver sus causas, consecuencias.  Naturalmente, es mejor buscar el desbordamiento de enteros en productos de c√≥digo abierto, para que no solo lea la descripci√≥n, sino que tambi√©n vea el c√≥digo. </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CVE-2019-3560</a> : el desbordamiento de enteros en Fizz (un proyecto que implementa TLS para Facebook) podr√≠a explotar una vulnerabilidad DoS utilizando un paquete de red reducido. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CVE-2018-14618</a> : desbordamiento de b√∫fer en Curl causado por desbordamiento de enteros debido a la longitud de la contrase√±a. </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CVE-2018-6092</a> : en los sistemas de 32 bits, una vulnerabilidad en WebAssembly para Chrome permiti√≥ que RCE se implementara a trav√©s de una p√°gina HTML especial. </li></ul><br><p>  Para no reinventar la rueda, se consider√≥ el c√≥digo para detectar el desbordamiento de enteros en el analizador est√°tico <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CppCheck</a> .  Su enfoque es el siguiente: </p><br><ol><li>  Determine si una expresi√≥n es un operador binario. </li><li>  En caso afirmativo, verifique si ambos argumentos son de tipo entero. </li><li>  Determinar el tama√±o de los tipos. </li><li>  Compruebe mediante c√°lculos si el valor puede ir m√°s all√° de sus l√≠mites m√°ximos o m√≠nimos. <br>  Pero en esta etapa no dio claridad.  Resulta muchas historias diferentes, y de esta sistematizaci√≥n de la informaci√≥n se hace m√°s dif√≠cil.  Todo en su lugar pone la lista de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">CWE</a> .  En total, hay 9 tipos de desbordamiento de enteros asignados en el sitio: <br><ul><li>  190 - desbordamiento de enteros </li><li>  191 - flujo inferior entero </li><li>  192 - error de coerci√≥n entero </li><li>  193 - off-by-one </li><li>  194 - Extensi√≥n de se√±al inesperada </li><li>  195 - Error de conversi√≥n de firmado a no firmado </li><li>  196 - Error de conversi√≥n de sin firmar a firmado </li><li>  197 - Error de truncamiento num√©rico </li><li>  198 - Uso de orden de bytes incorrecto </li></ul></li></ol><br><p>  Consideramos el motivo de cada opci√≥n y entendemos que se producen desbordamientos con conversiones expl√≠citas / impl√≠citas incorrectas.  Y porque  cualquier conversi√≥n se muestra en la estructura del √°rbol de sintaxis abstracta, usaremos AST para el an√°lisis.  En la figura a continuaci√≥n (Fig. 3), se puede ver que cualquier operaci√≥n que causa una conversi√≥n en el √°rbol es un nodo separado, y, deambulando por el √°rbol, podemos verificar todas las conversiones de tipos basadas en una tabla con transformaciones que pueden causar un error. </p><br><div class="scrollable-table"><table><thead><tr><th></th><th>  Signo g </th><th>  Signo l </th><th>  Reg√≠strate e </th><th>  Unsign g </th><th>  Unsign l </th><th>  Unsign e </th></tr></thead><tbody><tr><td>  Letrero </td><td>  + </td><td>  - </td><td>  + </td><td>  - </td><td>  - </td><td>  - </td></tr><tr><td>  Unsign </td><td>  + </td><td>  - </td><td>  - </td><td>  - </td><td>  - </td><td>  + </td></tr></tbody></table></div><br><p><img src="https://habrastorage.org/getpro/habr/post_images/e72/315/acb/e72315acbeaf57dcf7ea2f85670fe4e0.jpg" title="fig. 3"></p><br><p>  M√°s espec√≠ficamente, el algoritmo suena as√≠: vamos alrededor de Casts y miramos IntegralCast (conversiones enteras).  Si encuentra un nodo adecuado, mire a los descendientes en busca de una operaci√≥n binaria o Decl (declaraci√≥n de variable).  En el primer caso, debe verificar el signo y la profundidad de bits que utiliza la operaci√≥n binaria.  En el segundo caso, compare solo el tipo de declaraci√≥n. </p><br><h2 id="realizaciya-chekera">  Implementaci√≥n del verificador </h2><br><p>  Vayamos a la implementaci√≥n.  Necesitamos un esqueleto para un corrector, que puede ser una biblioteca independiente o puede ensamblarse como parte de Clang.  En el c√≥digo, la diferencia ser√° peque√±a.  Si ya est√° planeando escribir su propio complemento, le recomiendo que lea inmediatamente un peque√±o pdf: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Analizador est√°tico de Clang: Una gu√≠a para desarrolladores"</a> , las cosas b√°sicas est√°n bien descritas all√≠, aunque es posible que algo ya no sea relevante, la biblioteca se actualiza regularmente, pero usted agarrar de inmediato. </p><br><p>  Si desea agregar su corrector a su ensamblaje de clanes, entonces necesita: </p><br><ol><li><p>  Escriba el corrector en s√≠ con aproximadamente el siguiente contenido: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuperChecker</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Checker&lt;check::PreStmt&lt;BinaryOperator&gt;&gt; { <span class="hljs-comment"><span class="hljs-comment">//       ,    .       struct CheckerOpts { //       string FlagOne; int FlagTwo; }; CheckerOpts Opts; //cool code }; } void ento::registerSuperChecker(CheckerManager &amp;mgr) { auto checker = mgr.registerChecker&lt;SuperChecker&gt;(); //       ,   4    //       ,  stand-alone    . AnalyzerOptions &amp;AnOpts = mgr.getAnalyzerOptions(); SuperChecker::CheckerOpts &amp;ChOpts = checker-&gt;Opts; ChOpts.FlagOne = AnOpts.getCheckerStringOption("Inp1", "", checker); ChOpts.FlagTwo = AnOpts.getCheckerIntegerOption("Inp2", 0, checker); // getCheckerIntegerOption:  ,  ,   }</span></span></code> </pre> <br></li><li><p>  Luego, en el c√≥digo fuente de Clang, deber√° cambiar los archivos <code>CMakeLists.txt</code> y <code>Checkers.td</code> .  Vive por aqu√≠ <code>${llvm-source-path}/clang/lib/StaticAnalyzer/Checkers/CMakeLists.txt</code> <br>  y aqu√≠ <code>${llvm-source-path}/clang/include/clang/StaticAnalyzer/Checkers/Checkers.td</code> . <br>  En el primero, solo necesita agregar el nombre del archivo con el c√≥digo, en el segundo debe agregar una descripci√≥n estructural: </p><br><pre> <code class="cpp hljs"> #Checkers.td def SuperChecker : Checker&lt;<span class="hljs-string"><span class="hljs-string">"SuperChecker"</span></span>&gt;, HelpText&lt;<span class="hljs-string"><span class="hljs-string">"test checker"</span></span>&gt;, Documentation&lt;HasDocumentation&gt;;</code> </pre> <br></li></ol><br><p>  Si no est√° claro, en el archivo <code>Checkers.td</code> hay suficientes ejemplos de c√≥mo y qu√© hacer. </p><br><p>  Lo m√°s probable es que no desee reconstruir Clang, y recurrir√° a la opci√≥n con el ensamblado de la biblioteca (so / dll).  Luego, en el c√≥digo del verificador deber√≠a haber algo como esto: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> { <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">SuperChecker</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Checker&lt;check::PreStmt&lt;BinaryOperator&gt;&gt; { <span class="hljs-comment"><span class="hljs-comment">//       ,    .       struct CheckerOpts { string FlagOne; int FlagTwo; }; CheckerOpts Opts; //cool code }; } void initializationFunction(CheckerManager &amp;mgr){ SuperChecker *checker = mgr.registerChecker&lt;SuperChecker&gt;(); //       ,   4    AnalyzerOptions &amp;AnOpts = mgr.getAnalyzerOptions(); TestChecker::CheckerOpts &amp;ChOpts = checker-&gt;Opts; ChOpts.FlagOne = AnOpts.getCheckerStringOption("Inp1", "", checker); ChOpts.FlagTwo = AnOpts.getCheckerIntegerOption("Inp2", 0, checker); // getCheckerIntegerOption:  ,  ,   } extern "C" void clang_registerCheckers (CheckerRegistry &amp;registry) { registry.addChecker(&amp;initializationFunction, "test.Me", "SuperChecker description", "doc_link"); } extern "C" const char clang_analyzerAPIVersionString [] = "8.0.1";</span></span></code> </pre> <br><p>  A continuaci√≥n, recopile su c√≥digo, puede escribir su propio script para el ensamblaje, pero si tiene alg√∫n problema con esto (como ten√≠a el autor :)), puede usar el Makefile en el c√≥digo fuente clang y hacer el comando clangStaticAnalyzerCheckers de una manera extra√±a. </p><br><p>  Luego, llame al verificador: </p><br><ul><li><p>  para damas incorporadas </p><br><pre> <code class="bash hljs">clang++ -cc1 -analyze -analyzer-checker=core.DivideZero test.cpp</code> </pre> <br></li><li><p>  para externo </p><br><pre> <code class="bash hljs">clang++ -cc1 -load <span class="hljs-variable"><span class="hljs-variable">${PATH_TO_CHECKER}</span></span>/SuperChecker.so -analyze -analyzer-checker=test.Me -analyzer-config test.Me:UsrInp1=<span class="hljs-string"><span class="hljs-string">"foo"</span></span> test.Me:Inp1=<span class="hljs-string"><span class="hljs-string">"bar"</span></span> -analyzer-config test.Me:Inp2=123 test.cpp</code> </pre> <br><p>  En esta etapa, ya tenemos alg√∫n tipo de resultado (Fig. 4), pero el c√≥digo escrito solo puede detectar desbordamientos potenciales.  Y eso significa una gran cantidad de falsos positivos. </p><br></li></ul><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ac1/79d/29b/ac179d29b330efd513343fdd5f9a2ddd.jpg" title="fig. 4 4"></p><br><p>  Para solucionar esto, podemos: </p><br><ul><li>  Recorriendo el gr√°fico de un lado a otro y verificando los valores espec√≠ficos de las variables para casos en los que tenemos un desbordamiento potencial. </li><li>  Durante el recorrido AST, guarde inmediatamente valores espec√≠ficos para variables y verif√≠quelos cuando sea necesario. </li><li>  Usar an√°lisis de manchas. </li></ul><br><p>  Para reforzar m√°s argumentos, vale la pena mencionar que al analizar Clang, todos los archivos especificados en la directiva <code>#include</code> tambi√©n analizan, como resultado, el tama√±o del AST resultante aumenta.  Como resultado, de las opciones propuestas, solo una es racional con respecto a una tarea espec√≠fica: </p><br><ul><li>  Primero, lleva mucho tiempo completarlo.  Caminar en un √°rbol, buscar y contar todo lo que necesita llevar√° mucho tiempo, puede resultar dif√≠cil analizar un proyecto grande con dicho c√≥digo.  Para recorrer el √°rbol en el c√≥digo, usaremos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la clase</a> <code>clang::RecursiveASTVisitor</code> , que realiza una b√∫squeda de profundidad recursiva.  Una estimaci√≥n del tiempo de este enfoque. <img src="https://wikimedia.org/api/rest_v1/media/math/render/svg/a7cf317fbe3965ae3164f28c1f6858696adb23f4" title="calificaci√≥n de dificultad">  , donde V es el conjunto de v√©rtices y E es el conjunto de bordes del gr√°fico. </li><li>  El segundo: ciertamente puede almacenar, pero no sabemos qu√© necesitaremos y qu√© no.  Adem√°s, las estructuras de los √°rboles, que utilizamos en el an√°lisis, requieren mucha memoria, por lo que gastar esos recursos en otra cosa es una mala idea. </li><li>  En tercer lugar, es una buena idea, para este m√©todo puede encontrar suficiente investigaci√≥n y ejemplos.  Pero en CSA no hay una mancha lista.  Hay un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">verificador</a> , que luego se agreg√≥ a la lista de verificadores alfa (alpha.security.taint.TaintPropagation) en las fuentes, se describe en el archivo <code>GenericTaintChecker.cpp</code> .  El verificador es bueno, pero adecuado solo para funciones de E / S inseguras conocidas de C, solo "marca" las variables que fueron argumentos o resultados de funciones peligrosas.  Adem√°s de las opciones descritas, vale la pena considerar variables globales, campos de clase, etc., para restaurar correctamente el modelo de "distribuci√≥n". </li></ul><br><p>  El tiempo restante para la pasant√≠a se pas√≥ leyendo <code>GenericTaintChecker.cpp</code> y tratando de rehacerlo para satisfacer sus necesidades.  No funcion√≥ con √©xito al final del per√≠odo, pero sigui√≥ siendo una tarea de refinamiento que ya estaba m√°s all√° del alcance de la capacitaci√≥n en DSec.  Adem√°s, durante el desarrollo qued√≥ claro que identificar funciones peligrosas es una tarea separada, no siempre los lugares peligrosos del proyecto provienen de algunas funciones est√°ndar, por lo tanto, se agreg√≥ una marca al verificador para indicar una lista de funciones que se considerar√°n "envenenadas" / "marcadas" durante el an√°lisis de manchas. <br>  Adem√°s, se agreg√≥ una verificaci√≥n para determinar si la variable es un campo de bits.  Seg√∫n las herramientas CSA est√°ndar, el tama√±o est√° determinado por el tipo, y si trabajamos con un campo de bits, entonces su tama√±o tendr√° el valor del tipo de bit de todo el campo, y no el n√∫mero de bits especificado en la declaraci√≥n de variable. </p><br><h2 id="chto-v-itoge">  Cual es el resultado? </h2><br><p>  Por el momento, se ha implementado un simple comprobador que solo puede advertir sobre posibles desbordamientos de enteros.  Una clase modificada para el an√°lisis de manchas, que todav√≠a tiene mucho trabajo por hacer.  Despu√©s de eso, debe usar SMT para determinar los desbordamientos.  Para esto, el solucionador Z3 SMT es adecuado, que se agreg√≥ al ensamblaje de Clang en la versi√≥n 5.0.0 (a juzgar por las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">notas de la versi√≥n</a> ).  Para usar el solucionador, es necesario que Clang se construya con la opci√≥n <code>CLANG_ANALYZER_BUILD_Z3=ON</code> , y cuando se llama directamente al complemento CSA, se transmiten las banderas <code>-Xanalyzer -analyzer-constraints=z3</code> . </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Repositorio de resultados de GitHub</a> </p><br><h2 id="ssylki">  Referencias </h2><br><ol><li><p>  Howard M., Leblanc D., Viega J. "Los 24 pecados de la seguridad inform√°tica" </p><br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥mo escribir un corrector en 24 horas</a> </p><br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Analizador est√°tico de Clang: una gu√≠a para desarrolladores de Checker</a> </p><br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Manual de desarrollo del verificador CSA</a> </p><br></li><li><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dietz W. y col.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Comprender el desbordamiento de enteros en C / C ++</a> </p><br></li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/473412/">https://habr.com/ru/post/473412/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../473394/index.html">¬°Todos ustedes mienten! Acerca de la publicidad CRM</a></li>
<li><a href="../473396/index.html">Necesitamos otro bitrix</a></li>
<li><a href="../473400/index.html">Tecnolog√≠a de texto a voz de alta calidad, ligera y adaptable que utiliza LPCNet</a></li>
<li><a href="../473406/index.html">Marat√≥n gratuito "Ciencia de datos e IA: ense√±a a la m√°quina a escribir el gui√≥n de la serie"</a></li>
<li><a href="../473408/index.html">Depuraci√≥n de p√©rdidas de memoria ocultas en Ruby</a></li>
<li><a href="../473416/index.html">Programa de conferencia ZeroNights 2019</a></li>
<li><a href="../473418/index.html">OSCP - Seguridad ofensiva</a></li>
<li><a href="../473420/index.html">Abrimos la temporada de encuentros PHP en Nizhny Novgorod el 2 de noviembre</a></li>
<li><a href="../473424/index.html">ARM anunci√≥ las soluciones gr√°ficas Mali-G57 Valhall y Mali-D37, neuroprocesadores Ethos-N57 y N37</a></li>
<li><a href="../473426/index.html">Automatizaci√≥n de pruebas End-2-End de un sistema de informaci√≥n integrado. Parte 1. Organizacional</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>