<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍💻 💛 👩🏾‍🎤 Revolution oder Schmerz? Yandex React Hooks-Bericht ⏸️ 🤾🏿 👨‍👨‍👦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Mein Name ist Artyom Berezin, ich bin Entwickler mehrerer interner Yandex-Dienste. In den letzten sechs Monaten habe ich aktiv mit React Hooks gearbei...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Revolution oder Schmerz? Yandex React Hooks-Bericht</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/464071/"> Mein Name ist Artyom Berezin, ich bin Entwickler mehrerer interner Yandex-Dienste.  In den letzten sechs Monaten habe ich aktiv mit React Hooks gearbeitet.  Dabei gab es einige Schwierigkeiten, die bekämpft werden mussten.  Jetzt möchte ich diese Erfahrung mit Ihnen teilen.  In dem Bericht habe ich die React Hook-API aus praktischer Sicht untersucht. Warum brauchen wir Hooks? Lohnt es sich zu wechseln, was beim Portieren besser zu berücksichtigen ist?  Es ist leicht, während des Übergangs Fehler zu machen, aber es ist auch nicht so schwierig, sie zu vermeiden. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/xm/xa/7n/xmxa7ngpjx3l902ndjcetpyhsp0.jpeg"></a> <br><br>  - Hooks sind nur eine weitere Möglichkeit, die Logik Ihrer Komponenten zu beschreiben.  Sie können den Funktionskomponenten einige Funktionen hinzufügen, die bisher nur Komponenten in Klassen eigen waren. <br><br><a name="habracut"></a><img src="https://habrastorage.org/webt/hd/r8/4b/hdr84b-fmfibqz-gwcb0k8feny8.jpeg"><br><br>  Zuallererst ist es Unterstützung für den internen Zustand, dann - Unterstützung für Nebenwirkungen.  Zum Beispiel - Netzwerkanforderungen oder Anforderungen an WebSocket: Abonnement, Abmeldung von einigen Kanälen.  Oder wir sprechen über Anfragen an andere asynchrone oder synchrone Browser-APIs.  Außerdem geben uns Haken Zugang zum Lebenszyklus der Komponente, zu ihrem Beginn des Lebens, dh zur Montage, zur Aktualisierung ihrer Requisiten und zu ihrem Tod. <br><br><img src="https://habrastorage.org/webt/9d/f4/lk/9df4lk5afueo28ftgmebxggxuw0.jpeg"><br><br>  Wahrscheinlich der einfachste Weg, um im Vergleich zu veranschaulichen.  Hier ist der einfachste Code, der nur mit einer Komponente in Klassen vorhanden sein kann.  Die Komponente verändert etwas.  Dies ist ein regulärer Zähler, der erhöht oder verringert werden kann, nur ein Feld im Status.  Im Allgemeinen denke ich, dass der Code für Sie völlig offensichtlich ist, wenn Sie mit React vertraut sind. <br><br><img src="https://habrastorage.org/webt/iy/ms/2_/iyms2_hexuxc_nx5cnxwux8crva.jpeg"><br><br>  Eine ähnliche Komponente, die genau dieselbe Funktion ausführt, jedoch in Hooks geschrieben ist, sieht viel kompakter aus.  Nach meinen Berechnungen nimmt der Code beim Portieren von Komponenten in Klassen zu Komponenten in Hooks im Durchschnitt etwa anderthalb Mal ab, und es gefällt ihm. <br><br>  Ein paar Worte darüber, wie Haken funktionieren.  Ein Hook ist eine globale Funktion, die in React deklariert und jedes Mal aufgerufen wird, wenn eine Komponente gerendert wird.  React verfolgt die Aufrufe dieser Funktionen und kann deren Verhalten ändern oder entscheiden, was zurückgegeben werden soll. <br><br><img src="https://habrastorage.org/webt/yy/wy/xf/yywyxfylah95eiqs8saijtqbf-a.jpeg"><br><br>  Es gibt einige Einschränkungen bei der Verwendung von Hooks, die sie von normalen Funktionen unterscheiden.  Erstens können sie nicht in Komponenten für Klassen verwendet werden. Eine solche Einschränkung gilt nur, weil sie nicht für sie erstellt wurden, sondern für funktionale Komponenten.  Hooks können nicht innerhalb interner Funktionen, innerhalb von Schleifen, Bedingungen aufgerufen werden.  Nur auf der ersten Ebene der Verschachtelung innerhalb der Komponentenfunktionen.  Diese Einschränkung wird von React selbst auferlegt, um verfolgen zu können, welche Hooks aufgerufen wurden.  Und er stapelt sie in einer bestimmten Reihenfolge in seinem Gehirn.  Wenn sich diese Reihenfolge plötzlich ändert oder einige verschwinden, sind komplexe, schwer fassbare und schwer zu debuggende Fehler möglich. <br><br>  Wenn Sie jedoch eine recht komplizierte Logik haben und beispielsweise Hooks in Hooks verwenden möchten, ist dies höchstwahrscheinlich ein Zeichen dafür, dass Sie einen Hook erstellen sollten.  Angenommen, Sie stellen mehrere Haken her, die in einem separaten benutzerdefinierten Haken miteinander verbunden sind.  Und darin können Sie andere benutzerdefinierte Hooks verwenden, wodurch eine Hierarchie von Hooks erstellt wird, die die allgemeine Logik dort hervorhebt. <br><br><img src="https://habrastorage.org/webt/wr/av/h_/wravh_lbocryqocrjlnwqs8rrr4.jpeg"><br><br>  Haken bieten einige Vorteile gegenüber Klassen.  Zunächst können Sie, wie im vorherigen Abschnitt beschrieben, mit benutzerdefinierten Hooks die Logik viel einfacher fummeln.  Zuvor haben wir unter Verwendung des Ansatzes mit Komponenten höherer Ordnung eine Art gemeinsame Logik entworfen, die die Komponente umhüllte.  Jetzt setzen wir diese Logik in Haken.  Dadurch wird der Komponentenbaum reduziert: Seine Verschachtelung wird reduziert, und es wird für React einfacher, Komponentenänderungen zu verfolgen, den Baum neu zu berechnen, das virtuelle DOM neu zu berechnen usw. Dies löst das Problem der sogenannten Wrapper-Hölle.  Ich denke, diejenigen, die mit Redux arbeiten, sind damit vertraut. <br><br>  Mit Hooks geschriebener Code lässt sich mit modernen Minimierern wie Terser oder altem UglifyJS viel einfacher minimieren.  Tatsache ist, dass wir die Namen von Methoden nicht speichern müssen, wir müssen nicht über Prototypen nachdenken.  Wenn das Ziel nach der Transpilation ES3 oder ES5 ist, erhalten wir normalerweise eine Reihe von Prototypen, die gepatcht werden.  Hier muss dies alles nicht getan werden, daher ist es einfacher zu minimieren.  Und da wir keine Klassen verwenden, müssen wir nicht darüber nachdenken.  Für Anfänger ist dies oft ein großes Problem und wahrscheinlich einer der Hauptgründe für Fehler: Wir vergessen, dass dies ein Fenster sein kann, dass wir eine Methode binden müssen, zum Beispiel im Konstruktor oder auf andere Weise. <br><br>  Durch die Verwendung von Hooks können Sie auch die Logik hervorheben, die einen Nebeneffekt steuert.  Bisher musste diese Logik, insbesondere wenn wir mehrere Nebenwirkungen für eine Komponente haben, in verschiedene Methoden des Lebenszyklus der Komponente unterteilt werden.  Und seit dem Erscheinen von Minimierungs-Hooks, React.memo, eignen sich nun funktionale Komponenten zum Auswendiglernen, dh diese Komponente wird bei uns nicht neu erstellt oder aktualisiert, wenn sich ihre Requisiten nicht geändert haben.  Dies war vorher nicht möglich, jetzt ist es möglich.  Alle Funktionskomponenten können in Memos verpackt werden.  Außerdem wurde der useMemo-Hook angezeigt, mit dem wir einige schwere Werte berechnen oder einige Dienstprogrammklassen nur einmal instanziieren können. <br><br>  Der Bericht wird unvollständig sein, wenn ich nicht über einige grundlegende Haken spreche.  Zuallererst sind dies State-Management-Hooks. <br><br><img src="https://habrastorage.org/webt/ud/wg/vl/udwgvlovxonthzvnknxeewerxea.jpeg"><br><br>  Zunächst einmal - useState. <br><br><img src="https://habrastorage.org/webt/0c/xb/pk/0cxbpky3iayxkvaxutbik_ohbcw.jpeg"><br><br>  Ein Beispiel ähnelt dem am Anfang des Berichts.  useState ist eine Funktion, die einen Anfangswert annimmt und ein Tupel aus dem aktuellen Wert und der Funktion zum Ändern dieses Werts zurückgibt.  Alle Magie wird von React intern serviert.  Wir können diesen Wert einfach entweder lesen oder ändern. <br><br>  Im Gegensatz zu Klassen können wir so viele Statusobjekte verwenden, wie wir benötigen. Der Status wird in logische Teile zerlegt, um sie nicht wie in Klassen in einem Objekt zu mischen.  Und diese Teile werden vollständig voneinander isoliert: Sie können unabhängig voneinander geändert werden.  Das Ergebnis dieses Codes: Wir ändern zwei Variablen, berechnen das Ergebnis und zeigen Schaltflächen an, mit denen wir die erste Variable hier und da und die zweite Variable hier und da ändern können.  Denken Sie an dieses Beispiel, denn später werden wir etwas Ähnliches tun, aber viel komplizierter. <br><br><img src="https://habrastorage.org/webt/qh/cb/7r/qhcb7rezzu2hu5ymyqw8nw1bl9e.jpeg"><br><br>  Es gibt einen solchen useState für Steroide für Redux-Liebhaber.  Sie können den Status mithilfe eines Reduzierers konsistenter ändern.  Ich denke, dass diejenigen, die mit Redux vertraut sind, nicht einmal erklären können, für diejenigen, die nicht vertraut sind, werde ich sagen. <br><br>  Ein Reduzierer ist eine Funktion, die einen Status akzeptiert, und ein Objekt, das normalerweise als Aktion bezeichnet wird und beschreibt, wie sich dieser Status ändern soll.  Genauer gesagt, es werden einige Parameter übergeben, und innerhalb des Reduzierers entscheidet es bereits abhängig von seinen Parametern, wie sich der Status ändert. Infolgedessen sollte ein neuer Status zurückgegeben und aktualisiert werden. <br><br><img src="https://habrastorage.org/webt/k6/5x/gd/k65xgdpidy6wnhmuxabw3sqqtk0.jpeg"><br><br>  Auf ungefähr diese Weise wird es im Komponentencode verwendet.  Wir haben einen useReducer-Hook, der eine Reducer-Funktion benötigt, und der zweite Parameter ist der Anfangswert des Zustands.  Gibt wie useState, den aktuellen Status und die Funktion zum Ändern zurück, ist dispatch.  Wenn Sie ein Aktionsobjekt an den Versand übergeben, rufen wir eine Statusänderung auf. <br><br><img src="https://habrastorage.org/webt/un/sl/ng/unslngsedmksssjrthxjmzhn7bu.jpeg"><br><br>  Sehr wichtige VerwendungEffekthaken.  Sie können der Komponente Nebenwirkungen hinzufügen, die eine Alternative zum Lebenszyklus darstellen.  In diesem Beispiel verwenden wir eine einfache Methode mit useEffect: Sie fordert lediglich einige Daten vom Server an, beispielsweise mit der API, und zeigt diese Daten auf der Seite an. <br><br><img src="https://habrastorage.org/webt/bb/tc/gf/bbtcgfyw89tgu_jarnwwaagxmnq.jpeg"><br><br>  UseEffect verfügt über einen erweiterten Modus. Wenn die an useEffect übergebene Funktion eine andere Funktion zurückgibt, wird diese Funktion im nächsten Zyklus aufgerufen, wenn dieser useEffect angewendet wird. <br><br>  Ich habe vergessen zu erwähnen, dass useEffect direkt nach dem Anwenden der Änderung auf das DOM asynchron aufgerufen wird.  Das heißt, es garantiert, dass es ausgeführt wird, nachdem die Komponente gerendert wurde, und kann zum nächsten Rendern führen, wenn sich einige Werte ändern. <br><br><img src="https://habrastorage.org/webt/gl/yd/cj/glydcjxiui-c60mgjzhnfobsqcm.jpeg"><br><br>  Hier begegnen wir zum ersten Mal einem Konzept wie Abhängigkeiten.  Einige Hooks - useEffect, useCallback, useMemo - verwenden ein Array von Werten als zweites Argument, mit dem wir sagen können, was verfolgt werden soll.  Änderungen in diesem Array führen zu Effekten.  Zum Beispiel haben wir hier hypothetisch eine Art Komponente für die Auswahl eines Autors aus einer Liste.  Und ein Teller mit Büchern dieses Autors.  Und wenn sich der Autor ändert, wird useEffect aufgerufen.  Wenn diese authorId geändert wird, wird eine Anfrage aufgerufen und Bücher werden geladen. <br><br>  Ich erwähne auch beim Übergeben von Hooks wie useRef, dass dies eine Alternative zu React.createRef ist, ähnlich wie useState, aber Änderungen an ref führen nicht zum Rendern.  Manchmal praktisch für einige Hacks.  Mit useImperativeHandle können wir bestimmte "öffentliche Methoden" für die Komponente deklarieren.  Wenn Sie useRef in der übergeordneten Komponente verwenden, können diese Methoden abgerufen werden.  Um ehrlich zu sein, habe ich es einmal zu Bildungszwecken versucht, in der Praxis war es nicht nützlich.  useContext ist nur eine gute Sache. Sie können den aktuellen Wert aus dem Kontext übernehmen, wenn der Anbieter diesen Wert irgendwo höher in der Hierarchieebene definiert hat. <br><br>  Es gibt eine Möglichkeit, React-Anwendungen an Hooks zu optimieren: Memoisierung.  Das Auswendiglernen kann in interne und externe unterteilt werden.  Zuerst über die Außenseite. <br><br><img src="https://habrastorage.org/webt/ao/wq/-e/aowq-evnbye1bnr6lspo9sthw9y.jpeg"><br><br>  Dies ist React.memo, praktisch eine Alternative zur React.PureComponent-Klasse, die Änderungen an Requisiten und geänderten Komponenten nur dann verfolgte, wenn sich Requisiten oder Status änderten. <br><br>  Hier ähnlich jedoch ohne Staat.  Es überwacht auch Änderungen an Requisiten, und wenn sich die Requisiten geändert haben, tritt ein Renderer auf.  Wenn sich die Requisiten nicht geändert haben, wird die Komponente nicht aktualisiert, und wir sparen dies. <br><br><img src="https://habrastorage.org/webt/lk/0l/dn/lk0ldneyzriaeesmzxfnvvkl1h4.jpeg"><br><br>  Interne Optimierungsmethoden.  Zuallererst ist dies eine eher einfache Sache - useMemo, selten verwendet.  Sie können einen Wert berechnen und nur dann neu berechnen, wenn sich die in den Abhängigkeiten angegebenen Werte geändert haben. <br><br><img src="https://habrastorage.org/webt/ve/fs/ml/vefsmlmbjqbg6-1lejt5_qofoow.jpeg"><br><br>  Es gibt einen Sonderfall von useMemo für eine Funktion namens useCallback.  Es wird hauptsächlich verwendet, um den Wert von Ereignishandlerfunktionen zu speichern, die an untergeordnete Komponenten übergeben werden, damit diese untergeordneten Komponenten nicht erneut gerendert werden können.  Es wird einfach verwendet.  Wir beschreiben eine bestimmte Funktion, verpacken sie in useCallback und geben an, von welchen Variablen sie abhängt. <br><br>  Viele Menschen haben eine Frage, aber brauchen wir diese?  Brauchen wir haken  Bewegen wir uns oder bleiben wir wie zuvor?  Es gibt keine einzige Antwort, alles hängt von den Vorlieben ab.  Erstens, wenn Sie direkt fest an die objektorientierte Programmierung gebunden sind und Ihre Komponenten als Klasse daran gewöhnt sind, haben sie Methoden, die abgerufen werden können, dann scheint Ihnen diese Sache wahrscheinlich überflüssig zu sein.  Im Prinzip schien es mir, als ich zum ersten Mal von Hooks hörte, dass es zu kompliziert war, dass eine Art Magie hinzugefügt wurde und es nicht klar war, warum. <br><br>  Für Liebhaber von Funktionalitäten ist dies beispielsweise ein Muss, da Hooks Funktionen sind und funktionale Programmiertechniken auf sie anwendbar sind.  Sie können sie beispielsweise kombinieren oder überhaupt etwas tun, indem Sie beispielsweise Bibliotheken wie Ramda und dergleichen verwenden. <br><br><img src="https://habrastorage.org/webt/du/k4/n7/duk4n7l_1_are_xjgrkf4vvbccy.jpeg"><br><br>  Da wir Klassen losgeworden sind, müssen wir diesen Kontext nicht mehr an Methoden binden.  Wenn Sie diese Methoden als Rückruf verwenden.  Normalerweise war dies ein Problem, da Sie daran denken mussten, sie im Konstruktor zu binden oder eine inoffizielle Erweiterung der Sprachsyntax zu verwenden, z. B. Pfeilfunktionen als Eigenschaft.  Ziemlich übliche Praxis.  Ich habe meinen Dekorateur benutzt, der im Prinzip auch experimentell auf Methoden basiert. <br><br><img src="https://habrastorage.org/webt/pn/ew/fi/pnewfifb1wwktxkbddh1zqqk-os.jpeg"><br><br>  Es gibt einen Unterschied darin, wie der Lebenszyklus funktioniert und wie er verwaltet wird.  Hooks verknüpfen fast alle Lebenszyklusaktionen mit dem useEffect-Hook, mit dem Sie sowohl die Geburt als auch die Aktualisierung einer Komponente und deren Tod abonnieren können.  In den Klassen mussten wir dafür verschiedene Methoden neu definieren, z. B. componentDidMount, componentDidUpdate und componentWillUnmount.  Außerdem sollte die shouldComponentUpdate-Methode jetzt durch React.memo ersetzt werden. <br><br><img src="https://habrastorage.org/webt/7d/ae/qy/7daeqyxv0yh0on4i1wcdsraoaws.jpeg"><br><br>  Es gibt einen relativ kleinen Unterschied im Umgang mit dem Staat.  Erstens haben Klassen ein Zustandsobjekt.  Wir mussten dort alles stopfen.  In Hooks können wir den logischen Zustand in einige Teile zerlegen, was für uns praktisch wäre, wenn wir separat arbeiten würden. <br><br>  setState () von Komponenten in Klassen, die einen Status-Patch angeben dürfen, wodurch ein oder mehrere Felder des Status geändert werden.  In Hooks müssen wir den gesamten Zustand als Ganzes ändern, und das ist sogar gut so, denn es ist in Mode, alle möglichen unveränderlichen Dinge zu verwenden und niemals zu erwarten, dass unsere Objekte mutieren.  Sie sind immer neu bei uns. <br><br>  Das Hauptmerkmal von Klassen, die Hooks nicht haben: Wir könnten Statusänderungen abonnieren.  Das heißt, wir ändern den Status und abonnieren sofort seine Änderungen, wobei wir unmittelbar nach dem Anwenden der Änderungen unbedingt etwas verarbeiten müssen.  Bei Hooks funktioniert dies einfach nicht.  Dies muss auf sehr interessante Weise geschehen, ich werde es Ihnen weiter erzählen. <br><br>  Und ein wenig über die funktionale Art der Aktualisierung.  Es funktioniert sowohl dort als auch dort, wenn die Statusänderungsfunktionen eine andere Funktion akzeptieren, die dieser Status nicht ändern, sondern erstellen soll.  Und wenn im Fall der Klassenkomponente eine Art Patch an uns zurückgegeben werden kann, müssen wir in den Hooks den gesamten neuen Wert zurückgeben. <br><br>  Im Allgemeinen ist es unwahrscheinlich, dass Sie eine Antwort erhalten, ob Sie sich bewegen oder nicht.  Aber ich rate zumindest, zumindest für den neuen Code zu versuchen, ihn zu fühlen.  Als ich gerade anfing, mit Hooks zu arbeiten, identifizierte ich sofort mehrere benutzerdefinierte Hooks, die für mich für mein Projekt geeignet sind.  Grundsätzlich habe ich versucht, einige der Funktionen zu ersetzen, die ich durch Komponenten höherer Ordnung implementiert hatte. <br><br><img src="https://habrastorage.org/webt/d6/cs/1-/d6cs1-ebiop8wbrdgnrr93wskqm.jpeg"><br><br>  useDismounted - Für diejenigen, die mit RxJS vertraut sind, besteht die Möglichkeit, alle Observable innerhalb einer Komponente oder innerhalb einer Funktion in großen Mengen abzubestellen, indem jedes Observable ein spezielles Objekt, Subject, abonniert wird. Wenn es geschlossen wird, werden alle Abonnements gekündigt.  Dies ist sehr praktisch, wenn die Komponente komplex ist und wenn im Observable viele asynchrone Vorgänge vorhanden sind. Es ist praktisch, sich von allen gleichzeitig und nicht von jedem einzeln abzumelden. <br><br>  useObservable gibt einen Wert von Observable zurück, wenn dort ein neuer angezeigt wird.  Ein ähnlicher useBehaviourSubject-Hook wird von BehaviourSubject zurückgegeben.  Der Unterschied zu Observable besteht darin, dass es zunächst eine Bedeutung hat. <br><br>  Mit dem praktischen benutzerdefinierten Hook useDebounceValue können wir beispielsweise einen Sujest für die Suchzeichenfolge organisieren, sodass nicht jedes Mal, wenn Sie eine Taste drücken, etwas an den Server gesendet wird, sondern gewartet wird, bis der Benutzer die Eingabe beendet hat. <br><br>  Zwei ähnliche Haken.  useWindowResize gibt aktuelle Istwerte für Fenstergrößen zurück.  Der nächste Haken für die Bildlaufposition ist useWindowScroll.  Ich benutze sie, um einige Popups oder modale Fenster wiederzugeben, wenn es komplizierte Dinge gibt, die mit CSS einfach nicht möglich sind. <br><br>  Und so ein kleiner Haken zum Implementieren von Hotkeys, den die Komponente, wenn sie auf der Seite vorhanden ist, mit einem Hotkey abonniert.  Wenn er stirbt, erfolgt eine automatische Abmeldung. <br><br>  Wofür sind diese benutzerdefinierten Haken geeignet?  Dass wir ein Abbestellen innerhalb des Hooks stopfen können und nicht daran denken müssen, das Abmelden irgendwo in der Komponente, in der dieser Hook verwendet wird, manuell abzubestellen. <br><br>  Vor nicht allzu langer Zeit warfen sie mir einen Link zur React-Use-Bibliothek, und es stellte sich heraus, dass die meisten dieser benutzerdefinierten Hooks dort bereits implementiert waren.  Und ich habe ein Fahrrad geschrieben.  Dies ist manchmal nützlich, aber in Zukunft werde ich sie höchstwahrscheinlich wegwerfen und React-Use verwenden.  Und ich rate Ihnen, auch zu prüfen, ob Sie Haken verwenden möchten. <br><br><img src="https://habrastorage.org/webt/03/ls/_r/03ls_rryjcv9gax_wky56kv0hye.jpeg"><br><br>  Das Hauptziel des Berichts ist es, zu zeigen, wie man falsch schreibt, welche Probleme auftreten können und wie man sie vermeidet.  Das allererste, wahrscheinlich, was jeder, der diese Hooks studiert und versucht, etwas zu schreiben, ist, useEffect falsch zu verwenden.  Hier ist der Code ähnlich dem, den 100% jeder geschrieben hat, wenn er Hooks ausprobiert hat.  Dies liegt an der Tatsache, dass useEffect zunächst mental als Alternative zu componentDidMount wahrgenommen wird.  Im Gegensatz zu componentDidMount, das nur einmal aufgerufen wird, wird useEffect bei jedem Rendering aufgerufen.  Und der Fehler hier ist, dass es beispielsweise die Datenvariable ändert und gleichzeitig zu einem Komponenten-Renderer führt, wodurch der Effekt erneut angefordert wird.  Auf diese Weise erhalten wir eine endlose Reihe von AJAX-Anforderungen an den Server, und die Komponente selbst wird ständig aktualisiert, aktualisiert, aktualisiert. <br><br><img src="https://habrastorage.org/webt/ds/jw/cl/dsjwclnhk6kvmnmkxjw04vdrqd8.jpeg"><br><br>  Das Problem zu beheben ist sehr einfach.  Sie müssen hier ein leeres Array der Abhängigkeiten hinzufügen, von denen es abhängt, und Änderungen, bei denen der Effekt neu gestartet wird.  Wenn hier eine leere Liste von Abhängigkeiten angegeben ist, wird der Effekt dementsprechend nicht neu gestartet.  Dies ist keine Art von Hack, sondern eine grundlegende Funktion der Verwendung von useEffect. <br><br><img src="https://habrastorage.org/webt/tx/bw/it/txbwitnnldk_y5r-bf0f4pss7eg.jpeg"><br><br>  Nehmen wir an, wir haben es behoben.  Jetzt etwas kompliziert.  Wir haben eine Komponente, die etwas rendert, das für eine Art ID vom Server übernommen werden muss.  In diesem Fall funktioniert im Prinzip alles einwandfrei, bis wir die entityId im übergeordneten Element ändern. Dies ist möglicherweise für Ihre Komponente nicht relevant. <br><br><img src="https://habrastorage.org/webt/2e/pl/tx/2epltxjdup5yia7c6gsepl-o7xo.jpeg"><br><br>  Wenn es sich jedoch ändert oder geändert werden muss und Sie eine alte Komponente auf Ihrer Seite haben und sich herausstellt, dass sie nicht aktualisiert wird, ist es am besten, hier eine EntityId als Abhängigkeit hinzuzufügen, die die Aktualisierung verursacht und die Daten aktualisiert. <br><br><img src="https://habrastorage.org/webt/rd/lc/ep/rdlcepf4e8lzq8ersyffn8ydqgs.jpeg"><br><br>  Ein komplexeres Beispiel mit useCallback.  Hier ist auf den ersten Blick alles in Ordnung.  Wir haben eine bestimmte Seite, die eine Art Countdown-Timer hat, oder umgekehrt einen Timer, der nur tickt.  Eine Liste von Hosts und darüber hinaus Filter, mit denen Sie diese Liste von Hosts filtern können.  Nun, hier wurde Wartung hinzugefügt, um einen sich häufig ändernden Wert zu veranschaulichen, der in einen Renderer übersetzt wird. <br><br>    ,   ,    maintenance    ,   ,   ,      onChange.     onChange,        .  ,  HostFilters - , ,      dropdown,     .       ,    .  ,       . <br><br><img src="https://habrastorage.org/webt/bb/08/q1/bb08q1gwb5jzadcu0-bl1w0xsy0.jpeg"><br><br>     onChange    useCallback.         ,      . <br><br>    ,   . , ,  .      Facebook,   React.  , , ,  ,  '.     ,  ,  confusing . <br><br><img src="https://habrastorage.org/webt/xw/lv/et/xwlvetymaukrlaxd7t5cctegg-8.jpeg"><br><br>     ?        —     ,   -  , ,     ,      ,  ,         .         . <br><br> ,    ,          ,     ,      ,     , .  , Garbage Collector      ,    .  , ,     ,    ,    .   , , ,       reducer,     ,          . ,      . <br><br>    ,     ,   .     - , ,   setValue  - ,            ,   setState     .   -       useEffect. <br><br>   useEffect   -  ,   -  , ,   ,    useEffect.     useEffect     ,   .        ,    ,  Backbone,  : ,     ,  ,        -  .      ,    ,  -   ,  .    -   . ,  ,      ,    ,    -  . ,  ,  ,   , ,    ,  .     . <br><br>   ,   ,  . ,        ,     .           ,      .        ,     .  ,    , , dropdown  .   ,     .    dropdown  pop-up,     useWindowScroll, useWindowResize         ,  .         ,      , —  ,   . <br><br>        ,   ,  . ,       , ,   ,     ,       . , ,   ,      ,   ,         . <br><br><img src="https://habrastorage.org/webt/-r/tu/f_/-rtuf_bbscg5l9i4-oaeh-xpu80.jpeg"><br><br>   ,     «»,   . ,     ,   TypeScript    .      .    ,  reducer  Redux ,    action.  ,   action    ,     action.   ,   ,     ,  . <br><br>    .  ,        action.     ,     , IncrementA  0,  1, 2,   .         . ,    , ,  ,       .     action     action,   -     .   UnionType “Action”,         ,   ,    action.   . <br><br>   —     . ,   initialState,  .   ,       -  .       TypeScript.     . ,    typeState   ,   initialState. <br><br><img src="https://habrastorage.org/webt/_i/fg/79/_ifg793-qpfaiwittpdhffve_zw.jpeg"><br><br>       reducer.   State, Action,    :   switch  action.type.  TypeScript      UnionType:       case,      - ,    type.           action   . <br><br> ,  :  ,    ,     .  . <br><br><img src="https://habrastorage.org/webt/6r/8v/or/6r8vordbm6xpl9og288kzvrgewk.jpeg"><br><br>   ?  ,     .      .      ,   reducer. ,   action creator  ,   ,       dispatch. <br><br><img src="https://habrastorage.org/webt/vg/tg/aw/vgtgawewmkwgpr5su4c24n7hgo8.jpeg"><br><br>     extension   Dev Tools.            .    . <br><br>  ,  ,    .   ,     ,     .      useDebugValue ,        -    Dev Tool.        useConstants,       - , loaded,  ,     ,  . <br><br><img src="https://habrastorage.org/webt/rt/cc/sg/rtccsggw9kekwpt75gmvnwd_w2u.jpeg"><br><br>   —  .  ,     .     ,        .    ,   ,  ,    .     ,   ,          —   -       ,   —   . <br><br>   .  Facebook     ESLint,       .      ,  , .    ,   dependencies  .     ,    ,    ,     . <br><br>       ,  ,     ,  -   ,     .     ,   ,   ,       . .       ,    -   - . <br><br>    —       , ,  - .   ,    ,    .      ,   ,  -      . ,             .      .  Nützliche Links: <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">«React hooks —   ?»</a> C     .       ,    ,    ,      ,    . </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">   useEffect</a> .  ,   ,      ,   ,   ,     . . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">«useReducer vs useState in React»</a> ,    useReducer,      useState. :     ,  ,    ,    useReducer.    - ,   useState   . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">React Hooks CheatSheets</a> c      . </li><li>   . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Usehooks.com</a> —   , .     .     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">react-use</a> — ,       ,     . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de464071/">https://habr.com/ru/post/de464071/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de464045/index.html">Wie ich 1997 fast in Echtzeit Rennstrecken gefahren bin</a></li>
<li><a href="../de464053/index.html">Hinweis: Spurauswahl- und Rotationsalgorithmus</a></li>
<li><a href="../de464055/index.html">Wir untersuchen die von Xiaomi Mi Band für das Jahr gesammelten Daten</a></li>
<li><a href="../de464057/index.html">Hilbert, Lebesgue ... und die Leere</a></li>
<li><a href="../de464063/index.html">Kabel 2019 abschneiden</a></li>
<li><a href="../de464075/index.html">Einführung in C. Botschaft aus dem letzten Jahrhundert</a></li>
<li><a href="../de464077/index.html">Nein, Sie brauchen kein Delta mit 50 km / s. Sie benötigen additive Technologien (Teil 1)</a></li>
<li><a href="../de464079/index.html">Wie man ein horizontales Start- und Landungsraumschiff ohne Wundertechnologie baut</a></li>
<li><a href="../de464083/index.html">Wie ITSM hilft und wer diese Methode anwendet</a></li>
<li><a href="../de464089/index.html">Automatisierung von HTTP-Anforderungen im Kontext von Spring</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>