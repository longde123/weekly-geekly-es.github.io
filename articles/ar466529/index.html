<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>⚪️ 👠 👳 أنواع التجميع في JVM: تعريض جلسة السحر الأسود 🍉 🧛🏽 👩🏼‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="مرحبا بالجميع! 

 اليوم ، يتم توجيه انتباهك إلى ترجمة المقالة ، والتي تعرض أمثلة على خيارات الترجمة في JVM. يتم إيلاء اهتمام خاص لمجموعة AOT المدعومة ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>أنواع التجميع في JVM: تعريض جلسة السحر الأسود</h1><div class="post__body post__body_full" style=";text-align:right;direction:rtl"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/466529/" style=";text-align:right;direction:rtl">  مرحبا بالجميع! <br><br>  اليوم ، يتم توجيه انتباهك إلى ترجمة المقالة ، والتي تعرض أمثلة على خيارات الترجمة في JVM.  يتم إيلاء اهتمام خاص لمجموعة AOT المدعومة في Java 9 والإصدارات الأحدث. <br><br>  هل لديك قراءة لطيفة! <br><a name="habracut"></a><br>  أفترض أن أي شخص قام ببرمجة في Java قد سمع عن الترجمة الفورية (JIT) ، وربما التجميع قبل التنفيذ (AOT).  بالإضافة إلى ذلك ، ليست هناك حاجة لشرح اللغات "المفسرة".  تشرح هذه المقالة كيفية تنفيذ كل هذه الميزات في جهاز Java الظاهري ، JVM. <br><br>  ربما تعلم أنه عند البرمجة في Java ، ستحتاج إلى تشغيل مترجم (باستخدام برنامج "javac") الذي يجمع شفرة مصدر Java (ملفات .java) في Java bytecode (ملفات .class).  جافا بايت هو لغة وسيطة.  يطلق عليه "متوسط" لأنه لا يفهمه جهاز حوسبة حقيقي (CPU) ولا يمكن تنفيذه بواسطة جهاز كمبيوتر ، وبالتالي ، يمثل نموذجًا انتقاليًا بين الكود المصدر ورمز الجهاز "الأصلي" الذي تم تنفيذه في المعالج. <br><br>  لكي يقوم Java bytecode بأداء أي عمل محدد ، هناك 3 طرق للحصول عليه للقيام بذلك: <br><br><ol style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  مباشرة تنفيذ التعليمات البرمجية الوسيطة.  من الأفضل والأكثر صحة القول أنه يحتاج إلى "تفسير".  JVM لديه مترجم جافا.  كما تعلمون ، لكي تعمل JVM ، فأنت بحاجة إلى تشغيل برنامج "java". </li><li style=";text-align:right;direction:rtl">  قبل تنفيذ الشفرة الوسيطة ، قم بتجميعها إلى رمز أصلي واجبر وحدة المعالجة المركزية على تنفيذ هذا الكود الأصلي الطازج.  وبالتالي ، يتم التجميع قبل التنفيذ مباشرة (فقط في الوقت المناسب) ويسمى "ديناميكي". </li><li style=";text-align:right;direction:rtl">  3 أول شيء ، حتى قبل إطلاق البرنامج ، يتم ترجمة الشفرة الوسيطة إلى لغة أصلية وتشغيلها من خلال وحدة المعالجة المركزية من البداية إلى النهاية.  يتم هذا التجميع قبل التنفيذ ويسمى AoT (Ahead of Time). </li></ol><br>  لذلك ، (1) هو عمل المترجم الفوري ، (2) هو نتيجة تجميع JIT ، و (3) هو نتيجة تجميع AOT. <br><br>  من أجل الاكتمال ، سأذكر أن هناك طريقة رابعة - لتفسير الكود المصدري مباشرةً ، لكن هذا في Java غير مقبول.  يتم ذلك ، على سبيل المثال ، في بيثون. <br>  الآن دعنا نرى كيف يعمل "java" كـ (1) مترجم (2) مترجم JIT و / أو (3) مترجم AOT - ومتى. <br><br>  باختصار - كقاعدة عامة ، "java" تقوم بكل من (1) و (2).  بدءًا من Java 9 ، هناك خيار ثالث ممكن أيضًا. <br><br>  هنا فئة <code>Test</code> بنا ، والتي سيتم استخدامها في الأمثلة المستقبلية. <br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Test</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">1</span></span>; i &lt;= <span class="hljs-number"><span class="hljs-number">10</span></span>; i++) { System.out.println(<span class="hljs-string"><span class="hljs-string">"call "</span></span> + Integer.valueOf(i)); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> a = System.nanoTime(); <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Test().f(); <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> b = System.nanoTime(); System.out.println(<span class="hljs-string"><span class="hljs-string">"elapsed= "</span></span> + (ba)); } } }</code> </pre> <br>  كما ترون ، هناك طريقة <code>main</code> تعمل على إنشاء كائن <code>Test</code> وتستدعي الدالة <code>f</code> بشكل دوري 10 مرات على التوالي.  وظيفة <code>f</code> لا تفعل شيئا تقريبا. <br><br>  لذلك ، إذا قمت بترجمة وتشغيل الشفرة أعلاه ، فسيكون الإخراج متوقعًا تمامًا (بالطبع ، ستختلف قيم الوقت المنقضي عنك): <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">call 1 elapsed= 5373 call 2 elapsed= 913 call 3 elapsed= 654 call 4 elapsed= 623 call 5 elapsed= 680 call 6 elapsed= 710 call 7 elapsed= 728 call 8 elapsed= 699 call 9 elapsed= 853 call 10 elapsed= 645</code> </pre> <br>  والسؤال المطروح الآن هو: هل هذا الاستنتاج هو نتيجة عمل "java" كمترجم ، أي الخيار (1) ، "java" كمترجم JIT ، أي الخيار (2) أو هل هو مرتبط بطريقة ما بتجميع AOT ، وهذا هو ، الخيار (3)؟  في هذه المقالة سأجد الإجابات الصحيحة على كل هذه الأسئلة. <br><br>  الإجابة الأولى التي أريد تقديمها هي على الأرجح (1) فقط تحدث هنا.  أقول "على الأرجح" ، لأنني لا أعرف إذا تم تعيين أي متغير بيئة هنا من شأنه تغيير خيارات JVM الافتراضية.  إذا لم يتم تثبيت أي شيء لا لزوم له ، وهذه هي الطريقة التي يعمل بها "java" افتراضيًا ، فنحن هنا نراقب الخيار فقط بنسبة 100٪ ، أي يتم تفسير الشفرة بالكامل.  أنا متأكد من هذا ، منذ: <br><br><ul style=";text-align:right;direction:rtl"><li style=";text-align:right;direction:rtl">  وفقًا لوثائق java ، يتم تشغيل <code>-XX:CompileThreshold=invocations</code> مع <code>invocations=1500</code> الافتراضية <code>invocations=1500</code> على JVM للعميل (يتم شرح المزيد عن العميل JVM أدناه).  منذ أن قمت بتشغيله 10 مرات فقط و 10 &lt;1500 ، لا نتحدث عن تجميع ديناميكي هنا.  عادةً ما يحدد خيار سطر الأوامر هذا عدد المرات (الحد الأقصى) التي يجب أن يتم تفسير الوظيفة قبل بدء خطوة التحويل الديناميكي.  سوف أسهب في هذا أدناه. </li><li style=";text-align:right;direction:rtl">  في الواقع ، قمت بتشغيل هذا الرمز مع أعلام التشخيص ، لذلك أعرف ما إذا كان تم تجميعه ديناميكيًا.  سأشرح أيضًا هذه النقطة أدناه. </li></ul><br>  يرجى ملاحظة: JVM يمكن أن تعمل في وضع العميل أو الخادم ، والخيارات التي تم تعيينها بشكل افتراضي في الحالتين الأولى والثانية ستكون مختلفة.  كقاعدة عامة ، يتم اتخاذ القرار بشأن وضع بدء التشغيل تلقائيًا ، اعتمادًا على البيئة أو الكمبيوتر حيث تم تشغيل JVM.  فيما يلي ، <code>–client</code> خيار <code>–client</code> خلال جميع عمليات التشغيل ، حتى لا أشك في أن البرنامج يعمل في وضع العميل.  لن يؤثر هذا الخيار على الجوانب التي أريد إظهارها في هذا المنشور. <br><br>  إذا قمت بتشغيل "java" باستخدام <code>-XX:PrintCompilation</code> ، فسيقوم البرنامج بطباعة سطر عند تجميع الوظيفة ديناميكيًا.  لا تنس أن يتم إجراء ترجمة JIT لكل وظيفة على حدة ، فقد تظل بعض الوظائف في الفصل في رمز ثانوي (أي ، ليس مترجم) ، في حين أن البعض الآخر قد اجتاز بالفعل ترجمة JIT ، وهذا جاهز للتنفيذ المباشر في المعالج . <br><br>  أدناه أنا أيضا إضافة خيار <code>-Xbatch</code> .  هناك حاجة إلى خيار <code>-Xbatch</code> فقط لجعل الإخراج أكثر ملاءمة.  بخلاف ذلك ، يستمر تجميع JIT بشكل تنافسي (إلى جانب التفسير) ، وقد يبدو الإخراج بعد <code>-XX:PrintCompilation</code> في بعض الأحيان غريبًا في وقت التشغيل (بسبب - <code>-XX:PrintCompilation</code> ).  ومع ذلك ، فإن الخيار <code>–Xbatch</code> يعطل ترجمة الخلفية ، وبالتالي ، قبل تنفيذ ترجمة JIT ، سيتم إيقاف تنفيذ برنامجنا. <br><br>  (من أجل سهولة القراءة ، سأكتب كل خيار من سطر جديد) <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">$ java -client -Xbatch -XX:+PrintCompilation Test</code> </pre> <br>  لن أدرج مخرجات هذا الأمر هنا ، لأن JVM يجمع العديد من الوظائف الداخلية افتراضيًا (مثل ، على سبيل المثال ، حزم java و sun و jdk) ، وبالتالي فإن الإخراج سيكون طويل جدًا - لذلك ، على شاشتي ، هناك 274 سطرًا في الوظائف الداخلية ، وأكثر من ذلك - إلى غاية البرنامج).  لتسهيل هذا البحث ، سأقوم بإلغاء تجميع JIT للفئات الداخلية أو تمكينه بشكل انتقائي فقط <code>Test.f</code> ( <code>Test.f</code> ).  للقيام بذلك ، حدد خيارًا آخر ، <code>-XX:CompileCommand</code> .  يمكنك تحديد العديد من الأوامر (التحويل البرمجي) ، لذلك سيكون من الأسهل وضعها في ملف منفصل.  لحسن الحظ ، لدينا خيار <code>-XX:CompileCommandFile</code> .  لذلك ، انتقل إلى إنشاء الملف.  سوف أسميها <code>hotspot_compiler</code> لسبب <code>hotspot_compiler</code> قريبًا وأكتب ما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">quiet exclude java/* * exclude jdk/* * exclude sun/* *</code> </pre> <br>  في هذه الحالة ، يجب أن يكون من الواضح تمامًا أننا نستبعد جميع الوظائف (الأخيرة *) في جميع الفئات من جميع الحزم التي تبدأ بـ java و jdk و sun (يتم فصل أسماء الحزم بـ / ، ويمكنك استخدام *).  يخبر الأمر <code>quiet</code> JVM بعدم كتابة أي شيء عن الفئات المستبعدة ، لذلك فقط تلك التي يتم تجميعها الآن سيتم إخراجها إلى وحدة التحكم.  لذلك ، أركض: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">java -client -Xbatch -XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler Test</code> </pre> <br>  قبل إخبارك بإخراج هذا الأمر ، أذكرك بأنني قمت بتسمية هذا الملف <code>hotspot_compiler</code> ، لأنه يبدو (لم <code>.hotspot_compiler</code> ) أنه في Oracle JDK ، يتم تعيين الاسم <code>.hotspot_compiler</code> افتراضيًا للملف باستخدام أوامر برنامج التحويل البرمجي. <br><br>  لذلك الاستنتاج هو: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">many lines like this 111 1 n 0 java.lang.invoke.MethodHandle::linkToStatic(LLLLLL)L (native) (static) call 1 some more lines like this 161 48 n 0 java.lang.invoke.MethodHandle::linkToStatic(ILIJL)I (native) (static) elapsed= 7558 call 2 elapsed= 1532 call 3 elapsed= 920 call 4 elapsed= 732 call 5 elapsed= 774 call 6 elapsed= 815 call 7 elapsed= 767 call 8 elapsed= 765 call 9 elapsed= 757 call 10 elapsed= 868</code> </pre> <br>  أولاً ، لا أعرف لماذا لا تزال بعض أساليب <code>java.lang.invoke.MethodHandler.</code>  ربما ، بعض الأشياء فقط لا يمكن إيقاف.  كما فهمت ما الأمر ، فسوف أقوم بتحديث هذا المنشور.  ومع ذلك ، كما ترون ، فقد اختفت الآن جميع خطوات الترجمة (سابقًا كانت هناك 274 سطرًا).  في أمثلة أخرى ، سأقوم أيضًا بإزالة <code>java.lang.invoke.MethodHandler</code> من إخراج سجل التحويل البرمجي. <br><br>  دعونا نرى ما وصلنا إليه.  الآن لدينا رمز بسيط حيث ندير وظيفتنا 10 مرات.  لقد ذكرت سابقًا أن هذه الوظيفة يتم تفسيرها ، وليس تجميعها ، كما هو موضح في الوثائق ، والآن نراها في السجلات (في الوقت نفسه ، لا نراها في سجلات الترجمة ، وهذا يعني أنها لا تخضع لتجميع JIT).  حسنًا ، لقد رأيت للتو أداة "java" تعمل ، وتفسير وتفسير وظيفتنا فقط في 100٪ من الحالات.  لذلك ، يمكننا تحديد المربع الذي برز بالخيار (1).  نمر إلى (2) ، تجميع ديناميكي. <br><br>  وفقًا للوثائق ، يمكنك تشغيل الوظيفة 1500 مرة والتأكد من أن تجميع JIT يحدث بالفعل.  ومع ذلك ، يمكنك أيضًا استخدام <code>-XX:CompileThreshold=invocations</code> استدعاء <code>-XX:CompileThreshold=invocations</code> ، وتحديد القيمة المطلوبة بدلاً من 1500.  دعنا نشير هنا 5. هذا يعني أننا نتوقع ما يلي: بعد 5 "تفسيرات" من وظيفتنا f ، يجب على JVM ترجمة الطريقة ، ثم تشغيل الإصدار المترجم. <br>  جافا-العميل -Xbatch <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">-XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler -XX:CompileThreshold=5 Test</code> </pre> <br>  إذا قمت بتشغيل هذا الأمر ، فربما لاحظت أنه لم يتغير شيء مقارنة بالمثال أعلاه.  وهذا هو ، لا يزال لا يحدث تجميع.  اتضح ، وفقًا للوثائق ، <code>-XX:CompileThreshold</code> لا يعمل إلا عند تعطيل <code>TieredCompilation</code> ، وهو الافتراضي.  يتم <code>-XX:-TieredCompilation</code> مثل هذا: <code>-XX:-TieredCompilation</code> .  Tiered Compilation هي ميزة تم تقديمها في Java 7 لتحسين كل من إطلاق وسرعة الانطلاق في JVM.  في سياق هذا المنشور ، ليس من المهم ، لذلك لا تتردد في تعطيله.  لنقم الآن بتشغيل هذا الأمر مرة أخرى: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">java -client -Xbatch -XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler -XX:CompileThreshold=5 -XX:-TieredCompilation Test</code> </pre> <br>  هنا هو الإخراج (أذكر ، لقد فاتني الأسطر المتعلقة <code>java.lang.invoke.MethodHandle</code> ): <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">call 1 elapsed= 9411 call 2 elapsed= 1291 call 3 elapsed= 862 call 4 elapsed= 1023 call 5 227 56 b Test::&lt;init&gt; (5 bytes) 228 57 b Test::f (4 bytes) elapsed= 1051739 call 6 elapsed= 18516 call 7 elapsed= 940 call 8 elapsed= 769 call 9 elapsed= 855 call 10 elapsed= 838</code> </pre> <br>  نرحب (مرحبًا!) الدالة المترجمة ديناميكيًا Test.f أو <code>Test::&lt;init&gt;</code> مباشرةً بعد الاتصال بالرقم 5 ، لأنني قمت بتعيين CompileThreshold على 5. تفسر JVM الوظيفة 5 مرات ، ثم تقوم بترجمتها ثم تشغيل الإصدار المترجم أخيرًا.  نظرًا لأن الوظيفة يتم تصنيفها ، يجب أن تعمل بشكل أسرع ، لكن لا يمكننا التحقق من ذلك هنا ، لأن هذه الوظيفة لا تفعل شيئًا.  أعتقد أن هذا موضوع جيد لوظيفة منفصلة. <br><br>  كما قد تكون خمنت بالفعل ، يتم تجميع وظيفة أخرى هنا ، وهي <code>Test::&lt;init&gt;</code> ، وهو مُنشئ لفئة <code>Test</code> .  نظرًا لأن الرمز يستدعي المُنشئ ( <code>Test()</code> الجديد) ، فكلما <code>f</code> استدعاء <code>f</code> ، يتم تجميعه في نفس الوقت مع الدالة <code>f</code> ، بعد 5 مكالمات تمامًا. <br><br>  من حيث المبدأ ، يمكن أن ينهي هذا مناقشة الخيار (2) ، تجميع JIT.  كما ترون ، في هذه الحالة ، يتم تفسير الوظيفة أولاً بواسطة JVM ، ثم يتم تجميعها ديناميكيًا بعد تفسير خمسة أضعاف.  أرغب في إضافة التفاصيل الأخيرة المتعلقة <code>-XX:+PrintAssembly</code> JIT ، أي ذكر الخيار <code>-XX:+PrintAssembly</code> .  كما يوحي الاسم ، فإنه يخرج إلى وحدة التحكم نسخة مترجمة من الوظيفة (إصدار مترجم = كود الجهاز الأصلي = رمز المجمع).  ومع ذلك ، لن يعمل هذا إلا إذا كان هناك مفكك في مسار المكتبة.  أعتقد أن disassembler قد يختلف في JVMs مختلفة ، ولكن في هذه الحالة نحن نتعامل مع hsdis - disassembler for openjdk.  يمكن الحصول على الكود المصدري لمكتبة hsdis أو ملفها الثنائي في أماكن مختلفة.  في هذه الحالة ، قمت بتجميع هذا الملف ووضع <code>hsdis-amd64.so</code> في <code>JAVA_HOME/lib/server</code> . <br><br>  حتى الآن يمكننا تنفيذ هذا الأمر.  لكن أولاً يجب أن أضيف ذلك لتشغيل <code>-XX:+PrintAssembly</code> تحتاج أيضًا إلى إضافة خيار <code>-XX:+UnlockDiagnosticVMOptions</code> ، ويجب أن يتبع قبل خيار <code>PrintAssembly</code> .  إذا لم يتم ذلك ، <code>PrintAssembly</code> لك JVM تحذيرًا بشأن الاستخدام غير <code>PrintAssembly</code> لخيار <code>PrintAssembly</code> .  لنقم بتشغيل هذا الكود: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">java -client -Xbatch -XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler -XX:CompileThreshold=5 -XX:-TieredCompilation -XX:+UnlockDiagnosticVMOptions -XX:+PrintAssembly Test</code> </pre> <br>  سيكون الإخراج طويلًا ، وسيكون هناك خطوط مثل: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">0x00007f4b7cab1120: mov 0x8(%rsi),%r10d 0x00007f4b7cab1124: shl $0x3,%r10 0x00007f4b7cab1128: cmp %r10,%rax</code> </pre> <br>  كما ترون ، يتم تجميع الوظائف المقابلة في رمز الجهاز الأصلي. <br><br>  أخيرًا ، ناقش الخيار 3 ، AOT.  التجميع قبل التنفيذ ، AOT ، لم يكن متاحًا في Java قبل الإصدار 9. <br><br>  ظهرت أداة جديدة في JDK 9 ، jaotc - كما يوحي الاسم ، فهي مترجم AOT لجافا.  الفكرة هي: تشغيل برنامج Java "javac" ، ثم برنامج التحويل البرمجي AOT لـ Java "jaotc" ، ثم تشغيل JVM "java" كالمعتاد.  ينفذ JVM عادةً ترجمة وتصنيف JIT.  ومع ذلك ، إذا كانت الوظيفة تحتوي على شفرة مترجمة من AOT ، فإنها تستخدمها مباشرة ، ولا تلجأ إلى الترجمة الشفوية أو ترجمة JIT.  اسمحوا لي أن أشرح: ليس لديك لتشغيل برنامج التحويل البرمجي AOT ، إنه اختياري ، وإذا كنت تستخدمه ، يمكنك فقط ترجمة الفئات التي تريدها قبل تنفيذها. <br><br>  دعنا نبني مكتبة تتكون من نسخة مترجمة من AOT من <code>Test::f</code> .  لا تنسى: أن تفعل ذلك بنفسك ، ستحتاج إلى JDK 9 في الإصدار 150+. <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">jaotc --output=libTest.so Test.class</code> </pre> <br>  نتيجة لذلك ، <code>libTest.so</code> إنشاء <code>libTest.so</code> ، وهي مكتبة تحتوي على رمز وظائف أصلية مترجمة من <code>libTest.so</code> مدرج في فئة <code>Test</code> .  يمكنك عرض الحروف المحددة في هذه المكتبة: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">nm libTest.so</code> </pre> <br>  في الختام ، من بين أمور أخرى ، سيكون هناك: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">0000000000002120 t Test.f()I 00000000000021a0 t Test.&lt;init&gt;()V 00000000000020a0 t Test.main([Ljava/lang/String;)V</code> </pre> <br>  لذلك ، جميع وظائفنا ، المنشئ ، <code>f</code> ، الطريقة الثابتة <code>main</code> موجودة في مكتبة <code>libTest.so</code> . <br><br>  كما هو الحال بالنسبة لخيار "java" المقابل ، في هذه الحالة يمكن أن يكون الخيار مصحوبًا بملف ، لذلك يوجد خيار -compile-command to jaotc.  تقدم JEP 295 الأمثلة ذات الصلة التي لن أعرضها هنا. <br><br>  لنقم الآن بتشغيل "java" ومعرفة ما إذا كانت أساليب AOT المترجمة تستخدم.  إذا قمت بتشغيل "java" كما كان من قبل ، فلن يتم استخدام مكتبة AOT ، وهذا ليس مفاجئًا.  لاستخدام هذه الميزة الجديدة ، يتم توفير الخيار <code>-XX:AOTLibrary</code> ، والذي يجب عليك تحديده: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">java -XX:AOTLibrary=./libTest.so Test</code> </pre> <br>  يمكنك تحديد مكتبات AOT متعددة ، مفصولة بفواصل. <br><br>  ناتج هذا الأمر هو نفسه تمامًا عند بدء تشغيل "java" بدون <code>AOTLibrary</code> ، نظرًا لأن سلوك برنامج Test لم يتغير على الإطلاق.  للتحقق من استخدام الوظائف المترجمة من <code>-XX:+PrintAOT</code> ، يمكنك إضافة خيار جديد آخر ، <code>-XX:+PrintAOT</code> . <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">java -XX:AOTLibrary=./libTest.so -XX:+PrintAOT Test</code> </pre> <br>  قبل إخراج برنامج <code>Test</code> ، يعرض هذا الأمر ما يلي: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs"> 9 1 loaded ./libTest.so aot library 99 1 aot[ 1] Test.main([Ljava/lang/String;)V 99 2 aot[ 1] Test.f()I 99 3 aot[ 1] Test.&lt;init&gt;()V</code> </pre> <br>  كما هو مخطط ، يتم تحميل مكتبة AOT ، ويتم استخدام وظائف المترجمة من AOT. <br><br>  إذا كنت مهتمًا ، يمكنك تشغيل الأمر التالي وتحقق مما إذا كان تجميع JIT يحدث. <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">java -client -Xbatch -XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler -XX:CompileThreshold=5 -XX:-TieredCompilation -XX:AOTLibrary=./libTest.so -XX:+PrintAOT Test</code> </pre> <br>  كما هو متوقع ، لا يتم إجراء ترجمة JIT ، حيث يتم تجميع الأساليب الموجودة في فئة الاختبار قبل التنفيذ ويتم توفيرها كمكتبة. <br><br>  والسؤال المحتمل هو: إذا قمنا بتوفير رمز دالة أصلي ، فكيف تحدد JVM ما إذا كانت الشفرة الأصلية قديمة / لا معنى لها؟  كمثال أخير ، دعونا نقوم بتعديل الدالة <code>f</code> وتعيين 6. <br><br><pre style=";text-align:right;direction:rtl"> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">throws</span></span></span><span class="hljs-function"> Exception </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a; }</code> </pre> <br>  فعلت هذا فقط لتعديل ملف الفصل.  الآن نجعل javac يترجم ونشغل نفس الأمر على النحو الوارد أعلاه. <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">javac Test.java java -client -Xbatch -XX:+PrintCompilation -XX:CompileCommandFile=hotspot_compiler -XX:CompileThreshold=5 -XX:-TieredCompilation -XX:AOTLibrary=./libTest.so -XX:+PrintAOT Test</code> </pre> <br>  كما ترون ، لم أقم بتشغيل "jaotc" بعد "javac" ، وبالتالي فإن الكود من مكتبة AOT أصبح قديمًا وغير صحيح الآن ، والوظيفة <code>f</code> لها = 5. <br><br>  يوضح إخراج الأمر "java" أعلاه: <br><br><pre style=";text-align:right;direction:rtl"> <code class="plaintext hljs">228 56 b Test::&lt;init&gt; (5 bytes) 229 57 b Test::f (5 bytes)</code> </pre> <br>  هذا يعني أن الوظائف في هذه الحالة تم تجميعها ديناميكيًا ، لذلك لم يتم استخدام الكود الناتج من التحويل البرمجي AOT.  لذلك ، تم اكتشاف تغيير في ملف الفصل الدراسي.  عند إجراء التحويل البرمجي باستخدام javac ، يتم إدخال بصمة الأصابع في الفصل ، ويتم أيضًا تخزين بصمة الأصابع في مكتبة AOT.  نظرًا لأن بصمة الفصل الجديدة تختلف عن تلك المخزنة في مكتبة AOT ، لم يتم استخدام الكود الأصلي الذي تم تجميعه مسبقًا (AOT).  هذا كل ما أردت إخبارك به عن خيار التحويل البرمجي الأخير ، قبل التنفيذ. <br><br>  في هذا المقال ، حاولت أن أشرح وأوضح بأمثلة واقعية بسيطة كيف ينفذ JVM شفرة Java: تفسيرها ، وتجميعها ديناميكيًا (JIT) أو مقدمًا (AOT) - علاوة على ذلك ، ظهرت الفرصة الأخيرة فقط في JDK 9. أتمنى أن تكون قد تعلمت شيئًا ما. الجديد. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/ar466529/">https://habr.com/ru/post/ar466529/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../ar466517/index.html">تدريب التعريب بجامعة واشنطن</a></li>
<li><a href="../ar466519/index.html">تحليل مفصل AWS لامدا</a></li>
<li><a href="../ar466521/index.html">C للمعادن - المعادن الثمينة للحوسبة على بطاقات الرسومات Intel</a></li>
<li><a href="../ar466525/index.html">ما هو تخطيط PSD iPhone وكيفية استخدامه؟</a></li>
<li><a href="../ar466527/index.html">اختبار وظائف مستخدم موقع الويب باستخدام كائنات صفحة Capybara</a></li>
<li><a href="../ar466533/index.html">باستيلدا: النتائج</a></li>
<li><a href="../ar466535/index.html">إعادة التفكير في deepClone</a></li>
<li><a href="../ar466537/index.html">باستخدام وحدات جافا سكريبت في الإنتاج: الوضع الحالي. الجزء 1</a></li>
<li><a href="../ar466539/index.html">باستخدام وحدات جافا سكريبت في الإنتاج: الوضع الحالي. الجزء 2</a></li>
<li><a href="../ar466541/index.html">باستخدام DbTool لقاعدة بيانات البذور في تطبيقات .NET (الأساسية)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>