<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåÑ üñãÔ∏è üçö DevCore: parte del software del proyecto DevBoy üë≥üèø üëºüèº üßóüèº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hola amigos 

 Nikolay est√° con usted nuevamente, en el √∫ltimo art√≠culo " DevBoy: c√≥mo cre√© un proyecto de dispositivo de c√≥digo abierto y lanc√© un pr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DevCore: parte del software del proyecto DevBoy</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/424309/">  <b>Hola amigos</b> <br><br>  Nikolay est√° con usted nuevamente, en el √∫ltimo art√≠culo " <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">DevBoy: c√≥mo cre√© un proyecto de dispositivo de c√≥digo abierto y lanc√© un proyecto en Kickstarter</a></i> ", el √©nfasis estaba m√°s en la apariencia y el hardware, hoy hablaremos sobre c√≥mo se hace esto " <i>dentro</i> " y analizaremos la parte del software. <br><br><img src="https://habrastorage.org/webt/6r/n4/u8/6rn4u8jvzpd-c9_oykzqia4l8fk.jpeg"><br><br>  A qui√©n le importa: le pido un gato. <br><a name="habracut"></a><br>  Como se mencion√≥ anteriormente, el proyecto se basa en el microcontrolador <b>STM32F415RG</b> de STMicroelectronics en el n√∫cleo ARM Cortex-M4.  Hay varios IDE diferentes para desarrollar microcontroladores para estos microcontroladores, sin embargo, para un proyecto de c√≥digo abierto, necesita al menos un IDE gratuito, y preferiblemente de c√≥digo abierto.  Adem√°s, el IDE a√∫n debe ser compatible con <b>STM32CubeMX</b> .  Cuando comenc√© a trabajar en este proyecto, solo hab√≠a un IDE que cumpl√≠a con todos estos requisitos: <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">System Workbench para STM32</a></b> . <br><br><img src="https://habrastorage.org/webt/v7/pz/vi/v7pzviufspf40flvruysuro_ex0.png">  <i>Por el momento, existe Atollic TrueStudio, que se convirti√≥ en gratuito despu√©s de que STMicroelectronics los compr√≥.</i> <i><br></i> <br>  El siguiente programa utilizado es <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">STM32CubeMX</a></b> .  Este programa es una utilidad para configurar los perif√©ricos del microcontrolador utilizando una interfaz gr√°fica. <br><img src="https://habrastorage.org/webt/i4/ym/3u/i4ym3unkrgskza2fmumqmmfzs1o.png"><br>  El resultado es un c√≥digo que incluye <b>H</b> ardware <b>A</b> bstraction <b>L</b> ayer (HAL).  A muchos programadores realmente no les gusta esta " <i>creaci√≥n</i> ", no est√° exenta de errores, pero, sin embargo, simplifica enormemente el desarrollo y mejora la portabilidad de los programas entre diferentes microcontroladores de STMicroelectronics. <br><br>  Adem√°s, durante la configuraci√≥n, puede especificar el uso de alg√∫n software de c√≥digo abierto de terceros, como <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FreeRTOS</a></b> , <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">FatFS</a></b> y algunos otros. <br><br>  <b>Hemos</b> terminado la descripci√≥n del software utilizado, ahora pasemos a la parte m√°s interesante: <b>DevCore</b> .  El nombre proviene del " <i>Core Development</i> " vamos en orden. <br><br>  En primer lugar, es <b>C ++ RTOS Wrapper</b> ( <i>FreeRTOS en este caso</i> ).  Vrapper es necesario por dos razones: <br><br><ul><li>  Es mucho mejor crear un objeto y luego llamar a mutex.Take (), por ejemplo, que crear un identificador, llamar a la funci√≥n create y luego pasar este identificador a todas las funciones mutex </li><li>  Si es necesario reemplazar RTOS, es suficiente reemplazar el contenedor y no todas las llamadas a funciones RTOS desde el c√≥digo </li></ul><br>  No tiene sentido traer aqu√≠ el c√≥digo del contenedor, a qui√©n le importa: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">miramos a GitHub</a> y seguimos adelante. <br><br>  La siguiente parte es el <b>Marco de aplicaci√≥n</b> .  Esta es la clase base para todas las tareas.  Dado que estos son solo dos archivos relativamente peque√±os, tiene sentido enumerarlos por completo: <br><br><div class="spoiler">  <b class="spoiler_title">Encabezado</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//****************************************************************************** // @file AppTask.h // @author Nicolai Shlapunov // // @details DevCore: Application Task Base Class, header // // @section LICENSE // // Software License Agreement (Modified BSD License) // // Copyright (c) 2016, Devtronic &amp; Nicolai Shlapunov // All rights reserved. // // Redistribution and use in source and binary forms, with or without // modification, are permitted provided that the following conditions are met: // // 1. Redistributions of source code must retain the above copyright // notice, this list of conditions and the following disclaimer. // 2. Redistributions in binary form must reproduce the above copyright // notice, this list of conditions and the following disclaimer in the // documentation and/or other materials provided with the distribution. // 3. Neither the name of the Devtronic nor the names of its contributors // may be used to endorse or promote products derived from this software // without specific prior written permission. // 4. Redistribution and use of this software other than as permitted under // this license is void and will automatically terminate your rights under // this license. // // THIS SOFTWARE IS PROVIDED BY DEVTRONIC ''AS IS'' AND ANY EXPRESS OR IMPLIED // WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF // MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. // IN NO EVENT SHALL DEVTRONIC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED // TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. // // @section SUPPORT // // Devtronic invests time and resources providing this open source code, // please support Devtronic and open-source hardware/software by // donations and/or purchasing products from Devtronic. // //****************************************************************************** #ifndef AppTask_h #define AppTask_h // ***************************************************************************** // *** Includes ************************************************************ // ***************************************************************************** #include "DevCfg.h" // ***************************************************************************** // * AppTask class. This class is wrapper for call C++ function from class. **** // ***************************************************************************** class AppTask { public: // ************************************************************************* // *** Init Task ******************************************************* // ************************************************************************* virtual void InitTask(void) {CreateTask();} protected: // ************************************************************************* // *** Constructor ***************************************************** // ************************************************************************* AppTask(uint16_t stk_size, uint8_t task_prio, const char name[], uint16_t queue_len = 0U, uint16_t queue_msg_size = 0U, void* task_msg_p = nullptr, uint32_t task_interval_ms = 0U) : ctrl_queue((queue_len + 2U), sizeof(CtrlQueueMsg)), task_queue(queue_len, queue_msg_size), task_msg_ptr(task_msg_p), timer(task_interval_ms, RtosTimer::REPEATING, TimerCallback, (void*)this), stack_size(stk_size), task_priority(task_prio), task_name(name) {}; // ************************************************************************* // *** Virtual destructor - prevent warning **************************** // ************************************************************************* virtual ~AppTask() {}; // ************************************************************************* // *** Create task function ******************************************** // ************************************************************************* // * This function creates new task in FreeRTOS, provide pointer to function // * and pointer to class as parameter. When TaskFunctionCallback() called // * from FreeRTOS, it use pointer to class from parameter to call virtual // * functions. void CreateTask(); // ************************************************************************* // *** Setup function ************************************************** // ************************************************************************* // * * virtual function - some tasks may not have Setup() actions virtual Result Setup() {return Result::RESULT_OK;} // ************************************************************************* // *** IntervalTimerExpired function *********************************** // ************************************************************************* // * Empty virtual function - some tasks may not have TimerExpired() actions virtual Result TimerExpired() {return Result::RESULT_OK;} // ************************************************************************* // *** ProcessMessage function ***************************************** // ************************************************************************* // * Empty virtual function - some tasks may not have ProcessMessage() actions virtual Result ProcessMessage() {return Result::RESULT_OK;} // ************************************************************************* // *** Loop function *************************************************** // ************************************************************************* // * Empty virtual function - some tasks may not have Loop() actions virtual Result Loop() {return Result::RESULT_OK;} // ************************************************************************* // *** SendTaskMessage function **************************************** // ************************************************************************* Result SendTaskMessage(const void* task_msg, bool is_priority = false); private: // Task control queue message types enum CtrlQueueMsgType { CTRL_TIMER_MSG, CTRL_TASK_QUEUE_MSG }; // Task control queue message struct struct CtrlQueueMsg { CtrlQueueMsgType type; }; // Task control queue RtosQueue ctrl_queue; // Task queue RtosQueue task_queue; // Pointer to receive message buffer void* task_msg_ptr; // Timer object RtosTimer timer; // Task stack size uint16_t stack_size; // Task priority uint8_t task_priority; // Pointer to the task name const char* task_name; // ************************************************************************* // *** IntLoop function ************************************************ // ************************************************************************* Result IntLoop(); // ************************************************************************* // *** TaskFunctionCallback ******************************************** // ************************************************************************* static void TaskFunctionCallback(void* ptr); // ************************************************************************* // *** IntervalTimerCallback function ********************************** // ************************************************************************* static void TimerCallback(void* ptr); // ************************************************************************* // *** SendControlMessage function ************************************* // ************************************************************************* Result SendControlMessage(const CtrlQueueMsg&amp; ctrl_msg, bool is_priority = false); // ************************************************************************* // *** Change counter ************************************************** // ************************************************************************* static void ChangeCnt(bool is_up); // ************************************************************************* // *** Private constructor and assign operator - prevent copying ******* // ************************************************************************* AppTask(); AppTask(const AppTask&amp;); AppTask&amp; operator=(const AppTask&amp;); }; #endif</span></span></code> </pre> </div></div><div class="spoiler">  <b class="spoiler_title">C√≥digo</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//****************************************************************************** // @file AppTask.cpp // @author Nicolai Shlapunov // // @details DevCore: Application Task Base Class, implementation // // @copyright Copyright (c) 2016, Devtronic &amp; Nicolai Shlapunov // All rights reserved. // // @section SUPPORT // // Devtronic invests time and resources providing this open source code, // please support Devtronic and open-source hardware/software by // donations and/or purchasing products from Devtronic. // //****************************************************************************** // ***************************************************************************** // *** Includes ************************************************************ // ***************************************************************************** #include "AppTask.h" #include "RtosMutex.h" // ***************************************************************************** // *** Static variables **************************************************** // ***************************************************************************** static RtosMutex startup_mutex; static uint32_t startup_cnt = 0U; // ***************************************************************************** // *** Create task function ************************************************ // ***************************************************************************** void AppTask::CreateTask() { Result result = Result::RESULT_OK; // If interval timer period isn't zero or task queue present if((timer.GetTimerPeriod() != 0U) || (task_queue.GetQueueLen() != 0U)) { // Set Control Queue name ctrl_queue.SetName(task_name, "Ctrl"); // Create control queue result = ctrl_queue.Create(); } // If task queue present if(task_queue.GetQueueLen() != 0U) { // Set Task Queue name task_queue.SetName(task_name, "Task"); // Create task queue result |= task_queue.Create(); } // If interval timer period isn't zero if(timer.GetTimerPeriod() != 0U) { // Create timer result |= timer.Create(); } // Create task: function - TaskFunctionCallback(), parameter - pointer to "this" result |= Rtos::TaskCreate(TaskFunctionCallback, task_name, stack_size, this, task_priority); // Check result if(result.IsBad()) { // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> implement error handling Break(); } } // ***************************************************************************** // *** SendTaskMessage function ******************************************** // ***************************************************************************** Result AppTask::SendTaskMessage(const void* task_msg, bool is_priority) { Result result = Result::RESULT_OK; // Send task message to front or back of task queue if(is_priority == true) { result = task_queue.SendToFront(task_msg); } else { result = task_queue.SendToBack(task_msg); } // If successful - send message to the control queue if(result.IsGood()) { CtrlQueueMsg ctrl_msg; ctrl_msg.type = CTRL_TASK_QUEUE_MSG; result = SendControlMessage(ctrl_msg, is_priority); } return result; } // ***************************************************************************** // *** IntLoop function **************************************************** // ***************************************************************************** Result AppTask::IntLoop() { Result result = Result::RESULT_OK; while(result.IsGood()) { // Buffer for control message CtrlQueueMsg ctrl_msg; // Read on the control queue result = ctrl_queue.Receive(&amp;ctrl_msg, timer.GetTimerPeriod() * 2U); // If successful if(result.IsGood()) { // Check message type switch(ctrl_msg.type) { case CTRL_TIMER_MSG: result = TimerExpired(); break; case CTRL_TASK_QUEUE_MSG: { // Non blocking read from the task queue result = task_queue.Receive(task_msg_ptr, 0U); // If successful if(result.IsGood()) { // Process it! result = ProcessMessage(); } break; } default: result = Result::ERR_INVALID_ITEM; break; } } } return result; } // ***************************************************************************** // *** TaskFunctionCallback ************************************************ // ***************************************************************************** void AppTask::TaskFunctionCallback(void* ptr) { Result result = Result::ERR_NULL_PTR; if(ptr != nullptr) { // Set good result result = Result::RESULT_OK; // Get reference to the task object AppTask&amp; app_task = *(static_cast&lt;AppTask*&gt;(ptr)); // Increment counter before call Setup() ChangeCnt(true); // Call virtual Setup() function from AppTask class app_task.Setup(); // Decrement counter after call Setup() ChangeCnt(false); // Pause for give other tasks run Setup() RtosTick::DelayTicks(1U); // Pause while other tasks run Setup() before executing any Loop() while(startup_cnt) RtosTick::DelayTicks(1U); // If no timer or queue - just call Loop() function if((app_task.timer.GetTimerPeriod() == 0U) &amp;&amp; (app_task.task_queue.GetQueueLen() == 0U)) { // Call virtual Loop() function from AppTask class while(app_task.Loop() == Result::RESULT_OK); } else { // Start task timer if needed if(app_task.timer.GetTimerPeriod() != 0U) { result = app_task.timer.Start(); } // Check result if(result.IsGood()) { // Call internal AppTask function result = app_task.IntLoop(); } // Stop task timer if needed if(app_task.timer.GetTimerPeriod() != 0U) { result |= app_task.timer.Stop(); } } } // Check result if(result.IsBad()) { // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> implement error handling Break(); } // Delete task after exit Rtos::TaskDelete(); } // ***************************************************************************** // *** TimerCallback function ********************************************** // ***************************************************************************** void AppTask::TimerCallback(void* ptr) { Result result = Result::ERR_NULL_PTR; if(ptr != nullptr) { // Get reference to the task object AppTask&amp; task = *((AppTask*)ptr); // Create control timer message CtrlQueueMsg timer_msg; timer_msg.type = CTRL_TIMER_MSG; // Send message to the control queue result = task.SendControlMessage(timer_msg); } // Check result if(result.IsBad()) { // </span><span class="hljs-doctag"><span class="hljs-comment"><span class="hljs-doctag">TODO:</span></span></span><span class="hljs-comment"> implement error handling Break(); } } // ***************************************************************************** // *** SendControlMessage function ***************************************** // ***************************************************************************** Result AppTask::SendControlMessage(const CtrlQueueMsg&amp; ctrl_msg, bool is_priority) { Result result; if(is_priority == true) { result = ctrl_queue.SendToFront(&amp;ctrl_msg); } else { result = ctrl_queue.SendToBack(&amp;ctrl_msg); } return result; } // ***************************************************************************** // *** Change counter ****************************************************** // ***************************************************************************** void AppTask::ChangeCnt(bool is_up) { // Take semaphore before change counter startup_mutex.Lock(); // Check direction if(is_up == true) { // Increment counter startup_cnt++; } else { // Decrement counter startup_cnt--; } // Give semaphore after changes startup_mutex.Release(); }</span></span></code> </pre></div></div><br>  Las clases heredadas pueden anular 4 funciones virtuales: <br><br><ul><li>  <b>Setup ()</b> es una funci√≥n llamada antes de comenzar una tarea.  La finalizaci√≥n del c√≥digo est√° garantizada en todas estas funciones de todas las tareas antes de la ejecuci√≥n de los ciclos principales. </li><li>  <b>Loop ()</b> : el ciclo principal de la tarea, donde la tarea misma organiza lo que quiere.  No se puede usar junto con las siguientes dos funciones. </li><li>  <b>TimerExpired ()</b> - una funci√≥n llamada peri√≥dicamente con un intervalo dado.  Conveniente para implementar el sondeo de un sensor, por ejemplo. </li><li>  <b>ProcessMessage ()</b> : funci√≥n para procesar mensajes de otras tareas. </li></ul><br>  Las dos primeras funciones implementan " <i>Arduino-Style</i> " para las tareas. <br><br>  Los dos siguientes implementan el sistema de " <i>evento</i> " que simplifica la interacci√≥n de las tareas.  Con este enfoque, la tarea implementa una interfaz externa en forma de funciones que env√≠an datos de env√≠o a la tarea a trav√©s de un buz√≥n interno.  Con este enfoque, el usuario que usa esta interfaz no necesita preocuparse en qu√© contexto se realizan las acciones.  Es cierto que esto solo es posible para setters o equipos.  Para los captadores, es mejor usar mutexes y copia de datos para evitar la captura de mutex durante mucho tiempo. <br><br>  Este enfoque se detect√≥ cuando estaba desarrollando software para equipos m√©dicos.  El microcontrolador tiene un <i>perro guardi√°n</i> y <i>,</i> en el caso de muchas tareas, debe realizar un seguimiento de todas ellas.  Para esto, hubo una tarea separada que sirvi√≥ de perro guardi√°n y recibi√≥ mensajes de otras tareas enviadas desde la funci√≥n TimerExpired ().  Si durante el per√≠odo del temporizador de la tarea * n no hubo mensajes, la tarea muri√≥, <s>apagamos la luz y</s> tomamos medidas para apagar todas las gl√°ndulas que afectan al paciente. <br><br>  Todas las tareas son singleton, no puede crearlas directamente, pero puede obtener un enlace a la tarea.  Para hacer esto, cada tarea implementa el <b>m√©todo</b> est√°tico <b>GetInstance ()</b> : <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ***************************************************************************** // *** Get Instance ******************************************************** // ***************************************************************************** Application&amp; Application::GetInstance(void) { static Application application; return application; }</span></span></code> </pre> <br>  Tambi√©n se incluyen tareas para <b>salida de audio</b> , para <b>m√≥dulos de entrada</b> y para <b>mantenimiento de pantalla.</b> <br><br>  La tarea <b>de salida de sonido es</b> bastante simple: recibe una variedad de frecuencias y duraciones y simplemente cambia peri√≥dicamente la configuraci√≥n del temporizador para generar pulsos rectangulares de cierta frecuencia. <br><br><div class="spoiler">  <b class="spoiler_title">Encabezado</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//****************************************************************************** // @file SoundDrv.h // @author Nicolai Shlapunov // // @details DevCore: Sound Driver Class, header // // @section LICENSE // // Software License Agreement (Modified BSD License) // // Copyright (c) 2016, Devtronic &amp; Nicolai Shlapunov // All rights reserved. // // Redistribution and use in source and binary forms, with or without // modification, are permitted provided that the following conditions are met: // // 1. Redistributions of source code must retain the above copyright // notice, this list of conditions and the following disclaimer. // 2. Redistributions in binary form must reproduce the above copyright // notice, this list of conditions and the following disclaimer in the // documentation and/or other materials provided with the distribution. // 3. Neither the name of the Devtronic nor the names of its contributors // may be used to endorse or promote products derived from this software // without specific prior written permission. // 4. Redistribution and use of this software other than as permitted under // this license is void and will automatically terminate your rights under // this license. // // THIS SOFTWARE IS PROVIDED BY DEVTRONIC ''AS IS'' AND ANY EXPRESS OR IMPLIED // WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF // MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. // IN NO EVENT SHALL DEVTRONIC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED // TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. // // @section SUPPORT // // Devtronic invests time and resources providing this open source code, // please support Devtronic and open-source hardware/software by // donations and/or purchasing products from Devtronic. // //****************************************************************************** #ifndef SoundDrv_h #define SoundDrv_h // ***************************************************************************** // *** Includes ************************************************************ // ***************************************************************************** #include "DevCfg.h" #include "AppTask.h" #include "RtosMutex.h" #include "RtosSemaphore.h" // ***************************************************************************** // *** Sound Driver Class. This class implement work with sound. *********** // ***************************************************************************** class SoundDrv : public AppTask { public: // ************************************************************************* // *** Get Instance **************************************************** // ************************************************************************* // * This class is singleton. For use this class you must call GetInstance() // * to receive reference to Sound Driver class static SoundDrv&amp; GetInstance(void); // ************************************************************************* // *** Init Sound Driver Task ****************************************** // ************************************************************************* virtual void InitTask(TIM_HandleTypeDef *htm); // ************************************************************************* // *** Sound Driver Setup ********************************************** // ************************************************************************* virtual Result Setup(); // ************************************************************************* // *** Sound Driver Loop *********************************************** // ************************************************************************* virtual Result Loop(); // ************************************************************************* // *** Beep function *************************************************** // ************************************************************************* void Beep(uint16_t freq, uint16_t del, bool pause_after_play = false); // ************************************************************************* // *** Play sound function ********************************************* // ************************************************************************* void PlaySound(const uint16_t* melody, uint16_t size, uint16_t temp_ms = 100U, bool rep = false); // ************************************************************************* // *** Stop sound function ********************************************* // ************************************************************************* void StopSound(void); // ************************************************************************* // *** Mute sound function ********************************************* // ************************************************************************* void Mute(bool mute_flag); // ************************************************************************* // *** Is sound played function **************************************** // ************************************************************************* bool IsSoundPlayed(void); private: // Timer handle TIM_HandleTypeDef* htim = SOUND_HTIM; // Timer channel uint32_t channel = SOUND_CHANNEL; // Ticks variable uint32_t last_wake_ticks = 0U; // Pointer to table contains melody const uint16_t* sound_table = nullptr; // Size of table uint16_t sound_table_size = 0U; // Current position uint16_t sound_table_position = 0U; // Current frequency delay uint16_t current_delay = 0U; // Time for one frequency in ms uint32_t delay_ms = 100U; // Repeat flag bool repeat = false; // Mute flag bool mute = false; // Mutex to synchronize when playing melody frames RtosMutex melody_mutex; // Semaphore for start play sound RtosSemaphore sound_update; // ************************************************************************* // *** Process Button Input function *********************************** // ************************************************************************* void Tone(uint16_t freq); // ************************************************************************* // ** Private constructor. Only GetInstance() allow to access this class. ** // ************************************************************************* SoundDrv() : AppTask(SOUND_DRV_TASK_STACK_SIZE, SOUND_DRV_TASK_PRIORITY, "SoundDrv") {}; }; #endif</span></span></code> </pre> <br></div></div><br>  La tarea de dar servicio a <b>los m√≥dulos de agua</b> tambi√©n <b>es</b> bastante simple.  De los puntos interesantes, el m√≥dulo se detecta autom√°ticamente: primero, usando el ADC, medimos el voltaje, si est√° en el rango del 25% al ‚Äã‚Äã75% del voltaje de suministro, se inserta un joystick anal√≥gico, de lo contrario, botones o un codificador.  Si no es un joystick, verifique la cuarta l√≠nea del m√≥dulo de E / S: si est√° en un nivel alto, estos son botones ( <i>todos los botones se activan y, cuando se presionan los botones, se cierran al suelo</i> ), si est√° bajo, es un codificador ( <i>se "levanta</i> un <i>bot√≥n peque√±o" al suelo y cuando se presiona se cierra al poder</i> ). <br><br><div class="spoiler">  <b class="spoiler_title">Encabezado</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//****************************************************************************** // @file InputDrv.h // @author Nicolai Shlapunov // // @details DevCore: Input Driver Class, header // // @section LICENSE // // Software License Agreement (Modified BSD License) // // Copyright (c) 2016, Devtronic &amp; Nicolai Shlapunov // All rights reserved. // // Redistribution and use in source and binary forms, with or without // modification, are permitted provided that the following conditions are met: // // 1. Redistributions of source code must retain the above copyright // notice, this list of conditions and the following disclaimer. // 2. Redistributions in binary form must reproduce the above copyright // notice, this list of conditions and the following disclaimer in the // documentation and/or other materials provided with the distribution. // 3. Neither the name of the Devtronic nor the names of its contributors // may be used to endorse or promote products derived from this software // without specific prior written permission. // 4. Redistribution and use of this software other than as permitted under // this license is void and will automatically terminate your rights under // this license. // // THIS SOFTWARE IS PROVIDED BY DEVTRONIC ''AS IS'' AND ANY EXPRESS OR IMPLIED // WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF // MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. // IN NO EVENT SHALL DEVTRONIC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED // TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. // // @section SUPPORT // // Devtronic invests time and resources providing this open source code, // please support Devtronic and open-source hardware/software by // donations and/or purchasing products from Devtronic. // //****************************************************************************** #ifndef InputDrv_h #define InputDrv_h // ***************************************************************************** // *** Includes ************************************************************ // ***************************************************************************** #include "DevCfg.h" #include "AppTask.h" // ***************************************************************************** // * Input Driver Class. This class implement work with user input elements like // * buttons and encoders. class InputDrv : public AppTask { public: // ************************************************************************* // *** Enum with all buttons ******************************************* // ************************************************************************* typedef enum { EXT_LEFT, // Left ext port EXT_RIGHT, // Right ext port EXT_MAX // Ext port count } PortType; // ************************************************************************* // *** Enum with all devices types ************************************* // ************************************************************************* typedef enum { EXT_DEV_NONE, // No device EXT_DEV_BTN, // Buttons(cross) EXT_DEV_ENC, // Encoder EXT_DEV_JOY, // Joystick EXT_DEV_MAX // Device types count } ExtDeviceType; // ************************************************************************* // *** Enum with all buttons ******************************************* // ************************************************************************* typedef enum { BTN_UP, // Up button BTN_LEFT, // Left button BTN_DOWN, // Down button BTN_RIGHT, // Right button BTN_MAX // Buttons count } ButtonType; // ************************************************************************* // *** Enum with all encoder buttons *********************************** // ************************************************************************* typedef enum { ENC_BTN_ENT, // Press on the knob ENC_BTN_BACK, // Small button ENC_BTN_MAX // Buttons count } EncButtonType; // ************************************************************************* // *** Get Instance **************************************************** // ************************************************************************* // * This class is singleton. For use this class you must call GetInstance() // * to receive reference to Input Driver class static InputDrv&amp; GetInstance(void); // ************************************************************************* // *** Init Input Driver Task ****************************************** // ************************************************************************* // * This function initialize Input Driver class. If htim provided, this // * timer will be used instead FreeRTOS task. virtual void InitTask(TIM_HandleTypeDef* htm, ADC_HandleTypeDef* had); // ************************************************************************* // *** Input Driver Setup ********************************************** // ************************************************************************* virtual Result Setup(); // ************************************************************************* // *** Input Driver Loop *********************************************** // ************************************************************************* // * If FreeRTOS task used, this function just call ProcessInput() with 1 ms // * period. If FreeRTOS tick is 1 ms - this task must have highest priority virtual Result Loop(); // ************************************************************************* // *** Process Input function ****************************************** // ************************************************************************* // * Main class function - must call periodically for process user input. // * If timer used, this function must be called from interrupt handler. void ProcessInput(void); // ************************************************************************* // *** Process Encoders Input function ********************************* // ************************************************************************* void ProcessEncodersInput(void); // ************************************************************************* // *** Get device type ************************************************* // ************************************************************************* ExtDeviceType GetDeviceType(PortType port); // ************************************************************************* // *** Get button state ************************************************ // ************************************************************************* // Return button state: true - pressed, false - unpressed bool GetButtonState(PortType port, ButtonType button); // ************************************************************************* // *** Get button state ************************************************ // ************************************************************************* // Return button state change flag: true - changed, false - not changed bool GetButtonState(PortType port, ButtonType button, bool&amp; btn_state); // ************************************************************************* // *** Get encoder counts from last call ******************************* // ************************************************************************* // * Return state of encoder. Class counts encoder clicks and stored inside. // * This function substract from current encoder counter last_enc_val and // * return it to user. Before return last_enc_val will be assigned to // * current encoder counter. int32_t GetEncoderState(PortType port, int32_t&amp; last_enc_val); // ************************************************************************* // *** Get button state ************************************************ // ************************************************************************* // Return button state: true - pressed, false - unpressed bool GetEncoderButtonState(PortType port, EncButtonType button); // ************************************************************************* // *** Get encoder button state **************************************** // ************************************************************************* // Return button state: true - pressed, false - unpressed bool GetEncoderButtonState(PortType port, EncButtonType button, bool&amp; btn_state); // ************************************************************************* // *** Get joystick counts from last call ****************************** // ************************************************************************* void GetJoystickState(PortType port, int32_t&amp; x, int32_t&amp; y); // ************************************************************************* // *** SetJoystickCalibrationConsts ************************************ // ************************************************************************* // * Set calibration constants. Must be call for calibration joystick. void SetJoystickCalibrationConsts(PortType port, int32_t x_mid, int32_t x_kmin, int32_t x_kmax, int32_t y_mid, int32_t y_kmin, int32_t y_kmax); // ************************************************************************* // *** Get joystick button state *************************************** // ************************************************************************* // Return button state: true - pressed, false - unpressed bool GetJoystickButtonState(PortType port); // ************************************************************************* // *** Get joystick button state *************************************** // ************************************************************************* // Return button state: true - pressed, false - unpressed bool GetJoystickButtonState(PortType port, bool&amp; btn_state); private: // How many cycles button must change state before state will be changed in // result returned by GetButtonState() function. For reduce debouncing const static uint32_t BUTTON_READ_DELAY = 4U; // Coefficient for calibration const static int32_t COEF = 100; // ADC max value - 12 bit const static int32_t ADC_MAX_VAL = 0xFFF; // Joystich threshold const static int32_t JOY_THRESHOLD = 1000; // Ticks variable uint32_t last_wake_ticks = 0U; // ************************************************************************* // *** Structure to describe button ************************************ // ************************************************************************* typedef struct { bool btn_state; // Button state returned by GetButtonState() function bool btn_state_tmp; // Temporary button state for reduce debouncing uint8_t btn_state_cnt; // Counter for reduce debouncing GPIO_TypeDef* button_port;// Button port uint16_t button_pin; // Button pin GPIO_PinState pin_state; // High/low on input treated as pressed } ButtonProfile; // ************************************************************************* // *** Structure to describe encoder *********************************** // ************************************************************************* typedef struct { // Encoder rotation int32_t enc_cnt; // Encoder counter uint8_t enc_state; // Current state of encder clock &amp; data pins GPIO_TypeDef* enc_clk_port; // Encoder clock port uint16_t enc_clk_pin; // Encoder clock pin GPIO_TypeDef* enc_data_port;// Encoder data port uint16_t enc_data_pin; // Encoder data pin } EncoderProfile; // ************************************************************************* // *** Structure to describe joysticks ********************************* // ************************************************************************* typedef struct { int32_t x_ch_val; // Joystick X axis value uint32_t x_channel; // Joystick X axis ADC channel GPIO_TypeDef* x_port; // Joystick X axis port uint16_t x_pin; // Joystick X axis pin int32_t bx; // Joystick X offset int32_t kxmin; // Joystick X coefficient int32_t kxmax; // Joystick X coefficient bool x_inverted; // Joystick X inverted flag int32_t y_ch_val; // Joystick Y axis value uint32_t y_channel; // Joystick Y axis ADC channel GPIO_TypeDef* y_port; // Joystick Y axis port uint16_t y_pin; // Joystick Y axis pin int32_t by; // Joystick Y offset int32_t kymin; // Joystick Y coefficient int32_t kymax; // Joystick Y coefficient bool y_inverted; // Joystick Y inverted flag } JoystickProfile; // ************************************************************************* // *** Structure to describe encoders ********************************** // ************************************************************************* typedef struct { EncoderProfile enc; ButtonProfile btn[ENC_BTN_MAX]; } DevEncoders; // ************************************************************************* // *** Structure to describe encoders ********************************** // ************************************************************************* typedef struct { JoystickProfile joy; ButtonProfile btn; } DevJoysticks; // ************************************************************************* // *** Structure to describe buttons *********************************** // ************************************************************************* typedef struct { ButtonProfile button[BTN_MAX]; } DevButtons; // *** Array describes types of connected devices *********************** ExtDeviceType devices[EXT_MAX]; // *** Structures array for describe buttons inputs ********************* DevButtons buttons[EXT_MAX] = { // Left device {{{false, false, 0, EXT_L1_GPIO_Port, EXT_L1_Pin, GPIO_PIN_RESET}, {false, false, 0, EXT_L2_GPIO_Port, EXT_L2_Pin, GPIO_PIN_RESET}, {false, false, 0, EXT_L3_GPIO_Port, EXT_L3_Pin, GPIO_PIN_RESET}, {false, false, 0, EXT_L4_GPIO_Port, EXT_L4_Pin, GPIO_PIN_RESET}}}, // Right device {{{false, false, 0, EXT_R1_GPIO_Port, EXT_R1_Pin, GPIO_PIN_RESET}, {false, false, 0, EXT_R2_GPIO_Port, EXT_R2_Pin, GPIO_PIN_RESET}, {false, false, 0, EXT_R3_GPIO_Port, EXT_R3_Pin, GPIO_PIN_RESET}, {false, false, 0, EXT_R4_GPIO_Port, EXT_R4_Pin, GPIO_PIN_RESET}}} }; // *** Structures array for describe encoders inputs ******************** DevEncoders encoders[EXT_MAX] = { // Left device {{0, 0, EXT_L1_GPIO_Port, EXT_L1_Pin, EXT_L2_GPIO_Port, EXT_L2_Pin}, // Encoder {{false, false, 0, EXT_L3_GPIO_Port, EXT_L3_Pin, GPIO_PIN_RESET}, // Button Enter {false, false, 0, EXT_L4_GPIO_Port, EXT_L4_Pin, GPIO_PIN_SET}}}, // Button Back // Right device {{0, 0, EXT_R1_GPIO_Port, EXT_R1_Pin, EXT_R2_GPIO_Port, EXT_R2_Pin}, // Encoder {{false, false, 0, EXT_R3_GPIO_Port, EXT_R3_Pin, GPIO_PIN_RESET}, // Button Enter {false, false, 0, EXT_R4_GPIO_Port, EXT_R4_Pin, GPIO_PIN_SET}}} // Button Back }; // *** Structures array for describe encoders inputs ******************** DevJoysticks joysticks[EXT_MAX] = { // Left device {{0, ADC_CHANNEL_11, EXT_L2_GPIO_Port, EXT_L2_Pin, 0, COEF, COEF, false, // Joystick 0, ADC_CHANNEL_10, EXT_L1_GPIO_Port, EXT_L1_Pin, 0, COEF, COEF, true}, {false, false, 0, EXT_L3_GPIO_Port, EXT_L3_Pin, GPIO_PIN_RESET}}, // Button // Right device {{0, ADC_CHANNEL_13, EXT_R2_GPIO_Port, EXT_R2_Pin, 0, COEF, COEF, false, // Joystick 0, ADC_CHANNEL_12, EXT_R1_GPIO_Port, EXT_R1_Pin, 0, COEF, COEF, true}, {false, false, 0, EXT_R3_GPIO_Port, EXT_R3_Pin, GPIO_PIN_RESET}} // Button }; // Handle to timer used for process encoders input TIM_HandleTypeDef* htim = nullptr; // Handle to timer used for process encoders input ADC_HandleTypeDef* hadc = nullptr; // ************************************************************************* // *** Process Button Input function *********************************** // ************************************************************************* void ProcessButtonInput(ButtonProfile&amp; button); // ************************************************************************* // *** Process Encoder Input function ********************************** // ************************************************************************* void ProcessEncoderInput(EncoderProfile&amp; encoder); // ************************************************************************* // *** Process Joystick Input function ********************************* // ************************************************************************* void ProcessJoystickInput(JoystickProfile&amp; joysticks, PortType port); // ************************************************************************* // *** Emulate buttons using joystick function ************************* // ************************************************************************* void EmulateButtonsByJoystick(PortType port); // ************************************************************************* // *** Emulate encoders using buttons function ************************* // ************************************************************************* void EmulateEncodersByButtons(PortType port); // ************************************************************************* // *** Configure inputs devices types ********************************** // ************************************************************************* ExtDeviceType DetectDeviceType(PortType port); // ************************************************************************* // *** Configure ADC *************************************************** // ************************************************************************* void ConfigADC(ExtDeviceType dev_left, ExtDeviceType dev_right); // ************************************************************************* // *** Configure inputs for read digital/analog data ******************* // ************************************************************************* void ConfigInputIO(bool is_digital, PortType port); // ************************************************************************* // ** Private constructor. Only GetInstance() allow to access this class. ** // ************************************************************************* InputDrv() : AppTask(INPUT_DRV_TASK_STACK_SIZE, INPUT_DRV_TASK_PRIORITY, "InputDrv") {}; }; #endif</span></span></code> </pre> </div></div><br>  <b> </b> ‚Äî   .   ,   320x240x16bit,   <b>153600 </b>  .    ,    ‚Äî     192 ,          .   ?  :    !  -   ‚Ä¶ <br><br>            .       .        ,      SPI  DMA ,         . <br><br>             ?   <b> !</b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pero ella tiene una lista de objetos que saben c√≥mo dibujarse. </font><font style="vertical-align: inherit;">Cada uno de estos objetos se hereda de la clase </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">VisObject</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Encabezado</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//****************************************************************************** // @file VisObject.h // @author Nicolai Shlapunov // // @details DevCore: Visual Object Base Class, header // // @section LICENSE // // Software License Agreement (BSD License) // // Copyright (c) 2016, Devtronic &amp; Nicolai Shlapunov // All rights reserved. // // Redistribution and use in source and binary forms, with or without // modification, are permitted provided that the following conditions are met: // 1. Redistributions of source code must retain the above copyright // notice, this list of conditions and the following disclaimer. // 2. Redistributions in binary form must reproduce the above copyright // notice, this list of conditions and the following disclaimer in the // documentation and/or other materials provided with the distribution. // 3. Neither the name of the Devtronic nor the names of its contributors // may be used to endorse or promote products derived from this software // without specific prior written permission. // // THIS SOFTWARE IS PROVIDED BY DEVTRONIC ''AS IS'' AND ANY EXPRESS OR IMPLIED // WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF // MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. // IN NO EVENT SHALL DEVTRONIC BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED // TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR // PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY // LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING // NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS // SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. // //****************************************************************************** #ifndef VisObject_h #define VisObject_h // ***************************************************************************** // *** Includes ************************************************************ // ***************************************************************************** #include "DevCfg.h" // ***************************************************************************** // * VisObject class. This class implements base Visual Objects properties. class VisObject { public: // ************************************************************************* // *** Action ********************************************************** // ************************************************************************* typedef enum { ACT_TOUCH, // When object touched ACT_UNTOUCH, // When object detouched ACT_MOVE, // When object moved on object ACT_MOVEIN, // When object moved in to object ACT_MOVEOUT, // When object moved out of object ACT_MAX // Total possible actions } ActionType; // ************************************************************************* // *** VisObject ******************************************************* // ************************************************************************* VisObject() {}; // ************************************************************************* // *** ~VisObject ****************************************************** // ************************************************************************* // * Destructor. Call DelVisObjectFromList() from DisplayDrv class for // * remove from list before delete and delete semaphore. virtual ~VisObject(); // ************************************************************************* // *** LockVisObject *************************************************** // ************************************************************************* void LockVisObject(); // ************************************************************************* // *** UnlockVisObject ************************************************* // ************************************************************************* void UnlockVisObject(); // ************************************************************************* // *** Show ************************************************************ // ************************************************************************* // * Show VisObject on screen. This function call AddVisObjectToList() from // * DisplayDrv class. When this function calls first time, user must // * provide Z level. In future user can call this function without // * parameters - previously set Z will be used. virtual void Show(uint32_t z_pos = 0); // ************************************************************************* // *** Hide ************************************************************ // ************************************************************************* // * Hide VisObject from screen. This function call DelVisObjectFromList() // * from DisplayDrv class. virtual void Hide(void); // ************************************************************************* // *** IsShow ********************************************************** // ************************************************************************* // * Check status of Show Visual Object. Return true if object in DisplayDrv list. virtual bool IsShow(void); // ************************************************************************* // *** Move ************************************************************ // ************************************************************************* // * Move object on screen. Set new x and y coordinates. If flag is set - // * move is relative, not absolute. virtual void Move(int32_t x, int32_t y, bool is_delta = false); // ************************************************************************* // *** DrawInBufH ****************************************************** // ************************************************************************* // * Draw one horizontal line of object in specified buffer. // * Each derived class must implement this function. virtual void DrawInBufH(uint16_t* buf, int32_t n, int32_t row, int32_t start_y = 0) = 0; // ************************************************************************* // *** DrawInBufW ****************************************************** // ************************************************************************* // * Draw one vertical line of object in specified buffer. // * Each derived class must implement this function. virtual void DrawInBufW(uint16_t* buf, int32_t n, int32_t line, int32_t start_x = 0) = 0; // ************************************************************************* // *** Action ********************************************************** // ************************************************************************* virtual void Action(ActionType action, int32_t tx, int32_t ty); // ************************************************************************* // *** Return Start X coordinate *************************************** // ************************************************************************* virtual int32_t GetStartX(void) {return x_start;}; // ************************************************************************* // *** Return Start Y coordinate *************************************** // ************************************************************************* virtual int32_t GetStartY(void) {return y_start;}; // ************************************************************************* // *** Return End X coordinate ***************************************** // ************************************************************************* virtual int32_t GetEndX(void) {return x_end;}; // ************************************************************************* // *** Return End Y coordinate ***************************************** // ************************************************************************* virtual int32_t GetEndY(void) {return y_end;}; // ************************************************************************* // *** Return Width of object ****************************************** // ************************************************************************* virtual int32_t GetWidth(void) {return width;}; // ************************************************************************* // *** Return Height of object ***************************************** // ************************************************************************* virtual int32_t GetHeight(void) {return height;}; protected: // ************************************************************************* // *** Object parameters *********************************************** // ************************************************************************* // X and Y start coordinates of object int16_t x_start = 0, y_start = 0; // X and Y end coordinates of object int16_t x_end = 0, y_end = 0; // Width and Height of object int16_t width = 0, height = 0; // Rotation of object int8_t rotation = 0; // Object active bool active = false; private: // ************************************************************************* // *** Object parameters *********************************************** // ************************************************************************* // * Only base class and DisplayDrv have access to this parameters // Z position of object uint16_t z = 0; // Pointer to next object. This pointer need to maker object list. Object // can be added only to one list. VisObject* p_next = nullptr; // Pointer to next object. This pointer need to maker object list. Object // can be added only to one list. VisObject* p_prev = nullptr; // DisplayDrv is friend for access to pointers and Z friend class DisplayDrv; }; #endif</span></span></code> </pre> </div></div><br>              DrawInBufW()     ,  ,     ( <i>           ¬´¬ª</i> ).                        . <br><br>  ,         ‚Äî                      .         Action()   . <br><br>       , ( <i>, , </i> ),    ( <i>  </i> ). <br><br>    <b>DevCore</b>       UI( <i> </i> ),    I2C,  I2C       BME280  EEPROM 24256,           ‚Äî     . <br><br>    <s>   </s>  <b>GitHub</b> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">https://github.com/nickshl/devboy</a> <br><br> <b>PS</b>   ,    Epic Fail'.      ,     - " <i> </i> ", 180   ,          ( <i> , !</i> )        . <br><br>    ‚Äî   .  ‚Äî    ‚Ä¶ </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es424309/">https://habr.com/ru/post/es424309/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es424295/index.html">Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 9: "Seguridad de aplicaciones web", Parte 2</a></li>
<li><a href="../es424297/index.html">Curso MIT "Seguridad de sistemas inform√°ticos". Lecci√≥n 9: Seguridad de aplicaciones web, Parte 3</a></li>
<li><a href="../es424301/index.html">Algoritmo de filtro de imagen de red neuronal adaptativo</a></li>
<li><a href="../es424305/index.html">RIB de arquitectura m√≥vil multiplataforma de Uber</a></li>
<li><a href="../es424307/index.html">GitLab 11.3 lanzado con repositorio Maven y entornos seguros</a></li>
<li><a href="../es424311/index.html">L√≥gica comercial asincr√≥nica en estos d√≠as</a></li>
<li><a href="../es424313/index.html">EveryLang es un programa que puede hacer casi todo</a></li>
<li><a href="../es424315/index.html">Una nueva ronda de sustituci√≥n de importaciones. ¬øD√≥nde correr y qu√© hacer?</a></li>
<li><a href="../es424319/index.html">La estructura de la tienda en l√≠nea. Parte 2</a></li>
<li><a href="../es424321/index.html">Poner NetFlow barato y enojado</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>