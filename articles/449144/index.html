<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö© üêã üëáüèΩ Conceptos b√°sicos del motor de JavaScript: optimizaci√≥n de prototipos. Parte 2 üåº üë©üèΩ‚Äç‚öñÔ∏è üóúÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Buenas tardes amigos! Se lanz√≥ el curso "Seguridad de los sistemas de informaci√≥n" , en relaci√≥n con esto, compartimos con ustedes la parte final del ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Conceptos b√°sicos del motor de JavaScript: optimizaci√≥n de prototipos. Parte 2</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/449144/">  Buenas tardes amigos!  Se lanz√≥ el curso <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">"Seguridad de los sistemas de informaci√≥n"</a> , en relaci√≥n con esto, compartimos con ustedes la parte final del art√≠culo "Fundamentos de los motores JavaScript: optimizaci√≥n de prototipos", cuya primera parte se puede leer <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">aqu√≠</a> . <br><br>  Tambi√©n le recordamos que la publicaci√≥n actual es una continuaci√≥n de estos dos art√≠culos: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">‚ÄúFundamentos de los motores de JavaScript: formularios generales y almacenamiento en cach√© en l√≠nea.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 1 "</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">" Conceptos b√°sicos de los motores de JavaScript: formularios generales y almacenamiento en cach√© en l√≠nea.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2 "</a> . <br><br><img src="https://habrastorage.org/webt/2w/nl/r8/2wnlr8o2nlb7dcbfs4hgkbmf-hm.png"><br><br>  <b>Programaci√≥n de clases y prototipos.</b> <br><br>  Ahora que sabemos c√≥mo obtener acceso r√°pido a las propiedades de los objetos de JavaScript, podemos echar un vistazo a la estructura m√°s compleja de las clases de JavaScript.  As√≠ es como se ve la sintaxis de la clase en JavaScript: <br><br><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } }</code> </pre> <a name="habracut"></a><br>  Aunque esto parece un concepto relativamente nuevo para JavaScript, es solo "az√∫car sint√°ctico" para la programaci√≥n prototipo que siempre se ha utilizado en JavaScript: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Bar</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">x</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } Bar.prototype.getX = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getX</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; };</code> </pre> <br>  Aqu√≠ asignamos la propiedad <code>getX</code> objeto <code>getX</code> .  Esto funcionar√° igual que con cualquier otro objeto, ya que los prototipos en JavaScript son los mismos objetos.  En lenguajes de programaci√≥n de prototipos como JavaScript, se accede a los m√©todos a trav√©s de prototipos, mientras que los campos se almacenan en instancias espec√≠ficas. <br><br>  Echemos un vistazo m√°s de cerca a lo que sucede cuando creamos una nueva instancia de <code>Bar</code> , que llamaremos <code>foo</code> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br>  Una instancia creada con este c√≥digo tiene un formulario con una sola propiedad <code>'x'</code> .  El prototipo <code>foo</code> es <code>Bar.prototype</code> , que pertenece a la clase <code>Bar</code> . <br><br><img src="https://habrastorage.org/webt/bo/fa/q_/bofaq_0uieucjmw-dys_fv6rzk8.png"><br><br>  Este <code>Bar.prototype</code> tiene una forma de s√≠ mismo que contiene la √∫nica propiedad <code>'getX'</code> , cuyo valor est√° determinado por la funci√≥n <code>'getX'</code> , que cuando se llama devuelve <code>this.x</code>  El prototipo <code>Bar.prototype</code> es <code>Object.prototype</code> , que forma parte del lenguaje JavaScript.  <code>Object.prototype</code> es la ra√≠z del √°rbol prototipo, mientras que su prototipo es <code>null</code> . <br><br><img src="https://habrastorage.org/webt/do/wd/bu/dowdbubzibagdufziezgg9sp_tq.png"><br><br>  Cuando crea una nueva instancia de la misma clase, ambas instancias tienen la misma forma, como ya entendimos.  Ambas instancias apuntar√°n al mismo objeto <code>Bar.prototype</code> . <br><br>  <b>Acceder a las propiedades del prototipo</b> <br><br>  Bueno, ahora sabemos lo que sucede cuando definimos una clase y creamos una nueva instancia.  Pero, ¬øqu√© sucede si llamamos al m√©todo en la instancia, como hicimos en el siguiente ejemplo? <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">// ^^^^^^^^^^</span></span></code> </pre> <br>  Puede considerar cualquier llamada a un m√©todo como dos pasos separados: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">// is actually two steps: const $getX = foo.getX; const x = $getX.call(foo);</span></span></code> </pre><br>  El primer paso es cargar el m√©todo, que en realidad es una propiedad del prototipo (cuyo valor es una funci√≥n).  El segundo paso es llamar a una funci√≥n con una instancia, por ejemplo, el valor de <code>this</code> .  Echemos un vistazo m√°s de cerca al primer paso donde se <code>getX</code> m√©todo <code>getX</code> desde la instancia <code>foo</code> . <br><br><img src="https://habrastorage.org/webt/-o/8_/wo/-o8_wolugn73mtcs65v_yomvtzo.png"><br><br>  El motor inicia una instancia de <code>foo</code> y se da cuenta de que la forma <code>foo</code> no tiene <code>'getX'</code> , por lo que debe atravesar la cadena de prototipos para encontrarla.  Llegamos a <code>Bar.prototype</code> , miramos la forma del prototipo, vemos que tiene la propiedad <code>'getX'</code> en desplazamiento cero.  Buscamos el valor en este desplazamiento en <code>Bar.prototype</code> y encontramos la <code>JSFunction getX</code> que est√°bamos buscando. <br><br>  La flexibilidad de JavaScript permite que los enlaces de cadena prototipo cambien, por ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); foo.getX(); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí true Object.setPrototypeOf(foo, null); foo.getX(); // ‚Üí Uncaught TypeError: foo.getX is not a function</span></span></code> </pre> <br>  En este ejemplo, llamamos <pre> <code class="javascript hljs">foo.getX()</code> </pre>  dos veces, pero cada vez tiene significados y resultados completamente diferentes.  Es por eso que, a pesar del hecho de que los prototipos son solo objetos en JavaScript, acelerar el acceso a las propiedades de un prototipo es una tarea a√∫n m√°s importante para los motores de JavaScript que acelerar su propio acceso a las propiedades de los objetos normales. <br><br>  En la pr√°ctica diaria, cargar propiedades de prototipo es una operaci√≥n bastante com√∫n: ¬°esto sucede cada vez que llama a un m√©todo! <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> x = foo.getX(); <span class="hljs-comment"><span class="hljs-comment">// ^^^^^^^^^^</span></span></code> </pre> <br>  Anteriormente, hablamos sobre c√≥mo los motores optimizan la carga de propiedades regulares mediante el uso de formularios y cach√©s en l√≠nea.  ¬øC√≥mo puedo optimizar la carga de propiedades de prototipo para objetos de la misma forma?  Desde arriba vimos c√≥mo se cargan las propiedades. <br><br><img src="https://habrastorage.org/webt/h1/1q/tw/h11qtwohm_mgsjyp0iphqairudo.png"><br><br>  Para hacer esto r√°pidamente con descargas repetidas en este caso particular, necesita saber las siguientes tres cosas: <br><br><ul><li>  La forma <code>foo</code> no contiene <code>'getX'</code> y no ha cambiado.  Esto significa que nadie ha cambiado el objeto foo agregando o quitando una propiedad o cambiando uno de los atributos de la propiedad. </li><li>  El prototipo foo sigue siendo el prototipo original de <code>Bar.prototype</code> .  Entonces, nadie cambi√≥ el prototipo usando <code>Object.setPrototypeOf()</code> o asign√°ndolo a la propiedad especial <code>_proto_</code> . </li><li>  El formulario <code>Bar.prototype</code> contiene <code>'getX'</code> y no ha cambiado.  Esto significa que nadie ha cambiado <code>Bar.prototype</code> agregando o eliminando una propiedad o cambiando uno de los atributos de la propiedad. </li></ul><br>  En el caso general, esto significa que debe realizar una comprobaci√≥n de la instancia en s√≠ y dos comprobaciones m√°s para cada prototipo hasta el prototipo que contiene la propiedad deseada.  Las comprobaciones 1 + 2N, donde N es el n√∫mero de prototipos utilizados, no suena tan mal en este caso, ya que la cadena de prototipos es relativamente poco profunda.  Sin embargo, los motores a menudo tienen que lidiar con cadenas de prototipos mucho m√°s largas, como es el caso de las clases DOM regulares.  Por ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> anchor = <span class="hljs-built_in"><span class="hljs-built_in">document</span></span>.createElement(<span class="hljs-string"><span class="hljs-string">'a'</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ‚Üí HTMLAnchorElement const title = anchor.getAttribute('title');</span></span></code> </pre> <br>  Tenemos un <code>HTMLAnchorElement</code> y llamamos al m√©todo <code>getAttribute()</code> .  ¬°La cadena para este elemento simple ya incluye 6 prototipos!  La mayor√≠a de los m√©todos DOM que nos interesan no est√°n en el prototipo <code>HTMLAnchorElement</code> , sino en alg√∫n lugar de la cadena. <br><br><img src="https://habrastorage.org/webt/wz/kw/fa/wzkwfavxcgkiod8jgz0ybrmgzo8.png"><br><br>  El m√©todo <code>getAttribute()</code> est√° en <code>Element.prototype</code> .  Esto significa que cada vez que llamamos a <code>anchor.getAttribute()</code> , el motor de JavaScript necesita: <br><br><ol><li>  Compruebe que <code>'getAttribute'</code> no <code>'getAttribute'</code> un objeto de <code>anchor</code> per se; </li><li>  Verifique que el prototipo final sea <code>HTMLAnchorElement.prototype</code> ; </li><li>  Confirme la ausencia de <code>'getAttribute'</code> all√≠; </li><li>  Verifique que el pr√≥ximo prototipo sea <code>HTMLElement.prototype</code> ; </li><li>  Confirme la ausencia de <code>'getAttribute'</code> ; </li><li>  Verifique que el pr√≥ximo prototipo sea <code>Element.prototype</code> ; </li><li>  Compruebe que <code>'getAttribute'</code> presente en √©l. </li></ol><br>  Un total de 7 cheques.  Dado que este tipo de c√≥digo es bastante com√∫n en la web, los motores utilizan varios trucos para reducir la cantidad de comprobaciones necesarias para cargar las propiedades del prototipo. <br><br>  Volviendo a un ejemplo anterior en el que hicimos solo tres verificaciones cuando solicitamos <code>'getX'</code> para <code>foo</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(x) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x = x; } getX() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x; } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> foo = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-literal"><span class="hljs-literal">true</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> $getX = foo.getX;</code> </pre> <br>  Para cada objeto que se produce antes del prototipo que contiene la propiedad deseada, es necesario verificar los formularios para ver la ausencia de esta propiedad.  Ser√≠a bueno si pudi√©ramos reducir el n√∫mero de cheques presentando el cheque prototipo como un cheque por la ausencia de una propiedad.  En esencia, esto es exactamente lo que hacen los motores con un simple truco: en lugar de almacenar el enlace prototipo a la propia instancia, los motores lo almacenan en forma. <br><br><img src="https://habrastorage.org/webt/_q/j1/8q/_qj18qiex6e31a17r7sgho1r5hc.png"><br><br>  Cada forma indica un prototipo.  Esto significa que cada vez que el prototipo cambia, el motor se mueve a una nueva forma.  Ahora necesitamos verificar solo la forma del objeto para confirmar la ausencia de ciertas propiedades, as√≠ como proteger el enlace prototipo (proteger el enlace prototipo). <br><br>  Con este enfoque, podemos reducir la cantidad de verificaciones requeridas de 2N + 1 a 1 + N para acelerar el acceso.  Esta sigue siendo una operaci√≥n bastante costosa, ya que sigue siendo una funci√≥n lineal del n√∫mero de prototipos en la cadena.  Los motores utilizan varios trucos para reducir a√∫n m√°s el n√∫mero de comprobaciones a un cierto valor constante, especialmente en el caso de la carga secuencial de las mismas propiedades. <br><br>  <b>Celdas de validez</b> <br><br>  El V8 procesa formas prototipo espec√≠ficamente para este prop√≥sito.  Cada prototipo tiene una forma √∫nica que no se comparte con otros objetos (en particular, con otros prototipos), y cada una de estas formas de prototipo tiene un <code>ValidityCell</code> especial asociado con √©l. <br><br><img src="https://habrastorage.org/webt/pm/gc/m_/pmgcm_cjj6ufzx_dw8npfdbx2wi.png"><br><br>  Este <code>ValidityCell</code> desactiva cada vez que alguien cambia el prototipo asociado con √©l o cualquier otro prototipo que se encuentre encima.  Veamos como funciona. <br>  Para acelerar las descargas de prototipos posteriores, V8 coloca el cach√© en l√≠nea en una ubicaci√≥n de cuatro campos: <br><br><img src="https://habrastorage.org/webt/mr/ab/d2/mrabd2cyki6gglqlxphuqhjzoji.png"><br><br>  Cuando la cach√© en l√≠nea se calienta la primera vez que se ejecuta el c√≥digo, V8 recuerda el desplazamiento en el que se encontr√≥ la propiedad en el prototipo, este prototipo (por ejemplo, <code>Bar.prototype</code> ), el formulario de instancia (en nuestro caso, el formulario <code>foo</code> ), y tambi√©n une el <code>ValidityCell</code> actual al prototipo recibido desde la instancia del formulario (en nuestro caso, se toma el <code>Bar.prototype</code> .). <br><br>  La pr√≥xima vez que use el cach√© en l√≠nea, el motor debe verificar el formulario de instancia y <code>ValidityCell</code> .  Si a√∫n es v√°lido, el motor usa directamente el desplazamiento en el prototipo, omitiendo los pasos de b√∫squeda adicionales. <br><br><img src="https://habrastorage.org/webt/hd/qw/4w/hdqw4wkuumyd9dmm0opxan9cbji.png"><br><br>  Al cambiar el prototipo, se resalta un nuevo formulario y se deshabilita la celda anterior <code>ValidityCell</code> .  Debido a esto, la cach√© en l√≠nea se omite la pr√≥xima vez que se inicia, lo que conduce a un bajo rendimiento. <br><br>  Volvamos al ejemplo con el elemento DOM.  Cada cambio en <code>Object.prototype</code> no solo invalida las memorias cach√© en l√≠nea para <code>Object.prototype</code> , sino tambi√©n para cualquier prototipo en la cadena debajo de √©l, incluidos <code>EventTarget.prototype</code> , <code>Node.prototype</code> , <code>Element.prototype</code> , etc., hasta <code>HTMLAnchorElement.prototype</code> s√≠. <br><br><img src="https://habrastorage.org/webt/oo/ml/ga/oomlgamrgo0peti1y3xsae-vtes.png"><br><br>  De hecho, modificar <code>Object.prototype</code> mientras se ejecuta el c√≥digo es una p√©rdida de rendimiento terrible.  ¬°No hagas esto! <br><br>  Veamos un ejemplo espec√≠fico para comprender mejor c√≥mo funciona esto.  Digamos que tenemos una clase <code>Bar</code> y una funci√≥n <code>loadX</code> que llama a un m√©todo en objetos de tipo <code>Bar</code> .  Llamamos a la funci√≥n <code>loadX</code> varias veces con instancias de la misma clase. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ‚Ä¶ */</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">loadX</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">bar</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> bar.getX(); <span class="hljs-comment"><span class="hljs-comment">// IC for 'getX' on `Bar` instances. } loadX(new Bar(true)); loadX(new Bar(false)); // IC in `loadX` now links the `ValidityCell` for // `Bar.prototype`. Object.prototype.newMethod = y =&gt; y; // The `ValidityCell` in the `loadX` IC is invalid // now, because `Object.prototype` changed.</span></span></code> </pre> <br>  El cach√© en l√≠nea en <code>loadX</code> ahora apunta a <code>Bar.prototype</code> para <code>Bar.prototype</code> .  Si luego modifica el <code>Object.prototype</code> ( <code>Object.prototype</code> ), que es la ra√≠z de todos los prototipos en JavaScript, <code>ValidityCell</code> se invalida y la pr√≥xima vez no se utilizar√°n cach√©s en l√≠nea existentes, lo que <code>Object.prototype</code> un rendimiento deficiente. <br><br>  Cambiar <code>Object.prototype</code> siempre es una mala idea, ya que invalida cualquier cach√© en l√≠nea para prototipos cargados en el momento del cambio.  Aqu√≠ hay un ejemplo de c√≥mo NO hacerlo: <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.prototype.foo = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-comment"><span class="hljs-comment">/* ‚Ä¶ */</span></span> }; <span class="hljs-comment"><span class="hljs-comment">// Run critical code: someObject.foo(); // End of critical code. delete Object.prototype.foo;</span></span></code> </pre> <br>  Estamos ampliando <code>Object.prototype</code> , que invalida todos los cach√©s de prototipos en l√≠nea cargados por el motor en este momento.  Luego ejecutaremos un c√≥digo que utiliza el m√©todo descrito por nosotros.  El motor tendr√° que comenzar desde el principio y configurar cach√©s en l√≠nea para cualquier acceso a la propiedad del prototipo.  Y luego, finalmente, "limpiar" y eliminar el m√©todo prototipo que agregamos anteriormente. <br><br>  ¬øCrees que limpiar es una buena idea, verdad?  Bueno, en este caso, ¬°empeorar√° a√∫n m√°s la situaci√≥n!  La eliminaci√≥n de propiedades cambia <code>Object.prototype</code> , por lo que todas las memorias cach√© en l√≠nea se deshabilitan nuevamente, y el motor tiene que comenzar a trabajar desde el principio nuevamente. <br><br>  <b>Para resumir</b> .  A pesar del hecho de que los prototipos son solo objetos, los motores JavaScript los procesan especialmente para optimizar el rendimiento de las b√∫squedas de m√©todos por prototipos.  <b>¬°Deja en paz los prototipos!</b>  O si realmente necesita lidiar con ellos, ¬°h√°galo antes de ejecutar el c√≥digo, para que al menos no invalide todos los intentos de optimizar su c√≥digo durante su ejecuci√≥n! <br><br><blockquote>  <b>Resumir</b> <br><br>  Aprendimos c√≥mo JavaScript almacena objetos y clases, y c√≥mo los formularios, los cach√©s en l√≠nea y las celdas de validez ayudan a optimizar las operaciones del prototipo.  En base a este conocimiento, entendimos c√≥mo mejorar el rendimiento desde un punto de vista pr√°ctico: ¬°no toque los prototipos!  (o si realmente lo necesita, h√°galo antes de ejecutar el c√≥digo). </blockquote><br>  ‚Üê <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La primera parte</a> <br><br>  ¬øLe fue √∫til esta serie de publicaciones?  Escribe en los comentarios. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/449144/">https://habr.com/ru/post/449144/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../449132/index.html">Los mejores 17 complementos para Android Studio</a></li>
<li><a href="../449134/index.html">Zoo afl</a></li>
<li><a href="../449138/index.html">5 razones para crypto-hat ¬øPor qu√© a la gente de TI no le gusta Bitcoin?</a></li>
<li><a href="../449140/index.html">Deje una solicitud y le responderemos en l√≠nea en 1 minuto. O c√≥mo nos alejamos de OTRS</a></li>
<li><a href="../449142/index.html">Microbiota ¬øQu√© bacterias viven en los intestinos de los rusos?</a></li>
<li><a href="../449146/index.html">¬øPero no saludamos a la comunicaci√≥n √≥ptica? L√°ser, espacio, CubeSat</a></li>
<li><a href="../449148/index.html">Libros de arte para ni√±os sobre ingenier√≠a social.</a></li>
<li><a href="../449154/index.html">Preguntas frecuentes sobre el etiquetado obligatorio de zapatos: todo lo que no sab√≠a y ten√≠a miedo de preguntar</a></li>
<li><a href="../449158/index.html">Rough Coster: Libro de cocina comunitaria</a></li>
<li><a href="../449162/index.html">C ++ Rusia 2019. Un peque√±o informe del lugar de los eventos y el anuncio de la pr√≥xima conferencia en San Petersburgo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>