<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ‘¨â€ğŸ­ ğŸŒ‚ ğŸ‘¨ğŸ»â€ğŸ”¬ Bagaimana wadah sespan ini sampai di sini [di Kubernetes]? ğŸ”¬ ğŸ›µ ğŸ‘ŒğŸ¿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Catatan perev. : Dengan artikel ini, yang ditulis oleh Scott Rahner, seorang insinyur di Dow Jones, kami melanjutkan serangkaian banyak bahan yang men...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana wadah sespan ini sampai di sini [di Kubernetes]?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/flant/blog/431252/">  <i><b>Catatan</b></i>  <i><b>perev.</b></i>  <i>: Dengan artikel ini, yang ditulis oleh Scott Rahner, seorang insinyur di Dow Jones, kami melanjutkan serangkaian banyak bahan yang menjelaskan bagaimana Kubernetes bekerja, bagaimana komponen dasarnya bekerja, saling terhubung dan digunakan.</i>  <i>Kali ini ini adalah catatan praktis dengan kode sampel untuk membuat kait di Kubernetes, yang ditunjukkan oleh penulis "dengan dalih" untuk secara otomatis membuat wadah sespan.</i> <br><br><img src="https://habrastorage.org/webt/xg/bh/80/xgbh80h6dyzuokwsgrcttaiqtxs.jpeg"><br>  <i>(Foto oleh Gordon A. Maxwell, ditemukan di Internet.)</i> <br><br>  Ketika saya mulai mempelajari wadah sespan dan service mesh, saya perlu memahami bagaimana mekanisme kunci bekerja - penyisipan otomatis wadah sespan.  Memang, dalam kasus menggunakan sistem seperti Istio atau Konsul, ketika wadah dengan aplikasi dikerahkan, wadah Utusan yang sudah dikonfigurasi tiba-tiba muncul di podnya <i>(situasi serupa terjadi dengan Conduit, yang kami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tulis</a> di awal tahun - kira-kira Terjemahkan.)</i> .  Apa?  Bagaimana?  Jadi penelitian saya dimulai ... <a name="habracut"></a><br><br>  Bagi mereka yang tidak tahu, wadah sespan adalah wadah yang ditempatkan di sebelah wadah aplikasi untuk "membantu" aplikasi ini dengan cara tertentu.  Contoh penggunaan tersebut adalah proksi untuk mengelola lalu lintas dan mengakhiri sesi TLS, wadah untuk streaming log dan metrik, wadah untuk memindai masalah keamanan ... Idenya adalah untuk mengisolasi berbagai aspek dari seluruh aplikasi dari logika bisnis dengan menggunakan wadah terpisah untuk masing-masing fungsi. <br><br>  Sebelum melanjutkan, saya akan menjabarkan harapan saya.  Tujuan artikel ini bukan untuk menjelaskan seluk-beluk dan skenario penggunaan Docker, Kubernetes, service mesh, dll., Tetapi untuk menunjukkan satu pendekatan yang kuat untuk memperluas kemampuan teknologi ini.  Artikel ini ditujukan bagi mereka yang sudah terbiasa dengan penggunaan teknologi ini atau, setidaknya, telah membaca banyak tentang mereka.  Untuk mencoba bagian praktis dalam aksi, Anda akan membutuhkan mesin dengan Docker dan Kubernetes yang sudah dikonfigurasi.  Cara termudah untuk melakukan ini adalah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://docs.docker.com/docker-for-windows/kubernetes/</a> (manual Windows yang bekerja dengan Docker untuk Mac).  <i>(Catatan perev .: Sebagai alternatif bagi pengguna Linux dan * nix-sistem, kami dapat menawarkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Minikube</a> .)</i> <br><br><h2>  Gambaran keseluruhan </h2><br>  Untuk memulai, mari kita lihat sedikit Kubernetes: <br><br><img src="https://habrastorage.org/webt/gf/dh/2d/gfdh2deneli8j1ikyuutjbf2uvm.png"><br>  <i><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kube Arch</a> dilisensikan di bawah CC BY 4.0</i> <br><br>  Ketika Anda bermaksud untuk menyebarkan sesuatu ke Kubernetes, Anda harus mengirim objek ke kube-apiserver.  Ini paling sering dilakukan dengan memberikan argumen atau file YAML ke kubectl.  Dalam hal ini, server API melewati beberapa tahap sebelum langsung menempatkan data dalam etcd dan menjadwalkan tugas yang sesuai: <br><br><img src="https://habrastorage.org/webt/g-/mv/hw/g-mvhwfhhsoxrdofk2be2ezkrow.jpeg"><br><br>  Urutan ini penting untuk memahami cara kerja penyisipan wadah sespan.  Secara khusus, Anda perlu memperhatikan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kontrol Penerimaan</a> , di mana Kubernetes memvalidasi dan, jika perlu, memodifikasi objek sebelum menyimpannya <i>(untuk rincian lebih lanjut tentang langkah ini, lihat bab "Kontrol akses" di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel ini</a> - sekitar Terjemahan.)</i> .  Kubernetes juga memungkinkan Anda untuk mendaftar <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">webhook</a> yang dapat melakukan validasi dan <i>mutasi yang</i> ditentukan pengguna. <br><br>  Namun, proses membuat dan mendaftarkan kait Anda tidak begitu sederhana dan didokumentasikan dengan baik.  Saya harus menghabiskan beberapa hari membaca dan membaca kembali dokumentasi, serta menganalisis kode Istio dan Konsul.  Dan ketika sampai pada kode untuk beberapa tanggapan API, saya menghabiskan setidaknya setengah hari melakukan percobaan dan kesalahan acak. <br><br>  Setelah hasilnya tercapai, saya pikir tidak adil untuk tidak membagikannya kepada Anda semua.  Ini sederhana dan sekaligus efektif. <br><br><h2>  Kode </h2><br>  Nama webhook berbicara untuk dirinya sendiri - itu adalah titik akhir HTTP yang mengimplementasikan API yang didefinisikan dalam Kubernetes.  Anda membuat server API yang dapat dipanggil Kubernetes sebelum berurusan dengan Penyebaran.  Saya harus berurusan dengan kesulitan di sini, karena hanya beberapa contoh yang tersedia, beberapa di antaranya hanya unit test Kubernetes, yang lain tersembunyi di tengah-tengah basis kode besar ... dan semua ditulis dalam Go.  Tapi saya memilih opsi yang lebih terjangkau - Node.js: <br><br><pre><code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> app = express(); app.use(bodyParser.json()); app.post(<span class="hljs-string"><span class="hljs-string">'/mutate'</span></span>, (req, res) =&gt; { <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(req.body) <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(req.body.request.object) <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> adminResp = {<span class="hljs-attr"><span class="hljs-attr">response</span></span>:{ <span class="hljs-attr"><span class="hljs-attr">allowed</span></span>: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, <span class="hljs-attr"><span class="hljs-attr">patch</span></span>: Buffer.from(<span class="hljs-string"><span class="hljs-string">"[{ \"op\": \"add\", \"path\": \"/metadata/labels/foo\", \"value\": \"bar\" }]"</span></span>).toString(<span class="hljs-string"><span class="hljs-string">'base64'</span></span>), <span class="hljs-attr"><span class="hljs-attr">patchType</span></span>: <span class="hljs-string"><span class="hljs-string">"JSONPatch"</span></span>, }} <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(adminResp) res.send(adminResp) }) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = https.createServer(options, app);</code> </pre> <br>  <i>( <a href="">index.js</a> )</i> <br><br>  Jalur ke API - dalam hal ini <code>/mutate</code> - dapat berubah-ubah (hanya sesuai dengan YAML yang diteruskan ke Kubernetes di masa mendatang).  Penting baginya untuk melihat dan memahami JSON yang diterima dari server API.  Dalam hal ini, kami tidak menarik apa pun dari JSON, tetapi mungkin berguna dalam skenario lain.  Dalam kode di atas, kami memperbarui JSON.  Dua hal diperlukan untuk ini: <br><br><ol><li>  Pelajari dan pahami <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JSON Patch</a> . </li><li>  Konversi ekspresi Patch JSON dengan benar menjadi array byte yang disandikan dengan base64. </li></ol><br>  Setelah ini selesai, yang harus Anda lakukan adalah memberikan respons ke server API dengan objek yang sangat sederhana.  Dalam hal ini, kami menambahkan label <code>foo=bar</code> sembarang pod yang datang kepada kami. <br><br><h2>  Penempatan </h2><br>  Ya, kami memiliki kode yang menerima permintaan dari server API Kubernetes dan meresponsnya, tetapi bagaimana cara menggunakannya?  Dan bagaimana cara mendapatkan Kubernetes untuk mengarahkan permintaan ini kepada kami?  Anda dapat menggunakan titik akhir seperti itu di mana saja Anda dapat mencapai server API Kubernetes.  Cara paling sederhana adalah dengan menyebarkan kode ke kluster Kubernetes itu sendiri, yang akan kita lakukan dalam contoh ini.  Saya mencoba membuat contoh sesederhana mungkin, jadi untuk semua tindakan saya hanya menggunakan Docker dan kubectl.  Mari kita mulai dengan membuat wadah tempat kode akan dijalankan: <br><br><pre> <code class="plaintext hljs">FROM node:8 USER node WORKDIR /home/node COPY index.js . COPY package.json . RUN npm install #       TLS CMD node index.js</code> </pre> <br>  <i>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dockerfile</a> )</i> <br><br>  Ternyata, semuanya sangat sederhana di sini.  Ambil gambar komunitas dari node dan masukkan kode ke dalamnya.  Sekarang Anda dapat melakukan perakitan sederhana: <br><br><pre> <code class="bash hljs">docker build . -t localserver</code> </pre> <br>  Langkah selanjutnya adalah membuat Penempatan di Kubernetes: <br><br><pre> <code class="plaintext hljs">apiVersion: apps/v1 kind: Deployment metadata: name: webhook-server spec: replicas: 1 selector: matchLabels: component: webhook-server template: metadata: labels: component: webhook-server spec: containers: - name: webhook-server imagePullPolicy: Never image: localserver</code> </pre> <br>  <i>( <a href="">deployment.yaml</a> )</i> <br><br>  Perhatikan bagaimana kita menyinggung gambar yang baru saja kita buat?  Bisa juga berupa pod, dan hal lain yang bisa kita hubungkan dengan layanan di Kubernetes.  Sekarang tentukan Layanan ini: <br><br><pre> <code class="plaintext hljs">apiVersion: v1 kind: Service metadata: name: webhook-service spec: ports: - port: 443 targetPort: 8443 selector: component: webhook-server</code> </pre> <br>  Jadi di Kubernetes, titik akhir muncul dengan nama internal yang menunjuk ke wadah kami.  Langkah terakhir adalah memberi tahu Kubernetes bahwa kami ingin server API memanggil layanan ini ketika siap membuat <i>mutasi</i> : <br><br><pre> <code class="plaintext hljs">apiVersion: admissionregistration.k8s.io/v1beta1 kind: MutatingWebhookConfiguration metadata: name: webhook webhooks: - name: webhook-service.default.svc failurePolicy: Fail clientConfig: service: name: webhook-service namespace: default path: "/mutate" #    base64-  rootCA.crt #    `cat rootCA.crt | base64 | tr -d '\n'` #    .  caBundle: "==" rules: - operations: [ "CREATE" ] apiGroups: [""] apiVersions: ["v1"] resources: ["pods"]</code> </pre>  <i>( <a href="">hook.yaml</a> )</i> <br><br>  Nama dan jalur di sini dapat berupa apa saja, tetapi saya mencoba menjadikannya bermakna mungkin.  Mengubah jalur berarti perlunya memodifikasi kode yang sesuai dalam JavaScript.  Webhook <code>failurePolicy</code> juga <code>failurePolicy</code> - menentukan apakah objek harus disimpan jika kail mengembalikan kesalahan atau gagal.  Dalam hal ini, kami memberi tahu Kubernetes untuk tidak melanjutkan pemrosesan.  Akhirnya, aturan: mereka akan berubah tergantung pada API panggilan mana yang Anda harapkan dari Kubernetes.  Dalam hal ini, karena kami mencoba untuk meniru penyisipan wadah sespan, kami perlu mencegat permintaan untuk membuat pod. <br><br>  Itu saja!  Sangat sederhana ... tapi bagaimana dengan keamanan?  RBAC adalah salah satu aspek yang tidak tercakup dalam artikel.  Saya berasumsi bahwa Anda menjalankan contoh di Minikube atau di Kubernetes, yang dilengkapi dengan Docker untuk Windows / Mac.  Namun, saya akan memberi tahu Anda tentang elemen lain yang diperlukan.  Server API Kubernetes hanya mengakses titik akhir dengan HTTPS, sehingga aplikasi memerlukan sertifikat SSL.  Anda juga perlu memberi tahu Kubernetes siapa otoritas sertifikasi dari sertifikat root. <br><br><h2>  TLS </h2><br>  <b>Untuk tujuan demonstrasi saja (!!!),</b> saya menambahkan beberapa kode ke <code>Dockerfile</code> untuk membuat root CA dan menggunakannya untuk menandatangani sertifikat: <br><br><pre> <code class="plaintext hljs">RUN openssl genrsa -out rootCA.key 4096 RUN openssl req -x509 -new -nodes -key rootCA.key -sha256 -days 1024 -out rootCA.crt \ -subj "/C=US/ST=New Jersey/L=Princeton /O=Dow Jones/OU=PIB/CN=*.default.svc/emailAddress=scott.rahner@dowjones.com" RUN openssl genrsa -out webhook.key 4096 RUN openssl req -new -key webhook.key -out webhook.csr \ -subj "/C=US/ST=New Jersey/L=Princeton /O=Dow Jones/OU=PIB/CN=webhook-service.default.svc/emailAddress=scott.rahner@dowjones.com" RUN openssl x509 -req -in webhook.csr -CA rootCA.crt -CAkey rootCA.key -CAcreateserial -out webhook.crt -days 1024 -sha256 RUN cat rootCA.crt | base64 | tr -d '\n'</code> </pre> <br>  <i>( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Dockerfile</a> )</i> <br><br>  Harap dicatat: langkah terakhir adalah menampilkan satu baris dengan root CA yang disandikan di base64.  Ini adalah persis apa yang diperlukan untuk konfigurasi hook, jadi dalam pengujian Anda selanjutnya, pastikan untuk menyalin baris ini ke bidang <code>caBundle</code> dari file <code>caBundle</code> .  <code>Dockerfile</code> melempar sertifikat langsung ke <code>WORKDIR</code> , jadi JavaScript hanya mengambilnya dari sana dan menggunakannya untuk server: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> privateKey = fs.readFileSync(<span class="hljs-string"><span class="hljs-string">'webhook.key'</span></span>).toString(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> certificate = fs.readFileSync(<span class="hljs-string"><span class="hljs-string">'webhook.crt'</span></span>).toString(); <span class="hljs-comment"><span class="hljs-comment">//â€¦ const options = {key: privateKey, cert: certificate}; const server = https.createServer(options, app);</span></span></code> </pre> <br>  Sekarang kode mendukung peluncuran HTTPS, dan juga memberi tahu Kubernetes di mana menemukan kami dan pusat kepercayaan mana yang harus dipercaya.  Tetap hanya untuk menanamkan semuanya ke dalam kluster: <br><br><pre> <code class="bash hljs">kubectl create -f deployment.yaml kubectl create -f service.yaml kubectl create -f hook.yaml</code> </pre> <br><h3>  Ringkaslah </h3><br><ul><li>  <code>Deployment.yaml</code> meluncurkan wadah yang melayani API hook melalui HTTPS dan mengembalikan Patch JSON untuk memodifikasi objek. </li><li>  <code>Service.yaml</code> menyediakan titik akhir untuk wadah - <code>webhook-service.default.svc</code> . </li><li>  <code>Hook.yaml</code> memberi tahu server API tempat untuk menemukan kami: <code>https://webhook-service.default.svc/mutate</code> . </li></ul><br><h2>  Mari kita coba dalam bisnis! </h2><br>  Semuanya dikerahkan dalam sebuah cluster - saatnya untuk mencoba kode dalam tindakan, yang akan kita lakukan dengan menambahkan pod / Penempatan baru.  Jika semuanya berfungsi dengan benar, hook harus menambahkan label <code>foo</code> tambahan: <br><br><pre> <code class="plaintext hljs">apiVersion: apps/v1 kind: Deployment metadata: name: test spec: replicas: 1 selector: matchLabels: component: test template: metadata: labels: component: test spec: containers: - name: test image: node:8 command: [ "/bin/sh", "-c", "--" ] args: [ "while true; do sleep 30; done;" ]</code> </pre> <br>  <i>( <a href="">test.yaml</a> )</i> <br><br><pre> <code class="bash hljs">kubectl create -f test.yaml</code> </pre> <br>  Oke, kami melihat <code>deployment.apps test created</code> ... tetapi apakah berhasil? <br><br><pre> <code class="bash hljs">kubectl describe pods <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> Name: <span class="hljs-built_in"><span class="hljs-built_in">test</span></span>-6f79f9f8bd-r7tbd Namespace: default Node: docker-for-desktop/192.168.65.3 Start Time: Sat, 10 Nov 2018 16:08:47 -0500 Labels: component=<span class="hljs-built_in"><span class="hljs-built_in">test</span></span> foo=bar</code> </pre> <br>  Hebat!  Meskipun <code>test.yaml</code> diberi label tunggal ( <code>component</code> ), pod yang dihasilkan menerima dua: <code>component</code> dan <code>foo</code> . <br><br><h2>  PR </h2><br>  Tapi tunggu!  Apakah kita akan menggunakan kode ini untuk membuat wadah sespan?  Saya memperingatkan bahwa saya akan menunjukkan <b>cara</b> menambahkan sespan ... Dan sekarang, dengan pengetahuan dan kode: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://github.com/dowjones/k8s-webhook</a> - jangan ragu untuk bereksperimen dan mencari cara untuk membuat sespan yang dimasukkan secara otomatis.  Ini cukup sederhana: Anda hanya perlu menyiapkan JSON Patch yang benar, yang akan menambahkan wadah tambahan dalam penyebaran Penerapan.  Selamat orkestra! <br><br><h2>  PS dari penerjemah </h2><br>  Baca juga di blog kami: <br><br><ul><li>  â€œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jadi, apa itu pod di Kubernetes?</a>  "; </li><li>  â€œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Seberapa Ketersediaan Tinggi di Kubernetes Disediakan</a> â€; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagaimana cara kerja penjadwal Kubernetes bekerja?"</a>  "; </li><li>  "Apa yang terjadi di Kubernet ketika proses lari kubectl dimulai?"  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagian 2</a> ; </li><li>  " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memahami RBAC di Kubernetes</a> "; </li><li>  â€œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Pengalaman kami dengan Kubernetes dalam proyek-proyek kecil</a> â€ <i>(laporan video, yang mencakup pengenalan perangkat teknis Kubernetes)</i> ; </li><li>  â€œ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Apa itu service mesh dan mengapa saya membutuhkannya?</a>  ". </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id431252/">https://habr.com/ru/post/id431252/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id431242/index.html">Sertifikat TLS dan Web</a></li>
<li><a href="../id431244/index.html">"Dua tanpa filter" atau cara mudah untuk menembak kaki</a></li>
<li><a href="../id431246/index.html">@OpenStack Meetup di Mail.Ru Group: 30 November</a></li>
<li><a href="../id431248/index.html">Siapa yang akan bertanggung jawab dengan gesit untuk kualitas pengembangan proyek yang kompleks, atau metodologi Quality Gates</a></li>
<li><a href="../id431250/index.html">Penganut pengetikan statis dan dinamis tidak akan pernah saling memahami. Dan TypeScript tidak akan membantu mereka</a></li>
<li><a href="../id431254/index.html">Cara hidup dengan baik di situs terpencil</a></li>
<li><a href="../id431256/index.html">Inggris dan Belanda mendenda Uber $ 1,2 juta untuk kebocoran data pribadi</a></li>
<li><a href="../id431258/index.html">Webinar Desember Kotlin 1.3</a></li>
<li><a href="../id431260/index.html">Cara kerjanya: kerja tim analis yang menggunakan contoh pengembangan satu layanan digital</a></li>
<li><a href="../id431262/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 19: "Jaringan Anonim," bagian 1 (kuliah dari pencipta jaringan Tor)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>