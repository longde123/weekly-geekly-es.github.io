<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üñêüèª ü§üüèæ üà¥ Arbeiten mit Bildern in Python üë©üèæ‚Äçüíº ü§üüèæ üë®‚Äçüî¨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Thema der heutigen Konversation ist das, was Python in all den Jahren seines Bestehens in der Arbeit mit Bildern gelernt hat. Zus√§tzlich zu den Ol...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Arbeiten mit Bildern in Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/425471/">  Das Thema der heutigen Konversation ist das, was Python in all den Jahren seines Bestehens in der Arbeit mit Bildern gelernt hat.  Zus√§tzlich zu den Oldies von ImageMagick und GraphicsMagick aus dem Jahr 1990 gibt es moderne effektive Bibliotheken.  Zum Beispiel Pillow und produktiveres Pillow-SIMD.  Ihr aktiver Entwickler Alexander Karpinsky ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">homm</a> ) von MoscowPython verglich verschiedene Bibliotheken f√ºr die Arbeit mit Bildern in Python, pr√§sentierte Benchmarks und sprach √ºber nicht offensichtliche Funktionen, die immer ausreichen.  In diesem Artikel hilft Ihnen eine Abschrift des Berichts dabei, eine Bibliothek f√ºr Ihre Anwendung auszuw√§hlen und sie so effizient wie m√∂glich zu gestalten. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/CZ99Q0DQq3Y" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <strong>√úber den Sprecher:</strong> Alexander Karpinsky arbeitet bei <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Uploadcare</a> und besch√§ftigt sich mit der schnellen Bild√§nderung im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">laufenden</a> Betrieb.  Er ist an der Entwicklung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pillow beteiligt</a> , einer beliebten Bibliothek f√ºr die Arbeit mit Bildern in Python, und entwickelt einen eigenen Zweig dieser Bibliothek, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pillow-SIMD</a> , der moderne Prozessoranweisungen f√ºr maximale Leistung verwendet. <br><a name="habracut"></a><br><h2>  Hintergrund <br></h2><br>  Der Image-√Ñnderungsdienst von Uploadcare ist ein Server, der eine HTTP-Anforderung mit einer Image-ID und einigen Vorg√§ngen empf√§ngt, die ein Client ausf√ºhren muss.  Der Server muss die Vorg√§nge abschlie√üen und so schnell wie m√∂glich reagieren.  Der Client fungiert meistens als Browser. <br><br>  Der gesamte Dienst kann als Wrapper um die Grafikbibliothek beschrieben werden.  Die Qualit√§t des gesamten Projekts h√§ngt von der Qualit√§t, Leistung und Benutzerfreundlichkeit der Grafikbibliothek ab.  Es ist leicht zu erraten, dass Uploadcare Pillow als Grafikbibliothek verwendet. <br><br><h2>  Bibliotheken <br></h2><br>  Wir werden kurz untersuchen, welche Art von Grafikbibliotheken in Python im Allgemeinen vorhanden sind, um besser zu verstehen, was sp√§ter erl√§utert wird. <br><br><h3>  Kissen <br></h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kissengabel</a> von PIL (Python Imaging Library).  Dies ist ein sehr altes Projekt, das 1995 f√ºr Python 1.2 ver√∂ffentlicht wurde.  Sie k√∂nnen sich vorstellen, wie alt er ist!  Irgendwann wurde die Python Imaging Library aufgegeben und ihre Entwicklung gestoppt.  Eine Gabel aus Kissen wurde hergestellt, um die Python Imaging Library auf modernen Systemen zu installieren und zu erstellen.  Allm√§hlich wuchs die Anzahl der √Ñnderungen, die in der Python Imaging Library ben√∂tigt wurden, und Pillow 2.0 wurde ver√∂ffentlicht, wodurch Python 3 unterst√ºtzt wurde. Dies kann als Beginn eines separaten Lebens des Pillow-Projekts angesehen werden. <br><br>  Pillow ist ein natives Modul f√ºr Python. Die H√§lfte des Codes ist in C geschrieben, die andere H√§lfte in Python.  Die unterschiedlichsten Versionen von Python werden unterst√ºtzt: 2.7, 3.3+, PP, . <br><br><h3>  Pillow-SIMD <br></h3><br>  Dies ist meine Gabel aus Kissen, die im Mai 2016 herauskommt.  SIMD steht f√ºr Single Instruction, Multiple Data <strong>&nbsp;</strong>  - Ein Ansatz, bei dem der Prozessor mit modernen Anweisungen eine gr√∂√üere Anzahl von Aktionen pro Zyklus ausf√ºhren kann. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pillow-SIMD</a> ist keine Gabel im klassischen Sinne, wenn ein Projekt beginnt, sein eigenes Leben zu f√ºhren.  Dies ist ein Ersatz f√ºr Pillow, dh Sie installieren eine Bibliothek anstelle einer anderen, √§ndern keine Zeile in Ihrem Quellcode und erzielen mehr Leistung. <br><br>  Pillow-SIMD kann mit SSE4-Anweisungen zusammengebaut werden (Standard).  Dies ist eine Reihe von Anweisungen, die in fast allen modernen x86-Prozessoren enthalten sind.  Pillow-SIMD kann auch mit dem AVX2-Befehlssatz zusammengebaut werden.  Diese Anleitung beginnt mit der Haswell-Architektur, dh ungef√§hr ab 2013. <br><br><h3>  Opencv <br></h3><br>  Eine weitere Bibliothek f√ºr die Arbeit mit Bildern in Python, von der Sie wahrscheinlich geh√∂rt haben, ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OpenCV</a> (Open Computer Vision).  Es funktioniert seit 2000.  Python-Bindung ist enthalten.  Dies bedeutet, dass die Bindung st√§ndig relevant ist und keine Synchronit√§t zwischen der Bibliothek selbst und der Bindung besteht. <br><br>  Leider wird diese Bibliothek in PyPy noch nicht unterst√ºtzt, da OpenCV auf numpy basiert und numpy erst k√ºrzlich unter PyPy funktioniert und in OpenCV PyPy immer noch nicht unterst√ºtzt wird. <br><br><h3>  VIPS <br></h3><br>  Eine weitere Bibliothek, die es wert ist, beachtet zu werden, ist VIPS.  Die Hauptidee von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">VIPS</a> ist, dass Sie nicht das gesamte Bild in den Speicher laden m√ºssen, um mit dem Bild zu arbeiten.  Die Bibliothek kann einige kleine Teile laden, verarbeiten und speichern.  Um Gigapixel-Bilder zu verarbeiten, m√ºssen Sie also keine Gigabyte Speicherplatz aufwenden. <br><br>  Dies ist eine ziemlich alte Bibliothek - 1993, aber sie hat ihre Zeit √ºberholt.  Lange Zeit war wenig dar√ºber zu h√∂ren, aber seit kurzem tauchen VIPS-Ordner f√ºr verschiedene Sprachen auf, darunter f√ºr Go, Node.js, Ruby. <br><br>  Lange wollte ich diese Bibliothek ausprobieren, um sie zu f√ºhlen, aber es gelang mir aus einem sehr dummen Grund nicht.  Ich konnte nicht herausfinden, wie man VIPS installiert, da die Bindung sehr kompliziert war.  Aber jetzt (im Jahr 2017) wurde die Pyvips-Bindung vom Autor des VIPS selbst freigegeben, mit dem es keine Probleme mehr gibt.  Die Installation und Verwendung von VIPS ist jetzt sehr einfach.  Unterst√ºtzt: Python 2.7, 3.3+, RuPu, RuPuZ. <br><br><h3>  ImageMagick &amp; GraphicsMagick <br></h3><br>  Wenn wir √ºber die Arbeit mit Grafiken sprechen, k√∂nnen wir die alten Leute erw√§hnen - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ImageMagick-</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GraphicsMagick-</a> Bibliotheken.  Letzteres war urspr√ºnglich eine Abzweigung von ImageMagick mit h√∂herer Leistung, aber jetzt scheint ihre Leistung gleich zu sein.  Soweit ich wei√ü, gibt es keine weiteren grundlegenden Unterschiede zwischen ihnen.  Daher k√∂nnen Sie genau das verwenden, das Sie bevorzugen. <br><br>  Dies sind die √§ltesten Bibliotheken, die ich heute (1990) erw√§hnt habe.  W√§hrend dieser ganzen Zeit gab es mehrere Ordner f√ºr Python, und fast alle von ihnen sind inzwischen sicher gestorben.  Von denen, die verwendet werden k√∂nnen, gibt es: <br><br><ul><li>  Zauberstabbindung, die auf ctypes basiert, aber auch nicht mehr aktualisiert wird. </li><li>  Die pgmagick-Bindung verwendet Boost.Python, wird also sehr lange kompiliert und funktioniert in PyPy nicht.  Aber trotzdem kannst du es benutzen, ich w√ºrde sagen, dass es Wand vorzuziehen ist. </li></ul><br><h2>  Leistung <br></h2><br>  Wenn wir √ºber die Arbeit mit Bildern sprechen, interessiert uns (zumindest f√ºr mich) als erstes die Leistung, da wir sonst mit unseren H√§nden etwas in Python schreiben k√∂nnten. <br><br>  Leistung ist nicht so einfach.  Sie k√∂nnen nicht einfach sagen, dass eine Bibliothek schneller ist als eine andere.  Jede Bibliothek verf√ºgt √ºber eine Reihe von Funktionen, und jede Funktion arbeitet mit einer anderen Geschwindigkeit. <br><br>  Dementsprechend ist es richtig, nur zu sagen, dass die Leistung einer Funktion in einer bestimmten Bibliothek h√∂her oder niedriger ist.  Oder Sie haben eine Anwendung, die bestimmte Funktionen ben√∂tigt, und Sie setzen einen Benchmark speziell f√ºr diese Funktionalit√§t und sagen, dass diese und jene Bibliothek f√ºr Ihre Anwendung schneller (langsamer) funktioniert. <br><br><h3>  Es ist wichtig, das Ergebnis zu √ºberpr√ºfen. <br></h3><br>  Wenn Sie Benchmarks erstellen, ist es sehr wichtig, das erzielte Ergebnis zu betrachten.  Auch wenn Sie auf den ersten Blick denselben Code geschrieben haben, bedeutet dies nicht, dass er derselbe ist. <br><br>  K√ºrzlich bin ich in einem Artikel zum Vergleich der Leistung von Pillow und OpenCV auf diesen Code gesto√üen: <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image, ImageFilter.BoxBlur im.filter(ImageFilter.BoxBlur(<span class="hljs-number"><span class="hljs-number">3</span></span>)) ... <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> cv2 cv2.blur(im, ksize=(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>)) ...</code> </pre> <br>  Es scheint dort und dort zu sein, BoxBlur, und dort und dort, Argument 3, aber tats√§chlich ist das Ergebnis anders.  Denn in Pillow (3) ist dies der Unsch√§rferadius und in OpenCV ksize = (3, 3) die Kerngr√∂√üe, dh grob gesagt der Durchmesser.  In diesem Fall w√§re der korrekte Wert f√ºr OpenCV 3 ¬∑ 2 + 1, d. H. (7, 7). <br><br><h3>  Was ist das Problem? <br></h3><br>  Warum ist die Leistung bei der Arbeit mit Grafiken im Allgemeinen ein Problem?  Da die Komplexit√§t einer Operation von mehreren Parametern abh√§ngt und die Komplexit√§t meistens linear mit jedem von ihnen zunimmt.  Und wenn es zum Beispiel drei dieser Faktoren gibt und die Komplexit√§t linear von jedem abh√§ngt, wird die Komplexit√§t im W√ºrfel erhalten. <br><br>  <strong>Beispiel:</strong> Gau√üsche Unsch√§rfe in OpenCV. <br><br><img src="https://habrastorage.org/webt/q5/ea/ut/q5eaut_epivf3abcoh34rdmjsgg.jpeg"><br><br>  Links ist der Radius 3, rechts - 30. Wie Sie sehen k√∂nnen, betr√§gt der Geschwindigkeitsunterschied mehr als das Zehnfache. <br><br>  Als ich vor der Aufgabe stand, meiner Anwendung Gau√üsche Unsch√§rfe hinzuzuf√ºgen, war ich nicht gl√ºcklich, dass hypothetisch 900 ms f√ºr eine Operation aufgewendet werden konnten.  Die Anwendung enth√§lt Tausende solcher Vorg√§nge pro Minute, und es ist unpraktisch, so viel Zeit f√ºr einen Vorgang aufzuwenden.  Daher habe ich das Problem untersucht und die Gau√üsche Unsch√§rfe in Pillow implementiert, die in Bezug auf den Radius in konstanter Zeit arbeitet.  Das hei√üt, nur die Bildgr√∂√üe beeinflusst die Leistung der Gau√üschen Unsch√§rfe. <br><br>  Hauptsache hier ist aber nicht, dass etwas schneller oder langsamer funktioniert. <br><br><blockquote>  Ich m√∂chte vermitteln, dass es beim Aufbau eines Systems wichtig ist, zu verstehen, von welchen Parametern die Komplexit√§t der Ausgabe abh√§ngt.  Dann k√∂nnen Sie diese Parameter einschr√§nken oder auf andere Weise mit dieser Komplexit√§t umgehen. <br></blockquote><br>  Die wahrscheinlich h√§ufigste Operation, die wir mit Bildern nach dem √ñffnen ausf√ºhren, ist die Gr√∂√üen√§nderung. <br><br><img src="https://habrastorage.org/webt/ij/-6/xi/ij-6xiharsev-2a89wlcnvun6b0.jpeg"><br><br>  Die Grafik zeigt die Leistung (mehr ist besser) verschiedener Bibliotheken f√ºr den Vorgang, das Bild um das 8- und 1,25-fache zu reduzieren. <br><br>  F√ºr PIL bedeutet ein Ergebnis von 17 Mpx / s, dass das Foto von einem iPhone (12 Mpx) in weniger als einer Sekunde um das 1,25-fache reduziert werden kann.  Eine solche Leistung reicht f√ºr eine seri√∂se Anwendung, die viele dieser Vorg√§nge ausf√ºhrt, nicht aus. <br><br>  Ich begann, die Leistung der Gr√∂√üen√§nderung zu optimieren, und in Pillow 2.7 gelang es mir, die Produktivit√§t um das Doppelte und in Pillow 4.3 um das Dreifache zu steigern (die Version von Pillow 5.3 ist derzeit relevant, aber die Gr√∂√üen√§nderungsleistung ist dieselbe). <br><br>  Die Gr√∂√üen√§nderung ist jedoch eine Sache, die sehr gut auf SIMD passt.  Es n√§hert sich einer einzelnen Anweisung, mehreren Daten, und daher konnte ich in der aktuellen Version von Pillow-SIMD <strong>die Gr√∂√üen√§nderungsgeschwindigkeit im</strong> Vergleich zur urspr√ºnglichen Python Imaging Library mit denselben Ressourcen <strong>um das 19-fache erh√∂hen</strong> . <br><br>  Dies ist deutlich h√∂her als die OpenCV-Gr√∂√üen√§nderungsleistung.  Der Vergleich ist jedoch nicht ganz korrekt, da OpenCV eine etwas weniger hochwertige Methode zur Gr√∂√üen√§nderung mit einem Boxfilter verwendet und in Pillow-SIMD die Gr√∂√üen√§nderung mithilfe von Windungen implementiert wird. <br><br>  Dies ist eine unvollst√§ndige Liste der Vorg√§nge, die in Pillow-SIMD im Vergleich zu normalem Pillow beschleunigt werden. <br><br><ul><li>  Gr√∂√üe √§ndern: 4 bis 7 mal. </li><li>  Unsch√§rfe: 2,8 mal. </li><li>  3 √ó 3 oder 5 √ó 5: 11 maliges Aufbringen des Kerns. </li><li>  Multiplikation und Division durch Alpha-Kanal: 4 und 10 mal. </li><li>  Alpha-Zusammensetzung: 5 mal. </li></ul><br>  Ich habe bereits gesagt, dass man nicht sagen kann, dass eine Bibliothek schneller arbeitet als eine andere, aber Sie k√∂nnen einige Operationen zusammenstellen, die f√ºr Sie von Interesse sind.  Ich habe eine Reihe von Operationen ausgew√§hlt, die f√ºr meine Anwendung interessant sind, einen Benchmark erstellt und solche Ergebnisse erzielt. <br><br><img src="https://habrastorage.org/webt/it/_h/hq/it_hhqosz-vm69bg_o8tt8ajddm.jpeg"><br><br>  Es stellte sich heraus, dass Pillow-SIMD bei diesem Set zweimal schneller funktioniert als Pillow.  Ganz am Ende steht Wand (denken Sie daran, dass dies ImageMagick ist). <br><br>  Aber ich war an etwas anderem interessiert - warum sind OpenCV und VIPS so ergebnisarm, weil es sich um Bibliotheken handelt, die auch im Hinblick auf die Leistung entwickelt wurden?  Es stellte sich heraus, dass im Fall von OpenCV die mit pip installierte bin√§re OpenCV-Assembly mit einem langsamen JPEG-Codec zusammengestellt wurde (der Autor der Assembly wurde benachrichtigt, dieses Problem wurde bereits f√ºr 2018 gel√∂st).  Es wurde mit libjpeg erstellt, w√§hrend die meisten Systeme, zumindest auf Debian-Basis, libjpeg-turbo verwenden, das um ein Vielfaches schneller ist.  Wenn Sie OpenCV selbst aus der Quelle erstellen, ist die Leistung h√∂her. <br><br>  Bei VIPS ist die Situation anders.  Ich habe den Autor des VIPS kontaktiert, ihm diesen Benchmark gezeigt, und wir haben lange und fruchtbar korrespondiert.  Danach fand der VIPS-Autor mehrere Stellen im VIPS selbst, an denen die Ausf√ºhrung nicht auf dem optimalen Weg war, und korrigierte sie. <br><br>  Dies passiert mit der Leistung, wenn Sie OpenCV aus den Quellen der aktuellen Version und VIPS aus dem bereits vorhandenen Master erstellen. <br><br><img src="https://habrastorage.org/webt/m2/kg/o8/m2kgo8agnblbu9tsc5nw5fonyfk.jpeg"><br><blockquote>  Selbst wenn Sie eine Art Benchmark finden, ist es nicht so, dass genau auf Ihrer Maschine alles mit dieser Geschwindigkeit funktioniert. <br></blockquote><br><h3>  Reihe von Benchmarks <br></h3><br>  Alle Benchmarks, √ºber die ich gesprochen habe, finden Sie auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der Ergebnisseite</a> .  Dies ist ein separates Mini-Projekt, in dem ich Benchmarks schreibe, die ich selbst ben√∂tige, um Pillow-SIMD zu entwickeln, auszuf√ºhren und die Ergebnisse zu ver√∂ffentlichen. <br><br>  GitHub hat ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Projekt</a> mit Test-Frameworks, in dem jeder seine eigenen Benchmarks anbieten oder vorhandene korrigieren kann. <br><br><h2>  Parallele Arbeit <br></h2><br>  Bisher habe ich √ºber reine Leistung gesprochen, dh auf einem einzelnen Prozessorkern.  Aber wir haben alle schon lange Zugang zu Systemen mit mehr Kernen, und ich w√ºrde sie gerne entsorgen.  Hier muss ich sagen, dass Pillow tats√§chlich die einzige Bibliothek von allen ist, die keine Aufgabenparallelisierung verwendet.  Ich werde versuchen zu erkl√§ren, warum dies passiert.  Alle anderen Bibliotheken in der einen oder anderen Form verwenden es. <br><br><h3>  Leistungsmetriken <br></h3><br>  In Bezug auf die Leistung interessieren uns 2 Parameter: <br><br><ol><li>  <strong>Echtzeit der Ausf√ºhrung einer Operation.</strong>  Es gibt eine Operation (oder eine Folge von Operationen), und Sie fragen sich, zu welcher Echtzeit (Wanduhr) diese Folge ausgef√ºhrt wird.  Dieser Parameter ist auf dem Desktop wichtig, auf dem sich ein Benutzer befindet, der den Befehl gegeben hat und auf das Ergebnis wartet. <br></li><li>  <strong>Durchsatz des gesamten Systems</strong> (Workflow).  Wenn Sie eine Reihe von laufenden Vorg√§ngen oder viele unabh√§ngige Vorg√§nge haben und die Geschwindigkeit der Verarbeitung dieser Vorg√§nge auf Ihrer Hardware f√ºr Sie wichtig ist.  Diese Metrik ist auf einem Server mit vielen Clients wichtiger, und Sie m√ºssen sie alle bedienen.  Die Zeit, die ben√∂tigt wird, um einen Client zu bedienen, ist nat√ºrlich wichtig, aber etwas geringer als die Gesamtbandbreite. <br></li></ol><br>  Basierend auf diesen beiden Metriken betrachten wir verschiedene Arten des Parallelbetriebs. <br><br><h3>  Parallele Arbeitsmethoden <br></h3><br>  1. Wenn Sie auf Anwendungsebene auf Anwendungsebene entscheiden, dass Vorg√§nge in verschiedenen Threads verarbeitet werden.  Gleichzeitig √§ndert sich die tats√§chliche Ausf√ºhrungszeit einer Operation nicht, da wie zuvor ein Kern an einer Abfolge von Operationen beteiligt ist.  Der Durchsatz des Systems w√§chst proportional zur Anzahl der Kerne, das hei√üt sehr gut. <br><br>  2. <strong>Auf der Ebene der Grafikoperationen</strong> - genau das ist in den meisten Grafikbibliotheken der Fall.  Wenn eine Grafikbibliothek eine Operation empf√§ngt, erstellt sie die erforderliche Anzahl von Threads in sich selbst, teilt eine Operation in mehrere kleinere auf und f√ºhrt sie aus.  Gleichzeitig wird die tats√§chliche Ausf√ºhrungszeit reduziert - eine Operation ist schneller.  Der <strong>Durchsatz w√§chst jedoch nicht linear</strong> mit der Anzahl der Kerne.  Es gibt Operationen, die nicht parallel sind, und ein bemerkenswertes Beispiel ist die Dekodierung von PNG-Dateien - sie k√∂nnen in keiner Weise parallelisiert werden.  Dar√ºber hinaus entsteht ein Aufwand f√ºr das Erstellen von Threads und das Aufteilen von Aufgaben, bei denen die Bandbreite nicht linear wachsen kann. <br><br>  3. <strong>Auf der Ebene der Prozessorbefehle und -daten</strong> .  Wir bereiten Daten auf spezielle Weise auf und verwenden spezielle Befehle, damit der Prozessor schneller mit ihnen arbeitet.  Dies ist der SIMD-Ansatz, der tats√§chlich in Pillow-SIMD verwendet wird.  Die Laufzeit in Echtzeit nimmt ab, der Durchsatz steigt - <strong>dies</strong> ist <strong>eine Win-Win-Option</strong> . <br><br><h3>  Wie man Parallelarbeit kombiniert <br></h3><br>  Wenn wir irgendwie parallele Arbeit kombinieren m√∂chten, funktioniert SIMD gut mit der Parallelisierung innerhalb einer Operation, und SIMD funktioniert gut mit der Parallelisierung innerhalb einer Anwendung. <br><img src="https://habrastorage.org/webt/3z/pa/lo/3zpaloqfeh6cczwlz8zlk5s33lc.jpeg"><br>  Die Parallelisierung innerhalb der Anwendung und innerhalb des Vorgangs ist jedoch nicht miteinander kompatibel.  Wenn Sie dies versuchen, erhalten Sie Nachteile aus beiden Ans√§tzen.  Die Echtzeit des Vorgangs ist dieselbe wie auf einem Kern, und der Durchsatz des Systems steigt, jedoch nicht linear in Bezug auf die Anzahl der Kerne. <br><br><h3>  Multithreading <br></h3><br>  Wenn wir √ºber Threads sprechen, schreiben wir alle in Python und wissen, dass es eine GIL hat, die verhindert, dass zwei Threads gleichzeitig ausgef√ºhrt werden.  Python ist eine reine Single-Threaded-Sprache. <br><br>  Dies ist nat√ºrlich nicht der Fall, da die GIL tats√§chlich verhindert, dass zwei Threads in Python ausgef√ºhrt werden. Wenn der Code in einer anderen Sprache geschrieben ist und w√§hrend des Betriebs keine internen Python-Strukturen verwendet, kann dieser Code die GIL freigeben und somit den Interpreter freigeben f√ºr andere Aufgaben. <br><br>  Viele Grafikbibliotheken ver√∂ffentlichen GIL w√§hrend ihrer Arbeit, darunter Pillow, OpenCV, Pyvips und Wand.  Nur ein pgmagick ist nicht frei.  Das hei√üt, Sie k√∂nnen sicher Threads erstellen, um einige Vorg√§nge auszuf√ºhren. Dies funktioniert parallel zum Rest des Codes. <br><br>  Es stellt sich jedoch die Frage: <strong>Wie viele Threads m√ºssen erstellt werden?</strong> <br><br>  Wenn wir f√ºr jede Aufgabe, die wir haben, eine unendliche Anzahl von Threads erstellen, beanspruchen sie einfach den gesamten Speicher und den gesamten Prozessor - wir werden keine effektive Arbeit erhalten.  Ich habe eine Sonderregel formuliert. <br><br><blockquote>  <strong>Regel N + 1</strong> <br><br>  F√ºr produktive Arbeit m√ºssen Sie nicht mehr als N + 1 Worker erstellen, wobei N die Anzahl der Kerne oder Prozessorthreads auf dem Computer und der Worker der Prozess oder Thread ist, der an der Verarbeitung beteiligt ist. <br></blockquote><br>  Prozesse werden am besten verwendet, da selbst innerhalb desselben Interpreters Engp√§sse und Overhead auftreten. <br><br>  In unserer Anwendung wird beispielsweise der N + 1-Instanz-Tornado verwendet, dessen Balance von ngnix ausgef√ºhrt wird.  Wenn Tornado erw√§hnt wird, sprechen wir √ºber den asynchronen Betrieb. <br><br><h2>  Asynchroner Betrieb <br></h2><br>  Die Zeit, in der die Grafikbibliothek tats√§chlich n√ºtzliche Arbeit leistet - Bildverarbeitung - kann und sollte f√ºr die Eingabe / Ausgabe verwendet werden, wenn Sie sie in der Anwendung haben.  Asynchrone Frameworks sind hier sehr relevant. <br><br>  Aber es gibt ein Problem - wenn wir eine Art Verarbeitung aufrufen, wird sie synchron aufgerufen.  Selbst wenn die Bibliothek in diesem Moment die GIL freigibt, ist die Ereignisschleife immer noch blockiert. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@gen.coroutine def get(self, *args, **kwargs): im = process_image(...) ...</span></span></code> </pre><br>  Gl√ºcklicherweise ist dieses Problem sehr einfach zu l√∂sen, indem ein ThreadPoolExecutor mit einem einzelnen Thread erstellt wird, auf dem die Bildverarbeitung beginnt.  Dieser Aufruf erfolgt bereits asynchron. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@run_on_executor(executor=ThreadPoolExecutor(1)) def process_image(self, ... @gen.coroutine def get(self, *args, **kwargs): im = yield process_image(...) ...</span></span></code> </pre><br>  Im Wesentlichen wird hier eine Warteschlange mit einem Worker erstellt, die grafische Operationen ausf√ºhrt, und die Ereignisschleife wird nicht blockiert und in einem anderen Thread leise parallel ausgef√ºhrt. <br><br><h2>  Eingabe / Ausgabe <br></h2><br>  Ein weiteres Thema, das ich in der Diskussion der grafischen Operationen ansprechen m√∂chte, ist die Eingabe / Ausgabe.  Tatsache ist, dass wir selten Bilder mit einer Grafikbibliothek erstellen.  Meistens √∂ffnen wir Bilder, die von Benutzern zu uns gekommen sind, in Form von codierten Dateien (JPEG, PNG, BMP, TIFF usw.). <br><br>  Dementsprechend sollte die Grafikbibliothek zum Erstellen einer guten Anwendung einige Extras f√ºr die Eingabe / Ausgabe von Dateien enthalten. <br><br><h3>  Faules Laden <br></h3><br>  Das erste derartige Br√∂tchen ist das faule Laden.  Wenn Sie beispielsweise in Pillow ein Bild √∂ffnen, erfolgt in diesem Moment keine Dekodierung des Bildes.  Sie erhalten ein Objekt zur√ºck, das so aussieht, als ob das Bild bereits geladen ist und funktioniert.  Sie k√∂nnen sich die Eigenschaften ansehen und anhand der Eigenschaften dieses Bildes entscheiden, ob Sie bereit sind, weiter damit zu arbeiten, wenn der Benutzer beispielsweise ein Gigapixel-Bild heruntergeladen hat, um Ihren Dienst zu unterbrechen. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image &gt;&gt;&gt; %time im = Image.open() Wall time: <span class="hljs-number"><span class="hljs-number">1.2</span></span> ms &gt;&gt;&gt; im.mode, im.size (<span class="hljs-string"><span class="hljs-string">'RGB'</span></span>, (<span class="hljs-number"><span class="hljs-number">2152</span></span>, <span class="hljs-number"><span class="hljs-number">1345</span></span>))</code> </pre><br>  Wenn Sie entscheiden, was als N√§chstes zu tun ist, wird dieses Bild mithilfe des expliziten oder impliziten Aufrufs zum Laden dekodiert.  Bereits zu diesem Zeitpunkt wird die erforderliche Speichermenge zugewiesen. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image &gt;&gt;&gt; %time im = Image.open() Wall time: <span class="hljs-number"><span class="hljs-number">1.2</span></span> ms &gt;&gt;&gt; im.mode, im.size (<span class="hljs-string"><span class="hljs-string">'RGB'</span></span>, (<span class="hljs-number"><span class="hljs-number">2152</span></span>, <span class="hljs-number"><span class="hljs-number">1345</span></span>)) &gt;&gt;&gt; %time im.load() Wall time: <span class="hljs-number"><span class="hljs-number">73.6</span></span> ms</code> </pre><br><h3>  Defekter Bildmodus <br></h3><br>  Das zweite Element, das f√ºr die Arbeit mit benutzergenerierten Inhalten ben√∂tigt wird, ist der Modus f√ºr fehlerhafte Bilder.  Die Dateien, die wir von Benutzern erhalten, enthalten sehr h√§ufig Inkonsistenzen mit dem Format, in dem sie codiert sind. <br><br>  Diese Abweichungen treten aus verschiedenen Gr√ºnden auf.  Manchmal handelt es sich um einen √úbertragungsfehler √ºber das Netzwerk, manchmal handelt es sich nur um eine Art krummen Codecs, der das Bild codiert.  Standardm√§√üig l√∂st Pillow nur eine Ausnahme aus, wenn Bilder angezeigt werden, die nicht zum Format passen. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image Image.open(<span class="hljs-string"><span class="hljs-string">'trucated.jpg'</span></span>).save(<span class="hljs-string"><span class="hljs-string">'trucated.out.jpg'</span></span>) IOError: image file <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> truncated (<span class="hljs-number"><span class="hljs-number">143</span></span> bytes <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> processed)</code> </pre><br>  Aber der Benutzer ist nicht daf√ºr verantwortlich, dass sein Bild kaputt ist, er m√∂chte immer noch das Ergebnis erhalten.  Gl√ºcklicherweise hat Pillow einen defekten Bildmodus.  Wir √§ndern eine Einstellung und Pillow versucht, alle im Bild enthaltenen Dekodierungsfehler maximal zu ignorieren.  Dementsprechend sieht der Benutzer zumindest etwas. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image, ImageFile ImageFile.LOAD_TRUNCATED_IMAGES = <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> Image.open(<span class="hljs-string"><span class="hljs-string">'trucated.jpg'</span></span>).save(<span class="hljs-string"><span class="hljs-string">'trucated.out.jpg'</span></span>)</code> </pre><br><img src="https://habrastorage.org/webt/cm/jq/ju/cmjqjuopb_ct8wqinkaaeaw0bbc.jpeg"><br><br>  Selbst ein zugeschnittenes Bild ist immer noch besser als nichts - nur eine Seite mit einem Fehler. <br><br><h3>  √úbersichtstabelle <br></h3><br><img src="https://habrastorage.org/webt/zn/p3/yp/znp3ypfris3rbtkmok83gcyvup8.jpeg"><br><br>  In der obigen Tabelle habe ich alles, was mit Eingabe / Ausgabe zu tun hat, in den Bibliotheken gesammelt, √ºber die ich spreche.  Insbesondere habe ich die Anzahl der Codecs in verschiedenen Formaten gez√§hlt, die sich in den Bibliotheken befinden.  Es stellte sich heraus, dass sie in OpenCV am wenigsten sind, in ImageMagick am meisten.  Es scheint, dass Sie in ImageMagick jedes Bild √∂ffnen k√∂nnen, auf das Sie sto√üen.  VIPS verf√ºgt √ºber 12 native Codecs, VIPS kann jedoch ImageMagick als Zwischenstufe verwenden.  Ich habe nicht getestet, wie das funktioniert, hoffe es ist nahtlos. <br><br>  Kissen hat 17 Codecs.  Dies ist jetzt die einzige Bibliothek, in der EXIF ‚Äã‚Äãnicht automatisch gedreht wird.  Dies ist jedoch ein kleines Problem, da Sie EXIF ‚Äã‚Äãselbst lesen und das Bild entsprechend drehen k√∂nnen.  Dies ist eine Frage eines kleinen Ausschnitts, der leicht zu googeln ist und maximal 20 Zeilen ben√∂tigt. <br><br><h3>  Funktionen von OpenCV <br></h3><br>  Wenn Sie sich diese Tabelle genau ansehen, k√∂nnen Sie feststellen, dass in OpenCV tats√§chlich nicht alles so gut mit Eingabe / Ausgabe ist.  Es hat die geringste Anzahl von Codecs, kein verz√∂gertes Laden, und Sie k√∂nnen EXIF ‚Äã‚Äãund das Farbprofil nicht lesen. <br><br>  Das ist aber noch nicht alles.  In der Tat hat OpenCV mehr Funktionen.  Wenn wir einfach ein Bild √∂ffnen, dreht der Aufruf von <code>cv2.imread(filename)</code> die JPEG-Dateien gem√§√ü EXIF ‚Äã‚Äã(siehe Tabelle), ignoriert jedoch den Alphakanal von PNG-Dateien - ein ziemlich seltsames Verhalten! <br><br>  Gl√ºcklicherweise hat OpenCV ein Flag: <code>cv2.imread(filename, flags=cv2.IMREAD_UNCHANGED)</code> . <br><br>  Wenn Sie das IMREAD_UNCHANGED-Flag angeben, verl√§sst OpenCV den Alphakanal f√ºr PNG-Dateien, h√∂rt jedoch auf, JPEG-Dateien gem√§√ü EXIF ‚Äã‚Äãzu drehen.  Das hei√üt, dasselbe Flag wirkt sich auf zwei v√∂llig unterschiedliche Eigenschaften aus.  Wie aus der Tabelle hervorgeht, kann OpenCV EXIF ‚Äã‚Äãnicht lesen, und es stellt sich heraus, dass bei diesem Flag JPEG √ºberhaupt nicht gedreht werden kann. <br><br>  Was ist, wenn Sie nicht im Voraus wissen, welches Format Ihr Bild hat und Sie sowohl den Alphakanal f√ºr PNG als auch die automatische Drehung f√ºr JPEG ben√∂tigen?  Nichts zu tun - OpenCV funktioniert so nicht. <br><br>  Der Grund, warum OpenCV solche Probleme hat, liegt im Namen dieser Bibliothek.  Es verf√ºgt √ºber zahlreiche Funktionen f√ºr Computer Vision und Bildanalyse.  Tats√§chlich ist OpenCV f√ºr die Arbeit mit verifizierten Quellen ausgelegt.  Dies ist beispielsweise eine √úberwachungskamera f√ºr den Au√üenbereich, die einmal pro Sekunde Bilder aufnimmt und dies 5 Jahre lang im gleichen Format und mit derselben Aufl√∂sung tut.  Das E / A-Problem muss nicht variiert werden. <br><br>  Personen, die OpenCV-Funktionen ben√∂tigen, ben√∂tigen Benutzerinhaltsfunktionen nicht wirklich. <br><br>  Was aber, wenn Ihre Anwendung weiterhin Funktionen f√ºr die Arbeit mit Benutzerinhalten ben√∂tigt und Sie gleichzeitig die gesamte Leistung von OpenCV f√ºr die Verarbeitung und Statistik ben√∂tigen? <br><br><img src="https://habrastorage.org/webt/2g/2o/mu/2g2omu98a18hv0gzr4387egsj6s.jpeg"><br><br>  Die L√∂sung besteht darin, Bibliotheken zu kombinieren.  Tatsache ist, dass OpenCV auf der Basis von Numpy erstellt wurde und Pillow √ºber alle Mittel verf√ºgt, um Bilder von Pillow in ein Numpy-Array zu exportieren.  Das hei√üt, wir exportieren das numpy-Array, und OpenCV kann mit diesem Image wie mit seinem eigenen weiterarbeiten.  Dies ist sehr einfach zu bewerkstelligen: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image ... pillow_image = Image.open(filename) cv_image = numpy.array(pillow_image)</code> </pre><br>  Wenn wir mit OpenCV (Verarbeitung) zaubern, rufen wir eine andere Pillow-Methode auf und importieren das Bild von OpenCV zur√ºck in das Pillow-Format.  Dementsprechend kann wieder E / A verwendet werden. <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> numpy <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> PIL <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Image ... pillow_image = Image.fromarray(cv_image, <span class="hljs-string"><span class="hljs-string">"RGB"</span></span>) pillow_image.save(filename)</code> </pre><br>  Es stellt sich also heraus, dass wir die Eingabe / Ausgabe von Pillow und die Verarbeitung von OpenCV verwenden, dh wir nehmen das Beste aus den beiden Welten. <br><br>  Ich hoffe, dies hilft Ihnen beim Erstellen einer geladenen Grafikanwendung. <br><br><blockquote>  Sie k√∂nnen einige andere Entwicklungsgeheimnisse in Python lernen, aus unsch√§tzbaren und manchmal unerwarteten Erfahrungen lernen und vor allem Ihre Aufgaben sehr bald in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Moscow Python Conf ++</a> besprechen.  Achten Sie beispielsweise auf solche Namen und Themen im Zeitplan. <br><br><ul><li>  Donald Whyte mit einer Geschichte dar√ºber, wie man Mathematik mit g√§ngigen Bibliotheken, Tricks und List zehnmal schneller macht, und der Code ist verst√§ndlich und wird unterst√ºtzt. </li><li>  Bei Andrei Popov geht es darum, eine gro√üe Datenmenge zu sammeln und auf Bedrohungen zu analysieren. </li><li>  Ephraim Matosyan erkl√§rt Ihnen in seinem Bericht ‚ÄûMachen Sie Python wieder schnell‚Äú, wie Sie die Leistung des D√§mons steigern k√∂nnen, der Nachrichten vom Bus verarbeitet. </li></ul><br>  Eine vollst√§ndige Liste der Themen, die am 22. und 23. Oktober <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier</a> besprochen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> , ist Zeit, sich anzumelden. <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de425471/">https://habr.com/ru/post/de425471/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de425461/index.html">Devops and Security: Interviews mit Seth Wargo und Liz Rice</a></li>
<li><a href="../de425463/index.html">Unity Hexagon Maps: Wasser, Sehensw√ºrdigkeiten und Festungsmauern</a></li>
<li><a href="../de425465/index.html">Wie ein Designer mehr verdienen kann, ein ideales Werkzeug zum Arbeiten und Suchen nach Ideen</a></li>
<li><a href="../de425467/index.html">Motoren Renault D4F> B4D (auch bekannt als SCe). Generationswechsel. Autofahrer schauen</a></li>
<li><a href="../de425469/index.html">Der Python-Autor leitet die Entwicklung nicht mehr. Wird es die Sprache besser oder schlechter machen?</a></li>
<li><a href="../de425473/index.html">Konferenz √ºber Python und √ºber Kommunikation</a></li>
<li><a href="../de425475/index.html">Kollaborative Roboter von Universal Robots auf der IMTS 2018 in Chicago</a></li>
<li><a href="../de425477/index.html">Skillbox Friday-Webinare: Von der Auswahl einer Programmiersprache bis zur Suche nach Ihrem Unternehmen</a></li>
<li><a href="../de425479/index.html">Bald wird die H√§lfte der Anrufe von Robotern kommen. Tipp: Antworte nicht (?)</a></li>
<li><a href="../de425483/index.html">Wochenendlesung: 22 Artikel √ºber die Geschichte legend√§rer Audio-Unternehmen und wie sie ‚ÄûSound machen‚Äú</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>