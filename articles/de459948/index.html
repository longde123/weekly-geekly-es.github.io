<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåã ü•õ üßùüèø Implementierung physikalisch korrekter volumetrischer Wolken wie in Horizon Zero Dawn üö© üßïüèº ü§ï</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Fr√ºher wurden Wolken in Spielen mit gew√∂hnlichen 2D-Sprites gezeichnet, die immer in Richtung der Kamera gedreht werden. In den letzten Jahren k√∂nnen ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Implementierung physikalisch korrekter volumetrischer Wolken wie in Horizon Zero Dawn</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/459948/">  Fr√ºher wurden Wolken in Spielen mit gew√∂hnlichen 2D-Sprites gezeichnet, die immer in Richtung der Kamera gedreht werden. In den letzten Jahren k√∂nnen Sie mit neuen Grafikkartenmodellen physikalisch korrekte Wolken zeichnen, ohne dass Leistungseinbu√üen auftreten.  Es wird angenommen, dass volumin√∂se Wolken im Spiel das Studio Guerrilla Games zusammen mit dem Spiel Horizon Zero Dawn brachten.  Nat√ºrlich konnten solche Wolken fr√ºher gerendert werden, aber das Studio bildete so etwas wie einen Industriestandard f√ºr die Quellressourcen und die verwendeten Algorithmen, und jetzt entspricht jede Implementierung von volumetrischen Wolken irgendwie diesem Standard. <br><br><img src="https://habrastorage.org/webt/v9/uq/em/v9uqemwtz5ty7x5uvpppsoonmdu.png"><br><a name="habracut"></a><br>  Der gesamte Prozess des Renderns von Clouds ist sehr gut in Phasen unterteilt, und es ist wichtig zu beachten, dass eine ungenaue Implementierung selbst bei einer von ihnen zu solchen Konsequenzen f√ºhren kann, dass nicht klar ist, wo der Fehler liegt und wie er behoben werden kann. Daher ist es ratsam, jedes Mal eine Kontrollschlussfolgerung √ºber das Ergebnis zu ziehen. <br><br><h2>  Tonzuordnung, sRGB </h2><br>  Bevor Sie mit der Beleuchtung beginnen, m√ºssen Sie zwei Dinge tun: <br><br><ol><li>  Wenden Sie mindestens die einfachste Tonzuordnung an, bevor Sie das endg√ºltige Bild auf dem Bildschirm anzeigen: <br><br><pre><code class="cpp hljs">tunedColor=color/(<span class="hljs-number"><span class="hljs-number">1</span></span>+color)</code> </pre> <br>  Dies ist notwendig, da die berechneten Farbwerte viel gr√∂√üer als Eins sind. <br></li><li>  Stellen Sie sicher, dass der endg√ºltige Framebuffer, in den Sie zeichnen und der auf dem Bildschirm angezeigt wird, im sRGB-Format vorliegt.  Wenn die Aktivierung des sRGB-Modus ein Problem darstellt, kann die Konvertierung manuell im Shader durchgef√ºhrt werden: <br><br><pre> <code class="cpp hljs">finalColor=<span class="hljs-built_in"><span class="hljs-built_in">pow</span></span>(color, vec3(<span class="hljs-number"><span class="hljs-number">1.0</span></span>/<span class="hljs-number"><span class="hljs-number">2.2</span></span>))</code> </pre> <br>  Die Formel ist f√ºr die meisten F√§lle geeignet, jedoch je nach Monitor nicht zu 100%.  Es ist wichtig, dass die sRGB-Konvertierung immer zuletzt erfolgt. </li></ol><br><h2>  Beleuchtungsmodell </h2><br>  Stellen Sie sich einen Raum vor, der mit teilweise transparenter Materie unterschiedlicher Dichte gef√ºllt ist.  Wenn ein Lichtstrahl durch eine solche Substanz tritt, ist er vier Effekten ausgesetzt: Absorption, Streuung, Verst√§rkung der Streuung und Selbststrahlung.  Letzteres tritt bei chemischen Prozessen in einem Stoff auf und ist hier nicht betroffen. <br><br>  Angenommen, wir haben einen Lichtstrahl, der durch Materie von Punkt A nach Punkt B geht: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/_1/1t/9w/_11t9wizftnmwilerlsi5fvcrm4.png"></div><br>  <b>Absorption</b> <br><br>  Licht, das durch eine Substanz f√§llt, wird von dieser Substanz absorbiert.  Der nicht absorbierte Lichtanteil kann durch die Formel ermittelt werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/567/34c/ec6/56734cec6154e1fab8bb2d1538a8dffa.svg"></div><br>  wo <img src="https://habrastorage.org/getpro/habr/post_images/a3e/204/11f/a3e20411f145906908c5cd2b53a36dbe.svg">  - das am Punkt nach der Absorption verbleibende Licht <img src="https://habrastorage.org/getpro/habr/post_images/5cc/c8d/80d/5ccc8d80d010abd90b5c546d05856d3a.svg">  . <img src="https://habrastorage.org/getpro/habr/post_images/5cc/c8d/80d/5ccc8d80d010abd90b5c546d05856d3a.svg">  - in einiger Entfernung auf das Segment AB zeigen <img src="https://habrastorage.org/getpro/habr/post_images/2a3/102/4ea/2a31024ea1803c34a47496e24a53a1ef.svg">  von A. <br><br>  <b>Streuung</b> <br><br>  Ein Teil des Lichts unter dem Einfluss von Materieteilchen √§ndert seine Richtung.  Der Anteil des Lichts, der seine Richtung nicht ge√§ndert hat, kann durch die Formel ermittelt werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/04b/c17/2f5/04bc172f53fa572aebf0399275b5009f.svg"></div><br>  wo <img src="https://habrastorage.org/getpro/habr/post_images/5e3/0b7/bad/5e30b7badd64b9da62be750e48573c7d.svg">  - Lichtanteil, dessen Richtung sich nach der Streuung an einem Punkt nicht ge√§ndert hat <img src="https://habrastorage.org/getpro/habr/post_images/5cc/c8d/80d/5ccc8d80d010abd90b5c546d05856d3a.svg">  . <br><br>  Absorption und Dispersion m√ºssen kombiniert werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8d7/d5a/f1a/8d7d5af1a0506ee776c4c2f850e862a9.svg"></div><br>  Funktion <img src="https://habrastorage.org/getpro/habr/post_images/33f/297/4e9/33f2974e9c84331f8b92d8b7ed5aca97.svg">  D√§mpfung oder Ausl√∂schung genannt.  Eine Funktion <img src="https://habrastorage.org/getpro/habr/post_images/eea/d4d/0d4/eead4d0d4f08873f9aa49b69a7c46fd8.svg">  - √úbertragungsfunktion.  Es zeigt, wie viel Licht beim √úbergang von Punkt A nach Punkt B √ºbrig bleibt. <br><br>  Hinsichtlich <img src="https://habrastorage.org/getpro/habr/post_images/610/ddb/ee8/610ddbee8d80f847b44fa75c9a136489.svg">  und <img src="https://habrastorage.org/getpro/habr/post_images/cd1/8c2/405/cd18c240521dcfb71084a340a504e41f.svg">  :: <img src="https://habrastorage.org/getpro/habr/post_images/b76/ea9/fd5/b76ea9fd577eb1c2cee545caa4153bd3.svg">  wobei C eine bestimmte Konstante ist, die f√ºr jeden Kanal in RGB einen anderen Wert haben kann, <img src="https://habrastorage.org/getpro/habr/post_images/9ee/494/9d2/9ee4949d2897f56ac90e563db1eb96cd.svg">  Ist die Dichte des Mediums am Punkt <img src="https://habrastorage.org/getpro/habr/post_images/5cc/c8d/80d/5ccc8d80d010abd90b5c546d05856d3a.svg">  . <br><br>  Lassen Sie uns nun die Aufgabe komplizieren.  Licht bewegt sich von Punkt A nach Punkt B, es stirbt w√§hrend der Bewegung aus.  Am Punkt X wird ein Teil des Lichts in verschiedene Richtungen gestreut, eine der Richtungen entspricht dem Beobachter am Punkt O. Als n√§chstes bewegt sich ein Teil des gestreuten Lichts von Punkt X zu Punkt O und d√§mpft wieder.  Der Weg des AXO-Lichts interessiert uns. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zo/b_/tr/zob_troftvd8-ggp1ga7wesnrlk.png"></div><br>  Den Lichtverlust beim √úbergang von A nach X kennen wir: <img src="https://habrastorage.org/getpro/habr/post_images/25d/8c9/f76/25d8c9f76986f59eb045b801f19d4e0a.svg">  , so wie wir den Lichtverlust von X nach O kennen - das <img src="https://habrastorage.org/getpro/habr/post_images/25b/3a9/8e3/25b3a98e370f0a95b734794b74bee57a.svg">  .  Aber was ist mit dem Lichtanteil, der in Richtung des Betrachters gestreut wird? <br><br>  <b>Amplifikationsdispersion</b> <br><br>  Wenn bei gew√∂hnlicher Streuung die Lichtintensit√§t abnimmt, nimmt sie bei verst√§rkter Streuung aufgrund der in benachbarten Bereichen aufgetretenen Lichtstreuung zu.  Die Gesamtlichtmenge, die aus benachbarten Regionen kommt, kann durch die Formel ermittelt werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e4/be1/bd9/7e4be1bd9a1d8f05b9d1d47e1bb27ecc.svg"></div><br>  wo <img src="https://habrastorage.org/getpro/habr/post_images/e63/878/1e4/e638781e456c920d7864e85c8b14a746.svg">  bedeutet, das Integral √ºber die Kugel zu nehmen, <img src="https://habrastorage.org/getpro/habr/post_images/1ad/0bb/23e/1ad0bb23eb22871d78d2b5cc67d58292.svg">  - Phasenfunktion <img src="https://habrastorage.org/getpro/habr/post_images/da9/7bc/3c5/da97bc3c51ddad728182deecd39ba0d0.svg">  - Licht aus der Richtung <img src="https://habrastorage.org/getpro/habr/post_images/9c6/a44/e8e/9c6a44e8ed4cb10046e00346c6b58b15.svg">  . <br><br>  Es ist ziemlich schwierig, Licht aus allen Richtungen zu berechnen. Wir wissen jedoch, dass der urspr√ºngliche Lichtanteil von unserem urspr√ºnglichen AB-Strahl getragen wird.  Die Formel kann stark vereinfacht werden: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ef8/4aa/222/ef84aa22259c648ea9925502712250f6.svg"></div><br>  wo <img src="https://habrastorage.org/getpro/habr/post_images/2cb/bcb/347/2cbbcb347a44c276c1095ac5bb3f8242.svg">  - der Winkel zwischen dem Lichtstrahl und dem Beobachterstrahl (d. H. Der Winkel AXO), <img src="https://habrastorage.org/getpro/habr/post_images/309/1ee/38b/3091ee38b2de66a8aa89af86fe87eb65.svg">  - der Anfangswert der Lichtintensit√§t.  Wenn wir alle oben genannten Punkte zusammenfassen, erhalten wir die Formel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/642/fb7/273/642fb727356c245fc6f053dbc9affde8.svg"></div><br>  wo <img src="https://habrastorage.org/getpro/habr/post_images/309/1ee/38b/3091ee38b2de66a8aa89af86fe87eb65.svg">  - einfallendes Licht <img src="https://habrastorage.org/getpro/habr/post_images/f7a/fbd/138/f7afbd138efabfc5bf5dad3e26e6c0fb.svg">  - das Licht erreicht den Betrachter. <br><br>  Wir erschweren die Aufgabe etwas mehr.  Nehmen wir an, das Licht wird von einem gerichteten Licht emittiert, d.h.  die Sonne: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/wz/r2/gg/wzr2ggl_1oshhmhn3kkqalhtkoo.png"></div><br>  Alles passiert genauso wie im vorherigen Fall, aber oft.  Licht von Punkt A1 wird am Punkt X1 in Richtung des Beobachters am Punkt O gestreut, Licht von Punkt A2 wird am Punkt X2 in Richtung des Beobachters am Punkt O usw. gestreut.  Wir sehen, dass das Licht, das den Betrachter erreicht, gleich der Summe ist: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/838/191/24f/83819124f0beb6bdd5adc3644a79653b.svg"></div><br>  Oder ein genauerer integraler Ausdruck: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e01/7b0/5d2/e017b05d2026f311f43bc53da48c130e.svg"></div><br>  Es ist wichtig, das hier zu verstehen <img src="https://habrastorage.org/getpro/habr/post_images/e7b/3af/88e/e7b3af88eb6397d1f88774b011fe4cbb.svg">  d.h.  Das Segment ist in unendlich viele Abschnitte mit einer L√§nge von Null unterteilt. <br><br><h2>  Himmel </h2><br>  Mit einer leichten Vereinfachung wird ein Sonnenstrahl, der durch die Atmosph√§re geht, nur gestreut, d.h. <img src="https://habrastorage.org/getpro/habr/post_images/c79/ce0/055/c79ce005518e112e707da427d7231066.svg">  . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/k0/mm/tz/k0mmtzjcir3wnqxbcjzsouln4yo.png"></div><br>  Und nicht einmal eine Art von Streuung, sondern zwei: Rayleigh-Streuung und Mi-Streuung.  Das erste wird durch Luftmolek√ºle verursacht, und das zweite wird durch ein Aerosol aus Wasser verursacht. <br><br>  Die Gesamtdichte der Luft (oder des Aerosols), durch die ein Lichtstrahl von Punkt A nach Punkt B str√∂mt: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0bc/d80/e5d/0bcd80e5d5b35e43fef8336e6c66cde0.svg"></div>  wo <img src="https://habrastorage.org/getpro/habr/post_images/14b/01a/bf0/14b01abf043545d56ac10d61e69792e8.svg">  - Skalierungsh√∂he, h - aktuelle H√∂he. <br><br>  Eine einfache integrale L√∂sung w√§re: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d3f/b07/e75/d3fb07e750a91c2a253fdcf1de74de72.svg"></div><br>  Dabei ist dh die Schrittgr√∂√üe, mit der die H√∂henprobe entnommen wird. <br><br>  Schauen Sie sich nun die Abbildung an und verwenden Sie die im vorherigen Teil des ‚ÄûBeleuchtungsmodells‚Äú abgeleitete Formel: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gr/n0/fr/grn0fr0f-dly-jjpcjpg_pxof9a.png"></div><br>  Der Beobachter schaut von O nach O '.  Wir wollen alles Licht sammeln, das die Punkte X1, X2, ..., Xn erreicht, in ihnen gestreut wird und dann den Betrachter erreicht: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/540/c25/470/540c25470466173df2e5cf7880390ff9.svg"></div><br>  wo <img src="https://habrastorage.org/getpro/habr/post_images/c87/cb3/ca4/c87cb3ca4e0a0f0fc9d1a9d5c485c116.svg">  die Intensit√§t des von der Sonne emittierten Lichts, <img src="https://habrastorage.org/getpro/habr/post_images/6c3/b25/b5f/6c3b25b5f22b9a03c093ef2f25a06339.svg">  - H√∂he am Punkt <img src="https://habrastorage.org/getpro/habr/post_images/ee6/2f8/bed/ee62f8bed8d0d0e9b3d3cd2c81841ded.svg">  ;;  im Falle des Himmels die Konstante C, die in Funktion ist <img src="https://habrastorage.org/getpro/habr/post_images/cd1/8c2/405/cd18c240521dcfb71084a340a504e41f.svg">  bezeichnet als <img src="https://habrastorage.org/getpro/habr/post_images/cea/f36/742/ceaf36742def9a68dbd173a0ac9c9aeb.svg">  . <br><br>  Die L√∂sung des Integrals kann wie folgt sein: <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5be/44a/9fc/5be44a9fcdb92469fee29b924a957556.svg"></div><br>  Diese Formel gilt sowohl f√ºr Rayleigh-Streuung als auch f√ºr Mie-Streuung.  Infolgedessen addieren sich die Lichtwerte f√ºr jede der Streuungen einfach: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/34f/cb4/a91/34fcb4a9100e4b9c60a7c7eca2c489ec.svg"></div><br>  <b>Rayleigh-Dispersion</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/71e/a55/e80/71ea55e8043a70776eb70f29eb84d877.svg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/679/03f/8e9/67903f8e987346a525fb22e02e718aad.svg">  (enth√§lt Werte f√ºr jeden RGB-Kanal) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/4c9/02f/384/4c902f3848ae3cb24347ee0b367132d6.svg"><br><br>  Ergebnis: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/nk/xs/8z/nkxs8zt8hyh909tjilktrkrrvri.png"></div><br>  <b>Mi streuen</b> <br><br><img src="https://habrastorage.org/getpro/habr/post_images/72b/94b/cc1/72b94bcc19f99b0e164c6a48e4408b44.svg"><br><br><img src="https://habrastorage.org/getpro/habr/post_images/c9a/52e/00c/c9a52e00c5e6169a8ad778f902e49595.svg">  (Werte f√ºr alle RGB-Kan√§le sind gleich) <br><br><img src="https://habrastorage.org/getpro/habr/post_images/208/fcf/3bf/208fcf3bf216540af2bfa93a186a3a19.svg"><br><br>  Ergebnis: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fu/jv/sb/fujvsbtduq-il-1reylizx1kosa.png"></div><br>  Die Anzahl der Stichproben pro Segment <img src="https://habrastorage.org/getpro/habr/post_images/2a1/abf/7c3/2a1abf7c35ec6c9a9d35514977d15981.svg">  und auf dem Segment <img src="https://habrastorage.org/getpro/habr/post_images/392/559/f75/392559f75e1c271b8bbfbc6255e70d4d.svg">  Sie k√∂nnen 32 und h√∂her nehmen.  Der Erdradius betr√§gt 6371000 m, die Atmosph√§re 100000 m. <br><br>  Was tun mit all dem? <br><br><ol><li>  In jedem Pixel des Bildschirms berechnen wir die Richtung des Beobachters V. </li><li>  Wir nehmen die Position des Beobachters O gleich {0, 6371000, 0} ein. </li><li>  Wir finden <img src="https://habrastorage.org/getpro/habr/post_images/28d/cc9/fe7/28dcc9fe786e9216afc4ab3ae2196ebe.svg">  als Ergebnis des Schnittpunkts des Strahls, der vom Punkt O ausgeht, und der Richtung von V und der Kugel, die am Punkt {0,0,0} und einem Radius von 6471000 zentriert ist </li><li>  Liniensegment <img src="https://habrastorage.org/getpro/habr/post_images/392/559/f75/392559f75e1c271b8bbfbc6255e70d4d.svg">  in 32 gleich lange Abschnitte teilen </li><li>  F√ºr jeden Abschnitt berechnen wir die Rayleigh-Streuung und die Mie-Streuung und f√ºgen alles hinzu.  Dar√ºber hinaus zu berechnen <img src="https://habrastorage.org/getpro/habr/post_images/2a1/abf/7c3/2a1abf7c35ec6c9a9d35514977d15981.svg">  Wir m√ºssen auch das Segment aufteilen <img src="https://habrastorage.org/getpro/habr/post_images/0e6/fb0/4e8/0e6fb04e8525f5a3448df984993ab3c4.svg">  Jeweils 32 gleiche Parzellen. <img src="https://habrastorage.org/getpro/habr/post_images/60e/970/a20/60e970a20b30f36e7c21fe71c3d4dadb.svg">  kann durch eine Variable gelesen werden, deren Wert mit jedem Schritt im Zyklus zunimmt. </li></ol><br>  Das Endergebnis: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/no/gb/tl/nogbtlqbuzffixmq7xmt1w4j_ja.png"></div><br><h2>  Cloud-Modell </h2><br>  Wir werden verschiedene Arten von Rauschen in 3D ben√∂tigen.  Das erste ist Perlins lauerndes fraktales Brown'sches Bewegungsger√§usch (fBm): <br><br>  Ergebnis f√ºr ein 2D-Slice: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ld/h6/v6/ldh6v6zglre4jhon_n8qu193o8k.png"></div><br>  Das zweite ist Voronois Tarnger√§usch. <br><br>  Ergebnis f√ºr ein 2D-Slice: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/aa/rc/s2/aarcs2hvles3h89jqfc1lfrufjk.png"></div><br>  Um Vorleys Tarn-fBm-Rauschen zu erhalten, m√ºssen Sie Voronojs Tarn-fBm-Rauschen invertieren.  Ich habe die Wertebereiche jedoch nach meinem Ermessen geringf√ºgig ge√§ndert: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fbmTiledWorley3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(...)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> clamp((<span class="hljs-number"><span class="hljs-number">1.0</span></span>-fbmTiledVoronoi3(...))*<span class="hljs-number"><span class="hljs-number">1.5</span></span><span class="hljs-number"><span class="hljs-number">-0.25</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">1.0</span></span>); }</code> </pre> <br>  Das Ergebnis √§hnelt sofort Wolkenstrukturen: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ha/pf/em/hapfemxrqrxuqfpckajp53j4zxc.png"></div><br>  F√ºr Wolken ben√∂tigen Sie zwei spezielle Texturen.  Der erste hat eine Gr√∂√üe von 128 x 128 x 128 und ist f√ºr niederfrequentes Rauschen verantwortlich, der zweite hat eine Gr√∂√üe von 32 x 32 x 32 und ist f√ºr hochfrequentes Rauschen verantwortlich.  Jede Textur verwendet nur einen Kanal im R8-Format.  In einigen Beispielen werden 4 Kan√§le von R8G8B8A8 f√ºr die erste Textur und drei Kan√§le von R8G8B8 f√ºr die zweite Textur verwendet, und dann werden die Kan√§le in einem Shader gemischt.  Ich verstehe den Punkt nicht, da das Mischen im Voraus erfolgen kann, wodurch die Cache-Koh√§renz st√§rker beeintr√§chtigt wird. <br><br>  Zum Mischen und an einigen Stellen wird die Funktion remap () verwendet, mit der die Werte von einem Bereich zum anderen skaliert werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">remap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> minValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newMinValue, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> newMaxValue)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> newMinValue+(value-minValue)/(maxValue-minValue)*(newMaxValue-newMinValue); }</code> </pre> <br>  Beginnen wir mit der Vorbereitung der Textur mit niederfrequentem Rauschen: <br>  R-Kanal - Perlins fBm-Rauschen <br>  G-Kanal - gekacheltes fBm Vorley-Rauschen <br>  B-Kanal - kleineres fBm Worley-Rauschen mit kleinerem Ma√üstab <br>  A-Kanal - Varleys taylable fBm-Rauschen mit noch kleinerem Ma√üstab <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ms/_9/z-/ms_9z-hofvyvya5-zuh6vpi6da0.png"></div><br>  Das Mischen erfolgt folgenderma√üen: <br><br><pre> <code class="cpp hljs">finalValue=remap(noise.x, (noise.y * <span class="hljs-number"><span class="hljs-number">0.625</span></span> + noise.z*<span class="hljs-number"><span class="hljs-number">0.25</span></span> + noise.w * <span class="hljs-number"><span class="hljs-number">0.125</span></span>)<span class="hljs-number"><span class="hljs-number">-1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)</code> </pre> <br>  Ergebnis f√ºr ein 2D-Slice: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/64/qh/rl/64qhrl3wl2vrsbedao4fk9zr3xg.png"></div><br>  Bereiten Sie nun die Textur mit hochfrequentem Rauschen vor: <br>  R-Kanal - gekacheltes fBm Vorley-Rauschen <br>  G-Kanal - kleiner skaliertes fBm Vorley-Rauschen <br>  B-Kanal - Varley taylivaya fBm Rauschen mit noch kleinerem Ma√üstab <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ox/m6/in/oxm6inosejxwrkx2kdz7zv17eea.png"></div><br><pre> <code class="cpp hljs">finalValue=noise.x * <span class="hljs-number"><span class="hljs-number">0.625</span></span> + noise.y*<span class="hljs-number"><span class="hljs-number">0.25</span></span> + noise.z * <span class="hljs-number"><span class="hljs-number">0.125</span></span>;</code> </pre> <br>  Ergebnis f√ºr ein 2D-Slice: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/lg/mr/mc/lgmrmc2ohi3ayicwbji49fdhqb4.png"></div><br>  Wir ben√∂tigen auch eine 2D-Textur-Wetterkarte, die das Vorhandensein, die Dichte und die Form von Wolken in Abh√§ngigkeit von den Koordinaten des Raums bestimmt.  Es wurde von K√ºnstlern gemalt, um die Wolkendecke zu optimieren.  Die Interpretation der Farbkan√§le der Wetterkarte kann in der von mir geliehenen Version unterschiedlich sein: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fu/oi/m8/fuoim8wbtdzgqoc2lma8g6gb0ow.png"></div><br>  R-Kanal - Wolkendecke in geringer H√∂he <br>  G-Kanal - Wolkendecke in gro√üer H√∂he <br>  B-Kanal - maximale Wolkenh√∂he <br>  A-Kanal - Wolkendichte <br><br>  Jetzt k√∂nnen wir eine Funktion erstellen, die die Dichte der Wolken in Abh√§ngigkeit von den Koordinaten des 3D-Raums zur√ºckgibt. <br><br>  Am Eingang ein Punkt im Raum mit Koordinaten in km <br><br><pre> <code class="cpp hljs">vec3 position</code> </pre> <br>  F√ºgen Sie den Versatz sofort dem Wind hinzu <br><br><pre> <code class="cpp hljs">position.xz+=vec2(<span class="hljs-number"><span class="hljs-number">0.2f</span></span>)*ufmParams.time;</code> </pre> <br>  Holen Sie sich die Wetterkartenwerte <br><br><pre> <code class="cpp hljs">vec4 weather=textureLod(ufmWeatherMap, position.xz/<span class="hljs-number"><span class="hljs-number">4096.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre>  Wir erhalten den Prozentsatz der H√∂he (von 0 bis 1) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> height=cloudGetHeight(position);</code> </pre> <br>  F√ºgen Sie eine kleine Abrundung der Wolken unten hinzu: <pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SRb=clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.07</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre>  Wir nehmen eine lineare Abnahme der Dichte auf 0 mit zunehmender H√∂he gem√§√ü dem B-Kanal der Wetterkarte vor: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SRt=clamp(remap(height, weather.b*<span class="hljs-number"><span class="hljs-number">0.2</span></span>, weather.b, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre>  Kombinieren Sie das Ergebnis: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SA=SRb*SRt;</code> </pre> <br>  F√ºgen Sie noch einmal die Rundung der Wolken unten hinzu: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DRb=height*clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.15</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  F√ºgen Sie auch die Rundung der Wolken oben hinzu: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DRt=height*clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0.9</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre>  Wir kombinieren das Ergebnis, hier addieren wir den Einfluss der Dichte aus der Wetterkarte und den Einfluss der Dichte, der √ºber gui eingestellt wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DA=DRb*DRt*weather.a*<span class="hljs-number"><span class="hljs-number">2</span></span>*ufmProperties.density;</code> </pre> <br>  Kombinieren Sie niederfrequentes und hochfrequentes Rauschen aus unseren Texturen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SNsample=textureLod(ufmLowFreqNoiseTexture, position/<span class="hljs-number"><span class="hljs-number">48.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>).x*<span class="hljs-number"><span class="hljs-number">0.85f</span></span>+textureLod(ufmHighFreqNoiseTexture, position/<span class="hljs-number"><span class="hljs-number">4.8f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>).x*<span class="hljs-number"><span class="hljs-number">0.15f</span></span>;</code> </pre> <br>  In allen Dokumenten, die ich lese, erfolgt die Zusammenf√ºhrung auf andere Weise, aber diese Option hat mir gefallen. <br><br>  Wir bestimmen den Umfang der Abdeckung (% des Himmels, der von Wolken besetzt ist), der √ºber GUI eingestellt wird. Die R- und G-Kan√§le der Wetterkarte werden ebenfalls verwendet: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> WMc=max(weather.r, clamp(ufmProperties.coverage<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)*weather.g*<span class="hljs-number"><span class="hljs-number">2</span></span>);</code> </pre> <br>  Berechnen Sie die endg√ºltige Dichte: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d=clamp(remap(SNsample*SA, <span class="hljs-number"><span class="hljs-number">1</span></span>-ufmProperties.coverage*WMc, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)*DA;</code> </pre> <br>  Ganze Funktion: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cloudSampleDensity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec3 position)</span></span></span><span class="hljs-function"> </span></span>{ position.xz+=vec2(<span class="hljs-number"><span class="hljs-number">0.2f</span></span>)*ufmParams.time; vec4 weather=textureLod(ufmWeatherMap, position.xz/<span class="hljs-number"><span class="hljs-number">4096.0f</span></span>+vec2(<span class="hljs-number"><span class="hljs-number">0.2</span></span>, <span class="hljs-number"><span class="hljs-number">0.1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> height=cloudGetHeight(position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SRb=clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.07</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SRt=clamp(remap(height, weather.b*<span class="hljs-number"><span class="hljs-number">0.2</span></span>, weather.b, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SA=SRb*SRt; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DRb=height*clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0.15</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DRt=height*clamp(remap(height, <span class="hljs-number"><span class="hljs-number">0.9</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> DA=DRb*DRt*weather.a*<span class="hljs-number"><span class="hljs-number">2</span></span>*ufmProperties.density; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> SNsample=textureLod(ufmLowFreqNoiseTexture, position/<span class="hljs-number"><span class="hljs-number">48.0f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>).x*<span class="hljs-number"><span class="hljs-number">0.85f</span></span>+textureLod(ufmHighFreqNoiseTexture, position/<span class="hljs-number"><span class="hljs-number">4.8f</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>).x*<span class="hljs-number"><span class="hljs-number">0.15f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> WMc=max(weather.r, clamp(ufmProperties.coverage<span class="hljs-number"><span class="hljs-number">-0.5</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)*weather.g*<span class="hljs-number"><span class="hljs-number">2</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> d=clamp(remap(SNsample*SA, <span class="hljs-number"><span class="hljs-number">1</span></span>-ufmProperties.coverage*WMc, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>), <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>)*DA; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> d; }</code> </pre> <br>  Was genau diese Funktion sein sollte, ist eine offene Frage, denn wenn Sie die Gesetze ignorieren, denen die Wolken beim Einstellen von Parametern folgen, k√∂nnen Sie ein sehr ungew√∂hnliches und sch√∂nes Ergebnis erzielen.  Es h√§ngt alles von der Anwendung ab. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tf/nz/bz/tfnzbzvd2oucw2h_oed9pbm_8ku.png"></div><br><h2>  Integration </h2><br>  Die Erdatmosph√§re ist in zwei Schichten unterteilt: innere und √§u√üere, zwischen denen sich Wolken befinden k√∂nnen.  Diese Schichten k√∂nnen durch Kugeln, aber auch durch Ebenen dargestellt werden.  Ich lie√ü mich auf den Kugeln nieder.  F√ºr die erste Schicht habe ich den Kugelradius von 6415 km genommen, f√ºr die zweite Schicht den Radius von 6435 km.  Der Radius der Erde ist auf 6400 km gerundet.  Einige Parameter h√§ngen von der bedingten Dicke des ‚Äûwolkigen‚Äú Teils der Atmosph√§re (20 km) ab. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0z/ir/8r/0zir8r9qtvwlh9xk85i-hznhqa0.png"></div><br><br>  Im Gegensatz zum Himmel sind Wolken undurchsichtig, und f√ºr die Integration muss nicht nur die Farbe, sondern auch der Wert f√ºr den Alphakanal ermittelt werden.  Zuerst ben√∂tigen Sie eine Funktion, die die Gesamtdichte der Wolke zur√ºckgibt, durch die ein Lichtstrahl der Sonne f√§llt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5k/ne/lj/5kneljw4unaofsxxgbq12ealebw.png"></div><br>  Niemand macht darauf aufmerksam, aber die Praxis hat gezeigt, dass es √ºberhaupt nicht notwendig ist, den gesamten Weg des Strahls zu ber√ºcksichtigen, sondern nur die extremste L√ºcke.  Wir gehen davon aus, dass Wolken √ºber einem abgeschnittenen Segment √ºberhaupt nicht existieren. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ed/sr/ly/edsrlyis3-2or1nztj6q-osmats.png"></div><br>  Dar√ºber hinaus ist die Anzahl der Dichteproben, die ohne Beeintr√§chtigung der Leistung durchgef√ºhrt werden k√∂nnen, sehr begrenzt.  Guerilla-Spiele machen 6. Dar√ºber hinaus sagte der Entwickler in einer der Pr√§sentationen, dass sie diese Proben innerhalb des Kegels streuen, und die letzte Probe wurde speziell sehr weit vom Rest entfernt hergestellt, um so viel Platz wie m√∂glich abzudecken.  Die resultierenden Ungenauigkeiten und Rauschen werden immer noch vor dem Hintergrund benachbarter Proben gegl√§ttet, was zu einer erh√∂hten Genauigkeit f√ºhrt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5p/rr/df/5prrdfocofvzsjobvawnairijp0.png"></div><br>  Am Ende habe ich mich f√ºr 4 Proben entschieden, die auf derselben Linie liegen, aber letztere wird mit einem um das 6-fache erh√∂hten Schritt genommen.  Die Schrittweite betr√§gt 20 km * 0,01, was 200 m entspricht. <br><br>  Die Funktion ist ziemlich einfach: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cloudSampleDirectDensity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec3 position, vec3 sunDir)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   float avrStep=(6435.0-6415.0)*0.01; float sumDensity=0.0; for(int i=0;i&lt;4;i++) { float step=avrStep; //      6 if(i==3) step=step*6.0; //  position+=sunDir*step; //  ,  ,   //  float density=cloudSampleDensity(position)*step; sumDensity+=density; } return sumDensity; }</span></span></code> </pre> <br>  Jetzt k√∂nnen Sie zum schwierigeren Teil √ºbergehen.  Wir bestimmen den Beobachter auf der Erdoberfl√§che am Punkt {0, 6400,0} und finden den Schnittpunkt des Beobachtungsstrahls mit einer Kugel mit einem Radius von 6415 km und einem Mittelpunkt {0,0,0} - wir erhalten den Startpunkt S. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/25/je/zj/25jezjeea4j3bl51jneypfjetsi.png"></div><br>  Unten ist die Basisversion der Funktion: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vec4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainMarching</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec3 viewDir, vec3 sunDir)</span></span></span><span class="hljs-function"> </span></span>{ vec3 position; crossRaySphereOutFar(vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">6400.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>), viewDir, vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>), <span class="hljs-number"><span class="hljs-number">6415.0</span></span>, position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> avrStep=(<span class="hljs-number"><span class="hljs-number">6435.0</span></span><span class="hljs-number"><span class="hljs-number">-6415.0</span></span>)/<span class="hljs-number"><span class="hljs-number">64.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;<span class="hljs-number"><span class="hljs-number">128</span></span>;i++) { position+=viewDir*step; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(length(position)&gt;<span class="hljs-number"><span class="hljs-number">6435.0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec4(<span class="hljs-number"><span class="hljs-number">0.0</span></span>); }</code> </pre> <br>  Die Schrittgr√∂√üe ist definiert als 20 km / 64. d.h.  Bei der streng vertikalen Richtung des Beobachterstrahls werden 64 Proben erstellt.  Wenn diese Richtung jedoch horizontaler ist, sind die Abtastwerte etwas gr√∂√üer, sodass der Zyklus nicht 64 Schritte umfasst, sondern 128 mit einem Rand. <br><br>  Zu Beginn nehmen wir an, dass die endg√ºltige Farbe Schwarz und die Transparenz Einheit ist.  Mit jedem Schritt erh√∂hen wir den Farbwert und verringern den Transparenzwert.  Wenn die Transparenz nahe bei 0 liegt, k√∂nnen Sie die Schleife vorab beenden: <br><br><pre> <code class="cpp hljs">vec3 color=vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> transmittance=<span class="hljs-number"><span class="hljs-number">1.0</span></span>; ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">//    //      float density=cloudSampleDensity(position)*avrStep; //   ,   //   float sunDensity=cloudSampleDirectDensity(position, sunDir); //      float m2=exp(-ufmProperties.attenuation*sunDensity); float m3=ufmProperties.attenuation2*density; float light=ufmProperties.sunIntensity*m2*m3; //       color+=sunColor*light*transmittance; transmittance*=exp(-ufmProperties.attenuation*density); ‚Ä¶ return vec4(color, 1.0-transmittance);</span></span></code> </pre> <br>  ufmProperties.attenuation - Es gibt nur C in <img src="https://habrastorage.org/getpro/habr/post_images/610/ddb/ee8/610ddbee8d80f847b44fa75c9a136489.svg">  und ufmProperties.attenuation2 ist C in <img src="https://habrastorage.org/getpro/habr/post_images/cd1/8c2/405/cd18c240521dcfb71084a340a504e41f.svg">  .  ufmProperties.sunIntensity - die Strahlungsintensit√§t der Sonne.  sunColor - die Farbe der Sonne. <br><br>  Ergebnis: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/vc/ft/z9/vcftz9vsswkxpqoggirezpfpygm.png"></div><br>  Ein Fehler ist sofort erkennbar - starke Schattierung.  Aber jetzt werden wir den Mangel an verst√§rkter Beleuchtung in der N√§he der Sonne korrigieren.  Es ist passiert, weil wir keine Phasenfunktion hinzugef√ºgt haben.  Um die Streuung des durch die Wolken hindurchtretenden Lichts zu berechnen, wird die Phasenfunktion von Hengy-Greenstein verwendet, die es 1941 f√ºr √§hnliche Berechnungen in Gasclustern im Weltraum √∂ffnete: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4b0/b2e/33f/4b0b2e33fbd07036b14317d40cb1eac0.svg"></div><br>  Hier sollte ein Exkurs gemacht werden.  Nach dem kanonischen Beleuchtungsmodell sollte die Phasenfunktion eins sein.  In der Realit√§t ist das erzielte Ergebnis jedoch f√ºr niemanden geeignet, und jeder verwendet zwei Phasenfunktionen und kombiniert sogar seine Werte auf besondere Weise.  Ich habe mich auch auf zwei Phasenfunktionen konzentriert, aber ich addiere einfach ihre Werte.  Die erste Phasenfunktion hat g nahe 1 und erm√∂glicht es Ihnen, helles Licht in der N√§he der Sonne zu erzeugen.  Die Funktion der zweiten Phase hat g nahe 0,5 und erm√∂glicht es Ihnen, die Beleuchtung in der gesamten Himmelskugel allm√§hlich zu verringern. <br><br>  Aktualisierter Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// cos(theta) float mu=max(0, dot(viewDir, sunDir)); float m11=ufmProperties.phaseInfluence*cloudPhaseFunction(mu, ufmProperties.eccentrisy); float m12=ufmProperties.phaseInfluence2*cloudPhaseFunction(mu, ufmProperties.eccentrisy2); float m2=exp(-ufmProperties.attenuation*sunDensity); float m3=ufmProperties.attenuation2*density; float light=ufmProperties.sunIntensity*(m11+m12)*m2*m3;</span></span></code> </pre> <br>  ufmProperties.eccentrisy, ufmProperties.eccentrisy2 sind g-Werte <br><br>  Ergebnis: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ip/qr/fi/ipqrfivyafyxnmdswnn_nbpvfdk.png"></div><br>  Jetzt k√∂nnen Sie den Kampf mit zu viel Schattierung beginnen.  Es ist vorhanden, weil wir das Licht der umgebenden Wolken und des Himmels, das im wirklichen Leben ist, nicht ber√ºcksichtigt haben. <br><br>  Ich habe dieses Problem folgenderma√üen gel√∂st: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec4(color+ambientColor*ufmProperties.ambient, <span class="hljs-number"><span class="hljs-number">1.0</span></span>-transmittance);</code> </pre> <br>  W√§hrend ambientColor die Farbe des Himmels in Richtung des Beobachtungsstrahls ist, ist ufmProperties.ambient der Abstimmungsparameter. <br><br>  Ergebnis: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ct/8h/ji/ct8hjiyk7brz5pv8vuwjeji33bc.png"></div><br>  Es bleibt das letzte Problem zu l√∂sen.  Im wirklichen Leben sehen wir einen bestimmten Nebel oder Dunst, der es uns nicht erlaubt, sehr weit entfernte Objekte zu sehen, je horizontaler die Sicht gehalten wird.  Dies muss sich auch im Code widerspiegeln.  Ich nahm den √ºblichen Kosinus des Blickwinkels und der Exponentialfunktion.  Darauf basierend wird ein bestimmter Mischungskoeffizient berechnet, der eine lineare Interpolation zwischen der resultierenden Farbe und der Hintergrundfarbe erm√∂glicht. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> blending=<span class="hljs-number"><span class="hljs-number">1.0</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(-max(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, dot(viewDir, vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>)))*ufmProperties.fog); blending=blending*blending*blending; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec4(mix(ambientColor, color+ambientColor*ufmProperties.ambient, blending), <span class="hljs-number"><span class="hljs-number">1.0</span></span>-transmittance);</code> </pre> <br>  ufmProperties.fog - zur manuellen Konfiguration. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/02/td/9h/02td9ho6kelgum68wldvcf-zymu.png"></div><br>  Zusammenfassungsfunktion: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">vec4 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">mainMarching</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(vec3 viewDir, vec3 sunDir, vec3 sunColor, vec3 ambientColor)</span></span></span><span class="hljs-function"> </span></span>{ vec3 position; crossRaySphereOutFar(vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, <span class="hljs-number"><span class="hljs-number">6400.0</span></span>, <span class="hljs-number"><span class="hljs-number">0.0</span></span>), viewDir, vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>), <span class="hljs-number"><span class="hljs-number">6415.0</span></span>, position); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> avrStep=(<span class="hljs-number"><span class="hljs-number">6435.0</span></span><span class="hljs-number"><span class="hljs-number">-6415.0</span></span>)/<span class="hljs-number"><span class="hljs-number">64.0</span></span>; vec3 color=vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> transmittance=<span class="hljs-number"><span class="hljs-number">1.0</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i=<span class="hljs-number"><span class="hljs-number">0</span></span>;i&lt;<span class="hljs-number"><span class="hljs-number">128</span></span>;i++) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> density=cloudSampleDensity(position)*avrStep; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(density&gt;<span class="hljs-number"><span class="hljs-number">0.0</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sunDensity=cloudSampleDirectDensity(position, sunDir); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> mu=max(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, dot(viewDir, sunDir)); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m11=ufmProperties.phaseInfluence*cloudPhaseFunction(mu, ufmProperties.eccentrisy); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m12=ufmProperties.phaseInfluence2*cloudPhaseFunction(mu, ufmProperties.eccentrisy2); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m2=<span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(-ufmProperties.attenuation*sunDensity); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> m3=ufmProperties.attenuation2*density; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> light=ufmProperties.sunIntensity*(m11+m12)*m2*m3; color+=sunColor*light*transmittance; transmittance*=<span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(-ufmProperties.attenuation*density); } position+=viewDir*avrStep; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(transmittance&lt;<span class="hljs-number"><span class="hljs-number">0.05</span></span> || length(position)&gt;<span class="hljs-number"><span class="hljs-number">6435.0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> blending=<span class="hljs-number"><span class="hljs-number">1.0</span></span>-<span class="hljs-built_in"><span class="hljs-built_in">exp</span></span>(-max(<span class="hljs-number"><span class="hljs-number">0.0</span></span>, dot(viewDir, vec3(<span class="hljs-number"><span class="hljs-number">0.0</span></span>,<span class="hljs-number"><span class="hljs-number">1.0</span></span>,<span class="hljs-number"><span class="hljs-number">0.0</span></span>)))*ufmProperties.fog); blending=blending*blending*blending; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> vec4(mix(ambientColor, color+ambientColor*ufmProperties.ambient, blending), <span class="hljs-number"><span class="hljs-number">1.0</span></span>-transmittance); }</code> </pre> <br>  Demo-Video: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/uPxVgbwThmI" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Optimierung und m√∂gliche Verbesserungen </h2><br>  Nach der Implementierung des grundlegenden Rendering-Algorithmus besteht das n√§chste Problem darin, dass er zu langsam arbeitet.  Meine Version produzierte 25 fps in voller HD auf der Radeon RX 480. Die beiden folgenden Ans√§tze zur L√∂sung des Problems wurden von Guerilla Games selbst vorgeschlagen. <br><br>  <b>Wir zeichnen, was wirklich sichtbar ist</b> <br><br>  Der Bildschirm ist in Kacheln mit einer Gr√∂√üe von 16 x 16 Pixel unterteilt.  Zun√§chst wird die √ºbliche 3D-Umgebung gezeichnet.  Es stellt sich heraus, dass der gr√∂√üte Teil des Himmels von Bergen oder gro√üen Objekten bedeckt ist.  Dementsprechend m√ºssen Sie die Berechnung nur in den Kacheln durchf√ºhren, in denen die Wolken durch nichts blockiert sind. <br><br>  <b>Reprojektion</b> <br><br>  Wenn die Kamera station√§r ist, stellt sich heraus, dass die Wolken im Allgemeinen nicht aktualisiert werden k√∂nnen.  Wenn sich die Kamera jedoch bewegt hat, bedeutet dies nicht, dass wir den gesamten Bildschirm aktualisieren m√ºssen.  Alles ist bereits gezeichnet, Sie m√ºssen nur das Bild gem√§√ü den neuen Koordinaten neu erstellen.  Das Finden alter Koordinaten auf neuen durch die Projektions- und Ansichtsmatrizen des aktuellen und des vorherigen Frames wird als Projektion bezeichnet.  Bei einer Kameraverschiebung √ºbertragen wir also einfach die Farben gem√§√ü den neuen Koordinaten.  In F√§llen, in denen diese Koordinaten au√üerhalb des Bildschirms angezeigt werden, m√ºssen die Wolken ehrlich neu gezeichnet werden. <br><br>  <b>Teilaktualisierung</b> <br><br>  Die Idee der Neuprojektion gef√§llt mir nicht, da sich bei einer scharfen Drehung der Kamera m√∂glicherweise herausstellt, dass die Wolken f√ºr ein Drittel des Bildschirms gerendert werden m√ºssen, was zu Verz√∂gerungen f√ºhren kann.  Ich wei√ü nicht, wie Guerilla-Spiele damit umgegangen sind, aber zumindest in Horizon Zero Dawn bewegt sich die Kamera bei der Steuerung des Joysticks reibungslos und es gibt keine Probleme mit scharfen Spr√ºngen.  Daher habe ich als Experiment meinen eigenen Ansatz entwickelt.  Wolken werden in einer kubischen Karte in 5 Gesichtern gezeichnet, weil  Der Boden interessiert uns nicht.      ,  ‚Öî   .         88.          64    .       ,  ..   ,    .   radeon rx 480  500 fps  full hd    330 fps  opengl. Radeon hd 5700 series  109 fps  full hd  opengl (vulkan  ). <br><br> <b> mip-</b> <br><br>           mip-      ,        ,     mip-. <br><br> <b> </b> <br><br>    -  -   Guerrilla Games        3D ,    ,    2D . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ud/f2/vj/udf2vjpfht0hhpbf9zptwfmadhg.jpeg"></div><br> <b>Curl-</b> <br><br>            curl-.   ,    . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/-n/qq/pg/-nqqpgmixyogyjxqrdyhm4oxlpc.png"></div><br> <b> </b> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qd/wq/xv/qdwqxvzveiwuxgu2v84aw5fhjwo.png"></div><br>  ,  ,   .      ,     .         . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ap/vj/-a/apvj-assr02-vaov3o1k5frfawk.png"></div><br>     . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/jd/lg/1h/jdlg1hp7jajzhlbom4ocmn3vl70.png"></div><br>        ,       ,        . ,     .          Frostbite. <br><br><h2>  N√ºtzliche Links </h2><br> <b> Guerrilla Games</b> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">d1z4o56rleaq4j.cloudfront.net/downloads/assets/Nubis-Authoring-Realtime-Volumetric-Cloudscapes-with-the-Decima-Engine-Final.pdf?mtime=20170807141817</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">killzone.dl.playstation.net/killzone/horizonzerodawn/presentations/Siggraph15_Schneider_Real-Time_Volumetric_Cloudscapes_of_Horizon_Zero_Dawn.pdf</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.youtube.com/watch?v=-d8qT5-1LOI</a> <br><br> <b>  GPU Pro 7</b> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">vk.com/doc179245989_437393482?hash=a9af5f665eda4edf58&amp;dl=806d4dbdac0f7a761c</a> <br><br> <b></b> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.scratchapixel.com/lessons/procedural-generation-virtual-worlds/simulating-sky/simulating-colors-of-the-sky</a> <br><br> <b> Frostbite</b> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">media.contentapi.ea.com/content/dam/eacom/frostbite/files/s2016-pbs-frostbite-sky-clouds-new.pdf</a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">www.shadertoy.com/view/XlBSRz</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de459948/">https://habr.com/ru/post/de459948/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de459924/index.html">Vollst√§ndiger Reaktionstestzyklus. Auto.ru-Bericht</a></li>
<li><a href="../de459928/index.html">Der Weg des Sch√ºlers zur Entwicklung mobiler Apps</a></li>
<li><a href="../de459930/index.html">Python-Importautomatisierung</a></li>
<li><a href="../de459934/index.html">Die Zusammenfassung interessanter Materialien f√ºr den mobilen Entwickler # 306 (vom 8. bis 14. Juli)</a></li>
<li><a href="../de459936/index.html">9 weitere Tricks f√ºr die Arbeit mit Visual Studio</a></li>
<li><a href="../de459952/index.html">Ein wenig Erfahrung mit Backup & Storage</a></li>
<li><a href="../de459954/index.html">Warum eines der gr√∂√üten IT-Unternehmen zu CNCF kam - einem Fonds zur Entwicklung der Cloud-Infrastruktur</a></li>
<li><a href="../de459956/index.html">Implantation in v√∂lliger Abwesenheit von Z√§hnen infolge vorzeitiger Besuche beim Zahnarzt</a></li>
<li><a href="../de459958/index.html">Analysieren von Aufgaben aus der Hydra-Konferenz - Lastausgleich und In-Memory-Speicher</a></li>
<li><a href="../de459960/index.html">Von der Idee bis zur Ver√∂ffentlichung. Detaillierte Market Frontend-Erfahrung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>