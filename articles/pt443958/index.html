<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚ÜôÔ∏è üï∫ üë©‚Äçüë¶‚Äçüë¶ Padr√£o descart√°vel (princ√≠pio do design descart√°vel) pt. 1 üë©üèæ‚Äçüîß üë©üèø‚Äçü§ù‚Äçüë®üèª ‚è©</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Padr√£o descart√°vel (princ√≠pio do projeto descart√°vel) 


 Eu acho que quase todo programador que usa .NET agora diz que esse padr√£o √© um peda√ßo de bol...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Padr√£o descart√°vel (princ√≠pio do design descart√°vel) pt. 1</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443958/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/nm/tj/eq/nmtjeqodhdjh27wvs0w6v8_0dhu.png"></a> </p><br><h1 id="disposable-pattern-disposable-design-principle">  Padr√£o descart√°vel (princ√≠pio do projeto descart√°vel) </h1><br><p>  Eu acho que quase todo programador que usa .NET agora diz que esse padr√£o √© um peda√ßo de bolo.  Esse √© o padr√£o mais conhecido usado na plataforma.  No entanto, mesmo o dom√≠nio do problema mais simples e conhecido ter√° √°reas secretas que voc√™ nunca viu.  Ent√£o, vamos descrever tudo desde o in√≠cio para os iniciantes e todo o resto (para que cada um de voc√™s se lembre do b√°sico).  N√£o pule esses par√°grafos - estou observando voc√™! </p><br><p>  Se eu perguntar o que √© IDisposable, voc√™ certamente dir√° que √© </p><br><pre><code class="plaintext hljs">public interface IDisposable { void Dispose(); }</code> </pre> <br><p>  Qual √© o objetivo da interface?  Quero dizer, por que precisamos limpar a mem√≥ria, se temos um Garbage Collector inteligente que limpa a mem√≥ria em vez de n√≥s, para que nem precisemos pensar nisso.  No entanto, existem alguns pequenos detalhes. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Este cap√≠tulo foi traduzido do russo em conjunto pelo autor e por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tradutores profissionais</a> .  Voc√™ pode nos ajudar com a tradu√ß√£o do russo ou do ingl√™s para qualquer outro idioma, principalmente para chin√™s ou alem√£o. <br><br>  Al√©m disso, se voc√™ quiser nos agradecer, a melhor maneira de fazer isso √© nos dar uma estrela no github ou no fork do reposit√≥rio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote><a name="habracut"></a><br><p>  Existe um equ√≠voco de que o <code>IDisposable</code> serve para liberar recursos n√£o gerenciados.  Isso √© apenas parcialmente verdadeiro e, para entend√™-lo, basta lembrar dos exemplos de recursos n√£o gerenciados.  A classe <code>File</code> √© um recurso n√£o gerenciado?  N√£o.  Talvez o <code>DbContext</code> seja um recurso n√£o gerenciado?  N√£o de novo  Um recurso n√£o gerenciado √© algo que n√£o pertence ao sistema de tipos .NET.  Algo que a plataforma n√£o criou, algo que existe fora de seu escopo.  Um exemplo simples √© um identificador de arquivo aberto em um sistema operacional.  Um identificador √© um n√∫mero que identifica exclusivamente um arquivo aberto - n√£o, n√£o por voc√™ - por um sistema operacional.  Ou seja, todas as estruturas de controle (por exemplo, a posi√ß√£o de um arquivo em um sistema de arquivos, fragmentos de arquivo em caso de fragmenta√ß√£o e outras informa√ß√µes de servi√ßo, os n√∫meros de um cilindro, uma cabe√ßa ou um setor de um HDD) est√£o dentro de um sistema operacional, mas n√£o Plataforma .NET.  O √∫nico recurso n√£o gerenciado que √© passado para a plataforma .NET √© o n√∫mero IntPtr.  Esse n√∫mero √© agrupado por FileSafeHandle, que por sua vez √© agrupado pela classe File.  Isso significa que a classe File n√£o √© um recurso n√£o gerenciado por si s√≥, mas usa uma camada adicional na forma do IntPtr para incluir um recurso n√£o gerenciado - o identificador de um arquivo aberto.  Como voc√™ l√™ esse arquivo?  Usando um conjunto de m√©todos no sistema operacional WinAPI ou Linux. </p><br><p>  Primitivas de sincroniza√ß√£o em programas multithread ou multiprocessador s√£o o segundo exemplo de recursos n√£o gerenciados.  Aqui pertencem matrizes de dados que s√£o passadas por P / Invoke e tamb√©m mutexes ou sem√°foros. </p><br><blockquote>  Observe que o SO simplesmente n√£o passa o identificador de um recurso n√£o gerenciado para um aplicativo.  Ele tamb√©m salva esse identificador na tabela de identificadores abertos pelo processo.  Assim, o sistema operacional pode fechar corretamente os recursos ap√≥s o encerramento do aplicativo.  Isso garante que os recursos sejam fechados de qualquer maneira depois que voc√™ sair do aplicativo.  No entanto, o tempo de execu√ß√£o de um aplicativo pode ser diferente, o que pode causar um longo bloqueio de recursos. </blockquote><p>  Ok  Agora, cobrimos recursos n√£o gerenciados.  Por que precisamos usar o IDisposable nesses casos?  Porque o .NET Framework n√£o tem id√©ia do que est√° acontecendo fora de seu territ√≥rio.  Se voc√™ abrir um arquivo usando a API do SO, o .NET n√£o saber√° nada sobre ele.  Se voc√™ alocar um intervalo de mem√≥ria para suas pr√≥prias necessidades (por exemplo, usando o VirtualAlloc), o .NET tamb√©m n√£o saber√° nada.  Se n√£o souber, n√£o liberar√° a mem√≥ria ocupada por uma chamada do VirtualAlloc.  Ou n√£o fechar√° um arquivo aberto diretamente por meio de uma chamada da API do SO.  Isso pode causar consequ√™ncias diferentes e inesperadas.  Voc√™ pode obter o OutOfMemory se alocar muita mem√≥ria sem liber√°-la (por exemplo, apenas definindo um ponteiro como nulo).  Ou, se voc√™ abrir um arquivo em um compartilhamento de arquivo atrav√©s do SO sem fech√°-lo, bloquear√° o arquivo nesse compartilhamento por um longo per√≠odo de tempo.  O exemplo de compartilhamento de arquivos √© especialmente bom, pois o bloqueio permanecer√° no lado do IIS, mesmo depois que voc√™ fechar uma conex√£o com um servidor.  Voc√™ n√£o tem direitos para liberar o bloqueio e precisar√° solicitar aos administradores que executem o <code>iisreset</code> ou fechem os recursos manualmente usando um software especial. <br>  Esse problema em um servidor remoto pode se tornar uma tarefa complexa a ser resolvida. </p><br><p>  Todos esses casos precisam de um <em>protocolo</em> universal e familiar <em>para intera√ß√£o</em> entre um sistema de tipos e um programador.  Ele deve identificar claramente os tipos que requerem fechamento for√ßado.  A interface IDisposable serve exatamente para esse prop√≥sito.  Funciona da seguinte maneira: se um tipo contiver a implementa√ß√£o da interface IDisposable, voc√™ dever√° chamar Dispose () ap√≥s concluir o trabalho com uma inst√¢ncia desse tipo. </p><br><p>  Portanto, existem duas maneiras padr√£o de cham√°-lo.  Geralmente, voc√™ cria uma inst√¢ncia da entidade para us√°-la rapidamente em um m√©todo ou durante a vida √∫til da inst√¢ncia da entidade. </p><br><p>  A primeira maneira √© envolver uma inst√¢ncia no <code>using(...){ ... }</code> .  Isso significa que voc√™ instrui a destruir um objeto ap√≥s o t√©rmino do bloco relacionado ao uso, ou seja, chamar Dispose ().  A segunda maneira √© destruir o objeto, quando sua vida √∫til terminar, com uma refer√™ncia ao objeto que queremos liberar.  Mas o .NET n√£o tem nada al√©m de um m√©todo de finaliza√ß√£o que implica a destrui√ß√£o autom√°tica de um objeto, certo?  No entanto, a finaliza√ß√£o n√£o √© adequada, pois n√£o sabemos quando ser√° chamada.  Enquanto isso, precisamos liberar um objeto em um determinado momento, por exemplo, logo ap√≥s terminarmos o trabalho com um arquivo aberto.  √â por isso que tamb√©m precisamos implementar o IDisposable e chamar Dispose para liberar todos os recursos que possu√≠mos.  Assim, seguimos o <em>protocolo</em> , e √© muito importante.  Porque se algu√©m seguir, todos os participantes devem fazer o mesmo para evitar problemas. </p><br><h2 id="different-ways-to-implement-idisposable">  Diferentes maneiras de implementar IDisposable </h2><br><p>  Vejamos as implementa√ß√µes do IDisposable de simples a complicadas.  O primeiro e o mais simples √© usar o IDisposable, pois √©: </p><br><pre> <code class="plaintext hljs">public class ResourceHolder : IDisposable { DisposableResource _anotherResource = new DisposableResource(); public void Dispose() { _anotherResource.Dispose(); } }</code> </pre> <br><p>  Aqui, criamos uma inst√¢ncia de um recurso que √© lan√ßado posteriormente por Dispose ().  A √∫nica coisa que torna essa implementa√ß√£o inconsistente √© que voc√™ ainda pode trabalhar com a inst√¢ncia ap√≥s sua destrui√ß√£o por <code>Dispose()</code> : </p><br><pre> <code class="plaintext hljs">public class ResourceHolder : IDisposable { private DisposableResource _anotherResource = new DisposableResource(); private bool _disposed; public void Dispose() { if(_disposed) return; _anotherResource.Dispose(); _disposed = true; } [MethodImpl(MethodImplOptions.AggressiveInlining)] private void CheckDisposed() { if(_disposed) { throw new ObjectDisposedException(); } } }</code> </pre> <br><p>  CheckDisposed () deve ser chamado como uma primeira express√£o em todos os m√©todos p√∫blicos de uma classe.  A estrutura de classe <code>ResourceHolder</code> obtida parece boa para destruir um recurso n√£o gerenciado, que √© <code>DisposableResource</code> .  No entanto, essa estrutura n√£o √© adequada para um recurso n√£o gerenciado incorporado.  Vejamos o exemplo com um recurso n√£o gerenciado. </p><br><pre> <code class="plaintext hljs">public class FileWrapper : IDisposable { IntPtr _handle; public FileWrapper(string name) { _handle = CreateFile(name, 0, 0, 0, 0, 0, IntPtr.Zero); } public void Dispose() { CloseHandle(_handle); } [DllImport("kernel32.dll", EntryPoint = "CreateFile", SetLastError = true)] private static extern IntPtr CreateFile(String lpFileName, UInt32 dwDesiredAccess, UInt32 dwShareMode, IntPtr lpSecurityAttributes, UInt32 dwCreationDisposition, UInt32 dwFlagsAndAttributes, IntPtr hTemplateFile); [DllImport("kernel32.dll", SetLastError=true)] private static extern bool CloseHandle(IntPtr hObject); }</code> </pre> <br><p>  Qual √© a diferen√ßa no comportamento dos dois √∫ltimos exemplos?  O primeiro descreve a intera√ß√£o de dois recursos gerenciados.  Isso significa que, se um programa funcionar corretamente, o recurso ser√° liberado de qualquer maneira.  Como <code>DisposableResource</code> √© gerenciado, o .NET CLR sabe disso e liberar√° a mem√≥ria se o seu comportamento estiver incorreto.  Observe que conscientemente n√£o suponho que tipo <code>DisposableResource</code> encapsula.  Pode haver qualquer tipo de l√≥gica e estrutura.  Ele pode conter recursos gerenciados e n√£o gerenciados.  <em>Isso n√£o deveria nos preocupar</em> .  Ningu√©m nos pede para descompilar as bibliotecas de terceiros a cada vez e ver se eles usam recursos gerenciados ou n√£o gerenciados.  E se <em>nosso tipo</em> usa um recurso n√£o gerenciado, n√£o podemos estar cientes disso.  Fazemos isso na classe <code>FileWrapper</code> .  Ent√£o, o que acontece neste caso?  Se usarmos recursos n√£o gerenciados, teremos dois cen√°rios.  O primeiro √© quando tudo est√° OK e Dispose √© chamado.  O segundo √© quando algo d√° errado e Dispose falhou. </p><br><p>  Digamos imediatamente por que isso pode dar errado: </p><br><ul><li>  Se usarmos <code>using(obj) { ... }</code> , uma exce√ß√£o poder√° aparecer em um bloco interno de c√≥digo.  Essa exce√ß√£o √© capturada pelo bloco <code>finally</code> , que n√£o podemos ver (este √© o a√ß√∫car sint√°tico do C #).  Este bloco chama Dispose implicitamente.  No entanto, h√° casos em que isso n√£o acontece.  Por exemplo, nem <code>catch</code> nem <code>finally</code> pegar <code>StackOverflowException</code> .  Voc√™ deve sempre se lembrar disso.  Como se algum thread se tornar recursivo e o <code>StackOverflowException</code> ocorrer em algum momento, o .NET esquecer√° os recursos que ele usou, mas n√£o liberou.  Ele n√£o sabe como liberar recursos n√£o gerenciados.  Eles permanecer√£o na mem√≥ria at√© que o SO os libere, ou seja, quando voc√™ sair de um programa ou mesmo algum tempo ap√≥s o encerramento de um aplicativo. </li><li>  Se chamarmos Dispose () de outro Dispose ().  Novamente, podemos n√£o conseguir alcan√ß√°-lo.  Este n√£o √© o caso de um desenvolvedor de aplicativos distra√≠do que esqueceu de chamar Dispose ().  √â a quest√£o das exce√ß√µes.  No entanto, essas n√£o s√£o apenas as exce√ß√µes que travam um encadeamento de um aplicativo.  Aqui, falamos sobre todas as exce√ß√µes que impedir√£o um algoritmo de chamar um Dispose () externo que chamar√° nosso Dispose (). </li></ul><br><p>  Todos esses casos criar√£o recursos n√£o gerenciados suspensos.  Isso ocorre porque o Garbage Collector n√£o sabe que deve colet√°-los.  Tudo o que pode ser feito na pr√≥xima verifica√ß√£o √© descobrir que a √∫ltima refer√™ncia a um gr√°fico de objeto com o nosso tipo <code>FileWrapper</code> foi perdida.  Nesse caso, a mem√≥ria ser√° realocada para objetos com refer√™ncias.  Como podemos evit√°-lo? </p><br><p>  N√≥s devemos implementar o finalizador de um objeto.  O 'finalizador' √© nomeado desta maneira de prop√≥sito.  N√£o √© um destruidor, como pode parecer devido a maneiras semelhantes de chamar finalizadores em C # e destruidores em C ++.  A diferen√ßa √© que um finalizador ser√° chamado de <em>qualquer maneira</em> , ao contr√°rio de um destruidor (assim como <code>Dispose()</code> ).  Um finalizador √© chamado quando a Coleta de Lixo √© iniciada (agora √© suficiente saber disso, mas as coisas s√£o um pouco mais complicadas).  √â usado para uma libera√ß√£o garantida de recursos se <em>algo der errado</em> .  Precisamos implementar um finalizador para liberar recursos n√£o gerenciados.  Novamente, como um finalizador √© chamado quando o GC √© iniciado, n√£o sabemos quando isso acontece em geral. </p><br><p>  Vamos expandir nosso c√≥digo: </p><br><pre> <code class="plaintext hljs">public class FileWrapper : IDisposable { IntPtr _handle; public FileWrapper(string name) { _handle = CreateFile(name, 0, 0, 0, 0, 0, IntPtr.Zero); } public void Dispose() { InternalDispose(); GC.SuppressFinalize(this); } private void InternalDispose() { CloseHandle(_handle); } ~FileWrapper() { InternalDispose(); } /// other methods }</code> </pre> <br><p>  Aprimoramos o exemplo com o conhecimento sobre o processo de finaliza√ß√£o e protegemos o aplicativo contra a perda de informa√ß√µes de recursos se Dispose () n√£o for chamado.  Tamb√©m chamamos GC.SuppressFinalize para desativar a finaliza√ß√£o da inst√¢ncia do tipo se Dispose () for chamado com √™xito.  N√£o h√° necessidade de liberar o mesmo recurso duas vezes, certo?  Portanto, tamb√©m reduzimos a fila de finaliza√ß√£o liberando uma regi√£o aleat√≥ria do c√≥digo que provavelmente ser√° executada com a finaliza√ß√£o em paralelo, algum tempo depois.  Agora, vamos aprimorar o exemplo ainda mais. </p><br><pre> <code class="plaintext hljs">public class FileWrapper : IDisposable { IntPtr _handle; bool _disposed; public FileWrapper(string name) { _handle = CreateFile(name, 0, 0, 0, 0, 0, IntPtr.Zero); } public void Dispose() { if(_disposed) return; _disposed = true; InternalDispose(); GC.SuppressFinalize(this); } [MethodImpl(MethodImplOptions.AggressiveInlining)] private void CheckDisposed() { if(_disposed) { throw new ObjectDisposedException(); } } private void InternalDispose() { CloseHandle(_handle); } ~FileWrapper() { InternalDispose(); } /// other methods }</code> </pre> <br><p>  Agora, nosso exemplo de um tipo que encapsula um recurso n√£o gerenciado parece completo.  Infelizmente, o segundo <code>Dispose()</code> √© de fato um padr√£o da plataforma e permitimos cham√°-lo.  Observe que as pessoas geralmente permitem que a segunda chamada de <code>Dispose()</code> evite problemas com um c√≥digo de chamada e isso est√° errado.  No entanto, um usu√°rio da sua biblioteca que analisa a documenta√ß√£o da MS pode n√£o pensar e permitir√° v√°rias chamadas de Dispose ().  Chamar outros m√©todos p√∫blicos destruir√° a integridade de um objeto de qualquer maneira.  Se destru√≠mos o objeto, n√£o podemos mais trabalhar com ele.  Isso significa que devemos chamar <code>CheckDisposed</code> no in√≠cio de cada m√©todo p√∫blico. </p><br><p>  No entanto, este c√≥digo cont√©m um problema grave que o impede de funcionar como pretendido.  Se lembrarmos como a coleta de lixo funciona, notaremos um recurso.  Ao coletar lixo, o GC finaliza <em>principalmente</em> tudo o que √© herdado diretamente do <em>Object</em> .  Em seguida, lida com objetos que implementam <em>CriticalFinalizerObject</em> .  Isso se torna um problema, pois as duas classes que projetamos herdam Object.  N√£o sabemos em que ordem eles chegar√£o √† "√∫ltima milha".  No entanto, um objeto de n√≠vel superior pode usar seu finalizador para finalizar um objeto com um recurso n√£o gerenciado.  Embora isso n√£o pare√ßa uma √≥tima id√©ia.  A ordem de finaliza√ß√£o seria muito √∫til aqui.  Para defini-lo, o tipo de n√≠vel inferior com um recurso n√£o gerenciado encapsulado deve ser herdado de <code>CriticalFinalizerObject</code> . </p><br><p>  A segunda raz√£o √© mais profunda.  Imagine que voc√™ se atreveu a escrever um aplicativo que n√£o cuida muito da mem√≥ria.  Aloca mem√≥ria em grandes quantidades, sem descontar e outras sutilezas.  Um dia, esse aplicativo falhar√° com o OutOfMemoryException.  Quando isso ocorre, o c√≥digo √© executado especificamente.  Ele n√£o pode alocar nada, pois levar√° a uma exce√ß√£o repetida, mesmo que a primeira seja capturada.  Isso n√£o significa que n√£o devemos criar novas inst√¢ncias de objetos.  Mesmo uma simples chamada de m√©todo pode gerar essa exce√ß√£o, por exemplo, a finaliza√ß√£o.  Lembro que os m√©todos s√£o compilados quando voc√™ os chama pela primeira vez.  Esse √© o comportamento usual.  Como podemos evitar esse problema?  Muito facilmente.  Se o seu objeto for herdado do <em>CriticalFinalizerObject</em> , <em>todos os</em> m√©todos desse tipo ser√£o compilados imediatamente ap√≥s o carregamento na mem√≥ria.  Al√©m disso, se voc√™ marcar m√©todos com o atributo <em>[PrePrepareMethod]</em> , eles tamb√©m ser√£o pr√©-compilados e ter√£o seguran√ßa para chamar em uma situa√ß√£o de poucos recursos. </p><br><p>  Por que isso √© importante?  Por que gastar muito esfor√ßo com aqueles que morrem?  Porque os recursos n√£o gerenciados podem ser suspensos em um sistema por muito tempo.  Mesmo depois de reiniciar um computador.  Se um usu√°rio abrir um arquivo a partir de um compartilhamento de arquivos no seu aplicativo, o primeiro ser√° bloqueado por um host remoto e liberado no tempo limite ou quando voc√™ liberar um recurso fechando o arquivo.  Se o seu aplicativo travar quando o arquivo for aberto, ele n√£o ser√° lan√ßado mesmo ap√≥s a reinicializa√ß√£o.  Voc√™ ter√° que esperar muito tempo at√© que o host remoto o libere.  Al√©m disso, voc√™ n√£o deve permitir exce√ß√µes nos finalizadores.  Isso leva a uma falha acelerada do CLR e de um aplicativo, pois voc√™ n√£o pode encerrar a chamada de um finalizador na <em>tentativa ... captura</em> .  Quero dizer, quando voc√™ tenta liberar um recurso, deve ter certeza de que ele pode ser liberado.  O √∫ltimo, mas n√£o menos importante, fato: se o CLR descarregar um dom√≠nio de maneira anormal, os finalizadores dos tipos derivados de <em>CriticalFinalizerObject</em> tamb√©m ser√£o chamados, diferentemente dos herdados diretamente do <em>Object</em> . </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Este charper traduzido do russo como idioma do autor por <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">tradutores profissionais</a> .  Voc√™ pode nos ajudar a criar a vers√£o traduzida deste texto para qualquer outro idioma, incluindo chin√™s ou alem√£o, usando as vers√µes russa e inglesa do texto como fonte. <br><br>  Al√©m disso, se voc√™ quiser dizer "obrigado", a melhor maneira de escolher √© dar uma estrela no reposit√≥rio do github ou do fork <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">https://github.com/sidristij/dotnetbook</a> <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt443958/">https://habr.com/ru/post/pt443958/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt443948/index.html">Competi√ß√£o "Sou um Intel Studio Expert" com super pr√™mios para desenvolvedores</a></li>
<li><a href="../pt443950/index.html">Confie, aconselhe, sugira - procure an√°lises reais de software</a></li>
<li><a href="../pt443952/index.html">Internet Soberana - pelo nosso dinheiro</a></li>
<li><a href="../pt443954/index.html">Singularidade tecnol√≥gica: o mito moderno do fim do mundo sob o disfarce da hip√≥tese de progresso</a></li>
<li><a href="../pt443956/index.html">Rede social em 2019: Yandex lan√ßou o Aura</a></li>
<li><a href="../pt443960/index.html">Padr√£o descart√°vel (Princ√≠pio do projeto descart√°vel) pt. 2</a></li>
<li><a href="../pt443962/index.html">Padr√£o descart√°vel (Princ√≠pio do projeto descart√°vel) pt.3</a></li>
<li><a href="../pt443964/index.html">Kolesa Conf √© a maior confer√™ncia de TI do Cazaquist√£o. An√∫ncio de relat√≥rios</a></li>
<li><a href="../pt443966/index.html">Google Docs - um bate-papo favorito entre os alunos</a></li>
<li><a href="../pt443968/index.html">Como compramos uma casa com pain√©is solares e o que aconteceu</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>