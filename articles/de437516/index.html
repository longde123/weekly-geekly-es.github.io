<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨‍👨‍👧 👩🏾‍🤝‍👨🏻 👏🏿 Suchen nach Fehlern im Amazon Web Services SDK für .NET-Quellcode ✍️ 📀 🔜</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Grüße an alle Fans, die den Code eines anderen kritisiert haben. :) Heute ist in unserem Labor neues Forschungsmaterial der Quellcode des AWS SDK-Proj...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Suchen nach Fehlern im Amazon Web Services SDK für .NET-Quellcode</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/437516/"><p><img src="https://habrastorage.org/getpro/habr/post_images/188/292/f27/188292f271dd0648b09f848dbe66efa6.png" alt="Bild 1"></p><br>  Grüße an alle Fans, die den Code eines anderen kritisiert haben.  :) Heute ist in unserem Labor neues Forschungsmaterial der Quellcode des AWS SDK-Projekts für .NET.  Einmal haben wir einen Artikel über das Überprüfen des AWS SDK auf C ++ geschrieben.  Dann gab es nichts besonders Interessantes.  Mal sehen, wie uns die .NET-Version des AWS SDK gefallen wird.  Eine gute Gelegenheit, die Fähigkeiten des PVS-Studio-Analysators erneut zu demonstrieren und die Welt ein wenig perfekter zu machen. <br><a name="habracut"></a><br>  Das .NET SDK von Amazon Web Services (AWS) ist ein Entwickler-Toolkit, mit dem .NET-basierte Anwendungen in der AWS-Infrastruktur erstellt und das Schreiben von Code erheblich vereinfacht werden können.  Das SDK enthält .NET API-Suites für verschiedene AWS-Dienste wie Amazon S3, Amazon EC2, DynamoDB und andere.  Der Quellcode für das SDK wird auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub gehostet</a> . <br><br>  Wie gesagt, wir haben einmal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">einen Artikel</a> über das Überprüfen des AWS SDK auf C ++ geschrieben.  Der Artikel erwies sich als klein - es gab nur ein paar Fehler in 512.000 Codezeilen.  Dieses Mal haben wir es mit einer viel größeren Menge an Code zu tun, einschließlich ungefähr 34.000 cs-Dateien, und die Gesamtzahl der Codezeilen (ohne leere) beträgt beeindruckende 5 Millionen.  Ein kleiner Teil des Codes (200 Tausend Zeilen in 664 cs-Dateien) fällt auf die Tests, ich habe sie nicht berücksichtigt. <br><br>  Wenn die Qualität des .NET-Codes der SDK-Version ungefähr der von C ++ entspricht (zwei Fehler pro 512 KLOC), sollten wir ungefähr zehnmal mehr Fehler erhalten.  Dies ist natürlich eine sehr ungenaue Berechnungsmethode, bei der Sprachmerkmale und viele andere Faktoren nicht berücksichtigt werden, aber ich glaube nicht, dass der Leser jetzt in langweilige Diskussionen eintauchen möchte.  Stattdessen schlage ich vor, direkt zu den Ergebnissen zu gehen. <br><br>  Die Überprüfung wurde mit PVS-Studio Version 6.27 durchgeführt.  Unglaublicherweise konnte der Analysator etwa 40 erwähnenswerte Fehler im AWS SDK für .NET-Code erkennen.  Dies zeigt nicht nur die hohe Qualität des SDK-Codes (ca. 4 Fehler pro 512 KLOC), sondern auch die vergleichbare Qualität der C # -Arbeit des PVS-Studio-Analysators im Vergleich zu C ++.  Tolles Ergebnis! <br><br>  Die Autoren des AWS SDK für .NET sind großartig.  Von Projekt zu Projekt zeigen sie eine erstaunliche Codequalität.  Dies kann ein gutes Beispiel für andere Teams sein.  Aber natürlich wäre ich nicht der Entwickler eines statischen Analysators, wenn ich meine 5 Kopeken nicht eingesetzt hätte.  :) Wir arbeiten bereits mit dem Amazon Lumberyard-Team an der Verwendung von PVS-Studio.  Da es sich jedoch um ein sehr großes Unternehmen mit einer Reihe von Abteilungen auf der ganzen Welt handelt, ist es sehr wahrscheinlich, dass das AWS SDK für .NET-Team noch nie von PVS-Studio gehört hat.  Auf jeden Fall habe ich im SDK-Code keine Anzeichen für die Verwendung unseres Analysators gefunden, obwohl dies nichts bedeutet.  Das Team <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verwendet jedoch</a> mindestens <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den</a> in Visual Studio integrierten Analysator.  Das ist gut, aber Codeprüfungen können <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verbessert werden</a> :). <br><br>  Infolgedessen konnte ich immer noch einige Fehler im SDK-Code finden, und schließlich ist es Zeit, sie zu teilen. <br><br>  <b>Fehler in der Logik</b> <br><br>  <b>PVS-Studio Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3008</a> [CWE-563] Der Variablen 'this.linker.s3.region' werden zweimal nacheinander Werte zugewiesen.  Vielleicht ist das ein Fehler.  Überprüfen Sie die Zeilen: 116, 114. AWSSDK.DynamoDBv2.Net45 S3Link.cs 116 <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Region { get { .... } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (String.IsNullOrEmpty(value)) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.linker.s3.region = <span class="hljs-string"><span class="hljs-string">"us-east-1"</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.linker.s3.region = value; } }</code> </pre> <br>  Der Analysator warnt davor, den Wert derselben Variablen neu zuzuweisen.  Aus dem Code wird deutlich, dass dies auf einen Fehler zurückzuführen ist, der gegen die Funktionslogik verstößt: Der Wert der Variablen <i>this.linker.s3.region</i> ist unabhängig von der <i>if-</i> Bedingung <i>(String.IsNullOrEmpty (Wert))</i> immer gleich <i>value</i> .  Im Hauptteil des <i>if-</i> Blocks wurde die <i>Rückgabe</i> übersprungen.  Der Code muss wie folgt korrigiert werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> Region { get { .... } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (String.IsNullOrEmpty(value)) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.linker.s3.region = <span class="hljs-string"><span class="hljs-string">"us-east-1"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.linker.s3.region = value; } }</code> </pre> <br>  <b>Unendliche Rekursion</b> <br><br>  <b>PVS-Studio Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3110</a> [CWE-674] Mögliche unendliche Rekursion innerhalb der Eigenschaft 'OnFailure'.  AWSSDK.ElasticMapReduce.Net45 ResizeJobFlowStep.cs 171 <br><br><pre> <code class="cpp hljs">OnFailure? onFailure = null; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OnFailure? OnFailure { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.OnFailure; } <span class="hljs-comment"><span class="hljs-comment">// &lt;= set { this.onFailure = value; } }</span></span></code> </pre> <br>  Ein klassisches Tippfehlerbeispiel, das im <i>get-</i> <i>Accessor der OnFailure-</i> Eigenschaft eine unendliche Rekursion verursacht.  Anstatt den Wert des privaten Felds zurückzugeben, verweist <i>onFailure</i> auf die <i>OnFailure-</i> Eigenschaft.  Korrigierte Option: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OnFailure? OnFailure { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onFailure; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.onFailure = value; } }</code> </pre> <br>  Sie fragen: "Wie hat es funktioniert?"  Bisher auf keinen Fall.  Die Eigenschaft wird nirgendwo verwendet, ist aber nur vorübergehend.  Irgendwann wird jemand damit anfangen und definitiv ein unerwartetes Ergebnis erzielen.  Um solche Tippfehler zu vermeiden, wird empfohlen, keine Bezeichner zu verwenden, die sich nur im Großbuchstaben unterscheiden. <br><br>  Ein weiterer Hinweis zu diesem Entwurf ist die Verwendung eines Bezeichners, der vollständig mit dem Namen des <i>OnFailure-</i> Typs <i>übereinstimmt</i> .  Aus Sicht des Compilers ist dies durchaus akzeptabel, erschwert jedoch die menschliche Wahrnehmung des Codes. <br><br>  Ein weiterer ähnlicher Fehler: <br><br>  <b>PVS-Studio Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3110</a> [CWE-674] Mögliche unendliche Rekursion innerhalb der Eigenschaft 'SSES3'.  AWSSDK.S3.Net45 InventoryEncryption.cs 37 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> SSES3 sSES3; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SSES3 SSES3 { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SSES3; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.SSES3 = value; } }</code> </pre> <br>  Die Situation ist identisch mit der oben beschriebenen.  Nur hier tritt beim Zugriff auf die <i>SSES3-</i> Eigenschaft <i>zum</i> Lesen und Schreiben eine unendliche Rekursion auf.  Korrigierte Option: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> SSES3 SSES3 { get { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sSES3; } <span class="hljs-built_in"><span class="hljs-built_in">set</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.sSES3 = value; } }</code> </pre> <br>  <b>Achtsamkeitstest</b> <br><br>  Das Folgende ist eine Aufgabe eines Programmierers, der die Copy-Paste-Technik verwenden möchte.  Sehen Sie sich an, wie der Code im Visual Studio-Editor aussieht, und versuchen Sie, den Fehler zu finden. <br><br><p><img src="https://habrastorage.org/getpro/habr/post_images/bfa/71b/1ab/bfa71b1ab4af941c43e5349df51b1614.png" alt="Bild 3"></p><br>  <b>PVS-Studio Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3029</a> Die bedingten Ausdrücke der nebeneinander angeordneten if-Anweisungen sind identisch.  Überprüfen Sie die Zeilen: 91, 95. AWSSDK.AppSync.Net45 CreateApiKeyResponseUnmarshaller.cs 91 <br><br>  Ich habe den Hauptteil der <i>UnmarshallException-</i> Methode reduziert und alles Unnötige entfernt.  Jetzt können Sie sehen, dass identische Prüfungen nacheinander folgen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> override AmazonServiceException </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnmarshallException</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errorResponse.Code != null &amp;&amp; errorResponse.Code.Equals(<span class="hljs-string"><span class="hljs-string">"LimitExceededException"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LimitExceededException(errorResponse.Message, innerException, errorResponse.Type, errorResponse.Code, errorResponse.RequestId, statusCode); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (errorResponse.Code != null &amp;&amp; errorResponse.Code.Equals(<span class="hljs-string"><span class="hljs-string">"LimitExceededException"</span></span>)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> LimitExceededException(errorResponse.Message, innerException, errorResponse.Type, errorResponse.Code, errorResponse.RequestId, statusCode); } .... }</code> </pre> <br>  Es scheint, dass der Fehler nicht grob ist - nur eine zusätzliche Überprüfung.  Ein solches Muster kann jedoch häufig auf schwerwiegendere Probleme im Code hinweisen, wenn eine erforderliche Überprüfung nicht durchgeführt wird. <br><br>  Es gibt einige ähnliche Fehler im Code. <br><br>  <b>PVS-Studio-Warnungen:</b> <br><br><ul><li>  V3029 Die bedingten Ausdrücke der nebeneinander angeordneten if-Anweisungen sind identisch.  Überprüfen Sie die Zeilen: 75, 79. AWSSDK.CloudDirectory.Net45 CreateSchemaResponseUnmarshaller.cs 75 </li><li>  V3029 Die bedingten Ausdrücke der nebeneinander angeordneten if-Anweisungen sind identisch.  Überprüfen Sie die Zeilen: 105, 109. AWSSDK.CloudDirectory.Net45 GetSchemaAsJsonResponseUnmarshaller.cs 105 </li><li>  V3029 Die bedingten Ausdrücke der nebeneinander angeordneten if-Anweisungen sind identisch.  Überprüfen Sie die Zeilen: 201, 205. AWSSDK.CodeCommit.Net45 PostCommentForPullRequestResponseUnmarshaller.cs 201 </li><li>  V3029 Die bedingten Ausdrücke der nebeneinander angeordneten if-Anweisungen sind identisch.  Überprüfen Sie die Zeilen: 101, 105. AWSSDK.CognitoIdentityProvider.Net45 VerifySoftwareTokenResponseUnmarshaller.cs 101 </li><li>  V3029 Die bedingten Ausdrücke der nebeneinander angeordneten if-Anweisungen sind identisch.  Überprüfen Sie die Zeilen: 72, 76. AWSSDK.Glue.Net45 UpdateConnectionResponseUnmarshaller.cs 72 </li><li>  V3029 Die bedingten Ausdrücke der nebeneinander angeordneten if-Anweisungen sind identisch.  Überprüfen Sie die Zeilen: 123, 127. AWSSDK.Neptune.Net45 RestoreDBClusterFromSnapshotResponseUnmarshaller.cs 123 </li><li>  V3029 Die bedingten Ausdrücke der nebeneinander angeordneten if-Anweisungen sind identisch.  Überprüfen Sie die Zeilen: 167, 171. AWSSDK.Neptune.Net45 RestoreDBClusterFromSnapshotResponseUnmarshaller.cs 167 </li><li>  V3029 Die bedingten Ausdrücke der nebeneinander angeordneten if-Anweisungen sind identisch.  Überprüfen Sie die Zeilen: 127, 131. AWSSDK.RDS.Net45 RestoreDBClusterFromSnapshotResponseUnmarshaller.cs 127 </li><li>  V3029 Die bedingten Ausdrücke der nebeneinander angeordneten if-Anweisungen sind identisch.  Überprüfen Sie die Zeilen: 171, 175. AWSSDK.RDS.Net45 RestoreDBClusterFromSnapshotResponseUnmarshaller.cs 171 </li><li>  V3029 Die bedingten Ausdrücke der nebeneinander angeordneten if-Anweisungen sind identisch.  Überprüfen Sie die Zeilen: 99, 103. AWSSDK.Rekognition.Net45 RecognizeCelebritiesResponseUnmarshaller.cs 99 </li></ul><br>  <b>Was bist du</b> <br><br>  <b>PVS-Studio Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3062</a> Ein Objekt 'attributeName' wird als Argument für seine eigene Methode verwendet.  Überprüfen Sie das erste tatsächliche Argument der Methode 'Enthält'.  AWSSDK.MobileAnalytics.Net45 CustomEvent.cs 261 <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// &lt;summary&gt; /// Dictionary that stores attribute for this event only. /// &lt;/summary&gt; private Dictionary&lt;string,string&gt; _attributes = new Dictionary&lt;string,string&gt;(); /// &lt;summary&gt; /// Gets the attribute. /// &lt;/summary&gt; /// &lt;param name="attributeName"&gt;Attribute name.&lt;/param&gt; /// &lt;returns&gt;The attribute. Return null of attribute doesn't /// exist.&lt;/returns&gt; public string GetAttribute(string attributeName) { if(string.IsNullOrEmpty(attributeName)) { throw new ArgumentNullException("attributeName"); } string ret = null; lock(_lock) { if(attributeName.Contains(attributeName)) // &lt;= ret = _attributes[attributeName]; } return ret; }</span></span></code> </pre> <br>  Der Analysator hat einen Fehler in der <i>GetAttribute-</i> Methode <i>festgestellt</i> : Die Zeichenfolge wird auf die Tatsache überprüft, dass sie sich selbst enthält.  Aus der Beschreibung der Methode folgt, dass, wenn der Attributname ( <i>Attributname-</i> Schlüssel) gefunden wird (im <i>_attributes-</i> Wörterbuch), der Attributwert zurückgegeben werden sollte, andernfalls <i>null</i> .  Da die Bedingung <i>attributeName.Contains (attributeName)</i> immer wahr ist, wird in der Realität versucht, einen Wert durch einen Schlüssel zurückzugeben, der möglicherweise nicht im Wörterbuch gefunden wird.  Anstatt <i>null zurückzugeben, wird dann eine</i> <i>KeyNotFoundException</i> ausgelöst. <br><br>  Versuchen wir, diesen Code zu beheben.  Schauen Sie sich eine andere Methode an, um besser zu verstehen, wie das geht: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/// &lt;summary&gt; /// Determines whether this instance has attribute the specified /// attributeName. /// &lt;/summary&gt; /// &lt;param name="attributeName"&gt;Attribute name.&lt;/param&gt; /// &lt;returns&gt;Return true if the event has the attribute, else /// false.&lt;/returns&gt; public bool HasAttribute(string attributeName) { if(string.IsNullOrEmpty(attributeName)) { throw new ArgumentNullException("attributeName"); } bool ret = false; lock(_lock) { ret = _attributes.ContainsKey(attributeName); } return ret; }</span></span></code> </pre> <br>  Diese Methode prüft, ob der Attributname ( <i>Attributname-</i> Schlüssel) im <i>_attributes-</i> Wörterbuch vorhanden ist.  <i>Kehren wir</i> zur <i>GetAttribute-</i> Methode zurück und beheben Sie den Fehler: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAttribute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> attributeName)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(attributeName)) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArgumentNullException(<span class="hljs-string"><span class="hljs-string">"attributeName"</span></span>); } <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> ret = null; lock(_lock) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(_attributes.ContainsKey(attributeName)) ret = _attributes[attributeName]; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre> <br>  Jetzt macht die Methode genau das, was in der Beschreibung angegeben ist. <br><br>  Und noch eine kleine Bemerkung zu diesem Codefragment.  Ich habe festgestellt, dass Autoren bei der Arbeit mit dem <i>_attributes-</i> Wörterbuch die <i>Sperre verwenden</i> .  Dies ist natürlich bei Multithread-Zugriff erforderlich, aber das <i>Sperrkonstrukt</i> ist ziemlich langsam und umständlich.  In diesem Fall ist es möglicherweise bequemer, anstelle von <i>Dictionary</i> eine thread-sichere Version des Wörterbuchs zu verwenden - <i>ConcurrentDictionary</i> .  Dann verschwindet die Notwendigkeit einer <i>Sperre</i> .  Obwohl ich vielleicht keine Funktionen des Projekts kenne. <br><br>  <b>Verdächtiges Verhalten</b> <br><br>  <b>PVS-Studio Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3063</a> [CWE-571] Ein Teil des bedingten Ausdrucks ist immer wahr, wenn er ausgewertet wird: string.IsNullOrEmpty (inferredIndexName).  AWSSDK.DynamoDBv2.PCL ContextInternal.cs 802 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetQueryIndexName</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> inferredIndexName = null; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(specifiedIndexName) &amp;&amp; indexNames.Count == <span class="hljs-number"><span class="hljs-number">1</span></span>) { inferredIndexName = indexNames[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (indexNames.Contains(specifiedIndexName, StringComparer.Ordinal)) { inferredIndexName = specifiedIndexName; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(inferredIndexName) &amp;&amp; <span class="hljs-comment"><span class="hljs-comment">// &lt;= indexNames.Count &gt; 0) throw new InvalidOperationException("Local Secondary Index range key conditions are used but no index could be inferred from model. Specified index name = " + specifiedIndexName); .... }</span></span></code> </pre> <br>  Der Analysator hat die <i>Prüfung string.IsNullOrEmpty (inferredIndexName)</i> alarmiert.  In der Tat wird der Zeichenfolge <i>inferredIndexName</i> <i>null</i> zugewiesen, dann wird der Wert dieser Variablen nirgendwo geändert und aus irgendeinem Grund auf <i>null</i> oder eine leere Zeichenfolge überprüft.  Es sieht verdächtig aus.  Schauen wir uns das angegebene Code-Snippet genauer an.  Ich habe es bewusst nicht reduziert, um die Situation besser zu verstehen.  In der ersten <i>if-Anweisung</i> (und auch in der nächsten) wird die Variable VariableIndexName auf irgendeine Weise überprüft.  Abhängig vom Ergebnis der Überprüfungen erhält die Variable <i>inferredIndexName</i> einen neuen Wert.  Achten wir nun auf die dritte <i>if-Anweisung</i> .  Der Hauptteil dieser Anweisung ( <i>Auslösen</i> einer Ausnahme) wird ausgeführt, wenn <i>indexNames.Count&gt; 0 ist</i> , da der erste Teil der Bedingung <i>string.IsNullOrEmpty (inferredIndexName)</i> ist.  Möglicherweise sind die <i>angegebenen</i> VariablenIndexName und <i>inferredIndexName</i> einfach verwirrt.  Oder die dritte Prüfung sollte ohne <i>andere sein</i> und eine eigenständige <i>if-Anweisung darstellen</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(specifiedIndexName) &amp;&amp; indexNames.Count == <span class="hljs-number"><span class="hljs-number">1</span></span>) { inferredIndexName = indexNames[<span class="hljs-number"><span class="hljs-number">0</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (indexNames.Contains(specifiedIndexName, StringComparer.Ordinal)) { inferredIndexName = specifiedIndexName; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.IsNullOrEmpty(inferredIndexName) &amp;&amp; indexNames.Count &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException(....);</code> </pre> <br>  In diesem Fall ist es schwierig, eine eindeutige Antwort auf die Optionen zum Korrigieren dieses Codes zu geben.  Aber es ist definitiv notwendig, dass der Autor es inspiziert. <br><br>  <b>NullReferenceException</b> <br><br>  <b>PVS-Studio Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3095</a> [CWE-476] Das Objekt 'conditionValues' wurde verwendet, bevor es gegen null verifiziert wurde.  Überprüfen Sie die Zeilen: 228, 238. AWSSDK.Core.Net45 JsonPolicyWriter.cs 228 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeConditions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (....) { IList&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; conditionValues = keyEntry.Value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conditionValues.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-comment"><span class="hljs-comment">// &lt;= continue; .... if (conditionValues != null &amp;&amp; conditionValues.Count != 0) { .... } .... } }</span></span></code> </pre> <br>  Klassiker des Genres.  Die Variable <i>conditionValues ​​wird</i> verwendet, ohne vorher nach <i>null</i> zu <i>suchen</i> .  Darüber hinaus wird im Code eine solche Überprüfung durchgeführt, aber es ist zu spät.  :) :) <br><br>  Der Code kann wie folgt festgelegt werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeConditions</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... foreach (....) { IList&lt;<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; conditionValues = keyEntry.Value; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conditionValues != null &amp;&amp; conditionValues.Count == <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (conditionValues != null &amp;&amp; conditionValues.Count != <span class="hljs-number"><span class="hljs-number">0</span></span>) { .... } .... } }</code> </pre> <br>  Einige weitere ähnliche Fehler wurden im Code gefunden. <br><br>  <b>PVS-Studio-Warnungen:</b> <br><br><ul><li>  V3095 [CWE-476] Das Objekt 'ts.Listeners' wurde verwendet, bevor es gegen null verifiziert wurde.  Überprüfen Sie die Zeilen: 140, 143. AWSSDK.Core.Net45 Logger.Diagnostic.cs 140 </li><li>  V3095 [CWE-476] Das Objekt 'obj' wurde verwendet, bevor es gegen null verifiziert wurde.  Überprüfen Sie die Zeilen: 743, 745. AWSSDK.Core.Net45 JsonMapper.cs 743 </li><li>  V3095 [CWE-476] Das Objekt 'multipartUploadMultipartUploadpartsList' wurde verwendet, bevor es gegen null verifiziert wurde.  Überprüfen Sie die Zeilen: 65, 67. AWSSDK.S3.Net45 CompleteMultipartUploadRequestMarshaller.cs 65 </li></ul><br>  Die folgende Warnung hat eine sehr ähnliche Bedeutung, aber die Situation ist umgekehrt wie oben beschrieben. <br><br>  <b>PVS-Studio Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3125</a> [CWE-476] Das ' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">state'</a> -Objekt wurde verwendet, nachdem es gegen null verifiziert wurde.  Überprüfen Sie die Zeilen: 139, 127. AWSSDK.Core.Net45 RefreshingAWSCredentials.cs 139 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateToGeneratedCredentials</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( CredentialsRefreshState state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> errorMessage; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ShouldUpdate) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == null) errorMessage = <span class="hljs-string"><span class="hljs-string">"Unable to generate temporary credentials"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AmazonClientException(errorMessage); } state.Expiration -= PreemptExpiryTime; <span class="hljs-comment"><span class="hljs-comment">// &lt;= .... }</span></span></code> </pre> <br>  Eines der Codefragmente enthält eine Überprüfung der Statusvariablen auf <i>null</i> .  Weiter <i>unten</i> im Code wird die Statusvariable verwendet, um das <i>PreemptExpiryTime-</i> Ereignis <i>abzubestellen</i> , während die Prüfung auf <i>Null</i> nicht mehr durchgeführt wird und eine <i>NullReferenceException möglich ist</i> .  Sicherere Codeoption: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UpdateToGeneratedCredentials</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( CredentialsRefreshState state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> errorMessage; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ShouldUpdate) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state == null) errorMessage = <span class="hljs-string"><span class="hljs-string">"Unable to generate temporary credentials"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> .... <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> AmazonClientException(errorMessage); } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (state != null) state.Expiration -= PreemptExpiryTime; .... }</code> </pre> <br>  Es gibt andere ähnliche Fehler im Code. <br><br>  <b>PVS-Studio-Warnungen:</b> <br><br><ul><li>  V3125 [CWE-476] Das Objekt 'wrapRequest.Content' wurde verwendet, nachdem es gegen null verifiziert wurde.  Überprüfen Sie die Zeilen: 395, 383. AWSSDK.Core.Net45 HttpHandler.cs 395 </li><li>  V3125 [CWE-476] Das Objekt 'datasetUpdates' wurde verwendet, nachdem es gegen null verifiziert wurde.  Überprüfen Sie die Zeilen: 477, 437. AWSSDK.CognitoSync.Net45 Dataset.cs 477 </li><li>  V3125 [CWE-476] Das Objekt 'cORSConfigurationCORSConfigurationcORSRulesListValue' wurde verwendet, nachdem es gegen null verifiziert wurde.  Überprüfen Sie die Zeilen: 125, 111. AWSSDK.S3.Net45 PutCORSConfigurationRequestMarshaller.cs 125 </li><li>  V3125 [CWE-476] Das Objekt 'lifecycleConfigurationLifecycleConfigurationrulesListValue' wurde verwendet, nachdem es gegen null verifiziert wurde.  Überprüfen Sie die Zeilen: 157, 68. AWSSDK.S3.Net45 PutLifecycleConfigurationRequestMarshaller.cs 157 </li><li>  V3125 [CWE-476] Das Objekt 'this.Key' wurde verwendet, nachdem es gegen null verifiziert wurde.  Überprüfen Sie die Zeilen: 199, 183. AWSSDK.S3.Net45 S3PostUploadRequest.cs 199 </li></ul><br>  <b>Unbestrittene Realität</b> <br><br>  <b>PVS-Studio Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3009</a> [CWE-393] Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zurückgibt.  AWSSDK.Core.Net45 Lexer.cs 651 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State19</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'"'</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-string"><span class="hljs-string">'\\'</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">continue</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Die Methode gibt immer <i>true zurück</i> .  Mal sehen, wie kritisch dies für den aufrufenden Code ist.  Ich habe die Verwendung der <i>State19-</i> Methode verfolgt.  Er beteiligt sich am Füllen des Arrays von <i>fsm_handler_table-Handlern</i> zusammen mit anderen ähnlichen Methoden (es gibt 28 von ihnen mit Namen von <i>State1</i> bis <i>State28</i> ).  Hierbei ist zu beachten, dass neben <i>State19</i> auch Warnungen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3009</a> [CWE-393] für einige andere Handler ausgegeben wurden.  Dies sind die Handler: <i>State23, State26, State27, State28</i> .  Vom Analysator für sie ausgegebene Warnungen: <br><br><ul><li>  V3009 [CWE-393] Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zurückgibt.  AWSSDK.Core.Net45 Lexer.cs 752 </li><li>  V3009 [CWE-393] Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zurückgibt.  AWSSDK.Core.Net45 Lexer.cs 810 </li><li>  V3009 [CWE-393] Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zurückgibt.  AWSSDK.Core.Net45 Lexer.cs 822 </li><li>  V3009 [CWE-393] Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zurückgibt.  AWSSDK.Core.Net45 Lexer.cs 834 </li></ul><br>  So sieht die Deklaration und Initialisierung des Handler-Arrays aus: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> StateHandler[] fsm_handler_table; .... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PopulateFsmTables</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ fsm_handler_table = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StateHandler[<span class="hljs-number"><span class="hljs-number">28</span></span>] { State1, State2, .... State19, .... State23, .... State26, State27, State28 };</code> </pre> <br>  Der Vollständigkeit <i>halber</i> sehen wir uns den Code eines der Handler an, bei dem der Analysator keine Beschwerden hatte, z. B. <i>State2</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">State2</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (....) { .... <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } }</code> </pre> <br>  Und so heißen die Handler: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NextToken</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { handler = fsm_handler_table[state - <span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (! handler (fsm_context)) <span class="hljs-comment"><span class="hljs-comment">// &lt;= throw new JsonException (input_char); .... } .... }</span></span></code> </pre> <br>  Wie Sie sehen können, wird eine Ausnahme ausgelöst, wenn <i>false</i> zurückgegeben wird.  In unserem Fall wird dies für die Handler <i>State19, State23, State26, State27</i> und <i>State28</i> niemals passieren.  Es sieht verdächtig aus.  Auf der anderen Seite haben bis zu fünf Handler ein ähnliches Verhalten (geben immer <i>true zurück</i> ). Vielleicht war dies beabsichtigt und nicht das Ergebnis eines Tippfehlers. <br><br>  Warum habe ich mich so ausführlich mit all dem befasst?  Diese Situation ist sehr bezeichnend in dem Sinne, dass ein statischer Analysator oft nur ein verdächtiges Design anzeigen kann.  Und selbst eine Person (keine Maschine), die nicht über ausreichende Kenntnisse über das Projekt verfügt und Zeit damit verbracht hat, den Code zu studieren, kann immer noch keine erschöpfende Antwort auf das Vorhandensein eines Fehlers geben.  Der Code muss vom Entwickler studiert werden. <br><br>  <b>Sinnlose Schecks</b> <br><br>  <b>PVS-Studio Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3022</a> [CWE-571] Der Ausdruck 'doLog' ist immer wahr.  AWSSDK.Core.Net45 StoredProfileAWSCredentials.cs 235 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ValidCredentialsExistInSharedFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... var doLog = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { doLog = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span> (InvalidDataException) { doLog = <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (doLog) <span class="hljs-comment"><span class="hljs-comment">// &lt;= { .... } .... }</span></span></code> </pre> <br>  <i>Achten Sie auf die</i> Variable <i>doLog</i> .  Nach der Initialisierung mit <i>false</i> wird diese Variable im Code in allen Fällen <i>true</i> .  Die <i>if (doLog) -Prüfung</i> ist also immer wahr.  Möglicherweise gab es früher in dieser Methode einen Zweig, in dem der <i>doLog-</i> Variablen kein Wert zugewiesen wurde. <i>Zum</i> Zeitpunkt der Überprüfung konnte sie dann den <i>falschen</i> Wert enthalten, der während der Initialisierung erhalten wurde.  Aber jetzt gibt es keinen solchen Zweig. <br><br>  Ein weiterer ähnlicher Fehler: <br><br>  <b>PVS-Studio-</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warnung</a> <b>:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3022</a> Ausdruck '! Ergebnis' ist immer falsch.  AWSSDK.CognitoSync.PCL SQLiteLocalStorage.cs 353 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PutValue</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> result = PutValueHelper(....); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!result) &lt;= { _logger.DebugFormat(<span class="hljs-string"><span class="hljs-string">"{0}"</span></span>, @<span class="hljs-string"><span class="hljs-string">"Cognito Sync - SQLiteStorage - Put Value Failed"</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { UpdateLastModifiedTimestamp(....); } .... }</code> </pre> <br>  Der Analysator behauptet, dass der Wert der <i>Ergebnisvariablen</i> immer <i>wahr ist</i> .  Dies ist nur möglich, wenn die <i>PutValueHelper-</i> Methode immer <i>true</i> <i>zurückgibt</i> .  Schauen Sie sich diese Methode an: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PutValueHelper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(....)</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (....)) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (record == null) { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } }</code> </pre> <br>  In der Tat wird die Methode unter allen Bedingungen <i>true zurückgeben</i> .  Darüber hinaus gab der Analysator eine Warnung für diese Methode aus.  <b>PVS-Studio Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3009</a> [CWE-393] Es ist seltsam, dass diese Methode immer ein und denselben Wert von 'true' zurückgibt.  SQLiteLocalStorage.cs 1016 <br><br>  Ich habe diese Warnung absichtlich nicht früher zitiert, als ich andere Fehler von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3009</a> in Betracht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">gezogen habe</a> , aber ich habe sie für diesen Fall gespeichert.  Somit hat der Analysator zu Recht den Fehler <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3022</a> im aufrufenden Code angezeigt. <br><br>  <b>Kopieren-Einfügen.</b>  <b>Wieder</b> <br><br>  <b>PVS-Studio Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3001</a> Links und rechts vom '||' befinden sich identische Unterausdrücke 'this.token == JsonToken.String'.  Betreiber.  AWSSDK.Core.Net45 JsonReader.cs 343 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Read</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ( (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.token == JsonToken.ObjectEnd || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.token == JsonToken.ArrayEnd || <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.token == JsonToken.String || <span class="hljs-comment"><span class="hljs-comment">// &lt;= this.token == JsonToken.Boolean || this.token == JsonToken.Double || this.token == JsonToken.Int || this.token == JsonToken.UInt || this.token == JsonToken.Long || this.token == JsonToken.ULong || this.token == JsonToken.Null || this.token == JsonToken.String // &lt;= )) { .... } .... }</span></span></code> </pre> <br>  Vergleichen Sie das Feld <i>this.token</i> <i>doppelt</i> mit dem Wert <i>JsonToken.String</i> der <i>JsonToken-</i> Aufzählung.  Wahrscheinlich sollte einer der Vergleiche einen anderen Aufzählungswert enthalten.  Wenn ja, wurde ein schwerwiegender Fehler gemacht. <br><br>  <b>Refactoring + Nachlässigkeit?</b> <br><br>  <b>PVS-Studio Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3025</a> [CWE-685] Falsches Format.  Beim Aufrufen der Funktion 'Format' wird eine andere Anzahl von Formatelementen erwartet.  Nicht verwendete Argumente: AWSConfigs.AWSRegionKey.  AWSSDK.Core.Net45 AWSRegion.cs 116 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InstanceProfileAWSRegion</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (region == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException( <span class="hljs-built_in"><span class="hljs-built_in">string</span></span>.Format(CultureInfo.InvariantCulture, <span class="hljs-string"><span class="hljs-string">"EC2 instance metadata was not available or did not contain region information."</span></span>, AWSConfigs.AWSRegionKey)); } .... }</code> </pre> <br>  Wahrscheinlich enthielt die <i>Formatzeichenfolge</i> für die Methode <i>string.Format</i> zuvor den Ausgabespezifizierer <i>{0}</i> , für den das Argument <i>AWSConfigs.AWSRegionKey</i> festgelegt wurde.  Dann wurde die Zeile geändert, der Bezeichner war weg, aber sie haben vergessen, das Argument zu löschen.  Das obige Codefragment funktioniert fehlerfrei (eine Ausnahme würde im umgekehrten Fall ausgelöst - ein Bezeichner ohne Argument), sieht aber hässlich aus.  Der Code sollte wie folgt festgelegt werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (region == null) { <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> InvalidOperationException( <span class="hljs-string"><span class="hljs-string">"EC2 instance metadata was not available or did not contain region information."</span></span>); }</code> </pre> <br>  <b>Unsicher</b> <br><br>  <b>PVS-Studio Warnung:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3083</a> [CWE-367] Unsicherer Aufruf des Ereignisses 'mOnSyncSuccess', NullReferenceException ist möglich.  Überlegen Sie, ob Sie einer lokalen Variablen ein Ereignis zuweisen möchten, bevor Sie sie aufrufen.  AWSSDK.CognitoSync.PCL Dataset.cs 827 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FireSyncSuccessEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Record&gt; records)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (mOnSyncSuccess != null) { mOnSyncSuccess(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SyncSuccessEventArgs(records)); } }</code> </pre> <br>  Eine ziemlich häufige Situation eines unsicheren Aufrufs des Ereignishandlers.  Zwischen dem Überprüfen der Variablen <i>mOnSyncSuccess</i> auf <i>null</i> und dem Aufrufen des <i>Handlers</i> kann ein Ereignis abgemeldet werden, und sein Wert wird Null.  Die Wahrscheinlichkeit eines solchen Szenarios ist gering, aber es ist immer noch besser, den Code sicherer zu machen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">protected</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FireSyncSuccessEvent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(List&lt;Record&gt; records)</span></span></span><span class="hljs-function"> </span></span>{ mOnSyncSuccess?.Invoke(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SyncSuccessEventArgs(records)); }</code> </pre> <br>  Es gibt andere ähnliche Fehler im Code. <br><br>  <b>PVS-Studio-Warnungen:</b> <br><br><ul><li>  V3083 [CWE-367] Unsicherer Aufruf des Ereignisses 'mOnSyncFailure', NullReferenceException ist möglich.  Überlegen Sie, ob Sie einer lokalen Variablen ein Ereignis zuweisen möchten, bevor Sie sie aufrufen.  AWSSDK.CognitoSync.PCL Dataset.cs 839 </li><li>  V3083 [CWE-367] Unsicherer Aufruf des Ereignisses, NullReferenceException ist möglich.  Überlegen Sie, ob Sie einer lokalen Variablen ein Ereignis zuweisen möchten, bevor Sie sie aufrufen.  AWSSDK.Core.PCL AmazonServiceClient.cs 332 </li><li>  V3083 [CWE-367] Unsicherer Aufruf des Ereignisses, NullReferenceException ist möglich.  Überlegen Sie, ob Sie einer lokalen Variablen ein Ereignis zuweisen möchten, bevor Sie sie aufrufen.  AWSSDK.Core.PCL AmazonServiceClient.cs 344 </li><li>  V3083 [CWE-367] Unsicherer Aufruf des Ereignisses, NullReferenceException ist möglich.  Überlegen Sie, ob Sie einer lokalen Variablen ein Ereignis zuweisen möchten, bevor Sie sie aufrufen.  AWSSDK.Core.PCL AmazonServiceClient.cs 357 </li><li>  V3083 [CWE-367] Unsicherer Aufruf des Ereignisses 'mExceptionEvent', NullReferenceException ist möglich.  Überlegen Sie, ob Sie einer lokalen Variablen ein Ereignis zuweisen möchten, bevor Sie sie aufrufen.  AWSSDK.Core.PCL AmazonServiceClient.cs 366 </li><li>  V3083 [CWE-367] Unsicherer Aufruf des Ereignisses, NullReferenceException ist möglich.  Überlegen Sie, ob Sie einer lokalen Variablen ein Ereignis zuweisen möchten, bevor Sie sie aufrufen.  AWSSDK.Core.PCL AmazonWebServiceRequest.cs 78 </li><li>  V3083 [CWE-367] Unsicherer Aufruf des Ereignisses 'OnRead', NullReferenceException ist möglich.  Überlegen Sie, ob Sie einer lokalen Variablen ein Ereignis zuweisen möchten, bevor Sie sie aufrufen.  AWSSDK.Core.PCL EventStream.cs 97 </li><li>  V3083 [CWE-367] Unsicherer Aufruf des Ereignisses, NullReferenceException ist möglich.  Überlegen Sie, ob Sie einer lokalen Variablen ein Ereignis zuweisen möchten, bevor Sie sie aufrufen.  AWSSDK.Core.Android NetworkReachability.cs 57 </li><li>  V3083 [CWE-367] Unsicherer Aufruf des Ereignisses, NullReferenceException ist möglich.  Überlegen Sie, ob Sie einer lokalen Variablen ein Ereignis zuweisen möchten, bevor Sie sie aufrufen.  AWSSDK.Core.Android NetworkReachability.cs 94 </li><li>  V3083 [CWE-367] Unsicherer Aufruf des Ereignisses, NullReferenceException ist möglich.  Überlegen Sie, ob Sie einer lokalen Variablen ein Ereignis zuweisen möchten, bevor Sie sie aufrufen.  AWSSDK.Core.iOS NetworkReachability.cs 54 </li></ul><br>  <b>Unvollendete Klasse</b> <br><br>  <b>PVS-Studio-</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warnung</a> <b>:</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V3126 Der</a> Typ 'JsonData', der die IEquatable &lt;T&gt; -Schnittstelle implementiert, überschreibt die 'GetHashCode'-Methode nicht.  AWSSDK.Core.Net45 JsonData.cs 26 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonData</span></span></span><span class="hljs-class"> :</span></span> IJsonWrapper, IEquatable&lt;JsonData&gt; { .... }</code> </pre> <br>  Die <i>JsonData-</i> Klasse enthält viel Code, daher habe ich ihn nicht vollständig angegeben und mich darauf beschränkt, ihn nur zu deklarieren.  Diese Klasse enthält wirklich keine überschriebene <i>GetHashCode-</i> Methode, was unsicher ist, da dies zu fehlerhaftem Verhalten führen kann, wenn der Typ <i>JsonData</i> beispielsweise für Sammlungen verwendet wird.  Derzeit gibt es wahrscheinlich kein Problem, aber die Strategie für die Verwendung dieses Typs kann sich in Zukunft ändern.  Dieser Fehler wird in der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Dokumentation</a> ausführlicher beschrieben. <br><br>  <b>Fazit</b> <br><br>  Das sind all die interessanten Fehler, die ich im AWS SDK für .NET-Code mithilfe des statischen Analysators PVS-Studio festgestellt habe.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich betone noch einmal die Qualität des Projekts. </font><font style="vertical-align: inherit;">Ich habe eine sehr kleine Anzahl von Fehlern für 5 Millionen Codezeilen gefunden. </font><font style="vertical-align: inherit;">Obwohl eine gründlichere Analyse der ausgegebenen Warnungen es mir wahrscheinlich ermöglichen würde, dieser Liste einige weitere Fehler hinzuzufügen. </font><font style="vertical-align: inherit;">Es ist aber auch sehr wahrscheinlich, dass ich einige der beschriebenen Warnungen vergeblich auf Fehler zurückgeführt habe. </font><font style="vertical-align: inherit;">In diesem Fall trifft immer nur der Entwickler, der sich im Kontext des zu überprüfenden Codes befindet, eindeutige Schlussfolgerungen.</font></font><br><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/ts/z9/km/tsz9kmyjtteajhd4x1au60rsrvq.png" align="left"></a> </p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie diesen Artikel einem englischsprachigen Publikum zugänglich machen möchten, verwenden Sie bitte den Link zur Übersetzung: Sergey Khrenov. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Suchen nach Fehlern im Amazon Web Services SDK-Quellcode für .NET</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de437516/">https://habr.com/ru/post/de437516/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de437504/index.html">Winzige Komponenten: Was könnte schief gehen? Wir verwenden das Prinzip der alleinigen Verantwortung</a></li>
<li><a href="../de437508/index.html">CVE-2019-6111 und andere SCP-Schwachstellen</a></li>
<li><a href="../de437510/index.html">Was passiert, wenn Sie SMS senden?</a></li>
<li><a href="../de437512/index.html">Was sind reine Funktionen in JavaScript?</a></li>
<li><a href="../de437514/index.html">Suchen nach Fehlern im Amazon Web Services SDK-Quellcode für .NET</a></li>
<li><a href="../de437518/index.html">Käfer greifen an</a></li>
<li><a href="../de437520/index.html">„Mein Licht ist ein Spiegel! - Sagen Sie, zeigen Sie mir mein Dual ... ": Entwerfen Sie einen guten Rahmen und erhalten Sie den zweiten als Geschenk</a></li>
<li><a href="../de437522/index.html">Kolonie. Kapitel 22: Endgültige Entscheidung</a></li>
<li><a href="../de437524/index.html">Erstellen Sie eine einfache Schach-KI: 5 einfache Schritte</a></li>
<li><a href="../de437526/index.html">Volumetrisches Rendern in WebGL</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>