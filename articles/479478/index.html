<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèæ‚Äçüåæ üèôÔ∏è üë©üèΩ‚ÄçüöÄ Complemento Java sin dolor üë©üèæ‚Äçüé® üï¥üèæ ‚ôøÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En este art√≠culo, me gustar√≠a decirle c√≥mo crear r√°pida y f√°cilmente un marco de aplicaci√≥n Java con soporte para carga din√°mica de complementos. El l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Complemento Java sin dolor</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/479478/">  En este art√≠culo, me gustar√≠a decirle c√≥mo crear r√°pida y f√°cilmente un marco de aplicaci√≥n Java con soporte para carga din√°mica de complementos.  El lector probablemente pensar√° de inmediato que este problema ya se ha resuelto durante mucho tiempo, y simplemente puede usar marcos ya preparados o escribir su cargador de clases, pero nada de esto ser√° necesario en la soluci√≥n que propongo: <br><br><ul><li>  No necesitamos bibliotecas o marcos especiales ( <a href="https://www.youtube.com/watch%3Fv%3DE3A6Z02TIjg">OSGi</a> , Guice, etc.) </li><li>  No utilizaremos el an√°lisis de bytecode con ASM y bibliotecas similares. </li><li>  No escribiremos nuestro cargador de clases. </li><li>  No usaremos reflexiones y anotaciones. </li><li>  No es necesario preocuparse por el classpath para encontrar complementos.  No tocaremos el classpath en absoluto. </li><li> Adem√°s, no utilizaremos XML, YAML ni ning√∫n otro lenguaje declarativo para describir puntos de extensi√≥n (puntos de extensi√≥n en complementos). </li></ul><br>  Sin embargo, todav√≠a hay un requisito: dicha soluci√≥n solo funcionar√° en Java 9 o superior.  Porque se basar√° en <a href="https://www.youtube.com/watch%3Fv%3DJ1fHBhFvmco">m√≥dulos y servicios</a> . <br><a name="habracut"></a><br>  Entonces comencemos.  Formulamos el problema m√°s espec√≠ficamente: <br><blockquote> Debe implementar un marco de aplicaci√≥n m√≠nimo, que al inicio cargar√° los complementos del usuario desde la carpeta de <code>plugins</code> . </blockquote><br>  Es decir, la aplicaci√≥n ensamblada deber√≠a verse as√≠: <br><br><pre> <code class="bash hljs">plugin-app/ plugins/ plugin1.jar plugin2.jar ... core.jar ‚Ä¶</code> </pre> <br>  Comencemos con el m√≥dulo <code>core</code> .  Este m√≥dulo es el n√∫cleo de nuestra aplicaci√≥n, es decir, es nuestro marco. <br><br><div class="spoiler">  <b class="spoiler_title">Para aquellos que valoran el tiempo, el proyecto terminado est√° disponible en GitHub.</b>  <b class="spoiler_title">Instrucciones de montaje.</b> <div class="spoiler_text">  <a href="https://github.com/orionll/plugin-app">Enlace</a> <br><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/orionll/plugin-app <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> plugin-app mvn verify <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> core/target java --module-path core-1.0-SNAPSHOT.jar --module core</code> </pre> </div></div><br>  Cree los siguientes 4 archivos Java en el m√≥dulo: <br><br><pre> <code class="bash hljs">core/ src/main/java/ org/example/pluginapp/core/ IService.java BasicService.java Main.java module-info.java</code> </pre> <br>  El primer archivo, <code>IService.java</code> , es el archivo que describe nuestro punto de extensi√≥n.  Otros complementos podr√°n entonces contribuir a este punto de expansi√≥n ("contribuir").  Este es el principio est√°ndar para crear aplicaciones de complemento, que se denomina <a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">principio de inversi√≥n de dependencia</a> (Inversi√≥n de dependencia).  Este principio se basa en el hecho de que el n√∫cleo no depende de clases espec√≠ficas, sino de interfaces. <br><br>  Le di al punto de extensi√≥n el nombre abstracto <code>IService</code> , ya que ahora estoy demostrando un concepto exclusivamente.  En realidad, puede ser cualquier punto de extensi√≥n espec√≠fico, por ejemplo, si est√° escribiendo un editor gr√°fico, puede ser el efecto del procesamiento de im√°genes, por ejemplo, <code>IEffectProvider</code> , <code>IEffectContribution</code> o algo m√°s, dependiendo de c√≥mo prefiera nombrar los puntos de extensi√≥n.  Al mismo tiempo, la aplicaci√≥n en s√≠ contendr√° un conjunto b√°sico de efectos, y los desarrolladores de terceros podr√°n escribir efectos adicionales m√°s sofisticados y entregarlos en forma de complementos.  El usuario solo necesita poner estos efectos en la carpeta de <code>plugins</code> y reiniciar la aplicaci√≥n. <br><br>  El archivo <code>IService.java</code> es el siguiente: <br><br><pre> <code class="java hljs">‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> List&lt;IService&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getServices</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ModuleLayer layer)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ServiceLoader .load(layer, IService.class) .stream() .map(Provider::get) .collect(Collectors.toList()); } }</code> </pre> <br>  Por lo tanto, <code>IService</code> es solo una interfaz que hace un trabajo abstracto <code>doJob()</code> (repito, los detalles no son importantes, en realidad ser√° algo concreto). <br><br>  Tambi√©n preste atenci√≥n al segundo m√©todo <code>getServices()</code> .  Este m√©todo devuelve todas las implementaciones de la interfaz <code>IService</code> que encontr√≥ en esta capa de m√≥dulo y sus padres.  Hablaremos de esto con m√°s detalle m√°s adelante. <br><br>  El segundo archivo, <code>BasicService.java</code> , es la implementaci√≥n base de la interfaz <code>IService</code> .  Siempre estar√° presente, incluso si no hay complementos en la aplicaci√≥n.  En otras palabras, el <code>core</code> no es solo el n√∫cleo, sino tambi√©n al mismo tiempo un complemento para s√≠ mismo, que siempre se cargar√°.  El archivo <code>BasicService.java</code> ve as√≠: <br><br><pre> <code class="java hljs">‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BasicService</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Basic service"</span></span>); } }</code> </pre> <br>  Para simplificar, <code>doJob()</code> simplemente imprime la cadena <code>"Basic service"</code> y eso es todo. <br><br>  Por lo tanto, en este momento tenemos la siguiente imagen: <br><br><img src="https://habrastorage.org/webt/du/0f/fd/du0ffdkzy6bqmyc6rvqj6p-jw7w.png"><br><br>  El tercer archivo, <code>Main.java</code> , es donde se implementa el m√©todo <code>main()</code> .  Hay un poco de magia en √©l, para comprender cu√°l necesita saber qu√© es una capa de m√≥dulo. <br><br><h2>  Acerca de las capas del m√≥dulo </h2><br>  Cuando Java inicia la aplicaci√≥n, todos los m√≥dulos de plataforma + m√≥dulos enumerados en el argumento <code>--module-path</code> (y tambi√©n <code>classpath</code> , si los hay) caen en la llamada capa de <code>Boot</code> .  En nuestro caso, si compilamos el m√≥dulo core.jar y ejecutamos <code>java --module-path core.jar --module core</code> desde la l√≠nea de comandos, entonces al menos los m√≥dulos <code>java.base</code> y <code>core</code> estar√°n en la capa de <code>Boot</code> : <br><br><img src="https://habrastorage.org/webt/z5/ar/n-/z5arn-jtfurxwqjja-fxrbdfjbu.png"><br><br>  La capa de <code>Boot</code> siempre est√° presente en cualquier aplicaci√≥n Java, y esta es la configuraci√≥n m√°s peque√±a posible.  La mayor√≠a de las aplicaciones existen en una sola capa de m√≥dulos.  Sin embargo, en nuestro caso, queremos hacer una carga din√°mica de complementos desde la carpeta de <code>plugins</code> .  Podr√≠amos obligar al usuario a corregir la l√≠nea de inicio de la aplicaci√≥n para que √©l mismo agregue los complementos necesarios a <code>--module-path</code> , pero esta no ser√° la mejor soluci√≥n.  Especialmente aquellas personas que no son programadores y no entienden por qu√© necesitan escalar en alg√∫n lugar y arreglar algo para algo tan simple. <br><br>  Afortunadamente, hay una soluci√≥n: Java le permite crear sus propias capas de m√≥dulos en tiempo de ejecuci√≥n, que cargar√°n los m√≥dulos desde el lugar que necesitamos.  Para nuestros prop√≥sitos, una nueva capa para complementos ser√° suficiente, que tendr√° una capa de <code>Boot</code> como padre (cualquier capa debe tener un padre): <br><br><img src="https://habrastorage.org/webt/1-/yd/5i/1-yd5ikax42qfadybbu1uqbnkgo.png"><br><br>  El hecho de que la capa de complemento tenga la capa de <code>Boot</code> como principal significa que los m√≥dulos de la capa de complemento pueden hacer referencia a los m√≥dulos de la capa de <code>Boot</code> , pero no al rev√©s. <br><br>  Entonces, sabiendo ahora qu√© es una capa de m√≥dulo, finalmente puede ver el contenido del archivo <code>Main.java</code> : <br><br><pre> <code class="java hljs">‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Main</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String[] args)</span></span></span><span class="hljs-function"> </span></span>{ Path pluginsDir = Paths.get(<span class="hljs-string"><span class="hljs-string">"plugins"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//      plugins ModuleFinder pluginsFinder = ModuleFinder.of(pluginsDir); //  ModuleFinder      plugins       List&lt;String&gt; plugins = pluginsFinder .findAll() .stream() .map(ModuleReference::descriptor) .map(ModuleDescriptor::name) .collect(Collectors.toList()); //  ,      (   ) Configuration pluginsConfiguration = ModuleLayer .boot() .configuration() .resolve(pluginsFinder, ModuleFinder.of(), plugins); //      ModuleLayer layer = ModuleLayer .boot() .defineModulesWithOneLoader(pluginsConfiguration, ClassLoader.getSystemClassLoader()); //     IService       Boot List&lt;IService&gt; services = IService.getServices(layer); for (IService service : services) { service.doJob(); } } }</span></span></code> </pre> <br>  Si es la primera vez que mira este c√≥digo, puede parecer muy complicado, pero es una sensaci√≥n falsa debido a la gran cantidad de nuevas clases desconocidas.  Si comprende un poco sobre el significado de las <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/module/ModuleFinder.html">clases ModuleFinder</a> , <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/module/Configuration.html">Configuration</a> y <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/lang/ModuleLayer.html">ModuleLayer</a> , entonces todo encaja.  Y adem√°s, ¬°solo hay unas pocas docenas de l√≠neas!  Esta es toda la l√≥gica que se escribe una vez. <br><br><h2>  Descriptor del m√≥dulo </h2><br>  Hay un archivo m√°s (cuarto) que no consideramos: <code>module-info.java</code> .  Este es el archivo m√°s corto que contiene la declaraci√≥n de nuestro m√≥dulo y una descripci√≥n de los servicios (puntos de extensi√≥n): <br><br><pre> <code class="java hljs">‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> core { <span class="hljs-keyword"><span class="hljs-keyword">exports</span></span> org.example.pluginapp.core; uses IService; provides IService with BasicService; }</code> </pre> <br>  El significado de las l√≠neas de este archivo deber√≠a ser obvio: <br><br><ul><li>  En primer lugar, el m√≥dulo exporta el paquete <code>org.example.pluginapp.core</code> que los complementos puedan heredar de la interfaz <code>IService</code> (de lo contrario, <code>IService</code> no ser√≠a accesible fuera del m√≥dulo <code>core</code> ). </li><li>  En segundo lugar, anuncia que est√° utilizando el servicio <code>IService</code> . </li><li>  En tercer lugar, dice que proporciona una implementaci√≥n del servicio <code>IService</code> trav√©s de la clase <code>BasicService</code> . </li></ul><br>  Como la declaraci√≥n del m√≥dulo est√° escrita en Java, obtenemos ventajas muy importantes: <i>comprobaciones del compilador y garant√≠as est√°ticas</i> .  Por ejemplo, si cometimos un error en el nombre de los tipos o indicamos un paquete inexistente, lo habr√≠amos obtenido de inmediato.  En el caso de algunos OSGi, no tendr√≠amos ninguna comprobaci√≥n en el momento de la compilaci√≥n, ya que la declaraci√≥n de los puntos de extensi√≥n se escribir√≠a en XML. <br><br>  Entonces, el marco est√° listo.  Intentemos ejecutarlo: <br><br><pre> <code class="bash hljs">&gt; java --module-path core.jar --module core Basic service</code> </pre> <br>  Que paso <br><br><ol><li>  Java intent√≥ encontrar los m√≥dulos en la carpeta de <code>plugins</code> y no encontr√≥ ninguno. </li><li>  Se cre√≥ una capa vac√≠a. </li><li>  <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ServiceLoader.html">ServiceLoader</a> comenz√≥ a buscar todas <code>IService</code> implementaciones de <code>IService</code> . </li><li>  En la capa vac√≠a, no encontr√≥ ninguna implementaci√≥n de servicio, ya que no hay m√≥dulos all√≠. </li><li>  Despu√©s de esta capa, continu√≥ buscando en la capa principal (es decir, la capa de <code>Boot</code> ) y encontr√≥ una implementaci√≥n de <code>BasicService</code> en el m√≥dulo <code>core</code> . </li><li>  Todas las implementaciones encontradas ten√≠an el m√©todo <code>doJob()</code> llamado.  Como solo se encontr√≥ una implementaci√≥n, solo se imprimi√≥ el <code>"Basic service"</code> . </li></ol><br><h2>  Escribir un complemento </h2><br>  Habiendo escrito el n√∫cleo de nuestra aplicaci√≥n, ahora es el momento de intentar escribir complementos para ella.  Escribamos dos complementos <code>plugin1</code> y <code>plugin2</code> : deje que la primera imprima <code>"Service 1"</code> , la segunda - <code>"Service 2"</code> .  Para hacer esto, debe proporcionar dos implementaciones m√°s de <code>IService</code> en <code>plugin1</code> y <code>plugin2</code> respectivamente: <br><br><img src="https://habrastorage.org/webt/-o/3n/4v/-o3n4vlwhx-vwqxn7jpkunlamjq.png"><br><br>  Cree el primer complemento con dos archivos: <br><br><pre> <code class="bash hljs">plugin1/ src/main/java/ org/example/pluginapp/plugin1/ Service1.java module-info.java</code> </pre> <br>  Archivo <code>Service1.java</code> : <br><br><pre> <code class="java hljs">‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Service1</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">IService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doJob</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ System.out.println(<span class="hljs-string"><span class="hljs-string">"Service 1"</span></span>); } }</code> </pre> <br>  Archivo <code>module-info.java</code> : <br><br><pre> <code class="java hljs">‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">module</span></span> plugin1 { <span class="hljs-keyword"><span class="hljs-keyword">requires</span></span> core; provides IService with Service1; }</code> </pre> <br>  Tenga en cuenta que <code>plugin1</code> depende del <code>core</code> .  Este es el principio de inversi√≥n de dependencia que mencion√© anteriormente: el n√∫cleo no depende de complementos, sino viceversa. <br><br>  El segundo complemento es completamente similar al primero, por lo que no lo dar√© aqu√≠. <br><br>  Ahora recopilemos los complementos, col√≥quelos en la carpeta de <code>plugins</code> y ejecute la aplicaci√≥n: <br><br><pre> <code class="bash hljs">&gt; java --module-path core.jar --module core Service 1 Service 2 Basic service</code> </pre> <br>  ¬°Hurra, los complementos fueron recogidos!  ¬øC√≥mo sucedi√≥ esto? <br><br><ol><li>  Java encontr√≥ dos m√≥dulos en la carpeta de <code>plugins</code> . </li><li>  Se cre√≥ una capa con dos m√≥dulos <code>plugins1</code> y <code>plugins2</code> . </li><li>  ServiceLoader comenz√≥ a buscar todas <code>IService</code> implementaciones de <code>IService</code> . </li><li>  En la capa de complemento, encontr√≥ dos implementaciones del servicio <code>IService</code> . </li><li>  Despu√©s de eso, continu√≥ buscando en la capa principal (es decir, la capa de <code>Boot</code> ) y encontr√≥ una implementaci√≥n de <code>BasicService</code> en el m√≥dulo <code>core</code> . </li><li>  Todas las implementaciones encontradas ten√≠an el m√©todo <code>doJob()</code> llamado. </li></ol><br>  Tenga en cuenta que es precisamente porque la b√∫squeda de proveedores de servicios comienza con las capas secundarias y luego pasa a las capas principales, luego <code>"Service 2"</code> imprimen primero <code>"Service 1"</code> y <code>"Service 2"</code> y luego <code>"Basic Service"</code> .  Si desea que los servicios se ordenen para que los servicios b√°sicos vayan primero, y luego los complementos, puede ajustar el m√©todo <code>IService.getServices()</code> agregando la clasificaci√≥n all√≠ (es posible que deba agregar el <code>int getOrdering()</code> a la interfaz <code>IService</code> ). <br><br><h2>  Resumen </h2><br>  Entonces, mostr√© c√≥mo puede organizar r√°pida y eficientemente una aplicaci√≥n Java de complemento que tiene las siguientes propiedades: <br><br><ul><li>  <b>Simplicidad:</b> para los puntos de extensi√≥n y sus enlaces, solo se utilizan las caracter√≠sticas b√°sicas de Java (interfaces, clases y <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/ServiceLoader.html">ServiceLoader</a> ), sin marcos, reflejos, anotaciones y cargadores de clases. </li><li>  <b>Declarabilidad: los</b> puntos de extensi√≥n se describen en los descriptores del m√≥dulo.  Simplemente mire <code>module-info.java</code> y comprenda qu√© puntos de extensi√≥n existen y qu√© complementos contribuyen a estos puntos. </li><li>  <b>Garant√≠as est√°ticas:</b> en caso de errores en los descriptores del m√≥dulo, el programa no se compilar√°.  Adem√°s, como beneficio adicional, si usa IntelliJ IDEA, recibir√° advertencias adicionales (por ejemplo, si olvid√≥ usar <code>uses</code> y usar <code>ServiceLoader.load()</code> ) </li><li>  <b>Seguridad: el</b> sistema Java modular comprueba al inicio que la configuraci√≥n de los m√≥dulos es correcta y se niega a ejecutar el programa en caso de errores. </li></ul><br>  Repito, solo mostr√© la idea.  En una aplicaci√≥n de complemento real, habr√≠a decenas a cientos de m√≥dulos y cientos a miles de puntos de extensi√≥n. <br><br>  Decid√≠ plantear este tema porque durante los √∫ltimos 7 a√±os he estado escribiendo una aplicaci√≥n modular usando Eclipse RCP, en la que el notorio OSGi se usa como un sistema de complemento, y los descriptores de los complementos est√°n escritos en XML.  Tenemos m√°s de un centenar de complementos y todav√≠a estamos en Java 8. Pero incluso si actualizamos a una nueva versi√≥n de Java, es poco probable que usemos m√≥dulos de Java, ya que est√°n muy vinculados a OSGi. <br><br>  Pero si est√° escribiendo una aplicaci√≥n de complemento desde cero, entonces los m√≥dulos Java son una de las posibles opciones para su implementaci√≥n.  Recuerde que los m√≥dulos son solo una herramienta, no un objetivo. <br><br><h2>  Brevemente sobre mi </h2><br>  He estado programando durante m√°s de 10 a√±os (8 de ellos en Java), respondo a <a href="https://stackoverflow.com/users/706317/zhekakozlov">StackOverflow</a> y ejecuto mi propio <a href="https://t.me/miniJUG">canal en Telegram</a> dedicado a Java. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/479478/">https://habr.com/ru/post/479478/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../479462/index.html">Serialization in C ++</a></li>
<li><a href="../479464/index.html">Pipes & Filters. Example application and implementation using Spring</a></li>
<li><a href="../479466/index.html">Habraiting 2019: statistics and ranking of the best articles for 2019</a></li>
<li><a href="../479468/index.html">Edge of Honesty and John Doe</a></li>
<li><a href="../479474/index.html">Why is self-organization of teams so important in Scrum and why there cannot be managers in it</a></li>
<li><a href="../479480/index.html">SDK de SARIF y sus errores</a></li>
<li><a href="../479482/index.html">SDK de SARIF y sus errores</a></li>
<li><a href="../479486/index.html">Programaci√≥n heterog√©nea y oneAPI Toolkit. Conferencia improvisada experta de Intel responde sus preguntas</a></li>
<li><a href="../479488/index.html">Desde una computadora port√°til: un servidor dom√©stico con alimentaci√≥n redundante al enrutador Mikrotik</a></li>
<li><a href="../479492/index.html">Computaci√≥n sin servidor basada en OpenWhisk, parte 3</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>