<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👸🏽 🤴🏽 🌂 Tentang implementasi open-source dari fungsi hash GOST R 34.11-2012 dan dampaknya terhadap tanda tangan elektronik GOST R 34.10-2012 🙋🏾 😌 🕊️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pada suatu waktu, implementasi algoritma kriptografi domestik di perpustakaan libgcrypt sangat menginspirasi saya. Menjadi mungkin untuk menggunakan a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Tentang implementasi open-source dari fungsi hash GOST R 34.11-2012 dan dampaknya terhadap tanda tangan elektronik GOST R 34.10-2012</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/450024/"><img src="https://habrastorage.org/webt/_f/ce/y_/_fcey_1t2afkou2xu5zql3xuzbk.png" align="left">  Pada suatu waktu, implementasi algoritma kriptografi domestik di perpustakaan libgcrypt sangat menginspirasi saya.  Menjadi mungkin untuk menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">algoritma ini</a> di Kleopatra dan di Kmail dan GnuPg secara umum, untuk mempertimbangkan perpustakaan libgcrypt sebagai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">alternatif untuk openssl</a> dengan mesin GOST.  Dan semuanya hebat sampai Jumat lalu. <br><a name="habracut"></a><br>  Saya diminta untuk memverifikasi tanda tangan elektronik GOST R 34.10-2012-256 untuk dokumen yang dibuat di Microsoft Office di MS Windows.  Dan saya memutuskan untuk memeriksanya di Kleopatra (Saya punya Linux).  Dan bagaimana menurut Anda, tanda tangannya ternyata salah.  Keraguan merayap masuk.  Saya memutuskan untuk memeriksa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">openssl dengan</a> mesin <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GOST</a> .  Tanda tangan telah berhasil diverifikasi.  Segera menandatangani ulang file di Kleopatra dan tidak lulus tes pada MS Windows.  Kami mencoba masuk dan memverifikasi file lain, semuanya baik-baik saja.  Pertanyaannya adalah apa masalahnya?  Karena hash dokumen terlibat dalam penandatanganan, diputuskan untuk memeriksa perhitungan hash oleh berbagai program.  Pertama-tama, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">implementasi open-source untuk stribog terlibat</a> : <br><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Implementasi yang terkenal dari Degtyarev</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Implementasi Libgcrypt</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Libressl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mesin openssl</a> </li></ul><br>  Dan kemudian ada kejutan!  Hash yang dihitung oleh "implementasi Degtyarev yang terkenal" bertepatan dengan hash yang dihitung dalam openssl dengan GOST dari endine, tetapi tidak cocok dengan nilai hash yang dihitung menggunakan libgcrypt dan libressl. <br><br>  Betapa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" class="user_link">ru_crypt</a> benar ketika ia menulis di awal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikelnya</a> : <br><blockquote>  Saya segera memperingatkan Anda bahwa saya tidak memeriksa kebenaran implementasi. </blockquote><br>  Omong-omong, standar pada GOST R 34.10-2012 juga mengatakan bahwa contoh kontrol hanya untuk referensi.  Harus dipahami dengan jelas bahwa kasus uji tidak menjamin bahwa implementasi yang berbeda memberikan hasil yang sama untuk semua kesempatan. <br><br>  Untuk menghitung nilai hash, utilitas berikut digunakan: <br><br>  1) openssl <br><br><pre><code class="bash hljs">$ openssl dgst [–md_gost12_256|-md_gost12_512] &lt;file&gt;</code> </pre> <br>  2) Libresl <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$libressl</span></span> dgst [–streebog256|streebog512] &lt;file&gt;</code> </pre> <br>  3) libgcrypt <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$gchash</span></span> [stribog256|stribog512] &lt;file&gt;</code> </pre> <br>  4) Implementasi Degtyarev yang terkenal <br><br><pre> <code class="bash hljs"><span class="hljs-variable"><span class="hljs-variable">$gost3411</span></span>-2012 [-2|-5] &lt;file&gt;</code> </pre> <br>  Berikut ini juga hal yang menarik: dalam transkripsi stribogs Latin menulis baik stribog atau streebog.  Akan menyenangkan untuk datang ke keseragaman.  Dan sepertinya ini adalah fungsi yang berbeda.  Secara pribadi, saya lebih suka opsi pertama - stribog. <br><br>  Saya membutuhkan arbiter. <br><br>  Sebagai arbiter, diputuskan untuk menggunakan token PKCS # 11 RUTOKEN EDS-2.0, yang mendukung standar kriptografi Rusia GOST R 34.10-2012, GOST R 34.11-2012, VKO GOST R 34.10-2012 (RFC 7836) dengan panjang kunci 256 dan 512 bit , dan disertifikasi oleh FSB Rusia sebagai sarana perlindungan informasi kriptografi (CPSI) dan sarana tanda tangan elektronik. <br><br>  Selain itu, token RUTOKEN EDS-2.0 didistribusikan secara luas dan banyak <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sertifikat toko</a> untuk akses ke layanan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Negara</a> dan portal lainnya. <br>  Untuk menghitung nilai hash pada token, kita akan menggunakan skrip test_digest.tcl di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Tcl</a> : <br><br><div class="spoiler">  <b class="spoiler_title">test_digest.tcl</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">#! /usr/bin/env tclsh package require pki lappend auto_path . package require pki::pkcs11 #     PKCS#11 set pkcs11_module "/usr/local/lib64/librtpkcs11ecp_2.0.so" #set pkcs11_module "/usr/local/lib64/libls11sw2016.so" puts "Connect the Token and press Enter" gets stdin yes set handle [pki::pkcs11::loadmodule $pkcs11_module] set slots [pki::pkcs11::listslots $handle] foreach slotinfo $slots { set slotid [lindex $slotinfo 0] set slotlabel [lindex $slotinfo 1] set slotflags [lindex $slotinfo 2] if {[lsearch -exact $slotflags TOKEN_PRESENT] != -1} { set token_slotlabel $slotlabel set token_slotid $slotid #    break } } proc usage {use error} { puts "Copyright(C) Orlov Vladimir (http://soft.lissi.ru) 2019" if {$use == 1} { puts $error puts "Usage:\ndigest &lt;stribog256|stribog512&gt; &lt;file for digest&gt;\n" } } set countcert [llength $argv] if { $countcert != 2 } { usage 1 "Bad usage!" exit } set digest_algo [lindex $argv 0] if {$digest_algo != "stribog256" &amp;&amp; $digest_algo != "stribog512"} { usage 1 "Bad usage!" exit } set file [lindex $argv 1] if {![file exists $file]} { usage 1 "File $file not exist" exit } puts "Loading file for digest: $file" set fd [open $file] chan configure $fd -translation binary set cert_user [read $fd] close $fd if {$cert_user == "" } { usage 1 "Bad file: $file" exit } set aa [dict create pkcs11_handle $handle pkcs11_slotid $token_slotid] set digest_hex [pki::pkcs11::digest $digest_algo $cert_user $aa] puts "digest_hex=\n$digest_hex" exit</code> </pre> <br></div></div><br>  Kapan perbedaan implementasi ini muncul?  Sejauh ini, telah dimungkinkan untuk menentukan bahwa perbedaan ini terjadi ketika menghitung hash file doc yang dibuat di MS Office.  Selain itu, hash dari 143 byte pertama dianggap sama, dan ketika menghitung hash dari 144 byte, nilainya berbeda. <br><br>  143 byte pertama dalam tampilan heksadesimal seperti ini: <br><br><pre> <code class="bash hljs">d0cf11e0a1b11ae1000000000000000000000000000000003e000300feff0900060000000000000000000000010000000100000000000000001000002400000001000000feffffff0000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</code> </pre> <br>  Simpan di file Doc1_143_hex.txt. <br><br>  144 byte pertama dalam tampilan heksadesimal seperti ini: <br><br><pre> <code class="bash hljs">d0cf11e0a1b11ae1000000000000000000000000000000003e000300feff0900060000000000000000000000010000000100000000000000001000002400000001000000feffffff0000000000000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff</code> </pre> <br>  Simpan di file Doc1_144_hex.txt. <br><br>  Lebih mudah menggunakan skrip hex2bin.tcl untuk menerjemahkan dari bentuk heksadesimal ke biner: <br><br><pre> <code class="plaintext hljs">#!/usr/bin/tclsh proc usage {use error} { if {$use == 1} { puts $error puts "Usage:\nhex2bin &lt;file with hex&gt; &lt;file for bin&gt;\n" } } set countcert [llength $argv] if { $countcert != 2 } { usage 1 "Bad usage!" exit } set file [lindex $argv 0] if {![file exists $file]} { usage 1 "File $file not exist" exit } set fd [open $file] chan configure $fd -translation binary set cert_user [read $fd] close $fd if {$cert_user == "" } { usage 1 "Bad file with hex: $file" exit } set cert_user [binary format H* $cert_user] set fd [open [lindex $argv 1] w] chan configure $fd -translation binary puts -nonewline $fd $cert_user close $fd</code> </pre> <br>  Ubah kode heksadesimal menjadi biner: <br><pre> <code class="bash hljs">$./hex2bin Doc1_143_hex.txt Doc1_143.bin $./hex2bin Doc1_144_hex.txt Doc1_144.bin $</code> </pre> <br>  Sekarang Anda dapat memeriksa bagaimana hash dihitung dengan berbagai implementasi: <br>  Pertama, pertimbangkan hash untuk file Doc1_143, bin: <br><br><pre> <code class="bash hljs">$ ./openssl dgst -md_gost12_256 Doc1_143.bin md_gost12_256(Doc1_143.bin)= e63bd3edc44f9a03fece4198b690a8ae291b973ae61b2a0f512a9a7479431a63 $ ./libressl dgst -streebog256 Doc1_143.bin streebog256(Doc1_143.bin)= e63bd3edc44f9a03fece4198b690a8ae291b973ae61b2a0f512a9a7479431a63 $ ./gchash stribog256 Doc1_143.bin e63bd3edc44f9a03fece4198b690a8ae291b973ae61b2a0f512a9a7479431a63 Doc1_143.bin $ ./gost3411-2012 -2 Doc1_143.bin GOST R 34.11-2012 (Doc1_143.bin) = e63bd3edc44f9a03fece4198b690a8ae291b973ae61b2a0f512a9a7479431a63 $</code> </pre> <br>  Momen paling penting telah tiba, momen verifikasi pada sistem perlindungan informasi kriptografi bersertifikat: <br><br><pre> <code class="bash hljs">$ ./test_digest.tcl stribog256 Doc1_143.bin Connect the Token and press Enter Loading file <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> digest: Doc1_143.bin digest_hex= e63bd3edc44f9a03fece4198b690a8ae291b973ae61b2a0f512a9a7479431a63 $</code> </pre> <br>  Seperti yang Anda lihat, semuanya berakhir untuk selamanya. <br><br>  Mari kita lihat apa yang terjadi pada file Doc1_144.bin: <br><br><pre> <code class="bash hljs">$ ./openssl dgst -md_gost12_256 Doc1_144.bin md_gost12_256(Doc1_144.bin)= c766085540caaa8953bfcf7a1ba220619cee50d65dc242f82f23ba4b180b18e0 $ ./libressl dgst -streebog256 Doc1_144.bin streebog256(Doc1_144.bin)= 3965c99777eb1b64c783496fe950aa6540bc7baa399a3889995145afbdd76250 $</code> </pre> <br>  Itu saja, nilai-nilai hash tidak cocok.  Untuk kemurnian percobaan, kami memeriksa implementasi yang tersisa: <br><br><pre> <code class="bash hljs">$ ./gchash_1.7.10 stribog256 Doc1_144.bin 3965c99777eb1b64c783496fe950aa6540bc7baa399a3889995145afbdd76250 Doc1_144.bin $ ./gost3411-2012 -2 Doc1_144.bin GOST R 34.11-2012 (Doc1_144.bin) = c766085540caaa8953bfcf7a1ba220619cee50d65dc242f82f23ba4b180b18e0 $ ./test_digest.tcl stribog256 Doc1_144.bin Connect the Token and press Enter Loading file <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> digest: Doc1_144.bin digest_hex= c766085540caaa8953bfcf7a1ba220619cee50d65dc242f82f23ba4b180b18e0 $</code> </pre> <br>  Hash yang dihitung oleh "implementasi Degtyarev yang terkenal" cocok dengan hash yang dihitung dalam openssl dengan mesin GOST, tetapi tidak cocok dengan nilai hash yang dihitung menggunakan libgcrypt dan libressl. <br><br>  Kami mendapatkan hasil yang serupa jika kami mempertimbangkan hash stribog512. <br><br>  Ada satu kesimpulan.  Jika Anda ingin tanda tangan elektronik GOST R 34.10-2012 yang dihasilkan oleh libressl dan libgcrypt (atau mungkin yang lain) kompatibel dengan openssl dan, yang paling penting, dengan perlindungan informasi kriptografi yang disertifikasi dalam sistem sertifikasi FSB Rusia, gunakan yang terverifikasi implementasi untuk komputasi hash.  Saya berharap publikasi ini akan menghindari banyak kesalahpahaman, dan penulis penerapan stribog di libressl, libgrypt dan mungkin orang lain akan membantu menghilangkan perbedaan ini.  Hari ini, saya harus mengakui, dalam produk di atas, sebenarnya bukan GOST R 34.10-2012 yang diterapkan, tetapi sesuatu yang lain.  Ini adalah algoritma yang berbeda.  Contoh uji yang diberikan mungkin akan baik untuk dimasukkan sebagai contoh uji untuk GOST R 34.10-2012.  Dan saya akan mengedit libgcrypt untuk Kleopatra dan KMail.  Legenda Cleopart dan kriptografi Rusia belum selesai. <br><br>  PS Artikel sudah siap ketika kolega saya mengatakan bahwa perbedaan antara implementasi muncul ketika urutan 0xFF yang cukup panjang ditemukan.  Dia, urutan ini, by the way, hadir di awal file doc dari MS Office.  Saya memeriksa, apa adanya.  File tersebut mengandung 189 byte. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id450024/">https://habr.com/ru/post/id450024/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id450008/index.html">Temukan bug di LLVM 8 menggunakan penganalisa PVS-Studio</a></li>
<li><a href="../id450010/index.html">Penyimpanan, cadangan, dan katalogisasi foto</a></li>
<li><a href="../id450016/index.html">Pembuatan sistem verifikasi formal dari awal. Bagian 1: mesin virtual karakter dalam PHP dan Python</a></li>
<li><a href="../id450018/index.html">Duo matematika memetakan wilayah permukaan minimal yang tak berujung</a></li>
<li><a href="../id450020/index.html">Lembah Silikon datang ke anak sekolah Kansas. Ini menyebabkan protes.</a></li>
<li><a href="../id450026/index.html">Cipher akselerasi: kami mempelajari accelerometer perangkat Android menggunakan contoh tugas NeoQUEST-2019</a></li>
<li><a href="../id450028/index.html">Membangun Arsitektur Berorientasi Layanan pada Rel + Kafka</a></li>
<li><a href="../id450030/index.html">Saya tidak bisa menggunakan Rift S dan Anda tidak akan berhasil</a></li>
<li><a href="../id450032/index.html">Cara membuat tema gelap tanpa merusak: belajar dengan tim Yandex Mail</a></li>
<li><a href="../id450034/index.html">Mengapa Anda harus berpartisipasi dalam hackathons</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>