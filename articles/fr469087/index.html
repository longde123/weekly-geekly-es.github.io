<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üö¥üèº üë©‚Äçüë©‚Äçüë¶‚Äçüë¶ üë©üèø‚Äçüéì MVCC dans PostgreSQL-2. Fourches, limes, pages üèîÔ∏è üßïüèΩ üêì</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La derni√®re fois, nous avons parl√© de coh√©rence des donn√©es, examin√© la diff√©rence entre les niveaux d'isolement des transactions du point de vue de l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC dans PostgreSQL-2. Fourches, limes, pages</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/469087/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La derni√®re fois,</a> nous avons parl√© de coh√©rence des donn√©es, examin√© la diff√©rence entre les niveaux d'isolement des transactions du point de vue de l'utilisateur et compris pourquoi il √©tait important de le savoir.  Nous commen√ßons maintenant √† explorer comment PostgreSQL impl√©mente l'isolement de clich√© et la concurrence multiversionnelle. <br><br>  Dans cet article, nous verrons comment les donn√©es sont physiquement dispos√©es dans des fichiers et des pages.  Cela nous √©loigne de la discussion de l'isolement, mais une telle digression est n√©cessaire pour comprendre ce qui suit.  Nous devrons d√©terminer comment le stockage des donn√©es est organis√© √† un faible niveau. <br><br><h1>  Les relations </h1><br>  Si vous regardez √† l'int√©rieur des tables et des index, il s'av√®re qu'ils sont organis√©s de mani√®re similaire.  Les deux sont des objets de base de donn√©es qui contiennent des donn√©es compos√©es de lignes. <br><br>  Il ne fait aucun doute qu'une table est constitu√©e de lignes, mais cela est moins √©vident pour un index.  Cependant, imaginez un arbre B: il se compose de n≈ìuds qui contiennent des valeurs index√©es et des r√©f√©rences √† d'autres n≈ìuds ou lignes de table.  Ce sont ces n≈ìuds qui peuvent √™tre consid√©r√©s comme des lignes d'index, et en fait, ils le sont. <br><br>  En fait, quelques autres objets sont organis√©s de la m√™me mani√®re: des s√©quences (essentiellement des tables √† une seule ligne) et des vues mat√©rialis√©es (essentiellement des tables qui se souviennent de la requ√™te).  Et il y a aussi des vues r√©guli√®res, qui ne stockent pas les donn√©es elles-m√™mes, mais sont dans tous les autres sens similaires aux tableaux. <br><br>  Tous ces objets dans PostgreSQL sont appel√©s la <em>relation de</em> mots communs.  Ce mot est extr√™mement impropre car c'est un terme de la th√©orie relationnelle.  Vous pouvez faire un parall√®le entre une relation et une table (vue), mais certainement pas entre une relation et un index.  Mais il en est ainsi: l'origine acad√©mique de PostgreSQL se manifeste.  Il me semble que ce sont les tableaux et les vues qui ont √©t√© appel√©s ainsi en premier, et le reste a enfl√© avec le temps. <br><a name="habracut"></a><br>  Pour √™tre plus simple, nous discuterons plus loin des tables et des index, mais les autres <em>relations</em> sont organis√©es exactement de la m√™me mani√®re. <br><br><h1>  Fourches et limes </h1><br>  Habituellement, plusieurs <em>fourches</em> correspondent √† chaque relation.  Les fourches peuvent avoir plusieurs types, et chacun d'eux contient un certain type de donn√©es. <br><br>  S'il y a un fork, il est d'abord repr√©sent√© par le seul <em>fichier</em> .  Le nom de fichier est un identifiant num√©rique, qui peut √™tre ajout√© par une fin qui correspond au nom de la fourche. <br><br>  Le fichier grandit progressivement et lorsque sa taille atteint 1 Go, un nouveau fichier du m√™me fork est cr√©√© (des fichiers comme ceux-ci sont parfois appel√©s <em>segments</em> ).  Le num√©ro ordinal du segment est ajout√© √† la fin du nom de fichier. <br><br>  La limitation de 1 Go de la taille du fichier est apparue historiquement pour prendre en charge diff√©rents syst√®mes de fichiers, dont certains ne peuvent pas traiter des fichiers de plus grande taille.  Vous pouvez modifier cette limitation lors de la construction de PostgreSQL ( <code>./configure --with-segsize</code> ). <br><br>  Ainsi, plusieurs fichiers sur disque peuvent correspondre √† une seule relation.  Par exemple, pour une petite table, il y en aura trois. <br><br>  Tous les fichiers d'objets qui appartiennent √† un espace de table et √† une base de donn√©es seront stock√©s dans un r√©pertoire.  Vous devez avoir cela √† l'esprit car les syst√®mes de fichiers ne fonctionnent g√©n√©ralement pas correctement avec un grand nombre de fichiers dans un r√©pertoire. <br><br>  Notez ici que les fichiers, √† leur tour, sont divis√©s en <em>pages</em> (ou <em>blocs</em> ), g√©n√©ralement de 8 Ko.  Nous discuterons un peu plus loin de la structure interne des pages. <br><br><img src="https://habrastorage.org/webt/10/ze/w6/10zew6_pruaxe8amjtx7_6x70tk.png"><br><br>  Voyons maintenant les types de fourches. <br><br>  La <strong>fourche principale</strong> est les donn√©es elles-m√™mes: les m√™mes lignes de table et d'index.  Le fork principal est disponible pour toutes les relations (sauf les vues qui ne contiennent pas de donn√©es). <br><br>  Les noms des fichiers du fork principal sont constitu√©s du seul identifiant num√©rique.  Par exemple, voici le chemin d'acc√®s √† la table que nous avons cr√©√©e la derni√®re fois: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/41493/41496 (1 row)</code> </pre><br>  D'o√π proviennent ces identifiants?  Le r√©pertoire "base" correspond au tablespace "pg_default".  Le sous-r√©pertoire suivant, correspondant √† la base de donn√©es, est o√π se trouve le fichier d'int√©r√™t: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_database <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> datname = <span class="hljs-string"><span class="hljs-string">'test'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> oid ------- 41493 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfilenode <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfilenode ------------- 41496 (1 row)</code> </pre><br>  Le chemin est relatif, il est sp√©cifi√© √† partir du r√©pertoire de donn√©es (PGDATA).  De plus, pratiquement tous les chemins dans PostgreSQL sont sp√©cifi√©s √† partir de PGDATA.  Gr√¢ce √† cela, vous pouvez d√©placer PGDATA en toute s√©curit√© vers un emplacement diff√©rent - rien ne le limite (sauf qu'il peut √™tre n√©cessaire de d√©finir le chemin d'acc√®s aux biblioth√®ques dans LD_LIBRARY_PATH). <br><br>  De plus, en examinant le syst√®me de fichiers: <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41496</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 8192 /var/lib/postgresql/11/main/base/41493/41496</code> </pre><br>  La <strong>fourchette d'initialisation</strong> n'est disponible que pour les tables non enregistr√©es (cr√©√©es avec UNLOGGED sp√©cifi√©) et leurs index.  Des objets comme ceux-ci ne diff√®rent en rien des objets normaux, sauf que les op√©rations avec eux ne sont pas enregistr√©es dans le journal d'√©criture anticip√©e (WAL).  Pour cette raison, il est plus rapide de travailler avec eux, mais il est impossible de r√©cup√©rer les donn√©es dans l'√©tat coh√©rent en cas de d√©faillance.  Par cons√©quent, lors d'une r√©cup√©ration, PostgreSQL supprime simplement toutes les fourches de ces objets et √©crit le fork d'initialisation √† la place du fork principal.  Il en r√©sulte un objet vide.  Nous discuterons de la journalisation en d√©tail, mais dans une autre s√©rie. <br><br>  La table "comptes" est enregistr√©e, et par cons√©quent, elle n'a pas de fourche d'initialisation.  Mais pour exp√©rimenter, nous pouvons d√©sactiver la journalisation: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNLOGGED</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/41493/41507 (1 row)</code> </pre><br>  L'exemple pr√©cise qu'une possibilit√© d'activer et de d√©sactiver la journalisation √† la vol√©e est associ√©e √† la r√©√©criture des donn√©es dans des fichiers avec des noms diff√©rents. <br><br>  Un fork d'initialisation a le m√™me nom que le fork principal, mais avec le suffixe "_init": <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_init</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 0 /var/lib/postgresql/11/main/base/41493/41507_init</code> </pre><br>  La <strong>carte de l'espace libre</strong> est une fourchette qui assure le suivi de la disponibilit√© de l'espace libre √† l'int√©rieur des pages.  Cet espace est en constante √©volution: il diminue lorsque de nouvelles versions de lignes sont ajout√©es et augmente lors de l'aspiration.  La carte d'espace libre est utilis√©e lors de l'insertion de nouvelles versions de lignes afin de trouver rapidement une page appropri√©e, o√π les donn√©es √† ajouter conviendront. <br><br>  Le nom de la carte d'espace libre a le suffixe "_fsm".  Mais ce fichier n'appara√Æt pas imm√©diatement, mais seulement lorsque le besoin s'en fait sentir.  La fa√ßon la plus simple d'y parvenir est de passer l'aspirateur sur une table (nous expliquerons pourquoi le moment venu): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> accounts;</code> </pre><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_fsm</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 24576 /var/lib/postgresql/11/main/base/41493/41507_fsm</code> </pre><br>  La <strong>carte de visibilit√©</strong> est un fork o√π les pages qui ne contiennent que des versions de lignes √† jour sont marqu√©es par un bit.  En gros, cela signifie que lorsqu'une transaction essaie de lire une ligne d'une telle page, la ligne peut √™tre affich√©e sans v√©rifier sa visibilit√©.  Dans les prochains articles, nous expliquerons en d√©tail comment cela se produit. <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_vm</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 8192 /var/lib/postgresql/11/main/base/41493/41507_vm</code> </pre><br><h1>  Pages </h1><br>  Comme d√©j√† mentionn√©, les fichiers sont logiquement divis√©s en pages. <br><br>  Une page a g√©n√©ralement une taille de 8 Ko.  La taille peut √™tre modifi√©e dans certaines limites (16 Ko ou 32 Ko), mais uniquement pendant la g√©n√©ration ( <code>./configure --with-blocksize</code> ).  Une instance construite et ex√©cut√©e ne peut fonctionner qu'avec des pages de m√™me taille. <br><br>  Quelle que soit la fourchette √† laquelle appartiennent les fichiers, le serveur les utilise de mani√®re assez similaire.  Les pages sont d'abord lues dans le cache tampon, o√π les processus peuvent les lire et les modifier;  puis lorsque le besoin s'en fait sentir, ils sont renvoy√©s sur le disque. <br><br>  Chaque page a un partitionnement interne et contient en g√©n√©ral les partitions suivantes: <br><br><pre>        0 + ----------------------------------- +
           |  en-t√™te |
       24 + ----------------------------------- +
           |  tableau de pointeurs vers les versions de ligne |
    inf√©rieur + ----------------------------------- +
           |  espace libre |
    sup√©rieur + ----------------------------------- +
           |  versions de ligne |
  sp√©cial + ----------------------------------- +
           |  espace sp√©cial |
 taille de page + ----------------------------------- +
</pre><br>  Vous pouvez facilement conna√Ætre les tailles de ces partitions en utilisant la page d'extension "research" inspecter: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pageinspect; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> lower, upper, special, pagesize <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> page_header(get_raw_page(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> lower | upper | special | pagesize -------+-------+---------+---------- 40 | 8016 | 8192 | 8192 (1 row)</code> </pre><br>  Ici, nous regardons l'en- <strong>t√™te</strong> de la toute premi√®re page (z√©ro) du tableau.  En plus de la taille des autres zones, l'en-t√™te contient des informations diff√©rentes sur la page, ce qui ne nous int√©resse pas encore. <br><br>  Au bas de la page, il y a l' <strong>espace sp√©cial</strong> , qui est vide dans ce cas.  Il n'est utilis√© que pour les index, et m√™me pas pour tous.  "Au fond" refl√®te ici ce qui est dans l'image;  il peut √™tre plus exact de dire "dans des adresses √©lev√©es". <br><br>  Apr√®s l'espace sp√©cial, les <strong>versions de ligne</strong> sont localis√©es, c'est-√†-dire ces m√™mes donn√©es que nous stockons dans la table plus quelques informations internes. <br><br>  En haut d'une page, juste apr√®s l'en-t√™te, il y a la table des mati√®res: le <strong>tableau de pointeurs</strong> vers les versions de ligne disponibles dans la page. <br><br>  <strong>L'espace libre</strong> peut √™tre laiss√© entre les versions de ligne et les pointeurs (cet espace libre est conserv√© dans la carte de l'espace libre).  Notez qu'il n'y a pas de fragmentation de la m√©moire √† l'int√©rieur d'une page - tout l'espace libre est repr√©sent√© par une zone contigu√´. <br><br><h2>  Pointeurs </h2><br>  Pourquoi les pointeurs vers les versions de ligne sont-ils n√©cessaires?  Le fait est que les lignes d'index doivent en quelque sorte faire r√©f√©rence aux versions de ligne dans la table.  Il est clair que la r√©f√©rence doit contenir le num√©ro de fichier, le num√©ro de la page dans le fichier et une indication de la version de la ligne.  Nous pourrions utiliser le d√©calage depuis le d√©but de la page comme indicateur, mais ce n'est pas pratique.  Nous ne pourrions pas d√©placer une version de ligne √† l'int√©rieur de la page car cela casserait les r√©f√©rences disponibles.  Et cela entra√Ænerait la fragmentation de l'espace √† l'int√©rieur des pages et d'autres cons√©quences g√™nantes.  Par cons√©quent, l'index fait r√©f√©rence au num√©ro de pointeur et le pointeur fait r√©f√©rence √† l'emplacement actuel de la version de ligne dans la page.  Et c'est l'adressage indirect. <br><br>  Chaque pointeur occupe exactement quatre octets et contient: <br><br><ul><li>  une r√©f√©rence √† la version en ligne </li><li>  la taille de cette version en ligne </li><li>  plusieurs octets pour d√©terminer l'√©tat de la version de ligne </li></ul><br><h2>  Format des donn√©es </h2><br>  Le format des donn√©es sur le disque est exactement le m√™me que la repr√©sentation des donn√©es dans la RAM.  La page est lue dans le cache tampon "en l'√©tat", sans aucune conversion.  Par cons√©quent, les fichiers de donn√©es d'une plate-forme s'av√®rent incompatibles avec d'autres plates-formes. <br><br>  Par exemple, dans l'architecture X86, l'ordre des octets va des octets les moins significatifs aux octets les plus significatifs (little-endian), z / Architecture utilise l'ordre inverse (big-endian), et dans ARM l'ordre peut √™tre invers√©. <br><br>  De nombreuses architectures permettent l'alignement des donn√©es sur les limites des mots machine.  Par exemple, sur un syst√®me x86 32 bits, les nombres entiers (type "entier", qui occupe 4 octets) seront align√©s sur une limite de mots de 4 octets, de la m√™me mani√®re que les nombres √† double pr√©cision (type "double pr√©cision" , qui occupe 8 octets).  Et sur un syst√®me 64 bits, les nombres √† double pr√©cision seront align√©s sur une limite de mots de 8 octets.  C'est une raison de plus d'incompatibilit√©. <br><br>  En raison de l'alignement, la taille de la ligne du tableau d√©pend de l'ordre des champs.  Habituellement, cet effet n'est pas tr√®s visible, mais parfois, il peut entra√Æner une croissance significative de la taille.  Par exemple, si des champs de types ¬´char (1)¬ª et ¬´integer¬ª sont entrelac√©s, g√©n√©ralement 3 octets entre eux sont perdus.  Pour plus de d√©tails √† ce sujet, vous pouvez consulter la pr√©sentation de Nikolay Shaplov " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tuple internals</a> ". <br><br><h1>  Versions en ligne et TOAST </h1><br>  Nous discuterons des d√©tails de la structure interne des versions de ligne la prochaine fois.  √Ä ce stade, il est seulement important pour nous de savoir que chaque version doit correspondre compl√®tement √† une page: PostgreSQL n'a aucun moyen de "prolonger" la ligne √† la page suivante.  La technique de stockage des attributs surdimensionn√©s (TOAST) est utilis√©e √† la place.  Le nom lui-m√™me indique qu'une ligne peut √™tre d√©coup√©e en toasts. <br><br>  Blague √† part, TOAST implique plusieurs strat√©gies.  Nous pouvons transmettre de longues valeurs d'attribut √† une table interne s√©par√©e apr√®s les avoir divis√©es en petits morceaux de pain grill√©.  Une autre option consiste √† compresser une valeur afin que la version de ligne tienne sur une page standard.  Et nous pouvons faire les deux: d'abord compresser puis rompre et transmettre. <br><br>  Pour chaque table principale, une table TOAST distincte peut √™tre cr√©√©e si n√©cessaire, une pour tous les attributs (avec un index dessus).  La disponibilit√© d'attributs potentiellement longs d√©termine ce besoin.  Par exemple, si une table a une colonne de type "num√©rique" ou "texte", la table TOAST sera imm√©diatement cr√©√©e m√™me si les valeurs longues ne seront pas utilis√©es. <br><br>  Puisqu'une table TOAST est essentiellement une table ordinaire, elle a le m√™me ensemble de fourches.  Et cela double le nombre de fichiers qui correspondent √† une table. <br><br>  Les strat√©gies initiales sont d√©finies par les types de donn√©es de la colonne.  Vous pouvez les consulter √† l'aide de la commande <code>\d+</code> dans psql, mais comme elle g√©n√®re en outre de nombreuses autres informations, nous interrogerons le catalogue syst√®me: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> attname, atttypid::<span class="hljs-type"><span class="hljs-type">regtype</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> attstorage <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'p'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'plain'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'e'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'external'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'m'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'main'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'x'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'extended'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_attribute <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> attrelid = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attnum &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><pre> <code class="plaintext hljs"> attname | atttypid | storage ---------+----------+---------- id | integer | plain number | text | extended client | text | extended amount | numeric | main (4 rows)</code> </pre><br>  Les noms des strat√©gies signifient: <br><br><ul><li>  plain - TOAST n'est pas utilis√© (utilis√© pour les types de donn√©es connus pour √™tre courts, tels que "entier"). </li><li>  √©tendu - la compression et le stockage dans une table TOAST distincte sont autoris√©s </li><li>  external - les valeurs longues sont stock√©es dans la table TOAST sans compression. </li><li>  main - les valeurs longues sont d'abord compress√©es et n'entrent dans la table TOAST que si la compression n'a pas aid√©. </li></ul><br>  En g√©n√©ral, l'algorithme est le suivant.  PostgreSQL vise √† ce qu'au moins quatre lignes correspondent √† une page.  Par cons√©quent, si la taille de la ligne d√©passe un quart de la page, l'en-t√™te pris en compte (2040 octets pour une page ordinaire de 8K), TOAST doit √™tre appliqu√© √† une partie des valeurs.  Nous suivons l'ordre d√©crit ci-dessous et nous nous arr√™tons d√®s que la ligne ne d√©passe plus le seuil: <br><br><ol><li>  Nous passons d'abord par les attributs avec les strat√©gies "externe" et "√©tendue" de l'attribut le plus long au plus court.  Les attributs ¬´√©tendus¬ª sont compress√©s (s'il est efficace) et si la valeur elle-m√™me d√©passe un quart de la page, elle p√©n√®tre imm√©diatement dans la table TOAST.  Les attributs "externes" sont trait√©s de la m√™me mani√®re, mais ne sont pas compress√©s. </li><li>  Si apr√®s la premi√®re passe, la version ligne ne correspond pas encore √† la page, nous transmettons les attributs restants avec les strat√©gies "externe" et "√©tendue" √† la table TOAST. </li><li>  Si cela n'a pas aid√© non plus, nous essayons de compresser les attributs avec la strat√©gie "principale", mais les laissons dans la page du tableau. </li><li>  Et seulement si apr√®s cela, la ligne n'est pas assez courte, les attributs "principaux" entrent dans la table TOAST. </li></ol><br>  Parfois, il peut √™tre utile de modifier la strat√©gie de certaines colonnes.  Par exemple, s'il est connu √† l'avance que les donn√©es d'une colonne ne peuvent pas √™tre compress√©es, nous pouvons d√©finir la strat√©gie "externe" pour celle-ci, ce qui nous permet de gagner du temps en √©vitant les tentatives de compression inutiles.  Cela se fait comme suit: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> number <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STORAGE external</span></span>;</code> </pre><br>  En relan√ßant la requ√™te, nous obtenons: <br><br><pre> <code class="plaintext hljs"> attname | atttypid | storage ---------+----------+---------- id | integer | plain number | text | external client | text | extended amount | numeric | main</code> </pre><br>  Les tables et index TOAST sont situ√©s dans le sch√©ma pg_toast distinct et ne sont donc g√©n√©ralement pas visibles.  Pour les tables temporaires, le sch√©ma "pg_toast_temp_ <em>N</em> " est utilis√© de la m√™me mani√®re que l'habituel "pg_temp_ <em>N</em> ". <br><br>  Bien s√ªr, si vous aimez, personne ne vous g√™nera d'espionner la m√©canique interne du processus.  Disons que dans le tableau ¬´comptes¬ª, il y a trois attributs potentiellement longs et qu'il doit donc y avoir un tableau TOAST.  Le voici: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relnamespace::<span class="hljs-type"><span class="hljs-type">regnamespace</span></span>, relname <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> reltoastrelid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span> );</code> </pre><pre> <code class="plaintext hljs"> relnamespace | relname --------------+---------------- pg_toast | pg_toast_33953 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \d+ pg_toast.pg_toast_33953</code> </pre><pre> <code class="plaintext hljs">TOAST table "pg_toast.pg_toast_33953" Column | Type | Storage ------------+---------+--------- chunk_id | oid | plain chunk_seq | integer | plain chunk_data | bytea | plain</code> </pre><br>  Il est raisonnable que la strat√©gie "simple" soit appliqu√©e aux toasts dans lesquels la ligne est d√©coup√©e: il n'y a pas de TOAST de deuxi√®me niveau. <br><br>  PostgreSQL cache mieux l'index, mais il n'est pas difficile de le trouver non plus: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> indexrelid::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_index <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> indrelid = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'pg_toast_33953'</span></span> );</code> </pre><pre> <code class="plaintext hljs"> indexrelid ------------------------------- pg_toast.pg_toast_33953_index (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \d pg_toast.pg_toast_33953_index</code> </pre><pre> <code class="plaintext hljs">Unlogged index "pg_toast.pg_toast_33953_index" Column | Type | Key? | Definition -----------+---------+------+------------ chunk_id | oid | yes | chunk_id chunk_seq | integer | yes | chunk_seq primary key, btree, for table "pg_toast.pg_toast_33953"</code> </pre><br>  La colonne "client" utilise la strat√©gie "√©tendue": ses valeurs seront compress√©es.  V√©rifions: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> client = repeat(<span class="hljs-string"><span class="hljs-string">'A'</span></span>,<span class="hljs-number"><span class="hljs-number">3000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_toast.pg_toast_33953;</code> </pre><pre> <code class="plaintext hljs"> chunk_id | chunk_seq | chunk_data ----------+-----------+------------ (0 rows)</code> </pre><br>  Il n'y a rien dans la table TOAST: les caract√®res r√©p√©titifs sont tr√®s bien compress√©s et apr√®s compression, la valeur correspond √† une page de table habituelle. <br><br>  Et maintenant, laissez le nom du client compos√© de caract√®res al√©atoires: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> client = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> string_agg( chr(trunc(<span class="hljs-number"><span class="hljs-number">65</span></span>+random()*<span class="hljs-number"><span class="hljs-number">26</span></span>)::<span class="hljs-type"><span class="hljs-type">integer</span></span>), <span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3000</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RETURNING</span></span> left(client,<span class="hljs-number"><span class="hljs-number">10</span></span>) || <span class="hljs-string"><span class="hljs-string">'...'</span></span> || right(client,<span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ------------------------- TCKGKZZSLI...RHQIOLWRRX (1 row)</code> </pre><br>  Une telle s√©quence ne peut pas √™tre compress√©e et elle entre dans la table TOAST: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> chunk_id, chunk_seq, length(chunk_data), left(encode(chunk_data,<span class="hljs-string"><span class="hljs-string">'escape'</span></span>)::<span class="hljs-type"><span class="hljs-type">text</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) || <span class="hljs-string"><span class="hljs-string">'...'</span></span> || right(encode(chunk_data,<span class="hljs-string"><span class="hljs-string">'escape'</span></span>)::<span class="hljs-type"><span class="hljs-type">text</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_toast.pg_toast_33953;</code> </pre><pre> <code class="plaintext hljs"> chunk_id | chunk_seq | length | ?column? ----------+-----------+--------+------------------------- 34000 | 0 | 2000 | TCKGKZZSLI...ZIPFLOXDIW 34000 | 1 | 1000 | DDXNNBQQYH...RHQIOLWRRX (2 rows)</code> </pre><br>  Nous pouvons voir que les donn√©es sont divis√©es en morceaux de 2000 octets. <br><br>  Lorsqu'une valeur longue est accessible, PostgreSQL automatiquement et de mani√®re transparente pour l'application restaure la valeur d'origine et la renvoie au client. <br><br>  Certes, il est assez gourmand en ressources de compresser et de casser puis de restaurer.  Par cons√©quent, stocker des donn√©es massives dans PostgreSQL n'est pas la meilleure id√©e, surtout si elles sont fr√©quemment utilis√©es et que l'utilisation ne n√©cessite pas de logique transactionnelle (par exemple: num√©risation de documents comptables originaux).  Une alternative plus avantageuse consiste √† stocker ces donn√©es sur un syst√®me de fichiers avec les noms de fichiers stock√©s dans le SGBD. <br><br>  La table TOAST n'est utilis√©e que pour acc√©der √† une valeur longue.  En outre, sa propre concurrence de mutiversion est prise en charge pour une table TOAST: √† moins qu'une mise √† jour des donn√©es touche une valeur longue, une nouvelle version de ligne r√©f√©rencera la m√™me valeur dans la table TOAST, ce qui √©conomise de l'espace. <br><br>  Notez que TOAST ne fonctionne que pour les tables, mais pas pour les index.  Cela impose une limitation sur la taille des cl√©s √† indexer. <br><blockquote>  Pour plus de d√©tails sur la structure de donn√©es interne, vous pouvez lire la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> . <br></blockquote><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Continuez √† lire</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr469087/">https://habr.com/ru/post/fr469087/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr469073/index.html">D√©riv√© discret ou r√©sum√© de la somme des s√©ries</a></li>
<li><a href="../fr469075/index.html">Grokay DLR</a></li>
<li><a href="../fr469077/index.html">Nouveau cours Python de Microsoft [en anglais]</a></li>
<li><a href="../fr469079/index.html">Python dans Visual Studio Code: mise √† jour de l'extension de septembre</a></li>
<li><a href="../fr469085/index.html">Nous retirons le logiciel du microcontr√¥leur prot√©g√© par mot de passe Renesas M16C</a></li>
<li><a href="../fr469093/index.html">Comparaison de biblioth√®ques CLI moins populaires et peu utilis√©es: falaise, plac, plumbum et autres (partie 2)</a></li>
<li><a href="../fr469095/index.html">Mises √† jour de ML.NET et de Model Builder publi√©es: Quoi de neuf</a></li>
<li><a href="../fr469097/index.html">Serveur Web CentOS 8 avec php7, node.js et redis</a></li>
<li><a href="../fr469099/index.html">Tester les t√¢ches lors de l'entretien avec le d√©veloppeur - est-ce que cela a du sens?</a></li>
<li><a href="../fr469101/index.html">Apprendre l'anglais: comment apprendre √† parler en tant que locuteur natif</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>