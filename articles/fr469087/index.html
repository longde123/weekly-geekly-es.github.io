<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚴🏼 👩‍👩‍👦‍👦 👩🏿‍🎓 MVCC dans PostgreSQL-2. Fourches, limes, pages 🏔️ 🧕🏽 🐓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="La dernière fois, nous avons parlé de cohérence des données, examiné la différence entre les niveaux d'isolement des transactions du point de vue de l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC dans PostgreSQL-2. Fourches, limes, pages</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/469087/">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">La dernière fois,</a> nous avons parlé de cohérence des données, examiné la différence entre les niveaux d'isolement des transactions du point de vue de l'utilisateur et compris pourquoi il était important de le savoir.  Nous commençons maintenant à explorer comment PostgreSQL implémente l'isolement de cliché et la concurrence multiversionnelle. <br><br>  Dans cet article, nous verrons comment les données sont physiquement disposées dans des fichiers et des pages.  Cela nous éloigne de la discussion de l'isolement, mais une telle digression est nécessaire pour comprendre ce qui suit.  Nous devrons déterminer comment le stockage des données est organisé à un faible niveau. <br><br><h1>  Les relations </h1><br>  Si vous regardez à l'intérieur des tables et des index, il s'avère qu'ils sont organisés de manière similaire.  Les deux sont des objets de base de données qui contiennent des données composées de lignes. <br><br>  Il ne fait aucun doute qu'une table est constituée de lignes, mais cela est moins évident pour un index.  Cependant, imaginez un arbre B: il se compose de nœuds qui contiennent des valeurs indexées et des références à d'autres nœuds ou lignes de table.  Ce sont ces nœuds qui peuvent être considérés comme des lignes d'index, et en fait, ils le sont. <br><br>  En fait, quelques autres objets sont organisés de la même manière: des séquences (essentiellement des tables à une seule ligne) et des vues matérialisées (essentiellement des tables qui se souviennent de la requête).  Et il y a aussi des vues régulières, qui ne stockent pas les données elles-mêmes, mais sont dans tous les autres sens similaires aux tableaux. <br><br>  Tous ces objets dans PostgreSQL sont appelés la <em>relation de</em> mots communs.  Ce mot est extrêmement impropre car c'est un terme de la théorie relationnelle.  Vous pouvez faire un parallèle entre une relation et une table (vue), mais certainement pas entre une relation et un index.  Mais il en est ainsi: l'origine académique de PostgreSQL se manifeste.  Il me semble que ce sont les tableaux et les vues qui ont été appelés ainsi en premier, et le reste a enflé avec le temps. <br><a name="habracut"></a><br>  Pour être plus simple, nous discuterons plus loin des tables et des index, mais les autres <em>relations</em> sont organisées exactement de la même manière. <br><br><h1>  Fourches et limes </h1><br>  Habituellement, plusieurs <em>fourches</em> correspondent à chaque relation.  Les fourches peuvent avoir plusieurs types, et chacun d'eux contient un certain type de données. <br><br>  S'il y a un fork, il est d'abord représenté par le seul <em>fichier</em> .  Le nom de fichier est un identifiant numérique, qui peut être ajouté par une fin qui correspond au nom de la fourche. <br><br>  Le fichier grandit progressivement et lorsque sa taille atteint 1 Go, un nouveau fichier du même fork est créé (des fichiers comme ceux-ci sont parfois appelés <em>segments</em> ).  Le numéro ordinal du segment est ajouté à la fin du nom de fichier. <br><br>  La limitation de 1 Go de la taille du fichier est apparue historiquement pour prendre en charge différents systèmes de fichiers, dont certains ne peuvent pas traiter des fichiers de plus grande taille.  Vous pouvez modifier cette limitation lors de la construction de PostgreSQL ( <code>./configure --with-segsize</code> ). <br><br>  Ainsi, plusieurs fichiers sur disque peuvent correspondre à une seule relation.  Par exemple, pour une petite table, il y en aura trois. <br><br>  Tous les fichiers d'objets qui appartiennent à un espace de table et à une base de données seront stockés dans un répertoire.  Vous devez avoir cela à l'esprit car les systèmes de fichiers ne fonctionnent généralement pas correctement avec un grand nombre de fichiers dans un répertoire. <br><br>  Notez ici que les fichiers, à leur tour, sont divisés en <em>pages</em> (ou <em>blocs</em> ), généralement de 8 Ko.  Nous discuterons un peu plus loin de la structure interne des pages. <br><br><img src="https://habrastorage.org/webt/10/ze/w6/10zew6_pruaxe8amjtx7_6x70tk.png"><br><br>  Voyons maintenant les types de fourches. <br><br>  La <strong>fourche principale</strong> est les données elles-mêmes: les mêmes lignes de table et d'index.  Le fork principal est disponible pour toutes les relations (sauf les vues qui ne contiennent pas de données). <br><br>  Les noms des fichiers du fork principal sont constitués du seul identifiant numérique.  Par exemple, voici le chemin d'accès à la table que nous avons créée la dernière fois: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/41493/41496 (1 row)</code> </pre><br>  D'où proviennent ces identifiants?  Le répertoire "base" correspond au tablespace "pg_default".  Le sous-répertoire suivant, correspondant à la base de données, est où se trouve le fichier d'intérêt: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_database <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> datname = <span class="hljs-string"><span class="hljs-string">'test'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> oid ------- 41493 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relfilenode <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>;</code> </pre><pre> <code class="plaintext hljs"> relfilenode ------------- 41496 (1 row)</code> </pre><br>  Le chemin est relatif, il est spécifié à partir du répertoire de données (PGDATA).  De plus, pratiquement tous les chemins dans PostgreSQL sont spécifiés à partir de PGDATA.  Grâce à cela, vous pouvez déplacer PGDATA en toute sécurité vers un emplacement différent - rien ne le limite (sauf qu'il peut être nécessaire de définir le chemin d'accès aux bibliothèques dans LD_LIBRARY_PATH). <br><br>  De plus, en examinant le système de fichiers: <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41496</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 8192 /var/lib/postgresql/11/main/base/41493/41496</code> </pre><br>  La <strong>fourchette d'initialisation</strong> n'est disponible que pour les tables non enregistrées (créées avec UNLOGGED spécifié) et leurs index.  Des objets comme ceux-ci ne diffèrent en rien des objets normaux, sauf que les opérations avec eux ne sont pas enregistrées dans le journal d'écriture anticipée (WAL).  Pour cette raison, il est plus rapide de travailler avec eux, mais il est impossible de récupérer les données dans l'état cohérent en cas de défaillance.  Par conséquent, lors d'une récupération, PostgreSQL supprime simplement toutes les fourches de ces objets et écrit le fork d'initialisation à la place du fork principal.  Il en résulte un objet vide.  Nous discuterons de la journalisation en détail, mais dans une autre série. <br><br>  La table "comptes" est enregistrée, et par conséquent, elle n'a pas de fourche d'initialisation.  Mais pour expérimenter, nous pouvons désactiver la journalisation: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">UNLOGGED</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pg_relation_filepath(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>);</code> </pre><pre> <code class="plaintext hljs"> pg_relation_filepath ---------------------- base/41493/41507 (1 row)</code> </pre><br>  L'exemple précise qu'une possibilité d'activer et de désactiver la journalisation à la volée est associée à la réécriture des données dans des fichiers avec des noms différents. <br><br>  Un fork d'initialisation a le même nom que le fork principal, mais avec le suffixe "_init": <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_init</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 0 /var/lib/postgresql/11/main/base/41493/41507_init</code> </pre><br>  La <strong>carte de l'espace libre</strong> est une fourchette qui assure le suivi de la disponibilité de l'espace libre à l'intérieur des pages.  Cet espace est en constante évolution: il diminue lorsque de nouvelles versions de lignes sont ajoutées et augmente lors de l'aspiration.  La carte d'espace libre est utilisée lors de l'insertion de nouvelles versions de lignes afin de trouver rapidement une page appropriée, où les données à ajouter conviendront. <br><br>  Le nom de la carte d'espace libre a le suffixe "_fsm".  Mais ce fichier n'apparaît pas immédiatement, mais seulement lorsque le besoin s'en fait sentir.  La façon la plus simple d'y parvenir est de passer l'aspirateur sur une table (nous expliquerons pourquoi le moment venu): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">VACUUM</span></span> accounts;</code> </pre><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_fsm</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 24576 /var/lib/postgresql/11/main/base/41493/41507_fsm</code> </pre><br>  La <strong>carte de visibilité</strong> est un fork où les pages qui ne contiennent que des versions de lignes à jour sont marquées par un bit.  En gros, cela signifie que lorsqu'une transaction essaie de lire une ligne d'une telle page, la ligne peut être affichée sans vérifier sa visibilité.  Dans les prochains articles, nous expliquerons en détail comment cela se produit. <br><br><pre> <code class="plaintext hljs">postgres$ ls -l --time-style=+ /var/lib/postgresql/11/main/base/41493/41507_vm</code> </pre><pre> <code class="plaintext hljs">-rw------- 1 postgres postgres 8192 /var/lib/postgresql/11/main/base/41493/41507_vm</code> </pre><br><h1>  Pages </h1><br>  Comme déjà mentionné, les fichiers sont logiquement divisés en pages. <br><br>  Une page a généralement une taille de 8 Ko.  La taille peut être modifiée dans certaines limites (16 Ko ou 32 Ko), mais uniquement pendant la génération ( <code>./configure --with-blocksize</code> ).  Une instance construite et exécutée ne peut fonctionner qu'avec des pages de même taille. <br><br>  Quelle que soit la fourchette à laquelle appartiennent les fichiers, le serveur les utilise de manière assez similaire.  Les pages sont d'abord lues dans le cache tampon, où les processus peuvent les lire et les modifier;  puis lorsque le besoin s'en fait sentir, ils sont renvoyés sur le disque. <br><br>  Chaque page a un partitionnement interne et contient en général les partitions suivantes: <br><br><pre>        0 + ----------------------------------- +
           |  en-tête |
       24 + ----------------------------------- +
           |  tableau de pointeurs vers les versions de ligne |
    inférieur + ----------------------------------- +
           |  espace libre |
    supérieur + ----------------------------------- +
           |  versions de ligne |
  spécial + ----------------------------------- +
           |  espace spécial |
 taille de page + ----------------------------------- +
</pre><br>  Vous pouvez facilement connaître les tailles de ces partitions en utilisant la page d'extension "research" inspecter: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXTENSION</span></span> pageinspect; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> lower, upper, special, pagesize <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> page_header(get_raw_page(<span class="hljs-string"><span class="hljs-string">'accounts'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>));</code> </pre><pre> <code class="plaintext hljs"> lower | upper | special | pagesize -------+-------+---------+---------- 40 | 8016 | 8192 | 8192 (1 row)</code> </pre><br>  Ici, nous regardons l'en- <strong>tête</strong> de la toute première page (zéro) du tableau.  En plus de la taille des autres zones, l'en-tête contient des informations différentes sur la page, ce qui ne nous intéresse pas encore. <br><br>  Au bas de la page, il y a l' <strong>espace spécial</strong> , qui est vide dans ce cas.  Il n'est utilisé que pour les index, et même pas pour tous.  "Au fond" reflète ici ce qui est dans l'image;  il peut être plus exact de dire "dans des adresses élevées". <br><br>  Après l'espace spécial, les <strong>versions de ligne</strong> sont localisées, c'est-à-dire ces mêmes données que nous stockons dans la table plus quelques informations internes. <br><br>  En haut d'une page, juste après l'en-tête, il y a la table des matières: le <strong>tableau de pointeurs</strong> vers les versions de ligne disponibles dans la page. <br><br>  <strong>L'espace libre</strong> peut être laissé entre les versions de ligne et les pointeurs (cet espace libre est conservé dans la carte de l'espace libre).  Notez qu'il n'y a pas de fragmentation de la mémoire à l'intérieur d'une page - tout l'espace libre est représenté par une zone contiguë. <br><br><h2>  Pointeurs </h2><br>  Pourquoi les pointeurs vers les versions de ligne sont-ils nécessaires?  Le fait est que les lignes d'index doivent en quelque sorte faire référence aux versions de ligne dans la table.  Il est clair que la référence doit contenir le numéro de fichier, le numéro de la page dans le fichier et une indication de la version de la ligne.  Nous pourrions utiliser le décalage depuis le début de la page comme indicateur, mais ce n'est pas pratique.  Nous ne pourrions pas déplacer une version de ligne à l'intérieur de la page car cela casserait les références disponibles.  Et cela entraînerait la fragmentation de l'espace à l'intérieur des pages et d'autres conséquences gênantes.  Par conséquent, l'index fait référence au numéro de pointeur et le pointeur fait référence à l'emplacement actuel de la version de ligne dans la page.  Et c'est l'adressage indirect. <br><br>  Chaque pointeur occupe exactement quatre octets et contient: <br><br><ul><li>  une référence à la version en ligne </li><li>  la taille de cette version en ligne </li><li>  plusieurs octets pour déterminer l'état de la version de ligne </li></ul><br><h2>  Format des données </h2><br>  Le format des données sur le disque est exactement le même que la représentation des données dans la RAM.  La page est lue dans le cache tampon "en l'état", sans aucune conversion.  Par conséquent, les fichiers de données d'une plate-forme s'avèrent incompatibles avec d'autres plates-formes. <br><br>  Par exemple, dans l'architecture X86, l'ordre des octets va des octets les moins significatifs aux octets les plus significatifs (little-endian), z / Architecture utilise l'ordre inverse (big-endian), et dans ARM l'ordre peut être inversé. <br><br>  De nombreuses architectures permettent l'alignement des données sur les limites des mots machine.  Par exemple, sur un système x86 32 bits, les nombres entiers (type "entier", qui occupe 4 octets) seront alignés sur une limite de mots de 4 octets, de la même manière que les nombres à double précision (type "double précision" , qui occupe 8 octets).  Et sur un système 64 bits, les nombres à double précision seront alignés sur une limite de mots de 8 octets.  C'est une raison de plus d'incompatibilité. <br><br>  En raison de l'alignement, la taille de la ligne du tableau dépend de l'ordre des champs.  Habituellement, cet effet n'est pas très visible, mais parfois, il peut entraîner une croissance significative de la taille.  Par exemple, si des champs de types «char (1)» et «integer» sont entrelacés, généralement 3 octets entre eux sont perdus.  Pour plus de détails à ce sujet, vous pouvez consulter la présentation de Nikolay Shaplov " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tuple internals</a> ". <br><br><h1>  Versions en ligne et TOAST </h1><br>  Nous discuterons des détails de la structure interne des versions de ligne la prochaine fois.  À ce stade, il est seulement important pour nous de savoir que chaque version doit correspondre complètement à une page: PostgreSQL n'a aucun moyen de "prolonger" la ligne à la page suivante.  La technique de stockage des attributs surdimensionnés (TOAST) est utilisée à la place.  Le nom lui-même indique qu'une ligne peut être découpée en toasts. <br><br>  Blague à part, TOAST implique plusieurs stratégies.  Nous pouvons transmettre de longues valeurs d'attribut à une table interne séparée après les avoir divisées en petits morceaux de pain grillé.  Une autre option consiste à compresser une valeur afin que la version de ligne tienne sur une page standard.  Et nous pouvons faire les deux: d'abord compresser puis rompre et transmettre. <br><br>  Pour chaque table principale, une table TOAST distincte peut être créée si nécessaire, une pour tous les attributs (avec un index dessus).  La disponibilité d'attributs potentiellement longs détermine ce besoin.  Par exemple, si une table a une colonne de type "numérique" ou "texte", la table TOAST sera immédiatement créée même si les valeurs longues ne seront pas utilisées. <br><br>  Puisqu'une table TOAST est essentiellement une table ordinaire, elle a le même ensemble de fourches.  Et cela double le nombre de fichiers qui correspondent à une table. <br><br>  Les stratégies initiales sont définies par les types de données de la colonne.  Vous pouvez les consulter à l'aide de la commande <code>\d+</code> dans psql, mais comme elle génère en outre de nombreuses autres informations, nous interrogerons le catalogue système: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> attname, atttypid::<span class="hljs-type"><span class="hljs-type">regtype</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> attstorage <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'p'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'plain'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'e'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'external'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'m'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'main'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-string"><span class="hljs-string">'x'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'extended'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">storage</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_attribute <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> attrelid = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span>::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attnum &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre><pre> <code class="plaintext hljs"> attname | atttypid | storage ---------+----------+---------- id | integer | plain number | text | extended client | text | extended amount | numeric | main (4 rows)</code> </pre><br>  Les noms des stratégies signifient: <br><br><ul><li>  plain - TOAST n'est pas utilisé (utilisé pour les types de données connus pour être courts, tels que "entier"). </li><li>  étendu - la compression et le stockage dans une table TOAST distincte sont autorisés </li><li>  external - les valeurs longues sont stockées dans la table TOAST sans compression. </li><li>  main - les valeurs longues sont d'abord compressées et n'entrent dans la table TOAST que si la compression n'a pas aidé. </li></ul><br>  En général, l'algorithme est le suivant.  PostgreSQL vise à ce qu'au moins quatre lignes correspondent à une page.  Par conséquent, si la taille de la ligne dépasse un quart de la page, l'en-tête pris en compte (2040 octets pour une page ordinaire de 8K), TOAST doit être appliqué à une partie des valeurs.  Nous suivons l'ordre décrit ci-dessous et nous nous arrêtons dès que la ligne ne dépasse plus le seuil: <br><br><ol><li>  Nous passons d'abord par les attributs avec les stratégies "externe" et "étendue" de l'attribut le plus long au plus court.  Les attributs «étendus» sont compressés (s'il est efficace) et si la valeur elle-même dépasse un quart de la page, elle pénètre immédiatement dans la table TOAST.  Les attributs "externes" sont traités de la même manière, mais ne sont pas compressés. </li><li>  Si après la première passe, la version ligne ne correspond pas encore à la page, nous transmettons les attributs restants avec les stratégies "externe" et "étendue" à la table TOAST. </li><li>  Si cela n'a pas aidé non plus, nous essayons de compresser les attributs avec la stratégie "principale", mais les laissons dans la page du tableau. </li><li>  Et seulement si après cela, la ligne n'est pas assez courte, les attributs "principaux" entrent dans la table TOAST. </li></ol><br>  Parfois, il peut être utile de modifier la stratégie de certaines colonnes.  Par exemple, s'il est connu à l'avance que les données d'une colonne ne peuvent pas être compressées, nous pouvons définir la stratégie "externe" pour celle-ci, ce qui nous permet de gagner du temps en évitant les tentatives de compression inutiles.  Cela se fait comme suit: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">ALTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">COLUMN</span></span> number <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> <span class="hljs-keyword"><span class="hljs-keyword">STORAGE external</span></span>;</code> </pre><br>  En relançant la requête, nous obtenons: <br><br><pre> <code class="plaintext hljs"> attname | atttypid | storage ---------+----------+---------- id | integer | plain number | text | external client | text | extended amount | numeric | main</code> </pre><br>  Les tables et index TOAST sont situés dans le schéma pg_toast distinct et ne sont donc généralement pas visibles.  Pour les tables temporaires, le schéma "pg_toast_temp_ <em>N</em> " est utilisé de la même manière que l'habituel "pg_temp_ <em>N</em> ". <br><br>  Bien sûr, si vous aimez, personne ne vous gênera d'espionner la mécanique interne du processus.  Disons que dans le tableau «comptes», il y a trois attributs potentiellement longs et qu'il doit donc y avoir un tableau TOAST.  Le voici: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> relnamespace::<span class="hljs-type"><span class="hljs-type">regnamespace</span></span>, relname <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> reltoastrelid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'accounts'</span></span> );</code> </pre><pre> <code class="plaintext hljs"> relnamespace | relname --------------+---------------- pg_toast | pg_toast_33953 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \d+ pg_toast.pg_toast_33953</code> </pre><pre> <code class="plaintext hljs">TOAST table "pg_toast.pg_toast_33953" Column | Type | Storage ------------+---------+--------- chunk_id | oid | plain chunk_seq | integer | plain chunk_data | bytea | plain</code> </pre><br>  Il est raisonnable que la stratégie "simple" soit appliquée aux toasts dans lesquels la ligne est découpée: il n'y a pas de TOAST de deuxième niveau. <br><br>  PostgreSQL cache mieux l'index, mais il n'est pas difficile de le trouver non plus: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> indexrelid::<span class="hljs-type"><span class="hljs-type">regclass</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_index <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> indrelid = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-type"><span class="hljs-type">oid</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> relname = <span class="hljs-string"><span class="hljs-string">'pg_toast_33953'</span></span> );</code> </pre><pre> <code class="plaintext hljs"> indexrelid ------------------------------- pg_toast.pg_toast_33953_index (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; \d pg_toast.pg_toast_33953_index</code> </pre><pre> <code class="plaintext hljs">Unlogged index "pg_toast.pg_toast_33953_index" Column | Type | Key? | Definition -----------+---------+------+------------ chunk_id | oid | yes | chunk_id chunk_seq | integer | yes | chunk_seq primary key, btree, for table "pg_toast.pg_toast_33953"</code> </pre><br>  La colonne "client" utilise la stratégie "étendue": ses valeurs seront compressées.  Vérifions: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> client = repeat(<span class="hljs-string"><span class="hljs-string">'A'</span></span>,<span class="hljs-number"><span class="hljs-number">3000</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_toast.pg_toast_33953;</code> </pre><pre> <code class="plaintext hljs"> chunk_id | chunk_seq | chunk_data ----------+-----------+------------ (0 rows)</code> </pre><br>  Il n'y a rien dans la table TOAST: les caractères répétitifs sont très bien compressés et après compression, la valeur correspond à une page de table habituelle. <br><br>  Et maintenant, laissez le nom du client composé de caractères aléatoires: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> client = ( <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> string_agg( chr(trunc(<span class="hljs-number"><span class="hljs-number">65</span></span>+random()*<span class="hljs-number"><span class="hljs-number">26</span></span>)::<span class="hljs-type"><span class="hljs-type">integer</span></span>), <span class="hljs-string"><span class="hljs-string">''</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> generate_series(<span class="hljs-number"><span class="hljs-number">1</span></span>,<span class="hljs-number"><span class="hljs-number">3000</span></span>) ) <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> id = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RETURNING</span></span> left(client,<span class="hljs-number"><span class="hljs-number">10</span></span>) || <span class="hljs-string"><span class="hljs-string">'...'</span></span> || right(client,<span class="hljs-number"><span class="hljs-number">10</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ?column? ------------------------- TCKGKZZSLI...RHQIOLWRRX (1 row)</code> </pre><br>  Une telle séquence ne peut pas être compressée et elle entre dans la table TOAST: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> chunk_id, chunk_seq, length(chunk_data), left(encode(chunk_data,<span class="hljs-string"><span class="hljs-string">'escape'</span></span>)::<span class="hljs-type"><span class="hljs-type">text</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) || <span class="hljs-string"><span class="hljs-string">'...'</span></span> || right(encode(chunk_data,<span class="hljs-string"><span class="hljs-string">'escape'</span></span>)::<span class="hljs-type"><span class="hljs-type">text</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_toast.pg_toast_33953;</code> </pre><pre> <code class="plaintext hljs"> chunk_id | chunk_seq | length | ?column? ----------+-----------+--------+------------------------- 34000 | 0 | 2000 | TCKGKZZSLI...ZIPFLOXDIW 34000 | 1 | 1000 | DDXNNBQQYH...RHQIOLWRRX (2 rows)</code> </pre><br>  Nous pouvons voir que les données sont divisées en morceaux de 2000 octets. <br><br>  Lorsqu'une valeur longue est accessible, PostgreSQL automatiquement et de manière transparente pour l'application restaure la valeur d'origine et la renvoie au client. <br><br>  Certes, il est assez gourmand en ressources de compresser et de casser puis de restaurer.  Par conséquent, stocker des données massives dans PostgreSQL n'est pas la meilleure idée, surtout si elles sont fréquemment utilisées et que l'utilisation ne nécessite pas de logique transactionnelle (par exemple: numérisation de documents comptables originaux).  Une alternative plus avantageuse consiste à stocker ces données sur un système de fichiers avec les noms de fichiers stockés dans le SGBD. <br><br>  La table TOAST n'est utilisée que pour accéder à une valeur longue.  En outre, sa propre concurrence de mutiversion est prise en charge pour une table TOAST: à moins qu'une mise à jour des données touche une valeur longue, une nouvelle version de ligne référencera la même valeur dans la table TOAST, ce qui économise de l'espace. <br><br>  Notez que TOAST ne fonctionne que pour les tables, mais pas pour les index.  Cela impose une limitation sur la taille des clés à indexer. <br><blockquote>  Pour plus de détails sur la structure de données interne, vous pouvez lire la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> . <br></blockquote><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Continuez à lire</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr469087/">https://habr.com/ru/post/fr469087/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr469073/index.html">Dérivé discret ou résumé de la somme des séries</a></li>
<li><a href="../fr469075/index.html">Grokay DLR</a></li>
<li><a href="../fr469077/index.html">Nouveau cours Python de Microsoft [en anglais]</a></li>
<li><a href="../fr469079/index.html">Python dans Visual Studio Code: mise à jour de l'extension de septembre</a></li>
<li><a href="../fr469085/index.html">Nous retirons le logiciel du microcontrôleur protégé par mot de passe Renesas M16C</a></li>
<li><a href="../fr469093/index.html">Comparaison de bibliothèques CLI moins populaires et peu utilisées: falaise, plac, plumbum et autres (partie 2)</a></li>
<li><a href="../fr469095/index.html">Mises à jour de ML.NET et de Model Builder publiées: Quoi de neuf</a></li>
<li><a href="../fr469097/index.html">Serveur Web CentOS 8 avec php7, node.js et redis</a></li>
<li><a href="../fr469099/index.html">Tester les tâches lors de l'entretien avec le développeur - est-ce que cela a du sens?</a></li>
<li><a href="../fr469101/index.html">Apprendre l'anglais: comment apprendre à parler en tant que locuteur natif</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>