<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎧 🚵🏽 👨🏻‍🌾 Erfahrung in der Verwendung von LCD-Displays auf Basis von MELT-Produkten 🌚 🌖 👨🏿‍🚀</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Dieser Artikel ist einer aufregenden Abenteuerquest gewidmet, die ich vor anderthalb Jahren durchlaufen musste, um einen aktualisierten externen Senso...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Erfahrung in der Verwendung von LCD-Displays auf Basis von MELT-Produkten</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430828/"> Dieser Artikel ist einer aufregenden Abenteuerquest gewidmet, die ich vor anderthalb Jahren durchlaufen musste, um einen aktualisierten externen Sensor für die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hier in diesem Artikel</a> beschriebene Wetterstation zu erstellen.  Nach den Betriebserfahrungen der Vorgängerversion wollte ich unbedingt einen Sensor mit einer Kontrollanzeige erstellen, damit die kapriziöseste Komponente der Station - der Windgeschwindigkeitssensor - regelmäßig überprüft (und überprüft) werden kann.  Die Abenteuer begannen, als ich anfing, ein Display für diesen Zweck auszuwählen, und aus einer Reihe von Gründen, über die ich mich weiter für die Produkte meiner einheimischen MELT entschied.  Bevor ich jedoch die <s>Methoden des nicht-traditionellen Geschlechtsverkehrs beschreibe,</s> wie ich mit den Produkten dieses von mir gewählten Unternehmens umgehen kann, lohnt es sich, kurz auf den Hauptgrund für all diese grandiose Modernisierung einzugehen, die ich begonnen habe. <br><a name="habracut"></a><br>  In den Kommentaren zu diesem Artikel wurde ich zu Recht auf das Design der Sensoren hingewiesen, dass die Achse eines solchen Geräts eine feste Spitze haben und auf einer ebenso festen Basis ruhen sollte (denken Sie an eine Armbanduhr „auf so vielen Steinen“).  Natürlich wusste ich das, aber dann konnte ich mir keine Möglichkeit vorstellen, eine Lichtachse mit einem scharfen Punkt mit ausreichender Härte zu versehen. Im Gegenteil, ich ging den Weg der Minimierung der Reibung, indem ich eine Messingspitze (für Wetterfahne) oder eine Duralspitze (für Geschwindigkeitssensor) in ein weiches PTFE tauchte (siehe) .Draftsman im angegebenen Artikel).  In vollem Verständnis, dass diese Entscheidung nur vorübergehend und von kurzer Dauer ist und in naher Zukunft etwas Wesentlicheres einfallen muss. <br><br>  Das Ergebnis der letzten beiden Betriebszeiten zeigte jedoch, dass eine solche Lösung durchaus für eine Wetterfahne geeignet ist, die natürlich die fluoroplastische Basis mit einer Messingachse auf das Metall zersägte, ihn aber überhaupt nicht verletzte - minimale Reibung ist dort nicht erforderlich, auch nicht teilweise umgekehrt.  Schlimmer war es mit einem Geschwindigkeitssensor, bei dem nicht nur der Fluoroplast an der Basis gesägt wurde, sondern auch die Spitze selbst aus einem weichen Duraluminium, das zwei Millimeter lang gelöscht wurde.  Infolgedessen wurde zunächst die Startschwelle inakzeptabel erhöht und der Sensor musste modernisiert werden.  Das Anemometer selbst wurde ebenfalls modernisiert, da die Laser-CD, auf deren Grundlage sie von der Sonne geschichtet wurde, ein unordentliches Aussehen erhielt (nun, ich wusste vorher nicht, dass CDs aus zwei Schichten bestehen). <br><br>  Ich hoffe, dass ich Ihnen später mehr über den neuen Sensor erzählen kann, nachdem er zumindest ein wenig in Betrieb ist und Sie sicherstellen können, dass Sie nichts auf einmal ändern müssen (dh nicht früher als zu Beginn des Sommers).  Und jetzt nur noch einige Details zu den Änderungen im Messkreis, da sie sich auf das Hauptthema dieses Artikels beziehen. <br><br><h2>  Über den Sensormesskreis </h2><br>  Im Zusammenhang mit der Absenkung der Startschwelle stellte sich die Frage, wie lange es dauert, die vom Geschwindigkeitssensor kommenden niedrigen Frequenzen zu messen (Einzelheiten finden Sie in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dieser Veröffentlichung</a> zu Methoden zur Messung niedriger Frequenzen).  Um die Schwelle für den künstlichen Start nicht zu begrenzen, sollten wir in diesem Fall Frequenzen ab 1-2 Hertz messen: Wenn man bedenkt, dass der Sensor 16 Löcher in einem Kreis hat (siehe Foto des Sensors <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Originalartikel</a> ), entspricht dies ungefähr einer Umdrehung in 8-16 Sekunden, was offensichtlich niedriger ist als jeder Schwellenwert zum Starten.  Das heißt, das Zeitlimit für das Warten auf das Eintreffen des nächsten Frequenzimpulses sollte mindestens 1 s betragen (siehe den angegebenen Artikel zu Messmethoden). Dies macht Sinn für die Energiespargeschichte: Um eine akzeptable Aktualisierungszeit zu erhalten und gleichzeitig die Daten zu mitteln, um ein Rattern auf dem Display zu vermeiden, Wir müssen den Controller alle zwei Sekunden aufwecken.  Und wenn die Hälfte von ihnen die Zeit braucht, um auf Impulse zu warten, wird keine Energie eingespart - unter Berücksichtigung der Tatsache, dass die emittierende LED des Sensors die ganze Zeit funktioniert hat und etwa 20 mA verbraucht. <br><br><div class="spoiler">  <b class="spoiler_title">Einige Details in Klammern</b> <div class="spoiler_text">  Ich stelle in Klammern fest, dass ich mich im Zusammenhang mit diesem Problem sofort an den aktuellen Zähler erinnerte, der Anfang der achtziger Jahre in unserem Konstruktionsbüro entwickelt wurde, noch bevor alle Arten von Steuerungen auftauchten.  Darin wurde eine echte Vektormittelung implementiert: Die Aufzeichnung aller Messwerte wurde nämlich durch das Signal selbst vom Plattenteller des Geschwindigkeitssensors getaktet - ein ungefähres Analogon zum Nachlauf eines externen Interrupts.  Mit anderen Worten, wenn kein Strom vorhanden ist, wurde keine Aufzeichnung durchgeführt, und die Schaltung verbrauchte nichts - nur Echtzeituhren funktionierten.  Die Schwelle für den Start dieses Drehtellers, der in Form eines <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Laufrads ohne</a> Auftrieb hergestellt wurde, betrug, um die Wahrheit zu sagen, 2-3 cm / s, und das Messgerät zeigte die Richtung durch Drehen des gesamten Körpers an.  Es ist also im Wasser, das 700-mal dichter als Luft ist!  Während der Mittelungszeit, die Stunden betrug, drehte sich ein solches Windrad mindestens einmal um, da es dort fast keine leeren Messungen gab.  Und für eine Wetterstation ist, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">wie bereits erwähnt</a> , eine mathematisch korrekte Mittelungsmethode nicht geeignet, da sie bei Windstille etwas Reales zeigen sollte.  Daher können wir hier nicht auf eine künstlich begrenzte Zeitüberschreitung verzichten, um auf Impulse vom Sensor zu warten. <br></div></div><br>  Es ist möglich, eine komplexe Steuerung des Erwachens des Controllers aus zwei Quellen auszurüsten: normalerweise aufgrund einer externen Unterbrechung durch den Geschwindigkeitssensor (dh während des Wartens auf Impulse vom Sensor wechselt der Controller auch in den Energiesparmodus) und ohne Wind wird er vom Watchdog gezwungen.  Dies wäre nur dann sinnvoll, wenn das Prinzip des Lesens des Geschwindigkeitssensors von optischen zu weniger energieaufwendigen Schaltkreisen geändert wird (nach denen noch gesucht werden muss - der Hallsensor verbraucht beispielsweise 5-10 mA, was grundlegend weniger ist als das optische Design).  Aber alles wurde vereinfacht, weil mein Sensor jetzt von einer Solarbatterie gespeist wird, wodurch ich den Energiesparmodus einfach aufgeben konnte. <br><br>  Um die Messwerte zu messen, habe ich mich nicht mit Timern beschäftigt oder Arduino millis () gezählt, sondern einfach einen primitiven externen Frequenzgenerator mit einer Zeitspanne von ca. 1,5 Sekunden auf Timer 555 eingerichtet: <br><br><img src="https://habrastorage.org/webt/hn/o0/ig/hno0igehcu7spf5ge0q4fx9jynu.png" width="400"><br>  Wie wir uns erinnern, verwendet die Sensorschaltung den „nackten“ Atmega328-Controller im DIP-Paket, der über Uno programmiert und am Sockel installiert wurde. Arduino selbst wird nur für das Prototyping verwendet.  Der Generatorausgang wurde mit dem Interrupt-Pin INT0, Pin 4 der Mikroschaltung (Pin D2 der Uno-Karte) verbunden.  Die positive Differenzunterbrechung (RISING) setzt ein bestimmtes Flag, nach dem der nächste Messwert im Hauptzyklus genommen wird.  Die Frequenz vom Sensor wird ebenfalls mit der Interrupt-Methode gemessen (der Sensorausgang ist mit dem Interrupt-Eingang INT1, Pin 4 (D3), verbunden, siehe die letzte Methode <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im selben Artikel</a> ), da die maximale Gesamtwartezeit doppelt so lang ist wie die gemessene Frequenz.  Bei einer Zeitüberschreitung von 1 Sekunde beträgt die minimale gemessene Frequenz somit 2 Hz (eine Umdrehung des Anemometers in 8 Sekunden).  In jedem vierten Zyklus erfolgt eine Mittelwertbildung und die fertigen Daten werden an das Hauptmodul gesendet, dh die Messwerte werden ungefähr alle 6 Sekunden aktualisiert. <br><br>  Die gesamte Geschichte mit einem aktualisierten Sensor muss kalibriert und regelmäßig überprüft werden, um festzustellen, ob die Reibung zugenommen hat. Dabei werden die Messwerte mit einem manuellen Anemometer verglichen.  Daher ist es sehr unpraktisch, wenn die Messwerte an einer Stelle (im Haus) angezeigt werden und der externe Sensor an einer völlig anderen Stelle installiert wird - im Gartenpavillon.  Es stellte sich die Frage nach der Installation eines Steuer-LCD im Sensorgehäuse.  Da Schönheit hier nicht erforderlich ist, sind die Informationsanforderungen dafür minimal: Eine einzeilige Anzeige mit 10 Zeichen reicht aus.  Die geometrischen Anforderungen sind jedoch recht streng: Das Display muss in das vorhandene Gehäuse mit einer Breite von 70 mm passen.  Ich muss sagen, dass ich aufgrund meiner organischen Abneigung gegen LCD-Displays (schwach, kontrastarm, mit kleinen Buchstaben, ekelhafter Qualität der Hintergrundbeleuchtung und viel Verbrauch, dazu später mehr) fast nicht über das Angebot im Einzelhandel informiert bin.  Und so wurde sofort klar, dass die Displays, nach denen ich brauchte, im Verkauf sehr gesucht werden mussten: Das in Geschäften vorherrschende 16x2-LCD-Standarddisplay hat eine 80 mm lange Platine und passt nicht in meinen Sensor, und alle anderen Typen sind unabhängig davon noch größer von der Firma.  In der Natur gibt es natürlich kleinere Sorten, aber dann in der Natur und nicht im heimischen Einzelhandel. <br><br><h2>  Lösung: oh MELT! </h2><br>  Am Ende entdeckte ich zwei MELTs gleichzeitig, die wunderbar zu meiner Aufgabe passten.  Der erste von ihnen ist ein einzeiliger 10-stelliger MT-10S1 mit einem Controller, der laut Hersteller " <i>HD44780 von HITACHI und KS0066 von SAMSUNG ähnelt</i> ".  Es hat ziemlich große Zeichen: mehr als 8 mm hoch, was eigentlich für chinesische Displays mit viel größeren Größen charakteristisch ist.  Die Breite der Platte beträgt 66 mm, die Abmessungen des hervorstehenden Bildschirms (außen) betragen 62 x 19,5.  Der Verbrauch in diesem Fall stört mich nicht sehr (da der externe Sensor von einer Solarbatterie mit offensichtlich größerer Leistung als erforderlich gespeist wird), aber aus Gewohnheit stellte ich beim Betrachten der Zeile im Datenblatt fest, dass er auch kleiner als gewöhnlich ist - 0,7 mA (alle gewöhnlichen LCDs) Displays auf Analoga des HD44780 verbrauchen ab 1,2 mA).  Es gibt immer noch eine Hintergrundbeleuchtung für den Haufen, wie es für all diese Typen üblich ist - ziemlich elend und gleichzeitig viel Energie verbrauchend. <br><br><img src="https://habrastorage.org/webt/6h/j2/wp/6hj2wpcmpeo_32v2pui7fxdbqwm.png" width="400"><br><br>  Das zweite Display des MT-10T7 ist noch erstaunlicher: Genau in den gleichen Abmessungen passen 10 Sieben-Segment-Ziffern mit einer Höhe von bis zu 13 mm.  Einige Verdächtigungen wurden durch eine nicht standardmäßige und anscheinend selbst erstellte Schnittstelle verursacht (für die das Beispiel der Programmierung im verbalen Pseudocode sogar im Datenblatt angegeben ist).  Das Display enthält keine echte Steuerung: Es gibt eine Reihe von statischen Latch-Triggern, die durch kombinatorische Logik gesteuert werden.  Dank dieser Einfachheit verbraucht dieses gesamte Design nur 30 μA, das heißt, es ist wirklich für Geräte geeignet, die rund um die Uhr mit Batteriestrom betrieben werden (der Verbrauch von 1,4 mA in herkömmlichen Displays und sogar 0,7 mA in MT-10S1 ist viel höher als für solche zulässig Anwendung des Wertes - Berechnen Sie selbst, wie lange ein solches Display funktioniert, auch ohne Berücksichtigung der übrigen Komponenten des Gerätes (z. B. AAA-Batterien mit einer Kapazität von ca. 1500 mAh). <br><br><img src="https://habrastorage.org/webt/4c/dv/ki/4cdvkitbls9tkoihtq7swvmauly.png" width="400"><br><br>  Kurz gesagt, geben Sie zwei! <br><br><h2>  MT-10T7 </h2><br>  Ein Versuch, den im Datenblatt beschriebenen Algorithmus für MT-10T7 (sowohl auf Arduino als auch in reinem Assembler) unabhängig zu reproduzieren, führte nicht zum Erfolg.  Was falsch gemacht wurde, verstand ich nicht, weil ich auf <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">diese Publikation stieß</a> , in der der Autor (eshkinkot) ein sehr gut geschriebenes und gründlich ausgeführtes Beispiel für den Umgang mit MT-10T7 gab, wonach alles sofort funktionierte.  Wenn jemand interessiert ist, dann <a href="">liegt hier ein</a> modifiziertes Beispiel für eshkinkot, ergänzt durch alle aussagekräftigen Symbole, die auf siebenstelligen Indikatoren gültig sind, einschließlich Buchstaben, die nicht mit den Zahlen übereinstimmen: <br><br><img src="https://habrastorage.org/webt/hz/1u/4_/hz1u4_8n0uolveo40f-osvuitua.jpeg" width="400"><br><img src="https://habrastorage.org/webt/lk/wo/4g/lkwo4gmlxuqqfkmntzs13krvitc.jpeg" width="400"><br><img src="https://habrastorage.org/webt/n6/dd/pj/n6ddpjvxujkqk82ballqqvmua3w.jpeg" width="400"><br><img src="https://habrastorage.org/webt/gm/qq/x0/gmqqx0kwdiutig9tfvwrtuq2mtq.jpeg" width="400"><br><br>  In diesen Bildern wird der Bildschirmkontrast leicht verzerrt, indem der Teiler auf Vo - 18 kOhm (zur Leistung) eingestellt wird: 10 kOhm (zur Masse), obwohl ohne ihn der „Standard“ -Kontrast durchaus akzeptabel ist. <br><br>  Ich habe dann dem angegebenen Beispiel eine Funktion hinzugefügt, die eine beliebige Zahl auf dem Display innerhalb von drei bis vier Dezimalstellen wiedergibt - positiv oder negativ, ganzzahlig oder Gleitkomma, dh die Gesamtzahl der Zeichen kann fünf erreichen: "-12,7", zum Beispiel.  Da der Punkt im Sieben-Segment-Code keine separate Vertrautheit belegt, wird maximal 4 Bits angezeigt. Die Eingabeparameter für diese Funktion sind: a) ein Array (char buf [5]), das eine ACSII-Darstellung der Anzahl enthält, b) die tatsächliche Anzahl der darin enthaltenen Zeichen (ii von 1 bis 5) und c) die Position (pos von 0 bis 9), an der das erste (linke) Zeichen der Zahl gesetzt werden soll (für die Funktionen und die Notation, die auf dem Weg verwendet werden, siehe die angegebene Veröffentlichung von eshkinkot oder im Beispiel durch Bezugnahme): <br><br><div class="spoiler">  <b class="spoiler_title">Funktionscode</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">writeASCIIdig_serial</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> buf[</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">5</span></span></span></span><span class="hljs-function"><span class="hljs-params">], byte ii, byte pos)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">//      { boolean dot; //     //  ,   pos: pos=pos+(4-ii); //  ,    : for (byte i=0; i &lt;= ii; i++) if (buf[i]=='.') pos++; // : for (byte i=0; i &lt;= ii; i++){ // .  ,    : if (buf[i+1]=='.') dot=true; else dot=false; switch (buf[i]) { //decoder ASCII -&gt; 7-  case '0': writeSymbol(pos, DIGIT_ZERO, dot); break; case '1': writeSymbol(pos, DIGIT_ONE, dot); break; case '2': writeSymbol(pos, DIGIT_TWO, dot); break; case '3': writeSymbol(pos, DIGIT_THREE, dot); break; case '4': writeSymbol(pos, DIGIT_FOUR, dot); break; case '5': writeSymbol(pos, DIGIT_FIVE, dot); break; case '6': writeSymbol(pos, DIGIT_SIX, dot); break; case '7': writeSymbol(pos, DIGIT_SEVEN, dot); break; case '8': writeSymbol(pos, DIGIT_EIGHT, dot); break; case '9': writeSymbol(pos, DIGIT_NINE, dot); break; case '-': writeSymbol(pos, SYMBOL_MINUS, dot); break; } //end decoder if (buf[i]!='.') pos++; //  ,  +1  }//end for i }</span></span></span></span></code> </pre> <br></div></div><br>  Das MT-10T7-Modul für die Steuerausgabe von numerischen Werten ist bequemer als gewöhnliche Linienmatrixanzeigen: Es hat große Zahlen, und der Dezimalpunkt belegt keine separate Vertrautheit, und daher kann ein weiteres Zeichen an denselben Positionen angebracht werden.  Für meine Zwecke ist es jedoch bequemer, wenn die Möglichkeit besteht, Buchstaben auszugeben (andernfalls muss die Richtung in Kompassgraden angezeigt werden, was etwas ungewöhnlich ist).  In diesem Fall wandte ich mich daher der einzeiligen Matrix MT-10S1 mit identischer Größe zu, die trotz einiger Mängel zum fertigen Design migrierte.  Gleichzeitig hat er bereits eine Hintergrundbeleuchtung, die dem MT-10T7 fehlt (dafür musste sofort der MT-10T8 gekauft werden), und ich entschied, dass seine Anwesenheit in diesem Fall nicht schaden würde. <br><br><h2>  MT-10S1 </h2><br>  Das MT-10S1-Display hat eineinhalb Mal kleinere Buchstaben, aber auch eine recht anständige Größe.  Darüber hinaus ist sein Bildschirm in seinen Gesamtabmessungen wirtschaftlich verpackt: Es gibt keine 10-stelligen Import-Gegenstücke, aber im Winstar WH1601L (wo die Zeichen noch etwas kleiner sind) ist ein Zeichen mehr als einen Millimeter größer als die Gesamtlänge der Tafel und des Bildschirms.  Nun, der Controller-Verbrauch ist fast halbiert (im Vergleich zum gleichen WH1601L).  Eigentlich enden die Vorteile dort, dann beginnen die „Features“. <br><br>  Das Modul verfügt, wie bereits erwähnt, über einen Controller, der mit dem HD44780 von HITACHI kompatibel ist.  Das heißt, er sollte mit seinem geliebten Flüssigkristall ohne übermäßigen Stress arbeiten.  Darüber hinaus stimmt die "Standard" -Codierungsseite mit der englisch-kyrillischen Seite von HD44780 und ihren vielen Analoga überein, dh MT-10S1 sollte problemlos mit Liquid Crystal Rus funktionieren. Es sind keine Codepages erforderlich, damit dies umgeschaltet werden kann.  Und er macht das alles wirklich, aber mit Nuancen. <br><br>  Die erste Einschränkung: In der einzeiligen Version sparen Entwickler anscheinend Register, und nur 8 Zeichen einer Zeichenfolge (Adressen 00h - 07h) befinden sich im Speicher pro Register (und die verbleibenden zwei Zeichen befinden sich bereits in einem anderen Register (40h-41h).  Das heißt, die De-facto-Anzeige ist zweizeilig, nur beide Zeilen befinden sich physisch in einer Zeile.  Bei näherer Betrachtung stellte sich heraus, dass dies auch für WH1601 gilt (nur dort nimmt das zweite Register volle acht Ziffern an).  Warum dies so unpraktisch ist, ist völlig unklar. In gewöhnlichen 16x2-Displays sind die Register 16-Bit-Register, und eine solche Kürzung macht das Produkt kaum billiger, im Gegenteil, aufgrund der Notwendigkeit, verschiedene Versionen des Controllers zu produzieren (wenn sie unterschiedlich sind, von denen ich mir überhaupt nicht sicher bin).  Ich dachte, es wäre mit weniger als dem üblichen Verbrauch von MT-10S1 verbunden, aber der gleiche WH1601 verbraucht 1,2-1,4 mA, das heißt, er unterscheidet sich nicht von seinen fortschrittlichen Gegenstücken. <br><br>  Nun, es scheint, okay - in Liquid Crystal Rus wurden die Funktion setDRAMModel () und die entsprechende Konstante LCD_DRAM_WH1601 gefunden.  Für diesen Modus verfügt die Bibliothek über eine offensichtliche Adressübersetzung: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ac&gt;<span class="hljs-number"><span class="hljs-number">7</span></span> &amp;&amp; ac&lt;<span class="hljs-number"><span class="hljs-number">0x14</span></span>) command(LCD_SETDDRAMADDR | (<span class="hljs-number"><span class="hljs-number">0x40</span></span>+ac<span class="hljs-number"><span class="hljs-number">-8</span></span>));</code> </pre> <br>  Ich weiß jedoch nicht, wie es auf anderen einzeiligen Displays funktioniert, und der MT-10S1 weigert sich vollständig, in diesem Modus zu arbeiten - der Bildschirm bleibt einfach leer.  Da es sich um eine Adressierung handelt, können Sie dies nicht mit einer einfachen selbstgeschriebenen Funktion über der Bibliothek beheben, aber ich habe mich nicht in der Bibliothek umgesehen und herausgefunden, was los ist. Ich habe bereits mehr als ein halbes Dutzend flüssigkristallkorrigierte Optionen, ich möchte sie nicht produzieren und weiter. <br><br>  Die Anzeige des MT-10S1 muss zweizeilig deklariert sein: lcd.begin (16, 2);  (Anstelle von 16 können Sie 10 oder 12 ersetzen, es ändert sich nichts, da die tatsächliche Anzahl der Zeichen in einer Zeile immer noch 8 beträgt.)  Ein Versuch, es als einzelne Zeile zu initialisieren (Nummer 1 an zweiter Stelle), führt zu einem Fehler - der Hintergrund wird dunkel.  Und mehrstellige Zahlen können nur innerhalb von 8 Zeichen angezeigt werden. Bei längeren Zeilen verschwinden extreme Zeichen über 8 einfach.  Daher eignen sich die Zeichen 9 und 10 entweder nur zur Anzeige von Hilfsgrößen (z. B. Maßeinheiten), oder Sie müssen die Zeilennummer in separate Ziffern aufteilen und die Cursorposition auf das erste Zeichen der zweiten Zeile ändern, wenn Sie über das 8. Zeichen hinausgehen. <br><br>  Für Betroffene <a href="">können</a> Sie <a href="">hier</a> eine Probeskizze für diese Anzeige herunterladen (Anschluss von Leitungen - im Skizzentext oder in der Abbildung unten).  Übrigens wird der Kontrast (über den im Werksdatensatz kein Wort vorhanden ist und der Vo-Ausgang als NC bezeichnet wird) hier auf die übliche Weise eingestellt, aber Sie müssen dies wirklich nicht tun: Ohne Hintergrundbeleuchtung erscheint der Hintergrund etwas dunkel, aber wenn Sie versuchen, ihn aufzuhellen, indem Sie den Teiler mit dem Vo-Ausgang verbinden Beim Einschalten der Hintergrundbeleuchtung geht der Kontrast spürbar verloren. <br><br><h2>  Schnittstelle zum Controller </h2><br>  Nachdem überprüft wurde, ob alles ordnungsgemäß funktioniert, stellte sich die Frage, wie dies alles mit der Sensorsteuerung verbunden werden kann.  Natürlich gab es nicht genügend freie Schlussfolgerungen für die Sensorsteuerung, um die Steuerung von ihr aus zu ermöglichen, aber ich wollte die Stadt nicht wirklich mit großen Steuerungen umzäunen - es ist bequemer, wenn der Aufbau des Systems modular aufgebaut ist und die Anzeige den bereits zuvor debuggten grundlegenden Algorithmus nicht beeinträchtigt.  Es blieb eine der seriellen Schnittstellen zu verwenden. <br><br>  Dies erfordert die I <sup>2</sup> C-Lösung, die auf PCF8574 (oder seinen vielen Analoga) basiert, zumal dieser Chip selbst nur ein ausgetrickstes Schieberegister ist und daher im Betrieb mehrere zehn μA und im Ruhezustand weniger als 10 μA verbraucht.  Zusammen mit MT-10T7 bilden sie ein hervorragendes Paar für die Erstellung von Geräten mit geringem Stromverbrauch und Indikatoren. <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MELT</a> bietet für diesen Fall sogar eine vorgefertigte Option: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MT-10T11</a> mit einem Gesamtverbrauch von 30 μA. <br><br>  Für MT-10S1 gibt es jedoch keine so bequeme Lösung - aus irgendeinem Grund werden nur Versionen mit einer 20x4-Konfiguration mit einem Zusatz in Form eines Analogons von PCF8574 unter den MELT-Linienanzeigen geliefert ( <b>UPD:</b> In den Kommentaren wurde jedoch vorgeschlagen, dass es auch eine MT-16S2H-Konfiguration von 16x4 mit derselben Schnittstelle gibt , seine Dimensionen sind jenseits der Dimensionen, die ich brauche).  Das fertige Modul des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in diesem Artikel</a> beschriebenen Typs <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ist</a> in diesem Fall unpraktisch zu verwenden, da das zweite unangenehme Merkmal des MT-10S1-Displays die nicht standardmäßige Pinbelegung ist.  Die Schlussfolgerungen sind die gleichen (HD44780, genauer gesagt das inländische Gegenstück KB1013VG6), befinden sich jedoch in einer völlig nicht standardmäßigen Reihenfolge.  Aus Gründen des Interesses habe ich sowohl importierte 16x1- als auch MELT-Zweizeilen- / Vierzeilige überprüft - alle haben eine Standardausgabereihenfolge, und MT-10S1 hebt sich aus irgendeinem Grund von diesem Hintergrund ab.  Sie müssen also eine selbst getroffene Entscheidung treffen. <br><br>  Infolgedessen habe ich trivialerweise denselben ATmega328-Controller auf dem Display installiert, auf die gleiche Weise programmiert - über UNO - und dann auf einer separaten Platine in die Buchse gesteckt, die nur mit dem zum Starten erforderlichen Zubehör ausgestattet ist: Quarz mit Leitern, Stromversorgung und RC-Schaltung Ausgang zurücksetzen (siehe Sensorschaltung <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">im Originalartikel</a> , wo die Steuerung auf ähnliche Weise angeschlossen ist). <br><br><div class="spoiler">  <b class="spoiler_title">Apropos Reset-Verkettung</b> <div class="spoiler_text">  Übrigens zur Reset-Schaltung: Ich habe bereits einen Kondensator mit 1 Mikrofarad an einem Widerstand von mehreren kOhm, dh die Verzögerungszeit beim Einschalten der Stromversorgung beträgt einige Millisekunden.  Wie viele?  Das Handbuch lehrt uns, dass für die gesamte Mega-Familie hier überhaupt keine externe Kette erforderlich ist, der korrekte Start vom internen Schaltkreis ausgeführt werden soll und viel schneller.  Die Gewohnheit, beim Einschalten eine externe RC-Kette für einen verzögerten Start an Pin 1 des Controllers anzubringen, blieb mir jedoch aus der Zeit der bereits vergessenen AVR Classic-Familie erhalten, in der der Controller möglicherweise nicht richtig gestartet wurde, wenn die Versorgungsspannung nicht schnell genug war.  Und in der Mega Brown-out Detector-Familie funktioniert es möglicherweise nicht sehr gut.  In kritischen Fällen lohnt es sich immer noch, einen externen Leistungsmonitor zu installieren, aber hier schadet die RC-Kette nichts, kann aber in Fällen mit schlechten Stromquellen helfen.  Die Entwickler von Arduino-Boards sind sich dessen übrigens bewusst, denn auf dem Uno-Board gibt es zum Beispiel die gleiche Kette von 10 kOhm / 100 nF. <br></div></div><br>  Und Gott selbst befahl, zwei identische AVR-Controller an die übliche serielle Schnittstelle anzudocken, die bis auf den Programmierprozess ohnehin nirgendwo anders in diesem Projekt verwendet wird und für die alles bereits zur Hand ist.  Übrigens unterscheidet sich eine solche Lösung preislich nicht von den auf PCF8574 basierenden Komponenten und kann in der Variante mit MT-10T7 hinsichtlich der Energieeinsparung mit ihr konkurrieren - falls der oben erwähnte MT-10T11 nicht zur Hand ist. <br><br>  Insgesamt ist die Schaltung des MT-10S1-Moduls mit der Steuerung wie folgt (in der Abbildung ist die Bezeichnung der ATmega328-Schlussfolgerungen in Klammern nach den Schlussfolgerungen der Arduino-Karte angegeben): <br><br><img src="https://habrastorage.org/webt/zu/4h/sg/zu4hsgop0jxa8ufsqopzlr4xqro.png" width="880"><br><br>  Im Controller habe ich den Energiesparmodus angewendet (ja, das ist hier nicht wirklich erforderlich, aber warum sollte der Chip unnötig eingeschaltet bleiben?).  Darüber hinaus erfolgt das Aufwecken auf einem Signal vom gleichen Rechteckwellengenerator auf dem 555-Chip wie der Takt des Hauptreglers, nur diesmal auf der fallenden Flanke (FALLING), um die Mess- und Datenübertragungsfunktionen geringfügig zu trennen. <br><br><div class="spoiler">  <b class="spoiler_title">Das Geheimnis der Natur</b> <div class="spoiler_text">  Damit verbunden ist ein Geheimnis der Natur, das ich nicht lösen konnte.  Es ist bekannt, dass Mega nur durch einen externen asynchronen Interrupt aus dem Tiefschlaf gebracht werden kann, da die Uhr ausgeschaltet ist und ein synchroner Interrupt einfach nicht auftreten kann.  Und die ganze Familie der 28-poligen AVR-Controller, die ihren Stammbaum von ATmega8 (48/88/168/328) führen, hat als solche nur Low-Level-Interrupts INT0 und INT1 (und PCINT-Interrupt, wird aber in Arduino nicht verwendet).  Alle offiziellen Empfehlungen beziehen sich sowohl auf Atmel-Materialien als auch auf Arduino-Websites.  Das Beispiel auf der Website arduino.cc besagt ausdrücklich: " <i>In allen außer den IDLE-Schlafmodi kann nur LOW verwendet werden</i> ."  Und dies ist sozusagen kein Zweifel, zum Beispiel wiederholt Monk dasselbe <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in seinem Buch</a> ausführlicher: „ <i>Beachten Sie, dass der LOW-Interrupt-Typ ausgewählt ist.</i>  <i>Dies ist die einzige Art von Interrupt, die in diesem Beispiel verwendet werden kann.</i>  <i>Die Typen RISING, FALLING und CHANGE funktionieren nicht</i> . “ <br><br>  Eine Unterbrechung auf einem niedrigen Pegel ist sehr unpraktisch zu verwenden, da sie, sobald sie auftritt, mit diesem niedrigsten Pegel am Ausgang immer wieder auftritt und besondere Maßnahmen ergriffen werden müssen, um unnötige Auslöser zu beseitigen.  Als ich in den Foren nach verschiedenen Lösungen für dieses Problem suchte, stieß ich plötzlich auf einige Codebeispiele, in denen INT0 vom Typ RISING oder FALLING explizit verwendet wird, um aus dem Schlaf zu kommen.  Natürlich habe ich dies dem Analphabetismus der Autoren zugeschrieben.  Aber als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ich</a> über den Satz stolperte: „ <i>Obwohl Sie jede andere Art von Interrupt verwenden können (RISING, FALLING, CHANGE) - sie alle bringen den Prozessor aus dem Schlaf</i> “, entschied ich mich trotz der Feinde, ein Live-Experiment durchzuführen - es war gut dafür von Hand. <br><br>  Und zu meinem Erstaunen hat alles perfekt funktioniert.  Energiesparmodus - SLEEP_MODE_PWR_DOWN;  Aufgrund von Nutzlosigkeit habe ich hier keine Maßnahmen ergriffen, um den Verbrauch durch Deaktivieren aller anderen Funktionen weiter zu senken, aber der Taktgenerator ist offensichtlich ausgeschaltet.  Trotzdem wacht der Controller regelmäßig an der fallenden Flanke auf, fordert Daten an, zeigt sie auf dem Display an und schläft wieder ein.  Für die Reinheit des Experiments entfernte ich das MK von der UNO-Platine und steckte es mit dem angeschlossenen Quarz in meine Fassung, und trotzdem funktionierte alles weiter.  Dies ist am Verbrauch zu erkennen: fast 17 mA im Normalmodus und 0,9-1 mA bei eingeschalteter Energieeinsparung (davon sollten 0,7 mA dem Display zugeordnet werden). <br><br>  Ohne aus meinem Erstaunen herauszukommen, las ich die Datenblätter von Atmel, schaute in Evstifeevs Buch (mit ihrer Übersetzung), schaute sogar in das alte Atmel-Handbuch über die Classic-Familie und verbrachte dann einen halben Tag damit, nach einer Erklärung zu suchen, was geschah (sowohl auf Russisch als auch auf Russisch) auf Englisch) in zwei bekannten Suchmaschinen, fand aber nirgends auch nur einen Hinweis.  Es sei denn, es ist in den Anwendungshinweisen von Atmel nützlich, da es zweifelhaft ist, dass dort etwas veröffentlicht wurde, das den Datenblättern widerspricht. Ich bin froh, wenn jemand, der weiß, weiß, was ich falsch verstehe. <br>  <b>UPD: Die</b> Live-Assembler-Prüfung (ATmega8) ergab die vollständige Übereinstimmung mit den Datenblättern, dh, nur die Unterbrechung der Ebene funktioniert.  Die einzige Erklärung, die mir einfällt, ist, dass Arduino den PCINT-Interrupt irgendwie mit einem regulären Interrupt verbunden hat.  Ein Versuch, die Situation durch Studium des Textes der Arduino-Systembibliotheken zu klären, brachte nichts - dort würde sich der Teufel das Bein brechen. <br></div></div><br>  Die Datenübertragung von der Sensorsteuerung zur Anzeigesteuerung über UART ist in Form eines Dialogs organisiert.  Beim Aufwachen fordert der Display-Controller bei jeder vierten Unterbrechung nacheinander Daten an: <br><br><pre> <code class="cpp hljs">. . . . . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (flag==<span class="hljs-number"><span class="hljs-number">1</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//   4-  ~6  Serial.print('T'); //   while(!Serial.available()); //  T iit = Serial.readBytes(buft,5); //  5  , //  ii    Serial.print('H'); //   while(!Serial.available()); //  iihh=Serial.readBytes(bufhh,5); //  5  , //  ii    Serial.print('S'); //   while(!Serial.available()); //  iiss=Serial.readBytes(bufss,5); //  5  , //  ii    Serial.print('D'); //   while(!Serial.available()); //  iid=Serial.readBytes(bufd,5); //  5  , //  ii    flag=0; //   } . . . . .</span></span></code> </pre><br>  Hier sind buft, bufhh, bufss und bufd Arrays (keine Strings!) Aus fünf Bytes, die Daten zu Temperatur, Luftfeuchtigkeit, Geschwindigkeit und Richtung in Form einer ASCII-Zerlegung der entsprechenden Zahlen enthalten.  Um nicht zu viel zu akzeptieren, gibt das Setup eine verkürzte Zeitüberschreitung für den Empfang an: <br><br><pre> <code class="cpp hljs">. . . . . Serial.begin(<span class="hljs-number"><span class="hljs-number">9600</span></span>); Serial.setTimeout(<span class="hljs-number"><span class="hljs-number">10</span></span>); <span class="hljs-comment"><span class="hljs-comment">//   10  . . . . .</span></span></code> </pre><br>  Die Anzeige ist bequemer: Erstens haben Sie sofort die Länge der empfangenen Nummer, und zweitens sendet die Funktion Serial.print () eine ASCII-Zeichenfolge von der Seite des Sensorcontrollers, wobei die Pausen nur in den 10 ms zwischen den Sendungen festgelegt werden :: <br><br><pre> <code class="cpp hljs">. . . . . <span class="hljs-comment"><span class="hljs-comment">//     : if (Serial.available()&gt;0) //  { char ch=Serial.read(); if (ch=='T') { Serial.print(temperature,1); delay(10);} if (ch=='H') { Serial.print(humidity,0); delay(10);} if (ch=='S') { float wFrq=(3+0.8*f)/10; //   / if (wFrq&gt;0.3) Serial.print(wFrq,1); else Serial.print(0.0,1); delay(10);} if (ch=='D') { // Serial.println(wind_G); Serial.println(wind_Avr); delay(10); }//end ch }//end serial . . . . .</span></span></code> </pre><br>  Die Berechnung der Geschwindigkeit in m / s ist hier identisch mit der im Hauptmodul der Station durchgeführten (die Startschwelle wird zufällig auf 0,3 m / s eingestellt) und muss auch entsprechend den Kalibrierungsergebnissen geändert werden. <br><br>  Wenn Sie versuchen, die Daten mit dem üblichen Serial.read () zu akzeptieren, und dann das Ergebnis des Empfangs auf einem Display mit einer Funktion wie lcd.print (t, 1) anzeigen, wobei t die Temperatur in Grad ist, die beispielsweise 12,7 entspricht, dann MT-10S1 als Antwort darauf Der Befehl gibt "49.5" aus.  Erraten oder vorschlagen?  Dies sind die ersten drei Zeichen in der Sequenz „49 50 46 55“, dh in der ASCII-Erweiterung der Nummer „12.7“.  Daher ist es einfacher, ein Array von Zeichen sofort zu akzeptieren und direkt so viele Zeichen anzuzeigen, wie gesendet wurden (count ist ein Zähler, der sich mit jedem Interrupt um eins erhöht): <br><br><pre> <code class="cpp hljs">. . . . <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (count%<span class="hljs-number"><span class="hljs-number">8</span></span>==<span class="hljs-number"><span class="hljs-number">0</span></span>){ <span class="hljs-comment"><span class="hljs-comment">// 8   lcd.clear(); if (buft[0]!='-') lcd.print("+"); for (byte i = 0; i &lt; iit; i++) lcd.print(buft[i]); //  lcd.setCursor(6, 0); for (byte i = 0; i &lt; iihh; i++) lcd.print(bufhh[i]); //  lcd.setCursor(0, 1); lcd.print("%"); } if ((count+4)%8==0){ //  4  lcd.clear(); lcd.setCursor(0, 0); for (byte i = 0; i &lt; iiss; i++) lcd.print(bufss[i]); //  lcd.setCursor(5, 0); dir_dd(bufd); //  } . . . . .</span></span></code> </pre><br>  Die letzte Zeile muss entschlüsselt werden.  Tatsache ist, dass die Richtungsdaten im 0-15-Code gesendet werden (zu dem sie bei der Implementierung der Vektormittelung noch vom Gray-Code übertragen werden).  Im Fall des Sieben-Segment-Displays MT-10T7 wurden sie in Kompassgrade übersetzt: <br><br><pre> <code class="cpp hljs">. . . . . dd=atoi(bufd); <span class="hljs-comment"><span class="hljs-comment">//   dd=dd*22.5; //   itoa(dd,bufd,10); //    . . . . .</span></span></code> </pre><br>  Und hier können wir direkt in russischen Buchstaben schreiben, genauso wie im Hauptmodul der Wetterstation (aufgrund dessen diese Anzeige tatsächlich gewählt wurde): <br><br><pre> <code class="cpp hljs">. . . . . <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">dir_dd</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params"> dd[])</span></span></span><span class="hljs-function"> </span></span>{<span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(atoi(dd)) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: {lcd.print(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span>: {lcd.print(<span class="hljs-string"><span class="hljs-string">"C"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span>: {lcd.print(<span class="hljs-string"><span class="hljs-string">"C"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span>: {lcd.print(<span class="hljs-string"><span class="hljs-string">"C"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">4</span></span>: {lcd.print(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">5</span></span>: {lcd.print(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">6</span></span>: {lcd.print(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">7</span></span>: {lcd.print(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>: {lcd.print(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>: {lcd.print(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>: {lcd.print(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">11</span></span>: {lcd.print(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">12</span></span>: {lcd.print(<span class="hljs-string"><span class="hljs-string">""</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">13</span></span>: {lcd.print(<span class="hljs-string"><span class="hljs-string">"C"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">14</span></span>: {lcd.print(<span class="hljs-string"><span class="hljs-string">"C"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">15</span></span>: {lcd.print(<span class="hljs-string"><span class="hljs-string">"C"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;} }<span class="hljs-comment"><span class="hljs-comment">//end switch }//end dir . . . . .</span></span></code> </pre><br><h2>  Aussehen </h2><br>  Das Foto zeigt das Erscheinungsbild des Displays mit dem angeschlossenen Controller im Betriebszustand: <br><br><img src="https://habrastorage.org/webt/wo/dg/fk/wodgfkuefea3shdafmubstmlmke.jpeg" width="400"><br><br>  So sieht die modifizierte Sensorbaugruppe aus: <br><br><img src="https://habrastorage.org/webt/ww/v4/p_/wwv4p_duhu45imp1gwppoz0ydzo.jpeg" width="400"><br><br>  Die Hintergrundbeleuchtungsparameter sind die in der obigen Abbildung angegebenen.  Da der Spannungsabfall über der Hintergrundbeleuchtung in den MELT-Modulen bei einer 12-V-Stromversorgung 4,5 V beträgt, beträgt der Hintergrundbeleuchtungsstrom 50 mA (maximal für dieses Modul 60 mA). <br><br>  Das Gehäuse ist maximal abgedichtet, um zu vermeiden, dass feuchte Luft ins Innere gelangt (der schwarze Rahmen des Bildschirms stammt von der Gummimantel eines dünnen Kabels).  Die weiße Platte rechts ist das Gehäuse des Luftfeuchtigkeits-Temperatursensors SHT-75, der aus dem Gehäuse genommen wurde (der Sensor selbst befindet sich dahinter).  Das gelbe Kabel oben ist die 433-MHz-Sendeantenne.  Auf der linken Seite befinden sich die Anschlüsse, an denen die Geschwindigkeits- und Richtungssensoren angeschlossen sind. <br><br>  Und so sehen die Messwerte auf dem Display des Hauptmoduls der Wetterstation aus (das schwarze Modul mit der weißen Antenne rechts ist der 433-MHz-Empfänger): <br><br><img src="https://habrastorage.org/webt/53/kd/kg/53kdkgcw_aqjwuzrjw4ev1k7uby.jpeg" width="400"></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de430828/">https://habr.com/ru/post/de430828/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de430818/index.html">SQLAlchemy-Beschleunigung für Architekturastronauten</a></li>
<li><a href="../de430820/index.html">Schwarzer Freitag 2018 - VDS in Moskau und Amsterdam</a></li>
<li><a href="../de430822/index.html">Informationssicherheit im Internet der Dinge: Wer ist das Ding und wer ist der Meister?</a></li>
<li><a href="../de430824/index.html">Suchen Sie in MS SQL Server 2005 nach beschädigtem Objekt anhand der beschädigten Seitenzahl</a></li>
<li><a href="../de430826/index.html">Wie man einen Entwicklungsmanager entwickelt</a></li>
<li><a href="../de430830/index.html">Schwarzer Freitag, Traditionen und englische Redewendungen zum Einkaufen</a></li>
<li><a href="../de430832/index.html">Human Black Friday Preis</a></li>
<li><a href="../de430834/index.html">10 Todsünden des Sprechers</a></li>
<li><a href="../de430836/index.html">Kotlin: Statik, die es nicht gibt</a></li>
<li><a href="../de430838/index.html">Die Wunder des Crowd-Marketings oder wie man ein Unternehmen mit Bewertungen fördert</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>