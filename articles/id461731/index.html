<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐽 🤽🏽 📢 DPKI: Mengatasi Kerugian PKI Terpusat oleh Cara Blockchain ✳️ 👃🏾 🚷</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sertifikat digital adalah salah satu alat bantu yang paling umum dikenal yang membantu melindungi data di seluruh jaringan publik. Namun, kelemahan ut...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DPKI: Mengatasi Kerugian PKI Terpusat oleh Cara Blockchain</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/encry/blog/461731/"><img src="https://habrastorage.org/webt/nz/th/oe/nzthoe936pglmrwozahcz-kwqjk.jpeg"><br><br>  Sertifikat digital adalah salah satu alat bantu yang paling umum dikenal yang membantu melindungi data di seluruh jaringan publik.  Namun, kelemahan utama dari teknologi ini juga umum dikenal: pengguna dipaksa untuk secara implisit mempercayai otoritas sertifikasi yang mengeluarkan sertifikat digital.  Andrey Chmora, Direktur Teknologi dan Inovasi di ENCRY, menyarankan pendekatan baru untuk membangun <b>Infrastruktur Kunci Publik (PKI)</b> untuk menghilangkan kerugian yang ada dengan menggunakan teknologi ledger leded (blockchain). <br>  Mari kita mulai dengan dasar-dasarnya. <br><a name="habracut"></a><br>  <i>Jika Anda sudah mengetahui dasar-dasar infrastruktur kunci publik yang ada dan kelemahan utamanya, silakan gulir ke bawah ke deskripsi tentang apa yang kami sarankan untuk diubah.</i> <br><br><div class="spoiler">  <b class="spoiler_title">Apa itu tanda tangan digital dan sertifikat digital?</b> <div class="spoiler_text">  Interaksi melalui Internet selalu termasuk pertukaran data.  Dan dengan demikian kita semua tertarik untuk menjaga keamanan data selama pertukaran tersebut.  Tetapi apakah keamanan itu?  Layanan keselamatan yang paling populer adalah kerahasiaan, integritas, dan keaslian.  Hari ini, mereka didasarkan pada kriptografi asimetris, yang juga disebut kriptografi kunci publik. <br><br>  Pertama-tama, metode ini mensyaratkan bahwa entitas interaksi harus memiliki dua pasangan kunci khusus: publik dan pribadi.  Pasangan kunci ini menyediakan fitur keselamatan yang disebutkan di atas. <br><br>  Tetapi bagaimana cara mencapai pertukaran informasi pribadi? <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/95/g0/ar/95g0arsxoegtxcwsd8b9cr9lvra.png" alt="gambar"></div><br>  <i>Gambar 1. Transmisi terenkripsi menggunakan kriptografi kunci publik</i> <br><br>  Sebelum mengirim data apa pun, pengirim mengenkripsi (mengubah secara kriptografis) data publik menggunakan kunci publik penerima, dan kemudian penerima mendekripsi data yang dienkripsi menggunakan pasangan kunci pribadi. <br><br>  Bagaimana cara mencapai integritas dan keaslian informasi yang dikirim?  Masalah ini dapat diselesaikan dengan menggunakan mekanisme lain. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ig/2k/da/ig2kdawntfyggluw1gzwvoajfa4.png" alt="gambar"></div><br>  <i>Gambar 2. Penandatanganan / verifikasi digital</i> <br><br>  Meskipun data publik tidak dienkripsi, ini berisi nilai fungsi hash kriptografis, yaitu gambar "terkompresi" terenkripsi dari urutan data input.  Hasil hashing semacam itu disebut "intisari" dan dienkripsi menggunakan kunci pribadi pengirim ("autentikator").  Hasil enkripsi intisari adalah tanda tangan digital, yang dikirim ke penerima ("verifikasi") bersama dengan teks yang tidak dienkripsi.  Penerima mendekripsi tanda tangan digital menggunakan kunci publik autentikator dan kemudian membandingkannya dengan nilai fungsi hash kriptografis yang dihitung oleh verifikasi berdasarkan data publik yang diperoleh.  Jika mereka cocok, maka data yang diterima sepenuhnya otentik, integral dan bebas dari modifikasi apa pun yang mungkin bisa dilakukan oleh penyerang. <br><br>  Sebagian besar sumber daya yang memproses data pribadi dan informasi pembayaran (seperti bank, perusahaan asuransi, maskapai penerbangan, dan sistem pembayaran bersama dengan layanan pajak dan portal pemerintah lainnya) banyak menggunakan kriptografi asimetris. <br><br>  Bagaimana sertifikat digital dapat membantu di sini?  Sederhana saja.  Kedua proses termasuk kunci publik yang memainkan peran yang sangat penting dan oleh karena itu kita harus selalu memeriksa bahwa itu milik pengirim (atau ke autentikator ketika kita perlu memverifikasi tanda tangan) atau penerima daripada penyerang.  Dan di sinilah sertifikat digital dapat membantu memastikan keaslian dan integritas kunci publik. <br><br>  <i>Catatan: Keaslian dan integritas kunci publik diverifikasi dengan cara yang persis sama dengan data publik, yaitu menggunakan tanda tangan digital (DS).</i> </div></div><br><div class="spoiler">  <b class="spoiler_title">Siapa yang menerbitkan sertifikat digital?</b> <div class="spoiler_text"> Sertifikat digital dikeluarkan dan dikelola oleh Otoritas Sertifikasi (CA) yang tepercaya.  Entitas yang mengajukan permintaan meminta CA untuk menerbitkan sertifikat, mendaftar di Pusat Registrasi (RC) dan kemudian menerima sertifikatnya di CA.  CA menjamin bahwa kunci publik dari sertifikat milik entitas yang dikeluarkannya. <br><br>  Jika Anda tidak memverifikasi keaslian kunci publik, maka penyerang akan dapat mengganti kunci yang ditransfer / disimpan dengan kunci mereka sendiri.  Begitu kunci telah diganti, penyerang akan dapat mendekripsi segala sesuatu yang ditransfer pengirim ke penerima, atau bahkan memodifikasi data publik atas kebijakan mereka. <br><br>  Sertifikat digital selalu digunakan bersama dengan kriptografi asimetris.  Salah satu sertifikat digital paling populer adalah sertifikat SSL untuk komunikasi aman melalui HTTPS.  Sertifikat SSL dikeluarkan oleh ratusan perusahaan di berbagai yurisdiksi.  Pangsa pasar inti didistribusikan di antara lima hingga sepuluh otoritas sertifikasi tepercaya terbesar: IdenTrust, Comodo, GoDaddy, GlobalSign, DigiCert, CERTUM, Actalis, Secom, dan Trustwave. <br><br>  CA dan RC adalah komponen PKI yang juga meliputi: <br><br><ul><li>  <b>Kamus Umum:</b> Database publik yang menyediakan penyimpanan andal untuk sertifikat digital </li><li>  <b>Daftar Sertifikat yang Dicabut:</b> Database publik yang menyediakan penyimpanan yang andal untuk sertifikat digital kunci publik yang dicabut (mis. Karena kunci privat yang dikompromikan) <br>  Entitas infrastruktur dapat mengakses database ini sendiri atau menggunakan Protokol Status Sertifikasi Online (OCSP) yang menyederhanakan proses verifikasi. </li><li>  <b>Pengguna Sertifikat:</b> entitas PKI yang dilayani sesuai dengan perjanjian pengguna dengan CA dan memverifikasi tanda tangan digital dan / atau mengenkripsi data berdasarkan kunci publik dari sertifikat </li><li>  <b>Pelanggan:</b> Entitas PKI yang dilayani oleh CA, memegang kunci pribadi dan memasangkan kunci publik dari sertifikat, dan telah menyimpulkan perjanjian pelanggan dengan CA.  Pelanggan juga dapat menjadi pengguna sertifikat. </li></ul><br>  Dengan demikian, entitas tepercaya dari infrastruktur kunci publik, termasuk CA, RC, dan Kamus Umum, bertanggung jawab untuk: <br><br><ol><li>  Verifikasi entitas yang mengajukan permintaan </li><li>  Pembuatan profil sertifikat kunci publik </li><li>  Masalah sertifikat kunci publik untuk entitas yang diautentikasi membuat permintaan </li><li>  Perubahan status sertifikat kunci publik </li><li>  Penyediaan informasi tentang status saat ini dari sertifikat kunci publik. </li></ol></div></div><br><div class="spoiler">  <b class="spoiler_title">Apa kerugian PKI?</b> <div class="spoiler_text">  Kerugian mendasar PKI adalah bergantung pada entitas tepercaya.  <b>Pengguna dipaksa untuk mempercayai CA dan RC secara membabi buta.</b>  Namun, kepercayaan buta semacam itu berbahaya. <br><br>  Selama sepuluh tahun terakhir, kerentanan infrastruktur menyebabkan beberapa skandal besar. <br><br>  Pada 2010, malware Stuxnet yang ditandatangani menggunakan sertifikat digital curian dari RealTek dan JMicron mulai menyebar di Internet. <br><br>  Pada 2017, Google menuduh Symantec menerbitkan sejumlah besar sertifikat palsu.  <i>Pada saat itu, Symantec adalah salah satu CA terbesar dengan jumlah sertifikat yang dikeluarkan.</i>  <i>Sejak versi 70 Google Chrome, Google telah menghentikan dukungan untuk semua sertifikat yang dikeluarkan oleh perusahaan ini dan afiliasinya GeoTrust dan Thawte sebelum 1 Desember 2017.</i> <br><br>  CA ini terganggu dan, akibatnya, CA itu sendiri bersama dengan pengguna dan pelanggan terkena dampak.  Selain itu, kepercayaan terhadap infrastruktur juga terpengaruh.  Selain itu, sertifikat digital mungkin dilarang karena konflik politik dan karenanya berdampak pada banyak sumber daya.  Ini sebabnya pada tahun 2016 pihak berwenang Rusia mempertimbangkan penciptaan pusat sertifikasi nasional untuk mengeluarkan sertifikat SSL untuk situs web Runet.  Dalam situasi saat ini, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">portal pemerintah Rusia menggunakan</a> sertifikat digital yang dikeluarkan oleh perusahaan AS Comodo atau Thawte (anak perusahaan Symantec). <br><br>  Masih ada masalah lain: <b>bagaimana cara mengotentikasi pengguna pada awalnya?</b>  Bagaimana cara mengidentifikasi pengguna anonim yang telah meminta sertifikat digital dari CA?  Saat ini, sering dibuat sewenang-wenang tergantung pada kemampuan infrastruktur.  Beberapa informasi diambil dari basis data publik (misalnya tentang badan hukum yang meminta sertifikat) atau dari bank dan kantor pos tempat individu dapat diidentifikasi dengan kartu identitas dan dokumen lainnya. <br><br>  Peniruan berdasarkan kredensial palsu adalah salah satu masalah mendasar.  Dan, sayangnya, tidak ada solusi lengkap dari masalah ini bahkan mungkin ada karena aspek informasi dan teoritis: tanpa informasi yang dapat diandalkan, tidak mungkin untuk memverifikasi keaslian suatu entitas.  Sebagai aturan, proses verifikasi memerlukan seperangkat dokumen yang membuktikan identitas entitas yang mengajukan permintaan.  Meskipun ada banyak metode verifikasi, tidak ada satupun yang dapat menjamin keaslian dokumen.  Dengan demikian, keaslian entitas yang membuat permintaan juga tidak dapat diidentifikasi dengan pasti. <br></div></div><br><div class="spoiler">  <b class="spoiler_title">Bagaimana cara menghilangkan kerugian ini?</b> <div class="spoiler_text">  Karena masalah PKI saat ini terutama disebabkan oleh sentralisasi, jelas bahwa desentralisasi dapat membantu menghilangkan setidaknya beberapa dari mereka. <br><br>  Desentralisasi tidak bergantung pada entitas tepercaya, karena penciptaan <b>Infrastruktur Kunci Publik Terdesentralisasi (DPKI)</b> akan membuat CA dan RC tidak perlu.  Mari kita menolak konsep sertifikat digital dan sebagai gantinya menggunakan buku besar yang didistribusikan untuk menyimpan informasi tentang kunci publik.  Dalam kasus kami, buku besar adalah database linier yang terdiri dari catatan individual (blok) dan terhubung menggunakan teknologi blockchain.  Mari kita ganti istilah "sertifikat digital" dengan istilah "pemberitahuan". <br><br>  Beginilah tanda terima, verifikasi, dan pencabutan pemberitahuan di DPKI yang diusulkan: <br><br><ol><li>  Setiap entitas yang mengajukan permintaan mengajukan pemberitahuan sendiri dengan mengisi formulir pendaftaran, dan kemudian membuat transaksi yang akan disimpan dalam kumpulan khusus. </li><li>  Informasi tentang kunci publik bersama dengan rincian pemilik dan metadata lainnya disimpan dalam buku besar yang didistribusikan daripada dalam sertifikat digital yang dikeluarkan oleh CA di PKI terpusat. </li><li>  Entitas yang mengajukan permintaan kemudian diautentikasi oleh upaya bersama komunitas pengguna DPKI dan bukan oleh RC. </li><li>  Hanya pemilik pemberitahuan tersebut yang dapat mengubah status kunci publik. </li><li>  Semua orang dapat mengakses buku besar yang didistribusikan dan memeriksa status kunci publik saat ini. </li></ol><br>  <i>Catatan: Sekilas, otentikasi entitas yang membuat permintaan mungkin tampak tidak dapat diandalkan.</i>  <i>Namun, penting untuk diingat bahwa saat ini semua pengguna layanan digital meninggalkan jejak digital yang terus tumbuh.</i>  <i>Alat yang tersedia untuk umum meliputi basis data digital badan hukum, peta, gambar teritern digital, media sosial, dan banyak lagi.</i>  <i>Mereka sudah berhasil digunakan dalam penyelidikan oleh wartawan dan lembaga penegak hukum.</i>  <i>Salah satu contoh khas termasuk penyelidikan Bellingcat dan kelompok gabungan JIT, yang menyelidiki kecelakaan pesawat Boeing Malaysia.</i> </div></div><br>  Jadi, bagaimana infrastruktur kunci publik terdesentralisasi bekerja dalam praktik?  Mari selami teknologi yang telah kami <b>patenkan pada tahun 2018</b> dan pertimbangkan keahlian terbaik kami. <br><br>  Misalkan ada seseorang yang memiliki satu set kunci publik, di mana setiap kunci adalah semacam transaksi yang disimpan dalam buku besar.  Bagaimana cara memverifikasi bahwa semua kunci ini benar-benar milik pemilik yang diberikan tanpa CA?  Untuk menyelesaikan tugas ini, kita dapat membuat transaksi nol untuk menyimpan informasi tentang pemilik dan e-wallet mereka (dari mana biaya komisi untuk menambahkan transaksi ke buku besar didebet).  Transaksi nol adalah semacam "jangkar" untuk menghubungkan transaksi berikutnya bersama dengan data tentang kunci publik.  Setiap transaksi jenis ini berisi struktur data khusus yang disebut "notifikasi". <br><br>  <i>Pemberitahuan adalah kumpulan data terstruktur bidang fungsional yang menyimpan informasi tentang kunci publik pemilik dan menjamin persistensi kunci ini dengan menambahkannya ke salah satu catatan terkait dalam buku besar yang didistribusikan.</i> <br><br>  Pertanyaan jelas berikutnya adalah bagaimana membentuk transaksi nol?  Transaksi nol, sama seperti semua transaksi berikutnya, adalah agregasi dari enam bidang data.  Untuk membentuk transaksi nol, kami menggunakan pasangan kunci publik / pribadi untuk e-wallet.  Pasangan kunci publik / pribadi ini dibuat ketika pengguna membuat dompet mereka dari mana biaya komisi untuk menambahkan transaksi nol ke buku besar dan untuk operasi selanjutnya dengan pemberitahuan akan didebet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qw/gu/2d/qwgu2dihzkrkduvq7qz8gcplyve.jpeg" alt="gambar"></div><br>  <i>Gambar 3. Membuat transaksi nol</i> <br><br>  <i>Gambar 3</i> menunjukkan bagaimana intisari kunci publik e-wallet dibentuk menggunakan fungsi hash SHA256 dan kemudian fungsi hash RIPEMD160.  Di sini, RIPEMD160 bertanggung jawab untuk merepresentasikan data dengan ukuran digest hingga 160 bit.  Ini sangat penting, karena buku besar adalah database mahal.  Kunci publik itu sendiri termasuk dalam bidang kelima.  Bidang pertama berisi data yang menautkan transaksi yang diberikan dengan yang sebelumnya.  Dalam transaksi nol, tidak seperti semua transaksi lainnya, bidang ini kosong.  Kolom kedua berisi data untuk verifikasi konektivitas transaksi.  Demi singkatnya, kami akan merujuk data di bidang pertama dan kedua masing-masing sebagai "bind" dan "verifikasi". <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/py/4m/c8/py4mc8voonsndcqfs-xp1krttrw.jpeg" alt="gambar"></div><br>  <i>Gambar 4. Pengikatan dan verifikasi transaksi</i> <br><br>  Data dalam bidang ini dapat dibentuk menggunakan hashing berulang seperti yang ditunjukkan pada <i>Gambar 4 di</i> atas untuk mengikat transaksi kedua dan ketiga. <br>  Data dalam lima bidang pertama dikonfirmasi dengan DS yang dihasilkan menggunakan kunci pribadi e-wallet.  Dan itu saja - transaksi sekarang dapat ditambahkan ke kumpulan dan kemudian, setelah verifikasi berhasil (seperti yang ditunjukkan pada <i>Gambar 5</i> ), ke buku besar. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/f9/tt/uk/f9ttukcb_mprsdby_dsafwpnwow.jpeg" alt="gambar"></div><br>  <i>Gambar 5. Verifikasi transaksi nol</i> <br><br>  Sekarang transaksi ini dapat digunakan untuk "menghubungkan" transaksi selanjutnya.  Mari kita lihat <i>Gambar 6</i> untuk melihat bagaimana semua transaksi non-nol terbentuk. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/0c/ul/ks/0culksjzrhy0nx1dylr_scysrpu.jpeg" alt="gambar"></div><br>  <i>Gambar 6. Membuat transaksi non-null</i> <br><br>  Hal pertama yang Anda perhatikan adalah banyak pasangan kunci publik / pribadi.  Selain pasangan kunci publik / pribadi e-wallet yang sudah akrab, kami juga menggunakan pasangan kunci biasa dan layanan. <br><br>  Kunci publik biasa adalah bagian terpenting di sini.  Kunci ini digunakan dalam berbagai prosedur dan proses di dunia sekitarnya (seperti perbankan dan transaksi lainnya, aliran dokumen, dll.).  Misalnya, kunci pribadi dari pasangan kunci publik / pribadi biasa dapat digunakan untuk pembuatan DS untuk berbagai dokumen, seperti pesanan pembayaran, sementara kunci publik dapat digunakan untuk verifikasi DS dengan pelaksanaan selanjutnya dari ini. pesanan. <br><br>  Pasangan kunci publik / pribadi layanan dikeluarkan untuk entitas DPKI yang terdaftar.  Nama pasangan kunci publik / pribadi ini dengan jelas mencerminkan tujuannya.  Perhatikan bahwa kunci layanan tidak digunakan untuk pembangkitan / verifikasi transaksi nol. <br><br>  Supaya jelas, mari kita perbaiki tujuan dari kunci-kunci ini: <br><br><ol><li>  Kunci E-wallet digunakan untuk menghasilkan dan / atau memverifikasi transaksi null dan non-null.  Kunci pribadi e-wallet hanya diketahui oleh pemilik e-wallet yang juga memiliki seperangkat kunci publik biasa. </li><li>  Tujuan dari kunci publik biasa adalah sama dengan kunci publik dimana sertifikat dalam PKI terpusat dikeluarkan. </li><li>  Pasangan kunci publik / swasta milik DPKI.  Kunci pribadi dikeluarkan untuk entitas terdaftar dan digunakan untuk membuat DS dari semua transaksi non-nol.  Kunci publik digunakan untuk verifikasi DS untuk transaksi sebelum menambahkannya ke buku besar. </li></ol><br>  Jadi, kami memiliki dua kelompok kunci.  Grup pertama mencakup kunci layanan dan kunci e-wallet yang hanya memenuhi syarat dalam DPKI.  Grup kedua termasuk kunci biasa yang dapat digunakan untuk berbagai keperluan tergantung pada bidang aplikasi yang diberikan.  Pada saat yang sama, DPKI memastikan integritas dan keaslian kunci publik biasa. <br><br>  <i>Catatan: Pasangan kunci publik / pribadi layanan dapat diungkapkan ke berbagai entitas DPKI.</i>  <i>Dalam kasus tertentu, pasangan mungkin sama untuk semua entitas.</i>  <i>Inilah sebabnya mengapa membentuk tanda tangan untuk setiap transaksi non-null membutuhkan dua kunci pribadi, salah satunya adalah kunci e-wallet: kunci ini hanya diketahui oleh pemilik e-wallet yang juga memiliki seperangkat kunci publik biasa.</i>  <i>Semua kunci ini memiliki tujuan tertentu.</i>  <i>Sebagai contoh, kita selalu dapat membuktikan bahwa transaksi tertentu dimasukkan dalam buku besar oleh entitas DPKI terdaftar, karena tanda tangan dibentuk menggunakan kunci pribadi layanan juga.</i>  <i>Selain itu, ini mencegah setiap serangan DOS dan kegiatan penipuan lainnya, karena pemilik membayar untuk setiap transaksi.</i> <br><br>  Semua transaksi yang mengikuti transaksi nol dibentuk sama: kunci publik (dari pasangan kunci biasa, bukan kunci e-wallet seperti untuk transaksi nol) diproses menggunakan dua fungsi hash: SHA256 dan RIPEMD160.  Ini adalah bagaimana data di bidang ketiga terbentuk.  Bidang keempat berisi informasi tambahan (mis. Informasi tentang status saat ini, periode validitas, cap waktu, ID algoritma kriptografi, dll.).  Bidang kelima berisi kunci publik dari pasangan kunci publik / pribadi layanan.  Kunci ini direplikasi, karena akan digunakan untuk verifikasi DS.  Mari kita buktikan bahwa pendekatan seperti itu perlu. <br><br>  Setiap transaksi termasuk dalam kumpulan dan disimpan di sana sampai diproses.  Namun, menjaga transaksi di kolam berisiko, karena data transaksi dapat dipalsukan.  Pemilik mengotentikasi data transaksi menggunakan DS.  Kunci publik untuk verifikasi DS ini secara eksplisit ditentukan dalam salah satu bidang transaksi dan kemudian dimasukkan dalam buku besar.  Transaksi diproses dengan cara yang memungkinkan penyerang untuk memodifikasi data atas kebijakan mereka sendiri, memverifikasinya dengan kunci pribadi sendiri dan kemudian menentukan kunci publik yang sesuai untuk verifikasi DS langsung dalam transaksi.  Jika keaslian dan integritas dipastikan hanya menggunakan DS, pemalsuan semacam itu mungkin tetap tidak diperhatikan.  Namun, memperluas DS dengan mekanisme tambahan yang menyediakan pengarsipan dan kegigihan informasi yang disimpan akan membantu mendeteksi pemalsuan tersebut.  Yang perlu kita lakukan adalah memasukkan kunci publik asli pemilik ke dalam buku besar.  Mari kita lihat cara kerjanya. <br><br>  Misalkan penyerang sedang mencoba untuk memalsukan data transaksi.  Dalam hal kunci dan DS, opsi berikut dimungkinkan: <br><br><ol><li>  Penyerang menempatkan kunci publik mereka sendiri dalam transaksi sambil menjaga DS pemiliknya tidak berubah. </li><li>  Penyerang membentuk DS baru menggunakan kunci pribadi mereka sendiri sambil menjaga kunci publik pemiliknya tidak berubah. </li><li>  Penyerang membentuk DS baru menggunakan kunci pribadi mereka sendiri dan menempatkan kunci publik yang sesuai dalam transaksi. </li></ol><br>  Jelas bahwa opsi 1 dan 2 tidak berguna, karena verifikasi DS akan selalu mendeteksi pemalsuan tersebut.  Satu-satunya opsi yang masuk akal adalah opsi 3: jika penyerang membuat DS menggunakan kunci pribadi mereka sendiri, maka mereka terpaksa menyimpan kunci publik yang sesuai dalam transaksi, dan kunci ini akan berbeda dari kunci publik pemilik.  Ini satu-satunya cara bagi penyerang untuk menegakkan data palsu mereka. <br><br>  Misalkan pemilik memiliki pasangan kunci publik / pribadi yang diperbaiki.  Misalkan data diautentikasi dengan DS menggunakan kunci pribadi dari pasangan ini sementara kunci publik ditentukan dalam transaksi.  Misalkan juga bahwa kunci publik ini telah dimasukkan sebelumnya dalam buku besar dan telah sepenuhnya dikonfirmasi.  Kemudian pemalsuan dapat diungkapkan oleh fakta bahwa kunci publik dalam transaksi tidak cocok dengan kunci publik dalam buku besar. <br><br>  <b>Mari kita simpulkan.</b>  Saat memproses data dari transaksi pertama pemilik, kami harus mengotentikasi kunci publik yang termasuk dalam buku besar.  Untuk melakukan ini, kita dapat membaca kunci dari buku besar dan kemudian mencocokkan kunci ini dengan kunci publik asli pemilik dalam perimeter keamanan (area yang relatif kebal).  Jika kunci yang ditempatkan dikonfirmasi dan sepenuhnya persisten, maka kunci dari transaksi berikutnya juga dapat dengan mudah diautentikasi dengan mencocokkannya dengan kunci dari buku besar.  Dengan kata lain, kunci dari buku besar digunakan sebagai referensi.  Semua transaksi lain dari pemilik akan diproses dengan cara yang sama. <br><br>  Setiap transaksi diautentikasi dengan DS, dan di sini kita membutuhkan kunci privat: kunci privat layanan dan kunci privat e-wallet.  Berdasarkan dua kunci privat, kami dapat memastikan tingkat keamanan target, karena kunci privat layanan dapat diketahui oleh pengguna lain, sedangkan kunci privat e-wallet hanya diketahui oleh pemilik pasangan kunci biasa.  Kami menyebut tanda tangan dua kunci seperti itu sebagai "konsolidasi" DS. <br><br>  Transaksi non-nol diverifikasi menggunakan dua kunci publik: kunci e-wallet dan kunci layanan.  <i>(Gambar 7)</i> <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/5a/eh/tv/5aehtv6rf4sgqjp3jpclgc4chzs.jpeg" alt="gambar"></div><br>  <i>Gambar 7. Verifikasi transaksi non-nol</i> <br><br>  Proses verifikasi terdiri dari dua langkah dasar: langkah pertama termasuk verifikasi intisari kunci publik e-wallet sementara langkah kedua mengimplementasikan verifikasi DS "konsolidasi" transaksi yang dibentuk menggunakan dua kunci privat (yaitu e- kunci dompet dan kunci layanan).  Ketika DS diotentikasi, maka transaksi yang sesuai, setelah verifikasi tambahan, dimasukkan dalam buku besar. <br><br>  Namun, pertanyaan berikut muncul: bagaimana cara memverifikasi apakah transaksi yang diberikan milik rantai transaksi tertentu yang dimulai dari transaksi nol?  Untuk melakukan ini, kami telah memperbarui proses verifikasi dengan langkah lain - verifikasi konektivitas.  Langkah ini akan membutuhkan data dari dua bidang pertama yang belum kami gunakan sampai saat ini. <br><br>  Misalkan kita perlu memverifikasi apakah <i>transaksi # 2</i> benar-benar diikuti oleh <i>transaksi # 3</i> .  Untuk melakukan ini, kita bisa menggunakan metode hashing gabungan untuk menghitung nilai fungsi hash untuk data di bidang ketiga, keempat, dan kelima.  Kita dapat menggabungkan data dari bidang pertama <i>transaksi # 3</i> dan nilai fungsi hash gabungan yang dihitung sebelumnya untuk data di bidang ketiga, keempat, dan kelima bidang <i>transaksi # 2</i> .  Semua nilai ini kemudian diproses menggunakan dua fungsi hash: SHA256 dan RIPEMD160.  Jika nilai yang dihasilkan cocok dengan data di bidang kedua <i>transaksi # 2</i> , maka verifikasi berhasil dilewati dan konektivitas terbukti.  Ini ditunjukkan lebih detail pada gambar di bawah ini. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/6n/ui/df/6nuidfi_wipspjla7qjztkojqzk.jpeg" alt="gambar"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a7/e42/a2e/1a7e42a2ecbb13b06697ef8d98cfca15.jpg" alt="gambar"></div><br>  <i>Gambar 8, Gambar 9. Binding verifikasi, contoh transaksi kedua dan ketiga</i> <br><br>  Secara umum, membentuk dan memasukkan notifikasi dalam buku besar terlihat seperti ini.  Alur kerja pembentukan rantai pemberitahuan secara jelas ditunjukkan pada gambar berikut: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ql/ij/gs/qlijgsepx78xyecvyzyvryoui4i.jpeg" alt="gambar"></div><br>  <i>Gambar 10. Struktur dan pemrosesan transaksi</i> <br><br>  Dalam artikel ini, kami tidak akan membahas lebih dalam dan kembali ke pembahasan konsep infrastruktur terdesentralisasi untuk kunci publik. <br><br>  Jadi, karena entitas yang mengajukan permintaan mengirimkan permintaan registrasi notifikasi yang disimpan dalam buku besar daripada dalam database CA, komponen arsitektur inti dari DPKI adalah sebagai berikut: <br><ol><li>  Buku Besar Pemberitahuan Valid (LVN) </li><li>  Buku Besar Notifikasi Penarikan (LWN) </li><li>  Buku Besar Pemberitahuan Ditangguhkan (LSN). </li></ol><br><br>  Informasi tentang kunci publik disimpan dalam LVN / LWN / LSN sebagai nilai fungsi hash.  Perhatikan juga bahwa itu bisa berupa buku besar yang berbeda atau rantai yang berbeda atau bahkan rantai tunggal sebagai bagian dari buku besar tunggal, ketika informasi tentang status kunci publik biasa (penarikan, penskorsan, dll.) Ditambahkan ke bidang keempat dari struktur data sebagai nilai kode yang sesuai.  Ada banyak opsi untuk implementasi arsitektur DPKI tergantung pada berbagai kriteria optimisasi, seperti biaya untuk penyimpanan jangka panjang kunci publik dalam memori, dll. <br><br>  Dengan demikian, DPKI dapat berubah menjadi kompleksitas arsitektur yang sama atau bahkan lebih rendah dibandingkan dengan solusi terpusat. <br><br>  Jadi, pertanyaan utama di sini adalah <b>buku besar mana yang lebih cocok untuk menerapkan teknologi ini?</b> <br><br>  Persyaratan inti untuk buku besar adalah untuk dapat melakukan transaksi dalam jenis apa pun.  Contoh buku besar yang paling terkenal adalah Bitcoin.  Namun, menerapkan teknologi di atas untuk Bitcoin mungkin menghadapi kesulitan tertentu: keterbatasan bahasa scripting yang ada, kurangnya mekanisme yang diperlukan untuk memproses dataset sewenang-wenang dan metode untuk menghasilkan transaksi jenis sewenang-wenang, dan sebagainya. <br><br>  Kami di ENCRY mencoba untuk memecahkan masalah di atas dan mengembangkan buku besar, yang, menurut pendapat kami, menampilkan beberapa keuntungan penting: <br><br><ul><li>  <b>Mendukung beberapa jenis transaksi:</b> dalam buku besar ini, Anda dapat bertukar aset (mis. Melakukan transaksi keuangan) dan membentuk transaksi dari struktur yang arbitrer </li><li>  Pengembang dipersilakan untuk menggunakan <b>bahasa pemrograman eksklusif PrismLang</b> yang sangat fleksibel dalam menyelesaikan berbagai masalah teknologi </li><li>  Mekanisme yang diterapkan untuk <b>memproses dataset sewenang-wenang.</b> </li></ul><br>  Sederhananya, langkah-langkah berikut harus diselesaikan: <br><br><ol><li>  Entitas yang membuat permintaan mendaftar di DPKI dan memperoleh e-wallet.  Alamat e-wallet adalah nilai fungsi hash yang diterapkan pada kunci publik e-wallet.  Kunci pribadi e-wallet hanya diketahui oleh entitas yang mengajukan permintaan </li><li>  Setelah pendaftaran, entitas memperoleh akses ke kunci pribadi layanan </li><li>  Entitas membentuk transaksi nol dan kemudian mengesahkan DS-nya menggunakan kunci pribadi e-wallet </li><li>  Saat membentuk transaksi non-null, entitas harus mengotentikasi DS-nya menggunakan dua kunci pribadi: kunci e-wallet dan kunci layanan </li><li>  Entitas mengirimkan transaksi ke pool </li><li>  Node jaringan ENCRY membaca transaksi dari pool dan kemudian memverifikasi DS transaksi dan konektivitas </li><li>  Jika DS valid dan konektivitas terbukti, maka node akan menyiapkan transaksi untuk ditambahkan ke buku besar. </li></ol><br><br>  Di sini, buku besar berfungsi sebagai basis data terdistribusi yang menyimpan informasi tentang pemberitahuan yang valid, ditarik, dan ditangguhkan. <br><br>  <b>Tentu saja, desentralisasi bukanlah solusi satu ukuran untuk semua.</b>  Masalah inti dengan otentikasi pengguna utama masih berlanjut: sementara entitas yang membuat permintaan saat ini diverifikasi oleh CA, DPKI mengusulkan untuk mendelegasikan verifikasi ini kepada anggota masyarakat dan memotivasi mereka secara finansial.  Teknologi verifikasi berdasarkan sumber publik umumnya dikenal.  Efisiensi verifikasi semacam itu juga telah terbukti dalam praktiknya: beberapa investigasi tingkat tinggi yang dilakukan oleh Bellingcat adalah contoh yang baik untuk hal ini. <br><br>  Tetapi secara umum, kami cukup yakin bahwa DPKI mampu menghilangkan banyak, jika tidak semua, kerugian PKI yang tersentralisasi. <br><br>  <b>Jangan ragu untuk berlangganan blog kami di Habr</b> , di mana kami akan membahas penelitian dan pengembangan lebih lanjut, dan ikuti <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Twitter</a></b> kami untuk terus mengikuti berita tentang proyek ENCRY. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461731/">https://habr.com/ru/post/id461731/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461721/index.html">Metode Analisis Cluster Baru</a></li>
<li><a href="../id461723/index.html">Memahami paket Konteks di Golang</a></li>
<li><a href="../id461725/index.html">DataGrip 2019.2: Manajemen koneksi, pencarian data, pemfilteran dalam navigasi</a></li>
<li><a href="../id461727/index.html">Solusi Cisco Small Business: Jaringan Yang Baik Tidak Perlu Mahal</a></li>
<li><a href="../id461729/index.html">Menggunakan jailbreaking untuk mengekstrak data: risiko dan konsekuensi</a></li>
<li><a href="../id461733/index.html">Belajar Bahasa Inggris: 9 idiom gaya Amerika</a></li>
<li><a href="../id461735/index.html">Praktek Decoding Perangkat Keras FFmpeg DXVA2</a></li>
<li><a href="../id461737/index.html">Kami mengumpulkan lingkungan untuk TDD modern pada kode JavaScript + VS</a></li>
<li><a href="../id461739/index.html">Backend United 4: Okroshka. Insiden</a></li>
<li><a href="../id461741/index.html">Pengelompokan hirarki data kategorikal dalam R</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>