<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üëÉüèª üÖæÔ∏è üö• Blitz Engine & Battle Prime: ECS dan Kode Jaringan üë≤üèΩ üê∫ üî∏</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Battle Prime adalah proyek pertama dari studio kami. Terlepas dari kenyataan bahwa banyak anggota tim memiliki pengalaman yang layak dalam mengembangk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Blitz Engine & Battle Prime: ECS dan Kode Jaringan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469709/"><img src="https://habrastorage.org/webt/xi/ez/ao/xiezaordrjuxu_maz07nn1wdtqe.jpeg"><br><br>  <b>Battle Prime</b> adalah proyek pertama dari studio kami.  Terlepas dari kenyataan bahwa banyak anggota tim memiliki pengalaman yang layak dalam mengembangkan game, kami secara alami menghadapi berbagai kesulitan saat mengerjakannya.  Mereka muncul baik dalam proses bekerja pada mesin dan dalam proses mengembangkan game itu sendiri. <br><br>  Dalam industri gamedev, sejumlah besar pengembang yang rela berbagi cerita, praktik terbaik, keputusan arsitektur - dalam satu atau lain bentuk.  Pengalaman ini, diletakkan di ruang publik dalam bentuk artikel, presentasi, dan laporan, merupakan sumber ide dan inspirasi yang sangat baik.  Sebagai contoh, laporan tim pengembangan Overwatch sangat berguna bagi kami ketika bekerja pada mesin.  Seperti permainan itu sendiri, mereka dibuat dengan sangat berbakat, dan saya menyarankan semua orang yang tertarik untuk melihatnya.  Tersedia di lemari besi GDC dan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">YouTube</a> . <br><br>  Ini adalah salah satu alasan mengapa kami juga ingin berkontribusi pada tujuan bersama - dan artikel ini adalah salah satu yang pertama ditujukan untuk rincian teknis pengembangan Mesin Blitz dan memainkannya - Battle Prime. <br><br>  Artikel akan dibagi menjadi dua bagian: <br><br><ul><li>  ECS: penerapan pola Entity-Component-System di dalam Blitz Engine.  Bagian ini penting untuk memahami contoh kode dalam artikel, dan dengan sendirinya merupakan topik menarik yang terpisah. </li><li>  Netcode dan gameplay: semua yang terkait dengan bagian jaringan tingkat tinggi dan penggunaannya di dalam game - arsitektur client-server, prediksi klien, replikasi.  Salah satu hal terpenting dalam penembak adalah menembak, jadi lebih banyak waktu akan dikhususkan untuk itu. </li></ul><br>  <i>Di bawah memotong banyak megabita gif!</i> <br><a name="habracut"></a><br>  Di dalam setiap bagian, di samping cerita tentang fungsionalitas dan penggunaannya, saya akan mencoba menggambarkan kekurangan yang ada pada dirinya sendiri - baik itu keterbatasannya, ketidaknyamanan dalam pekerjaan, atau hanya pemikiran tentang perbaikannya di masa depan. <br><br>  Saya juga akan mencoba memberikan contoh kode dan beberapa statistik.  Pertama, ini hanya menarik, dan kedua, ia memberikan sedikit konteks pada skala penggunaan fungsi dan proyek ini atau itu. <br><br><h1>  ECS </h1><br>  Di dalam mesin, kami menggunakan istilah "dunia" untuk menggambarkan adegan yang mengandung hierarki objek. <br><br>  Dunia bekerja sesuai dengan templat Entity-Component-System ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">deskripsi di Wikipedia</a> ): <br><br><ul><li>  Entity - objek di dalam adegan.  Ini adalah repositori untuk sekumpulan komponen.  Objek dapat disarangkan, membentuk hierarki di dunia; </li><li>  Komponen - adalah data yang diperlukan untuk pengoperasian semua mekanika, dan yang menentukan perilaku objek.  Misalnya, `TransformComponent` berisi transformasi objek, dan` DynamicBodyComponent` berisi data untuk simulasi fisik.  Beberapa komponen mungkin tidak memiliki data tambahan, keberadaannya yang sederhana di objek menggambarkan keadaan objek ini.  Misalnya, dalam Battle Prime, `AliveComponent` dan` DeadComponent` digunakan, yang menandai karakter yang hidup dan mati, masing-masing; </li><li>  Sistem - seperangkat fungsi yang disebut secara berkala yang mendukung solusi dari tugasnya.  Dengan setiap panggilan, sistem memproses objek yang memenuhi beberapa kondisi (biasanya memiliki serangkaian komponen tertentu) dan, jika perlu, mengubahnya.  Semua logika game dan sebagian besar engine diimplementasikan pada level sistem.  Misalnya, di dalam mesin terdapat `LodSystem`, yang terlibat dalam menghitung indeks LOD (level detail) untuk objek berdasarkan transformasi di dunia dan data lainnya.  Indeks ini yang terkandung dalam `LodComponent` kemudian digunakan oleh sistem lain untuk tugas-tugasnya. </li></ul><br>  Pendekatan ini memudahkan untuk menggabungkan mekanika yang berbeda dalam objek yang sama.  Segera setelah entitas menerima data yang cukup untuk pekerjaan beberapa mekanik, sistem yang bertanggung jawab untuk mekanik ini mulai memproses objek ini. <br><br>  Dalam praktiknya, menambahkan fungsional baru mengurangi ke komponen baru (atau set komponen) dan sistem baru (atau set sistem) yang mengimplementasikan fungsional ini.  Dalam sebagian besar kasus, mengerjakan pola ini adalah hal yang mudah. <br><br><h2>  Refleksi </h2><br>  Sebelum melanjutkan ke deskripsi komponen dan sistem, saya akan membahas sedikit tentang mekanisme refleksi, karena akan sering digunakan dalam contoh kode. <br><br>  Refleksi memungkinkan Anda menerima dan menggunakan informasi tentang jenis saat aplikasi sedang berjalan.  Secara khusus, fitur berikut tersedia: <br><br><ul><li>  Dapatkan daftar jenis sesuai dengan kriteria tertentu (misalnya, pewaris kelas atau memiliki tag khusus), </li><li>  Dapatkan daftar bidang kelas, </li><li>  Dapatkan daftar metode di dalam kelas, </li><li>  Dapatkan daftar nilai enum, </li><li>  Panggil beberapa metode atau ubah nilai suatu bidang, </li><li>  Dapatkan metadata bidang atau metode yang dapat digunakan untuk fungsional tertentu. </li></ul><br>  Banyak modul di dalam mesin menggunakan refleksi untuk keperluan mereka sendiri.  Beberapa contoh: <br><br><ul><li>  Integrasi bahasa scripting menggunakan refleksi untuk bekerja dengan tipe yang dideklarasikan dalam kode C ++; </li><li>  Editor menggunakan refleksi untuk mendapatkan daftar komponen yang dapat ditambahkan ke objek, serta untuk menampilkan dan mengedit bidangnya; </li><li>  Modul jaringan menggunakan metadata bidang di dalam komponen untuk sejumlah fungsi: mereka menunjukkan parameter untuk mereplikasi bidang dari server ke klien, kuantisasi data selama replikasi, dan sebagainya; </li><li>  Berbagai konfigurasi dideserialisasi menjadi objek dari tipe yang sesuai menggunakan refleksi. </li></ul><br>  Kami menggunakan implementasi kami sendiri, antarmuka yang tidak jauh berbeda dari solusi lain yang ada (misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">github.com/rttrorg/rttr</a> ).  Menggunakan contoh CapturePointComponent (yang menjelaskan titik tangkap untuk mode permainan), menambahkan refleksi ke jenisnya terlihat seperti ini: <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//     class CapturePointComponent final : public Component { //            BZ_VIRTUAL_REFLECTION(Component); public: float points_to_own = 10.0f; String visible_name; // ‚Ä¶   }; //   .cpp  BZ_VIRTUAL_REFLECTION_IMPL(CapturePointComponent) { //       ReflectionRegistrar::begin_class&lt;CapturePointComponent&gt;() [M&lt;Serializable&gt;(), M&lt;Scriptable&gt;(), M&lt;DisplayName&gt;("Capture point")] //      .field("points_to_own", &amp;CapturePointComponent::points_to_own) [M&lt;Serializable&gt;(), M&lt;DisplayName&gt;("Points to own")] .field("visible_name", &amp;CapturePointComponent::visible_name) [M&lt;Serializable&gt;(), M&lt;DisplayName&gt;("Name")] // ‚Ä¶     }</span></span></code> </pre> <br>  Saya ingin memberikan perhatian khusus pada metadata jenis, bidang, dan metode yang dideklarasikan menggunakan ekspresi <br><br><pre> <code class="cpp hljs">M&lt;T&gt;()</code> </pre> <br>  di mana `T` adalah jenis metadata (di dalam perintah kita cukup menggunakan istilah" meta ", di masa depan saya akan menggunakannya).  Mereka digunakan oleh modul yang berbeda untuk keperluan mereka sendiri.  Sebagai contoh, editor menggunakan `DisplayName` untuk menampilkan nama jenis dan bidang di dalam editor, dan modul jaringan menerima daftar semua komponen, dan di antaranya mencari kolom bertanda` Replicable` - mereka akan dikirim dari server ke klien. <br><br><h2>  Deskripsi komponen dan tambahannya ke objek </h2><br>  Setiap komponen adalah pewaris kelas dasar `Komponen` dan dapat menggambarkan dengan bantuan refleksi bidang yang digunakannya (jika perlu). <br><br>  Beginilah cara `AvatarHitComponent` dideklarasikan dan dijelaskan di dalam game: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/** Component that indicates avatar hit event. */</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AvatarHitComponent</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Component { BZ_VIRTUAL_REFLECTION(Component); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: PlayerId source_id = NetConstants::INVALID_PLAYER_ID; PlayerId target_id = NetConstants::INVALID_PLAYER_ID; HitboxType hitbox_type = HitboxType::UNKNOWN; }; BZ_VIRTUAL_REFLECTION_IMPL(AvatarHitComponent) { ReflectionRegistrar::begin_class&lt;AvatarHitComponent&gt;() .ctor_by_pointer() .copy_ctor_by_pointer() .field(<span class="hljs-string"><span class="hljs-string">"source_id"</span></span>, &amp;AvatarHitComponent::source_id)[M&lt;Replicable&gt;()] .field(<span class="hljs-string"><span class="hljs-string">"target_id"</span></span>, &amp;AvatarHitComponent::target_id)[M&lt;Replicable&gt;()] .field(<span class="hljs-string"><span class="hljs-string">"hitbox_type"</span></span>, &amp;AvatarHitComponent::hitbox_type)[M&lt;Replicable&gt;()]; }</code> </pre> <br>  Komponen ini menandai objek yang dibuat sebagai hasil dari pemain memukul pemain lain.  Ini berisi informasi tentang acara ini, seperti pengidentifikasi pemain yang menyerang dan tujuannya, serta jenis kotak hit di mana serangan itu terjadi. <br>  Sederhananya, objek ini dibuat di dalam sistem server dengan cara yang mirip: <br><br><pre> <code class="cpp hljs">Entity hit_entity = world-&gt;create_entity(); <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>* <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> avatar_hit_component = hit_entity.add&lt;AvatarHitComponent&gt;(); avatar_hit_component-&gt;source_id = source_player_id; avatar_hit_component-&gt;target_id = target_player_id; avatar_hit_component-&gt;hitbox_type = hitbox_type; <span class="hljs-comment"><span class="hljs-comment">//      //      // ...</span></span></code> </pre> <br>  Objek dengan `AvatarHitComponent` kemudian digunakan oleh sistem yang berbeda: untuk memainkan suara memukul pemain, mengumpulkan statistik, melacak prestasi pemain, dan sebagainya. <br><br><h2>  Deskripsi sistem dan pekerjaannya </h2><br>  Suatu sistem adalah objek dengan tipe yang diwarisi dari `System`, yang berisi metode yang mengimplementasikan tugas tertentu.  Sebagai aturan, satu metode sudah cukup.  Beberapa metode diperlukan jika harus dilakukan pada titik waktu yang berbeda dalam kerangka yang sama. <br><br>  Mirip dengan komponen yang menggambarkan bidangnya, setiap sistem menggambarkan metode yang harus dilakukan oleh dunia. <br><br>  Sebagai contoh, ExplosiveSystem yang bertanggung jawab atas ledakan dinyatakan dan dijelaskan sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// System responsible for handling explosive components: // - tracking when they need to be exploded: by timer, trigger zone etc. // - destroying them on explosion and creating separate explosion entity class ExplosiveSystem final : public System { BZ_VIRTUAL_REFLECTION(System); public: ExplosiveSystem(World* world); private: void update(float dt); //    ,     // ... }; BZ_VIRTUAL_REFLECTION_IMPL(ExplosiveSystem) { ReflectionRegistrar::begin_class&lt;ExplosiveSystem&gt;()[M&lt;SystemTags&gt;("battle")] .ctor_by_pointer&lt;World*&gt;() .method("ExplosiveSystem::update", &amp;ExplosiveSystem::update)[M&lt;SystemTask&gt;( TaskGroups::GAMEPLAY_END, ReadAccess::set&lt; TimeSingleComponent, WeaponDescriptorComponent, BallisticComponent, ProjectileComponent, GrenadeComponent&gt;(), WriteAccess::set&lt;ExplosiveComponent&gt;(), InitAccess::set&lt;ExplosiveStatsComponent, LocalExplosionComponent, ServerExplosionComponent, EntityWasteComponent, ReplicationComponent, AbilityIdComponent, WeaponBaseStatsComponent, HitDamageStatsComponent, ClusterGrenadeStatsComponent&gt;(), UpdateType::FIXED, Vector&lt;TaskOrder&gt;{ TaskOrder::before(FastName{ "ballistic_update" }) })]; }</span></span></code> </pre> <br>  Data berikut ditunjukkan di dalam deskripsi sistem: <br><br><ul><li>  Tag yang menjadi milik sistem.  Setiap dunia berisi satu set tag, dan pada mereka adalah sistem yang harus bekerja di dunia ini.  Dalam hal ini, tag `battle` berarti dunia di mana pertempuran antara para pemain berlangsung.  Contoh lain dari tag adalah `server` dan` client` (masing-masing sistem hanya berjalan di server atau klien) dan `render` (sistem hanya berjalan dalam mode GUI); </li><li>  Grup tempat sistem ini dijalankan dan daftar komponen yang digunakan sistem ini - untuk menulis, membaca, dan membuat; </li><li>  Jenis pembaruan - apakah sistem ini harus bekerja dalam pembaruan normal, pembaruan tetap atau lainnya; </li><li>  Ketergantungan izin eksplisit antara sistem. </li></ul><br>  Informasi lebih lanjut tentang kelompok sistem, dependensi dan tipe pembaruan akan dijelaskan di bawah ini. <br><br>  Metode yang dideklarasikan dipanggil oleh dunia pada waktu yang tepat untuk menjaga fungsionalitas sistem ini.  Isi dari metode ini tergantung pada sistem, tetapi, sebagai aturan, ini adalah berjalan melalui semua objek yang memenuhi kriteria sistem ini, dan pembaruan selanjutnya.  Misalnya, memperbarui `ExplosiveSystem` di dalam game adalah sebagai berikut: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> ExplosiveSystem::update(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> dt) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>* time_single_component = world-&gt;get&lt;TimeSingleComponent&gt;(); <span class="hljs-comment"><span class="hljs-comment">// Init new explosives for (Component* component : new_explosives_group-&gt;components) { auto* explosive_component = static_cast&lt;ExplosiveComponent*&gt;(component); init_explosive(explosive_component, time_single_component); } new_explosives_group-&gt;components.clear(); // Update all explosives for (ExplosiveComponent* explosive_component : explosives_group) { update_explosive(explosive_component, time_single_component, dt); } }</span></span></code> </pre> <br>  Grup-grup dalam contoh di atas (`new_explosives_group` dan` explosives_group`) adalah wadah bantu yang menyederhanakan implementasi sistem.  new_explosives_group adalah wadah dengan objek baru yang diperlukan untuk sistem ini dan yang belum pernah diproses, dan explosives_group adalah wadah dengan semua objek yang perlu diproses setiap frame.  Dunia bertanggung jawab langsung untuk mengisi wadah-wadah ini.  Penerimaan mereka oleh sistem terjadi di konstruktornya: <br><br><pre> <code class="cpp hljs">ExplosiveSystem::ExplosiveSystem(World* world) : System(world) { <span class="hljs-comment"><span class="hljs-comment">// `explosives_group`        `ExplosiveComponent` explosives_group = world-&gt;acquire_component_group&lt;ExplosiveComponent&gt;(); // `new_explosives_group`        //  `ExplosiveComponent` -       new_explosives_group = explosive_group-&gt;acquire_component_group_on_add(); }</span></span></code> </pre> <br><h2>  Pembaruan dunia </h2><br>  Dunia, objek bertipe `Dunia`, masing-masing frame memanggil metode yang diperlukan dalam sejumlah sistem.  Sistem mana yang akan dipanggil tergantung pada tipenya. <br><br>  Bagian dari sistem setiap frame harus diperbarui (istilah "pembaruan normal" digunakan di dalam mesin) - tipe ini mencakup semua sistem yang memengaruhi rendering frame dan suara: animasi kerangka, partikel, UI, dan sebagainya.  Bagian lain dieksekusi pada frekuensi tetap yang telah ditentukan (kami menggunakan istilah "pembaruan tetap", dan untuk jumlah pembaruan tetap per detik - FFPS) - mereka memproses sebagian besar logika gameplay dan semua yang perlu disinkronkan antara klien dan server - misalnya, bagian dari input pemain, pergerakan karakter, pemotretan, bagian dari simulasi fisik. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/j7/uo/wo/j7uowoyprp2hgp3lqgdy9rsotpm.png" height="1024" width="768"></div><br><br>  Frekuensi pelaksanaan pembaruan tetap harus seimbang - nilai yang terlalu kecil mengarah ke permainan yang tidak responsif (misalnya, input pemain diproses lebih jarang, dan karenanya dengan penundaan yang lebih lama), dan terlalu tinggi - untuk persyaratan kinerja yang luar biasa dari perangkat tempat aplikasi itu berjalan.  Ini juga berarti bahwa semakin tinggi frekuensinya, semakin besar biaya kapasitas server (lebih sedikit pertempuran dapat bekerja secara bersamaan pada mesin yang sama). <br><br>  Pada gif di bawah ini, dunia bekerja pada frekuensi 5 pembaruan tetap per detik.  Anda dapat melihat penundaan antara menekan tombol W dan awal gerakan, serta penundaan antara melepaskan tombol dan menghentikan pergerakan karakter: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0dd/cbe/d6a/0ddcbed6a0354d56cc93efe6c2901b17.gif" alt="gambar" height="1024" width="768"></div><br>  Di gif berikutnya, dunia bekerja pada frekuensi 30 pembaruan tetap per detik, yang memberikan kontrol yang jauh lebih responsif: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fe9/330/c42/fe9330c427acbd0bf5c807edcd9463ff.gif" alt="gambar" height="1024" width="768"></div><br>  Saat ini, dalam pembaruan tetap Battle Prime dunia berjalan 31 kali per detik.  Nilai "jelek" seperti itu dipilih secara khusus - ini dapat menyebabkan bug yang tidak akan ada dalam situasi lain ketika jumlah pembaruan per detik, misalnya, angka bulat atau kelipatan dari refresh rate layar. <br><br><h2>  Perintah Eksekusi Sistem </h2><br>  Salah satu hal yang mempersulit pekerjaan dengan ECS adalah tugas menjalankan sistem.  Untuk konteks, pada saat penulisan, di klien Battle Prime selama pertempuran antara para pemain ada sistem 251 dan jumlah mereka hanya bertambah. <br><br>  Sebuah sistem yang keliru dijalankan pada waktu yang salah dapat menyebabkan bug halus atau keterlambatan pengoperasian beberapa mekanik untuk satu frame (misalnya, jika sistem kerusakan bekerja di awal frame dan sistem penerbangan proyektil pada akhirnya, maka kerusakan dilakukan dengan penundaan satu frame). <br><br>  Urutan eksekusi sistem dapat diatur dengan berbagai cara, misalnya: <br><br><ul><li>  Pemesanan eksplisit </li><li>  Indikasi "prioritas" numerik sistem dan penyortiran berikutnya berdasarkan prioritas; </li><li>  Secara otomatis membangun grafik dependensi antara sistem dan menginstalnya di tempat yang tepat dalam urutan eksekusi. </li></ul><br>  Saat ini, kami menggunakan opsi ketiga.  Setiap sistem menunjukkan komponen mana yang digunakannya untuk membaca, mana untuk menulis, dan komponen mana yang dibuatnya.  Kemudian, sistem secara otomatis diatur di antara mereka sendiri dalam urutan yang diperlukan: <br><ul><li>  Komponen pembacaan sistem A muncul setelah sistem menulis ke komponen A; </li><li>  Sistem yang menulis atau membaca komponen B datang setelah sistem yang membuat komponen B; </li><li>  Jika kedua sistem menulis ke komponen C, urutannya bisa apa saja (tetapi dapat ditentukan secara manual jika perlu). </li></ul><br>  Secara teori, solusi semacam itu meminimalkan kontrol atas urutan eksekusi, yang diperlukan hanyalah mengatur masker komponen untuk sistem.  Dalam praktiknya, dengan pertumbuhan proyek, ini mengarah pada semakin banyak siklus antar sistem.  Jika sistem-1 menulis ke komponen A, dan membaca komponen B, dan sistem-2 membaca komponen A dan menulis ke komponen B, ini merupakan siklus, dan harus diselesaikan secara manual.  Seringkali, ada lebih dari dua sistem dalam satu siklus.  Resolusi mereka membutuhkan waktu dan indikasi eksplisit tentang hubungan di antara mereka. <br><br>  Karena itu, Blitz Engine memiliki "kelompok" sistem.  Di dalam kelompok, sistem secara otomatis berbaris dalam urutan yang diinginkan (dan siklus masih diselesaikan secara manual), dan urutan kelompok diatur secara eksplisit.  Keputusan ini merupakan persilangan antara pesanan yang sepenuhnya manual dan yang sepenuhnya otomatis, dan ukuran kelompok sangat memengaruhi efektivitasnya.  Begitu grup menjadi terlalu besar, programmer lagi sering menemukan masalah loop di dalamnya. <br><br>  Saat ini ada 10 grup di Battle Prime.  Ini masih belum cukup, dan kami berencana untuk menambah jumlahnya dengan membangun urutan logis yang ketat di antara mereka, dan menggunakan konstruksi otomatis dari grafik di dalam masing-masing. <br><br>  Indikasi komponen mana yang digunakan oleh sistem untuk menulis atau membaca juga akan memungkinkan di masa depan untuk secara otomatis mengelompokkan sistem menjadi "blok" yang akan dieksekusi secara paralel satu sama lain. <br><br>  Di bawah ini adalah utilitas tambahan yang menampilkan daftar sistem dan dependensi di antara mereka di dalam masing-masing grup (grafik lengkap di dalam grup terlihat mengintimidasi).  Warna oranye menunjukkan ketergantungan yang didefinisikan secara eksplisit antara sistem: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/592/2a4/fae/5922a4fae880eb7c80252628a827d2a0.gif" alt="gambar" height="1024" width="768"></div><br><h2>  Komunikasi antara sistem dan konfigurasinya </h2><br>  Tugas-tugas yang dilakukan sistem dalam diri mereka sendiri, sampai taraf tertentu, bergantung pada hasil dari sistem lain.  Sebagai contoh, suatu sistem yang memproses tabrakan dari dua objek tergantung pada simulasi fisika yang mendaftarkan tabrakan ini.  Dan sistem kerusakan tergantung pada hasil sistem balistik, yang bertanggung jawab atas pergerakan kerang. <br><br>  Cara paling sederhana dan paling jelas untuk berkomunikasi antar sistem adalah dengan menggunakan komponen.  Satu sistem menambahkan hasil pekerjaannya ke dalam komponen, dan sistem kedua membaca hasil ini dari komponen dan memecahkan masalahnya berdasarkan pada mereka. <br><br>  Pendekatan berbasis komponen mungkin tidak nyaman dalam beberapa kasus: <br><br><ul><li>  Bagaimana jika hasil dari sistem tidak terikat langsung ke beberapa objek?  Misalnya, sistem yang mengumpulkan statistik pertempuran (jumlah tembakan, klik, kematian, dan sebagainya) - mengumpulkannya secara global, berdasarkan seluruh pertempuran; </li><li>  Bagaimana jika sistem perlu dikonfigurasi dengan cara tertentu?  Misalnya, sistem simulasi fisik perlu mengetahui jenis objek mana yang harus merekam tabrakan antara mereka dan yang tidak. </li></ul><br>  Untuk mengatasi masalah ini, kami menggunakan pendekatan yang kami pinjam dari tim pengembangan Overwatch - Komponen Tunggal. <br><br>  Komponen tunggal adalah komponen yang ada di dunia dalam satu salinan dan diperoleh langsung dari dunia.  Sistem dapat menggunakannya untuk menjumlahkan hasil pekerjaan mereka, yang kemudian digunakan oleh sistem lain, atau untuk mengkonfigurasi pekerjaan mereka. <br><br>  Saat ini, proyek (modul mesin + permainan) memiliki sekitar 120 Komponen Tunggal yang digunakan untuk berbagai keperluan - mulai dari menyimpan data dunia global hingga konfigurasi sistem individual. <br><br><h2>  Pendekatan "Bersih" </h2><br>  Dalam bentuknya yang paling murni, pendekatan seperti itu terhadap sistem dan komponen membutuhkan ketersediaan data hanya di dalam komponen dan keberadaan logika hanya di dalam sistem.  Menurut pendapat saya, dalam praktiknya, pembatasan ini jarang masuk akal untuk diamati secara ketat (meskipun perdebatan tentang hal ini masih diangkat secara berkala). <br><br>  Argumen berikut yang mendukung pendekatan yang kurang "keras" dapat disorot: <br><br><ul><li>  Bagian dari kode harus dibagikan - dan dijalankan secara serempak dari sistem yang berbeda atau ketika mengatur beberapa properti komponen.  Logika serupa dijelaskan secara terpisah.  Sebagai bagian dari mesin, kami menggunakan istilah Utils.  Misalnya, di dalam game `DamageUtils` berisi logika yang terkait dengan aplikasi kerusakan - yang dapat diterapkan dari sistem yang berbeda; </li><li>  Tidak masuk akal untuk menyimpan data pribadi sistem di suatu tempat selain dari sistem ini sendiri - tidak ada yang akan membutuhkannya kecuali untuk itu, dan memindahkannya ke tempat lain tidak terlalu berguna.  Ada pengecualian untuk aturan ini, yang terkait dengan fungsi prediksi klien - ini akan ditulis tentang bagian di bawah ini; </li><li>  Berguna bagi komponen untuk memiliki sedikit logika - sebagian besar adalah getter dan setter pintar yang menyederhanakan bekerja dengan komponen. </li></ul><br><h1>  Netcode </h1><br>  Battle Prime menggunakan arsitektur dengan server yang otoriter dan prediksi klien.  Hal ini memungkinkan pemain untuk menerima umpan balik instan dari tindakan mereka bahkan pada ping tinggi dan paket kerugian, dan proyek secara keseluruhan - untuk meminimalkan kecurangan oleh pemain, karena  server menentukan semua hasil simulasi di dalam pertempuran. <br><br>  Semua kode di dalam proyek game dibagi menjadi tiga bagian: <br><br><ul><li>  Klien - sistem dan komponen yang hanya berfungsi pada klien.  Ini termasuk hal-hal seperti UI, pemotretan otomatis dan interpolasi; </li><li>  Server - sistem dan komponen yang hanya berfungsi di server.  Misalnya, segala sesuatu yang berkaitan dengan kerusakan dan menelurkan karakter; </li><li>  Umum - ini adalah semua yang berfungsi pada server dan klien.  Secara khusus, semua sistem yang menghitung pergerakan karakter, keadaan senjata (jumlah putaran, cooldown) dan segala hal lain yang perlu diprediksi pada klien.  Sebagian besar sistem yang bertanggung jawab atas efek visual juga umum - server secara opsional dapat diluncurkan dalam mode GUI (sebagian besar hanya untuk debugging). </li></ul><br><h2>  Input pengguna (input) </h2><br>  Sebelum beralih ke detail replikasi dan prediksi pada klien, Anda harus memikirkan untuk bekerja dengan input di dalam mesin - detailnya akan penting di bagian di bawah ini. <br><br>  Semua input dari pemain dibagi menjadi dua jenis: level rendah dan level tinggi: <br><br><ul><li>  Input tingkat rendah - ini adalah peristiwa dari perangkat input, seperti penekanan tombol, menyentuh layar, dan sebagainya.  Masukan seperti itu jarang diproses oleh sistem permainan; </li><li>  Input tingkat tinggi - adalah tindakan pengguna yang dilakukan olehnya dalam konteks permainan: tembakan, perubahan senjata, pergerakan karakter, dan sebagainya.  Untuk tindakan tingkat tinggi seperti itu, kami menggunakan istilah `Aksi`.  Selain itu, data tambahan dapat dikaitkan dengan tindakan - seperti arah gerakan atau indeks senjata yang dipilih.  Sebagian besar sistem bekerja dengan Aksi. </li></ul><br>  Input tingkat tinggi dihasilkan berdasarkan pengikat dari input tingkat rendah, atau secara terprogram.  Misalnya, aksi penembakan dapat diikat ke klik mouse, atau dapat dihasilkan oleh sistem yang bertanggung jawab untuk penembakan otomatis - segera setelah pemain membidik musuh, sistem ini menghasilkan bidikan aksi jika pengguna mengaktifkan pengaturan yang sesuai.  Tindakan juga dapat dikirim oleh sistem UI: misalnya, dengan menekan tombol yang sesuai atau ketika menggerakkan joystick di layar.  Sistem yang menyala tidak peduli bagaimana tindakan ini dibuat. <br><br>  Tindakan yang terkait secara logis dikelompokkan bersama (objek bertipe `ActionSet`).  Grup dapat terputus jika mereka tidak diperlukan dalam konteks saat ini - misalnya, di Battle Prime ada beberapa kelompok, di antaranya: <br><br><ul><li>  Tindakan untuk mengontrol pergerakan karakter, </li><li>  Tindakan untuk menembakkan senjata otomatis, </li><li>  Tindakan untuk menembakkan senjata semi-otomatis. </li></ul><br>  Dari dua kelompok terakhir, hanya satu yang aktif pada satu waktu, tergantung pada jenis senjata yang dipilih - mereka berbeda dalam bagaimana tindakan KEBAKARAN dihasilkan: ketika tombol ditekan (untuk senjata otomatis) atau hanya sekali ketika tombol ditekan (untuk senjata semi-otomatis ) <br><br>  Demikian pula, kelompok tindakan dibuat dan dikonfigurasi dalam permainan di dalam salah satu sistem: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Map&lt;FastName, ActionSet&gt; action_sets = { { <span class="hljs-comment"><span class="hljs-comment">//     ControlModes::CHARACTER_MOVEMENT, ActionSet { { DigitalBinding{ ActionNames::JUMP, { { InputCode::KB_SPACE, DigitalState::just_pressed() } }, nullopt }, DigitalBinding{ ActionNames::MOVE, { { InputCode::KB_W, DigitalState::pressed() } }, ActionValue{ AnalogState{0.0f, 1.0f, 0.0f} } }, //    ... }, { AnalogBinding{ ActionNames::LOOK, InputCode::MOUSE_RELATIVE_POSITION, AnalogStateType::ABSOLUTE, AnalogStateBasis::LOGICAL, {} } //    ... } } }, { //       ControlModes::AUTOMATIC_FIRE, ActionSet { { // FIRE    ,      DigitalBinding{ ActionNames::FIRE, { { InputCode::MOUSE_LBUTTON, DigitalState::pressed() } }, nullopt }, //       ... } } }, { //       ControlModes::SEMI_AUTOMATIC_FIRE, ActionSet { { // FIRE          DigitalBinding{ ActionNames::FIRE, { { InputCode::MOUSE_LBUTTON, DigitalState::just_pressed() } }, nullopt }, //       ... } } } //   ... };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Battle Prime menggambarkan sekitar 40 aksi. </font><font style="vertical-align: inherit;">Beberapa dari mereka hanya digunakan untuk debugging atau merekam klip.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Replikasi </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Replikasi adalah proses mentransfer data dari server ke klien. </font><font style="vertical-align: inherit;">Semua data ditransmisikan melalui objek di dunia:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Penciptaan dan penghapusan mereka, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Membuat dan menghapus komponen pada objek, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ubah properti komponen. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Replikasi dikonfigurasikan menggunakan komponen yang sesuai. </font><font style="vertical-align: inherit;">Misalnya, dengan cara yang sama, permainan mengatur replikasi senjata pemain:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>* replication_component = weapon_entity.add&lt;ReplicationComponent&gt;(); replication_component-&gt;enable_replication&lt;WeaponDescriptorComponent&gt;(Privacy::PUBLIC); replication_component-&gt;enable_replication&lt;WeaponBaseStatsComponent&gt;(Privacy::PUBLIC); replication_component-&gt;enable_replication&lt;WeaponComponent&gt;(Privacy::PRIVATE); replication_component-&gt;enable_replication&lt;BallisticsStatsComponent&gt;(Privacy::PRIVATE); <span class="hljs-comment"><span class="hljs-comment">// ...   </span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk setiap komponen, privasi yang digunakan selama replikasi ditunjukkan. Komponen pribadi akan dikirim dari server hanya ke pemain yang memiliki senjata ini. Komponen publik akan dikirim ke semua orang. Dalam contoh ini, `WeaponDescriptorComponent` dan` WeaponBaseStatsComponent` bersifat publik - mereka berisi data yang diperlukan untuk tampilan yang benar dari pemain lain. Misalnya, indeks slot tempat senjata berada dan tipenya diperlukan untuk animasi. Komponen yang tersisa dikirim secara pribadi ke pemain yang memiliki senjata ini - parameter balistik cangkang, informasi tentang jumlah total ronde, mode pemotretan yang tersedia, dan sebagainya. Ada mode privasi yang lebih khusus: misalnya, Anda dapat mengirim komponen hanya ke sekutu atau hanya ke musuh.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setiap komponen dalam uraiannya harus menunjukkan bidang mana yang harus direplikasi dalam komponen ini. </font><font style="vertical-align: inherit;">Misalnya, semua bidang di dalam `WeaponComponent` ditandai sebagai` Replicable`:</font></font><br><br><pre> <code class="cpp hljs">BZ_VIRTUAL_REFLECTION_IMPL(WeaponComponent) { ReflectionRegistrar::begin_class&lt;WeaponComponent&gt;() .ctor_by_pointer() .copy_ctor_by_pointer() .field(<span class="hljs-string"><span class="hljs-string">"owner"</span></span>, &amp;WeaponComponent::owner)[M&lt;Replicable&gt;()] .field(<span class="hljs-string"><span class="hljs-string">"fire_mode"</span></span>, &amp;WeaponComponent::fire_mode)[M&lt;Replicable&gt;()] .field(<span class="hljs-string"><span class="hljs-string">"loaded_ammo"</span></span>, &amp;WeaponComponent::loaded_ammo)[M&lt;Replicable&gt;()] .field(<span class="hljs-string"><span class="hljs-string">"ammo"</span></span>, &amp;WeaponComponent::ammo)[M&lt;Replicable&gt;()] .field(<span class="hljs-string"><span class="hljs-string">"shooting_cooldown_end_ms"</span></span>, &amp;WeaponComponent::shooting_cooldown_end_ms)[M&lt;Replicable&gt;()]; }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mekanisme ini sangat nyaman digunakan. </font><font style="vertical-align: inherit;">Misalnya, di dalam sistem server, yang bertanggung jawab untuk "mengeluarkan" token dari lawan yang terbunuh (dalam mode permainan khusus), itu sudah cukup untuk menambah dan mengkonfigurasi `ReplicationComponent` pada token semacam itu. </font><font style="vertical-align: inherit;">Ini terlihat seperti ini:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Component* component : added_dead_avatars-&gt;components) { Entity kill_token_entity = world-&gt;create_entity(); <span class="hljs-comment"><span class="hljs-comment">//           // ... //   auto* replication_component = kill_token_entity.add&lt;ReplicationComponent&gt;(); replication_component-&gt;enable_replication&lt;TransformComponent&gt;(Privacy::PUBLIC); replication_component-&gt;enable_replication&lt;KillTokenComponent&gt;(Privacy::PUBLIC); }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam contoh ini, simulasi fisik token selama kehilangan akan terjadi di server, dan transformasi akhir token akan dikirim dan diterapkan pada klien. Sistem interpolasi juga akan berfungsi pada klien, yang akan memuluskan pergerakan token ini, dengan mempertimbangkan frekuensi pembaruan, kualitas koneksi ke server, dan sebagainya. Sistem lain yang terkait dengan mode permainan ini akan menambahkan bagian visual ke objek dengan `KillTokenComponent` dan memantau pilihannya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Satu-satunya ketidaknyamanan dari pendekatan saat ini yang ingin Anda perhatikan dan yang ingin Anda singkirkan di masa depan adalah ketidakmampuan untuk mengatur privasi untuk setiap bidang komponen. Ini tidak terlalu kritis, karena masalah yang sama dapat dengan mudah diselesaikan dengan membagi komponen menjadi beberapa: misalnya, permainan berisi `ShooterPublicComponent` dan` ShooterPrivateComponent` dengan privasi yang sesuai. Terlepas dari kenyataan bahwa mereka terikat pada satu mekanik (pemotretan), diperlukan dua komponen untuk menghemat lalu lintas - beberapa bidang sama sekali tidak diperlukan pada klien yang tidak memiliki komponen ini. Namun, ini menambah pekerjaan ke programmer.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara umum, objek yang direplikasi ke klien dapat memiliki status untuk frame yang berbeda. </font><font style="vertical-align: inherit;">Oleh karena itu, kemampuan untuk mengelompokkan objek dengan membentuk kelompok replikasi ditambahkan. </font><font style="vertical-align: inherit;">Semua komponen pada objek dalam grup yang sama selalu memiliki keadaan untuk frame yang sama pada klien - ini diperlukan agar prediksi berfungsi dengan benar (lebih lanjut tentang mereka di bawah). </font><font style="vertical-align: inherit;">Misalnya, senjata dan karakter yang memilikinya berada dalam kelompok yang sama. </font><font style="vertical-align: inherit;">Jika objek berada dalam kelompok yang berbeda, maka negara mereka di dunia dapat untuk bingkai yang berbeda. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sistem replikasi mencoba untuk meminimalkan jumlah lalu lintas, khususnya dengan mengompresi data yang dikirimkan (setiap bidang di dalam komponen secara opsional dapat ditandai sesuai untuk kompresi) dan dengan mentransmisikan hanya perbedaan nilai antara dua frame.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Prediksi pelanggan </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prediksi klien (istilah prediksi sisi klien digunakan dalam bahasa Inggris) memungkinkan pemain untuk menerima umpan balik instan pada sebagian besar tindakannya dalam permainan. </font><font style="vertical-align: inherit;">Pada saat yang sama, karena kata terakhir selalu berada di belakang server, jika ada kesalahan dalam simulasi (istilah mispredict digunakan dalam bahasa Inggris, di masa depan saya akan memanggil mereka hanya "salah duga") klien harus memperbaikinya. </font><font style="vertical-align: inherit;">Rincian lebih lanjut tentang kesalahan prediksi dan bagaimana mereka diperbaiki akan dijelaskan di bawah ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Prediksi klien bekerja sesuai dengan aturan berikut:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Klien mensimulasikan dirinya sendiri maju dengan N frame; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Semua input yang dihasilkan oleh klien dikirim ke server (dalam bentuk tindakan yang dilakukan oleh pemain); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">N tergantung pada kualitas koneksi ke server. </font><font style="vertical-align: inherit;">Semakin kecil nilai ini, semakin "terkini" gambaran dunia diperuntukkan bagi klien (yaitu, jarak waktu antara pemain lokal dan pemain lain lebih kecil).</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akibatnya, server dan klien melakukan simulasi berdasarkan input klien. </font><font style="vertical-align: inherit;">Server kemudian mengirimkan hasil simulasi ini ke klien. </font><font style="vertical-align: inherit;">Jika klien menentukan bahwa hasilnya tidak sesuai dengan yang di server, maka ia mencoba untuk memperbaiki kesalahan - memutar dirinya kembali ke keadaan server yang terakhir diketahui, dan lagi mensimulasikan N frame di depan. </font><font style="vertical-align: inherit;">Kemudian semuanya berlanjut sesuai dengan skema yang sama - klien terus mensimulasikan dirinya sendiri di masa depan sehubungan dengan server, dan server mengirimkannya hasil simulasi. </font><font style="vertical-align: inherit;">Oleh karena itu, semua kode yang mempengaruhi prediksi klien harus dibagi antara klien dan server.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Juga, untuk menghemat lalu lintas, seluruh input dipadatkan berdasarkan skema yang telah ditentukan. Kemudian dikirim ke server dan segera didekompresi kembali ke klien. Pengemasan dan pembongkaran selanjutnya pada klien diperlukan untuk menghilangkan perbedaan dalam nilai yang terkait dengan input antara klien dan server. Saat membuat skema, kisaran nilai untuk tindakan ini ditunjukkan, dan jumlah bit yang harus dimasukkan. Demikian pula, pengumuman skema kemasan di Battle Prime terlihat seperti di dalam sistem umum antara klien dan server:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span>* input_packing_sc = world-&gt;get_for_write&lt;InputPackingSingleComponent&gt;(); input_packing_sc-&gt;packing_schema = { { ActionNames::MOVE, AnalogStatePrecision{ <span class="hljs-number"><span class="hljs-number">8</span></span>, { <span class="hljs-number"><span class="hljs-number">-1.f</span></span>, <span class="hljs-number"><span class="hljs-number">1.f</span></span> }, <span class="hljs-literal"><span class="hljs-literal">false</span></span> } }, { ActionNames::LOOK, AnalogStatePrecision{ <span class="hljs-number"><span class="hljs-number">16</span></span>, { -PI, PI }, <span class="hljs-literal"><span class="hljs-literal">false</span></span> } }, { ActionNames::JUMP, nullopt }, <span class="hljs-comment"><span class="hljs-comment">// ..    action' };</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kondisi kritis untuk kinerja prediksi klien untuk bekerja adalah kebutuhan input untuk memiliki waktu untuk sampai ke server pada saat simulasi frame yang input ini berhubungan. Jika input tidak berhasil mencapai frame yang diinginkan pada server (ini dapat terjadi selama, misalnya, lompatan ping yang tajam), server akan mencoba menggunakan input dari klien ini dari frame sebelumnya. Ini adalah mekanisme cadangan yang dapat membantu menghilangkan salah duga pada klien dalam beberapa situasi. Misalnya, jika klien hanya berjalan dalam satu arah dan inputnya tidak berubah untuk waktu yang relatif lama, penggunaan input untuk frame terakhir akan berhasil - server akan "menebak" itu, dan tidak akan ada perbedaan antara klien dan server. Skema serupa digunakan di Overwatch (disebutkan dalam ceramah tentang GDC:</font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">www.youtube.com/watch?v=W3aieHjyNvw</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat ini, klien Battle Prime memprediksi status objek berikut:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pemain avatar (posisi di dunia dan segala sesuatu yang dapat memengaruhinya, keadaan keterampilan, dll); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Semua senjata pemain (jumlah putaran di toko, cooldown di antara tembakan, dll.). </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan prediksi klien adalah menambah dan mengkonfigurasi `PredictionComponent` pada klien ke objek yang diinginkan. </font><font style="vertical-align: inherit;">Misalnya, prediksi avatar pemain di salah satu sistem dihidupkan dengan cara yang sama:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// `new_local_avatars`       , //      for (Entity avatar : new_local_avatars) { auto* avatar_prediction_component = avatar.add&lt;PredictionComponent&gt;(); avatar_prediction_component-&gt;enable_prediction&lt;TransformComponent&gt;(); avatar_prediction_component-&gt;enable_prediction&lt;CharacterControllerComponent&gt;(); avatar_prediction_component-&gt;enable_prediction&lt;ShooterPrivateComponent&gt;(); avatar_prediction_component-&gt;enable_prediction&lt;ShooterPublicComponent&gt;(); // ...      }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kode ini berarti bahwa bidang di dalam komponen di atas akan terus-menerus dibandingkan dengan bidang yang sama dari komponen server - jika ada ketidaksesuaian dalam nilai-nilai dalam bingkai tunggal diperhatikan, penyesuaian akan dilakukan pada klien. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kriteria perbedaan tergantung pada jenis data. Dalam kebanyakan kasus, ini hanya panggilan ke `operator ==`, pengecualiannya adalah data berdasarkan float - bagi mereka kesalahan maksimum yang diijinkan saat ini diperbaiki dan sama dengan 0,005. Di masa depan, ada keinginan untuk menambahkan kemampuan untuk mengatur akurasi untuk setiap bidang komponen secara terpisah.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alur kerja replikasi dan prediksi klien didasarkan pada kenyataan bahwa semua data yang diperlukan untuk simulasi terkandung dalam komponen. Di atas, pada bagian ECS, saya menulis bahwa sistem diperbolehkan untuk menyimpan sebagian data - ini bisa nyaman dalam beberapa kasus. Ini tidak berlaku untuk data apa pun yang mempengaruhi simulasi - itu harus selalu di dalam komponen, karena sistem snapshot klien dan server hanya bekerja dengan komponen.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain memprediksi nilai bidang dalam komponen, dimungkinkan untuk memprediksi pembuatan dan penghapusan komponen. Misalnya, jika, sebagai akibat dari menggunakan kemampuan, `SpeedModifierComponent` ditumpangkan pada karakter (yang memodifikasi kecepatan gerakan, misalnya, mempercepat pemain), maka itu harus ditambahkan ke karakter baik di server dan pada klien di frame yang sama, jika tidak, maka akan menyebabkan prediksi posisi karakter pada klien yang salah. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Memprediksi penciptaan dan penghapusan objek saat ini tidak didukung. Ini mungkin nyaman dalam beberapa situasi, tetapi juga akan menyulitkan modul jaringan. Mungkin kita akan kembali ke ini di masa depan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di bawah ini adalah gif di mana kontrol karakter berlangsung dengan RTT selama sekitar 1,5 detik. </font><font style="vertical-align: inherit;">Seperti yang Anda lihat, karakter dikontrol secara instan, meskipun ada penundaan tinggi: bergerak, menembak, memuat ulang, melempar granat - semuanya terjadi tanpa menunggu informasi dari server. </font><font style="vertical-align: inherit;">Anda juga dapat memperhatikan bahwa penangkapan suatu titik (zona yang dibatasi oleh segitiga) dimulai dengan penundaan - mekanisme ini hanya berfungsi pada server dan tidak diprediksi oleh klien.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a6b/224/09f/a6b22409f317a314819b0163f14f2b6e.gif" alt="gambar" height="1024" width="768"></div><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kesalahan prediksi dan resimulasi </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mispredict - perbedaan antara hasil simulasi server dan klien. Resimulasi adalah proses memperbaiki perbedaan ini oleh klien. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alasan pertama untuk munculnya salah duga adalah lompatan ping yang tajam, di mana klien tidak punya waktu untuk menyesuaikan. Dalam situasi seperti itu, input dari pemain mungkin tidak punya waktu untuk sampai ke server, dan server akan menggunakan mekanisme cadangan yang dijelaskan di atas dengan duplikasi input terakhir untuk beberapa waktu, dan setelah beberapa saat ia akan berhenti menggunakannya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alasan kedua adalah interaksi karakter dengan objek yang sepenuhnya dikontrol server dan tidak diprediksi secara lokal oleh klien. Misalnya, tabrakan dengan pemain lain akan menyebabkan kesalahan prediksi - karena mereka, pada kenyataannya, hidup dalam dua periode waktu yang berbeda (karakter lokal di masa depan relatif terhadap pemain lain - yang posisinya berasal dari server dan diinterpolasi). </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alasan ketiga dan paling tidak menyenangkan adalah bug dalam kode. Misalnya, suatu sistem dapat secara keliru menggunakan data yang tidak direplikasi untuk mengendalikan simulasi, atau sistem bekerja dalam urutan yang salah, atau bahkan dalam urutan berbeda pada server dan klien. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menemukan bug ini terkadang membutuhkan waktu yang cukup lama. Untuk mempermudah pencarian mereka, kami membuat beberapa alat bantu - saat aplikasi berjalan, Anda dapat melihat:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Komponen yang direplikasi </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jumlah salah duga </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Di frame mana mereka terjadi, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Data apa yang ada di server dan klien di komponen yang berbeda, </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Masukan apa yang diterapkan pada server dan pada klien untuk frame ini. </font></font></li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/9d/ym/7x/9dym7xq_wej-rqkes4zumdvkrxa.png" height="1024" width="768"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/4t/4i/ar/4t4iarkyqjkmgdlbabbfordysgi.png" height="1024" width="768"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/gp/zt/cy/gpztcyp0k9yobauozchbixe4suy.png" height="1024" width="768"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sayangnya, bahkan dengan mereka, pencarian penyebab resimulasi masih membutuhkan waktu yang cukup lama. </font><font style="vertical-align: inherit;">Tidak diragukan lagi, alat dan validasi perlu dikembangkan untuk mengurangi kemungkinan bug dan menyederhanakan pencarian mereka. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mendukung operasi resimulasi, sistem harus mewarisi dari kelas tertentu `ResimulatableSystem`. </font><font style="vertical-align: inherit;">Dalam situasi ketika mispredict terjadi, dunia "memutar kembali" semua objek ke kondisi server yang terakhir diketahui, dan kemudian membuat jumlah simulasi yang diperlukan untuk memperbaiki kesalahan ini - hanya sistem yang dapat diulang yang akan berpartisipasi dalam hal ini.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Secara umum, resimulasi klien tidak boleh terlihat oleh pemain. </font><font style="vertical-align: inherit;">Ketika mereka terjadi, semua bidang komponen diinterpolasi dengan lancar ke dalam nilai baru untuk secara visual memuluskan kemungkinan ‚Äúberkedut‚Äù. </font><font style="vertical-align: inherit;">Namun, sangat penting untuk menjaga jumlah mereka serendah mungkin.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menembak </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kerusakan pada pemain sepenuhnya ditentukan oleh server - pelanggan tidak dapat dipercaya dalam mekanisme yang sedemikian penting untuk mengurangi kemungkinan kecurangan. Tetapi, seperti gerakan, menembak pada klien harus responsif mungkin dan tanpa penundaan - pemain harus menerima umpan balik instan dalam bentuk efek dan suara - moncong flash, jejak penerbangan proyektil, serta efek proyektil mengenai lingkungan dan pemain lain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oleh karena itu, seluruh keadaan karakter yang terkait dengan penembakan diprediksi oleh klien - berapa banyak putaran yang ada di toko, dispersi selama penembakan, penundaan antara tembakan, waktu tembakan terakhir, dan sebagainya. Juga pada klien adalah sistem yang sama yang bertanggung jawab untuk pergerakan cangkang seperti pada server - ini memungkinkan Anda untuk mensimulasikan tembakan pada klien tanpa menunggu hasil simulasi mereka di server.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Balistik cangkang itu sendiri tidak dapat diprediksi - karena mereka terbang dengan kecepatan yang sangat tinggi, dan, sebagai aturan, menyelesaikan gerakan mereka dalam beberapa bingkai, cangkang tersebut akan memiliki waktu untuk sampai ke suatu titik di dunia dan kehilangan efeknya sebelum kita mendapatkan hasil simulasi ini adalah proyektil dari server (atau kurangnya hasil jika, karena kesalahan prediksi, klien menembakkan proyektil karena kesalahan).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Skema kerja proyektil terbang lambat sedikit berbeda. </font><font style="vertical-align: inherit;">Jika seorang pemain melempar granat, tetapi akibat salah duga ternyata granat itu tidak terlempar, itu akan dihancurkan pada klien. </font><font style="vertical-align: inherit;">Demikian pula, jika klien salah memperkirakan kerusakan sebuah granat (itu sudah meledak di server, tetapi belum pada klien), maka granat klien juga akan dihancurkan. </font><font style="vertical-align: inherit;">Semua informasi tentang ledakan yang ditampilkan pada klien berasal dari server untuk menghindari situasi di mana, sebagai akibat dari kesalahan klien, ledakan server terjadi di satu tempat dan pada klien di tempat lain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Idealnya, saya ingin benar-benar memprediksi kerang terbang lambat di masa depan - tidak hanya waktu hidup, tetapi juga posisi mereka.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kompensasi keterlambatan </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompensasi lag adalah teknik yang memungkinkan Anda untuk meningkatkan efek keterlambatan antara server dan klien pada akurasi pengambilan gambar. </font><font style="vertical-align: inherit;">Di bagian ini, saya akan menganggap bahwa penembakan selalu berasal dari senjata "hitscan" - mis. </font><font style="vertical-align: inherit;">proyektil yang ditembakkan oleh senjata bergerak dengan kecepatan tak terbatas. </font><font style="vertical-align: inherit;">Tetapi segala sesuatu yang dijelaskan di sini juga penting dengan jenis senjata lainnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Poin-poin berikut membuatnya perlu untuk mengkompensasi kelambatan saat memotret:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Karakter di bawah kendali pemain di masa depan relatif terhadap server (memprediksi keadaannya untuk sejumlah frame di depan); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konsekuensinya, sisa pemain ada hubungannya dengan dia di masa lalu; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ketika dipecat, tindakan yang sesuai dikirim oleh klien ke server dan diterapkan pada bingkai yang sama dengan yang diterapkan pada klien (jika mungkin). </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jika kami menganggap bahwa pemain membidik musuh yang berlari ke arah kepala dan menekan tombol tembakan, gambar berikut diperoleh: </font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pada klien: penembak pada frame N1 melepaskan tembakan ke kepala musuh yang terletak di frame N0 (N0 &lt;N1); </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Di server: penembak pada frame N1 menembakkan tembakan ke kepala musuh, juga terletak di frame N1 (di server, semuanya ada pada waktu yang bersamaan). </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasil ini, dengan probabilitas tinggi, adalah kehilangan selama tembakan. </font><font style="vertical-align: inherit;">Karena klien menargetkan berdasarkan gambarnya tentang dunia, yang tidak sesuai dengan gambar dunia server, untuk masuk ke musuh, ia harus membidiknya bahkan ketika menggunakan senjata hitscan, dan jarak di depannya yang harus dia tembak tergantung pada kualitas koneksi dengan server. </font><font style="vertical-align: inherit;">Singkatnya, ini bukan pengalaman yang baik bagi seorang penembak. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menghilangkan masalah ini, kompensasi lag digunakan. </font><font style="vertical-align: inherit;">Skema karyanya adalah sebagai berikut:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Server memiliki sejarah snapshot ukuran terbatas di dunia; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ketika ditembakkan, musuh (atau bagian dari musuh) ‚Äúmemutar balik‚Äù sedemikian rupa sehingga dunia pada server cocok dengan dunia yang dilihat klien dalam dirinya sendiri - klien ada di "sekarang" (saat tembakan), dan musuh di masa lalu; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mekanisme deteksi hit berfungsi, hit direkam; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dunia kembali ke keadaan semula. </font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Karena gambaran dunia pada klien juga tergantung pada pengoperasian sistem interpolasi, untuk ‚Äúmemutar kembali‚Äù dunia ke status klien yang paling akurat di server, klien memberinya data tambahan - perbedaan antara kerangka klien saat ini dan kerangka di mana ia melihat semua pemain lain (saat ini adalah dua byte per frame), serta waktu pembuatan input bidikan relatif terhadap awal frame. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kompensasi lag ada pada level modul terpisah di dalam mesin dan tidak terikat pada proyek tertentu. </font><font style="vertical-align: inherit;">Dari sudut pandang pengembang mekanika gameplay, penggunaannya adalah sebagai berikut:</font></font><br><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> `LagCompensationComponent` ditambahkan ke pemain, dan daftar hitbox yang akan disimpan dalam sejarah diisi; </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saat memotret (atau mekanik lain yang membutuhkan kompensasi - misalnya, dalam serangan jarak dekat), `LagCompensation :: invoke` dipanggil, di mana functor dilewatkan, yang akan dieksekusi dalam" kompensasi ", dari sudut pandang pemain tertentu, dunia. </font><font style="vertical-align: inherit;">Itu harus memiliki semua deteksi hit yang diperlukan.</font></font></li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kode dengan contoh penggunaan kompensasi jeda dari Batle Prime saat memindahkan proyektil balistik: </font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// `targets_data`    , //   ‚Äú‚Äù    , //    const auto compensated_action = [this](const Vector&lt;LagCompensation::LagCompensationData&gt;&amp; targets_data) { process_projectile(projectile, elapsed_time); }; LagCompensation::invoke( observer, // ,       projectile_component-&gt;input_time_ms, // ,      compensated_entities, // ,    compensated_action // ,       );</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya juga ingin mencatat bahwa kompensasi lag adalah skema yang menempatkan pengalaman penembak di atas pengalaman target yang dia tembak. </font><font style="vertical-align: inherit;">Dari sudut pandang target, musuh dapat masuk ke dirinya pada saat dia sudah berada di belakang hambatan (sering keluhan di forum game). </font><font style="vertical-align: inherit;">Untuk melakukan ini, kompensasi lag memiliki jumlah bingkai terbatas yang tujuannya dapat ‚Äúdipompa keluar‚Äù. </font><font style="vertical-align: inherit;">Saat ini, di Battle Prime, penembak dengan RTT sekitar 400 milidetik dapat dengan nyaman mengenai musuh. </font><font style="vertical-align: inherit;">Jika RTT lebih tinggi, Anda harus terus maju. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh menembak tanpa kompensasi - Anda harus menembak ke depan untuk terus mengenai musuh:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f49/510/94b/f4951094b844f899b7bafc0fd2783534.gif" alt="gambar" height="1024" width="768"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dan dengan kompensasi - Anda dapat dengan nyaman mengarahkan langsung ke musuh: </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffe/2fe/126/ffe2fe12616364feb0251847e02b3807.gif" alt="gambar" height="1024" width="768"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agen pembuat kami juga secara berkala menjalankan tes otomatis yang memeriksa pekerjaan berbagai mekanik. Di antara mereka, ada juga autotest untuk akurasi menembak dengan kompensasi lag diaktifkan. Dalam gif di bawah tes ini ditampilkan - karakter hanya menembak kepala musuh yang berlari melewati dan menghitung jumlah hit pada dirinya. Untuk debugging, hitbox musuh yang ada di server pada saat tembakan (putih) dan hitbox yang digunakan untuk deteksi hit di dalam dunia yang dikompensasi (berwarna biru) juga ditampilkan:</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f99/8cf/e30/f998cfe305878180085bb44352b36a85.gif" alt="gambar" height="1024" width="768"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Faktor tambahan yang memengaruhi keakuratan pemotretan adalah posisi kotak hit pada karakter. Hitbox bergantung pada animasi skeletal, dan fase mereka saat ini tidak disinkronkan dengan cara apa pun, sehingga situasi mungkin di mana hitbox berbeda antara klien dan server. Konsekuensi dari ini tergantung pada animasi itu sendiri - semakin besar rentang gerakan di dalam animasi, semakin besar perbedaan potensial dalam posisi hitbox antara server dan klien. Dalam prakteknya, perbedaan seperti itu kurang terlihat bagi pemain dan lebih banyak mempengaruhi tubuh bagian bawah, yang kurang kritis dibandingkan dengan bagian atas (kepala, bagasi, lengan). Namun demikian, di masa depan saya ingin membahas secara lebih rinci masalah sinkronisasi animasi antara server dan klien.</font></font><br><br><h1>  Kesimpulan </h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam artikel ini saya mencoba untuk menggambarkan dasar di mana Battle Prime dibangun - ini adalah penerapan pola ECS di dalam Blitz Engine, serta modul jaringan yang bertanggung jawab untuk replikasi, prediksi klien, dan mekanika terkait. </font><font style="vertical-align: inherit;">Meskipun ada beberapa kekurangan (yang kami terus perbaiki), menggunakan fungsi ini sekarang sederhana dan nyaman. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk menunjukkan gambaran keseluruhan dari Battle Prime, saya harus menyentuh sejumlah besar topik. </font><font style="vertical-align: inherit;">Banyak dari mereka dapat dikhususkan untuk artikel yang terpisah di masa depan, di mana mereka akan dijelaskan secara lebih rinci! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Game ini sudah diuji coba di Turki dan Filipina. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Artikel kami sebelumnya dapat ditemukan di tautan berikut:</font></font><br><br><ol><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habr.com/en/post/461623</font></font></a> </li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">habr.com/en/post/465343</font></font></a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id469709/">https://habr.com/ru/post/id469709/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id469691/index.html">Tempat mendengarkan tentang Apache Ignite dan GridGain pada bulan Oktober</a></li>
<li><a href="../id469693/index.html">Bagaimana memberi makan jutaan orang Cina dalam waktu setengah jam</a></li>
<li><a href="../id469697/index.html">Kelahiran teknologi baru dalam proses bisnis yang diproduksi secara tradisional</a></li>
<li><a href="../id469703/index.html">Avalonia Biasa</a></li>
<li><a href="../id469707/index.html">Mengkonfigurasi VSCode agar berfungsi dengan Scala</a></li>
<li><a href="../id469717/index.html">Biarkan cahaya bersinar</a></li>
<li><a href="../id469721/index.html">Dell OptiPlex 7070 Ultra: komputer modular yang mengubah setiap monitor menjadi monoblok</a></li>
<li><a href="../id469723/index.html">Menciptakan keterampilan stateful untuk Alice pada fungsi serverless Yandex.Cloud dan Python</a></li>
<li><a href="../id469725/index.html">Panduan Tata Surya untuk Hitchhikers</a></li>
<li><a href="../id469731/index.html">Menangani Pengecualian ASP.NET Menggunakan IRO.Mvc.MvcExceptionHandler</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>