<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💇🏿 👨‍👦 💖 没有zone.js的Angular：最高性能 💪🏽 👉🏾 👩🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Angular开发人员应归功于zone.js。 例如，她在与Angular合作时帮助实现了几乎神奇的轻松。 实际上，几乎总是，当您只需要更改某些属性，而我们在不考虑任何事情的情况下更改它时，Angular会重新渲染相应的组件。 结果，用户看到的总是包含最新信息。 太好了 

 在这里，我想探讨使用新...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>没有zone.js的Angular：最高性能</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/476956/">  Angular开发人员应归功于zone.js。 例如，她在与Angular合作时帮助实现了几乎神奇的轻松。 实际上，几乎总是，当您只需要更改某些属性，而我们在不考虑任何事情的情况下更改它时，Angular会重新渲染相应的组件。 结果，用户看到的总是包含最新信息。 太好了 <br><br> 在这里，我想探讨使用新Ivy编译器（出现在Angular 9中）如何极大地促进拒绝使用zone.js的某些方面。 <br><br> <a href="https://habr.com/ru/company/ruvds/blog/476956/"><img src="https://habrastorage.org/webt/9m/ql/xa/9mqlxapag9joinziuleg8frnslm.jpeg"></a> <br><br> 通过放弃该库，我能够显着提高在高负载下运行的Angular应用程序的性能。 同时，我设法使用TypeScript装饰器实现了所需的机制，这几乎不需要额外的系统资源。 <br><br> 请注意，本文介绍的优化Angular应用程序的方法仅因为默认情况下启用了Angular Ivy和AOT是可行的。 本文是出于教育目的而写的，其目的不是为了促进其中介绍的方法用于Angular项目的开发。 <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">为什么可能需要在没有zone.js的情况下使用Angular？</font> </h2><br> 在继续之前，让我们问一个重要的问题：“鉴于这个库可以帮助我们轻松地重新渲染模板，所以值得摆脱zone.js吗？” 当然，这个库非常有用。 但是，像往常一样，您必须支付所有费用。 <br><br> 如果您的应用程序有特定的性能要求，则禁用zone.js可以帮助满足这些要求。 一个性能至关重要的应用程序示例是一个界面经常更新的项目。 以我为例，这样的项目原来是实时交易应用程序。 它的客户端不断通过WebSocket协议接收消息。 这些消息中的数据应尽快显示。 <br><br><h2>  <font color="#3AC1EF">从Angular中删除zone.js</font> </h2><br> 没有zone.js，可以很容易地使Angular正常工作。 为此，必须首先注释掉或删除相应的导入命令，该命令位于<code>polyfills.ts</code>文件中。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7a4/f95/17e/7a4f9517eb4898e51240862c08e4faa9.png"></div><br>  <i><font color="#999999">注释掉zone.js导入命令</font></i> <br><br> 下一步-您需要为根模块配备以下选项： <br><br><pre> <code class="javascript hljs">platformBrowserDynamic()  .bootstrapModule(AppModule, {    <span class="hljs-attr"><span class="hljs-attr">ngZone</span></span>: <span class="hljs-string"><span class="hljs-string">'noop'</span></span>  })  .catch(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">err</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.error(err));</code> </pre> <br><h2>  <font color="#3AC1EF">Angular Ivy：通过ɵdetectChanges和ɵmarkDirty进行自我检测的更改</font> </h2><br> 在开始创建TypeScript装饰器之前，我们需要了解Ivy如何允许您调用检测组件更改，使其变脏并绕过zone.js和DI的过程。 <br><br> 现在，我们可以从<code>@angular/core</code>导出两个附加功能。 这些是<code>ɵdetectChanges</code>和<code>ɵmarkDirty</code> 。 这两个功能仍仅供内部使用，并且不稳定-符号<code>ɵ</code>位于其名称的开头。 <br><br> 让我们看看如何使用这些功能。 <br><br><h3>  <font color="#3AC1EF">ɵmarkDirty函数</font> </h3><br> 此功能使您可以标记零部件，使其“肮脏”，即需要重新渲染。 她，如果在调用该组件之前未将其标记为“脏”，则计划启动更改检测过程。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ɵmarkDirty <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> markDirty } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; @Component({...}) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span></span>{  setTitle(title: string) {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.title = title;    markDirty(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);  } }</code> </pre> <br><h3>  <font color="#3AC1EF">ɵdetectChanges功能</font> </h3><br>  Angular内部文档说，出于性能原因，您不应使用<code>ɵdetectChanges</code> 。 相反，建议使用<code>ɵmarkDirty</code>函数。  <code>ɵdetectChanges</code>函数同步调用检测组件及其子组件中的更改的过程。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { ɵdetectChanges <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> detectChanges } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'@angular/core'</span></span>; @Component({...}) <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-class"> </span></span>{  setTitle(title: string) {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.title = title;    detectChanges(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);  } }</code> </pre> <br><h2>  <font color="#3AC1EF">使用TypeScript装饰器自动检测更改</font> </h2><br> 尽管Angular提供的功能可以通过允许DI来增加开发的可用性，但是程序员仍然感到沮丧，因为他需要自己导入并调用这些函数来启动变更检测过程。 <br><br> 为了简化更改检测的自动开始，您可以编写TypeScript装饰器，它将独立解决此问题。 当然，这里有一些限制，我们将在下面讨论，但是在我看来，这种方法正是我所需要的。 <br><br><h3>  <font color="#3AC1EF">ob介绍@observed装饰器</font> </h3><br> 为了检测到更改，以最小的努力，我们将创建可以以三种方式应用的装饰器。 即，它适用于以下实体： <br><br><ul><li> 要同步的方法。 </li><li> 可观察对象。 </li><li> 到普通物体。 </li></ul><br> 考虑几个小例子。 在以下代码片段中，我们将<code>@observed</code>装饰器应用于<code>state</code>对象和<code>changeTitle</code>方法： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{    title = <span class="hljs-string"><span class="hljs-string">''</span></span>;    @observed() state = {        <span class="hljs-attr"><span class="hljs-attr">name</span></span>: <span class="hljs-string"><span class="hljs-string">''</span></span>    };    @observed()    changeTitle(title: string) {        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.title = title;    }    changeName(name: string) {        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.state.name = name;    } }</code> </pre> <br><ul><li> 要检查<code>state</code>对象的更改，我们使用一个代理对象，该对象拦截对对象的更改并调用检测更改的过程。 </li><li> 我们通过应用一个函数来覆盖<code>changeTitle</code>方法，该函数首先调用此方法，然后启动更改检测过程。 </li></ul><br> 这是<code>BehaviorSubject</code>的示例： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span></span>{    @observed() show$ = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BehaviorSubject(<span class="hljs-literal"><span class="hljs-literal">true</span></span>);    toggle() {        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.show$.next(!<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.show$.value);    } }</code> </pre> <br> 对于Observable对象，使用装饰器看起来更加复杂。 即，您需要订阅观察到的对象，并在订阅中将组件标记为“脏”，但是还需要清除订阅。 为了做到这一点，我们重新分配了<code>ngOnInit</code>和<code>ngOnDestroy</code>以进行订阅并稍后<code>ngOnDestroy</code>进行清理。 <br><br><h3>  <font color="#3AC1EF">▍创建装饰</font> </h3><br> 这是<code>observed</code>装饰器签名： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">observed</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">    target: object,    propertyKey: string,    descriptor?: PropertyDescriptor  </span></span></span><span class="hljs-function">) </span></span>{} }</code> </pre> <br> 如您所见， <code>descriptor</code>是一个可选参数。 这是因为我们需要将装饰器应用于方法和属性。 如果参数存在，则意味着将装饰器应用于该方法。 在这种情况下，我们这样做： <br><br><ul><li> 保存<code>descriptor.</code>属性<code>descriptor.</code>  <code>value</code> 。 </li><li> 我们重新定义该方法，如下所示：调用原始函数，然后调用<code>markDirty(this)</code>以启动更改检测过程。 看起来是这样的： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (descriptor) {  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> original = descriptor.value; <span class="hljs-comment"><span class="hljs-comment">//     descriptor.value = function(...args: any[]) {    original.apply(this, args); //       markDirty(this);  }; } else {  //   }</span></span></code> </pre> </li></ul><br> 接下来，您需要检查我们正在处理的属性类型。 它可以是一个Observable对象，也可以是一个普通对象。 在这里，我们将使用另一个内部Angular API。 我相信，它不适用于常规应用程序（抱歉！）。 <br><br> 我们谈论的是<code>ɵcmp</code>属性，在<code>ɵcmp</code>属性后，它可以访问Angular处理的属性。 我们可以使用它们来覆盖<code>onInit</code>和<code>onDestroy</code> 。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> getCmp = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">type</span></span></span><span class="hljs-function"> =&gt;</span></span> (type).ɵcmp; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> cmp = getCmp(target.constructor); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onInit = cmp.onInit || noop; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> onDestroy = cmp.onDestroy || noop;</code> </pre> <br> 为了将一个属性标记为要监视的属性，我们使用<code>ReflectMetadata</code>并将其值设置为<code>true</code> 。 结果，我们将知道在初始化组件时需要观察该属性： <br><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.set(target, propertyKey, <span class="hljs-literal"><span class="hljs-literal">true</span></span>);</code> </pre> <br> 现在是时候重写<code>onInit</code>钩子并在创建组件实例时检查属性了： <br><br><pre> <code class="javascript hljs">cmp.onInit = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  checkComponentProperties(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);  onInit.call(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); };</code> </pre> <br> 我们定义了<code>checkComponentProperties</code>函数，该函数将绕过组件的属性，并根据之前使用<code>Reflect.set</code>设置的值对它们进行<code>Reflect.set</code> ： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkComponentProperties = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">ctx</span></span></span><span class="hljs-function">) =&gt;</span></span> {  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> props = <span class="hljs-built_in"><span class="hljs-built_in">Object</span></span>.getOwnPropertyNames(ctx);  props.map(<span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">prop</span></span></span><span class="hljs-function">) =&gt;</span></span> {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Reflect</span></span>.get(target, prop);  }).filter(<span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>).forEach(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {    checkProperty.call(ctx, propertyKey);  }); };</code> </pre> <br>  <code>checkProperty</code>函数将负责装饰单个属性。 首先，我们检查属性是Observable还是常规对象。 如果这是一个Observable对象，我们对其进行订阅，并将该订阅添加到组件中存储的订阅列表中，以满足其内部需求。 <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> checkProperty = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">name: string</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ctx = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx[name] <span class="hljs-keyword"><span class="hljs-keyword">instanceof</span></span> Observable) {    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> subscriptions = getSubscriptions(ctx);    subscriptions.add(ctx[name].subscribe(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {      markDirty(ctx);    }));  } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> {    <span class="hljs-comment"><span class="hljs-comment">//    } };</span></span></code> </pre> <br> 如果该属性是普通对象，则我们将其转换为Proxy对象，并在其<code>handler</code>函数中调用<code>markDirty</code> ： <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handler = {  set(obj, prop, value) {    obj[prop] = value;    ɵmarkDirty(ctx);    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>;  } }; ctx[name] = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-built_in"><span class="hljs-built_in">Proxy</span></span>(ctx, handler);</code> </pre> <br> 最后，您需要在销毁组件之后清除订阅： <br><br><pre> <code class="javascript hljs">cmp.onDestroy = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ctx = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>;  <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ctx[subscriptionsSymbol]) {    ctx[subscriptionsSymbol].unsubscribe();  }  onDestroy.call(ctx); };</code> </pre> <br> 不能将这种装饰器的可能性称为全面性。 它们并未涵盖大型应用程序中可能出现的所有可能用途。 例如，这些是对返回Observable对象的模板函数的调用。 但是我正在努力。 <br><br> 尽管如此，上面的装饰器足以满足我的小项目需求。 您可以在资料末尾找到其完整代码。 <br><br><h2>  <font color="#3AC1EF">应用加速结果分析</font> </h2><br> 既然我们已经讨论了Ivy的内部机制，以及如何使用这些机制创建装饰器，那么现在该测试一下我们在实际应用程序中的功能了。 <br><br> 为了找出摆脱zone.js对Angular应用程序性能的影响，我使用了我的<a href="https://github.com/gbuomprisco/cryptofolio">Cryptofolio</a>业余项目。 <br><br> 我将装饰器应用于模板和禁用的zone.js中使用的所有必要链接。 例如，考虑以下组件： <br><br><pre> <code class="javascript hljs">@Component({...}) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AssetPricerComponent</span></span></span><span class="hljs-class"> </span></span>{  @observed() price$: Observable&lt;string&gt;;  @observed() trend$: Observable&lt;Trend&gt;;   <span class="hljs-comment"><span class="hljs-comment">// ... }</span></span></code> </pre> <br> 模板中使用了两个变量： <code>price</code> （资产价格将位于此处）和<code>trend</code> （此变量可以采用<code>up</code> ， <code>stale</code>和<code>down</code>值，指示价格变化的方向）。 我用<code>@observed</code>装饰它们。 <br><br><h3>  <font color="#3AC1EF">▍项目包大小</font> </h3><br> 首先，让我们看一下在摆脱zone.js的同时，项目包的大小已减少了多少。 以下是使用zone.js构建项目的结果。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a0b/cb3/7e8/a0bcb37e870dfdcafa1c49a80aeaeb04.png"></div><br>  <i><font color="#999999">使用zone.js构建项目的结果</font></i> <br><br> 这是没有zone.js的程序集。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7d5/6ae/adc/7d56aeadce675e6953e5e603b3594c2c.png"></div><br>  <i><font color="#999999">没有zone.js的项目构建的结果</font></i> <br><br> 请注意<code>polyfills-es2015.xxx.js</code> 。 如果项目使用zone.js，则其大小约为35 Kb。 但是没有zone.js，只有130个字节。 <br><br><h3>  <font color="#3AC1EF">▍启动</font> </h3><br> 我使用Lighthouse研究了两个应用程序选项。 这项研究的结果如下。 应该指出的是，我不会太重视它们。 事实是，在尝试寻找平均值时，通过对同一应用程序版本执行多次测量，我得到了明显不同的结果。 <br><br> 评估两个应用程序选项的差异可能仅取决于捆绑包的大小。 <br><br> 因此，这是使用zone.js的应用程序获得的结果。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dfd/922/5f3/dfd9225f368de1f7c3e43d47bddbad16.png"></div><br>  <i><font color="#999999">使用zone.js的应用程序的分析结果</font></i> <br><br> 这是在分析未使用zone.js的应用程序之后发生的事情。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f41/684/9ba/f416849ba2f210d1ed48345e607a3d8f.png"></div><br>  <i><font color="#999999">不使用zone.js的应用程序的分析结果</font></i> <br><br><h3>  <font color="#3AC1EF">▍表现</font> </h3><br> 现在我们进入了最有趣的阶段。 这是在负载下运行的应用程序的性能。 我们想了解当应用程序每秒显示数百种资产的价格更新时处理器的感觉。 <br><br> 为了加载该应用程序，我创建了100个实体，这些实体以每250毫秒更改一次的价格提供条件数据。 如果价格上涨，则以绿色显示。 如果减少-红色。 所有这些可能会严重加载我的MacBook Pro。 <br><br> 应当指出，在金融部门从事旨在为数据片段的高频传输设计的几种应用程序时，我多次遇到类似的情况。 <br><br> 为了分析不同版本的应用程序如何使用处理器资源，我使用了Chrome开发人员工具。 <br><br> 这是使用zone.js的应用程序的外观 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fbf/11b/56f/fbf11b56ffe060d5bcdc4680a0ddd347.gif"></div><br>  <i><font color="#999999">由使用zone.js的应用程序创建的系统负载</font></i> <br><br> 这是不使用zone.js的应用程序的工作方式。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fb/657/240/8fb65724082e810619f061cb238c76da.gif"></div><br>  <i><font color="#999999">由不使用zone.js的应用程序创建的系统负载</font></i> <br><br> 我们分析这些结果，并注意处理器负载图（黄色）： <br><br><ul><li> 如您所见，使用zone.js的应用程序会不断加载70-100％的处理器！ 如果您长时间保持浏览器选项卡处于打开状态，从而在系统上造成了这样的负载，则其中运行的应用程序很可能会失败。 </li><li> 不使用zone.js的应用程序版本会在处理器上产生30％到40％的稳定负载。 太好了！ </li></ul><br> 请注意，这些结果是在打开“ Chrome开发者工具”窗口的情况下获得的，这也给系统增加了压力并降低了应用程序的速度。 <br><br><h3>  <font color="#3AC1EF">▍负荷增加</font> </h3><br> 我试图确保每个负责更新价格的实体除已产生的价格外，每秒还会发布4次更新。 <br><br> 这是我们设法找出不使用zone.js的应用程序的内容： <br><br><ul><li> 该应用程序通常使用大约50％的处理器资源来应对负载。 </li><li> 仅当价格每10毫秒更新一次（与以前一样，新数据来自100个实体）时，他设法通过zone.js尽可能多地为处理器加载了应用程序。 </li></ul><br><h3>  <font color="#3AC1EF">with Angular Benchpress的性能分析</font> </h3><br> 我上面进行的性能分析不能称为特别科学。 为了更认真地研究各种框架的性能，我建议使用<a href="https://krausest.github.io/js-framework-benchmark/current.html">此基准</a> 。 为了进行研究，Angular应该选择该框架的常规版本以及不带zone.js的版本。 <br><br> 受此基准测试的一些想法启发，我创建了一个执行大量计算的<a href="https://github.com/Gbuomprisco/zoneless-angular">项目</a> 。 我用<a href="https://github.com/angular/angular/tree/master/packages/benchpress">Angular Benchpress</a>测试了它的性能。 <br><br> 这是经过测试的组件的代码： <br><br><pre> <code class="javascript hljs">@Component({...}) <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppComponent</span></span></span><span class="hljs-class"> </span></span>{  public data = [];  @observed()  run(length: number) {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.clear();    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buildData(length);  }  @observed()  append(length: number) {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.buildData(length);  }  @observed()  removeAll() {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.clear();  }  @observed()  remove(item) {    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, l = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data.length; i &lt; l; i++) {      <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data[i].id === item.id) {        <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data.splice(i, <span class="hljs-number"><span class="hljs-number">1</span></span>);        <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>;      }    }  }  trackById(item) {    <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> item.id;  }  private clear() {    <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data = [];  }  private buildData(length: number) {    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> start = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data.length;    <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> end = start + length;    <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> n = start; n &lt;= end; n++) {      <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.data.push({        <span class="hljs-attr"><span class="hljs-attr">id</span></span>: n,        <span class="hljs-attr"><span class="hljs-attr">label</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">Math</span></span>.random()      });    }  } }</code> </pre> <br> 我使用量角器和Benchpress启动了一小套基准测试。 进行了指定次数的操作。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/5c2/167/a7b/5c2167a7bae21093e5e7cdc9f2482361.gif"></div><br>  <i><font color="#999999">卧推动作</font></i> <br><br><h4> 结果 </h4><br> 这是使用Benchpress获得的结果的示例。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f5a/467/0f0/f5a4670f0af5b461a1f0fad2d7f982b3.png"></div><br>  <i><font color="#999999">基准测试结果</font></i> <br><br> 这是此表中显示的指标的说明： <br><br><ul><li>  <code>gcAmount</code> ：gc操作量（垃圾收集），Kb。 </li><li>  <code>gcTime</code> ：gc操作时间，毫秒。 </li><li>  <code>majorGcTime</code> ：主要操作时间gc，毫秒。 </li><li>  <code>pureScriptTime</code> ：脚本执行时间（以毫秒为单位），不包括gc操作和渲染。 </li><li>  <code>renderTime</code> ：渲染时间，毫秒。 </li><li>  <code>scriptTime</code> ：考虑gc操作和渲染的脚本执行时间。 </li></ul><br> 现在，我们将分析各种应用程序变体中某些操作的性能。 绿色显示使用zone.js的应用程序的结果，橙色显示不使用zone.js的应用程序的结果。 请注意，此处仅分析渲染时间。 如果您对所有测试结果都感兴趣，请<a href="https://github.com/Gbuomprisco/zoneless-angular">点击此处</a> 。 <br><br><h4> 测试：创建1000行 </h4><br> 在第一个测试中，创建了1000行。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/944/d48/745/944d48745c79b697bececc092c78c9be.png"></div><br>  <i><font color="#999999">测试结果</font></i> <br><br><h4> 测试：创建10,000行 </h4><br> 随着应用程序负载的增长，其性能差异也随之增加。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e1/971/8aa/7e19718aadeec04390f1f4b7fa408f89.png"></div><br>  <i><font color="#999999">测试结果</font></i> <br><br><h4> 测试：加入1000行 </h4><br> 在此测试中，将1000行附加到10,000行。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/3f3/682/d30/3f3682d3064b9158ef95146426d2638b.png"></div><br>  <i><font color="#999999">测试结果</font></i> <br><br><h4> 测试：删除10,000行 </h4><br> 在这里，创建了10,000行，然后将其删除。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f85/d5d/bb7/f85d5dbb78b094bd9bb9afccbce148e3.png"></div><br>  <i><font color="#999999">测试结果</font></i> <br><br><h2>  <font color="#3AC1EF">TypeScript装饰器源代码</font> </h2><br> 以下是此处讨论的TypeScript装饰器的源代码。 此代码也可以在<a href="">这里</a>找到。 <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">// tslint:disable import { Observable, Subscription } from 'rxjs'; import { Type, ɵComponentType as ComponentType, ɵmarkDirty as markDirty } from '@angular/core'; interface ComponentDefinition {  onInit(): void;  onDestroy(): void; } const noop = () =&gt; { }; const getCmp = &lt;T&gt;(type: Function) =&gt; (type as any).ɵcmp as ComponentDefinition; const subscriptionsSymbol = Symbol('__ng__subscriptions'); export function observed() {  return function(    target: object,    propertyKey: string,    descriptor?: PropertyDescriptor  ) {    if (descriptor) {      const original = descriptor.value;      descriptor.value = function(...args: any[]) {        original.apply(this, args);        markDirty(this);      };    } else {      const cmp = getCmp(target.constructor);      if (!cmp) {        throw new Error(`Property ɵcmp is undefined`);      }      const onInit = cmp.onInit || noop;      const onDestroy = cmp.onDestroy || noop;      const getSubscriptions = (ctx) =&gt; {        if (ctx[subscriptionsSymbol]) {          return ctx[subscriptionsSymbol];        }        ctx[subscriptionsSymbol] = new Subscription();        return ctx[subscriptionsSymbol];      };      const checkProperty = function(name: string) {        const ctx = this;        if (ctx[name] instanceof Observable) {          const subscriptions = getSubscriptions(ctx);          subscriptions.add(ctx[name].subscribe(() =&gt; markDirty(ctx)));        } else {          const handler = {            set(obj: object, prop: string, value: unknown) {              obj[prop] = value;              markDirty(ctx);              return true;            }          };          ctx[name] = new Proxy(ctx, handler);        }      };      const checkComponentProperties = (ctx) =&gt; {        const props = Object.getOwnPropertyNames(ctx);        props.map((prop) =&gt; {          return Reflect.get(target, prop);        }).filter(Boolean).forEach(() =&gt; {          checkProperty.call(ctx, propertyKey);        });      };      cmp.onInit = function() {        const ctx = this;        onInit.call(ctx);        checkComponentProperties(ctx);      };      cmp.onDestroy = function() {        const ctx = this;        onDestroy.call(ctx);        if (ctx[subscriptionsSymbol]) {          ctx[subscriptionsSymbol].unsubscribe();        }      };      Reflect.set(target, propertyKey, true);    }  }; }</span></span></code> </pre> <br><h2>  <font color="#3AC1EF">总结</font> </h2><br> 尽管我希望您喜欢我关于优化Angular项目性能的故事，但我也希望我不会希望您急于从项目中删除zone.js。 为了提高Angular应用程序的性能，此处描述的策略应该是您可以采取的最后手段。 <br><br> 首先，您需要尝试以下方法，例如使用OnPush更改检测策略，应用<code>trackBy</code> ，禁用组件，在zone.js外部执行代码，将zone.js事件列入黑名单（此优化方法列表可以继续）。 此处显示的方法非常昂贵，我不确定每个人是否愿意为性能付出如此高的代价。 <br><br> 实际上，没有zone.js的开发可能不是最吸引人的东西。 也许这不仅适用于参与项目的人员，而且完全由他控制。 也就是说-它是依赖项的所有者，并且有能力和时间将所有内容恢复为正确的形式。 <br><br> 如果事实证明您尝试了所有事情并认为项目的瓶颈恰恰是zone.js，那么也许您应该尝试通过独立检测更改来加快Angular的速度。 <br><br> 我希望本文能使您了解Angular未来的期望，Ivy的能力以及zone.js可以做什么以最大程度地提高应用程序速度。 <br><br>  <b>亲爱的读者们！</b> 如何优化需要最大性能的Angular项目？ <br><br><div style="text-align:center;"> <a href="https://ruvds.com/vps_start/"><img src="https://habrastorage.org/webt/-o/2e/tu/-o2etuqogwhmdnmysb9_vivc9v4.png"></a> </div><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN476956/">https://habr.com/ru/post/zh-CN476956/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN476938/index.html">英特尔无与伦比的奢华体验：酷睿i9-9990XE，带有14个内核，频率为5.0 GHz（2部分）</a></li>
<li><a href="../zh-CN476940/index.html">C ++事件上的信号量</a></li>
<li><a href="../zh-CN476944/index.html">公司的大脑。 开始</a></li>
<li><a href="../zh-CN476948/index.html">量子轨迹及其与之一起吃的东西</a></li>
<li><a href="../zh-CN476954/index.html">工作不是狼，第3部分。初学者-生长还是生存？</a></li>
<li><a href="../zh-CN476958/index.html">欧米茄Red + PS1 Emulator = Kojima Genius</a></li>
<li><a href="../zh-CN476970/index.html">EkbDotNet第1次会议-叶卡捷琳堡加入DotNet.Ru社区</a></li>
<li><a href="../zh-CN476972/index.html">Deno：Node.JS时间用完了吗？</a></li>
<li><a href="../zh-CN476974/index.html">在5分钟内学习自适应Web设计</a></li>
<li><a href="../zh-CN476976/index.html">会议上公开演讲的6个错误</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>