<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤘🏻 🥪 🧠 RxJava到协程：端到端功能迁移 😎 🙎🏼 🐭</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="（最初在Medium上发布） 

 Kotlin协程不仅仅只是轻量级线程-它们是一种新的范例，可以帮助开发人员以结构化和惯用的方式处理并发。 

 开发Android应用程序时，应考虑许多不同的事情：从UI线程中删除长时间运行的操作，处理生命周期事件，取消订阅，切换回UI线程以更新用户界面。 在过去...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>RxJava到协程：端到端功能迁移</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483832/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/jb/id/pq/jbidpqpivwqpagw9azop_fswram.png" alt="图片"></div><br>  （最初在<a href="https://link.medium.com/OJ7ed2RCd3" rel="nofollow">Medium上</a>发布） <br><br>  Kotlin协程不仅仅只是轻量级线程-它们是一种新的范例，可以帮助开发人员以<a href="https://medium.com/%40elizarov/structured-concurrency-722d765aa952" rel="nofollow">结构化</a>和惯用的方式处理并发。 <br><br> 开发Android应用程序时，应考虑许多不同的事情：从UI线程中删除长时间运行的操作，处理生命周期事件，取消订阅，切换回UI线程以更新用户界面。 在过去的两年中，RxJava成为解决这一系列问题的最常用框架之一。 在本文中，我将指导您完成从RxJava到协程的端到端功能迁移。 <br><a name="habracut"></a><br><h4> 特色 </h4><br> 我们要转换为协程的功能非常简单：当用户提交国家/地区时，我们会进行API调用，以检查该国家/地区是否可以通过<a href="https://www.gov.uk/government/organisations/companies-house" rel="nofollow">Companies House</a>等提供程序进行业务详细信息查询。 如果呼叫成功，我们将显示响应，否则显示错误消息。 <br><br><h4> 迁徙 </h4><br><img src="https://habrastorage.org/webt/j0/0h/kg/j00hkgwjgnuwnzz4lsgdf5ry_fa.png" align="left"><br> 我们将以自下而上的方法迁移代码，从Retrofit服务开始，再移至存储库层，然后移至Interactor层，最后移至ViewModel。 <br><br> 当前返回Single的函数应成为挂起函数，而返回Observable的函数应返回Flow。 在此特定示例中，我们将不对Flows做任何事情。 <br><br><h4> 翻新服务 </h4><br> 让我们直接进入代码，并将BusinessLookupService中的businessLookupEligibility方法重构为协程。 这就是现在的样子。 <br><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BusinessLookupService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@GET(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"v1/eligibility"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">businessLookupEligibility</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@Query(</span></span></span><span class="hljs-meta-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta"><span class="hljs-meta-string">"countryCode"</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">)</span></span></span></span><span class="hljs-function"><span class="hljs-params"> countryCode: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>: Single&lt;NetworkResponse&lt;BusinessLookupEligibilityResponse, ErrorResponse&gt;&gt; }</code> </pre> <br> 重构步骤： <br><br><ol><li> 从<a href="" rel="nofollow">2.6.0版</a>开始，Retrofit支持suspend修饰符。 让我们将businessLookupEligibility方法变成一个暂停函数。 </li><li> 从返回类型中删除Single包装器。 </li></ol><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BusinessLookupService</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-meta"><span class="hljs-meta">@GET(</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"v1/eligibility"</span></span></span><span class="hljs-meta">)</span></span> <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">businessLookupEligibility</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-meta"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">@Query(</span></span></span><span class="hljs-meta-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta"><span class="hljs-meta-string">"countryCode"</span></span></span></span></span><span class="hljs-function"><span class="hljs-params"><span class="hljs-meta">)</span></span></span></span><span class="hljs-function"><span class="hljs-params"> countryCode: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>: NetworkResponse&lt;BusinessLookupEligibilityResponse, ErrorResponse&gt; }</code> </pre><br>  NetworkResponse是一个密封的类，表示BusinessLookupEligibilityResponse或ErrorResponse。  NetworkResponse是在自定义Retrofit呼叫适配器中构造的。 这样，我们将数据流限制为仅两种可能的情况-成功或错误，因此BusinessLookupService的使用者无需担心异常处理。 <br><br><h4> 资料库 </h4><br> 让我们继续前进，看看我们在BusinessLookupRepository中拥有什么。 在businessLookupEligibility方法主体中，我们称为businessLookupService.businessLookupEligibility（我们刚刚重构的对象），并使用RxJava的map运算符将NetworkResponse转换为Result并将响应模型映射到域模型。  Result是另一个密封的类，它表示Result.Success，并且如果网络调用成功，则包含BusinessLookupEligibility对象。 如果网络调用中出现错误，反序列化异常或其他错误，我们将使用有意义的错误消息（ErrorMessage是String的类型<a href="https://kotlinlang.org/docs/reference/type-aliases.html" rel="nofollow">别名</a> ）构造Result.Failure。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BusinessLookupRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> businessLookupService: BusinessLookupService, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> businessLookupApiToDomainMapper: BusinessLookupApiToDomainMapper, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> responseToString: Mapper, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> schedulerProvider: SchedulerProvider ) { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">businessLookupEligibility</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(countryCode: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Single&lt;Result&lt;BusinessLookupEligibility, ErrorMessage&gt;&gt; { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> businessLookupService.businessLookupEligibility(countryCode) .map { response -&gt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span><span class="hljs-symbol"><span class="hljs-symbol">@map</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (response) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> NetworkResponse.Success -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> businessLookupEligibility = businessLookupApiToDomainMapper.map(response.body) Result.Success&lt;BusinessLookupEligibility, ErrorMessage&gt;(businessLookupEligibility) } <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> NetworkResponse.Error -&gt; Result.Failure&lt;BusinessLookupEligibility, ErrorMessage&gt;( responseToString.transform(response) ) } }.subscribeOn(schedulerProvider.io()) } }</code> </pre><br> 重构步骤： <br><br><ol><li>  businessLookupEligibility变为挂起函数。 </li><li> 从返回类型中删除Single包装器。 </li><li> 存储库中的方法通常执行长时间运行的任务，例如网络调用或数据库查询。 存储库负责指定应在哪个线程上执行此工作。 通过subscriptionOn（schedulerProvider.io（）），我们告诉RxJava应该在io线程上完成工作。 协程如何实现相同目的？ 我们将withwithContext与特定的调度程序一起使用，以将块的执行转移到不同的线程上，并在执行完成后转移回原始的调度程序。 最好使用withContext确保函数是主安全的。  BusinessLookupRepository的使用者不应考虑应该使用哪个线程来执行businessLookupEligibility方法，应安全地从主线程调用它。 </li><li> 我们不再需要地图运算符，因为我们可以在暂停函数的主体中使用businessLookupService.businessLookupEligibility的结果。 </li></ol><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BusinessLookupRepository</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> businessLookupService: BusinessLookupService, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> businessLookupApiToDomainMapper: BusinessLookupApiToDomainMapper, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> responseToString: Mapper, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> dispatcherProvider: DispatcherProvider ) { <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">businessLookupEligibility</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(countryCode: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Result&lt;BusinessLookupEligibility, ErrorMessage&gt; = withContext(dispatcherProvider.io) { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> response = businessLookupService.businessLookupEligibility(countryCode)) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> NetworkResponse.Success -&gt; { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> businessLookupEligibility = businessLookupApiToDomainMapper.map(response.body) Result.Success&lt;BusinessLookupEligibility, ErrorMessage&gt;(businessLookupEligibility) } <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> NetworkResponse.Error -&gt; Result.Failure&lt;BusinessLookupEligibility, ErrorMessage&gt;( responseToString.transform(response) ) } } }</code> </pre><br><h4> 牵连器 </h4><br> 在此特定示例中，BusinessLookupEligibilityInteractor不包含任何其他逻辑，并用作BusinessLookupRepository的代理。 我们使用调用<a href="https://kotlinlang.org/docs/reference/operator-overloading.html" rel="nofollow">运算符重载，</a>以便可以将交互器作为一个函数来调用。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BusinessLookupEligibilityInteractor</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> businessLookupRepository: BusinessLookupRepository ) { <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(countryCode: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Single&lt;Result&lt;BusinessLookupEligibility, ErrorMessage&gt;&gt; = businessLookupRepository.businessLookupEligibility(countryCode) }</code> </pre><br> 重构步骤： <br><br><ol><li> 操作员有趣的调用变为暂停操作员有趣的调用。 </li><li> 从返回类型中删除Single包装器。 </li></ol><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BusinessLookupEligibilityInteractor</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> businessLookupRepository: BusinessLookupRepository ) { <span class="hljs-keyword"><span class="hljs-keyword">suspend</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">invoke</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(countryCode: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>: Result&lt;BusinessLookupEligibility, ErrorMessage&gt; = businessLookupRepository.businessLookupEligibility(countryCode) }</code> </pre><br><h4> 视图模型 </h4><br> 在BusinessProfileViewModel中，我们调用返回Single的BusinessLookupEligibilityInteractor。 我们订阅流并通过指定UI调度程序在UI线程上对其进行观察。 如果成功，我们会将域模型中的值分配给businessViewState LiveData。 如果出现故障，我们将分配一条错误消息。 <br><br> 我们将每个订阅添加到CompositeDisposable中，并将其处置在ViewModel生命周期的onCleared（）方法中。 <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BusinessProfileViewModel</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> businessLookupEligibilityInteractor: BusinessLookupEligibilityInteractor, <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> schedulerProvider: SchedulerProvider ) : ViewModel() { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> disposables = CompositeDisposable() <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> businessViewState: MutableLiveData&lt;ViewState&gt; = LiveDataFactory.createDefault(<span class="hljs-string"><span class="hljs-string">"Loading..."</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCountrySubmit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(country: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Country</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { disposables.add(businessLookupEligibilityInteractor(country.countryCode) .observeOn(schedulerProvider.ui()) .subscribe { state -&gt; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span><span class="hljs-symbol"><span class="hljs-symbol">@subscribe</span></span> <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (state) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Result.Success -&gt; businessViewState.value = state.entity.provider <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Result.Failure -&gt; businessViewState.value = state.failure } }) } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> void onCleared() { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCleared(); disposables.clear(); } }</code> </pre><br> 重构步骤： <br><br><ol><li> 在本文的开头，我提到了协程的主要优点之一-结构化并发。 这就是它发挥作用的地方。 每个协程都有一个范围。 示波器通过其工作可以控制协程。 如果取消作业，则相应范围内的所有协程也将被取消。 您可以自由创建自己的范围，但是在这种情况下，我们将利用ViewModel生命周期感知的viewModelScope。 我们将使用viewModelScope.launch在viewModelScope中启动一个新的协程。 协程将在主线程中启动，因为viewModelScope具有默认的分派器-Dispatchers.Main。 一个协程在Dispatchers上启动，Main在挂起时不会阻塞主线程。 当我们刚刚启动了协程时，我们可以调用businessLookupEligibilityInteractor挂起运算符并获取结果。  businessLookupEligibilityInteractor调用BusinessLookupRepository.businessLookupEligibility，这会将执行转移到Dispatchers.IO，然后又转移到Dispatchers.Main。 正如我们在UI线程中一样，我们可以通过分配一个值来更新businessViewState LiveData。 </li><li> 由于viewModelScope绑定到ViewModel生命周期，因此我们可以摆脱一次性用品。 如果清除ViewModel，则在此范围内启动的所有协程都会自动取消。 </li></ol><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BusinessProfileViewModel</span></span></span><span class="hljs-class"> </span><span class="hljs-meta"><span class="hljs-class"><span class="hljs-meta">@Inject</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">constructor</span></span></span></span>( <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> businessLookupEligibilityInteractor: BusinessLookupEligibilityInteractor ) : ViewModel() { <span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> businessViewState: MutableLiveData&lt;ViewState&gt; = LiveDataFactory.createDefault(<span class="hljs-string"><span class="hljs-string">"Loading..."</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCountrySubmit</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(country: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Country</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { viewModelScope.launch { <span class="hljs-keyword"><span class="hljs-keyword">when</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> state = businessLookupEligibilityInteractor(country.countryCode)) { <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Result.Success -&gt; businessViewState.value = state.entity.provider <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Result.Failure -&gt; businessViewState.value = state.failure } } } }</code> </pre><br><h4> 重要要点 </h4><br> 读取和理解用协程编写的代码非常容易，但是这是一种范式转换，需要一些努力来学习如何使用协程编写代码。 <br><br> 在本文中，我没有介绍测试。 我在使用Mockito测试协程时遇到问题，因此使用了<a href="https://mockk.io/" rel="nofollow">ockk</a>库。 <br><br> 我发现用Rx Java编写的所有内容都非常容易使用协程， <a href="https://kotlinlang.org/docs/reference/coroutines/flow.html" rel="nofollow">流</a>和<a href="https://kotlinlang.org/docs/reference/coroutines/channels.html" rel="nofollow">通道</a>来实现。 协程的优点之一是它们是Kotlin语言的功能，并且与语言一起发展。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN483832/">https://habr.com/ru/post/zh-CN483832/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN483822/index.html">5个JavaScript功能，如果没有这些功能，我将无法编写代码</a></li>
<li><a href="../zh-CN483824/index.html">在研究了我的五个规则后，如何实现梦想，积极思考并继续前进？</a></li>
<li><a href="../zh-CN483826/index.html">使用Vo模拟输出连接MH-Z19B型CO2传感器</a></li>
<li><a href="../zh-CN483828/index.html">闪耀与贫困原子交换</a></li>
<li><a href="../zh-CN483830/index.html">iOS路由：通用导航，无需重写应用程序</a></li>
<li><a href="../zh-CN483834/index.html">Debian：只需将i386转换为amd64</a></li>
<li><a href="../zh-CN483842/index.html">创建家庭云的历史。 第5部分。更新2019-PHP 7.2，MariaDB 10.4和Nextcloud 17</a></li>
<li><a href="../zh-CN483844/index.html">分析俄罗斯信贷和金融部门信息保护的监管文件</a></li>
<li><a href="../zh-CN483846/index.html">Linux上的替代窗口管理</a></li>
<li><a href="../zh-CN483850/index.html">没有神烧锅</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>