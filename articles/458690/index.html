<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏺 🛐 🧔🏻 ¡Automatízalo! Cómo mejoramos las pruebas de integración ⏯️ 🕴🏿 ☠️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En los viejos tiempos, teníamos solo unos pocos servicios, y poner en un día una actualización de más de uno de ellos en producción fue un gran éxito ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¡Automatízalo! Cómo mejoramos las pruebas de integración</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yamoney/blog/458690/">  En los viejos tiempos, teníamos solo unos pocos servicios, y poner en un día una actualización de más de uno de ellos en producción fue un gran <s>éxito</s> .  Luego, el mundo se aceleró, el sistema se volvió más complejo y nos transformamos en una organización con arquitectura de microservicios.  Ahora tenemos alrededor de un centenar de servicios, y con el aumento en su número, la frecuencia de los lanzamientos también aumenta: hay más de 250 por semana. <br><br>  Y si se prueban nuevas características dentro de los equipos de productos, entonces la tarea del equipo de pruebas de integración es verificar que los cambios incluidos en la versión no rompan la funcionalidad del componente, el sistema y otras características. <br><br><img src="https://habrastorage.org/webt/uf/se/rm/ufsermb8tifgozgjgtfs3cdcbk8.jpeg"><br><br>  Trabajo como ingeniero de automatización de pruebas en Yandex.Money. <br>  En este artículo hablaré sobre la evolución de las pruebas de integración de los servicios web, así como sobre la adaptación del proceso para aumentar el número de componentes del sistema y aumentar la frecuencia de los lanzamientos. <br><a name="habracut"></a><br>  Acerca de los cambios en el ciclo de lanzamiento y el desarrollo del mecanismo de cálculo fueron descritos por ops y dev en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">uno de los artículos anteriores</a> .  Te contaré sobre el historial de cambios en los procesos de prueba durante esta transformación. <br><br>  Ahora tenemos unos 30 equipos de desarrollo.  El equipo generalmente incluye al gerente de producto, gerente de proyecto, desarrolladores y probadores de front-end y back-end.  Están unidos por el trabajo en tareas para un producto específico.  En general, el servicio es responsable del servicio, que a menudo realiza cambios en él. <br><br><h2>  Pruebas de aceptación de extremo a extremo </h2><br>  No hace mucho tiempo, con el lanzamiento de cada componente, solo se ejecutaban pruebas de unidades y componentes, y después de eso, solo algunos de los scripts de extremo a extremo más importantes se ejecutaban en un entorno de prueba completo antes de poner el servicio en producción.  Junto con el aumento en el número de componentes, el número de conexiones entre ellos comenzó a crecer exponencialmente.  A menudo, conexiones completamente no triviales.  Recuerdo cómo la falta de disponibilidad del servicio para emitir datos de marketing rompió el registro del usuario por completo (por supuesto, por un corto tiempo). <br><br>  Este enfoque para verificar los cambios comenzó a fallar cada vez más a menudo: requería cubrir todos los escenarios empresariales críticos con pruebas automáticas y ejecutarlos en un entorno de prueba completo con una versión de componente lista para su lanzamiento. <br><br>  Bien, han aparecido pruebas automáticas para escenarios críticos, pero ¿cómo ejecutarlas?  Había una tarea para integrar en el ciclo de lanzamiento, afectando mínimamente su fiabilidad con falsas caídas de prueba.  Por otro lado, quería llevar a cabo la etapa de prueba de integración lo más rápido posible.  Entonces había una infraestructura para llevar a cabo pruebas de aceptación. <br><br>  Intentamos aprovechar al máximo las herramientas ya utilizadas para llevar a cabo el componente en el ciclo de lanzamiento y las tareas de lanzamiento: Jira y Jenkins, respectivamente. <br><br><h3>  Ciclo de prueba de aceptación </h3><br>  Para realizar pruebas de aceptación, determinamos el siguiente ciclo: <br><ol><li>  monitoreo de tareas entrantes para pruebas de aceptación de una versión, <br></li><li>  ejecutar el trabajo de Jenkins para instalar la compilación de lanzamiento en un entorno de prueba, <br></li><li>  comprobar que el servicio ha aumentado <br></li><li>  lanzar el trabajo de Jenkins con pruebas de integración, <br></li><li>  análisis de los resultados de la carrera, <br></li><li>  prueba repetida (si es necesario), <br></li><li>  actualizar el estado de la tarea: completada o interrumpida, indicando el motivo en el comentario. <br></li></ol><br>  El ciclo completo se realizó manualmente cada vez.  Como resultado, ya en el décimo lanzamiento por día, quería jurar que realizaría las mismas tareas, en el mejor de los casos, por lo bajo, agarrándome la cabeza y exigiendo <s>cerveza de</s> valeriana. <br><br><h2>  Monitor Bot </h2><br>  Nos dimos cuenta de que el seguimiento y la notificación de nuevas tareas en Jira son procesos importantes que son rápidos y fáciles de automatizar.  Entonces había un bot que hace esto. <br><br>  Los datos para generar alertas vienen en forma de notificaciones push de Jira.  Después de iniciar el bot, dejamos de actualizar la página del tablero con las tareas de aceptación, y el ancho de la sonrisa del autómata aumentó ligeramente. <br><br><h2>  Pinger </h2><br>  Decidimos simplificar la verificación de que durante la implementación en el entorno de prueba no se produjeron errores de ensamblaje o instalación y que se levantó la versión deseada del componente, y no otra.  El componente proporciona su versión y estado a través de HTTP.  Y comprobar que el servicio devuelve la versión correcta sería simple y comprensible si no se escribieran diferentes componentes en diferentes idiomas, algunos en Node.js, otros en C #.  Además, nuestros servicios más populares en Java también dieron la versión en un formato diferente. <br><br>  Además, quería tener información y notificaciones en tiempo real no solo sobre los cambios de versión, sino también sobre los cambios en la disponibilidad de componentes en el sistema.  Para resolver este problema, apareció el servicio Pinger, que recopila información sobre el estado y la versión de los componentes sondeándolos cíclicamente. <br><br>  Utilizamos un modelo de envío de mensajes push: se implementa un agente en cada instancia del entorno de prueba, que recopila información sobre los componentes de este entorno y almacena los datos en un nodo central cada 10 segundos.  Accedemos a este nodo para conocer el estado actual: este enfoque nos permite admitir más de cien bancos de pruebas. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/666/dfe/88a/666dfe88ade7ac5107ec244103a2b0d7.png"><br><br><h2>  Taquilla </h2><br>  Ha llegado el momento de realizar tareas más complejas: actualización automática de componentes y ejecución de pruebas.  En ese momento, nuestro equipo ya tenía 3 bancos de pruebas en OpenStack para las pruebas de aceptación, y primero era necesario resolver el problema de administrar los recursos de los bancos de pruebas: sería desagradable si la actualización de la próxima versión "se ejecuta" cuando se ejecutan pruebas en el sistema.  También sucede que el banco de pruebas está depurado, y luego no debe usarlo para su aceptación. <br>  Quería poder ver el estado del empleo y, si es necesario, bloquear manualmente el soporte durante el análisis de las pruebas caídas o hasta la finalización de otro trabajo. <br><br>  Por todo esto, ha aparecido el servicio Locker.  Mantiene el estado del banco de pruebas durante mucho tiempo ("ocupado" / "libre"), le permite especificar un comentario sobre "ocupado", para que quede claro que ahora estamos depurando, volviendo a crear una copia del entorno de prueba o ejecutando pruebas para la próxima versión.  También comenzamos a bloquear stands en la noche; en ellos, los administradores realizan el trabajo en un horario, como copias de seguridad y sincronización de bases de datos. <br><br>  Cuando se bloquea, siempre se establece el tiempo después del cual expira la cerradura; ahora las personas no necesitan participar en el regreso de los stands al grupo disponible, y la máquina hace todo. <br><br><h2>  Deber </h2><br>  Para distribuir equitativamente la carga entre los miembros del equipo para analizar los resultados de las pruebas, elaboramos turnos diarios.  El asistente trabaja con las tareas de pruebas de aceptación de versiones, analiza las pruebas automáticas caídas e informa de errores.  Si el asistente comprende que no está haciendo frente al flujo de tareas, puede pedir ayuda al equipo.  En este momento, el resto del equipo está involucrado en tareas que no están relacionadas con los lanzamientos. <br><br>  Con el aumento en el número de lanzamientos, apareció la función del segundo asistente, que se conecta con el principal si hay bloqueos o hay lanzamientos críticos en la cola.  Para proporcionar información sobre el progreso de las versiones de prueba, creamos una página con el número de tareas en los estados "abierto" / "en ejecución" / "esperando una respuesta del deber", el estado de los bancos de prueba bloqueados y los componentes inaccesibles en los bancos: <br><img src="https://habrastorage.org/webt/mi/am/v0/miamv0ugxbwqruuip9quxjjk45g.png"><br><br>  El trabajo del oficial de servicio requiere concentración, por lo que tiene un moño: el día de servicio, puede elegir un lugar para almorzar para todo el equipo cerca de la oficina.  Los sobornos de servicio en el estilo se ven especialmente divertidos: "déjame ayudarte a resolver las tareas, y hoy iremos a <i>mi</i> lugar favorito" =) <br><br><h2>  Reportero </h2><br>  Una de las tareas que encontramos cuando presentamos el reloj fue la necesidad de transferir el conocimiento de un oficial a otro, por ejemplo, sobre las pruebas que caen en una nueva versión o los detalles de la actualización de un componente. <br><br>  Además, tenemos nuevas características de trabajo. <br><br><ol><li>  Hubo una categoría de pruebas que caen con una frecuencia mayor o menor debido a problemas con los bancos de prueba.  Las caídas pueden ocurrir debido al mayor tiempo de respuesta de uno de los servicios o la larga carga de recursos en el navegador.  No quiero apagar las pruebas; se han agotado los medios razonables para aumentar su fiabilidad. <br></li><li>  Tuvimos un segundo proyecto experimental con pruebas automáticas, y surgió la necesidad de analizar las ejecuciones de dos proyectos a la vez, mirando los informes de Allure. <br></li><li>  Una ejecución de prueba puede demorar hasta 20 minutos, y desea comenzar a analizar los resultados inmediatamente después del inicio de las primeras gotas.  Especialmente si la tarea es crítica y los miembros del equipo responsable de la liberación están parados detrás de usted <s>, sosteniendo el cuchillo en la garganta</s> con ojos lastimosos. <br></li></ol><br>  Así es como surgió el servicio Reporter.  En él, empujamos los resultados de la ejecución de la prueba en tiempo real durante el proceso de prueba.  El servicio tiene una base de datos de problemas o errores conocidos que están vinculados a una prueba específica.  Además, se publicó una publicación en el portal wiki de la compañía de un informe resumido sobre los resultados de la ejecución del reportero.  Esto es conveniente para los gerentes que no desean sumergirse en los detalles técnicos con los que abunda la interfaz Reporter o Allure. <br><br>  Si la prueba falla, puede buscar en el Reporter una lista de errores relacionados o corregir tareas.  Dicha información acorta el tiempo de análisis y facilita el intercambio de conocimientos sobre problemas entre los miembros de nuestro equipo.  Los registros de las tareas completadas se archivan, pero si es necesario, puede "espiarlos" en una lista separada.  Para no cargar servicios internos durante el horario comercial, entrevistamos a Jira por la noche y archivamos entradas para problemas con el estado final. <br><br>  Una ventaja adicional de la introducción de Reporter fue la aparición de una base de datos de ejecución, en la que puede analizar la frecuencia de caídas, clasificar las pruebas por su nivel de estabilidad o "utilidad" en términos de la cantidad de errores encontrados. <br><br><h2>  Autorun </h2><br>  A continuación, pasamos a automatizar el lanzamiento de las pruebas cuando el tema de las pruebas de aceptación del lanzamiento llega al rastreador de problemas.  Para este propósito, se escribió el servicio Autorun, que verifica si hay nuevas tareas de aceptación en Jira, y si es así, determina el nombre del componente y su versión en función del contenido de la tarea. <br><br>  Para la tarea, se realizan varios pasos: <br><br><ol><li>  tome la cerradura de uno de los bancos de prueba gratuitos en el servicio Locker, <br></li><li>  comience la instalación del componente necesario en Jenkins, espere a que el componente se genere con la versión requerida, <br></li><li>  ejecutar pruebas <br></li><li>  espere a que se complete la ejecución de la prueba, en el proceso de ejecución todos los resultados se envían a Reporter, <br></li><li>  le pedimos a Reporter la cantidad de pruebas fallidas, excluyendo las que cayeron debido a problemas conocidos, <br></li><li>  si 0 ha caído, transferimos la tarea para la prueba de aceptación a "Finalizar" y terminamos de trabajar con ella.  Todo está listo =) <br></li><li>  si hay pruebas "rojas", traducimos la tarea a "En espera" y vamos a Reporter para analizarlas. <br></li></ol><br>  El cambio entre etapas está organizado por el principio de una máquina de estados finitos.  Cada etapa en sí misma conoce las condiciones para la transición a la siguiente.  Los resultados de la etapa se almacenan en el contexto de la tarea, que es común para las etapas de una tarea. <br><br><img src="https://habrastorage.org/webt/dw/dp/iy/dwdpiy0irgtip9wdw0z_v5gnsue.png"><br><br>  Todo esto le permite transferir automáticamente versiones a lo largo de la tubería de implementación, de acuerdo con las cuales el 100 por ciento de las pruebas son verdes.  Pero, ¿qué pasa con la inestabilidad causada no por problemas en el componente, sino por las características "naturales" de las pruebas de IU o por el aumento de los retrasos de la red en el banco de pruebas? <br><br>  Para hacer esto, hemos implementado un mecanismo de reintento, que muchas personas usan, pero pocos lo reconocen.  Las retransmisiones se organizan como una ejecución secuencial de pruebas en la tubería de Jenkins. <br><br>  Después de la ejecución, solicitamos una lista de pruebas fallidas de Reporter de Jenkins, y reiniciamos solo las fallidas.  Además, reducimos el número de subprocesos al inicio.  Si el número de pruebas descartadas no ha disminuido en comparación con la ejecución anterior, finalizamos inmediatamente Job.  En nuestro caso, este enfoque para reiniciar nos permite aumentar el éxito de las pruebas de aceptación aproximadamente 2 veces. <br><br><h2>  Bloqueo rápido </h2><br>  El sistema de pruebas de aceptación resultante nos permitió realizar más del 60% de las emisiones sin intervención humana.  ¿Pero qué hacer con el resto?  Si es necesario, el asistente crea un informe de error en el componente bajo prueba o la tarea de arreglar las pruebas al equipo de desarrollo.  A veces: elabora un error de la configuración del banco de pruebas para el departamento de operaciones. <br><br>  Las tareas para corregir las pruebas a menudo bloquean el paso correcto de las pruebas automáticas, ya que las pruebas irrelevantes siempre serán "rojas".  Los evaluadores de los equipos de desarrollo son responsables de escribir nuevas pruebas y actualizar las existentes, haciendo cambios a través de solicitudes de extracción al proyecto con pruebas automáticas.  Estas ediciones están sujetas a una revisión obligatoria, que requiere un tiempo del revisor y del autor, y quiero bloquear temporalmente las pruebas irrelevantes hasta que la tarea se traduzca a su estado final. <br><br>  Primero, implementamos un mecanismo de apagado basado en anotaciones de métodos de prueba.  Posteriormente, resultó que debido a la presencia de una revisión obligatoria del código, el bloqueo del código no siempre es conveniente y puede llevar más tiempo del que quisiéramos. <br><br>  Por lo tanto, trasladamos la lista de tareas que bloquean las pruebas a un nuevo servicio con una página web: bloqueo rápido.  Por lo tanto, los miembros del equipo responsable del componente pueden bloquear rápidamente la prueba.  Antes de la ejecución, vamos a este servicio y obtenemos una lista de pruebas en cuarentena, que traducimos al estado omitido. <br><br><h2>  Resumen </h2><br>  Hemos pasado de la aceptación de lanzamientos en modo manual a un proceso casi completamente automático, que puede realizarse a través de pruebas de aceptación de más de 50 lanzamientos por día.  Esto ayuda a la compañía a reducir el tiempo que lleva publicar los cambios, y nuestro equipo puede encontrar recursos para experimentar y desarrollar herramientas de prueba. <br><br>  En el futuro, planeamos aumentar la confiabilidad del proceso, por ejemplo, mediante la distribución de solicitudes entre un par de instancias de cada servicio de la lista anterior.  Esto le permitirá actualizar las herramientas sin tiempo de inactividad e incluir nuevas funciones solo para parte de las pruebas de aceptación.  Además, prestamos atención a estabilizar las pruebas en sí.  En desarrollo, un generador de tickets para refactorizar pruebas con la tasa de éxito más baja. <br><br>  Mejorar la confiabilidad de las pruebas no solo aumentará la confianza en ellas, sino que también acelerará las pruebas de lanzamientos debido a la falta de reinicios de scripts caídos. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/458690/">https://habr.com/ru/post/458690/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../458676/index.html">Cómo aprovechar al máximo la educación en informática</a></li>
<li><a href="../458680/index.html">¿Por qué necesitamos UML? O cómo salvar tus nervios y tu tiempo</a></li>
<li><a href="../458684/index.html">ICANN elimina el umbral de precio para el dominio .org: por qué la comunidad de TI está en contra y qué sucederá después</a></li>
<li><a href="../458686/index.html">@Pythonetc Junio ​​2019</a></li>
<li><a href="../458688/index.html">Consejos y trucos de mi canal de Telegram @pythonetc, junio de 2019</a></li>
<li><a href="../458692/index.html">Mónada "Tal vez" a través de asíncrono / espera en C # (¡Sin tareas!)</a></li>
<li><a href="../458694/index.html">¿Python GIL está realmente muerto?</a></li>
<li><a href="../458696/index.html">Texturizado, o lo que necesitas saber para convertirte en un Artista de Surface. Parte 3. PBR y materiales</a></li>
<li><a href="../458698/index.html">El camino de la paz y el camino de la guerra en proyectos de TI</a></li>
<li><a href="../458702/index.html">Perros de trineo: lo que necesita saber sobre ellos y cómo fueron traídos</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>