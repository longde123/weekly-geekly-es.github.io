<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>❣️ 👨🏿‍🚀 👓 JavaScript-Bündelung und Leistung: Best Practices 🔭 🧑🏼‍🤝‍🧑🏻 🤓</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jetzt, zur Wende des Jahrzehnts, ist es an der Zeit, das, was in der jüngeren Vergangenheit als richtig galt, kritisch zu überschätzen und herauszufin...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>JavaScript-Bündelung und Leistung: Best Practices</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/483682/">  Jetzt, zur Wende des Jahrzehnts, ist es an der Zeit, das, was in der jüngeren Vergangenheit als richtig galt, kritisch zu überschätzen und herauszufinden, ob es in unseren Tagen an Relevanz verloren hat.  Aus den Best Practices von gestern werden manchmal die Antimuster von heute. <br><br> <a href="https://habr.com/ru/company/ruvds/blog/483682/"><img src="https://habrastorage.org/webt/tp/h1/jh/tph1jh5adpkk21ojvgqsadxjga4.jpeg"></a> <br><br>  Der Autor des Artikels, dessen Übersetzung wir heute veröffentlichen, wird drei Ansätze zur Bündelung von JavaScript-Projekten am Beispiel einer einfachen Hello World-Anwendung untersuchen, die mit React erstellt wurde.  Zu den Beispielen, die er anführt, gehört das Lesen der Grundlagen von Modul-Buildern, wie z. B. <a href="https://webpack.js.org/">Webpack</a> , das heute das beliebteste Tool zu sein scheint. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Ansatz Nr. 1: Absolut alles kommt ins Bündel (es sieht aus wie ein großer Fadenballen)</font> </h2><br>  Die Hauptidee: Verwenden Sie diesen Ansatz nicht. <br><br>  Bei diesem Ansatz wird der Modul-Builder einfach verwendet, um alles im Bundle zu packen - sowohl Abhängigkeiten als auch Anwendungscode.  Die Ausgabe ist so etwas wie ein großer Wollknäuel.  In meinem Beispiel sind dies die Angaben " <code>react</code> , " <code>react-dom</code> und der Code der Anwendung selbst.  Ein einzelnes Bundle mit dem gesamten Projektcode ist mit der Seite verbunden: <br><br><pre> <code class="javascript hljs">&lt;!-- index.html --&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"bundle.[hash].min.js"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="undefined"></span><span class="hljs-tag"><span class="xml"><span class="undefined"></span><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  Vor der Veröffentlichung von HTTP / 2 konnte dieses Muster in gewisser Weise als akzeptabel angesehen werden, da durch seine Verwendung die Anzahl der HTTP-Anforderungen verringert wird, die der Browser beim Laden von Seitenmaterialien ausführt.  Angesichts der Tatsache, dass die meisten Sites heutzutage HTTP / 2 verwenden, ist dieses Muster zu einem Antimuster geworden. <br><br>  Warum?  Tatsache ist, dass bei Verwendung von HTTP / 2 die Ausführung vieler Anforderungen nicht mehr die gleiche Systemlast wie zuvor erzeugt.  Infolgedessen bietet das Packen des Codes in ein einzelnes großes Bündel dem Projekt keine signifikanten Vorteile mehr. <br><br>  Mit diesem Ansatz ist die effiziente Organisation des Browser-Cachings kompliziert.  Wenn Sie beispielsweise in einer einfachen Anwendung nur eine Codezeile ändern, wird der Bundle-Hash geändert und der Cache ungültig, in dem der gesamte Projektcode gespeichert ist.  Infolgedessen müssen alle wiederkehrenden Besucher den gesamten Site-Code erneut herunterladen, obwohl dieser Code zu 99% nicht von dem Code abweicht, den sie beim vorherigen Besuch heruntergeladen haben.  Hier geht es um den irrationalen Einsatz von Netzwerkressourcen aufgrund der wiederholten Übertragung der gleichen Daten vom Server zum Client. <br><br>  HTTP / 2 wird heute von <a href="&amp;xid=17259,15700023,15700043,15700186,15700190,15700259,15700271&amp;usg=ALkJrhjW0kYhRL2R60K7nHyFQnywxAzg-A#feat=">mehr als 95% der Clients unterstützt</a> .  Im Jahr 2019 wurde dieses Protokoll von den <a href="httparchive.org/reports/state-of-the-web">meisten</a> Servern implementiert.  Weitere Informationen zur Verwendung von HTTP / 2 im Jahr 2019 finden Sie hier. <br><br><h2>  <font color="#3AC1EF">Ansatz Nr. 2: Separate Verpackung des Projektcodes und des Codes von Fremdbibliotheken (Codetrennung)</font> </h2><br>  Hauptidee: Bitte verwenden Sie diesen Ansatz. <br><br>  Lassen Sie uns berücksichtigen, worüber wir im vorherigen Abschnitt gesprochen haben, und die Situation beim Browser-Caching verbessern, indem Sie den Projektcode vom Abhängigkeitscode trennen.  Dies löst das Problem in dem oben beschriebenen Fall, wenn wir den Projektcode geringfügig ändern und anschließend das Update in der Produktion veröffentlichen.  Jetzt hat sich nur der Hash des <code>index</code> Bundles geändert, in dem der projekteigene Code gespeichert ist, und der Hash des <code>vendor</code> Bundles bleibt unverändert.  Besucher, die zur aktualisierten Site zurückkehren, laden nur die geänderte <code>index</code> mit dieser Methode herunter, wodurch einige Netzwerkressourcen gespart werden. <br><br>  Wenn wir über Webpack sprechen, benötigen Sie zur Implementierung dieser Strategie <a href="https://webpack.js.org/guides/code-splitting">zusätzliche Einstellungen</a> für die Codetrennung.  Mit ihrer Hilfe informieren wir den Bundler darüber, wo sich der Abhängigkeitscode befindet.  Ein einfacher und bequemer Weg, solchen Code zu erkennen, besteht darin, dass sich im Pfad zu den entsprechenden Dateien <code>node_modules</code> befinden, da der gesamte Abhängigkeitscode in diesem Ordner gespeichert ist. <br><br>  Folgendes ist der Verbindungscode des Skripts: <br><br><pre> <code class="javascript hljs">&lt;!-- index.html --&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"vendor.[hash].min.js"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="undefined"></span><span class="hljs-tag"><span class="xml"><span class="undefined"></span><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;script src=<span class="hljs-string"><span class="hljs-string">"index.[hash].min.js"</span></span>&gt;<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  Und hier ist die Wasserfall-Timeline zum Laden der Seite, wenn mit HTTP / 2 gearbeitet wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bf5/d02/f85/bf5d02f8583eb58f1094dfaa592822e1.png"></div><br>  <i><font color="#999999">Ladezeitplan für Wasserfall-Seiten</font></i> <br><br>  Dies ist ein Schritt in die richtige Richtung.  Wir können die Bündelung aber weiter optimieren.  Wenn Sie darüber nachdenken, können Sie verstehen, dass sich einige Projektabhängigkeiten seltener ändern als andere.  Vielleicht ändern sich <code>react</code> und <code>react-dom</code> wenigsten <code>react</code> und wenn eine Bibliothek aktualisiert wird, wird eine andere aktualisiert.  Als Ergebnis können wir schließen, dass diese beiden Bibliotheken zu einem logischen Fragment zusammengefasst werden können, das von anderen Abhängigkeiten getrennt werden kann, die sich häufiger ändern als <code>react</code> und <code>react-dom</code> .  Wenn wir diese Idee verwirklichen, erhalten wir Folgendes: <br><br><pre> <code class="javascript hljs">&lt;!-- index.html --&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"vendor.react.[hash].min.js"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="undefined"></span><span class="hljs-tag"><span class="xml"><span class="undefined"></span><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;script src=<span class="hljs-string"><span class="hljs-string">"vendor.others.[hash].min.js"</span></span>&gt;<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;script src=<span class="hljs-string"><span class="hljs-string">"index.[hash].min.js"</span></span>&gt;<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  Wenn wir diese Idee weiterentwickeln, müssen Website-Besucher möglicherweise nicht den gesamten Projektcode herunterladen, um nur eine Seite anzuzeigen.  Im Winter nehmen einige von uns zu - und so wächst die <code>index</code> , die den Anwendungscode enthält, mit der Zeit.  Irgendwann kann sich herausstellen, dass der Projektcode zu Recht einer weiteren Trennung unterzogen wird, indem einzelne Komponenten <a href="https://reacttraining.com/react-router/web/guides/code-splitting">dynamisch geladen</a> und sogar das <a href="https://webpack.js.org/guides/code-splitting/">Vorladen</a> einzelner Module organisiert wird. <br><br>  Für mich scheint diese Ebene der Codetrennung immer noch ziemlich entmutigend.  Es sieht immer noch nach experimenteller Technologie aus (und so ähnlich, in der sich subtile Fehler manifestieren können).  Mir ist jedoch sehr klar, dass eine starke Codetrennung die Richtung ist, in die sich die Webentwicklungsbranche bewegt.  Vielleicht werden wir aufgrund der Browserunterstützung für JavaScript-Module in der Lage sein, Bundler wie Webpack vollständig aufzugeben und den Clients einfach einzelne Codemodule zuzuweisen.  Es wird interessant sein zu sehen, wohin uns das alles führt! <br><br><h2>  <font color="#3AC1EF">Ansatz 3: Verwenden öffentlicher CDNs für den Code einiger Abhängigkeiten</font> </h2><br>  Die Hauptidee: Verwenden Sie diesen Ansatz nicht. <br><br>  Wenn Sie einer von denen sind, die in der Webentwicklung ein bisschen altmodisch sind (wie ich), dann haben Sie möglicherweise das interne Gefühl, dass wir möglicherweise die Datei <code>vendor.react</code> verbinden können, die im Abschnitt „Vorgehensweise Nr. 2 "mit einer öffentlichen CDN-Ressource: <br><br><pre> <code class="javascript hljs">&lt;!-- index.html --&gt; <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">crossorigin</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">"https://unpkg.com/react@16.12.0/umd/react.production.min.js"</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="undefined"></span><span class="hljs-tag"><span class="xml"><span class="undefined"></span><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;script crossorigin src=<span class="hljs-string"><span class="hljs-string">"https://unpkg.com/react-dom@16.12.0/umd/react-dom.production.min.js"</span></span>&gt;<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> &lt;script src=<span class="hljs-string"><span class="hljs-string">"index.[hash].min.js"</span></span>&gt;<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">script</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span></code> </pre> <br>  Ich stelle fest, dass es bei Verwendung dieses Ansatzes erforderlich ist <a href="https://webpack.js.org/configuration/externals/">, dem</a> Webpack-Projektkollektor mitzuteilen, dass er <a href="https://webpack.js.org/configuration/externals/">den</a> Reaction- und Reaction <code>react-dom</code> Code aus dem Bundle ausschließen soll. <br><br>  Auf den ersten Blick sieht das alles ganz gut aus, aber dieser Ansatz hat einige Nachteile, die ich in Betracht ziehen möchte. <br><br><h3>  <font color="#3AC1EF">▍ Minus 1: Verwenden verschiedener Standorte derselben Abhängigkeitsdateien?</font>  <font color="#3AC1EF">Nicht mehr…</font> </h3><br>  Die Entwickler der alten Schule hoffen, dass, wenn alle Websites auf dieselbe CDN-Ressource verweisen und dieselbe Version von React wie unsere Website verwenden, die Besucher unserer Website, wenn sich bereits ein React-Code im Cache ihres Browsers befindet, Verschwenden Sie keine Zeit, um es neu zu laden.  Dies würde die Geschwindigkeit der Anzeige von Seiten unserer Website im Arbeitsmodus erheblich erhöhen.  Ja, und die React- <a href="https://reactjs.org/docs/cdn-links.html">Dokumentation</a> zu diesem Thema sieht vielversprechend aus.  Daher verwenden einige Entwickler mit Sicherheit dieses Muster.  Richtig? <br><br>  Obwohl dies in letzter Zeit in Browsern zur Erhöhung der Sicherheit durchaus funktionieren könnte, haben sie damit begonnen, einen Mechanismus für die gemeinsame Nutzung von Caches zu implementieren.  Wir sprechen über die Tatsache, dass selbst unter idealen Bedingungen, wenn zwei Sites dieselbe Bibliothek verwenden, die über denselben CDN-Link geladen wird, der Code für jede Domain unabhängig heruntergeladen wird und der Cache aus Gründen des Datenschutzes in der Sandbox landet einer bestimmten Domain zugeordnet.  Wie <a href="https://andydavies.me/blog/2018/09/06/safari-caching-and-3rd-party-resources/">sich herausstellte</a> , wurde dieser Mechanismus bereits in Safari implementiert (anscheinend existiert er seit 2013?!).  Wenn wir über Chrome 77 sprechen, müssen Sie ein spezielles <a href="https://chromestatus.com/feature/5730772021411840">Flag verwenden</a> , um die Cache-Trennung für den Moment zu aktivieren. <br><br>  <a href="httparchive.org/en/2019/cdn">Es</a> wird davon ausgegangen, dass die Verwendung öffentlich verfügbarer CDNs abnimmt, wenn die Cache-Freigabe in mehr Browsern implementiert wird. <br><br><h3>  <font color="#3AC1EF">▍ Minus 2: Verschwendung von Systemressourcen bei Hilfsoperationen (für jede Domäne)</font> </h3><br>  <a href="https://habr.com/ru/company/ruvds/blog/481574/">Hier wird die</a> Idee geäußert, dass die Verwendung von CDN zu einer Erhöhung der Systemlast führt, da der Browser bereits vor dem Senden der HTTP-Anfrage viele Probleme lösen muss: DNS-Namensauflösung, TCP-Verbindung, SSL-Handshake.  Um eine Verbindung mit der Site herzustellen, muss der Browser diese Aktionen in jedem Fall ausführen. Wenn jedoch auch eine Verbindung mit dem CDN hergestellt werden muss, erhöht dies die Belastung für die Site. <br><br>  Hier ist ein Wasserfalldiagramm, das den Vorgang des Ladens einer Seite veranschaulicht, die Skripte aus einer öffentlich verfügbaren CDN-Ressource verwendet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7cd/3eb/c0a/7cd3ebc0aebe48e5819fc27993b016a0.png"></div><br>  <i><font color="#999999">Wasserfall-Timeline zum Laden einer Seite unter Verwendung öffentlich verfügbarer CDN-Ressourcen</font></i> <br><br>  Die roten Ovale markieren die Bereiche, in denen Vorgänge ausgeführt werden, die der Ausführung von Abfragen vorausgehen.  Dies scheint ein bisschen zu viel für eine einfache Hello World-Anwendung. <br><br>  Da sich mein einfaches Beispiel weiterentwickelt und erweitert, wird es eine Zeit geben, in der ich meine eigene Schriftart verwenden möchte.  Zum Beispiel - entnommen aus Google Fonts.  Dies bedeutet, dass die Anzahl solcher Verzögerungen nur zunimmt, da Sie eine Verbindung zur entsprechenden Domäne herstellen müssen, um Schriftarten herunterzuladen.  Hier scheint die Idee, alle Ressourcen der Site in einer eigenen Hauptdomäne zu hosten (die sich natürlich hinter der projekteigenen CDN-Ressource auf Basis von Cloudflare oder Cloudfront befindet), sehr attraktiv zu sein. <br><br>  Wenn wir in unserem Beispiel zwei React-Abhängigkeiten von der Hauptdomäne der Site herunterladen, führt dies dazu, dass der Wasserfall-Zeitplan für das Laden von Seiten viel genauer wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f32/82a/12e/f3282a12e8626574f5a13e9a10540417.png"></div><br>  <i><font color="#999999">Ladezeitplan für Wasserfälle für eine Seite, die keine öffentlich verfügbaren CDN-Ressourcen verwendet</font></i> <br><br><h3>  <font color="#3AC1EF">▍Minus Nr. 3: Verwenden verschiedener Versionen von Abhängigkeiten von verschiedenen Standorten</font> </h3><br>  Mit React habe ich eine kleine <a href="https://docs.google.com/spreadsheets/d/12sNP1msbarCFw3v0tFyIpa8Nu0LDWGqDKjLRKkVb8gU/edit">Studie zu den</a> 32 größten Standorten erstellt.  Leider habe ich herausgefunden, dass nur 10% von ihnen öffentlich verfügbare CDN-Ressourcen zum Herunterladen von React verwenden.  Angesichts der Versionen von React, die von allen untersuchten Sites verwendet werden, stellte sich jedoch heraus, dass dies nicht wirklich wichtig ist.  In einer idealen Welt würde es keine Trennung des Browser-Cache geben, und alle Sites könnten organisiert werden und dieselben Skriptversionen aus denselben öffentlichen CDNs verwenden.  In der Realität gibt es extrem starke Unterschiede in den Versionen von React, die von verschiedenen Sites verwendet werden.  Dies zerstört die Idee eines gemeinsam genutzten Browser-Cache. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/876/fc9/4b0/876fc94b0752931da06e97f3132b3584.png"></div><br>  <i><font color="#999999">Von verschiedenen Sites verwendete Versionen reagieren</font></i> <br><br>  Wenn Sie zuerst eine beliebte Site mit React öffnen und dann eine andere, ist die Wahrscheinlichkeit sehr gering, dass beide Sites dieselbe Version von React verwenden. <br><br>  Im Laufe der Recherche habe ich weitere interessante Informationen zu diesen React-Sites gefunden.  Vielleicht erscheinen sie Ihnen auch interessant: <br><br><ul><li>  Auf 2/3 Sites wird Webpack zum Erstellen von Code verwendet. </li><li>  87% der Websites verwenden HTTP / 2. Dies ist mehr als der Durchschnittswert von 58%. </li><li>  Die meisten Projekte (ca. 56%) hosten die Schriftarten selbst. </li></ul><br>  <a href="https://docs.google.com/spreadsheets/d/12sNP1msbarCFw3v0tFyIpa8Nu0LDWGqDKjLRKkVb8gU/edit">Hier sind die</a> Quelldaten für mein Experiment. <br><br><h3>  <font color="#3AC1EF">▍Minus Nr. 4: Probleme mit Nichterfüllung</font> </h3><br>  Leider haben diejenigen, die öffentlich verfügbare CDN-Ressourcen nutzen, heute nicht nur Probleme mit der Geschwindigkeit beim Laden von Seiten, sondern auch mit einigen anderen Problemen: <br><br><ul><li>  Sicherheitsfragen.  Mit der Verwendung öffentlich verfügbarer CDN-Ressourcen sind andere Sicherheitsprobleme verbunden als die, mit denen die Cache-Freigabe in Browsern behoben werden soll.  Wenn beispielsweise Hacker in eine öffentlich zugängliche CDN-Ressource eindringen, können sie schädlichen JavaScript-Code sehr sorgfältig in Bibliotheken einfügen.  Ein solcher Code verfügt über alle Berechtigungen des Site-Codes, der auf dem Client ausgeführt wird. Er kann mit den Daten von Benutzern arbeiten, die sich auf der Site angemeldet haben. </li><li>  Datenschutzprobleme.  Viele Unternehmen erheben Benutzerdaten aus Anfragen von Drittanbietern.  Wenn die Verwendung einer öffentlich verfügbaren CDN-Ressource zum Herunterladen von Abhängigkeitscode oder Zeichensätzen auf allen Sites implementiert ist, kann diese CDN-Ressource theoretisch Benutzersitzungen und die Funktionen ihrer Arbeit im Internet verfolgen.  Eine ähnliche Ressource kann Annahmen darüber treffen, was sie interessiert (zum Beispiel für Werbezwecke).  Und das alles - ohne den Einsatz von Cookies! </li><li>  Single Point of Failure.  Durch die Verteilung der für das Funktionieren der Website erforderlichen Materialien auf mehrere Domänen steigt die Wahrscheinlichkeit, dass der Client aufgrund von Problemen in einer dieser Domänen nur einen Teil der Materialien herunterladen kann, die erforderlich sind, um die Seiten funktionsfähig zu machen.  Um ehrlich zu sein, können solche Probleme mit JavaScript gelöst werden, aber der Website-Entwickler muss hierfür einige zusätzliche Anstrengungen unternehmen. </li></ul><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  Es ist sehr offensichtlich, dass die Zukunft bei Ansatz Nr. 2 liegt. <br><br>  Hosten Sie Ihre eigenen CDN-Ressourcen vor Ihren Servern mithilfe von HTTP / 2 (z. B. Cloudflare oder Cloudfront).  Teilen Sie den Code in kleine Fragmente auf, um den Browser-Cache effektiv zu nutzen.  In Zukunft werden die Fragmente, in die der Site-Code unterteilt ist, möglicherweise noch kleiner und erreichen die Größe einzelner <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Modules">JavaScript-Module</a> , da die Browser die Unterstützung für diese Technologie bereits implementiert haben. <br><br>  <b>Sehr geehrte Leser!</b>  Verwenden Sie Codetrennungstechnologien in Ihren Webprojekten? <br><br> <a href="https://ruvds.com/ru-rub/"><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de483682/">https://habr.com/ru/post/de483682/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de483668/index.html">Die Verdauung von frischen Materialien aus der Welt des Frontends für die letzte Woche Nr. 397 (6. - 12. Januar 2020)</a></li>
<li><a href="../de483670/index.html">Alles, was Sie über die MAC-Adresse wissen wollten</a></li>
<li><a href="../de483674/index.html">Wie binäre neuronale Netze funktionieren und warum sie 2020 populär sein werden</a></li>
<li><a href="../de483676/index.html">Bewertung der Wirksamkeit und der Kosten der Implementierung eines umfassenden Marketinganalysesystems</a></li>
<li><a href="../de483680/index.html">Häufig zu vermeidende Programmierfehler</a></li>
<li><a href="../de483684/index.html">PHP Digest Nr. 171 (1. - 13. Januar 2020)</a></li>
<li><a href="../de483686/index.html">32 Tipps für einen Webentwickler, der 2020 über sich hinauswachsen will</a></li>
<li><a href="../de483688/index.html">Etwa 30x Concurrency Boost in Node.js</a></li>
<li><a href="../de483698/index.html">Wie LoRaWAN zum Aufbau eines modernen Internets der Dinge beiträgt</a></li>
<li><a href="../de483700/index.html">Körperliche Ergebnisse des Jahres - 2019</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>