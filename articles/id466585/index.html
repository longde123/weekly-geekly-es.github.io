<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐼 🔂 👇🏻 Memahami broker pesan. Mempelajari mekanisme pengiriman pesan melalui ActiveMQ dan Kafka. Bab 3. Kafka 👩🏻‍🤝‍👨🏿 💙 🗨️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Kelanjutan dari terjemahan sebuah buku kecil: 
 "Memahami Pialang Pesan", 
 penulis: Jakub Korab, penerbit: O'Reilly Media, Inc., tanggal publikasi: J...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Memahami broker pesan. Mempelajari mekanisme pengiriman pesan melalui ActiveMQ dan Kafka. Bab 3. Kafka</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/466585/"> Kelanjutan dari terjemahan sebuah buku kecil: <br>  "Memahami Pialang Pesan", <br>  penulis: Jakub Korab, penerbit: O'Reilly Media, Inc., tanggal publikasi: Juni 2017, ISBN: 9781492049296. <br><br>  <b>Terjemahan selesai: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tele.gg/middle_java</a></b> <br><br>  Bagian sebelumnya: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Memahami Pialang Pesan.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Mempelajari mekanisme pengiriman pesan melalui ActiveMQ dan Kafka.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 2. ActiveMQ</a> <br><a name="habracut"></a><br><h2>  BAB 3 </h2><br><h2>  Kafka </h2><br>  Kafka dikembangkan di LinkedIn untuk menghindari beberapa batasan dari pialang pesan tradisional dan untuk menghindari kebutuhan untuk mengonfigurasi beberapa pialang pesan untuk interaksi titik-ke-titik yang berbeda, yang dijelaskan dalam bagian “Penskalaan Vertikal dan Horisontal” pada halaman 28 dalam buku ini. LinkedIn sangat bergantung pada penyerapan satu arah data dalam jumlah sangat besar, seperti klik halaman dan log akses, sambil memungkinkan banyak sistem untuk menggunakan data ini.  am, tanpa mempengaruhi kinerja produsen atau konsyumerov lainnya.  Faktanya, alasan Kafka ada adalah untuk mendapatkan arsitektur perpesanan yang dijelaskan oleh Universal Data Pipeline. <br><br>  Mengingat tujuan akhir ini, persyaratan lain muncul secara alami.  Kafka harus: <br><br><ul><li>  Sangat cepat </li><li>  Berikan throughput perpesanan yang lebih besar </li><li>  Mendukung model Publisher-Subscriber dan Point-to-Point </li><li>  Jangan memperlambat dengan penambahan konsumen.  Misalnya, kinerja antrian dan topik di ActiveMQ memburuk seiring dengan meningkatnya jumlah konsumen di tujuan. </li><li>  Dapat diskalakan secara horizontal;  jika satu pesan tetap hanya dapat melakukan ini pada kecepatan disk maksimum, maka untuk meningkatkan kinerja, masuk akal untuk melampaui batas satu instance broker </li><li>  Gambarkan akses ke penyimpanan dan pengambilan pesan </li></ul><br>  Untuk mencapai semua ini, Kafka telah mengadopsi arsitektur yang mendefinisikan kembali peran dan tanggung jawab klien dan broker pesan.  Model JMS sangat fokus pada broker, di mana dia bertanggung jawab atas distribusi pesan, dan pelanggan hanya perlu khawatir tentang mengirim dan menerima pesan.  Kafka, di sisi lain, berorientasi pada pelanggan, dengan klien mengambil banyak fungsi dari broker tradisional, seperti distribusi adil pesan yang relevan di antara konsumen, dalam pertukaran menerima broker yang sangat cepat dan dapat diskalakan.  Bagi orang yang bekerja dengan sistem pesan tradisional, bekerja dengan Kafka membutuhkan perubahan mendasar dalam sikap. <br>  Arah teknik ini telah mengarah pada penciptaan infrastruktur perpesanan yang dapat meningkatkan throughput oleh banyak pesanan yang besar dibandingkan dengan broker konvensional.  Seperti yang akan kita lihat, pendekatan ini penuh dengan kompromi, yang berarti bahwa Kafka tidak cocok untuk jenis beban tertentu dan perangkat lunak yang diinstal. <br><br><h3>  Model Tujuan Terpadu </h3><br>  Untuk memenuhi persyaratan yang dijelaskan di atas, Kafka menggabungkan publikasi-berlangganan dan pesan point-to-point dalam satu jenis penerima - <i>topik</i> .  Ini membingungkan bagi orang yang bekerja dengan sistem perpesanan, di mana kata "topik" mengacu pada mekanisme penyiaran dari mana (dari topik) pembacaan tidak dapat diandalkan (tidak dapat dipertahankan).  Topik-topik Kafka harus dianggap sebagai jenis tujuan campuran, sebagaimana didefinisikan dalam pengantar buku ini. <br><blockquote>  Di sisa bab ini, kecuali jika kami secara eksplisit menentukan sebaliknya, istilah topik akan merujuk ke topik Kafka. </blockquote><br>  Untuk sepenuhnya memahami bagaimana topik berperilaku dan jaminan apa yang mereka berikan, pertama-tama kita perlu mempertimbangkan bagaimana mereka diterapkan di Kafka. <br>  <i>Setiap topik di Kafka memiliki jurnal sendiri.</i> <br>  Produsen yang mengirim pesan ke Kafka menambahkan ke majalah ini, dan konsumen membaca dari majalah menggunakan petunjuk yang terus bergerak maju.  Kafka secara berkala menghapus bagian tertua dari jurnal, terlepas dari apakah pesan di bagian ini dibaca atau tidak.  Bagian utama dari desain Kafka adalah bahwa broker tidak peduli apakah pesan dibaca atau tidak - ini adalah tanggung jawab klien. <br><blockquote>  Istilah "jurnal" dan "indeks" tidak ditemukan dalam <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dokumentasi Kafka</a> .  Istilah-istilah terkenal ini digunakan di sini untuk membantu pemahaman. </blockquote><br>  Model ini sama sekali berbeda dari ActiveMQ, di mana pesan dari semua antrian disimpan dalam satu jurnal, dan broker menandai pesan setelah dihapus setelah dibaca. <br>  Sekarang mari kita sedikit lebih dalam dan melihat majalah topik secara lebih rinci. <br>  Majalah Kafka terdiri dari beberapa partisi ( <a href="">Gambar 3-1</a> ).  Kafka menjamin pemesanan ketat di setiap partisi.  Ini berarti bahwa pesan yang ditulis ke partisi dalam urutan tertentu akan dibaca dalam urutan yang sama.  Setiap partisi diimplementasikan sebagai file log bergulir (log) yang berisi <i>subset dari</i> semua pesan yang dikirim ke topik oleh produsennya.  Topik yang dibuat berisi satu partisi secara default.  Partisi adalah ide sentral Kafka untuk penskalaan horizontal. <br><br><img src="https://habrastorage.org/webt/tm/w2/yf/tmw2yf3lanppqtrumxoidotplhi.png"><br>  <i>Gambar 3-1.</i>  <i>Partisi Kafka</i> <br><br>  Ketika produser mengirim pesan ke topik Kafka, ia memutuskan partisi mana yang akan dikirimi pesan.  Kami akan mempertimbangkan ini secara lebih rinci nanti. <br><br><h2>  Membaca pesan </h2><br>  Klien yang ingin membaca pesan mengontrol penunjuk bernama yang disebut <i>grup konsumen</i> , yang menunjukkan <i>offset</i> pesan dalam partisi.  Offset adalah posisi dengan angka yang bertambah yang dimulai dari 0 pada awal partisi.  Kelompok konsumen ini, yang dirujuk dalam API melalui group_id pengenal yang ditentukan pengguna, berhubungan dengan <i>satu konsumen logis atau sistem</i> . <br><br>  Sebagian besar sistem pesan membaca data dari penerima melalui beberapa kejadian dan utas untuk memproses pesan secara paralel.  Dengan demikian, biasanya akan ada banyak contoh konsumen yang berbagi kelompok konsumen yang sama. <br><br>  Masalah membaca dapat direpresentasikan sebagai berikut: <br><br><ul><li>  Topik ini memiliki beberapa partisi </li><li>  Beberapa kelompok konsumen dapat menggunakan topik pada saat yang bersamaan. </li><li>  Sekelompok konsumen dapat memiliki beberapa contoh terpisah. </li></ul><br>  Ini adalah masalah banyak-ke-banyak nontrivial.  Untuk memahami bagaimana Kafka menangani hubungan antara kelompok konsumen, contoh dari konsumen dan partisi, mari kita lihat serangkaian skrip bacaan yang semakin kompleks. <br><br><h3>  Grup Konsumen dan Konsumen </h3><br>  Mari kita ambil satu topik partisi sebagai titik awal ( <a href="">Gambar 3-2</a> ). <br><br><img src="https://habrastorage.org/webt/6z/tz/dh/6ztzdhqmjweck-z15htxb2xbe28.png"><br>  <i>Gambar 3-2.</i>  <i>Konsumen membaca dari partisi</i> <br><br>  Ketika instance konsumen terhubung dengan group_id-nya sendiri ke topik ini, ia diberi partisi untuk dibaca dan offset di partisi ini.  Posisi offset ini dikonfigurasikan pada klien sebagai penunjuk ke posisi terbaru (pesan terbaru) atau posisi paling awal (pesan terlama).  Konsumen meminta (polling) pesan dari topik, yang mengarah ke pembacaan berurutan dari jurnal. <br>  Posisi ofset secara teratur dikomit kembali ke Kafka dan disimpan sebagai pesan dalam topik internal <i>_consumer_offsets</i> .  Membaca pesan masih belum dihapus, tidak seperti broker biasa, dan klien dapat memundurkan offset untuk memproses ulang pesan yang sudah dilihat. <br><br>  Ketika konsumen logis kedua terhubung menggunakan group_id lain, itu mengontrol pointer kedua yang independen dari yang pertama ( <a href="">Gambar 3-3</a> ).  Dengan demikian, topik Kafka bertindak sebagai antrian di mana ada satu konsumen dan, sebagai topik biasa, pelanggan-pelanggan (pub-sub), di mana beberapa pelanggan berlangganan, dengan keuntungan tambahan bahwa semua pesan disimpan dan dapat diproses beberapa kali. <br><br><img src="https://habrastorage.org/webt/qe/v1/yk/qev1yktga3s-g1gqlynylbe3n9w.png"><br>  <i>Gambar 3-3.</i>  <i>Dua konsumen dalam kelompok konsumen yang berbeda membaca dari partisi yang sama</i> <br><br><h3>  Konsumen dalam Kelompok Konsumen </h3><br>  Ketika salah satu instance dari konsumen membaca data dari partisi, itu sepenuhnya mengontrol pointer dan memproses pesan, seperti yang dijelaskan di bagian sebelumnya. <br>  Jika beberapa instance dari konsumen terhubung dengan group_id yang sama ke topik dengan satu partisi, maka instance yang terhubung terakhir akan diberikan kontrol atas pointer dan sejak saat itu akan menerima semua pesan ( <a href="">Gambar 3-4</a> ). <br><br><img src="https://habrastorage.org/webt/0j/ao/f2/0jaof2mdwg3cqvmwemhtxkrltuq.png"><br>  <i>Gambar 3-4.</i>  <i>Dua konsumen dalam kelompok konsumen yang sama membaca dari partisi yang sama</i> <br><br>  Mode pemrosesan ini, di mana jumlah instance konsumen melebihi jumlah partisi, dapat dianggap sebagai semacam konsumen monopoli.  Ini dapat berguna jika Anda memerlukan pengelompokan "aktif-pasif" (atau "panas-hangat") dari contoh konsumen Anda, meskipun operasi paralel dari beberapa konsumen ("aktif-aktif" atau "panas-panas") jauh lebih khas daripada konsumen dalam modus siaga. <br><blockquote>  Perilaku distribusi pesan ini, dijelaskan di atas, bisa mengejutkan dibandingkan dengan bagaimana antrian JMS biasa berperilaku.  Dalam model ini, pesan yang dikirim ke antrian akan didistribusikan secara merata antara dua konsumen. </blockquote><br>  Paling sering, ketika kami membuat beberapa contoh kompiler, kami melakukan ini baik untuk pemrosesan pesan paralel, atau untuk meningkatkan kecepatan membaca, atau untuk meningkatkan stabilitas proses membaca.  Karena hanya satu instance dari konsumen yang dapat membaca data dari partisi, bagaimana hal ini dicapai dalam Kafka? <br><br>  Salah satu cara untuk melakukan ini adalah dengan menggunakan satu instance dari konsumen untuk membaca semua pesan dan mengirimkannya ke kumpulan utas.  Meskipun pendekatan ini meningkatkan throughput pemrosesan, itu meningkatkan kompleksitas logika konsumen dan tidak melakukan apa pun untuk meningkatkan stabilitas sistem membaca.  Jika salah satu instance dari konsumen mati karena kegagalan daya atau peristiwa serupa, maka proofreading berhenti. <br><br>  Cara kanonik untuk menyelesaikan masalah ini di Kafka adalah dengan menggunakan lebih banyak partisi. <br><br><h3>  Partisi </h3><br>  Partisi adalah mekanisme utama untuk memparalelkan pembacaan dan penskalaan topik di luar bandwidth dari satu instance broker.  Untuk lebih memahami hal ini, mari kita lihat situasi di mana ada topik dengan dua partisi dan satu konsumen berlangganan topik ini ( <a href="">Gambar 3-5</a> ). <br><br><img src="https://habrastorage.org/webt/en/9g/ct/en9gct0o017cqp8buawguwlscty.png"><br>  <i>Gambar 3-5.</i>  <i>Seorang konsumen membaca dari beberapa partisi</i> <br><br>  Dalam skenario ini, konsultan diberikan kendali atas pointer yang sesuai dengan group_id di kedua partisi, dan membaca pesan dari kedua partisi dimulai. <br>  Ketika kompurator tambahan ditambahkan ke topik ini untuk group_id yang sama, Kafka menugaskan kembali (realokasi) salah satu partisi dari yang pertama ke yang kedua.  Setelah itu, setiap instance dari konsumen akan dikurangkan dari satu partisi topik ( <a href="">Gambar 3-6</a> ). <br><br>  Untuk memastikan bahwa pesan diproses secara paralel dalam 20 utas, Anda memerlukan setidaknya 20 partisi.  Jika ada lebih sedikit partisi, Anda masih akan memiliki konsumen yang tidak memiliki apa-apa untuk dikerjakan, seperti yang dijelaskan sebelumnya dalam diskusi monitor eksklusif. <br><br><img src="https://habrastorage.org/webt/8b/a0/um/8ba0umn2yzr9yy3vztonhdfiub0.png"><br>  <i>Gambar 3-6.</i>  <i>Dua konsumen dalam kelompok konsumen yang sama membaca dari partisi yang berbeda</i> <br><br>  Skema ini secara signifikan mengurangi kompleksitas broker Kafka dibandingkan dengan distribusi pesan yang diperlukan untuk mendukung antrian JMS.  Tidak perlu mengurus hal-hal berikut: <br><br><ul><li>  Konsumen mana yang harus menerima pesan berikutnya berdasarkan distribusi round-robin, kapasitas buffer prefetch saat ini, atau pesan sebelumnya (seperti untuk grup pesan JMS). </li><li>  Pesan apa yang dikirim ke konsumen mana dan harus dibenci jika terjadi kegagalan. </li></ul><br>  Semua yang harus dilakukan oleh broker Kafka adalah secara konsisten mengirim pesan kepada penasihat ketika yang terakhir meminta mereka. <br><br>  Namun, persyaratan untuk memaralelkan proofreading dan mengirim ulang pesan yang gagal tidak hilang - tanggung jawab untuknya hanya berpindah dari broker ke klien.  Ini berarti bahwa mereka harus diperhitungkan dalam kode Anda. <br><br><h2>  Mengirim pesan </h2><br>  Tanggung jawab untuk memutuskan partisi mana yang akan dikirimi pesan adalah produsen pesan.  Untuk memahami mekanisme yang melaluinya ini dilakukan, pertama-tama Anda perlu mempertimbangkan apa yang sebenarnya kami kirim. <br><br>  Sementara di JMS kami menggunakan struktur pesan dengan metadata (header dan properti) dan badan yang mengandung muatan, di Kafka pesannya adalah <i>pasangan nilai kunci</i> .  Payload pesan dikirim sebagai nilai.  Kunci, di sisi lain, digunakan terutama untuk mempartisi dan harus mengandung <i>kunci logika bisnis khusus</i> untuk meletakkan pesan terkait di partisi yang sama. <br><br>  Dalam Bab 2, kami membahas skenario taruhan online, ketika acara terkait harus diproses secara berurutan oleh satu konsumen: <br><br><ol><li>  Akun pengguna sudah dikonfigurasikan. </li><li>  Uang dikreditkan ke akun. </li><li>  Taruhan dibuat yang menarik uang dari akun. </li></ol><br>  Jika setiap peristiwa adalah pesan yang dikirim ke topik, maka dalam hal ini pengenal akun akan menjadi kunci alami. <br>  Ketika sebuah pesan dikirim menggunakan API Produser Kafka, itu diteruskan ke fungsi partisi, yang, mengingat pesan dan keadaan saat ini dari cluster Kafka, mengembalikan pengidentifikasi partisi yang pesannya harus dikirim.  Fitur ini diimplementasikan di Jawa melalui antarmuka Partitioner. <br><br>  Antarmuka ini adalah sebagai berikut: <br><br><pre><code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Partitioner</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">partition</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(String topic, Object key, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] keyBytes, Object value, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] valueBytes, Cluster cluster)</span></span></span></span>; }</code> </pre> <br>  Implementasi Partitioner menggunakan algoritma hashing tujuan umum default atas kunci atau round-robin jika kunci tidak ditentukan untuk menentukan partisi.  Nilai default ini berfungsi dengan baik dalam banyak kasus.  Namun, di masa depan Anda akan ingin menulis sendiri. <br><br><h3>  Menulis strategi pemartisian Anda sendiri </h3><br>  Mari kita lihat contoh ketika Anda ingin mengirim metadata bersama dengan payload pesan.  Payload dalam contoh kami adalah instruksi untuk melakukan setoran ke akun game.  Suatu instruksi adalah sesuatu yang kami ingin jamin untuk tidak dimodifikasi selama transmisi, dan kami ingin memastikan bahwa hanya sistem superior yang tepercaya yang dapat memulai instruksi ini.  Dalam hal ini, sistem pengiriman dan penerimaan menyetujui penggunaan tanda tangan untuk mengotentikasi pesan. <br>  Dalam JMS biasa, kami cukup mendefinisikan properti tanda tangan pesan dan menambahkannya ke pesan.  Namun, Kafka tidak memberi kami mekanisme untuk mentransmisikan metadata - hanya kunci dan nilainya. <br><br>  Karena nilainya adalah payload dari transfer bank (pay transfer bank), integritas yang ingin kami pertahankan, kami tidak punya pilihan selain menentukan struktur data untuk digunakan dalam kunci.  Dengan asumsi kami membutuhkan pengenal akun untuk dipartisi, karena semua pesan yang terkait dengan akun harus diproses secara berurutan, kami akan membuat struktur JSON berikut: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"signature"</span></span>: <span class="hljs-string"><span class="hljs-string">"541661622185851c248b41bf0cea7ad0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"accountId"</span></span>: <span class="hljs-string"><span class="hljs-string">"10007865234"</span></span> }</code> </pre> <br>  Karena nilai tanda tangan akan bervariasi tergantung pada payload, strategi hash antarmuka Partitioner default tidak akan secara andal mengelompokkan pesan terkait.  Oleh karena itu, kita perlu menulis strategi kita sendiri, yang akan menganalisis kunci ini dan membagikan nilai dari akunId. <br><blockquote>  Kafka mencakup checksum untuk mendeteksi korupsi pesan di repositori dan memiliki serangkaian fitur keamanan lengkap.  Bahkan kemudian, persyaratan spesifik industri terkadang muncul, seperti yang di atas. </blockquote><br>  Strategi partisi pengguna harus memastikan bahwa semua pesan terkait berakhir di partisi yang sama.  Meskipun ini tampak sederhana, persyaratannya bisa rumit karena pentingnya memesan pesan terkait dan seberapa tetap jumlah partisi dalam topik. <br><br>  Jumlah partisi dalam topik dapat berubah seiring waktu, karena dapat ditambahkan jika lalu lintas melampaui harapan awal.  Dengan demikian, kunci pesan dapat dikaitkan dengan partisi yang awalnya dikirim, menyiratkan bagian dari negara yang harus didistribusikan antara instance produsen. <br><br>  Faktor lain yang perlu dipertimbangkan adalah distribusi seragam dari pesan antar partisi.  Sebagai aturan, kunci tidak didistribusikan secara merata di seluruh pesan, dan fungsi hash tidak menjamin distribusi pesan yang adil untuk sekumpulan kunci kecil. <br>  Penting untuk dicatat bahwa, tidak peduli bagaimana Anda memutuskan untuk membagi pesan, pemisah itu sendiri mungkin perlu digunakan kembali. <br><br>  Pertimbangkan persyaratan untuk replikasi data antara kelompok Kafka di lokasi geografis yang berbeda.  Untuk tujuan ini, Kafka dilengkapi dengan alat baris perintah yang disebut MirrorMaker, yang digunakan untuk membaca pesan dari satu cluster dan mentransfernya ke yang lain. <br><br>  MirrorMaker harus memahami kunci dari topik yang direplikasi untuk mempertahankan urutan relatif antara pesan selama replikasi antar cluster, karena jumlah partisi untuk topik ini mungkin tidak bertepatan dalam dua cluster. <br><br>  Strategi partisi kustom relatif jarang, karena hash default atau round robin bekerja dengan sukses di sebagian besar skenario.  Namun, jika Anda memerlukan jaminan pemesanan yang ketat atau Anda perlu mengekstrak metadata dari payload, partisi adalah sesuatu yang harus Anda perhatikan lebih dekat. <br><br>  Skalabilitas dan manfaat kinerja Kafka berasal dari mentransfer beberapa tanggung jawab broker tradisional kepada klien.  Dalam hal ini, keputusan dibuat pada distribusi pesan yang berpotensi terkait di antara beberapa konsumen yang bekerja secara paralel. <br><blockquote>  Broker JMS juga harus berurusan dengan persyaratan tersebut.  Menariknya, mekanisme untuk mengirim pesan terkait ke akun yang sama diimplementasikan melalui Grup Pesan JMS (semacam strategi penyeimbangan sticky load balancing (SLB)) juga mengharuskan pengirim untuk menandai pesan yang terkait.  Dalam kasus JMS, broker bertanggung jawab untuk mengirim grup ini pesan terkait ke salah satu dari banyak pelanggan dan mengalihkan kepemilikan grup jika pelanggan telah jatuh. </blockquote><br><h2>  Perjanjian produsen </h2><br>  Partisi bukan satu-satunya hal yang perlu dipertimbangkan saat mengirim pesan.  Mari kita lihat metode send () dari kelas Produser di Java API: <br><br><pre> <code class="java hljs">Future &lt; RecordMetadata &gt; send(ProducerRecord &lt; K, V &gt; record); Future &lt; RecordMetadata &gt; send(ProducerRecord &lt; K, V &gt; record, Callback callback);</code> </pre> <br>  Harus segera dicatat bahwa kedua metode mengembalikan Masa Depan, yang menunjukkan bahwa operasi pengiriman tidak dilakukan segera.  Akibatnya, ternyata pesan (ProducerRecord) ditulis ke buffer kirim untuk setiap partisi aktif dan dikirim ke broker di aliran latar belakang di perpustakaan klien Kafka.  Meskipun ini membuat pekerjaan menjadi sangat cepat, itu berarti bahwa aplikasi yang tidak berpengalaman dapat kehilangan pesan jika prosesnya dihentikan. <br><br>  Seperti biasa, ada cara untuk membuat operasi pengiriman lebih dapat diandalkan karena kinerja.  Ukuran buffer ini dapat diatur ke 0, dan utas aplikasi pengirim akan dipaksa untuk menunggu hingga pesan dikirim ke broker, sebagai berikut: <br><br><pre> <code class="java hljs">RecordMetadata metadata = producer.send(record).get();</code> </pre> <br><h2>  Sekali lagi tentang membaca pesan </h2><br>  Membaca pesan memiliki kesulitan tambahan yang perlu dipertimbangkan.  Tidak seperti JMS API, yang dapat memulai pendengar pesan sebagai respons terhadap pesan, antarmuka Kafka <i>Konsumen</i> hanya melakukan polling.  Mari kita lihat lebih dekat pada <i>polling ()</i> metode yang digunakan untuk tujuan ini: <br><br><pre> <code class="java hljs">ConsumerRecords &lt; K, V &gt; poll(<span class="hljs-keyword"><span class="hljs-keyword">long</span></span> timeout);</code> </pre> <br>  Nilai kembali dari metode ini adalah struktur kontainer yang berisi beberapa objek <i>ConsumerRecord</i> dari beberapa partisi yang berpotensi.  <i>ConsumerRecord</i> sendiri adalah objek pemegang untuk pasangan kunci-nilai dengan metadata terkait, seperti partisi dari mana ia berasal. <br><br>  Seperti dibahas dalam Bab 2, kita harus terus-menerus mengingat apa yang terjadi pada pesan setelah mereka berhasil atau tidak berhasil diproses, misalnya, jika klien tidak dapat memproses pesan atau jika itu mengganggu pekerjaan.  Di JMS, ini ditangani melalui mode pengakuan.  Pialang akan menghapus pesan yang berhasil diproses, atau mengirim kembali pesan mentah atau terbalik (asalkan transaksi telah digunakan). <br>  Kafka bekerja dengan cara yang sangat berbeda.  Pesan tidak dihapus di broker setelah proofreading, dan tanggung jawab untuk apa yang terjadi setelah kegagalan terletak pada kode itu sendiri. <br><br>  Seperti yang sudah kami katakan, sekelompok konsumen dikaitkan dengan offset di majalah.  Posisi log yang terkait dengan bias ini sesuai dengan pesan berikutnya yang akan dikeluarkan sebagai tanggapan terhadap <i>jajak pendapat ()</i> .  Penting dalam membaca adalah saat ketika offset ini meningkat. <br><br>  Kembali ke model membaca yang dibahas sebelumnya, pemrosesan pesan terdiri dari tiga tahap: <br><br><ol><li>  Ambil pesan untuk dibaca. </li><li>  Memproses pesan. </li><li>  Konfirmasikan pesan. </li></ol><br>  Penasihat Konsumen Kafka hadir dengan <i>opsi</i> konfigurasi <i>enable.auto.commit</i> .  Ini adalah pengaturan default yang umum digunakan, seperti biasanya halnya dengan pengaturan yang mengandung kata "auto". <br><br>  Sebelum Kafka 0.10, klien yang menggunakan parameter ini mengirim ofset pesan terakhir yang dibaca pada panggilan berikutnya <i>()</i> setelah pemrosesan.  Ini berarti bahwa setiap pesan yang sudah diambil dapat diproses ulang jika klien sudah memprosesnya, tetapi secara tak terduga dihancurkan sebelum memanggil <i>polling ()</i> .  Karena pialang tidak mempertahankan status apa pun tentang berapa kali pesan telah dibaca, konsumen berikutnya yang mengambil pesan ini tidak akan tahu bahwa sesuatu yang buruk telah terjadi.  Perilaku ini transaksional semu.  Offset hanya dilakukan jika berhasil memproses pesan, tetapi jika klien menyela, broker kembali mengirim pesan yang sama ke klien lain.  Perilaku ini konsisten dengan jaminan pengiriman pesan " <i>setidaknya satu kali</i> ". <br><br>  Dalam Kafka 0.10, kode klien diubah sedemikian rupa sehingga komit mulai secara berkala dimulai oleh perpustakaan klien, sesuai dengan pengaturan <i>auto.commit.interval.ms</i> .  Perilaku ini berada di antara mode JMS AUTO_ACKNOWLEDGE dan DUPS_OK_ACKNOWLEDGE.  Ketika menggunakan komit otomatis, pesan dapat dikonfirmasi terlepas dari apakah mereka benar-benar diproses - ini bisa terjadi dalam kasus konsumen yang lambat.  Jika compurator terputus, pesan diambil oleh kompurator berikutnya, mulai dari posisi aman, yang dapat menyebabkan pesan dilewati.  Dalam hal ini, Kafka tidak kehilangan pesan, kode bacaan tidak memprosesnya. <br><br>  Mode ini memiliki prospek yang sama seperti dalam versi 0.9: pesan dapat diproses, tetapi jika terjadi kegagalan, offset mungkin tidak ditutup, yang berpotensi menyebabkan duplikasi pengiriman.  Semakin banyak pesan yang Anda ambil saat melakukan <i>polling ()</i> , semakin besar masalah ini. <br><br>  Sebagaimana dibahas dalam bagian "Mengurangi Pesan dari Antrian" pada <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 2</a> , tidak ada pengiriman pesan satu kali dalam sistem pengiriman pesan, mengingat mode kegagalan. <br><br>  Di Kafka, ada dua cara untuk memperbaiki (melakukan) offset (offset): otomatis dan manual.  Dalam kedua kasus, pesan dapat diproses beberapa kali, jika pesan diproses tetapi gagal sebelum melakukan.  Anda juga tidak dapat memproses pesan sama sekali jika komit terjadi di latar belakang dan kode Anda selesai sebelum mulai diproses (mungkin di Kafka 0.9 dan versi sebelumnya). <br><br>  Anda dapat mengontrol proses melakukan offset secara manual di Kafka <i>Consumer</i> API dengan mengatur <i>enable.auto.commit</i> untuk false dan secara eksplisit memanggil salah satu metode berikut: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">commitSync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">commitAsync</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>;</code> </pre> <br>  Jika Anda ingin memproses pesan "setidaknya sekali", Anda harus melakukan offset secara manual menggunakan <i>commitSync ()</i> dengan menjalankan perintah ini segera setelah memproses pesan. <br><br>  Metode-metode ini tidak memungkinkan pesan untuk diakui sebelum diproses, tetapi mereka tidak melakukan apa pun untuk menghilangkan duplikasi pemrosesan yang potensial, sementara pada saat yang sama menciptakan tampilan transaksionalitas.  Kafka tidak memiliki transaksi.  Klien tidak memiliki kesempatan untuk melakukan hal berikut: <br><br><ul><li>  Secara otomatis memutar kembali pesan rollback.  Konsumen sendiri harus menangani pengecualian yang muncul dari muatan bermasalah dan pemutusan sambungan, karena mereka tidak dapat mengandalkan broker untuk mengirim kembali pesan. </li><li>  Kirim pesan ke beberapa topik dalam satu operasi atom.  Seperti yang akan kita lihat nanti, kontrol atas berbagai topik dan partisi dapat ditemukan di berbagai mesin di cluster Kafka, yang tidak mengoordinasikan transaksi saat mengirim.  Pada saat penulisan ini, beberapa pekerjaan telah dilakukan untuk memungkinkan hal ini dengan KIP-98. </li><li>  Kaitkan membaca satu pesan dari satu topik dengan mengirim pesan lain ke topik lain.  Sekali lagi, arsitektur Kafka tergantung pada banyak mesin independen yang bekerja sebagai satu bus dan tidak ada upaya untuk menyembunyikannya.  Misalnya, tidak ada komponen API yang memungkinkan <i>Konsumen</i> dan <i>Produser</i> untuk ditautkan dalam transaksi.  Dalam JMS, ini disediakan oleh objek <i>Sesi</i> dari mana <i>MessageProducers</i> dan <i>MessageConsumers</i> dibuat. </li></ul><br>  Jika kita tidak bisa mengandalkan transaksi, bagaimana kita bisa menyediakan semantik yang lebih dekat dengan yang disediakan oleh sistem pesan tradisional? <br><br>  Jika ada kemungkinan bahwa offset konsumen dapat meningkat sebelum pesan diproses, misalnya, selama kegagalan pelanggan, maka pelanggan tidak akan tahu apakah grup pelanggan telah melewatkan pesan ketika ia diberi partisi.  Dengan demikian, salah satu strategi adalah memundurkan offset ke posisi sebelumnya.  API Penasihat Konsumen Kafka menyediakan metode berikut untuk ini: <br><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">seek</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(TopicPartition partition, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">long</span></span></span></span><span class="hljs-function"><span class="hljs-params"> offset)</span></span></span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">seekToBeginning</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Collection &lt; TopicPartition &gt; partitions)</span></span></span></span>;</code> </pre> <br>  Metode <i>seek ()</i> dapat digunakan dengan metode tersebut <br>  <i>offsetsForTimes (Peta &lt;TopicPartition, Long&gt; timestampsToSearch)</i> untuk mundur ke keadaan pada titik tertentu di masa lalu. <br><br>  Secara implisit, menggunakan pendekatan ini berarti sangat mungkin bahwa beberapa pesan yang diproses sebelumnya akan dibaca dan diproses lagi.  Untuk menghindari hal ini, kita dapat menggunakan pembacaan idempoten, seperti dijelaskan dalam Bab 4, untuk melacak pesan yang dilihat sebelumnya dan menghilangkan duplikat. <br><br>  Sebagai alternatif, kode konsumen Anda dapat menjadi sederhana jika kehilangan atau duplikasi pesan diizinkan.  Ketika kami mempertimbangkan skenario penggunaan yang biasanya digunakan Kafka, misalnya, memproses peristiwa log, metrik, pelacakan klik, dll., Kami memahami bahwa hilangnya masing-masing pesan tidak akan berdampak signifikan pada aplikasi di sekitarnya.  Dalam kasus tersebut, nilai default dapat diterima.  Di sisi lain, jika aplikasi Anda perlu mentransfer pembayaran, Anda harus hati-hati mengurus setiap pesan individu.  Itu semua bermuara pada konteks. <br><br>  Pengamatan pribadi menunjukkan bahwa dengan meningkatnya intensitas pesan, nilai setiap pesan individu menurun.  Pesan bervolume tinggi cenderung menjadi berharga jika dilihat dalam bentuk agregat. <br><br><h2>  Ketersediaan Tinggi </h2><br>  Pendekatan ketersediaan tinggi Kafka sangat berbeda dari ActiveMQ.  Kafka dikembangkan berdasarkan kelompok yang dapat diskalakan secara horizontal di mana semua instance broker menerima dan mendistribusikan pesan secara bersamaan. <br><br>  Cluster Kafka terdiri dari beberapa instance broker yang berjalan di server yang berbeda.  Kafka dirancang untuk bekerja pada perangkat keras mandiri konvensional, di mana setiap node memiliki penyimpanan khusus sendiri.  Menggunakan Network Attached Storage (SAN) tidak dianjurkan karena beberapa node komputasi dapat bersaing untuk slot waktu penyimpanan dan menciptakan konflik. <br><br>  Kafka adalah sistem yang <i>konstan</i> .  Banyak pengguna Kafka besar tidak pernah memadamkan kelompok mereka dan perangkat lunak selalu memberikan pembaruan melalui restart yang konsisten.  Ini dicapai dengan menjamin kompatibilitas dengan versi sebelumnya untuk pesan dan interaksi antara broker. <br><br>  Broker terhubung ke <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cluster</a> server <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ZooKeeper</a> , yang bertindak sebagai registri konfigurasi yang diberikan dan digunakan untuk mengoordinasikan peran masing-masing broker.  ZooKeeper sendiri adalah sistem terdistribusi yang menyediakan ketersediaan tinggi melalui replikasi informasi dengan membentuk <i>kuorum</i> . <br><br>  Dalam kasus dasar, topik dibuat di cluster Kafka dengan properti berikut: <br><br><ul><li>  Jumlah partisi.  Seperti dibahas sebelumnya, nilai tepat yang digunakan di sini tergantung pada tingkat bacaan yang diinginkan secara bersamaan. </li><li>  Koefisien replikasi (faktor) menentukan berapa banyak instance broker dalam cluster yang harus berisi log untuk partisi ini. </li></ul><br>  Menggunakan ZooKeepers untuk koordinasi, Kafka mencoba untuk secara adil mendistribusikan partisi baru antara broker di cluster.  Ini dilakukan oleh satu instance, yang bertindak sebagai Controller. <br><br>  Dalam runtime <i>untuk setiap partisi topik,</i> <i>Pengendali</i> memberikan kepada broker peran <i>pemimpin</i> (pemimpin, master, pemimpin) dan <i>pengikut</i> (pengikut, budak, bawahan).  Pialang, bertindak sebagai pemimpin untuk partisi ini, bertanggung jawab untuk menerima semua pesan yang dikirim kepadanya oleh produsen, dan mendistribusikan pesan kepada konsumen.  Saat mengirim pesan ke partisi topik, mereka direplikasi ke semua simpul broker yang bertindak sebagai pengikut untuk partisi ini.  Setiap node yang berisi log untuk partisi disebut <i>replika</i> .  Seorang broker dapat bertindak sebagai pemimpin untuk beberapa partisi dan sebagai pengikut untuk yang lain. <br><br>  Seorang pengikut yang berisi semua pesan yang disimpan oleh pemimpin disebut <i>replika tersinkronisasi</i> (replika dalam keadaan tersinkronisasi, replika in-sync).  Jika pialang yang bertindak sebagai pemimpin untuk partisi terputus, pialang yang dalam keadaan diperbarui atau disinkronkan untuk partisi ini dapat mengambil peran sebagai pemimpin.  Ini adalah desain yang sangat berkelanjutan. <br><br>  Bagian dari konfigurasi produsen adalah parameter <i>acks</i> , yang menentukan berapa banyak replika yang harus mengakui penerimaan pesan sebelum aliran aplikasi melanjutkan pengiriman: 0, 1 atau semua.  Jika nilainya diatur ke <i>semua</i> , maka ketika pesan diterima, pemimpin akan mengirimkan konfirmasi kembali ke produser segera setelah ia menerima konfirmasi dari beberapa replika (termasuk dirinya sendiri) yang ditentukan oleh <i>pengaturan</i> topik <i>min.insync.replicas</i> (secara default 1).  Jika pesan tidak berhasil direplikasi, maka produser akan mengeluarkan pengecualian untuk aplikasi ( <i>NotEnoughReplicas</i> atau <i>NotEnoughReplicasAfterAppend</i> ). <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam konfigurasi tipikal, topik dibuat dengan koefisien replikasi 3 (1 pemimpin, 2 pengikut untuk setiap partisi) dan parameter </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">min.insync.replicas</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> diatur ke 2. Dalam kasus ini, klaster akan memungkinkan salah satu pialang yang mengelola partisi terputus tanpa mempengaruhi aplikasi klien. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini membawa kita kembali ke kompromi yang sudah lazim antara kinerja dan keandalan. Replikasi terjadi karena waktu tunggu tambahan untuk ucapan terima kasih (followers) dari pengikut. Meskipun, karena berjalan secara paralel, replikasi setidaknya tiga node memiliki kinerja yang sama dengan dua (mengabaikan peningkatan penggunaan bandwidth jaringan).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menggunakan skema replikasi ini, Kafka secara cerdik menghindari kebutuhan untuk secara fisik menulis setiap pesan ke disk menggunakan operasi </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sinkronisasi ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Setiap pesan yang dikirim oleh produser akan ditulis ke log partisi, tetapi, seperti dibahas dalam Bab 2, penulisan ke file pada awalnya dilakukan di buffer sistem operasi. Jika pesan ini direplikasi ke instance Kafka lain dan ada dalam ingatannya, kehilangan seorang pemimpin tidak berarti bahwa pesan itu sendiri hilang - replika yang disinkronkan dapat mengambilnya sendiri. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Menyisih dari </font><i><font style="vertical-align: inherit;">sinkronisasi ()</font></i><font style="vertical-align: inherit;"> operasi</font></font><i><font style="vertical-align: inherit;"></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">berarti Kafka dapat menerima pesan dengan kecepatan yang dapat ditulisnya ke memori. Sebaliknya, semakin lama Anda dapat menghindari pembilasan memori ke disk, semakin baik. Karena alasan ini, tidak jarang pialang Kafka mengalokasikan 64 GB atau lebih memori. Penggunaan memori ini berarti bahwa satu instance Kafka dapat dengan mudah bekerja pada kecepatan ribuan kali lebih cepat daripada broker pesan tradisional. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kafka juga dapat dikonfigurasi untuk menggunakan </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sinkronisasi ()</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ke paket pesan. Karena semua yang ada di Kafka berorientasi pada paket, sebenarnya berfungsi cukup baik untuk banyak kasus penggunaan dan merupakan alat yang berguna bagi pengguna yang membutuhkan jaminan yang sangat kuat. Sebagian besar kinerja murni Kafka terkait dengan pesan yang dikirim ke broker dalam bentuk paket, dan fakta bahwa pesan ini dibaca dari broker dalam blok berturut-turut menggunakan </font><font style="vertical-align: inherit;">operasi </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">zero-copy</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (operasi yang tidak melakukan tugas menyalin data dari satu area memori ke lain). Yang terakhir adalah keuntungan besar dalam hal kinerja dan sumber daya dan hanya dimungkinkan melalui penggunaan struktur data log yang mendasari yang mendefinisikan skema partisi.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dalam sebuah cluster Kafka, kinerja yang jauh lebih tinggi dimungkinkan daripada ketika menggunakan broker Kafka tunggal, karena partisi topik dapat diskalakan secara horizontal pada banyak mesin yang terpisah. </font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ringkasan </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam bab ini, kami memeriksa bagaimana arsitektur Kafka menginterpretasikan ulang hubungan antara klien dan broker untuk menyediakan jalur perpesanan yang sangat kuat, dengan throughput berkali-kali lebih besar daripada broker pesan biasa. Kami membahas fungsionalitas yang digunakannya untuk mencapai tujuan ini, dan secara singkat meninjau arsitektur aplikasi yang menyediakan fungsionalitas ini. Dalam bab berikutnya, kita akan membahas masalah umum yang perlu dipecahkan oleh aplikasi pengiriman pesan dan membahas strategi untuk menyelesaikannya. Kami menyimpulkan bab ini dengan menguraikan cara berbicara tentang teknologi pengiriman pesan secara umum sehingga Anda dapat mengevaluasi kesesuaiannya dengan kasus penggunaan Anda. </font></font><br><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Terjemahan selesai: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tele.gg/middle_java</font></font></a></b> <br><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Akan dilanjutkan ...</font></font></i> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id466585/">https://habr.com/ru/post/id466585/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id466575/index.html">Melewati daftar dua dimensi dari python ke DLL</a></li>
<li><a href="../id466577/index.html">Bagaimana dua siswa membuat game di bawah iOS dan berapa banyak yang mereka hasilkan di sana</a></li>
<li><a href="../id466579/index.html">Sejarah algoritma pengacakan Tetris</a></li>
<li><a href="../id466581/index.html">Darwinisme Kuantum: Sebuah Ide yang Menjelaskan Realitas Objektif Lulus Tes Pertama</a></li>
<li><a href="../id466583/index.html">Sejarah Singkat Detektor Kebohongan</a></li>
<li><a href="../id466587/index.html">Variabel CSS dan tema warna untuk situs dalam beberapa baris</a></li>
<li><a href="../id466589/index.html">Cara menerima data dari Google Analytics menggunakan R di Microsoft SQL Server</a></li>
<li><a href="../id466591/index.html">MVC tanpa C: Apa yang akan mengubah SwiftUI dalam arsitektur aplikasi?</a></li>
<li><a href="../id466593/index.html">Situasi: Hybrid Cloud dan Perspektif IaaS</a></li>
<li><a href="../id466597/index.html">Posisi Kedua di Mini AI Cup 4: Paper IO</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>