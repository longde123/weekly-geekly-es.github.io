<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôãüèª üßöüèº üêπ Python (+ numba) es m√°s r√°pido que C, ¬øen serio? Parte 1. Teor√≠a üçä üî∂ üëß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Durante mucho tiempo iba a escribir un art√≠culo sobre numba y sobre c√≥mo comparar su velocidad con si. Art√≠culo de Haskell " M√°s r√°pido que C ++; m√°s ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python (+ numba) es m√°s r√°pido que C, ¬øen serio? Parte 1. Teor√≠a</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484136/"><p>  Durante mucho tiempo iba a escribir un art√≠culo sobre numba y sobre c√≥mo comparar su velocidad con si.  Art√≠culo de Haskell " <a href="https://habr.com/ru/post/483864/">M√°s r√°pido que C ++;</a>  <a href="https://habr.com/ru/post/483864/">m√°s lento que PHP</a> "empuj√≥ a la acci√≥n.  En los comentarios a este art√≠culo, mencionaron la biblioteca numba y que m√°gicamente puede aproximar la velocidad de ejecuci√≥n del c√≥digo en python a la velocidad en s.  En este art√≠culo, despu√©s de una breve revisi√≥n sobre numba (parte 1), un an√°lisis un poco m√°s detallado de esta situaci√≥n ( <a href="https://habr.com/ru/post/484142/">parte 2</a> ). </p><br><p><img src="https://habrastorage.org/webt/a8/i_/ej/a8i_ejoqo5krkvtbdxo7fahp3p8.jpeg"></p><a name="habracut"></a><br><p> La principal desventaja de una pit√≥n se considera su velocidad.  Python overclocking con un √©xito variable comenz√≥ casi desde los primeros d√≠as de su existencia: <a href="https://ru.wikipedia.org/wiki/Shedskin" rel="nofollow">shedskin</a> , <a href="https://en.wikipedia.org/wiki/Psyco" rel="nofollow">psyco</a> , <a href="https://en.wikipedia.org/wiki/Psyco" rel="nofollow">unden</a> <a href="https://ru.wikipedia.org/wiki/Unladen_Swallow" rel="nofollow">shallow</a> , <a href="https://ru.wikipedia.org/wiki/Nuitka" rel="nofollow">perkeet</a> , <a href="https://pythran.readthedocs.io/en/latest/" rel="nofollow">theano</a> , <a href="https://ru.wikipedia.org/wiki/Cython" rel="nofollow">nuitka</a> , <a href="https://ru.wikipedia.org/wiki/Cython" rel="nofollow">pythran</a> , <a href="https://ru.wikipedia.org/wiki/PyPy" rel="nofollow">cython</a> , <a href="https://en.wikipedia.org/wiki/Numba" rel="nofollow">pypy</a> , <a href="https://en.wikipedia.org/wiki/Numba" rel="nofollow">numba</a> . <br><img src="https://habrastorage.org/webt/yy/4u/gr/yy4ugrto-i7axd0v6ds5cj58lmk.png"><br>  Hasta la fecha, los tres √∫ltimos son los m√°s solicitados.  <code>Cython</code> (no debe confundirse con cpython): es sem√°nticamente bastante diferente de Python normal.  De hecho, este es un lenguaje separado, un h√≠brido de C y python.  En cuanto a <code>pypy</code> (una implementaci√≥n alternativa del traductor de python usando la compilaci√≥n <code>numba</code> ) y <code>numba</code> (una biblioteca para compilar c√≥digo en llvm), fueron de diferentes maneras.  <code>pypy</code> inicialmente declar√≥ soporte para todas las construcciones de python.  En numba, procedieron del hecho de que la mayor√≠a de las veces requiere c√°lculos matem√°ticos vinculados a la CPU, respectivamente, identificaron la parte del lenguaje asociado con los c√°lculos y comenzaron a overclockearlo, aumentando gradualmente la "cobertura" (por ejemplo, hasta hace poco no hab√≠a soporte de l√≠nea , ahora ella ha aparecido).  En consecuencia, no todo el programa est√° overclockeado en <code>numba</code> , sino <em>funciones separadas</em> , esto le permite combinar alta velocidad y compatibilidad con versiones anteriores con bibliotecas que <code>numba</code> (todav√≠a) no admite.  Numpy es compatible (con restricciones menores) tanto en <code>pypy</code> como en <code>numba</code> . </p><br><p><img src="https://habrastorage.org/webt/c0/7l/_y/c07l_ygigxdy7wsfwnyn_nfm2v4.png" width="30%" align="right">  Mi conocimiento de Numba comenz√≥ en 2015 con esta pregunta sobre stackoverflow sobre la velocidad de la multiplicaci√≥n de matrices en python: <a href="https://stackoverflow.com/questions/27809511/efficient-outer-product-in-python" rel="nofollow">producto externo eficiente en python</a> </p><br><p>  Desde entonces, se han producido muchos eventos en cada una de las bibliotecas, pero la imagen con respecto a <code>numba</code> / <code>cython</code> / <code>pypy</code> no <code>pypy</code> cambiado <code>numba</code> : <code>numba</code> supera a <code>cython</code> mediante el uso de instrucciones de procesador nativas ( <code>cython</code> no puede <code>cython</code> ) y <code>pypy</code> debido a una ejecuci√≥n m√°s eficiente del c√≥digo de bytes llvm . </p><br><p>  Numba es √∫til para m√≠ en el trabajo (procesamiento de im√°genes hiperespectrales) y en la ense√±anza (integraci√≥n num√©rica, resoluci√≥n de ecuaciones diferenciales). </p><br><h4 id="kak-ustanovit">  como configurar </h4><br><p>  Hace un par de a√±os hubo problemas con la instalaci√≥n, ahora todo se resolvi√≥: se instala igualmente bien a trav√©s de <code>pip install numba</code> y <code>conda install numba</code> .  llvm se aprieta e instala autom√°ticamente. </p><br><h4 id="kak-uskoryat">  como acelerar </h4><br><p>  Para acelerar una funci√≥n, debe ingresar al decorador njit antes de definirla: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numba <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> njit @njit <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n)</span></span></span><span class="hljs-function">:</span></span> s = <span class="hljs-number"><span class="hljs-number">0.</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(n): s += sqrt(i) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s</code> </pre> <br><p>  Aceleraci√≥n de <strong>40</strong> veces. </p><br><p>  La ra√≠z es necesaria, porque de lo contrario numba reconocer√° la suma de la progresi√≥n aritm√©tica (!) Y la calcular√° en tiempo constante. </p><br><h4 id="jit-vs-njit">  jit vs njit </h4><br><p>  Anteriormente, solo el modo <code>@jit</code> (no <code>@njit</code> ) era relevante.  El punto es que en este modo puede usar operaciones no compatibles con numba: la numba a alta velocidad alcanza la primera operaci√≥n, luego se ralentiza y hasta el final de la ejecuci√≥n de la funci√≥n contin√∫a a la velocidad habitual de Python, incluso si no se encuentra nada m√°s "prohibido" en la funci√≥n ( el llamado modo de objeto), que obviamente es irracional.  Ahora <code>@jit</code> abandonando gradualmente <code>@jit</code> , siempre se recomienda usar @njit (o en forma completa <code>@jit(nopython=True)</code> ): en este modo, la numba jura con excepciones en esos lugares; es mejor reescribirlos para no perder velocidad. </p><br><h4>  que puede acelerar </h4><br><p>  En las funciones overclockeadas, solo se puede usar parte de la funcionalidad de python y numba.  Todos los operadores, funciones y clases se dividen en dos partes con respecto a la numba: las que la numba "entiende" y las que "no entiende". </p><br><p>  Hay dos listas de este tipo en la documentaci√≥n de numba (con ejemplos): </p><br><ul><li>  Un subconjunto de la funcionalidad de <a href="https://numba.pydata.org/numba-doc/dev/reference/pysupported.html" rel="nofollow">Python</a> familiar para adormecer y </li><li>  Un subconjunto del <a href="https://numba.pydata.org/numba-doc/dev/reference/numpysupported.html" rel="nofollow">numpy</a> funcional familiar para adormecer. </li></ul><br><p>  De lo notable en estas listas: </p><br><ul><li>  numba "entiende" las listas de Python con adiciones r√°pidas (O (1)) al final que numpy "no entiende" (aunque solo las homog√©neas de elementos del mismo tipo), </li><li>  Las matrices de Numpy que no est√°n en la base de Python.  Comprende tambi√©n </li><li>  tuplas: pueden, como una pit√≥n normal, contener elementos de diferentes tipos. </li><li>  diccionarios: numba tiene su propia implementaci√≥n de un diccionario escrito.  Todas las claves deben ser del mismo tipo, exactamente como los valores.  Python dict no se puede pasar a numba, pero numba <code>numba.typed.Dict</code> se puede crear en python y transferir a / desde numba (mientras que en python funciona un poco m√°s lento que python). </li><li>  recientemente str y bytes, sin embargo, solo como par√°metros de entrada no se pueden crear (¬øtodav√≠a?). </li></ul><br><p>  Ella no entiende ninguna otra biblioteca (en particular, scipy y pandas) en absoluto. </p><br><p>  Pero incluso ese subconjunto del lenguaje que entiende es suficiente para overclockear la mayor parte del c√≥digo para aplicaciones cient√≠ficas en las que la numba se centra principalmente. </p><br><h4>  importante! </h4><br><p>  De las funciones overclockeadas, solo se pueden llamar overclockeadas, no overclockeadas. <br>  (aunque las funciones overclockeadas pueden llamarse desde overclockeadas y no overclockeadas). </p><br><h4>  globales </h4><br><p>  En las funciones overclockeadas, las variables globales se convierten en constantes: su valor se fija en el momento en que se compila la funci√≥n ( <a href="https://python-nsu.bitbucket.io/numba/globals.html" rel="nofollow">ejemplo</a> ).  =&gt; No utilice variables globales en funciones overclockeadas (excepto para constantes). </p><br><h4>  firmas </h4><br><p>  En el n√∫mero de cada funci√≥n, se asignan uno o varios tipos de argumentos de entrada y salida, es decir  firmas  Cuando se llama por primera vez a la funci√≥n, se genera la firma y el c√≥digo de funci√≥n binario correspondiente se compila autom√°ticamente.  Cuando se inicia con otros tipos de argumentos, se crear√°n nuevas firmas y nuevos binarios (se conservan los antiguos).  Por lo tanto, se produce la "salida al modo" en t√©rminos de velocidad de ejecuci√≥n para cada firma, comenzando desde la segunda ejecuci√≥n con este tipo de argumentos.  Entonces tampoco </p><br><ul><li>  "Calentar el cach√©" iniciando con peque√±os tama√±os de matrices de entrada, o </li><li>  especifique el argumento <code>@jit(cache=True)</code> para guardar el c√≥digo compilado en el disco con su carga autom√°tica durante los siguientes lanzamientos de programas (aunque en la pr√°ctica hoy en d√≠a este primer lanzamiento sigue siendo un poco m√°s lento que los posteriores, pero m√°s r√°pido que sin <code>cache=True</code> ) . </li></ul><br><p>  Hay una tercera v√≠a.  Las firmas se pueden configurar manualmente: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numba <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> int16, int32 @njit(int32(int16, int16)) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y &gt;&gt;&gt; f.signatures [(int16, int16)]</code> </pre> <br><p>  Cuando ejecuta una funci√≥n con la firma especificada en el decorador, la primera ejecuci√≥n ser√° r√°pida: la compilaci√≥n se producir√° en el momento en que Python vea la definici√≥n de la funci√≥n, y no en el primer inicio.  Puede haber varias firmas, el orden de su secuencia es importante. </p><br><p>  Advertencia: este √∫ltimo m√©todo no es seguro para el futuro.  Los autores de numba advierten que la sintaxis para especificar tipos puede cambiar en el futuro, <code>@jit</code> / <code>@njit</code> sin firmas es una opci√≥n m√°s segura a este respecto. </p><br><p>  <code>f.signatures</code> comienzan a mostrar firmas solo cuando el pit√≥n se entera de ellas, es decir, despu√©s de la primera llamada a la funci√≥n, o si se configuran manualmente. </p><br><p>  Adem√°s de <code>f.signatures</code> firmas se pueden ver a trav√©s de <code>f.inspect_types()</code> ; adem√°s de los tipos de par√°metros de entrada, esta funci√≥n mostrar√° los tipos de par√°metros de salida y los tipos de todas las variables locales. </p><br><p>  Adem√°s de los tipos de par√°metros de entrada y salida, es posible especificar manualmente los tipos de variables locales: </p><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">from</span></span> numba <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> int16, int32 @njit(int32(int16, int16), locals={<span class="hljs-string"><span class="hljs-string">'z'</span></span>: int32}) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">f</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(x, y)</span></span></span><span class="hljs-function">:</span></span> z = y + <span class="hljs-number"><span class="hljs-number">10</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + z</code> </pre> <br><h4 id="int">  int </h4><br><p>  En numba, los enteros no tienen aritm√©tica larga como en python "simple", pero hay tipos est√°ndar de varios anchos desde <code>int8</code> hasta <code>int64</code> ( <a href="https://numba.pydata.org/numba-doc/0.12.2/tutorial_types.html" rel="nofollow">tabla de tipos</a> en la documentaci√≥n).  Tambi√©n hay tipos <code>int_</code> (as√≠ como <code>float_</code> ), que le dan a la numba la oportunidad de elegir el ancho de campo √≥ptimo (desde su punto de vista). </p><br><h4 id="klassy">  clases </h4><br><p>  Generalmente hay soporte para las clases (@jitclass), pero hasta ahora es experimental, por lo que es mejor evitar usarlas por el momento (en este momento, en mi experiencia, es mucho m√°s lento con ellas que sin ellas). </p><br><h4 id="custom-dtypes">  tipos personalizados </h4><br><p>  Numba admite una cierta alternativa a las clases de matrices estructuradas numpy o, en otras palabras, tipos de letra personalizados.  Funcionan a la misma velocidad que las matrices numpy regulares, son un poco m√°s convenientes para indexar (por ejemplo, <code>a['y2']</code> m√°s legible que <code>a[3]</code> ).  Curiosamente, en numba, a diferencia de numpy, se permite un a.y2 m√°s conciso junto con la sintaxis habitual <code>a['y2']</code> .  Pero en general, su apoyo en numba deja mucho que desear, y algunas operaciones, incluso obvias en numpy, con ellos en numba se registran de manera bastante trivial. </p><br><h4 id="gpu">  GPU </h4><br><p>  Es capaz de ejecutar c√≥digo overclockeado en la GPU, y en contraste con el mismo, por ejemplo, pycuda o pytorch, no solo en nvidia, sino tambi√©n en tarjetas amd'shnyh.  Con esto, hasta ahora se ha tratado poco.  Aqu√≠ hay un art√≠culo sobre la <a href="https://habr.com/ru/post/317328/">comparaci√≥n de</a> Habre 2016 <a href="https://habr.com/ru/post/317328/">del rendimiento de los c√°lculos de GPU en Python y C.</a>  All√≠, se obtuvo una velocidad comparable a la de C. </p><br><h4 id="ahead-of-time-kompilyaciya">  compilaci√≥n anticipada </h4><br><p>  Hay un modo de compilaci√≥n normal (es decir, no jit) ( <a href="https://numba.pydata.org/numba-doc/dev/user/pycc.html" rel="nofollow">documentaci√≥n</a> ) en la numba, pero este modo no es el principal, no lo entend√≠. </p><br><h4 id="avtomaticheskoe-rasparallelivanie">  paralelizaci√≥n autom√°tica </h4><br><p>  Algunas tareas (por ejemplo, multiplicar una matriz por un n√∫mero) est√°n paralelas de forma natural.  Pero hay tareas cuya implementaci√≥n no puede ser paralela.  Con el decorador <code>@njit(parallel=True)</code> numba analiza el c√≥digo de la funci√≥n overclockeada, encuentra esas secciones, cada una de las cuales no puede ser paralelizada por s√≠ misma, y ‚Äã‚Äãlas ejecuta simult√°neamente en diferentes n√∫cleos de CPU ( <a href="https://numba.pydata.org/numba-doc/dev/user/parallel.html" rel="nofollow">documentaci√≥n</a> ).  Anteriormente, solo pod√≠a paralelizar funciones manualmente usando <code>@vectorize</code> ( <a href="https://numba.pydata.org/numba-doc/dev/reference/jit-compilation.html" rel="nofollow">documentaci√≥n</a> ), que requer√≠a cambios de c√≥digo. </p><br><p>  En la pr√°ctica, se ve as√≠: agregue <code>parallel=True</code> , mida la velocidad, si tenemos suerte y result√≥ m√°s r√°pido, lo dejamos, m√°s lento, lo eliminamos.  (** Actualizaci√≥n Como se se√±al√≥ en el <a href="https://habr.com/ru/post/484142/">comentario</a> a la segunda parte del art√≠culo, esta bandera tiene muchos errores abiertos) </p><br><h4 id="osvobozhdenie-gil">  Lanzamiento de GIL </h4><br><p>  Las funciones decoradas con <code>@jit(nogil=True)</code> y que se ejecutan en diferentes hilos se pueden ejecutar en paralelo.  Para evitar condiciones de carrera, debe usar la sincronizaci√≥n de subprocesos. </p><br><h4 id="dokumentaciya">  la documentaci√≥n </h4><br><p>  Numbe a√∫n carece de documentaci√≥n sensata.  Ella es, pero no todo est√° en ella. </p><br><h4 id="optimizaciya">  optimizaci√≥n </h4><br><p>  Hay algo de imprevisibilidad al optimizar el c√≥digo manualmente: el c√≥digo no pit√≥nico a menudo se ejecuta m√°s r√°pido que el pit√≥nico. </p><br><p>  Para aquellos interesados ‚Äã‚Äãen el tema, puedo recomendar un <a href="https://www.youtube.com/watch%3Fv%3D1AwG0T4gaO0" rel="nofollow">video de una</a> clase magistral de numba de la conferencia scipy 2017 (hay <a href="https://github.com/gforsyth/numba_tutorial_scipy2017" rel="nofollow">c√≥digos fuente</a> en el github).  Es realmente largo y parcialmente desactualizado (por ejemplo, las l√≠neas ya son compatibles), pero ayuda a tener una idea general: hay, en particular, acerca de pythonic / unpythonic, jit (paralelo = True), etc. </p><br><p>  En la <a href="https://habr.com/ru/post/484142/">segunda</a> parte, consideraremos el uso de numba usando el c√≥digo del art√≠culo mencionado al principio del art√≠culo. </p></div></div><p>Source: <a href="https://habr.com/ru/post/484136/">https://habr.com/ru/post/484136/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../484114/index.html">Una selecci√≥n de 143 traducciones del ensayo de Paul Graham (de 184)</a></li>
<li><a href="../484118/index.html">32 de enero</a></li>
<li><a href="../484120/index.html">Las habilidades m√°s buscadas en la profesi√≥n de ingeniero de datos</a></li>
<li><a href="../484124/index.html">Nikolai Prokhorov: "En Finlandia hab√≠a un gran departamento de Vneshtorg, que suministraba nuestros autom√≥viles a pa√≠ses extranjeros"</a></li>
<li><a href="../484130/index.html">Microservicios con Spring Boot. Parte 1. Comenzando</a></li>
<li><a href="../484142/index.html">Python (+ numba) es m√°s r√°pido que C, ¬øen serio? Parte 2. Practica</a></li>
<li><a href="../484146/index.html">Los enga√±os en Internet no desaparecer√°n, ¬øqu√© debemos hacer?</a></li>
<li><a href="../484148/index.html">SVM Explicaci√≥n desde cero e implementaci√≥n en python. An√°lisis detallado del m√©todo del vector de soporte.</a></li>
<li><a href="../484150/index.html">5 nuevas herramientas para crear contenido divertido</a></li>
<li><a href="../484152/index.html">Controlador PAC de alta velocidad WISE-5580</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>