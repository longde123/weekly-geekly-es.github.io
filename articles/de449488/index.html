<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîû üë©‚Äçüç≥ üõê Cataclysm Dark Days Ahead: Statische Analyse und Roguelike-Spiele üíÜüèæ üë¶üèº üê´</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sie m√ºssen bereits aus dem Titel erraten haben, dass sich der heutige Artikel auf Fehler im Software-Quellcode konzentrieren wird. Aber nicht nur das....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cataclysm Dark Days Ahead: Statische Analyse und Roguelike-Spiele</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/449488/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f8/70b/ef1/2f870bef158597577eac654a524b00ac.png" alt="Bild 5"></div><br>  Sie m√ºssen bereits aus dem Titel erraten haben, dass sich der heutige Artikel auf Fehler im Software-Quellcode konzentrieren wird.  Aber nicht nur das.  Wenn Sie nicht nur an C ++ interessiert sind und √ºber Fehler im Code anderer Entwickler lesen m√∂chten, sondern auch ungew√∂hnliche Videospiele ausgraben und sich fragen, was "Roguelikes" sind und wie Sie sie spielen, dann lesen Sie weiter! <br><a name="habracut"></a><br>  Auf der Suche nach ungew√∂hnlichen Spielen bin ich auf <i>Cataclysm Dark Days Ahead</i> gesto√üen, das sich unter anderem durch seine Grafiken auszeichnet, die auf ASCII-Zeichen in verschiedenen Farben basieren, die auf dem schwarzen Hintergrund angeordnet sind. <br><br>  Eine Sache, die Sie an diesem und anderen √§hnlichen Spielen √ºberrascht, ist, wie viel Funktionalit√§t in sie eingebaut ist.  Insbesondere in <i>Cataclysm</i> k√∂nnen Sie beispielsweise nicht einmal einen Charakter erstellen, ohne den Drang zu versp√ºren, einige Anleitungen zu googeln, da Dutzende von Parametern, Merkmalen und Anfangsszenarien verf√ºgbar sind, ganz zu schweigen von den zahlreichen Variationen von Ereignissen, die w√§hrend des Spiels auftreten. <br><br>  Da es sich um ein Spiel mit Open-Source-Code handelt, das in C ++ geschrieben wurde, konnten wir nicht vorbeigehen, ohne es mit unserem statischen Code-Analysator PVS-Studio zu √ºberpr√ºfen, an dessen Entwicklung ich aktiv teilnehme.  Der Code des Projekts ist √ºberraschend hochwertig, weist jedoch noch einige kleinere M√§ngel auf, von denen ich in diesem Artikel auf einige eingehen werde. <br><br>  Viele Spiele wurden bereits mit PVS-Studio √ºberpr√ºft.  Einige Beispiele finden Sie in unserem Artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Statische Analyse in der Videospielentwicklung: Top 10 Softwarefehler</a> ". <br><br><h2>  Logik </h2><br>  <b>Beispiel 1:</b> <br><br>  Dieses Beispiel zeigt einen klassischen Fehler beim Kopieren und Einf√ºgen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V501</a> Links und rechts vom '||' befinden sich identische Unterausdr√ºcke.  Operator: rng (2, 7) &lt;abs (z) ||  rng (2, 7) &lt;abs (z) overmap.cpp 1503 <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> overmap::generate_sub( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z ) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( rng( <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span> ) &lt; <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>( z ) || rng( <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span> ) &lt; <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>( z ) ) { .... } .... }</code> </pre> <br>  Der gleiche Zustand wird zweimal √ºberpr√ºft.  Der Programmierer hat den Ausdruck kopiert, aber vergessen, die Kopie zu √§ndern.  Ich bin nicht sicher, ob dies ein kritischer Fehler ist, aber Tatsache ist, dass die √úberpr√ºfung nicht so funktioniert, wie es beabsichtigt war. <br><br>  Ein weiterer √§hnlicher Fehler: <br><br><ul><li>  V501 Links und rechts vom Operator '&amp;&amp;' befinden sich identische Unterausdr√ºcke 'one_in (100000 / to_turns &lt;int&gt; (dur))'.  player_hardcoded_effects.cpp 547 </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d92/a93/7ac/d92a937ac860e5f2fb5ded04b8e05683.png" alt="Bild 11"></div><br>  <b>Beispiel 2:</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V728</a> Eine √ºberm√§√üige √úberpr√ºfung kann vereinfacht werden.  Die '(A &amp;&amp; B) ||  (! A &amp;&amp;! B) 'Ausdruck entspricht dem Ausdruck' bool (A) == bool (B) '.  inventar_ui.cpp 199 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> inventory_selector_preset::sort_compare( .... ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> left_fav = g-&gt;u.inv.assigned.count( lhs.location-&gt;invlet ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> right_fav = g-&gt;u.inv.assigned.count( rhs.location-&gt;invlet ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ( left_fav &amp;&amp; right_fav ) || ( !left_fav &amp;&amp; !right_fav ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> .... } .... }</code> </pre> <br>  Dieser Zustand ist logisch korrekt, aber zu kompliziert.  Wer diesen Code geschrieben hat, sollte Mitleid mit seinen Programmierkollegen haben, die ihn pflegen werden.  Es k√∂nnte in einer einfacheren Form umgeschrieben werden: <i>if (left_fav == right_fav)</i> . <br><br>  Ein weiterer √§hnlicher Fehler: <br><br><ul><li>  V728 Eine √ºberm√§√üige √úberpr√ºfung kann vereinfacht werden.  Das '(A &amp;&amp;! B) ||  (! A &amp;&amp; B) 'Ausdruck entspricht dem Ausdruck' bool (A)! = Bool (B) '.  iuse_actor.cpp 2653 </li></ul><br><h2>  Exkurs i </h2><br>  Ich war √ºberrascht zu entdecken, dass Spiele, die heute unter dem Namen "Roguelikes" bekannt sind, nur moderatere Vertreter des alten Genres der Roguelike-Spiele sind.  Alles begann mit dem Kult-Spiel <i>Rogue</i> von 1980, das viele Studenten und Programmierer dazu inspirierte, ihre eigenen Spiele mit √§hnlichen Elementen zu entwickeln.  Ich denke, viel Einfluss kam auch von der Community des Tabletop-Spiels <i>DnD</i> und seinen Variationen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4dc/d85/de3/4dcd85de3509609962cab730653f7ed1.png" alt="Bild 8"></div><br><h2>  Mikrooptimierungen </h2><br>  <b>Beispiel 3:</b> <br><br>  Warnungen dieser Gruppe weisen auf Stellen hin, die m√∂glicherweise optimiert werden k√∂nnten, anstatt auf Fehler. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V801</a> Leistungsminderung.  Es ist besser, das zweite Funktionsargument als Referenz neu zu definieren.  Ersetzen Sie 'const ... type' durch 'const ... &amp; type'.  map.cpp 4644 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Stack&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;item&gt; use_amount_stack( Stack <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> itype_id type ) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;item&gt; ret; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.begin(); a != <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.end() &amp;&amp; quantity &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a-&gt;use_amount( type, ret ) ) { a = <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.erase( a ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++a; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br>  In diesem Code ist <i>itype_id</i> tats√§chlich ein getarnter <i>std :: string</i> .  Da das Argument ohnehin als Konstante √ºbergeben wird, was bedeutet, dass es unver√§nderlich ist, w√ºrde die einfache √úbergabe eines Verweises auf die Variable dazu beitragen, die Leistung zu verbessern und Rechenressourcen zu sparen, indem der Kopiervorgang vermieden wird.  Und obwohl es unwahrscheinlich ist, dass die Zeichenfolge lang ist, ist es eine schlechte Idee, sie jedes Mal ohne guten Grund zu kopieren - zumal diese Funktion von verschiedenen Aufrufern aufgerufen wird, die wiederum auch von au√üen typisiert werden und haben um es zu kopieren. <br><br>  √Ñhnliche Probleme: <br><br><ul><li>  V801 Leistungsminderung.  Es ist besser, das dritte Funktionsargument als Referenz neu zu definieren.  Ersetzen Sie 'const ... evt_filter' durch 'const ... &amp; evt_filter'.  input.cpp 691 </li><li>  V801 Leistungsminderung.  Es ist besser, das f√ºnfte Funktionsargument als Referenz neu zu definieren.  Ersetzen Sie 'const ... color' durch 'const ... &amp; color'.  output.h 207 </li><li>  Der Analysator gab insgesamt 32 Warnungen dieses Typs aus. </li></ul><br>  <b>Beispiel 4:</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V813</a> Leistungsminderung.  Das Argument 'str' sollte wahrscheinlich als konstante Referenz wiedergegeben werden.  catacharset.cpp 256 <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base64_encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> str )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( str.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; str[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'#'</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> input_length = str.length(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encoded_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( output_length, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'\0'</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, j = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; input_length; ) { .... } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; mod_table[input_length % <span class="hljs-number"><span class="hljs-number">3</span></span>]; i++ ) { encoded_data[output_length - <span class="hljs-number"><span class="hljs-number">1</span></span> - i] = <span class="hljs-string"><span class="hljs-string">'='</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"#"</span></span> + encoded_data; }</code> </pre> <br>  Obwohl das Argument nicht konstant ist, √§ndert es sich in keiner Weise im Funktionsk√∂rper.  Aus Gr√ºnden der Optimierung w√§re es daher eine bessere L√∂sung, diese als konstante Referenz zu √ºbergeben, anstatt den Compiler zu zwingen, lokale Kopien zu erstellen. <br><br>  Diese Warnung kam auch nicht alleine;  Die Gesamtzahl der Warnungen dieses Typs betr√§gt 26. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ff/557/9b3/4ff5579b36733a7bd46f4c3df6f30d90.png" alt="Bild 7"></div><br>  √Ñhnliche Probleme: <br><br><ul><li>  V813 Leistungsminderung.  Das Argument 'message' sollte wahrscheinlich als konstante Referenz gerendert werden.  json.cpp 1452 </li><li>  V813 Leistungsminderung.  Das Argument 's' sollte wahrscheinlich als konstante Referenz wiedergegeben werden.  catacharset.cpp 218 </li><li>  Und so weiter ... </li></ul><br><h2>  Exkurs ii </h2><br>  Einige der klassischen Roguelike-Spiele befinden sich noch in der aktiven Entwicklung.  Wenn Sie die GitHub-Repositorys von <i>Cataclysm DDA</i> oder <i>NetHack</i> √ºberpr√ºfen, werden Sie <i>feststellen</i> , dass √Ñnderungen jeden Tag √ºbermittelt werden.  <i>NetHack</i> ist tats√§chlich das √§lteste Spiel, das noch entwickelt wird: Es wurde im Juli 1987 ver√∂ffentlicht und die letzte Version stammt aus dem Jahr 2018. <br><br>  <i>Dwarf Fortress</i> ist eines der beliebtesten - wenn auch j√ºngeren - Spiele des Genres.  Die Entwicklung begann im Jahr 2002 und die erste Version wurde im Jahr 2006 ver√∂ffentlicht. Das Motto "Verlieren macht Spa√ü" spiegelt die Tatsache wider, dass es unm√∂glich ist, in diesem Spiel zu gewinnen.  Im Jahr 2007 wurde die <i>Zwergenfestung</i> durch eine j√§hrliche Abstimmung auf der ASCII GAMES-Website als "Bestes Roguelike-Spiel des Jahres" ausgezeichnet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e39/7fb/efa/e397fbefa4204777cc74d97e2b8e52e9.png" alt="Bild 6"></div><br>  √úbrigens k√∂nnten Fans froh sein zu wissen, dass <i>Dwarf Fortress</i> mit verbesserten 32-Bit-Grafiken, die von zwei erfahrenen Moddern hinzugef√ºgt wurden, zu Steam kommt.  Die Premium-Version erh√§lt au√üerdem zus√§tzliche Musiktitel und Steam Workshop-Unterst√ºtzung.  Besitzer von kostenpflichtigen Kopien k√∂nnen auf Wunsch zu den alten ASCII-Grafiken wechseln.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mehr</a> <br><br><h2>  √úberschreiben des Zuweisungsoperators </h2><br>  <b>Beispiele 5, 6:</b> <br><br>  Hier sind einige interessante Warnungen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V690</a> Die Klasse 'JsonObject' implementiert einen Kopierkonstruktor, es fehlt jedoch der Operator '='.  Es ist gef√§hrlich, eine solche Klasse zu benutzen.  json.h 647 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonObject</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: .... JsonIn *jsin; .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: JsonObject( JsonIn &amp;jsin ); JsonObject( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> JsonObject &amp;jsobj ); JsonObject() : positions(), start( <span class="hljs-number"><span class="hljs-number">0</span></span> ), end( <span class="hljs-number"><span class="hljs-number">0</span></span> ), jsin( <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) {} ~JsonObject() { finish(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finish</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// moves the stream to the end of the object .... void JsonObject::finish() { .... } .... }</span></span></code> </pre> <br>  Diese Klasse verf√ºgt √ºber einen Kopierkonstruktor und einen Destruktor, √ºberschreibt jedoch den Zuweisungsoperator nicht.  Das Problem ist, dass ein automatisch generierter Zuweisungsoperator den Zeiger nur <i>JsonIn</i> zuweisen kann.  Infolgedessen w√ºrden beide Objekte der Klasse <i>JsonObject</i> auf dasselbe <i>JsonIn verweisen</i> .  Ich kann nicht sicher sagen, ob eine solche Situation in der aktuellen Version auftreten k√∂nnte, aber eines Tages wird sicherlich jemand in diese Falle tappen. <br><br>  Die n√§chste Klasse hat ein √§hnliches Problem. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V690</a> Die Klasse 'JsonArray' implementiert einen Kopierkonstruktor, es fehlt jedoch der Operator '='.  Es ist gef√§hrlich, eine solche Klasse zu benutzen.  json.h 820 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonArray</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: .... JsonIn *jsin; .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: JsonArray( JsonIn &amp;jsin ); JsonArray( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> JsonArray &amp;jsarr ); JsonArray() : positions(), ...., jsin( <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) {}; ~JsonArray() { finish(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finish</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// move the stream position to the end of the array void JsonArray::finish() { .... } }</span></span></code> </pre> <br>  Die Gefahr, den Zuweisungsoperator in einer komplexen Klasse nicht zu √ºberschreiben, wird im Artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Gesetz der gro√üen Zwei</a> " ausf√ºhrlich erl√§utert. <br><br>  <b>Beispiele 7, 8:</b> <br><br>  Diese beiden befassen sich auch mit dem √úberschreiben von Zuweisungsoperatoren, diesmal jedoch mit spezifischen Implementierungen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V794</a> Der Zuweisungsoperator sollte vor dem Fall 'this == &amp; other' gesch√ºtzt werden.  mattack_common.h 49 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringRef</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringRefTestAccess</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* m_start; size_type m_size; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* m_data = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = ( StringRef <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;other ) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> -&gt; StringRef&amp; { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[] m_data; m_data = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; m_start = other.m_start; m_size = other.m_size; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre><br>  Diese Implementierung bietet keinen Schutz vor einer m√∂glichen Selbstzuweisung, was eine unsichere Praxis ist.  Das hei√üt, das √úbergeben eines <i>* dieser</i> Referenz an diesen Operator kann zu einem Speicherverlust f√ºhren. <br><br>  Hier ist ein √§hnliches Beispiel f√ºr einen nicht ordnungsgem√§√ü √ºberschriebenen Zuweisungsoperator mit einer besonderen Nebenwirkung: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V794</a> Der Zuweisungsoperator sollte vor dem Fall 'this == &amp; rhs' gesch√ºtzt werden.  player_activity.cpp 38 <br><br><pre> <code class="cpp hljs">player_activity &amp;player_activity::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> player_activity &amp;rhs ) { type = rhs.type; .... targets.clear(); targets.reserve( rhs.targets.size() ); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::transform( rhs.targets.begin(), rhs.targets.end(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::back_inserter( targets ), []( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> item_location &amp; e ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.clone(); } ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre><br>  Dieser Code hat auch keine Pr√ºfung gegen Selbstzuweisung und zus√§tzlich einen zu f√ºllenden Vektor.  Bei dieser Implementierung des Zuweisungsoperators f√ºhrt das Zuweisen eines Objekts zu sich selbst zu einer Verdoppelung des Vektors im <i>Zielfeld</i> , wobei einige der Elemente besch√§digt werden.  Der <i>Transformation</i> geht jedoch <i>clear</i> voraus, wodurch der Vektor des Objekts gel√∂scht wird, was zu Datenverlust f√ºhrt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/618/b4e/dd8/618b4edd868317d8e9e6a0e5d82cb5d0.png" alt="Bild 3"></div><br><h2>  Exkurs iii </h2><br>  Im Jahr 2008 erhielten Roguelikes sogar eine formale Definition, die unter dem epischen Titel "Berlin Interpretation" bekannt ist.  Demnach teilen alle diese Spiele die folgenden Elemente: <br><br><ul><li>  Zuf√§llig erzeugte Welt, die die Wiederspielbarkeit erh√∂ht; </li><li>  Permadeath: Wenn dein Charakter stirbt, stirbt er f√ºr immer und alle seine Gegenst√§nde gehen verloren. </li><li>  Rundenbasiertes Gameplay: √Ñnderungen treten nur zusammen mit den Aktionen des Spielers auf.  Der Zeitfluss wird unterbrochen, bis der Spieler eine Aktion ausf√ºhrt. </li><li>  √úberleben: Ressourcen sind knapp. </li></ul><br>  Schlie√ülich ist das wichtigste Merkmal von Roguelikes, sich haupts√§chlich darauf zu konzentrieren, die Welt zu erkunden, neue Verwendungsm√∂glichkeiten f√ºr Gegenst√§nde zu finden und Dungeons zu kriechen. <br><br>  In <i>Cataclysm DDA</i> ist es eine h√§ufige Situation, dass Ihr Charakter bis auf die Knochen gefroren, hungrig und durstig ist und, um das Ganze abzurunden, seine beiden Beine durch sechs Tentakel ersetzt wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fe/f8e/b69/8fef8eb69a48050011726fe47ec1da35.png" alt="Bild 15"></div><br><h2>  Details, die wichtig sind </h2><br>  <b>Beispiel 9:</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V1028</a> M√∂glicher √úberlauf.  Ziehen Sie in Betracht, Operanden des Operators 'start + large' in den Typ 'size_t' umzuwandeln, nicht in das Ergebnis.  worldfactory.cpp 638 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> worldfactory::draw_mod_list( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &amp;start, .... ) { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> larger = ....; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iNum = ....; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( .... ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( iNum &gt;= <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;( start ) &amp;&amp; iNum &lt; <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;( start + larger ) ) { .... } .... } .... }</code> </pre> <br>  Es sieht so aus, als wollte der Programmierer Vorsichtsma√ünahmen gegen einen √úberlauf treffen.  Das Heraufstufen des Summentyps macht jedoch keinen Unterschied, da der √úberlauf vorher beim Hinzuf√ºgen der Werte auftritt und das Heraufstufen √ºber einen bedeutungslosen Wert erfolgt.  Um dies zu vermeiden, sollte nur eines der Argumente in einen breiteren Typ umgewandelt werden: <i>(static_cast &lt;size_t&gt; (start) + gr√∂√üer)</i> . <br><br>  <b>Beispiel 10:</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V530</a> Der R√ºckgabewert der Funktion 'Gr√∂√üe' muss verwendet werden.  worldfactory.cpp 1340 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> worldfactory::world_need_lua_build( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> world_name ) { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> LUA .... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Prevent unused var error when LUA and RELEASE enabled. world_name.size(); return false; }</span></span></span></span></code> </pre> <br>  F√ºr solche F√§lle gibt es einen Trick.  Wenn Sie am Ende eine nicht verwendete Variable haben und die Compiler-Warnung unterdr√ºcken m√∂chten, schreiben Sie einfach <i>(void) world_name,</i> anstatt Methoden f√ºr diese Variable aufzurufen. <br><br>  <b>Beispiel 11:</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V812</a> Leistungsminderung.  Ineffektive Verwendung der Z√§hlfunktion.  Es kann m√∂glicherweise durch den Aufruf der Funktion 'find' ersetzt werden.  player.cpp 9600 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> player::read( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> inventory_position, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> continuous ) { .... player_activity activity; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !continuous || !<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::all_of( learners.begin(), learners.end(), [&amp;]( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;npc *, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; elem ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::count( activity.values.begin(), activity.values.end(), elem.first-&gt;getID() ) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } ) { .... } .... }</code> </pre> <br>  Die Tatsache, dass <i>count</i> mit null verglichen wird, legt nahe, dass der Programmierer herausfinden wollte, ob die <i>Aktivit√§t</i> mindestens ein erforderliches Element enth√§lt.  Die <i>Z√§hlung</i> muss jedoch durch den gesamten Container laufen, da alle Vorkommen des Elements gez√§hlt werden.  Die Arbeit k√∂nnte schneller erledigt werden, indem <i>find verwendet wird</i> , das stoppt, sobald das erste Vorkommen gefunden wurde. <br><br>  <b>Beispiel 12:</b> <br><br>  Dieser Fehler ist leicht zu finden, wenn Sie ein schwieriges Detail √ºber den <i>Zeichentyp kennen</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V739</a> EOF sollte nicht mit einem Wert vom Typ 'char' verglichen werden.  Das 'ch' sollte vom Typ 'int' sein.  json.cpp 762 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> JsonIn::skip_separator() { <span class="hljs-keyword"><span class="hljs-keyword">signed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ch == <span class="hljs-string"><span class="hljs-string">','</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ate_separator ) { .... } .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ch == EOF) { .... }</code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/76e/830/467/76e830467157aab1aad9e710c195b03d.png" alt="Bild 13"></div><br>  Dies ist einer der Fehler, die Sie nur dann leicht erkennen k√∂nnen, wenn Sie wissen, dass <i>EOF</i> als -1 definiert ist.  Wenn Sie es mit einer Variablen vom Typ <i>char</i> mit Vorzeichen vergleichen, wird die Bedingung daher in fast allen F√§llen als <i>falsch</i> ausgewertet.  Die einzige Ausnahme ist das Zeichen, dessen Code 0xFF (255) ist.  Bei Verwendung in einem Vergleich wird -1 angezeigt, wodurch die Bedingung erf√ºllt wird. <br><br>  <b>Beispiel 13:</b> <br><br>  Dieser kleine Fehler kann eines Tages kritisch werden.  Es gibt schlie√ülich gute Gr√ºnde daf√ºr, dass es auf der CWE-Liste als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CWE-834 steht</a> .  Beachten Sie, dass das Projekt diese Warnung f√ºnfmal ausgel√∂st hat. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V663</a> Endlosschleife ist m√∂glich.  Die Bedingung 'cin.eof ()' reicht nicht aus, um die Schleife zu verlassen.  F√ºgen Sie dem bedingten Ausdruck m√∂glicherweise den Funktionsaufruf 'cin.fail ()' hinzu.  action.cpp 46 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_keymap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::istream &amp;keymap_txt, .... )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( !keymap_txt.eof() ) { .... } }</code> </pre> <br>  Wie in der Warnung angegeben, reicht es nicht aus, beim Lesen aus der Datei nach EOF zu <i>suchen</i> . Sie m√ºssen auch nach einem Eingabefehler <i>suchen,</i> indem Sie <i>cin.fail ()</i> aufrufen.  Korrigieren wir den Code, um ihn sicherer zu machen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( !keymap_txt.eof() ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(keymap_txt.fail()) { keymap_txt.clear(); keymap_txt.ignore(numeric_limits&lt;streamsize&gt;::max(),<span class="hljs-string"><span class="hljs-string">'\n'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } .... }</code> </pre> <br>  Der Zweck von <i>keymap_txt.clear ()</i> besteht darin, den Fehlerstatus (Flag) im Stream zu l√∂schen, nachdem ein Lesefehler <i>aufgetreten</i> ist, damit Sie den Rest des Textes lesen k√∂nnen.  <i>Wenn</i> Sie <i>keymap_txt.ignore</i> mit den Parametern <i>numeric_limits &lt;streamsize&gt; :: max ()</i> und Newline-Zeichen aufrufen, k√∂nnen Sie den verbleibenden Teil der Zeichenfolge √ºberspringen. <br><br>  Es gibt eine viel einfachere M√∂glichkeit, das Lesen zu stoppen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( !keymap_txt ) { .... }</code> </pre> <br>  Im logischen Kontext wandelt sich der Stream in einen Wert um, der <i>true</i> entspricht, bis <i>EOF</i> erreicht ist. <br><br><h2>  Exkurs iv </h2><br>  Die beliebtesten Roguelike-bezogenen Spiele unserer Zeit kombinieren die Elemente von Original-Roguelike-Spielen und anderen Genres wie Plattformspielern, Strategien usw.  Solche Spiele sind als "roguelike-like" oder "roguelite" bekannt geworden.  Unter diesen sind so ber√ºhmte Titel wie <i>Don't Starve</i> , <i>Die Bindung von Isaac</i> , <i>FTL: Schneller als Licht</i> , <i>Darkest Dungeon</i> und sogar <i>Diablo</i> . <br><br>  Der Unterschied zwischen Roguelike und Roguelite kann jedoch manchmal so gering sein, dass man nicht genau sagen kann, in welche Kategorie das Spiel geh√∂rt.  Einige argumentieren, dass die <i>Zwergenfestung</i> im engeren Sinne kein Roguelike ist, w√§hrend andere glauben, dass <i>Diablo</i> ein klassisches Roguelike-Spiel ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/330/a83/895/330a838954a71a90e8bd65764a9169a8.png" alt="Bild 1"></div><br><h2>  Fazit </h2><br>  Obwohl sich das Projekt im Allgemeinen als qualitativ hochwertig erwiesen hat und nur wenige schwerwiegende M√§ngel aufweist, bedeutet dies nicht, dass es auf statische Analysen verzichten kann.  Die M√∂glichkeiten der statischen Analyse werden regelm√§√üig genutzt und nicht einmalig √ºberpr√ºft, wie wir sie f√ºr die Popularisierung durchf√ºhren.  Bei regelm√§√üiger Verwendung helfen Ihnen statische Analyseger√§te dabei, Fehler in der fr√ºhesten Entwicklungsphase zu erkennen und sie daher billiger zu beheben.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispielberechnungen</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/18d/90c/4b5/18d90c4b57268f6f55e2721a68fc017c.png" alt="Bild 2"></div><br>  Das Spiel wird noch intensiv entwickelt und von einer aktiven Modder-Community bearbeitet.  √úbrigens wurde es auf mehrere Plattformen portiert, darunter iOS und Android.  Also, wenn Sie interessiert sind, probieren Sie es aus! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de449488/">https://habr.com/ru/post/de449488/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de449476/index.html">Ein neuer SSD-Speichertyp reduziert den Stromverbrauch im Rechenzentrum - so funktioniert es</a></li>
<li><a href="../de449478/index.html">Hinzuf√ºgen von UICollectionViews zu einer benutzerdefinierten UITableViewCell, die √ºber Xib erfolgt</a></li>
<li><a href="../de449480/index.html">W√§hlen Sie die entsprechende Fehlerverfolgung</a></li>
<li><a href="../de449484/index.html">Wir entwickeln einen Luftqualit√§tskontrollsensor f√ºr InfluxDB, Grafana, Docker und Raspberry Pi</a></li>
<li><a href="../de449486/index.html">Massenexodus von Browsergames</a></li>
<li><a href="../de449490/index.html">Slurm: Intensiv von Kubernetes. Programm und Boni</a></li>
<li><a href="../de449494/index.html">KI-Schnittstellen und wo sie leben</a></li>
<li><a href="../de449496/index.html">Hackathon DevDays'19 (Teil 2): ‚Äã‚ÄãAudio-Nachrichten-Parser f√ºr die Telegramm- und Grammatikpr√ºfung in IntelliJ IDEA</a></li>
<li><a href="../de449498/index.html">Analysten: Microsoft sch√§tzt, dass bald 1 Billion US-Dollar √ºberschritten werden</a></li>
<li><a href="../de449500/index.html">Wie kann man nicht in Panik geraten, wenn viele Programmierer zu Besuch kommen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>