<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔞 👩‍🍳 🛐 Cataclysm Dark Days Ahead: Statische Analyse und Roguelike-Spiele 💆🏾 👦🏼 🐫</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sie müssen bereits aus dem Titel erraten haben, dass sich der heutige Artikel auf Fehler im Software-Quellcode konzentrieren wird. Aber nicht nur das....">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cataclysm Dark Days Ahead: Statische Analyse und Roguelike-Spiele</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/449488/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f8/70b/ef1/2f870bef158597577eac654a524b00ac.png" alt="Bild 5"></div><br>  Sie müssen bereits aus dem Titel erraten haben, dass sich der heutige Artikel auf Fehler im Software-Quellcode konzentrieren wird.  Aber nicht nur das.  Wenn Sie nicht nur an C ++ interessiert sind und über Fehler im Code anderer Entwickler lesen möchten, sondern auch ungewöhnliche Videospiele ausgraben und sich fragen, was "Roguelikes" sind und wie Sie sie spielen, dann lesen Sie weiter! <br><a name="habracut"></a><br>  Auf der Suche nach ungewöhnlichen Spielen bin ich auf <i>Cataclysm Dark Days Ahead</i> gestoßen, das sich unter anderem durch seine Grafiken auszeichnet, die auf ASCII-Zeichen in verschiedenen Farben basieren, die auf dem schwarzen Hintergrund angeordnet sind. <br><br>  Eine Sache, die Sie an diesem und anderen ähnlichen Spielen überrascht, ist, wie viel Funktionalität in sie eingebaut ist.  Insbesondere in <i>Cataclysm</i> können Sie beispielsweise nicht einmal einen Charakter erstellen, ohne den Drang zu verspüren, einige Anleitungen zu googeln, da Dutzende von Parametern, Merkmalen und Anfangsszenarien verfügbar sind, ganz zu schweigen von den zahlreichen Variationen von Ereignissen, die während des Spiels auftreten. <br><br>  Da es sich um ein Spiel mit Open-Source-Code handelt, das in C ++ geschrieben wurde, konnten wir nicht vorbeigehen, ohne es mit unserem statischen Code-Analysator PVS-Studio zu überprüfen, an dessen Entwicklung ich aktiv teilnehme.  Der Code des Projekts ist überraschend hochwertig, weist jedoch noch einige kleinere Mängel auf, von denen ich in diesem Artikel auf einige eingehen werde. <br><br>  Viele Spiele wurden bereits mit PVS-Studio überprüft.  Einige Beispiele finden Sie in unserem Artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Statische Analyse in der Videospielentwicklung: Top 10 Softwarefehler</a> ". <br><br><h2>  Logik </h2><br>  <b>Beispiel 1:</b> <br><br>  Dieses Beispiel zeigt einen klassischen Fehler beim Kopieren und Einfügen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V501</a> Links und rechts vom '||' befinden sich identische Unterausdrücke.  Operator: rng (2, 7) &lt;abs (z) ||  rng (2, 7) &lt;abs (z) overmap.cpp 1503 <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> overmap::generate_sub( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z ) { .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( rng( <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span> ) &lt; <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>( z ) || rng( <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span> ) &lt; <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>( z ) ) { .... } .... }</code> </pre> <br>  Der gleiche Zustand wird zweimal überprüft.  Der Programmierer hat den Ausdruck kopiert, aber vergessen, die Kopie zu ändern.  Ich bin nicht sicher, ob dies ein kritischer Fehler ist, aber Tatsache ist, dass die Überprüfung nicht so funktioniert, wie es beabsichtigt war. <br><br>  Ein weiterer ähnlicher Fehler: <br><br><ul><li>  V501 Links und rechts vom Operator '&amp;&amp;' befinden sich identische Unterausdrücke 'one_in (100000 / to_turns &lt;int&gt; (dur))'.  player_hardcoded_effects.cpp 547 </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d92/a93/7ac/d92a937ac860e5f2fb5ded04b8e05683.png" alt="Bild 11"></div><br>  <b>Beispiel 2:</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V728</a> Eine übermäßige Überprüfung kann vereinfacht werden.  Die '(A &amp;&amp; B) ||  (! A &amp;&amp;! B) 'Ausdruck entspricht dem Ausdruck' bool (A) == bool (B) '.  inventar_ui.cpp 199 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> inventory_selector_preset::sort_compare( .... ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> { .... <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> left_fav = g-&gt;u.inv.assigned.count( lhs.location-&gt;invlet ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> right_fav = g-&gt;u.inv.assigned.count( rhs.location-&gt;invlet ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ( left_fav &amp;&amp; right_fav ) || ( !left_fav &amp;&amp; !right_fav ) ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> .... } .... }</code> </pre> <br>  Dieser Zustand ist logisch korrekt, aber zu kompliziert.  Wer diesen Code geschrieben hat, sollte Mitleid mit seinen Programmierkollegen haben, die ihn pflegen werden.  Es könnte in einer einfacheren Form umgeschrieben werden: <i>if (left_fav == right_fav)</i> . <br><br>  Ein weiterer ähnlicher Fehler: <br><br><ul><li>  V728 Eine übermäßige Überprüfung kann vereinfacht werden.  Das '(A &amp;&amp;! B) ||  (! A &amp;&amp; B) 'Ausdruck entspricht dem Ausdruck' bool (A)! = Bool (B) '.  iuse_actor.cpp 2653 </li></ul><br><h2>  Exkurs i </h2><br>  Ich war überrascht zu entdecken, dass Spiele, die heute unter dem Namen "Roguelikes" bekannt sind, nur moderatere Vertreter des alten Genres der Roguelike-Spiele sind.  Alles begann mit dem Kult-Spiel <i>Rogue</i> von 1980, das viele Studenten und Programmierer dazu inspirierte, ihre eigenen Spiele mit ähnlichen Elementen zu entwickeln.  Ich denke, viel Einfluss kam auch von der Community des Tabletop-Spiels <i>DnD</i> und seinen Variationen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4dc/d85/de3/4dcd85de3509609962cab730653f7ed1.png" alt="Bild 8"></div><br><h2>  Mikrooptimierungen </h2><br>  <b>Beispiel 3:</b> <br><br>  Warnungen dieser Gruppe weisen auf Stellen hin, die möglicherweise optimiert werden könnten, anstatt auf Fehler. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V801</a> Leistungsminderung.  Es ist besser, das zweite Funktionsargument als Referenz neu zu definieren.  Ersetzen Sie 'const ... type' durch 'const ... &amp; type'.  map.cpp 4644 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span> &lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Stack&gt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;item&gt; use_amount_stack( Stack <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> itype_id type ) { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">list</span></span>&lt;item&gt; ret; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> a = <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.begin(); a != <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.end() &amp;&amp; quantity &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>; ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( a-&gt;use_amount( type, ret ) ) { a = <span class="hljs-built_in"><span class="hljs-built_in">stack</span></span>.erase( a ); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { ++a; } } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ret; }</code> </pre><br>  In diesem Code ist <i>itype_id</i> tatsächlich ein getarnter <i>std :: string</i> .  Da das Argument ohnehin als Konstante übergeben wird, was bedeutet, dass es unveränderlich ist, würde die einfache Übergabe eines Verweises auf die Variable dazu beitragen, die Leistung zu verbessern und Rechenressourcen zu sparen, indem der Kopiervorgang vermieden wird.  Und obwohl es unwahrscheinlich ist, dass die Zeichenfolge lang ist, ist es eine schlechte Idee, sie jedes Mal ohne guten Grund zu kopieren - zumal diese Funktion von verschiedenen Aufrufern aufgerufen wird, die wiederum auch von außen typisiert werden und haben um es zu kopieren. <br><br>  Ähnliche Probleme: <br><br><ul><li>  V801 Leistungsminderung.  Es ist besser, das dritte Funktionsargument als Referenz neu zu definieren.  Ersetzen Sie 'const ... evt_filter' durch 'const ... &amp; evt_filter'.  input.cpp 691 </li><li>  V801 Leistungsminderung.  Es ist besser, das fünfte Funktionsargument als Referenz neu zu definieren.  Ersetzen Sie 'const ... color' durch 'const ... &amp; color'.  output.h 207 </li><li>  Der Analysator gab insgesamt 32 Warnungen dieses Typs aus. </li></ul><br>  <b>Beispiel 4:</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V813</a> Leistungsminderung.  Das Argument 'str' sollte wahrscheinlich als konstante Referenz wiedergegeben werden.  catacharset.cpp 256 <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">base64_encode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">string</span></span></span></span><span class="hljs-function"><span class="hljs-params"> str )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( str.length() &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> &amp;&amp; str[<span class="hljs-number"><span class="hljs-number">0</span></span>] == <span class="hljs-string"><span class="hljs-string">'#'</span></span> ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> str; } <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> input_length = str.length(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encoded_data</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( output_length, </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">'\0'</span></span></span></span><span class="hljs-function"><span class="hljs-params"> )</span></span></span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>, j = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; input_length; ) { .... } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; mod_table[input_length % <span class="hljs-number"><span class="hljs-number">3</span></span>]; i++ ) { encoded_data[output_length - <span class="hljs-number"><span class="hljs-number">1</span></span> - i] = <span class="hljs-string"><span class="hljs-string">'='</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"#"</span></span> + encoded_data; }</code> </pre> <br>  Obwohl das Argument nicht konstant ist, ändert es sich in keiner Weise im Funktionskörper.  Aus Gründen der Optimierung wäre es daher eine bessere Lösung, diese als konstante Referenz zu übergeben, anstatt den Compiler zu zwingen, lokale Kopien zu erstellen. <br><br>  Diese Warnung kam auch nicht alleine;  Die Gesamtzahl der Warnungen dieses Typs beträgt 26. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ff/557/9b3/4ff5579b36733a7bd46f4c3df6f30d90.png" alt="Bild 7"></div><br>  Ähnliche Probleme: <br><br><ul><li>  V813 Leistungsminderung.  Das Argument 'message' sollte wahrscheinlich als konstante Referenz gerendert werden.  json.cpp 1452 </li><li>  V813 Leistungsminderung.  Das Argument 's' sollte wahrscheinlich als konstante Referenz wiedergegeben werden.  catacharset.cpp 218 </li><li>  Und so weiter ... </li></ul><br><h2>  Exkurs ii </h2><br>  Einige der klassischen Roguelike-Spiele befinden sich noch in der aktiven Entwicklung.  Wenn Sie die GitHub-Repositorys von <i>Cataclysm DDA</i> oder <i>NetHack</i> überprüfen, werden Sie <i>feststellen</i> , dass Änderungen jeden Tag übermittelt werden.  <i>NetHack</i> ist tatsächlich das älteste Spiel, das noch entwickelt wird: Es wurde im Juli 1987 veröffentlicht und die letzte Version stammt aus dem Jahr 2018. <br><br>  <i>Dwarf Fortress</i> ist eines der beliebtesten - wenn auch jüngeren - Spiele des Genres.  Die Entwicklung begann im Jahr 2002 und die erste Version wurde im Jahr 2006 veröffentlicht. Das Motto "Verlieren macht Spaß" spiegelt die Tatsache wider, dass es unmöglich ist, in diesem Spiel zu gewinnen.  Im Jahr 2007 wurde die <i>Zwergenfestung</i> durch eine jährliche Abstimmung auf der ASCII GAMES-Website als "Bestes Roguelike-Spiel des Jahres" ausgezeichnet. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e39/7fb/efa/e397fbefa4204777cc74d97e2b8e52e9.png" alt="Bild 6"></div><br>  Übrigens könnten Fans froh sein zu wissen, dass <i>Dwarf Fortress</i> mit verbesserten 32-Bit-Grafiken, die von zwei erfahrenen Moddern hinzugefügt wurden, zu Steam kommt.  Die Premium-Version erhält außerdem zusätzliche Musiktitel und Steam Workshop-Unterstützung.  Besitzer von kostenpflichtigen Kopien können auf Wunsch zu den alten ASCII-Grafiken wechseln.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mehr</a> <br><br><h2>  Überschreiben des Zuweisungsoperators </h2><br>  <b>Beispiele 5, 6:</b> <br><br>  Hier sind einige interessante Warnungen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V690</a> Die Klasse 'JsonObject' implementiert einen Kopierkonstruktor, es fehlt jedoch der Operator '='.  Es ist gefährlich, eine solche Klasse zu benutzen.  json.h 647 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonObject</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: .... JsonIn *jsin; .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: JsonObject( JsonIn &amp;jsin ); JsonObject( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> JsonObject &amp;jsobj ); JsonObject() : positions(), start( <span class="hljs-number"><span class="hljs-number">0</span></span> ), end( <span class="hljs-number"><span class="hljs-number">0</span></span> ), jsin( <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) {} ~JsonObject() { finish(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finish</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// moves the stream to the end of the object .... void JsonObject::finish() { .... } .... }</span></span></code> </pre> <br>  Diese Klasse verfügt über einen Kopierkonstruktor und einen Destruktor, überschreibt jedoch den Zuweisungsoperator nicht.  Das Problem ist, dass ein automatisch generierter Zuweisungsoperator den Zeiger nur <i>JsonIn</i> zuweisen kann.  Infolgedessen würden beide Objekte der Klasse <i>JsonObject</i> auf dasselbe <i>JsonIn verweisen</i> .  Ich kann nicht sicher sagen, ob eine solche Situation in der aktuellen Version auftreten könnte, aber eines Tages wird sicherlich jemand in diese Falle tappen. <br><br>  Die nächste Klasse hat ein ähnliches Problem. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V690</a> Die Klasse 'JsonArray' implementiert einen Kopierkonstruktor, es fehlt jedoch der Operator '='.  Es ist gefährlich, eine solche Klasse zu benutzen.  json.h 820 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">JsonArray</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: .... JsonIn *jsin; .... <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: JsonArray( JsonIn &amp;jsin ); JsonArray( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> JsonArray &amp;jsarr ); JsonArray() : positions(), ...., jsin( <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> ) {}; ~JsonArray() { finish(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">finish</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">// move the stream position to the end of the array void JsonArray::finish() { .... } }</span></span></code> </pre> <br>  Die Gefahr, den Zuweisungsoperator in einer komplexen Klasse nicht zu überschreiben, wird im Artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Gesetz der großen Zwei</a> " ausführlich erläutert. <br><br>  <b>Beispiele 7, 8:</b> <br><br>  Diese beiden befassen sich auch mit dem Überschreiben von Zuweisungsoperatoren, diesmal jedoch mit spezifischen Implementierungen. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V794</a> Der Zuweisungsoperator sollte vor dem Fall 'this == &amp; other' geschützt werden.  mattack_common.h 49 <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringRef</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: .... <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StringRefTestAccess</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>* m_start; size_type m_size; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span>* m_data = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; .... <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> = ( StringRef <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> &amp;other ) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> -&gt; StringRef&amp; { <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>[] m_data; m_data = <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span>; m_start = other.m_start; m_size = other.m_size; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre><br>  Diese Implementierung bietet keinen Schutz vor einer möglichen Selbstzuweisung, was eine unsichere Praxis ist.  Das heißt, das Übergeben eines <i>* dieser</i> Referenz an diesen Operator kann zu einem Speicherverlust führen. <br><br>  Hier ist ein ähnliches Beispiel für einen nicht ordnungsgemäß überschriebenen Zuweisungsoperator mit einer besonderen Nebenwirkung: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V794</a> Der Zuweisungsoperator sollte vor dem Fall 'this == &amp; rhs' geschützt werden.  player_activity.cpp 38 <br><br><pre> <code class="cpp hljs">player_activity &amp;player_activity::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> player_activity &amp;rhs ) { type = rhs.type; .... targets.clear(); targets.reserve( rhs.targets.size() ); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::transform( rhs.targets.begin(), rhs.targets.end(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::back_inserter( targets ), []( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> item_location &amp; e ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> e.clone(); } ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; }</code> </pre><br>  Dieser Code hat auch keine Prüfung gegen Selbstzuweisung und zusätzlich einen zu füllenden Vektor.  Bei dieser Implementierung des Zuweisungsoperators führt das Zuweisen eines Objekts zu sich selbst zu einer Verdoppelung des Vektors im <i>Zielfeld</i> , wobei einige der Elemente beschädigt werden.  Der <i>Transformation</i> geht jedoch <i>clear</i> voraus, wodurch der Vektor des Objekts gelöscht wird, was zu Datenverlust führt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/618/b4e/dd8/618b4edd868317d8e9e6a0e5d82cb5d0.png" alt="Bild 3"></div><br><h2>  Exkurs iii </h2><br>  Im Jahr 2008 erhielten Roguelikes sogar eine formale Definition, die unter dem epischen Titel "Berlin Interpretation" bekannt ist.  Demnach teilen alle diese Spiele die folgenden Elemente: <br><br><ul><li>  Zufällig erzeugte Welt, die die Wiederspielbarkeit erhöht; </li><li>  Permadeath: Wenn dein Charakter stirbt, stirbt er für immer und alle seine Gegenstände gehen verloren. </li><li>  Rundenbasiertes Gameplay: Änderungen treten nur zusammen mit den Aktionen des Spielers auf.  Der Zeitfluss wird unterbrochen, bis der Spieler eine Aktion ausführt. </li><li>  Überleben: Ressourcen sind knapp. </li></ul><br>  Schließlich ist das wichtigste Merkmal von Roguelikes, sich hauptsächlich darauf zu konzentrieren, die Welt zu erkunden, neue Verwendungsmöglichkeiten für Gegenstände zu finden und Dungeons zu kriechen. <br><br>  In <i>Cataclysm DDA</i> ist es eine häufige Situation, dass Ihr Charakter bis auf die Knochen gefroren, hungrig und durstig ist und, um das Ganze abzurunden, seine beiden Beine durch sechs Tentakel ersetzt wird. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8fe/f8e/b69/8fef8eb69a48050011726fe47ec1da35.png" alt="Bild 15"></div><br><h2>  Details, die wichtig sind </h2><br>  <b>Beispiel 9:</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V1028</a> Möglicher Überlauf.  Ziehen Sie in Betracht, Operanden des Operators 'start + large' in den Typ 'size_t' umzuwandeln, nicht in das Ergebnis.  worldfactory.cpp 638 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> worldfactory::draw_mod_list( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> &amp;start, .... ) { .... <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> larger = ....; <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> iNum = ....; .... <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( .... ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( iNum &gt;= <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;( start ) &amp;&amp; iNum &lt; <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span>&gt;( start + larger ) ) { .... } .... } .... }</code> </pre> <br>  Es sieht so aus, als wollte der Programmierer Vorsichtsmaßnahmen gegen einen Überlauf treffen.  Das Heraufstufen des Summentyps macht jedoch keinen Unterschied, da der Überlauf vorher beim Hinzufügen der Werte auftritt und das Heraufstufen über einen bedeutungslosen Wert erfolgt.  Um dies zu vermeiden, sollte nur eines der Argumente in einen breiteren Typ umgewandelt werden: <i>(static_cast &lt;size_t&gt; (start) + größer)</i> . <br><br>  <b>Beispiel 10:</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V530</a> Der Rückgabewert der Funktion 'Größe' muss verwendet werden.  worldfactory.cpp 1340 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> worldfactory::world_need_lua_build( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> world_name ) { <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> LUA .... #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// Prevent unused var error when LUA and RELEASE enabled. world_name.size(); return false; }</span></span></span></span></code> </pre> <br>  Für solche Fälle gibt es einen Trick.  Wenn Sie am Ende eine nicht verwendete Variable haben und die Compiler-Warnung unterdrücken möchten, schreiben Sie einfach <i>(void) world_name,</i> anstatt Methoden für diese Variable aufzurufen. <br><br>  <b>Beispiel 11:</b> <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V812</a> Leistungsminderung.  Ineffektive Verwendung der Zählfunktion.  Es kann möglicherweise durch den Aufruf der Funktion 'find' ersetzt werden.  player.cpp 9600 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> player::read( <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> inventory_position, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> continuous ) { .... player_activity activity; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( !continuous || !<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::all_of( learners.begin(), learners.end(), [&amp;]( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;npc *, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt; elem ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::count( activity.values.begin(), activity.values.end(), elem.first-&gt;getID() ) != <span class="hljs-number"><span class="hljs-number">0</span></span>; } ) { .... } .... }</code> </pre> <br>  Die Tatsache, dass <i>count</i> mit null verglichen wird, legt nahe, dass der Programmierer herausfinden wollte, ob die <i>Aktivität</i> mindestens ein erforderliches Element enthält.  Die <i>Zählung</i> muss jedoch durch den gesamten Container laufen, da alle Vorkommen des Elements gezählt werden.  Die Arbeit könnte schneller erledigt werden, indem <i>find verwendet wird</i> , das stoppt, sobald das erste Vorkommen gefunden wurde. <br><br>  <b>Beispiel 12:</b> <br><br>  Dieser Fehler ist leicht zu finden, wenn Sie ein schwieriges Detail über den <i>Zeichentyp kennen</i> . <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V739</a> EOF sollte nicht mit einem Wert vom Typ 'char' verglichen werden.  Das 'ch' sollte vom Typ 'int' sein.  json.cpp 762 <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> JsonIn::skip_separator() { <span class="hljs-keyword"><span class="hljs-keyword">signed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> ch; .... <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ch == <span class="hljs-string"><span class="hljs-string">','</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( ate_separator ) { .... } .... } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (ch == EOF) { .... }</code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/76e/830/467/76e830467157aab1aad9e710c195b03d.png" alt="Bild 13"></div><br>  Dies ist einer der Fehler, die Sie nur dann leicht erkennen können, wenn Sie wissen, dass <i>EOF</i> als -1 definiert ist.  Wenn Sie es mit einer Variablen vom Typ <i>char</i> mit Vorzeichen vergleichen, wird die Bedingung daher in fast allen Fällen als <i>falsch</i> ausgewertet.  Die einzige Ausnahme ist das Zeichen, dessen Code 0xFF (255) ist.  Bei Verwendung in einem Vergleich wird -1 angezeigt, wodurch die Bedingung erfüllt wird. <br><br>  <b>Beispiel 13:</b> <br><br>  Dieser kleine Fehler kann eines Tages kritisch werden.  Es gibt schließlich gute Gründe dafür, dass es auf der CWE-Liste als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CWE-834 steht</a> .  Beachten Sie, dass das Projekt diese Warnung fünfmal ausgelöst hat. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V663</a> Endlosschleife ist möglich.  Die Bedingung 'cin.eof ()' reicht nicht aus, um die Schleife zu verlassen.  Fügen Sie dem bedingten Ausdruck möglicherweise den Funktionsaufruf 'cin.fail ()' hinzu.  action.cpp 46 <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parse_keymap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::istream &amp;keymap_txt, .... )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( !keymap_txt.eof() ) { .... } }</code> </pre> <br>  Wie in der Warnung angegeben, reicht es nicht aus, beim Lesen aus der Datei nach EOF zu <i>suchen</i> . Sie müssen auch nach einem Eingabefehler <i>suchen,</i> indem Sie <i>cin.fail ()</i> aufrufen.  Korrigieren wir den Code, um ihn sicherer zu machen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( !keymap_txt.eof() ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(keymap_txt.fail()) { keymap_txt.clear(); keymap_txt.ignore(numeric_limits&lt;streamsize&gt;::max(),<span class="hljs-string"><span class="hljs-string">'\n'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } .... }</code> </pre> <br>  Der Zweck von <i>keymap_txt.clear ()</i> besteht darin, den Fehlerstatus (Flag) im Stream zu löschen, nachdem ein Lesefehler <i>aufgetreten</i> ist, damit Sie den Rest des Textes lesen können.  <i>Wenn</i> Sie <i>keymap_txt.ignore</i> mit den Parametern <i>numeric_limits &lt;streamsize&gt; :: max ()</i> und Newline-Zeichen aufrufen, können Sie den verbleibenden Teil der Zeichenfolge überspringen. <br><br>  Es gibt eine viel einfachere Möglichkeit, das Lesen zu stoppen: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span>( !keymap_txt ) { .... }</code> </pre> <br>  Im logischen Kontext wandelt sich der Stream in einen Wert um, der <i>true</i> entspricht, bis <i>EOF</i> erreicht ist. <br><br><h2>  Exkurs iv </h2><br>  Die beliebtesten Roguelike-bezogenen Spiele unserer Zeit kombinieren die Elemente von Original-Roguelike-Spielen und anderen Genres wie Plattformspielern, Strategien usw.  Solche Spiele sind als "roguelike-like" oder "roguelite" bekannt geworden.  Unter diesen sind so berühmte Titel wie <i>Don't Starve</i> , <i>Die Bindung von Isaac</i> , <i>FTL: Schneller als Licht</i> , <i>Darkest Dungeon</i> und sogar <i>Diablo</i> . <br><br>  Der Unterschied zwischen Roguelike und Roguelite kann jedoch manchmal so gering sein, dass man nicht genau sagen kann, in welche Kategorie das Spiel gehört.  Einige argumentieren, dass die <i>Zwergenfestung</i> im engeren Sinne kein Roguelike ist, während andere glauben, dass <i>Diablo</i> ein klassisches Roguelike-Spiel ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/330/a83/895/330a838954a71a90e8bd65764a9169a8.png" alt="Bild 1"></div><br><h2>  Fazit </h2><br>  Obwohl sich das Projekt im Allgemeinen als qualitativ hochwertig erwiesen hat und nur wenige schwerwiegende Mängel aufweist, bedeutet dies nicht, dass es auf statische Analysen verzichten kann.  Die Möglichkeiten der statischen Analyse werden regelmäßig genutzt und nicht einmalig überprüft, wie wir sie für die Popularisierung durchführen.  Bei regelmäßiger Verwendung helfen Ihnen statische Analysegeräte dabei, Fehler in der frühesten Entwicklungsphase zu erkennen und sie daher billiger zu beheben.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beispielberechnungen</a> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/18d/90c/4b5/18d90c4b57268f6f55e2721a68fc017c.png" alt="Bild 2"></div><br>  Das Spiel wird noch intensiv entwickelt und von einer aktiven Modder-Community bearbeitet.  Übrigens wurde es auf mehrere Plattformen portiert, darunter iOS und Android.  Also, wenn Sie interessiert sind, probieren Sie es aus! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de449488/">https://habr.com/ru/post/de449488/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de449476/index.html">Ein neuer SSD-Speichertyp reduziert den Stromverbrauch im Rechenzentrum - so funktioniert es</a></li>
<li><a href="../de449478/index.html">Hinzufügen von UICollectionViews zu einer benutzerdefinierten UITableViewCell, die über Xib erfolgt</a></li>
<li><a href="../de449480/index.html">Wählen Sie die entsprechende Fehlerverfolgung</a></li>
<li><a href="../de449484/index.html">Wir entwickeln einen Luftqualitätskontrollsensor für InfluxDB, Grafana, Docker und Raspberry Pi</a></li>
<li><a href="../de449486/index.html">Massenexodus von Browsergames</a></li>
<li><a href="../de449490/index.html">Slurm: Intensiv von Kubernetes. Programm und Boni</a></li>
<li><a href="../de449494/index.html">KI-Schnittstellen und wo sie leben</a></li>
<li><a href="../de449496/index.html">Hackathon DevDays'19 (Teil 2): ​​Audio-Nachrichten-Parser für die Telegramm- und Grammatikprüfung in IntelliJ IDEA</a></li>
<li><a href="../de449498/index.html">Analysten: Microsoft schätzt, dass bald 1 Billion US-Dollar überschritten werden</a></li>
<li><a href="../de449500/index.html">Wie kann man nicht in Panik geraten, wenn viele Programmierer zu Besuch kommen?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>