<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>‚úçüèæ üë©‚Äçüé§ üì° Por qu√© no es buena idea portar el desbordamiento de enteros üõ£Ô∏è ü§Ωüèº üßõüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este art√≠culo se centra en el comportamiento indefinido y las optimizaciones del compilador, especialmente en el contexto del desbordamiento de entero...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Por qu√© no es buena idea portar el desbordamiento de enteros</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/427683/">  <b>Este art√≠culo se centra en el comportamiento indefinido y las optimizaciones del compilador, especialmente en el contexto del desbordamiento de enteros con signo.</b> <br><br>  <b>Nota del traductor:</b> en ruso no existe una correspondencia clara en el contexto utilizado de la palabra "wrap" / "wrapping".  Hay un t√©rmino matem√°tico " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">transferencia</a> ", que est√° cerca del fen√≥meno descrito, y el t√©rmino "bandera de acarreo" es un mecanismo para establecer una bandera en los procesadores durante el desbordamiento de enteros.  Otra opci√≥n de traducci√≥n puede ser la frase "rotaci√≥n / volteo / revoluci√≥n alrededor de cero".  Refleja mejor el significado de "envoltura" en comparaci√≥n con "llevar", porque  muestra la transici√≥n de n√∫meros cuando se desborda de rango positivo a negativo.  Sin embargo, result√≥ que estas palabras parecen inusuales en el texto para los lectores de prueba.  Por simplicidad, en el futuro tomaremos la palabra "transferencia" como una traducci√≥n del t√©rmino "envolver". <br><br>  Los compiladores del lenguaje C (y C ++) en su trabajo se gu√≠an cada vez m√°s por el concepto de <i>comportamiento indefinido</i> : la noci√≥n de que el comportamiento de un programa para algunas operaciones no est√° regulado por el est√°ndar y que, al generar c√≥digo objeto, el compilador tiene el derecho de proceder desde el supuesto de que el programa no realiza tales operaciones.  Muchos programadores se opusieron a este enfoque, ya que el c√≥digo generado en este caso puede no comportarse como el autor del programa previsto.  Este problema se agudiza, ya que los compiladores utilizan m√©todos de optimizaci√≥n m√°s sofisticados, que probablemente se basar√°n en el concepto de comportamiento indefinido. <br><a name="habracut"></a><br>  En este contexto, un ejemplo con un desbordamiento de entero con signo es indicativo.  La mayor√≠a de los desarrolladores de C escriben c√≥digo para m√°quinas que usan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥digo adicional</a> para representar enteros, y la suma y resta en esta representaci√≥n se implementan exactamente de la misma manera, en aritm√©tica sin signo.  Si la suma de dos enteros positivos con un signo se desborda, es decir, se hace m√°s grande de lo que el tipo acomoda, el procesador devolver√° un valor que, interpretado como un complemento binario del n√∫mero con signo, se considerar√° negativo.  Este fen√≥meno se llama "transferencia", ya que el resultado, despu√©s de haber alcanzado el l√≠mite superior del rango de valores, se "transfiere" y comienza desde el l√≠mite inferior. <br><br>  Por esta raz√≥n, a veces puedes ver este c√≥digo en C: <br><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> b = a + <span class="hljs-number"><span class="hljs-number">1000</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (b &lt; a) { <span class="hljs-comment"><span class="hljs-comment">//  puts("input too large!"); return; }</span></span></code> </pre> <br>  La tarea de la <i>instrucci√≥n if</i> es detectar una condici√≥n de desbordamiento (en este caso, ocurre despu√©s de agregar 1000 al valor de la variable <i>a</i> ) e informar un error.  El problema es que en C, el desbordamiento de enteros con signo es uno de los casos de comportamiento indefinido.  Durante alg√∫n tiempo, los compiladores siempre han considerado que tales condiciones son falsas: si agrega 1000 (o cualquier otro n√∫mero positivo) a otro n√∫mero, el resultado no puede ser inferior al valor inicial.  Si se produce un desbordamiento, entonces hay un comportamiento indefinido, y no permitir que esto ya sea (aparentemente) la preocupaci√≥n del programador.  Por lo tanto, el compilador puede decidir que el operador condicional se puede eliminar por completo para fines de optimizaci√≥n (despu√©s de todo, la condici√≥n siempre es falsa, no afecta nada, por lo que puede prescindir de ella). <br><br>  El problema es que con esta optimizaci√≥n, el compilador elimin√≥ la verificaci√≥n que el programador agreg√≥ espec√≠ficamente para detectar comportamientos indefinidos y procesarlos.  Aqu√≠ puedes ver c√≥mo sucede esto en la pr√°ctica.  (Nota: ¬°el sitio web godbolt.org, que alberga el ejemplo, es genial! Puede editar el c√≥digo e inmediatamente ver c√≥mo lo procesan los diferentes compiladores, y hay muchos de ellos. ¬°Experimente!).  Tenga en cuenta que el compilador no elimina la comprobaci√≥n de desbordamiento si cambia el tipo a sin signo, ya que se define el comportamiento del desbordamiento sin signo en C (m√°s precisamente, el resultado se transfiere con aritm√©tica sin signo, por lo que el desbordamiento no ocurre realmente). <br><br>  ¬øEntonces esto est√° mal?  Alguien dice que s√≠, aunque es obvio que muchos desarrolladores de compiladores consideran legal esta decisi√≥n.  Si entiendo correctamente, los argumentos principales de los partidarios (edici√≥n: dependiente de la implementaci√≥n) de la transferencia durante el desbordamiento son los siguientes: <br><br><ul><li>  Desbordarse es un comportamiento √∫til. </li><li>  La migraci√≥n es el comportamiento que los programadores esperan. </li><li>  La sem√°ntica del comportamiento de desbordamiento indefinido no proporciona una ventaja notable. </li><li>  El est√°ndar del lenguaje C para el comportamiento indefinido permite que la implementaci√≥n "ignore completamente la situaci√≥n, y el resultado ser√° impredecible", pero esto no le da al compilador el derecho de optimizar el c√≥digo basado en el supuesto de que la situaci√≥n con el comportamiento indefinido no ocurre en absoluto. </li></ul><br>  Analicemos cada elemento por turno: <br><br>  <b>Migraci√≥n por desbordamiento: ¬øcomportamiento √∫til?</b> <br><br>  La migraci√≥n es √∫til principalmente cuando necesita rastrear un desbordamiento que ya ha ocurrido.  (Si hay otros problemas que pueden resolverse mediante transferencia y no pueden resolverse utilizando variables enteras sin signo, no puedo recordar de inmediato tales ejemplos, y sospecho que hay pocos).  Si bien la transferencia realmente simplifica el problema de usar variables desbordadas incorrectamente, definitivamente no es una panacea (recuerde la multiplicaci√≥n o adici√≥n de dos cantidades desconocidas con un signo desconocido). <br><br>  En casos triviales, cuando la transferencia simplemente le permite rastrear el desbordamiento que ha surgido, tampoco es dif√≠cil saber de antemano si ocurrir√°.  Nuestro ejemplo puede reescribirse de la siguiente manera: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a &gt; INT_MAX - <span class="hljs-number"><span class="hljs-number">1000</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//    puts("input too large!"); return; } int b = a + 1000;</span></span></code> </pre> <br>  Es decir, en lugar de calcular la suma y luego averiguar si se ha producido un desbordamiento o no, verificando la coherencia matem√°tica del resultado, puede verificar si la suma excede el n√∫mero m√°ximo que se ajusta al tipo.  (Si se desconoce el signo de ambos operandos, la verificaci√≥n tendr√° que ser muy complicada, pero lo mismo se aplica a la verificaci√≥n durante la transferencia). <br><br>  Dado todo esto, el argumento me parece poco convincente de que la transferencia es √∫til en la mayor√≠a de los casos. <br><br>  <b>¬øEs la migraci√≥n el comportamiento que los programadores esperan?</b> <br><br>  Es m√°s dif√≠cil discutir con este argumento, ya que es obvio que el c√≥digo de al menos <i>algunos</i> programadores de C asume la sem√°ntica de transferencia con un desbordamiento de entero con signo.  Pero este hecho por s√≠ solo no es suficiente para considerar preferible tal sem√°ntica (tenga en cuenta que algunos compiladores le permiten habilitarla si es necesario). <br><br>  Una soluci√≥n obvia al problema (los programadores esperan este comportamiento) es hacer que el compilador emita una advertencia cuando optimice el c√≥digo, suponiendo que no haya un comportamiento indefinido.  Desafortunadamente, como vimos en el ejemplo en godbolt.org usando el enlace de arriba, los compiladores no siempre hacen esto (Gcc versi√≥n 7.3 - s√≠, pero versi√≥n 8.1 - no, as√≠ que hay un paso atr√°s). <br><br>  <b>¬øLa sem√°ntica del comportamiento de desbordamiento indefinido no ofrece una ventaja notable?</b> <br><br>  Si esta observaci√≥n es cierta en todos los casos, entonces servir√≠a como un fuerte argumento a favor del hecho de que los compiladores deben adherirse a la sem√°ntica de transferencia de forma predeterminada, ya que probablemente ser√≠a mejor permitir verificaciones de desbordamiento, incluso si este mecanismo es incorrecto desde un punto de vista t√©cnico, aunque ser√≠a porque se puede usar en c√≥digo potencialmente roto. <br><br>  Supongo que esta optimizaci√≥n (eliminaci√≥n de comprobaciones de condiciones matem√°ticamente contradictorias) en los programas normales de C a menudo se puede descuidar, ya que sus autores se esfuerzan por obtener el mejor rendimiento y a√∫n optimizan el c√≥digo manualmente: es decir, si es obvio que esta <i>declaraci√≥n</i> contiene una condici√≥n , que nunca ser√° cierto, es probable que el programador lo elimine √©l mismo.  De hecho, descubr√≠ que en varios estudios la efectividad de dicha optimizaci√≥n se puso en tela de juicio, se prob√≥ y result√≥ ser pr√°cticamente insignificante en el marco de las pruebas de control.  Sin embargo, aunque esta optimizaci√≥n casi nunca ofrece una ventaja en el lenguaje C, los generadores de c√≥digo y las optimizaciones del compilador son en su mayor parte universales y pueden usarse en otros lenguajes, y para ellos esta conclusi√≥n puede ser incorrecta.  Tomemos el lenguaje C ++ con su, digamos, tradici√≥n de confiar en el optimizador para eliminar construcciones redundantes en el c√≥digo de la plantilla, en lugar de hacerlo manualmente.  Pero hay lenguajes que el transportador convierte a C, y el c√≥digo redundante en ellos tambi√©n est√° optimizado por los compiladores de C. <br><br>  Adem√°s, incluso si sigue buscando desbordamientos, no es un hecho que el costo <i>directo</i> de transferir variables enteras sea m√≠nimo, incluso en m√°quinas que usan c√≥digo adicional.  La arquitectura Mips, por ejemplo, solo puede realizar operaciones aritm√©ticas en registros de un tama√±o fijo (32 bits).  El tipo <i>short int</i> , como regla, tiene un tama√±o de 16 bits y <i>char</i> - 8 bits;  cuando una variable de uno de estos tipos se almacena en el registro, su tama√±o se expandir√° y, para transferirla correctamente, ser√° necesario realizar al menos una operaci√≥n adicional y, posiblemente, usar un registro adicional (para acomodar la m√°scara de bits correspondiente).  Tengo que admitir que no he tratado con el c√≥digo de Mips durante mucho tiempo, por lo que no estoy seguro sobre el costo exacto de estas operaciones, pero estoy seguro de que no es cero y que los mismos problemas pueden ocurrir en otras arquitecturas RISC. <br><br>  <b>¬øUn est√°ndar de lenguaje proh√≠be evitar la envoltura de variables si est√° dise√±ado por la arquitectura?</b> <br><br>  Si nos fijamos, este argumento es especialmente d√©bil.  Su esencia es que el est√°ndar supuestamente permite que la implementaci√≥n (compilador) interprete el "comportamiento indefinido" solo de forma limitada.  En el texto de la norma en s√≠, en ese fragmento al que apelan los defensores de la transferencia, se dice lo siguiente (esto es parte de la definici√≥n del t√©rmino "comportamiento indefinido"): <br><br>  NOTA: El <i>comportamiento indefinido puede tomar la forma de ignorar completamente la situaci√≥n, mientras que el resultado ser√° impredecible, ...</i> <br><br>  La idea es que las palabras "ignorar completamente la situaci√≥n" no sugieren que un evento que conduzca a un comportamiento indefinido, por ejemplo, desbordamiento durante la adici√≥n, no puede ocurrir, sino que si lo hace, el compilador deber√≠a continuar trabajando como si que nunca sucedi√≥, pero tambi√©n tenga en cuenta el resultado que resultar√° si le env√≠a al procesador una solicitud para realizar dicha operaci√≥n (en otras palabras, como si el c√≥digo fuente se tradujera al c√≥digo de la m√°quina de una manera directa e ingenua). <br><br>  En primer lugar, debe tenerse en cuenta que este texto se proporciona como una "nota" y, por lo tanto, no es normativo (es decir, no puede prescribir algo), de acuerdo con la directiva ISO mencionada en la introducci√≥n a la norma: <br><br>  <i>De acuerdo con la Parte 3 de las Directivas ISO / IEC, este prefacio, introducci√≥n al texto, notas, notas al pie y ejemplos tambi√©n son solo para fines informativos.</i> <br><br>  Dado que este pasaje de "comportamiento indefinido" es una nota, no prescribe nada.  Tenga en cuenta que la definici√≥n actual de "comportamiento indefinido" es: <br><br>  <i>comportamiento derivado del uso de un dise√±o de software intolerable o incorrecto o datos incorrectos, a los cuales</i> <b><i>esta Norma Internacional no impone ning√∫n requisito</i></b> <i>.</i> <br><br>  Destaqu√© la idea principal: no se imponen requisitos sobre el comportamiento indefinido;  La lista de "posibles tipos de comportamiento indefinido" en la nota contiene solo ejemplos y no puede ser la receta final.  La frase "no exige nada" no puede interpretarse de otra manera. <br><br>  Algunos, al desarrollar este argumento, argumentan que, independientemente del texto, el comit√© de lenguaje, cuando formul√≥ estas palabras, <i>significaba</i> que el comportamiento en su conjunto deber√≠a corresponder a la arquitectura del hardware en el que se ejecuta el programa, lo m√°s posible, lo que implica una traducci√≥n ingenua en c√≥digo de m√°quina.  Esto puede ser cierto, aunque no he visto ninguna evidencia (por ejemplo, documentos hist√≥ricos) en apoyo de este argumento.  Sin embargo, incluso si esto fuera as√≠, no es un hecho que esta declaraci√≥n se aplique a la versi√≥n actual del texto. <br><br>  <b>√öltimos pensamientos</b> <br><br>  Los argumentos a favor de la transferencia son en gran medida insostenibles.  Quiz√°s el argumento m√°s s√≥lido se obtenga si los combinamos: los programadores menos experimentados (que no conocen las complejidades del lenguaje C y el comportamiento indefinido en √©l) a veces esperan transferencia, y no reduce el rendimiento, aunque este √∫ltimo no es cierto en todos los casos, y la primera parte no es concluyente si lo consideras por separado. <br><br>  Personalmente, preferir√≠a que los desbordamientos se bloqueen (atrapando) en lugar de envolver.  Es decir, para que el programa se bloquee y no contin√∫e funcionando, con un comportamiento incierto o resultados potencialmente incorrectos, porque en ambos casos aparece una vulnerabilidad.  Tal soluci√≥n, por supuesto, reducir√° ligeramente el rendimiento en la mayor√≠a de las arquitecturas (?), Especialmente en x86, pero, por otro lado, los errores de desbordamiento se identificar√°n de inmediato y no podr√°n aprovecharlos ni obtener resultados incorrectos al usarlos en el camino programas  Adem√°s, en teor√≠a, los compiladores con este enfoque podr√≠an eliminar de forma segura las comprobaciones de desbordamiento redundantes, ya que <i>ciertamente</i> no suceder√°, aunque, como veo, ni Clang ni GCC aprovechan esta oportunidad. <br><br>  Afortunadamente, tanto la interrupci√≥n como la transferencia se implementan en el compilador que uso con m√°s frecuencia es GCC.  Para cambiar entre modos, se utilizan los argumentos de l√≠nea de comando <i>-ftrapv</i> y <i>-fwrapv</i> , respectivamente. <br><br>  Por supuesto, hay muchas acciones que conducen a un comportamiento indefinido: el desbordamiento de enteros es solo una de ellas.  No creo en absoluto que sea √∫til interpretar todos estos casos como comportamiento indefinido, y estoy seguro de que hay muchas situaciones espec√≠ficas en las que la sem√°ntica debe determinarse por el lenguaje o, al menos, dejarse a discreci√≥n de las implementaciones.  Y me temo que los fabricantes de compiladores interpretan de manera demasiado libre este concepto: si el comportamiento del compilador no cumple con las ideas intuitivas de los desarrolladores, especialmente aquellos que leen personalmente el texto del est√°ndar, esto puede conducir a errores reales;  Si la ganancia de rendimiento en este caso es insignificante, es mejor abandonar tales interpretaciones.  En una de las siguientes publicaciones, probablemente analizar√© algunos de estos problemas. <br><br>  Suplemento (del 24 de agosto de 2018) <br><br>  Me di cuenta de que gran parte de lo anterior podr√≠a escribirse mejor.  A continuaci√≥n resumo y explico brevemente mis palabras y agrego algunas observaciones menores: <br><br><ul><li>  No sostuve que el comportamiento indefinido sea preferible al desbordamiento, sino que, <i>en la pr√°ctica, la</i> transferencia <i>no</i> es <i>mucho mejor que el</i> comportamiento indefinido.  En particular, se pueden obtener problemas de seguridad en el primer caso y en el segundo, y apuesto a que muchas de las vulnerabilidades causadas por desbordamientos que no se detectaron a tiempo (excepto aquellas de las cuales el compilador es responsable de eliminar las comprobaciones err√≥neas) en realidad provienen de - debido a la transferencia del resultado, pero no debido al comportamiento indefinido asociado con el desbordamiento. </li><li>  La √∫nica ventaja real de la transferencia es que no se eliminan las comprobaciones de desbordamiento.  Aunque de esta manera puede proteger el c√≥digo de algunos escenarios de ataque, es probable que algunos de los desbordamientos no se verifiquen en absoluto (es decir, el programador se olvidar√° de agregar dicha verificaci√≥n) y pasar√°n desapercibidos. </li><li>  Si el problema de seguridad no es tan importante, y la alta velocidad del programa se destaca, entonces el comportamiento indefinido dar√° una optimizaci√≥n m√°s rentable y un mayor aumento de la productividad, al menos en algunos casos.  Por otro lado, si la seguridad es lo primero, la portabilidad est√° llena de vulnerabilidades. </li><li>  Esto significa que si elige entre interrupci√≥n, transferencia y comportamiento indefinido, hay muy pocas tareas en las que la transferencia puede ser √∫til. </li><li>  En cuanto a las comprobaciones del desbordamiento que se ha producido, creo que dejarlas es perjudicial, porque crea la falsa impresi√≥n de que funcionan y siempre funcionar√°n.  Interrumpir los desbordamientos evita este problema;  advertencias adecuadas: mitigarlo. </li><li>  Creo que cualquier desarrollador que escriba c√≥digo cr√≠tico para la seguridad idealmente deber√≠a tener un buen dominio de la sem√°ntica del lenguaje en el que escribe, as√≠ como ser consciente de sus dificultades.  Para C, esto significa que necesita conocer la sem√°ntica del desbordamiento y las sutilezas del comportamiento indefinido.  Es triste que algunos programadores no hayan crecido a este nivel. </li><li>  Me he encontrado con la afirmaci√≥n de que "la mayor√≠a de los programadores de C esperan la migraci√≥n como el comportamiento predeterminado", pero no conozco la evidencia de esto.  (En el art√≠culo, escrib√≠ "algunos programadores", porque conozco varios ejemplos de la vida real, y en general dudo que alguien discuta esto). </li><li>  Hay dos problemas diferentes: qu√© requiere el est√°ndar del lenguaje C y qu√© compiladores deber√≠an implementar.  (Generalmente) me gusta la forma en que el est√°ndar define el comportamiento de desbordamiento indefinido.  En esta publicaci√≥n, hablo sobre lo que deber√≠an hacer los compiladores. </li><li>  Cuando se interrumpe el desbordamiento, no hay necesidad de verificar cada operaci√≥n.  Idealmente, el programa con este enfoque se comporta de manera consistente en t√©rminos de reglas matem√°ticas o deja de funcionar.  En este caso, la existencia de un "desbordamiento temporal" se hace posible, lo que no conduce a la aparici√≥n de un resultado incorrecto.  Entonces, tanto la expresi√≥n <i>a + b - b</i> como la expresi√≥n <i>(a * b) / b</i> se pueden optimizar a <i>a</i> (la primera tambi√©n es posible durante la transferencia, pero la segunda ya no est√° presente). </li></ul><br>  <b>Nota</b>  La traducci√≥n del art√≠culo se publica en el blog con el permiso del autor.  Texto original: Davin McCall " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Ajustar el desbordamiento de enteros no es una buena idea</a> ". <br><br>  Enlaces relacionados adicionales del equipo PVS-Studio: <br><br><ol><li>  Andrey Karpov.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El comportamiento indefinido est√° m√°s cerca de lo que piensas</a> . </li><li>  Will Dietz, Peng Li, John Regehr y Vikram Adve.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Comprender el desbordamiento de enteros en C / C ++</a> . </li><li>  V1026.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">La variable se incrementa en el bucle.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Se producir√° un comportamiento indefinido en caso de desbordamiento de entero con signo</a> . </li><li>  Stackoverflow  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬øEl desbordamiento de entero con signo sigue siendo un comportamiento indefinido en C ++?</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es427683/">https://habr.com/ru/post/es427683/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es427671/index.html">Sberbank y Yandex lanzaron oficialmente la plataforma comercial Beru, la versi√≥n rusa de Amazon</a></li>
<li><a href="../es427673/index.html">Machine learning @ booking.com</a></li>
<li><a href="../es427675/index.html">Papeles, por favor. C√≥mo una red neuronal nos ayuda a verificar clientes y atrapar a los estafadores</a></li>
<li><a href="../es427679/index.html">Reducir a cero el l√≠mite de compras libres de impuestos llevar√° un a√±o y medio, si se toma una decisi√≥n</a></li>
<li><a href="../es427681/index.html">Arrastra y desliza en RecyclerView. Parte 1: ItemTouchHelper</a></li>
<li><a href="../es427685/index.html">FSB contra Internet satelital de operadores extranjeros</a></li>
<li><a href="../es427687/index.html">Referencia para aplicaciones comerciales | Arquitectura DentalTap</a></li>
<li><a href="../es427689/index.html">Cerveza directamente de la nube</a></li>
<li><a href="../es427691/index.html">Crear un bot de chat simple en VK en Python 3</a></li>
<li><a href="../es427693/index.html">El libro "Gravedad. La √∫ltima tentaci√≥n de Einstein</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>