<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😥 👨🏽‍🏫 👎🏽 Filsuf makan "modern" di C ++ melalui aktor dan CSP 📩 🚭 👨🏾‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Beberapa waktu lalu, tautan ke artikel "filsuf makan modern" tersebar di berbagai sumber seperti Reddit dan HackerNews. Artikel ini menarik, menunjukk...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Filsuf makan "modern" di C ++ melalui aktor dan CSP</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437998/"><p>  Beberapa waktu lalu, tautan ke artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">"filsuf makan modern"</a> tersebar di berbagai sumber seperti Reddit dan HackerNews.  Artikel ini menarik, menunjukkan beberapa solusi untuk tugas terkenal ini, diimplementasikan dalam C ++ modern menggunakan pendekatan berbasis tugas.  Jika seseorang belum membaca artikel ini, maka masuk akal untuk menghabiskan waktu dan membacanya. </p><br><p>  Namun, saya tidak bisa mengatakan bahwa solusi yang disajikan dalam artikel itu tampak sederhana dan dapat dipahami bagi saya.  Ini mungkin karena penggunaan tugas.  Terlalu banyak dari mereka yang dibuat dan dikirim melalui berbagai dispatcher / serialis.  Jadi tidak selalu jelas di mana, kapan, dan tugas apa yang dilakukan. </p><br><p>  Selain itu, pendekatan berbasis tugas bukan satu-satunya yang mungkin untuk memecahkan masalah seperti itu.  Mengapa tidak melihat bagaimana tugas "filsuf makan" diselesaikan melalui model Aktor dan CSP? </p><br><p>  Oleh karena itu, saya mencoba mencari dan menerapkan beberapa solusi untuk masalah ini menggunakan Aktor dan CSP.  Kode untuk solusi ini dapat ditemukan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">di repositori di GitHub</a> .  Dan di bawah pemotong, penjelasan dan penjelasan, jadi siapa pun yang tertarik, selamat datang di bawah dipotong. </p><a name="habracut"></a><br><h1 id="neskolko-obschih-slov">  Beberapa kata umum </h1><br><p>  Saya tidak memiliki tujuan mengulangi keputusan yang ditunjukkan dalam artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">"filsuf makan modern"</a> , terutama karena saya pada dasarnya tidak menyukai satu hal penting: pada kenyataannya, filsuf tidak melakukan apa pun pada keputusan itu.  Dia hanya mengatakan "Aku ingin makan", dan kemudian seseorang memberinya garpu secara ajaib, atau dia berkata "sekarang tidak akan berhasil." </p><br><p>  Jelas mengapa penulis memilih perilaku seperti itu: ia memungkinkan penggunaan implementasi yang sama dari "filsuf" dalam hubungannya dengan implementasi yang berbeda dari "protokol".  Namun, menurut saya pribadi bahwa itu lebih menarik ketika "filsuf" mencoba untuk mengambil satu plug pertama, lalu yang lain.  Dan ketika "filsuf" terpaksa menangani upaya gagal untuk menangkap garpu. </p><br><p>  Justru ini realisasi tugas "filsuf makan" yang saya coba buat.  Pada saat yang sama, beberapa solusi menggunakan pendekatan yang sama seperti pada artikel yang disebutkan (misalnya, diimplementasikan oleh protokol ForkLevelPhilosopherProtocol dan WaiterFair). </p><br><p>  Saya membuat keputusan berdasarkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">SObjectizer</a> , yang sepertinya tidak mengejutkan mereka yang telah membaca artikel saya sebelumnya.  Jika seseorang belum pernah mendengar tentang SObjectizer, secara singkat: ini adalah salah satu dari sedikit "kerangka aktor" OpenSource untuk C ++ ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">CAF</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">QP / C ++</a> juga dapat disebutkan antara lain).  Saya berharap contoh di atas dengan komentar saya akan cukup jelas bahkan untuk mereka yang tidak terbiasa dengan SObjectizer.  Jika tidak, saya akan dengan senang hati menjawab pertanyaan di komentar. </p><br><h1 id="resheniya-na-baze-aktorov">  Solusi Aktor </h1><br><p>  Kami akan memulai diskusi tentang solusi yang diimplementasikan dengan yang didasarkan pada Aktor.  Pertama, pertimbangkan implementasi solusi Edsger Dijkstra, kemudian beralih ke beberapa solusi lain dan lihat bagaimana perilaku masing-masing solusi tersebut berbeda. </p><br><h2 id="reshenie-deykstry">  Keputusan Dijkstra </h2><br><p>  Edsger Dijkstra, dia tidak hanya merumuskan tugas "filum makan" (formulasi menggunakan "garpu" dan "spageti" disuarakan oleh Tony Hoar), dia juga mengusulkan solusi yang sangat sederhana dan indah.  Yaitu: para filsuf seharusnya hanya mengambil garpu untuk menambah jumlah garpu, dan jika filsuf berhasil mengambil garpu pertama, maka ia tidak akan melepaskannya sampai ia menerima garpu kedua. </p><br><p>  Misalnya, jika seorang filsuf perlu menggunakan garpu dengan angka 5 dan 6, maka seorang filsuf pertama-tama harus mengambil garpu nomor 5. Hanya kemudian ia dapat mengambil garpu nomor 6. Dengan demikian, jika garpu dengan angka yang lebih rendah berada di sebelah kiri para filsuf, maka filsuf harus pertama ambil garpu kiri dan baru setelah itu dia bisa mengambil garpu kanan. </p><br><p>  Filsuf terakhir dalam daftar, yang harus berurusan dengan percabangan pada angka (N-1) dan 0, melakukan yang sebaliknya: ia pertama kali mengambil percabangan kanan dengan angka 0, dan kemudian percabangan kiri dengan angka (N-1). </p><br><p>  Untuk menerapkan pendekatan ini, dua jenis aktor akan diperlukan: satu untuk garpu dan satu untuk filsuf.  Jika filsuf ingin makan, ia mengirim pesan ke aktor garpu yang sesuai untuk menangkap garpu, dan aktor garpu merespons dengan pesan tanggapan. </p><br><p>  Kode untuk menerapkan pendekatan ini dapat dilihat di <a href="" rel="nofollow">sini</a> . </p><br><h3 id="soobscheniya">  Pesan </h3><br><p>  Sebelum berbicara tentang aktor, Anda perlu melihat pesan yang akan dipertukarkan oleh aktor: </p><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">take_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> m_who; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> m_philosopher_index; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">taken_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">put_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {};</code> </pre> <br><p>  Ketika aktor-filsuf ingin mengambil steker, ia mengirim pesan <code>take_t</code> ke aktor garpu dan aktor garpu merespons dengan pesan <code>taken_t</code> .  Ketika aktor filsuf selesai makan dan ingin meletakkan garpu kembali di atas meja, ia mengirim pesan put_t ke <code>put_t</code> . </p><br><p>  Dalam pesan <code>take_t</code> , bidang <code>take_t</code> menunjukkan kotak surat (alias mbox) dari aktor filsuf.  Pesan respons <code>taken_t</code> harus dikirim ke <code>taken_t</code> ini.  Kolom kedua dari <code>take_t</code> tidak digunakan dalam contoh ini, kita akan membutuhkannya ketika kita sampai pada implementasi dari wait_with_queue dan waiter_with_timestamps. </p><br><h3 id="aktor-vilka">  Garpu aktor </h3><br><p>  Sekarang kita bisa melihat apa itu aktor garpu.  Ini kodenya: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fork_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx ) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx) } {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//     'free'. this &gt;&gt;= st_free; //   'free'    . st_free .event( [this]( mhood_t&lt;take_t&gt; cmd ) { this &gt;&gt;= st_taken; so_5::send&lt; taken_t &gt;( cmd-&gt;m_who ); } ); //   'taken'   . st_taken .event( [this]( mhood_t&lt;take_t&gt; cmd ) { //     . m_queue.push( cmd-&gt;m_who ); } ) .event( [this]( mhood_t&lt;put_t&gt; ) { if( m_queue.empty() ) //     . this &gt;&gt;= st_free; else { //      . const auto who = m_queue.front(); m_queue.pop(); so_5::send&lt; taken_t &gt;( who ); } } ); } private : //    . const state_t st_free{ this, "free" }; const state_t st_taken{ this, "taken" }; //   . std::queue&lt; so_5::mbox_t &gt; m_queue; };</span></span></code> </pre> <br><p>  Setiap aktor di SObjectizer harus diturunkan dari base class <code>agent_t</code> .  Apa yang kita lihat di sini untuk tipe <code>fork_t</code> . </p><br><p>  Metode <code>so_define_agent()</code> ditimpa di kelas <code>so_define_agent()</code> .  Ini adalah metode khusus, ini secara otomatis dipanggil oleh SObjectizer ketika mendaftarkan agen baru.  Dalam metode <code>so_define_agent()</code> , <code>so_define_agent()</code> "dikonfigurasikan" untuk bekerja di SObjectizer: status awal berubah, pesan yang diperlukan dilanggan. </p><br><p>  Setiap aktor di SObjectizer adalah mesin status dengan status (meskipun aktor hanya menggunakan satu status default).  Aktor <code>fork_t</code> memiliki dua status: <em>gratis</em> dan <em>diambil</em> .  Ketika seorang aktor dalam keadaan <em>bebas</em> , colokan dapat "ditangkap" oleh filsuf.  Dan setelah menangkap "fork", aktor <code>fork_t</code> harus masuk ke status yang <em>diambil</em> .  Di dalam kelas <code>fork_t</code> state diwakili oleh instance <code>st_free</code> dan <code>st_taken</code> tipe <code>state_t</code> khusus. </p><br><p>  Negara memungkinkan Anda memproses pesan masuk dengan cara berbeda.  Misalnya, dalam keadaan <em>bebas</em> , agen merespons hanya untuk <code>take_t</code> dan reaksi ini sangat sederhana: keadaan aktor berubah dan respon yang <code>taken_t</code> : </p><br><pre> <code class="cpp hljs">st_free .event( [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]( <span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span>&gt; cmd ) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_taken; so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span> &gt;( cmd-&gt;m_who ); } );</code> </pre> <br><p>  Sementara semua pesan lainnya, termasuk <code>put_t</code> dalam status <em>bebas</em> , diabaikan saja. </p><br><p>  Dalam status yang <em>diambil</em> , aktor memproses dua pesan, dan bahkan pesan <code>take_t</code> ia memproses secara berbeda: </p><br><pre> <code class="cpp hljs">st_taken .event( [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]( <span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span>&gt; cmd ) { m_queue.push( cmd-&gt;m_who ); } ) .event( [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]( <span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">put_t</span></span>&gt; ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_queue.empty() ) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_free; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> who = m_queue.front(); m_queue.pop(); so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span> &gt;( who ); } } );</code> </pre> <br><p>  Handler untuk <code>put_t</code> paling menarik di <code>put_t</code> : jika antrian para filsuf yang menunggu kosong, maka kita dapat kembali ke yang <em>gratis</em> , tetapi jika tidak kosong, yang pertama dari mereka perlu dikirim dengan <code>taken_t</code> . </p><br><h3 id="aktor-filosof">  Aktor filsuf </h3><br><p>  <a href="" rel="nofollow">Kode aktor-filsuf</a> jauh lebih banyak, jadi saya tidak akan memberikannya di sini sepenuhnya.  Kami hanya akan membahas fragmen yang paling signifikan. </p><br><p>  Seorang aktor-filsuf memiliki lebih banyak keadaan: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_thinking{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"thinking.normal"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_wait_left{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"wait_left"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_wait_right{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"wait_right"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_eating{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"eating"</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_done{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"done"</span></span> };</code> </pre> <br><p>  Aktor memulai karyanya dalam keadaan <em>berpikir</em> , kemudian beralih ke <em>wait_left</em> , lalu ke <em>wait_right</em> , lalu ke <em>makan</em> .  Dari <em>makan, seorang</em> aktor dapat kembali <em>berpikir</em> atau dapat <em>melakukan</em> jika filsuf telah makan semua yang seharusnya. </p><br><p>  Diagram keadaan untuk aktor-filsuf dapat direpresentasikan sebagai berikut: </p><br><p><img src="https://habrastorage.org/webt/ir/j0/sm/irj0smrzaedcsud20y71aynfqb4.png" alt="gambar"></p><br><p>  Logika perilaku aktor dijelaskan dalam penerapan metode <code>so_define_agent()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   thinking     stop_thinking. st_thinking .event( [=]( mhood_t&lt;stop_thinking_t&gt; ) { //    . this &gt;&gt;= st_wait_left; so_5::send&lt; take_t &gt;( m_left_fork, so_direct_mbox(), m_index ); } ); //        taken. st_wait_left .event( [=]( mhood_t&lt;taken_t&gt; ) { //     .   . this &gt;&gt;= st_wait_right; so_5::send&lt; take_t &gt;( m_right_fork, so_direct_mbox(), m_index ); } ); //    ,    taken. st_wait_right .event( [=]( mhood_t&lt;taken_t&gt; ) { //    ,  . this &gt;&gt;= st_eating; } ); //      stop_eating. st_eating // 'stop_eating'        'eating'. .on_enter( [=] { so_5::send_delayed&lt; stop_eating_t &gt;( *this, eat_pause() ); } ) .event( [=]( mhood_t&lt;stop_eating_t&gt; ) { //      . so_5::send&lt; put_t &gt;( m_right_fork ); so_5::send&lt; put_t &gt;( m_left_fork ); //     . ++m_meals_eaten; if( m_meals_count == m_meals_eaten ) this &gt;&gt;= st_done; //  ,  ,  . else think(); } ); st_done .on_enter( [=] { //   ,   . completion_watcher_t::done( so_environment(), m_index ); } ); }</span></span></code> </pre> <br><p>  Mungkin satu-satunya hal yang harus ditekankan adalah pendekatan untuk meniru proses "berpikir" dan "makan".  Tidak ada <code>this_thread::sleep_for</code> dalam kode aktor atau cara lain untuk memblokir utas yang saat ini aktif.  Sebaliknya, pesan yang tertunda digunakan.  Misalnya, ketika seorang aktor memasuki kondisi <em>makan</em> , ia mengirim pesan <code>stop_eating_t</code> tertunda ke dirinya sendiri.  Pesan ini diberikan ke timer SObjectizer dan timer mengirimkan pesan ke aktor ketika saatnya tiba. </p><br><p>  Menggunakan pesan tertunda memungkinkan Anda untuk menjalankan semua aktor dalam konteks utas tunggal.  Secara kasar, satu utas membaca pesan dari beberapa antrian dan menarik penangan pesan berikutnya dari aktor penerima yang sesuai.  Lebih lanjut tentang konteks kerja untuk para aktor akan dibahas di bawah ini. </p><br><h3 id="rezultaty">  Hasil </h3><br><p>  Hasil implementasi ini mungkin terlihat sebagai berikut (fragmen kecil): </p><br><pre> <code class="plaintext hljs"> Socrates: tttttttttttLRRRRRRRRRRRRRREEEEEEEttttttttLRRRRRRRRRRRRRREEEEEEEEEEEEE Plato: ttttttttttEEEEEEEEEEEEEEEEttttttttttRRRRRREEEEEEEEEEEEEEttttttttttLLL Aristotle: ttttEEEEEtttttttttttLLLLLLRRRREEEEEEEEEEEEttttttttttttLLEEEEEEEEEEEEE Descartes: tttttLLLLRRRRRRRREEEEEEEEEEEEEtttLLLLLLLLLRRRRREEEEEEttttttttttLLLLLL Spinoza: ttttEEEEEEEEEEEEEttttttttttLLLRRRREEEEEEEEEEEEEttttttttttRRRREEEEEEtt Kant: ttttttttttLLLLLLLRREEEEEEEEEEEEEEEttttttttttLLLEEEEEEEEEEEEEEtttttttt Schopenhauer: ttttttEEEEEEEEEEEEEttttttLLLLLLLLLEEEEEEEEEttttttttLLLLLLLLLLRRRRRRRR Nietzsche: tttttttttLLLLLLLLLLEEEEEEEEEEEEEttttttttLLLEEEEEEEEEttttttttRRRRRRRRE Wittgenstein: ttttEEEEEEEEEEtttttLLLLLLLLLLLLLEEEEEEEEEttttttttttttRRRREEEEEEEEEEEt Heidegger: tttttttttttLLLEEEEEEEEEEEEEEtttttttLLLLLLREEEEEEEEEEEEEEEtttLLLLLLLLR Sartre: tttEEEEEEEEEttttLLLLLLLLLLLLRRRRREEEEEEEEEtttttttLLLLLLLLRRRRRRRRRRRR</code> </pre> <br><p>  Baca ini sebagai berikut: </p><br><ul><li>  <code>t</code> menyatakan bahwa filsuf itu "berpikir"; </li><li>  <code>L</code> berarti bahwa filsuf mengharapkan untuk menangkap garpu kiri (dalam keadaan <em>wait_left</em> ); </li><li>  <code>R</code> berarti bahwa filsuf mengharapkan untuk menangkap garpu yang tepat (dalam status <em>wait_right</em> ) </li><li>  <code>E</code> berarti bahwa filsuf "makan." </li></ul><br><p>  Kita dapat melihat bahwa Socrates dapat mengambil garpu di sebelah kiri hanya setelah Sartre memberikannya.  Setelah itu Socrates akan menunggu sampai Plato melepaskan garpu yang tepat.  Hanya setelah ini Socrates akan dapat makan. </p><br><h2 id="prostoe-reshenie-bez-arbitra-oficianta">  Keputusan sederhana tanpa arbiter (pelayan) </h2><br><p>  Jika kita menganalisis hasil keputusan Dijkstra, kita akan melihat bahwa para filsuf menghabiskan banyak waktu menunggu penangkapan garpu.  Apa yang tidak baik, karena  waktu ini juga dapat digunakan untuk refleksi.  Bukan tanpa alasan bahwa ada pendapat bahwa jika Anda berpikir dengan perut kosong, Anda bisa mendapatkan hasil yang jauh lebih menarik dan tak terduga;) </p><br><p>  Mari kita lihat solusi paling sederhana di mana filsuf mengembalikan garpu yang ditangkap pertama jika dia tidak bisa menangkap yang kedua (dalam artikel "filsuf makan modern" yang disebutkan di atas, solusi ini diterapkan oleh ForkLevelPhilosopherProtocol). </p><br><p>  Kode sumber untuk implementasi ini dapat dilihat di <a href="" rel="nofollow">sini</a> , dan kode untuk aktor filsuf terkait di <a href="" rel="nofollow">sini</a> . </p><br><h3 id="soobscheniya-1">  Pesan </h3><br><p>  Solusi ini menggunakan sekumpulan pesan yang hampir sama: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">take_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> m_who; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> m_philosopher_index; }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">busy_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">taken_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">put_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">signal_t</span></span> {};</code> </pre> <br><p>  Satu-satunya perbedaan adalah kehadiran sinyal <code>busy_t</code> .  Garpu aktor-mengirimkan sinyal ini sebagai tanggapan terhadap filsuf-aktor jika garpu sudah ditangkap oleh filsuf lain. </p><br><h3 id="aktor-vilka-1">  Garpu aktor </h3><br><p>  Aktor fork dalam solusi ini bahkan lebih sederhana daripada solusi Dijkstra: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fork_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx ) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>( ctx ) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_free; st_free.event( [<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>]( <span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span>&gt; cmd ) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_taken; so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span> &gt;( cmd-&gt;m_who ); } ); st_taken.event( []( <span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span>&gt; cmd ) { so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">busy_t</span></span> &gt;( cmd-&gt;m_who ); } ) .just_switch_to&lt; <span class="hljs-keyword"><span class="hljs-keyword">put_t</span></span> &gt;( st_free ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_free{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> st_taken{ <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> }; };</code> </pre> <br><p>  Di sini kita bahkan tidak perlu menjaga garis para filsuf yang menunggu. </p><br><h3 id="aktor-filosof-1">  Aktor filsuf </h3><br><p>  Filsuf-aktor dalam implementasi ini mirip dengan solusi Dijkstra, tetapi di sini filsuf-aktor harus memproses <code>busy_t</code> , sehingga diagram negara terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/webt/xa/ek/c8/xaekc8xbxewoj1e7myao4le6jn0.png" alt="gambar"></p><br><p>  Demikian pula, seluruh logika aktor-filsuf didefinisikan dalam <code>so_define_agent()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">so_define_agent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ st_thinking .event&lt; <span class="hljs-keyword"><span class="hljs-keyword">stop_thinking_t</span></span> &gt;( [=] { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_wait_left; so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span> &gt;( m_left_fork, so_direct_mbox(), m_index ); } ); st_wait_left .event&lt; <span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span> &gt;( [=] { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_wait_right; so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span> &gt;( m_right_fork, so_direct_mbox(), m_index ); } ) .event&lt; <span class="hljs-keyword"><span class="hljs-keyword">busy_t</span></span> &gt;( [=] { think( st_hungry_thinking ); } ); st_wait_right .event&lt; <span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span> &gt;( [=] { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_eating; } ) .event&lt; <span class="hljs-keyword"><span class="hljs-keyword">busy_t</span></span> &gt;( [=] { so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">put_t</span></span> &gt;( m_left_fork ); think( st_hungry_thinking ); } ); st_eating .on_enter( [=] { so_5::send_delayed&lt; <span class="hljs-keyword"><span class="hljs-keyword">stop_eating_t</span></span> &gt;( *<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, eat_pause() ); } ) .event&lt; <span class="hljs-keyword"><span class="hljs-keyword">stop_eating_t</span></span> &gt;( [=] { so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">put_t</span></span> &gt;( m_right_fork ); so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">put_t</span></span> &gt;( m_left_fork ); ++m_meals_eaten; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_meals_count == m_meals_eaten ) <span class="hljs-keyword"><span class="hljs-keyword">this</span></span> &gt;&gt;= st_done; <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> think( st_normal_thinking ); } ); st_done .on_enter( [=] { <span class="hljs-keyword"><span class="hljs-keyword">completion_watcher_t</span></span>::done( so_environment(), m_index ); } ); }</code> </pre> <br><p>  Secara umum, ini hampir kode yang sama seperti dalam solusi Dijkstra, kecuali untuk beberapa penangan untuk <code>busy_t</code> . </p><br><h3 id="rezultaty-1">  Hasil </h3><br><p>  Hasil pekerjaan terlihat berbeda: </p><br><pre> <code class="plaintext hljs"> Socrates: tttttttttL..R.....EEEEEEEEEEEEttttttttttR...LL..EEEEEEEttEEEEEE Plato: ttttEEEEEEEEEEEttttttL.....L..EEEEEEEEEEEEEEEttttttttttL....L.... Aristotle: ttttttttttttL..LR.EEEEEEtttttttttttL..L....L....R.....EEEEEEEEE Descartes: ttttttttttEEEEEEEEttttttttttttEEEEEEEEttttEEEEEEEEEEEttttttL..L.. Spinoza: ttttttttttL.....L...EEEEEEtttttttttL.L......L....L..L...R...R...E Kant: tttttttEEEEEEEttttttttL.L.....EEEEEEEEttttttttR...R..R..EEEEEtttt Schopenhauer: tttR..R..L.....EEEEEEEttttttR.....L...EEEEEEEEEEEEEEEEttttttttttt Nietzsche: tttEEEEEEEEEEtttttttttEEEEEEEEEEEEEEEttttL....L...L..L....EEEEEEE Wittgenstein: tttttL.L..L.....RR....L.....L....L...EEEEEEEEEEEEEEEtttttttttL. Heidegger: ttttR..R......EEEEEEEEEEEEEttttttttttR..L...L...L..L...EEEEtttttt Sartre: tttEEEEEEEtttttttL..L...L....R.EEEEEEEtttttEEEEtttttttR.....R..R.</code> </pre> <br><p>  Di sini kita melihat simbol baru, yang berarti bahwa aktor-filsuf dalam "pikiran lapar". </p><br><p>  Bahkan dalam fragmen pendek ini, orang dapat melihat bahwa ada periode waktu yang lama di mana filsuf tidak dapat makan.  Ini karena solusi ini dilindungi dari masalah kebuntuan, tetapi tidak memiliki perlindungan terhadap kelaparan. </p><br><h2 id="reshenie-s-oficiantom-i-ocheredyu">  Keputusan dengan pelayan dan antrian </h2><br><p>  Solusi paling sederhana yang ditunjukkan di atas tanpa arbiter tidak melindungi terhadap kelaparan.  Artikel "filsuf makan modern" yang disebutkan di atas berisi solusi untuk masalah puasa dalam bentuk protokol WaiterFair.  Intinya adalah bahwa ada seorang wasit (pelayan), yang menjadi tujuan para filsuf ketika mereka ingin makan.  Dan pelayan memiliki antrian aplikasi dari para filsuf.  Dan sang filsuf mendapat garpu hanya jika kedua garunya gratis sekarang, dan tidak ada tetangga dari filsuf yang menoleh ke pelayan di antrian. </p><br><p>  Mari kita lihat bagaimana solusi yang sama ini terlihat pada para aktor. </p><br><p>  Kode sumber untuk implementasi ini dapat ditemukan di <a href="" rel="nofollow">sini</a> . </p><br><h3 id="tryuk">  Trick </h3><br><p>  Cara termudah adalah dengan memperkenalkan satu set pesan baru di mana para filsuf dapat berkomunikasi dengan pelayan.  Tapi saya ingin menyimpan tidak hanya set pesan yang sudah ada (mis. <code>take_t</code> , <code>taken_t</code> , <code>busy_t</code> , <code>put_t</code> ).  Saya juga ingin aktor-filsuf yang sama untuk digunakan seperti dalam solusi sebelumnya.  Oleh karena itu, saya harus menyelesaikan masalah yang rumit: bagaimana membuat aktor-filsuf berkomunikasi dengan satu-satunya aktor-pelayan, tetapi pada saat yang sama berpikir bahwa ia berinteraksi langsung dengan garpu aktor (yang sudah hilang). </p><br><p>  Masalah ini diselesaikan dengan menggunakan trik sederhana: seorang aktor-pelayan menciptakan seperangkat mbox-s, tautan yang diberikan kepada aktor-filsuf sebagai tautan ke mbox-s dari aktor-aktor garpu.  Pada saat yang sama, aktor-pelayan berlangganan pesan dari semua mboxes ini (yang mudah diimplementasikan dalam SObjectizer, karena SObjectizer adalah implementasi tidak hanya / karena banyak Model Aktor, tetapi juga Pub / Sub didukung di luar kotak) . </p><br><p>  Dalam kode, tampilannya seperti ini: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">waiter_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">waiter_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">context_t</span></span> ctx, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> forks_count ) : so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(ctx) } , m_fork_states( forks_count, <span class="hljs-keyword"><span class="hljs-keyword">fork_state_t</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">free</span></span> ) { <span class="hljs-comment"><span class="hljs-comment">//  mbox-   "" m_fork_mboxes.reserve( forks_count ); for( std::size_t i{}; i != forks_count; ++i ) m_fork_mboxes.push_back( so_environment().create_mbox() ); } ... void so_define_agent() override { //      "". for( std::size_t i{}; i != m_fork_mboxes.size(); ++i ) { //     .   . //          //    . so_subscribe( fork_mbox( i ) ) .event( [i, this]( mhood_t&lt;take_t&gt; cmd ) { on_take_fork( std::move(cmd), i ); } ) .event( [i, this]( mhood_t&lt;put_t&gt; cmd ) { on_put_fork( std::move(cmd), i ); } ); } } private : ... //     "". std::vector&lt; so_5::mbox_t &gt; m_fork_mboxes;</span></span></code> </pre> <br><p>  Yaitu  Pertama, buat vektor mbox-s untuk "garpu" yang tidak ada, kemudian berlangganan masing-masing.  Ya, kami berlangganan untuk mengetahui plug mana yang terkait dengan permintaan tersebut. </p><br><p>  Penangan asli untuk permintaan masuk <code>on_take_fork()</code> adalah metode <code>on_take_fork()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">on_take_fork</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mhood_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">take_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt; cmd, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fork_index )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//   ,       //    . if( fork_index == cmd-&gt;m_philosopher_index ) handle_take_left_fork( std::move(cmd), fork_index ); else handle_take_right_fork( std::move(cmd), fork_index ); }</span></span></code> </pre> <br><p>  Ngomong-ngomong, di sinilah kami membutuhkan bidang kedua dari pesan <code>take_t</code> . </p><br><p>  Jadi, di <code>on_take_fork()</code> kami memiliki permintaan asli dan indeks garpu yang terkait dengan permintaan tersebut.  Karena itu, kita dapat menentukan apakah filsuf meminta garpu kiri atau garpu kanan.  Dan, karenanya, kita dapat memprosesnya secara berbeda (dan kita harus memprosesnya secara berbeda). </p><br><p>  Karena filsuf selalu pertama-tama meminta garpu kiri, maka kita perlu melakukan semua pemeriksaan yang diperlukan pada saat ini.  Dan kita dapat menemukan diri kita dalam salah satu situasi berikut: </p><br><ol><li>  Kedua garpu gratis dan dapat diberikan kepada filsuf yang mengirim permintaan.  Dalam hal ini, kami <code>taken_t</code> filsuf, dan menandai garpu kanan sebagai cadangan sehingga tidak ada orang lain yang dapat mengambilnya. </li><li>  Garpu tidak dapat diberikan kepada filsuf.  Tidak peduli mengapa  Mungkin beberapa dari mereka sedang sibuk sekarang.  Atau sejalan adalah salah satu tetangga filsuf.  Bagaimanapun, kami menempatkan filsuf yang mengirim permintaan dalam antrian, setelah itu kami <code>busy_t</code> kepadanya. </li></ol><br><p>  Berkat logika kerja ini, filsuf yang menerima <code>taken_t</code> untuk garpu kiri dapat dengan aman mengirim permintaan <code>take_t</code> untuk garpu kanan.  Permintaan ini akan segera dipenuhi, karena  garpu sudah disediakan untuk filsuf ini. </p><br><h3 id="rezultaty-2">  Hasil </h3><br><p>  Jika Anda menjalankan solusi yang dihasilkan, Anda dapat melihat sesuatu seperti: </p><br><pre> <code class="plaintext hljs"> Socrates: tttttttttttL....EEEEEEEEEEEEEEttttttttttL...L...EEEEEEEEEEEEEtttttL. Plato: tttttttttttL....L..L..L...L...EEEEEEEEEEEEEtttttL.....L....L.....EEE Aristotle: tttttttttL.....EEEEEEEEEttttttttttL.....L.....EEEEEEEEEEEtttL....LL Descartes: ttEEEEEEEEEEtttttttL.L..EEEEEEEEEEEEtttL..L....L....L.....EEEEEEEEEE Spinoza: tttttttttL.....EEEEEEEEEttttttttttL.....L.....EEEEEEEEEEEtttL....LL Kant: ttEEEEEEEEEEEEEtttttttL...L.....L.....EEEEEttttL....L...L..L...EEEEE Schopenhauer: ttttL...L.....L.EEEEEEEEEEEEEEEEEtttttttttttL..L...L..EEEEEEEttttttt Nietzsche: tttttttttttL....L..L..L...L...L.....L....EEEEEEEEEEEEttL.....L...L.. Wittgenstein: tttttttttL....L...L....L....L...EEEEEEEttttL......L.....L.....EEEEEE Heidegger: ttttttL..L...L.....EEEEEEEEEEEEtttttL...L..L.....EEEEEEEEEEEttttttL. Sartre: ttEEEEEEEEEEEEEttttttttL.....L...EEEEEEEEEEEEttttttttttttL.....EEEEE</code> </pre> <br><p>  Anda dapat memperhatikan kurangnya karakter <code>R</code>  Ini karena kegagalan atau harapan tidak dapat terjadi pada permintaan garpu yang tepat. </p><br><h2 id="esche-odno-reshenie-s-ispolzovaniem-arbitra-oficianta">  Keputusan lain menggunakan arbiter (pelayan) </h2><br><p>  Dalam beberapa kasus, solusi waiter_with_queue sebelumnya dapat menampilkan hasil yang mirip dengan yang ini: </p><br><pre> <code class="plaintext hljs"> Socrates: tttttEEEEEEEEEEEEEEtttL.....LL...L....EEEEEEEEEttttttttttL....L.....EE Plato: tttttL..L..L....LL...EEEEEEEEEEEEEEEttttttttttttL.....EEEEEEEEEttttttt Aristotle: tttttttttttL..L...L.....L.....L....L.....EEEEEEEEEEEEtttttttttttL....L.. Descartes: ttttttttttEEEEEEEEEEttttttL.....L....L..L.....L.....L..L...L..EEEEEEEEtt Spinoza: tttttttttttL..L...L.....L.....L....L.....L..L..L....EEEEEEEEEEtttttttttt Kant: tttttttttL....L....L...L...L....L..L...EEEEEEEEEEEttttttttttL...L......E Schopenhauer: ttttttL....L..L...L...LL...L...EEEEEtttttL....L...L.....EEEEEEEEEttttt Nietzsche: tttttL..L..L....EEEEEEEEEEEEEttttttttttttEEEEEEEEEEEEEEEttttttttttttL... Wittgenstein: tttEEEEEEEEEEEEtttL....L....L..EEEEEEEEEtttttL..L..L....EEEEEEEEEEEEEEEE Heidegger: tttttttttL...L..EEEEEEEEttttL..L.....L...EEEEEEEEEtttL.L..L...L....L...L Sartre: ttttttttttL..L....L...L.EEEEEEEEEEEtttttL...L..L....EEEEEEEEEEtttttttttt</code> </pre> <br><p>  Anda dapat melihat keberadaan periode waktu yang cukup lama ketika para filsuf tidak dapat makan walaupun ada garpu gratis.  Misalnya, garpu kiri dan kanan untuk Kant gratis untuk waktu yang lama, tetapi Kant tidak dapat mengambilnya, karena  tetangganya sudah mengantri.  Yang sedang menunggu tetangga mereka.  Siapa yang menunggu tetangga mereka, dll. </p><br><p>  Oleh karena itu, implementasi dari wait_with_queue yang dibahas di atas melindungi terhadap kelaparan dalam arti bahwa cepat atau lambat filsuf akan makan.  Ini dijamin untuknya.  Tetapi periode puasa bisa sangat lama.  Dan pemanfaatan sumber daya mungkin tidak optimal. </p><br><p>  Untuk mengatasi masalah ini, saya menerapkan solusi lain, waiter_with_timestamp (kodenya dapat ditemukan di <a href="" rel="nofollow">sini</a> ).  Alih-alih mengantri, mereka memprioritaskan permintaan dari para filsuf dengan mempertimbangkan waktu puasa mereka.  Semakin lama filsuf kelaparan, semakin prioritas permintaannya. </p><br><p>  Kami tidak akan mempertimbangkan kode untuk solusi ini, karena  pada umumnya hal utama di dalamnya adalah trik yang sama dengan seperangkat mbox untuk "garpu" yang tidak ada, yang sudah kita bahas dalam percakapan tentang penerapan waiter_with_queue. </p><br><h2 id="neskolko-detaley-realizacii-na-kotorye-hotelos-by-obratit-vnimanie">  Beberapa detail implementasi yang ingin saya perhatikan </h2><br><p>  Ada beberapa detail dalam implementasi berdasarkan Aktor yang ingin saya perhatikan, karena  detail ini menunjukkan fitur menarik dari SObjectizer. </p><br><h3 id="rabochiy-kontekst-dlya-aktorov">  Konteks kerja untuk para aktor </h3><br><p>  Dalam implementasi yang dipertimbangkan, semua aktor utama ( <code>fork_t</code> , <code>philosopher_t</code> , <code>waiter_t</code> ) bekerja pada konteks satu utas kerja umum.  Yang tidak berarti sama sekali bahwa dalam SObjectizer semua aktor bekerja hanya pada satu utas tunggal.  Dalam SObjectizer Anda dapat mengikat aktor ke konteks yang berbeda, yang dapat dilihat, misalnya, dalam kode fungsi <code>run_simulation()</code> dalam solusi no_waiter_simple. </p><br><div class="spoiler">  <b class="spoiler_title">Run_simulation kode dari no_waiter_simple</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run_simulation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">environment_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; env, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">names_holder_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; names )</span></span></span><span class="hljs-function"> </span></span>{ env.introduce_coop( [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop ) { coop.make_agent_with_binder&lt; <span class="hljs-keyword"><span class="hljs-keyword">trace_maker_t</span></span> &gt;( so_5::disp::one_thread::create_private_disp( env )-&gt;binder(), names, <span class="hljs-keyword"><span class="hljs-keyword">random_pause_generator_t</span></span>::trace_step() ); coop.make_agent_with_binder&lt; <span class="hljs-keyword"><span class="hljs-keyword">completion_watcher_t</span></span> &gt;( so_5::disp::one_thread::create_private_disp( env )-&gt;binder(), names ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> count = names.size(); <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> * &gt; forks( count, <span class="hljs-literal"><span class="hljs-literal">nullptr</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != count; ++i ) forks[ i ] = coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">fork_t</span></span> &gt;(); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != count; ++i ) coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span> &gt;( i, forks[ i ]-&gt;so_direct_mbox(), forks[ (i + <span class="hljs-number"><span class="hljs-number">1</span></span>) % count ]-&gt;so_direct_mbox(), default_meals_count ); }); }</code> </pre> </div></div><br><p>  Dalam fungsi ini, aktor tambahan dari tipe <code>trace_maker_t</code> dan <code>completion_watcher_t</code> .  Mereka akan bekerja pada konteks pekerjaan individu.  Untuk melakukan ini, dua instance dari dispatcher dari tipe <code>one_thread</code> dan para aktor terikat pada instance dari dispatcher ini.  Yang berarti bahwa para aktor ini akan berfungsi sebagai <em>objek aktif</em> : masing-masing akan memiliki utas kerjanya sendiri. </p><br><p>  SObjectizer menyediakan satu set beberapa dispatcher berbeda yang dapat digunakan langsung di luar kotak.  Dalam hal ini, pengembang dapat membuat dalam aplikasinya sebanyak contoh operator yang dibutuhkan pengembang. </p><br><p>    ,        ,       . ,      <code>fork_t</code>     ,   <code>philosopher_t</code>   . </p><br><div class="spoiler"> <b class="spoiler_title"> run_simulation  no_waiter_simple_tp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run_simulation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">environment_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; env, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">names_holder_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; names )</span></span></span><span class="hljs-function"> </span></span>{ env.introduce_coop( [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop ) { coop.make_agent_with_binder&lt; <span class="hljs-keyword"><span class="hljs-keyword">trace_maker_t</span></span> &gt;( so_5::disp::one_thread::create_private_disp( env )-&gt;binder(), names, <span class="hljs-keyword"><span class="hljs-keyword">random_pause_generator_t</span></span>::trace_step() ); coop.make_agent_with_binder&lt; <span class="hljs-keyword"><span class="hljs-keyword">completion_watcher_t</span></span> &gt;( so_5::disp::one_thread::create_private_disp( env )-&gt;binder(), names ); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> count = names.size(); <span class="hljs-comment"><span class="hljs-comment">//     thread_pool-. so_5::disp::thread_pool::bind_params_t bind_params; bind_params.fifo( so_5::disp::thread_pool::fifo_t::individual ); std::vector&lt; so_5::agent_t * &gt; forks( count, nullptr ); //     -. auto fork_disp = so_5::disp::thread_pool::create_private_disp( env, 3u //  . ); for( std::size_t i{}; i != count; ++i ) //      . forks[ i ] = coop.make_agent_with_binder&lt; fork_t &gt;( fork_disp-&gt;binder( bind_params ) ); //     -. auto philosopher_disp = so_5::disp::thread_pool::create_private_disp( env, 6u //  . ); for( std::size_t i{}; i != count; ++i ) coop.make_agent_with_binder&lt; philosopher_t &gt;( philosopher_disp-&gt;binder( bind_params ), i, forks[ i ]-&gt;so_direct_mbox(), forks[ (i + 1) % count ]-&gt;so_direct_mbox(), default_meals_count ); }); }</span></span></code> </pre> </div></div><br><p>            <code>fork_t</code>  <code>philosopher_t</code> . </p><br><h3 id="trassirovka-smeny-sostoyaniy-aktorov">     </h3><br><p>          <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">Modern dining philosophers</a>    ,     , : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doEat</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ eventLog_.startActivity(ActivityType::eat); wait(randBetween(<span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">50</span></span>)); eventLog_.endActivity(ActivityType::eat);</code> </pre> <br><p>          SObjectizer   .  ,   , .  Karena apa? </p><br><p>   ,   SObjectizer-   :   .       <code>agent_state_listener_t</code> .     ,  SObjectizer        . </p><br><p>        <code>greedy_philosopher_t</code>  <code>philosopher_t</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">philosopher_t</span></span>(...) ... { so_add_destroyable_listener( <span class="hljs-keyword"><span class="hljs-keyword">state_watcher_t</span></span>::make( so_environment(), index ) ); }</code> </pre> <br><p>  <code>state_watcher_t</code> —       . </p><br><div class="spoiler"> <b class="spoiler_title"> state_watcher_t</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">state_watcher_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_state_listener_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> m_mbox; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> m_index; <span class="hljs-keyword"><span class="hljs-keyword">state_watcher_t</span></span>( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> mbox, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> index ); <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">auto</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">make</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">environment_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; env, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_state_listener_unique_ptr_t</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">state_watcher_t</span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">trace_maker_t</span></span>::make_mbox(env), index } }; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">changed</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">agent_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp;, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">state_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; state )</span></span></span><span class="hljs-function"> override</span></span>; };</code> </pre> </div></div><br><p>   <code>state_watcher_t</code>    SObjectizer   <code>changed()</code>    .    <code>state_watcher_t::changed</code>      -. </p><br><div class="spoiler"> <b class="spoiler_title">  state_watcher_t::changed</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> <span class="hljs-keyword"><span class="hljs-keyword">state_watcher_t</span></span>::changed( so_5::<span class="hljs-keyword"><span class="hljs-keyword">agent_t</span></span> &amp;, <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">state_t</span></span> &amp; state ) { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> detect_label = []( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> &amp; name ) {...}; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> state_label = detect_label( state.query_name() ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-string"><span class="hljs-string">'?'</span></span> == state_label ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; so_5::send&lt; trace::<span class="hljs-keyword"><span class="hljs-keyword">state_changed_t</span></span> &gt;( m_mbox, m_index, state_label ); }</code> </pre> </div></div><br><h1 id="resheniya-na-baze-csp">    CSP </h1><br><p>     ,     .       (no_waiter_dijkstra, no_waiter_simple, waiter_with_timestamps)     <code>std::thread</code>  SObjectizer- mchain- (,  ,  CSP- ). ,  ,  CSP-        (   <code>take_t</code> , <code>taken_t</code> , <code>busy_t</code> , <code>put_t</code> ). </p><br><p>  CSP-  ""   .   ,         <code>std::thread</code> . </p><br><h2 id="reshenie-deykstry-1">   </h2><br><p>       <a href="" rel="nofollow"></a> . </p><br><h3 id="nit-dlya-vilki">    </h3><br><p>         :       +    <code>take_t</code>  <code>put_t</code> .    <code>fork_process</code>  : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fork_process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fork_ch )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  :   . bool taken = false; //   . std::queue&lt; so_5::mbox_t &gt; wait_queue; //        . so_5::receive( so_5::from( fork_ch ), [&amp;]( so_5::mhood_t&lt;take_t&gt; cmd ) { if( taken ) //  ,     . wait_queue.push( cmd-&gt;m_who ); else { //    . taken = true; so_5::send&lt; taken_t &gt;( cmd-&gt;m_who ); } }, [&amp;]( so_5::mhood_t&lt;put_t&gt; ) { if( wait_queue.empty() ) taken = false; //     . else { //       . const auto who = wait_queue.front(); wait_queue.pop(); so_5::send&lt; taken_t &gt;( who ); } } ); }</span></span></code> </pre> <br><p>   <code>fork_process</code>   :  ,   -   . </p><br><p>    <code>fork_process</code> —  ""       ,     .        <code>receive()</code> : </p><br><pre> <code class="cpp hljs">so_5::receive( so_5::from( fork_ch ), [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span>&gt; cmd ) {...}, [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">put_t</span></span>&gt; ) {...} );</code> </pre> <br><p>  SObjectizer-     <code>receive()</code>       .           .      .   ,      .   ,    . </p><br><p>      -.           <code>fork_t</code>     . ,  ,  . </p><br><h3 id="nit-dlya-filosofa">    </h3><br><p>       <code>philosopher_process</code> .      ,        . </p><br><div class="spoiler"> <b class="spoiler_title">  philosopher_process</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">oid </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">philosopher_process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">trace_maker_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; tracer, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> control_ch, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> philosopher_index, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left_fork, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right_fork, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> meals_count )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> meals_eaten{ <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">random_pause_generator_t</span></span> pause_generator; <span class="hljs-comment"><span class="hljs-comment">//         . auto self_ch = so_5::create_mchain( control_ch-&gt;environment() ); while( meals_eaten &lt; meals_count ) { tracer.thinking_started( philosopher_index, thinking_type_t::normal ); //    . std::this_thread::sleep_for( pause_generator.think_pause( thinking_type_t::normal ) ); //    . tracer.take_left_attempt( philosopher_index ); so_5::send&lt; take_t &gt;( left_fork, self_ch-&gt;as_mbox(), philosopher_index ); //  ,  . so_5::receive( so_5::from( self_ch ).handle_n( 1u ), [&amp;]( so_5::mhood_t&lt;taken_t&gt; ) { //   ,   . tracer.take_right_attempt( philosopher_index ); so_5::send&lt; take_t &gt;( right_fork, self_ch-&gt;as_mbox(), philosopher_index ); //  ,  . so_5::receive( so_5::from( self_ch ).handle_n( 1u ), [&amp;]( so_5::mhood_t&lt;taken_t&gt; ) { //    .  . tracer.eating_started( philosopher_index ); //     . std::this_thread::sleep_for( pause_generator.eat_pause() ); //     . ++meals_eaten; //     . so_5::send&lt; put_t &gt;( right_fork ); } ); //     . so_5::send&lt; put_t &gt;( left_fork ); } ); } //   ,   . tracer.philosopher_done( philosopher_index ); so_5::send&lt; philosopher_done_t &gt;( control_ch, philosopher_index ); }</span></span></code> </pre> </div></div><br><p>     : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">philosopher_process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">trace_maker_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; tracer, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> control_ch, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> philosopher_index, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left_fork, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right_fork, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> meals_count )</span></span></span></span></code> </pre> <br><p>         . </p><br><p>     SObjectizer- ,             ,       Actor-.         : </p><br><pre> <code class="cpp hljs">tracer.thinking_started( philosopher_index, <span class="hljs-keyword"><span class="hljs-keyword">thinking_type_t</span></span>::normal );</code> </pre> <br><p>   <code>tracer</code>      ,     . </p><br><p>  <code>control_ch</code>  ,       <code>philosopher_done_t</code>  ,    ,   .            . </p><br><p>  <code>left_fork</code>  <code>right_fork</code>      .        <code>take_t</code>  <code>put_t</code> .    ,     <code>mbox_t</code>  <code>mchain_t</code> ? </p><br><p>   !       ,    .    ,  mchain —  -   mbox-,    mchain-     <code>mbox_t</code> . </p><br><p>    ,    : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> meals_eaten{ <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">random_pause_generator_t</span></span> pause_generator; <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> self_ch = so_5::create_mchain( control_ch-&gt;environment() );</code> </pre> <br><p>     —  <code>self_ch</code> .    ,         . </p><br><p>           .  Yaitu       ,     . </p><br><p>  ,        ,       <code>this_thread::sleep_for</code>   . </p><br><p>       ,      : </p><br><pre> <code class="cpp hljs">so_5::send&lt; <span class="hljs-keyword"><span class="hljs-keyword">take_t</span></span> &gt;( left_fork, self_ch-&gt;as_mbox(), philosopher_index );</code> </pre> <br><p>       <code>take_t</code> .       <code>mbox_t</code> ,   <code>self_ch</code>   <code>mchain_t</code> .              <code>as_mbox()</code> . </p><br><p>     <code>receive()</code> : </p><br><pre> <code class="cpp hljs">so_5::receive( so_5::from( self_ch ).handle_n( <span class="hljs-number"><span class="hljs-number">1u</span></span> ), [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span>&gt; ) {...} );</code> </pre> <br><p>         <code>taken_t</code>    .      .  ,         . </p><br><p>  -   ,       <code>philosopher_process</code> .        <code>receive()</code>      : </p><br><pre> <code class="cpp hljs">so_5::receive( so_5::from( self_ch ).handle_n( <span class="hljs-number"><span class="hljs-number">1u</span></span> ), [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span>&gt; ) { ... so_5::receive( so_5::from( self_ch ).handle_n( <span class="hljs-number"><span class="hljs-number">1u</span></span> ), [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span>&gt; ) {...} ); ... } );</code> </pre> <br><p>           -  . </p><br><h3 id="funkciya-zapuska-simulyacii">    </h3><br><p>             <code>run_simulation()</code> ,         .      CSP-  <code>run_simulation()</code>   .     ,       ,       (      ). </p><br><div class="spoiler"> <b class="spoiler_title">   run_simulation</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run_simulation</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">environment_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; env, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">names_holder_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; names )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> table_size = names.size(); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> join_all = []( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread&gt; &amp; threads ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; t : threads ) t.join(); }; <span class="hljs-keyword"><span class="hljs-keyword">trace_maker_t</span></span> tracer{ env, names, <span class="hljs-keyword"><span class="hljs-keyword">random_pause_generator_t</span></span>::trace_step() }; <span class="hljs-comment"><span class="hljs-comment">//  . std::vector&lt; so_5::mchain_t &gt; fork_chains; std::vector&lt; std::thread &gt; fork_threads( table_size ); for( std::size_t i{}; i != table_size; ++i ) { //     . fork_chains.emplace_back( so_5::create_mchain(env) ); //     . fork_threads[ i ] = std::thread{ fork_process, fork_chains.back() }; } //      . auto control_ch = so_5::create_mchain( env ); //  . const auto philosopher_maker = [&amp;](auto index, auto left_fork_idx, auto right_fork_idx) { return std::thread{ philosopher_process, std::ref(tracer), control_ch, index, fork_chains[ left_fork_idx ]-&gt;as_mbox(), fork_chains[ right_fork_idx ]-&gt;as_mbox(), default_meals_count }; }; std::vector&lt; std::thread &gt; philosopher_threads( table_size ); for( std::size_t i{}; i != table_size - 1u; ++i ) { //      . philosopher_threads[ i ] = philosopher_maker( i, i, i+1u ); } //        . philosopher_threads[ table_size - 1u ] = philosopher_maker( table_size - 1u, table_size - 1u, 0u ); //     . so_5::receive( so_5::from( control_ch ).handle_n( table_size ), [&amp;names]( so_5::mhood_t&lt;philosopher_done_t&gt; cmd ) { fmt::print( "{}: done\n", names[ cmd-&gt;m_philosopher_index ] ); } ); //     . join_all( philosopher_threads ); //     . for( auto &amp; ch : fork_chains ) so_5::close_drop_content( ch ); //       . join_all( fork_threads ); //  . tracer.done(); //   SObjectizer. env.stop(); }</span></span></code> </pre> </div></div><br><p>  ,    <code>run_simulation()</code>   - .      . </p><br><p>      .        : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; so_5::<span class="hljs-keyword"><span class="hljs-keyword">mchain_t</span></span> &gt; fork_chains; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread &gt; fork_threads( table_size ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != table_size; ++i ) { fork_chains.emplace_back( so_5::create_mchain(env) ); fork_threads[ i ] = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread{ fork_process, fork_chains.back() }; }</code> </pre> <br><p>       ,   ,    .         .      ,    <code>join</code>  . </p><br><p>                , ..      <code>join</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread &gt; philosopher_threads( table_size ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != table_size - <span class="hljs-number"><span class="hljs-number">1u</span></span>; ++i ) { philosopher_threads[ i ] = philosopher_maker( i, i, i+<span class="hljs-number"><span class="hljs-number">1u</span></span> ); } philosopher_threads[ table_size - <span class="hljs-number"><span class="hljs-number">1u</span></span> ] = philosopher_maker( table_size - <span class="hljs-number"><span class="hljs-number">1u</span></span>, table_size - <span class="hljs-number"><span class="hljs-number">1u</span></span>, <span class="hljs-number"><span class="hljs-number">0u</span></span> );</code> </pre> <br><p>          .        : </p><br><pre> <code class="cpp hljs">so_5::receive( so_5::from( control_ch ).handle_n( table_size ), [&amp;names]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">philosopher_done_t</span></span>&gt; cmd ) { fmt::print( <span class="hljs-string"><span class="hljs-string">"{}: done\n"</span></span>, names[ cmd-&gt;m_philosopher_index ] ); } );</code> </pre> <br><p>   <code>receive()</code>      <code>table_size</code>   <code>philosopher_done_t</code> . </p><br><p>      <code>philosopher_done_t</code>    . </p><br><p>  <code>join</code>     : </p><br><pre> <code class="cpp hljs">join_all( philosopher_threads );</code> </pre> <br><p>     <code>join</code>    .    <code>join</code> , ..    .        <code>receive()</code>     .              <code>join</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; ch : fork_chains ) so_5::close_drop_content( ch ); join_all( fork_threads );</code> </pre> <br><p>          . </p><br><h4 id="neskolko-slov-o-noexcept">    noexcept </h4><br><p> ,   <code>run_simulation</code>        ,      <em>noexcept</em> .   ,    exception-safety     .            —     . </p><br><p>   <code>run_simulation</code>       ? </p><br><p>  ,                .    - exception-safety      ,    .  -  ,            : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != table_size; ++i ) { fork_chains.emplace_back( so_5::create_mchain(env) ); fork_threads[ i ] = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread{ fork_process, fork_chains.back() }; } } <span class="hljs-keyword"><span class="hljs-keyword">catch</span></span>( ... ) { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != fork_chains.size(); ++i ) { so_5::close_drop_content( fork_chains[ i ] ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( fork_threads[ i ].joinable() ) fork_threads[ i ].join(); } <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span>; }</code> </pre> <br><p>  ,     .  Karena         ,       .    -   : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">fork_threads_stuff_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; so_5::<span class="hljs-keyword"><span class="hljs-keyword">mchain_t</span></span> &gt; m_fork_chains; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread &gt; m_fork_threads; <span class="hljs-keyword"><span class="hljs-keyword">fork_threads_stuff_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> table_size ) : m_fork_threads( table_size ) {} ~<span class="hljs-keyword"><span class="hljs-keyword">fork_threads_stuff_t</span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != m_fork_chains.size(); ++i ) { so_5::close_drop_content( m_fork_chains[ i ] ); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( m_fork_threads[ i ].joinable() ) m_fork_threads[ i ].join(); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> i{}; i != m_fork_threads.size(); ++i ) { m_fork_chains.emplace_back( so_5::create_mchain(env) ); m_fork_threads[ i ] = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::thread{ fork_process, m_fork_chains.back() }; } } } fork_threads_stuff{ table_size }; <span class="hljs-comment"><span class="hljs-comment">//   . fork_threads_stuff.run(); //     . //       fork_threads_stuff.</span></span></code> </pre> <br><p>     ,           (, Boost- ScopeExit-, GSL- finally()   ). </p><br><p>         .       . </p><br><p> ,        exception-safety  <code>run_simulation()</code> ,   <code>run_simulation()</code>   ,    .      ,          -.       exception-safety  <code>run_simulation()</code>     <em>noexcept</em> ,     <code>std::terminate</code>    . ,          . </p><br><p>   ,   ,       ,       ,   .    ,     <code>join</code> ,            <code>join</code> .         . </p><br><h2 id="prostoe-reshenie-bez-ispolzovaniya-arbitra-oficianta">      () </h2><br><p>    ,   CSP-          ,   . </p><br><p>       <a href="" rel="nofollow"></a> . </p><br><h3 id="nit-dlya-vilki-1">    </h3><br><p>      <code>fork_process</code> ,    : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fork_process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> fork_ch )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//  :   . bool taken = false; //      . so_5::receive( so_5::from( fork_ch ), [&amp;]( so_5::mhood_t&lt;take_t&gt; cmd ) { if( taken ) so_5::send&lt; busy_t &gt;( cmd-&gt;m_who ); else { taken = true; so_5::send&lt; taken_t &gt;( cmd-&gt;m_who ); } }, [&amp;]( so_5::mhood_t&lt;put_t&gt; ) { if( taken ) taken = false; } ); }</span></span></code> </pre> <br><p>  ,   <code>fork_process</code> ,      (      ,      ). </p><br><h3 id="nit-dlya-filosofa-1">    </h3><br><p>      <code>philosopher_process</code> ,    ,      . </p><br><div class="spoiler"> <b class="spoiler_title">  philosopher_process</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">philosopher_process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">trace_maker_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; tracer, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> control_ch, </span></span><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-params"><span class="hljs-built_in">std</span></span></span></span><span class="hljs-function"><span class="hljs-params">::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> philosopher_index, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> left_fork, so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mbox_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> right_fork, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> meals_count )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> meals_eaten{ <span class="hljs-number"><span class="hljs-number">0</span></span> }; <span class="hljs-comment"><span class="hljs-comment">//       . thinking_type_t thinking_type{ thinking_type_t::normal }; random_pause_generator_t pause_generator; //      . auto self_ch = so_5::create_mchain( control_ch-&gt;environment() ); while( meals_eaten &lt; meals_count ) { tracer.thinking_started( philosopher_index, thinking_type ); //    . std::this_thread::sleep_for( pause_generator.think_pause( thinking_type ) ); //  ,     . thinking_type = thinking_type_t::hungry; //    . tracer.take_left_attempt( philosopher_index ); so_5::send&lt; take_t &gt;( left_fork, self_ch-&gt;as_mbox(), philosopher_index ); //  ,  . so_5::receive( so_5::from( self_ch ).handle_n( 1u ), []( so_5::mhood_t&lt;busy_t&gt; ) { /*     */ }, [&amp;]( so_5::mhood_t&lt;taken_t&gt; ) { //   ,   . tracer.take_right_attempt( philosopher_index ); so_5::send&lt; take_t &gt;( right_fork, self_ch-&gt;as_mbox(), philosopher_index ); //  ,  . so_5::receive( so_5::from( self_ch ).handle_n( 1u ), []( so_5::mhood_t&lt;busy_t&gt; ) { /*     */ }, [&amp;]( so_5::mhood_t&lt;taken_t&gt; ) { //    ,  . tracer.eating_started( philosopher_index ); //     . std::this_thread::sleep_for( pause_generator.eat_pause() ); //     . ++meals_eaten; //      . so_5::send&lt; put_t &gt;( right_fork ); //        "normal". thinking_type = thinking_type_t::normal; } ); //       . so_5::send&lt; put_t &gt;( left_fork ); } ); } //    . tracer.philosopher_done( philosopher_index ); so_5::send&lt; philosopher_done_t &gt;( control_ch, philosopher_index ); }</span></span></code> </pre> </div></div><br><p>  -  <code>philosopher_process</code>     <code>philosopher_process</code>   .     . </p><br><p> -,   <code>thinking_type</code> .    ,      ,     ,      "" . </p><br><p> -,     <code>busy_t</code> .       <code>receive()</code> : </p><br><pre> <code class="cpp hljs">so_5::receive( so_5::from( self_ch ).handle_n( <span class="hljs-number"><span class="hljs-number">1u</span></span> ), []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">busy_t</span></span>&gt; ) { <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> }, [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span>&gt; ) { ... so_5::receive( so_5::from( self_ch ).handle_n( <span class="hljs-number"><span class="hljs-number">1u</span></span> ), []( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">busy_t</span></span>&gt; ) { <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> }, [&amp;]( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mhood_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">taken_t</span></span>&gt; ) {...} );</code> </pre> <br><p> ,   <code>busy_t</code> ,   ,           <code>receive()</code> ,       <code>receive()</code> .    <code>busy_t</code>    .      , ..    <code>receive()</code>   <code>busy_t</code>  .     <code>receive()</code>        <code>busy_t</code> . </p><br><h2 id="reshenie-s-oficiantom-i-vremennymi-otmetkami">       </h2><br><p>   CSP-     ,       .            ():    waiter_with_queue,      ,      waiter_with_timestamps.         :    mbox-   ,  mbox-  ,    mbox-  . </p><br><p>      CSP-  ,        <code>philosopher_process</code>   no_waiter_simple.       mchain-           ,  ? </p><br><p>  , . </p><br><p>   mchain-  .   ,       mchain-. </p><br><p>  SObjectizer-   <code>select()</code> ,    , ,    : </p><br><pre> <code class="cpp hljs">so_5::select( so_5::from_all(), case_(ch1, one_handler_1, one_handler_2, one_handler_3, ...), case_(ch2, two_handler_1, two_handler_2, two_handler_3, ...), ...);</code> </pre> <br><p>   <code>select()</code> ,            -.       " "        .   CSP-           . </p><br><p>     . </p><br><p> ,   ,     <code>take_t</code>  <code>put_t</code>      .     -   .         <code>take_t</code>  <code>put_t</code> ,       : </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extended_take_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> m_who; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> m_philosopher_index; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> m_fork_index; <span class="hljs-keyword"><span class="hljs-keyword">extended_take_t</span></span>( so_5::<span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> who, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> philosopher_index, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> fork_index ) : m_who{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(who) } , m_philosopher_index{ philosopher_index } , m_fork_index{ fork_index } {} }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">extended_put_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> m_fork_index; <span class="hljs-keyword"><span class="hljs-keyword">extended_put_t</span></span>( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">size_t</span></span> fork_index ) : m_fork_index{ fork_index } {} };</code> </pre> <br><blockquote>  ,       <code>so_5::message_t</code> ,         (     ).         ,      SObjectizer- . </blockquote><p>    ,         .       <code>take_t</code>  <code>put_t</code> ,    <code>extended_take_t</code>  <code>extended_put_t</code> ,    . </p><br><p>      mbox.   :) </p><br><div class="spoiler"> <b class="spoiler_title">  mbox-</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">wrapping_mbox_t</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::extra::mboxes::proxy::<span class="hljs-keyword"><span class="hljs-keyword">simple_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">base_type_t</span></span> = so_5::extra::mboxes::proxy::<span class="hljs-keyword"><span class="hljs-keyword">simple_t</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    . const so_5::mbox_t m_target; //  ,      . const std::size_t m_fork_index; //    . static std::type_index original_take_type; static std::type_index original_put_type; public : wrapping_mbox_t( const so_5::mbox_t &amp; target, std::size_t fork_index ) : base_type_t{ target } , m_target{ target } , m_fork_index{ fork_index } {} //    so_5::abstract_message_box_t   . //       . void do_deliver_message( const std::type_index &amp; msg_type, const so_5::message_ref_t &amp; message, unsigned int overlimit_reaction_deep ) const override { if( original_take_type == msg_type ) { //     . const auto &amp; original_msg = so_5::message_payload_type&lt;::take_t&gt;:: payload_reference( *message ); //     . so_5::send&lt; extended_take_t &gt;( m_target, original_msg.m_who, original_msg.m_philosopher_index, m_fork_index ); } else if( original_put_type == msg_type ) { //     . so_5::send&lt; extended_put_t &gt;( m_target, m_fork_index ); } else base_type_t::do_deliver_message( msg_type, message, overlimit_reaction_deep ); } //       wrapping_mbox_t. static auto make( const so_5::mbox_t &amp; target, std::size_t fork_index ) { return so_5::mbox_t{ new wrapping_mbox_t{ target, fork_index } }; } }; std::type_index wrapping_mbox_t::original_take_type{ typeid(::take_t) }; std::type_index wrapping_mbox_t::original_put_type{ typeid(::put_t) };</span></span></code> </pre> </div></div><br><p>        mbox-:    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow">so_5_extra</a>  ,        .           <code>so_5::abstract_message_box_t</code>      . </p><br><p>     ,    <code>wrapping_mbox_t</code> .          ,       .      wrapping_mbox,          mchain .   <code>waiter_process</code> ,      ,      : </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waiter_process</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( so_5::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">mchain_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> waiter_ch, details::</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">waiter_logic_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; logic )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//        . so_5::receive( so_5::from( waiter_ch ), [&amp;]( so_5::mhood_t&lt;details::extended_take_t&gt; cmd ) { logic.on_take_fork( std::move(cmd) ); }, [&amp;]( so_5::mhood_t&lt;details::extended_put_t&gt; cmd ) { logic.on_put_fork( std::move(cmd) ); } ); }</span></span></code> </pre> <br><p>  ,               ,      .      waiter_with_timestamps <a href="" rel="nofollow"></a> . </p><br><p>       : "      <code>philosopher_process</code>  mbox-?"  ,    waiter_with_timestamps    mbox,   mchain. </p><br><p>  ,       mchain.       , ..  so_5_extra        mchain- (    ).          mbox-  mchain-. </p><br><h1 id="zaklyuchenie">  Kesimpulan </h1><br><p> , ,  ,          CSP .       ,     .   ,  ,     . ,  -   . </p><br><p>     ,   SObjectizer-.    ,         ""  SObjectizer —  5.6,     5.5.        ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"></a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"></a> ). -   ,    SO-5.6   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=" rel="nofollow"></a> (      ). </p><br><p>     ,          ! </p><br><p>  PS.  ""      ,       .        C++14. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id437998/">https://habr.com/ru/post/id437998/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id437988/index.html">React Tutorial, Bagian 12: Workshop, Aplikasi TODO Tahap 3</a></li>
<li><a href="../id437990/index.html">Bereaksi Tutorial Bagian 13: Komponen Berbasis Kelas</a></li>
<li><a href="../id437992/index.html">Layanan microser. Versi dalam Integrasi dan Penerapan Sistem Berkelanjutan Studi Kasus CI / CD Menggunakan TFS</a></li>
<li><a href="../id437994/index.html">Pemerah susu otomatis dan rumah kaca otomatis: cara kerja pertanian teknologi tinggi kecil</a></li>
<li><a href="../id437996/index.html">SITIS CTF: bagaimana seal membantu CTF menang</a></li>
<li><a href="../id438000/index.html">Keberhasilan dan kegagalan dalam membuat proyek Anda (startup)</a></li>
<li><a href="../id438002/index.html">Konfigurasikan proxy terbalik untuk Nextcloud dan ONLYOFFICE</a></li>
<li><a href="../id438004/index.html">Apple atau Soul Electronics: Tantangan dan Kepemimpinan untuk Headphone Kebugaran Nirkabel</a></li>
<li><a href="../id438006/index.html">Small Business CRM: Rahasia untuk Implementasi yang Sukses</a></li>
<li><a href="../id438008/index.html">Mengkonfigurasi peralatan pintar Zyxel dalam mode mandiri dan cloud</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>