<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍘 👨‍👧‍👧 💖 Ivan Tulup: asynchrone en JS sous le capot 👩🏼‍🔬 🆕 💊</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Connaissez-vous Ivan Tulup? Très probablement oui, vous ne savez pas encore de quel type de personne il s'agit, et vous devez faire très attention à l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ivan Tulup: asynchrone en JS sous le capot</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/417461/">  Connaissez-vous Ivan Tulup?  Très probablement oui, vous ne savez pas encore de quel type de personne il s'agit, et vous devez faire très attention à l'état de son système cardiovasculaire. <br><br>  À ce sujet et comment l'asynchronisme fonctionne dans JS sous le capot, comment fonctionne la boucle d'événement dans les navigateurs et Node.js, y a-t-il des différences et peut-être des choses similaires ont été racontées par <strong>Mikhail Bashurov</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">SaitoNakamura</a> ) dans son rapport sur RIT ++.  Nous sommes heureux de partager avec vous la transcription de cette présentation informative. <br><br><img src="https://habrastorage.org/webt/mv/fj/ah/mvfjah-dahl8fndi-w8rt4qkbxw.jpeg"><br><br>  <strong>À propos de l'orateur:</strong> Mikhail Bashurov est un développeur Web fullstack sur JS et .NET de Luxoft.  Il aime la belle interface utilisateur, les tests verts, la transpilation, la compilation, le compilateur permettant la technique et améliorer l'expérience de développement. <br><br>  <strong>Note de l'éditeur:</strong> le rapport de Mikhail était accompagné non seulement de diapositives, mais d'un projet de démonstration dans lequel vous pouvez cliquer sur les boutons et regarder indépendamment l'exécution des shuffles.  La meilleure option serait d'ouvrir la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">présentation</a> dans un onglet adjacent et de s'y référer périodiquement, mais le texte fournira également des liens vers des pages spécifiques.  Et maintenant, nous passons la parole à l'orateur, profitez-en pour lire. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/bUx8wk4LdoY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br><h2>  Grand-père Ivan Tulup </h2><br>  J'ai eu une candidature pour Ivan Tulup. <br><br><img src="https://habrastorage.org/webt/hl/8x/lx/hl8xlx_fubycz-ivega_hinmhp0.png"><br><br>  Mais j'ai décidé d'emprunter une voie plus conformiste, alors rencontrez - le grand-père Ivan Tulup! <br><br><img src="https://habrastorage.org/webt/qd/jc/dn/qdjcdntndkzeyiuw3zpwt4vos74.png"><br><br>  En fait, seulement deux choses doivent être connues de lui: <br><br><ol><li>  Il aime jouer aux cartes. </li><li>  Comme tout le monde, il a un cœur et il bat. </li></ol><br><h2>  Faits sur la crise cardiaque </h2><br>  Vous avez peut-être entendu dire que les cas de maladies cardiaques et leur mortalité sont récemment devenus plus fréquents.  La maladie cardiaque la plus courante est probablement une crise cardiaque, c'est-à-dire une crise cardiaque. <br><br>  Qu'est-ce qui est intéressant avec la crise cardiaque? <br><br><ul><li>  Le plus souvent, cela se produit le lundi matin. </li><li>  Chez les personnes seules, le risque de crise cardiaque est deux fois plus élevé.  Ici, peut-être, le point est uniquement en corrélation, et non dans une relation causale.  Malheureusement (ou heureusement), il en est ainsi. </li><li>  Dix chefs d'orchestre sont décédés d'une crise cardiaque pendant la conduite (travail apparemment très nerveux!). </li><li>  Une crise cardiaque est une nécrose du muscle cardiaque causée par un manque de circulation sanguine. </li></ul><br>  Nous avons une artère coronaire qui apporte du sang au muscle (myocarde).  Si le sang commence à y circuler mal, le muscle meurt progressivement.  Naturellement, cela a un effet extrêmement négatif sur le cœur et son travail. <br><br>  Le grand-père Ivan Tulup a aussi un cœur et il bat.  Mais notre cœur pompe le sang, et le cœur d'Ivan Tulup pompe notre code et nos peines. <br><br><h2>  Tasky: un grand cercle de circulation sanguine <br></h2><br>  Quelles sont les tâches?  Qu'est-ce qui peut être généralement paresseux dans un navigateur?  Pourquoi sont-ils nécessaires du tout? <br><br>  Par exemple, nous exécutons du code à partir d'un script.  C'est un battement de cœur, et maintenant nous avons le flux sanguin.  Nous avons cliqué sur le bouton et nous sommes abonnés à l'événement - le gestionnaire d'événements pour cet événement a craché - le rappel que nous avons envoyé.  Ils ont mis Timeout, Callback travaillé - une autre tâche.  Et donc dans certaines parties, un battement de cœur est une tâche. <br><br><img src="https://habrastorage.org/webt/vz/sb/0z/vzsb0znwotnkpldqmb2chhwblxs.png"><br><br>  Il existe de nombreuses sources différentes de chou, selon les spécifications, il y en a un grand nombre.  Notre cœur continue de battre, et pendant qu'il bat, tout va bien pour nous. <br><br><h3>  Boucle d'événement dans le navigateur: version simplifiée <br></h3><br>  Cela peut être représenté dans un diagramme très simple. <br><br><img src="https://habrastorage.org/webt/hy/zf/2p/hyzf2pktcyzag0oroich978odpa.png"><br><br><ul><li>  Il y a une tâche, nous l'avons accomplie. </li><li>  Ensuite, nous exécutons le rendu du navigateur. </li></ul><br>  Mais en fait, cela n'est pas nécessaire, car dans certains cas, le navigateur peut ne pas afficher entre deux tâches. <br><br>  Cela peut se produire, par exemple, si le navigateur peut décider de regrouper plusieurs délais d'expiration ou plusieurs événements de défilement.  Ou à un moment donné, quelque chose ne va pas, et le navigateur décide au lieu de 60 ips (fréquence d'images normale pour que tout se passe bien et en douceur) d'afficher 30 ips.  Ainsi, il aura beaucoup plus de temps pour exécuter votre code et autres travaux utiles, il pourra effectuer plusieurs chocs. <br><br>  Par conséquent, le rendu n'est pas vraiment effectué après chaque tâche. <br><br><h3>  Tasky: classification <br></h3><br>  Il existe deux types d'opérations potentielles: <br><br><ol><li>  E / S liées; </li><li>  Lié au processeur. </li></ol><br>  <strong>Le CPU</strong> est notre travail utile que nous faisons (croire, afficher, etc.) <br><br>  <strong>Les E / S liées</strong> sont les points auxquels nous pouvons partager nos tâches.  Ce pourrait être: <br><br><ul><li>  Timeout </li></ul>  Nous avons fait setTimeout 5000 ms, et nous attendons juste ces 5000 ms, mais nous pouvons faire d'autres travaux utiles.  Ce n'est que lorsque ce temps passe, que nous recevons un rappel et que nous y travaillons. <br><br><ul><li>  xhr / fetch. </li></ul>  Nous sommes allés en ligne.  Pendant que nous attendons une réponse du réseau, nous attendons simplement, mais nous pouvons aussi faire quelque chose d'utile. <br><br><ul><li>  Réseau (OBD). </li></ul>  Ou, par exemple, nous allons sur Network BD.  Nous parlons également de Node.js, y compris, et si nous voulons aller quelque part vers le réseau à partir de Node.js, veuillez - c'est la même tâche potentielle liée aux E / S (entrée / sortie). <br><br><ul><li>  Fichier. </li></ul>  Lisez le fichier - ce n'est potentiellement pas une tâche liée au processeur.  Dans Node.js, il s'exécute dans le pool de threads en raison d'une API Linux légèrement tordue, pour être honnête. <br><br>  Alors CPUbound est: <br><br><ul><li>  Par exemple, lorsque nous faisons une boucle for of / for (;;) ou que nous traversons le tableau d'une manière ou d'une autre en utilisant des méthodes supplémentaires: filtre, carte, etc. </li><li>  JSON.parse ou JSON.stringify, c'est-à-dire la sérialisation / désérialisation des messages.  Tout cela se fait sur le CPU, nous ne pouvons pas attendre que tout soit exécuté par magie quelque part. </li><li>  Compter les hachages, c'est-à-dire, par exemple, l'extraction de crypto. </li></ul><br>  Bien sûr, la crypto peut également être exploitée sur le GPU, mais je pense - GPU, CPU - vous comprenez cette analogie. <br><br><h3>  Tasky: arythmie et thrombus </h3><br>  En conséquence, il s'avère que notre cœur bat: il fait une tâche, la deuxième, la troisième - jusqu'à ce que nous fassions quelque chose de mal.  Par exemple, nous parcourons un tableau de 1 million d'éléments et comptons la somme.  Il semblerait que ce ne soit pas si difficile, mais cela peut prendre du temps tangible.  Si nous prenons constamment du temps tangible sans libérer de tâche, notre rendu ne peut pas être effectué.  Il a plané dans ce désir, et tout - l'arythmie commence. <br><br>  Je pense que tout le monde comprend que l'arythmie est une maladie cardiaque plutôt désagréable.  Mais vous pouvez toujours vivre avec lui.  Que se passe-t-il si vous placez une tâche qui suspend simplement la boucle d'événement entière dans une boucle sans fin?  Vous mettez en quelque sorte un caillot de sang dans la coronaire ou une autre artère, et tout deviendra complètement triste.  Malheureusement, notre grand-père Ivan Tulup va mourir. <br><br><h3>  Alors le grand-père Ivan est mort ... <br></h3><br><img src="https://habrastorage.org/webt/8t/nq/gc/8tnqgc8lygwpsdvts0b3xpqgtta.png"><br><br>  Pour nous, cela signifie que l'onglet entier se bloque complètement - vous ne pouvez pas cliquer sur quoi que ce soit, puis Chrome dit: "Aw, Snap!" <br><br>  C'est encore pire que les bugs du site Web en cas de problème.  Mais si tout a raccroché, et même, probablement, le processeur chargé et l'utilisateur généralement bloqué, il ne reviendra probablement jamais sur votre site. <br><br>  Par conséquent, l'idée est la suivante: nous avons une tâche et nous n'avons pas besoin de nous accrocher à cette tâche pendant très longtemps.  Nous devons le libérer rapidement, afin que le navigateur, le cas échéant, puisse effectuer un rendu (s'il le souhaite).  Si vous ne voulez pas - super, dansez! <br><br><h2>  Démo de Philip Roberts: Loupe de Philip Roberts <br></h2><br>  Prenons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un exemple</a> : <br><br><pre><code class="javascript hljs">$.on(<span class="hljs-string"><span class="hljs-string">'button'</span></span>, <span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onClick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'click'</span></span>); }); setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeout</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span> log(<span class="hljs-string"><span class="hljs-string">"timeout"</span></span>); }. <span class="hljs-number"><span class="hljs-number">5000</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(“Hello world<span class="hljs-string"><span class="hljs-string">");</span></span></code> </pre> <br>  L'essence est la suivante: nous avons un bouton, nous nous y abonnons (addEventListener), Timeout est appelé pendant 5 secondes et immédiatement dans le console.log nous écrivons "Bonjour, monde!", Dans setTimeout nous écrivons Timeout, dans onClick nous écrivons Click. <br><br>  Que se passera-t-il si nous l'exécutons et plusieurs fois nous cliquons sur le bouton - quand le Timeout sera-t-il réellement exécuté?  Voyons la démo: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/bUx8wk4LdoY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Le code commence à s'exécuter, se met sur la pile, le Timeout disparaît.  Pendant ce temps, nous avons cliqué sur le bouton.  Au bas de la file d'attente, plusieurs événements ont été ajoutés.  Pendant que Click est en cours d'exécution, Timeout attend, bien que 5 secondes se soient écoulées. <br><br>  Ici, onClick est rapide, mais si vous mettez une tâche plus longue, alors tout se fige, comme déjà expliqué.  Ceci est un exemple très simplifié.  Voici un tour, mais dans les navigateurs, en fait, tout n'est pas le cas. <br><br>  Dans quel ordre les événements sont-ils exécutés - que dit la spécification HTML? <br><br>  Elle dit ce qui suit: nous avons 2 concepts: <br><br><ol><li>  source de la tâche; </li><li>  file d'attente des tâches. </li></ol><br>  La source de tâche est une sorte de tâche.  Cela peut être une interaction utilisateur, c'est-à-dire onClick, onChange - quelque chose avec lequel l'utilisateur interagit;  ou des minuteries, c'est-à-dire setTimeout et setInterval, ou PostMessages;  ou même des types complètement sauvages comme la source de tâche Canvas Blob Serialization - également un type distinct. <br><br>  La spécification indique que pour la même tâche, les tâches seront garanties d'être exécutées dans l'ordre où elles sont ajoutées.  Pour tout le reste, rien n'est garanti, car il peut y avoir un nombre illimité de files d'attente de tâches.  Le navigateur décide combien il y en aura.  À l'aide de la file d'attente des tâches et de leur création, le navigateur peut hiérarchiser certaines tâches. <br><br><h3>  Priorités du navigateur et files d'attente de tâches <br></h3><br><img src="https://habrastorage.org/webt/xv/fu/s9/xvfus9kn-18e_oxy00s_xwm6vdq.png"><br><br>  Imaginez que nous ayons 3 lignes: <br><br><ol><li>  interaction avec l'utilisateur; </li><li>  délais </li><li>  publier des messages. </li></ol><br>  Le navigateur commence à obtenir des tâches à partir de ces files d'attente: <br><br><ul><li>  Tout d'abord, il prend en <strong>charge</strong> l'interaction utilisateur - c'est très important - un battement de cœur a disparu. <br></li><li>  Puis il prend <strong>postMessages</strong> - eh bien, postMessages est une priorité assez élevée, cool! <br></li><li>  Le suivant, <strong>onChange,</strong> est également à nouveau de l'interaction utilisateur en priorité. <br></li><li>  Le prochain <strong>onClick est</strong> envoyé.  La file d'attente d'interaction avec l'utilisateur est terminée, nous avons montré à l'utilisateur tout ce dont il avait besoin. <br></li><li>  Ensuite, nous prenons <strong>setInterval</strong> , ajoutons postMessages. <br></li><li>  <strong>setTimeout n'exécutera que la plus récente</strong> .  Il était quelque part au bout de la ligne. <br></li></ul><br>  Il s'agit là encore d'un exemple très simplifié et, malheureusement, <strong>personne ne peut garantir comment cela fonctionnera dans les navigateurs</strong> , car ils décident eux-mêmes de tout cela.  Vous devez tester cela vous-même si vous voulez savoir ce que c'est. <br><br>  Par exemple, postMessages a priorité sur setTimeout.  Vous avez peut-être entendu parler d'une chose telle que setImmediate, qui, par exemple, dans les navigateurs IE, n'était que native.  Mais il existe des polyfichiers qui sont principalement basés non pas sur setTimeout, mais sur la création d'un canal postMessages et sur son abonnement.  Cela fonctionne généralement plus rapidement car les navigateurs le priorisent. <br><br>  Eh bien, ces tâches sont effectuées.  À quel moment terminons-nous notre tâche et comprenons-nous que nous pouvons prendre la suivante, ou que nous pouvons rendre? <br><br><h3>  Pile </h3><br>  La pile est une structure de données simple qui fonctionne sur le principe du "dernier entré - premier sorti", c'est-à-dire  "J'ai mis le dernier - tu as le premier <strong>.</strong> "  La contrepartie la plus proche, probablement réelle, est un jeu de cartes.  Par conséquent, notre grand-père Ivan Tulup aime jouer aux cartes. <br><br><img src="https://habrastorage.org/webt/5b/03/dh/5b03dh5di0r9oktsyvekmflkey4.png"><br><br>  L'exemple ci-dessus, dans lequel il y a du code, le même exemple peut être poussé dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">présentation</a> .  À un certain endroit, nous appelons handleClick, entrez console.log, appelons showPopup et window.  confirmer.  Formons une pile. <br><br><ul><li>  Donc, nous prenons d'abord handleClick et poussons l'appel à cette fonction sur la pile - super! </li><li>  Ensuite, nous entrons dans son corps et l'exécutons. </li><li>  Nous mettons console.log sur la pile et l'exécutons immédiatement, car tout est là pour l'exécuter. </li><li>  Ensuite, nous mettons showConfirm - c'est un appel de fonction - super. </li><li>  Nous mettons des fonctions sur la pile - nous mettons son corps, c'est-à-dire window.confirm. </li></ul><br>  Nous n'avons plus rien - nous le faisons.  Une fenêtre apparaîtra: «Êtes-vous sûr?», Cliquez sur «Oui», et tout quittera la pile.  Nous avons maintenant terminé le corps showConfirm et le corps handleClick.  Notre pile est effacée et nous pouvons passer à la tâche suivante.  Question: OK, je sais maintenant que vous devez tout casser en petits morceaux.  Comment puis-je, par exemple, faire cela dans le cas le plus élémentaire? <br><br><h3>  Partitionner un tableau en morceaux et les traiter de manière asynchrone </h3><br>  Regardons l'exemple le plus «frontal».  Je vous préviens tout de suite: n'essayez pas de répéter cela à la maison - cela ne se compilera pas. <br><br><img src="https://habrastorage.org/webt/on/a4/kz/ona4kz7lojjan82vfis4dkoxvh0.png"><br><br>  Nous avons un grand, grand tableau, et nous voulons calculer quelque chose en fonction de celui-ci, par exemple, pour analyser certaines données binaires.  Nous pouvons simplement le diviser en morceaux: traiter cette pièce, ceci et cela.  Nous sélectionnons la taille du morceau, par exemple, 10 000 éléments, nous considérons combien de morceaux nous aurons.  Nous avons une fonction parseData qui va dans le CPU et peut vraiment faire quelque chose de lourd.  Ensuite, nous divisons le tableau en morceaux, définissez setTimeout (() =&gt; parseData (tranche), 0). <br><br>  Dans ce cas, le navigateur pourra à nouveau hiérarchiser l'interaction de l'utilisateur et effectuer le rendu entre les deux.  Autrement dit, vous libérez au moins votre boucle d'événement, et cela continue de fonctionner.  Votre cœur continue de battre et c'est bien. <br><br>  Mais c'est vraiment un exemple très «frontal».  Il existe de nombreuses API dans les navigateurs pour vous aider à le faire de manière plus spécialisée. <br><br>  Outre setTimeout et setInterval, il existe des API qui vont au-delà des limites, telles que, par exemple, requestAnimationFrame et requestIdleCallback. <br><br>  Beaucoup connaissent <strong>probablement requestAnimationFrame</strong> et l'utilisent déjà.  Il est exécuté avant le rendu.  Son charme est que, d'une part, il essaie d'exécuter toutes les 60 ips (ou 30 ips), et d'autre part, tout cela se fait immédiatement avant de créer le modèle d'objet CSS, etc. <br><br><img src="https://habrastorage.org/webt/0-/hy/qt/0-hyqtkge9dm9ayeciqrrzgjors.png"><br><br>  Par conséquent, même si vous avez plusieurs requestAnimationFrame, ils regrouperont en fait toutes les modifications et le cadre sortira complet.  Dans le cas de setTimeout, vous ne pouvez certainement pas obtenir une telle garantie.  Un setTimeout changera une chose, l'autre une autre, et entre le rendu peut glisser - vous aurez une secousse de l'écran ou autre chose.  RequestAnimationFrame est idéal pour cela. <br><br>  En plus de cela, il existe également <strong>requestIdleCallback.</strong>  Vous avez peut-être entendu dire qu'il est utilisé dans React v16.0 (Fibre).  RequestIdleCallback fonctionne de telle manière que si le navigateur comprend qu'il a du temps entre les images (60 ips) pour faire quelque chose d'utile, et en même temps, il a déjà tout fait - ils ont fait la tâche, requestAnimationFrame a fait - cela semble cool, alors ça peut produire de petits quanta, disons, 50 ms chacun, vous pouvez donc faire quelque chose (mode IDLE). <br><br>  Ce n'est pas dans le schéma ci-dessus, car il n'est situé à aucun endroit particulier.  Le navigateur peut décider de le placer avant le cadre, après le cadre, entre le requestAnimationFrame et le rendu, après la tâche, avant la tâche.  Personne ne peut garantir cela. <br><br>  Il vous est garanti que si vous avez du travail qui n'est pas lié à la modification du DOM (car alors requestAnimationFrame est une animation et ainsi de suite), alors qu'il n'est pas super prioritaire, mais tangible, alors requestIdleCallback est votre chemin. <br><br>  Donc, si nous avons une longue opération liée au processeur, nous pouvons essayer de la diviser en morceaux. <br><br><ul><li>  S'il s'agit d'un changement DOM, utilisez <strong>requestAnimationFrame.</strong> <br></li><li>  S'il s'agit d'une tâche non prioritaire, de courte durée et non difficile qui ne <strong>surchargera</strong> pas <strong>le</strong> processeur, alors <strong>requestIdleCallback.</strong> <br></li><li>  Si nous avons une grosse tâche puissante qui doit être effectuée en permanence, nous allons au-delà de la boucle d'événement et utilisons WebWorkers.  Il n'y a pas d'autre moyen. <br></li></ul><br>  <strong>Tâches dans les navigateurs:</strong> <br><br><ol><li>  Écrasez tout en petites tâches. </li><li>  Il existe de nombreux types de tâches. </li><li>  Les tâches sont hiérarchisées par ces types via des files d'attente de spécifications. </li><li>  Les navigateurs décident en grande partie et la seule façon de comprendre comment cela fonctionne est de simplement vérifier si l'un ou l'autre code est en cours d'exécution. </li><li>  Mais le cahier des charges n'est pas toujours respecté! </li></ol><br>  Le problème est que notre Ivan Tulup est un vieux grand-père, car les implémentations de la boucle d'événement dans les navigateurs sont également très anciennes.  Ils ont été créés avant la rédaction de la spécification, de sorte que la spécification est malheureusement respectée dans la mesure où.  Même si vous lisez à quoi devrait ressembler la spécification, personne ne garantit que tous les navigateurs la prennent en charge.  Assurez-vous donc de vérifier dans les navigateurs comment cela fonctionne réellement. <br><br>  Le grand-père Ivan Tulup dans les navigateurs est une personne peu prévisible, avec quelques fonctionnalités intéressantes, vous devez vous en souvenir. <br><br><h2>  Terminator Santa: boucle de mascotte sur Node.js <br></h2><br>  Node.js ressemble plus à quelqu'un comme ça. <br><br><img src="https://habrastorage.org/webt/bb/5u/bx/bb5ubx5cvdgtu2lilmk-rfmeajc.png"><br><br>  Parce que d'un côté c'est le même grand-père avec une barbe, mais en même temps tout est réparti en phases et il est clairement peint où ce qui se fait. <br><br>  <strong>Phases de la boucle d'événement dans Node.js:</strong> <br><br><ul><li>  minuteries; <br></li><li>  rappel en attente; <br></li><li>  au ralenti, se préparer; <br></li><li>  sondage; <br></li><li>  vérifier; <br></li><li>  fermer les rappels. <br></li></ul><br>  Tout sauf le dernier n'est pas très clair ce que cela signifie.  Les phases ont des noms si étranges, car sous le capot, comme nous le savons déjà, nous avons Libuv pour gouverner tout le monde: <br><br><ul><li>  <em>Linux -</em> epoll / POSIX AIO; <br></li><li>  <em>BSD -</em> kqueue; <br></li><li>  <em>Windows -</em> IOCP; <br></li><li>  <em>Solaris -</em> ports d'événements. <br></li></ul><br>  Des milliers d'entre eux tous! <br><br>  De plus, Libuv fournit également la même boucle d'événement.  Il n'a pas les spécificités de Node.js, mais il y a des phases, et Node.js les utilise simplement.  Mais pour une raison quelconque, elle a pris les noms de là. <br><br>  Voyons ce que signifie réellement chaque phase. <br><br><h4>  La phase Timers effectue: <br></h4><br><ul><li>  Minuteries prêtes pour le rappel; <br></li><li>  setTimeout et setInterval; <br></li><li>  Mais <strong>PAS</strong> setImmediate est une phase différente. <br></li></ul><br><h4>  Rappels de phase en attente <br></h4><br>  Avant cela, la phase de documentation appelait les rappels d'E / S.  Plus récemment, cette documentation a été corrigée et elle a cessé de se contredire.  Avant cela, à un endroit, il était écrit que les rappels d'E / S étaient exécutés dans cette phase, dans une autre - celle de la phase d'interrogation.  Mais maintenant, tout y est écrit sans équivoque et bien, alors lisez la documentation - quelque chose deviendra beaucoup plus compréhensible. <br><br>  Dans la phase de rappel en attente, les rappels de certaines opérations système (erreur TCP) sont exécutés.  Autrement dit, si dans Unix il y a une erreur dans le socket TCP, dans ce cas, il ne veut pas le jeter immédiatement, mais dans le rappel, qui sera exécuté juste dans cette phase.  C’est tout ce que nous devons savoir sur elle.  Nous n'y sommes pratiquement pas intéressés. <br><br><h4>  Phase inactive, préparer <br></h4><br>  Dans cette phase, nous ne pouvons rien faire du tout, nous allons donc l’oublier en principe. <br><br><img src="https://habrastorage.org/webt/xa/6l/n-/xa6ln-ao3qbubxteqecnh8lm5ke.png"><br><br><h4>  Phase de sondage <br></h4><br>  C'est la phase la plus intéressante de Node.js car elle fait le principal travail utile: <br><br><ul><li>  Effectue des rappels d'E / S (pas de phase de rappel en attente!). </li><li>  Attente d'événements d'E / S; </li><li>  C'est cool de faire setImmediate; </li><li>  Pas de minuteries; </li></ul><br>  À l'avenir, setImmediate s'exécutera dans la prochaine phase de vérification, c'est-à-dire garantie avant les temporisateurs. <br><br>  Et la phase d'interrogation contrôle également le flux de la boucle d'événements.  Par exemple, si nous n'avons pas de temporisateurs, il n'y a pas de setImmediate, c'est-à-dire que personne n'a le temporisateur, setImmediate n'a pas appelé, nous bloquons simplement dans cette phase et attendons l'événement des E / S, si quelque chose nous arrive, s'il y a des rappels si nous nous sommes inscrits pour quelque chose. <br><br>  Comment un modèle non bloquant est-il implémenté?  Par exemple, au même Epoll, nous pouvons nous abonner à un événement - ouvrir une socket et attendre que quelque chose y soit écrit.  De plus, le deuxième argument est le timeout, c'est-à-dire  nous attendrons Epoll, mais si le délai expire et que l'événement des E / S ne se produit pas, il quittera le délai.  Si un événement nous vient du réseau (quelqu'un écrit sur socket), il viendra. <br><br>  Par conséquent, la phase d'interrogation supprime le tas (le tas est une structure de données qui permet une livraison et une livraison bien triées) du premier rappel, prend son délai d'expiration, écrit dans ce délai et libère tout.  Ainsi, même si personne ne nous écrit dans le socket, le délai d'attente fonctionnera, retournera à la phase d'interrogation et le travail se poursuivra. <br><br><blockquote>  Il est important de noter que dans la phase de sondage, il y a une limite sur le nombre de rappels à la fois. <br></blockquote><br>  Il est triste que ce ne soit pas le cas dans les phases restantes.  Si vous ajoutez 10 milliards d'expiration, vous ajoutez 10 milliards d'expiration.  Par conséquent, la phase suivante est la phase de vérification. <br><br><h4>  Phase de vérification </h4><br>  C'est là que setImmediate s'exécute.  La phase est belle dans la mesure où setImmediate, appelé dans la phase d'interrogation, est garanti pour s'exécuter plus tôt que le temporisateur.  Parce que le chronomètre ne sera activé que sur le tick suivant au tout début, et plus tôt à partir de la phase de sondage.  Par conséquent, nous ne pouvons pas avoir peur de la concurrence avec d'autres chronomètres et utiliser cette phase pour les choses que nous ne voulons pas pour une raison quelconque exécuter dans un rappel. <br><br><h4>  Rappels de fermeture de phase </h4><br>  Cette phase n'exécute pas tous nos rappels de fermeture de socket et d'autres types: <br><br><pre> <code class="javascript hljs">socket.on(<span class="hljs-string"><span class="hljs-string">'close'</span></span>, …).</code> </pre><br>  Elle ne les exécute que si cet événement a volé de façon inattendue, par exemple, quelqu'un à l'autre bout du fil a envoyé: "Tout - fermez la prise - allez d'ici, Vasya!"  Ensuite, cette phase fonctionnera, car l'événement est inattendu.  Mais cela ne nous affecte pas particulièrement. <br><br><h3>  Traitement asynchrone incorrect des morceaux dans Node.js </h3><br>  Que se passera-t-il si nous mettons le même modèle que nous avons pris dans les navigateurs avec setTimeout sur Node.js - c'est-à-dire que nous divisons le tableau en morceaux, pour chaque morceau que nous faisons setTimeout - 0. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bigArray = [<span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>_000_000] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> chunks = getChunks(bigArray) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> parseData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">slice</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">// parse binary data for (chunk of chunks) { setTimeout(() =&gt; parseData(slice), 0) }</span></span></code> </pre><br>  Pensez-vous que cela pose des problèmes? <br><br>  J'ai déjà un peu avancé lorsque j'ai dit que si vous ajoutez 10 000 délais d'attente (ou 10 milliards!), Il y aura 10 000 temporisateurs dans la file d'attente, et il les obtiendra et les exécutera - il n'y a aucune protection contre cela: obtenez - exécutez, obtenez - à accomplir et ainsi de suite à l'infini. <br><br>  Seule la phase d'interrogation, si nous obtenons constamment un événement d'E / S, tout le temps que quelqu'un écrit quelque chose dans le socket afin que nous puissions même exécuter des temporisations et setImmediate, il a une protection limite et dépend du système.  Autrement dit, il différera sur différents systèmes d'exploitation. <br><br>  Malheureusement, d'autres phases, y compris les minuteries et setImmediate, <strong>ne disposent pas d'une telle protection.</strong>  Par conséquent, si vous faites comme dans l'exemple, tout gèlera et n'atteindra pas la phase d'interrogation pendant très longtemps. <br><br>  Mais pensez-vous que quelque chose changera si nous remplaçons setTimeout (() =&gt; parseData (tranche), 0) par setImmediate (() =&gt; parseData (tranche))?  - Naturellement, non, il n'y a pas non plus de protection sur la phase de contrôle. <br><br>  Pour résoudre ce problème, vous pouvez appeler un <strong>traitement récursif</strong> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> parseData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">slice</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">// parse binary data const recursiveAsyncParseData = (i) =&gt; { parseData(getChunk(i)) setImmediate(() =&gt; recursiveAsyncParseData(i + 1)) } recursiveAsyncParseData(0)</span></span></code> </pre><br>  L'essentiel est que nous avons pris la fonction parseData et écrit son appel récursif, mais pas seulement nous-mêmes, mais via setImmediate.  Lorsque vous appelez cela dans la phase setImmediate, il passe au tick suivant, et non au tick courant.  Par conséquent, cela libérera la boucle d'événement, cela ira plus loin dans un cercle.  Autrement dit, nous avons recursiveAsyncParseData, où nous passons un certain index, obtenons le morceau par cet index, l'analysons - puis mettons la file d'attente setImmediate avec l'index suivant.  Cela arrivera à notre prochain tick et nous pouvons traiter récursivement tout cela. <br><br>  Certes, le problème est qu'il s'agit toujours d'une sorte de tâche liée au processeur.  Peut-être qu'elle va encore peser et prendre du temps dans Event Loop.  Il est fort probable que vous souhaitiez que vos Node.js soient purement liés aux E / S. <br>  Par conséquent, il vaut mieux utiliser d'autres choses, par exemple, le <strong>processus fork / thread pool.</strong> <br><br>  Maintenant, nous savons à propos de Node.js que: <br><br><ul><li>  tout est distribué par phases - eh bien, nous le savons clairement; <br></li><li>  il y a une protection contre une phase de scrutin trop longue, mais pas le reste; <br></li><li>  des modèles de traitement récursifs peuvent être appliqués afin de ne pas bloquer la boucle d'événement; </li><li>  Mais il est préférable d'utiliser le processus fork, le pool de threads, le processus enfant </li></ul><br>  Vous devez également être prudent avec le pool de threads, car Node.js démarre les choses là-haut, en particulier la résolution DNS, car pour Linux, pour une raison quelconque, la fonction de résolution DNS n'est pas asynchrone.  Par conséquent, il doit être exécuté dans ThreadPool.  Sur Windows, heureusement, non.  Mais là, vous pouvez lire des fichiers de manière asynchrone.  Sous Linux, malheureusement, c'est impossible. <br><br>  À mon avis, la limite standard est de 4 processus dans ThreadPool.  Par conséquent, si vous faites activement quelque chose là-bas, il sera en concurrence avec tout le monde - avec fs et autres.  Vous pouvez envisager d'augmenter ThreadPool, mais aussi très soigneusement.  Alors lisez quelque chose sur ce sujet. <br><br><h2>  Microtâche: circulation pulmonaire </h2><br>  Nous avons des tâches dans Node.js et des tâches dans les navigateurs.  Vous avez peut-être déjà entendu parler de microtâche.  Voyons ce que c'est et comment ils fonctionnent, et commençons par les navigateurs. <br><br><h3>  Microtâche dans les navigateurs <br></h3><br>  Pour comprendre le fonctionnement de la microtâche, nous nous tournons vers l'algorithme de boucle d'événements selon la norme whatwg, c'est-à-dire, allons à la spécification et voyons à quoi tout cela ressemble. <br><br><img src="https://habrastorage.org/webt/cb/kj/76/cbkj76j9xqsivioo2demagbbfty.png"><br><br>  Traduisant en langage humain, cela ressemble à ceci: <br><br><ul><li>  Prenez la tâche gratuite de notre ligne </li><li>  Nous le réalisons </li><li>  Nous effectuons un point de contrôle des microtâches - OK, nous ne savons toujours pas ce que c'est, mais nous nous en souvenons. </li><li>  Nous mettons à jour le rendu (si nécessaire) et revenons à la case départ. </li></ul><br><img src="https://habrastorage.org/webt/1h/rs/ce/1hrsceluhstlxrdjjr7ig2wh9l0.png"><br><br>  Ils sont effectués à l'endroit indiqué sur le schéma, et dans plusieurs autres endroits, dont nous allons bientôt connaître.  Autrement dit, la tâche est terminée, les microtâches sont exécutées. <br><br><h3>  Sources de microtucks </h3><br><ul><li>  <strong>Promesse.alors.</strong> </li></ul><br>  Important - pas Promise lui-même, à savoir Promise.then.  Le rappel qui a été placé alors est une microtâche.  Si vous avez appelé 10 alors - vous avez 10 microcars, 10 000 alors - 10 000 microcars. <br><br><ul><li>  <strong>Observateur de mutations.</strong> <br></li><li>  <strong>Object.observe</strong> , qui est obsolète et dont personne n'a besoin. <br></li></ul><br>  Combien utilisent l'observateur de mutation? <br><br>  Je pense que peu utilisent l'observateur de mutation.  Très probablement, Promise.then est plus utilisé, c'est pourquoi nous le considérerons dans l'exemple. <br><br>  <strong>Caractéristiques du point de contrôle des microtâches:</strong> <br><br><ul><li>  <strong>Nous faisons tout</strong> - cela signifie que nous réalisons tous les microtâches que nous avons dans la file d'attente jusqu'à la fin.  Nous ne lâchons rien - nous prenons et faisons tout ce qui est, ils devraient être micro, non? </li><li>  Vous pouvez toujours générer de nouvelles microtâches dans le processus, et elles seront exécutées dans le même point de contrôle de microtâches. </li><li>  Ce qui est également important - ils sont exécutés non seulement après l'exécution de la tâche, mais également après avoir effacé la pile. </li></ul><br>  Ceci est un point intéressant.  Il s'avère qu'il est possible de générer de nouveaux microtâches et nous les remplirons tous tous.  À quoi cela peut-il nous conduire? <br><br><img src="https://habrastorage.org/webt/yr/i_/i9/yri_i9mhp2jz-6nyyj7pvfwl6yg.png"><br>  Nous avons deux cœurs.  J'ai animé le premier cœur avec l'animation JS, et le second avec l'animation CSS.  Il existe une autre fonctionnalité intéressante appelée starveMicrotasks.  Nous appelons Promise.resolve, puis mettons la même fonction dans then. <br>  Voyez dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">présentation</a> ce qui se passe si vous appelez cette fonction. <br><br>  Oui, le cœur de JS s'arrêtera, car nous ajoutons une microtâche, puis nous y ajoutons une microtâche, puis nous y ajoutons une microtâche ... Et ainsi de suite sans fin. <br><br>  Autrement dit, l'appel récursif de microtucks va tout bloquer.  Mais il semblerait que j'ai tout asynchrone!  Il faut le laisser partir, j'ai appelé setTimeout là-bas.  Non!  Malheureusement, vous devez être prudent avec la microtâche, donc si vous utilisez un appel récursif d'une manière ou d'une autre, soyez prudent - vous pouvez tout bloquer. <br><br>  De plus, comme nous nous en souvenons, la microtâche est exécutée à la fin du nettoyage de la pile.  Nous nous souvenons de ce qu'est une pile.  Il s'avère que dès que nous sommes sortis de notre code, le rappel setTimeout a été exécuté - c'est tout - les microtâches sont allées là.  Cela peut entraîner des effets secondaires intéressants. <br><br>  Prenons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un exemple</a> . <br><br><img src="https://habrastorage.org/webt/kf/e-/tq/kfe-tqsysmprki74ayahty-n9ke.png"><br><br>  Il y a un bouton et un récipient gris dans lequel il se trouve.  Nous souscrivons au clic du bouton et du conteneur. ,   , ,       . <br><br>     2 : <br><br><ol><li> Promise.resolve; </li><li> .then,    console.log('RO') </li></ol><br>       «FUS»,      – «DAH!» (    ). <br><br>   ,      ?      ,    ,   «FUS RO DAH!»  Super!  ,   . <br><br><img src="https://habrastorage.org/webt/3g/b6/w3/3gb6w3gi4es-fzxcicyk2batfm8.png"><br><br>       ,            ,        .   –  . , -   ? <br><br><img src="https://habrastorage.org/webt/uo/-t/dx/uo-tdxdjrfwgt0vvse4a6vuqips.png"><br><br>  !         . <br><br><img src="https://habrastorage.org/webt/yk/ob/w3/ykobw30-vcw5h6t6vvlitwk-y2a.png"><br><br>  ,   . <br><br> ,      ,     ,     .  ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a> . <br><br><ul><li>         — buttonHandleClick,    . </li><li>    Promise.resolve.     .   ,      console.log('RO')  .   . </li><li>      console.log('FUS'). </li><li>   buttonHandleClick       .        . </li><li>   ,      (divHandleClick)    ,  «DAH!». </li><li> HandleClick . </li></ul><br>  ,     .         ?     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a> : <br><br><ul><li>  button.click().     . </li><li>   button HandleClick. </li><li>  Promise.resolve  then.      , Promise.resolve . </li><li>    console.log   «FUS». </li><li>    buttonHandleClick    ,    . </li></ul><br>     (click)  ,       ,    .     divHandleClick , ,  console.log('DAH!') .        ,      . <br><br>   , ,    button.click   . <br>        .   , ,   .  ,    ,    . <br><br>    :     ()       (  ).   - ,      ,   stopPropagation.  ,     ,  ,  ,   -   ,  . <br><br>  ,  -   ( junior-)     —      «»,    promise,  ,    then  ,  -  .    ,  <strong>    ,    </strong> :   ,    ,  .   .        ,   -       . <br><br>    (  4)    ,        .     ,   ,  ,   ,      -   .           . <br><br> <strong>     , :</strong> <br><br><ul><li>      Event Loop.  C'est désagréable. </li><li>         ,   . </li></ul><br>           ,    .  —   ,     ,  . <br><br><h2>   Node.js <br></h2><br>   Node.js  Promise.then  process.nextTick.      ,    —    .   ,   , ,   , . <br><br><h3> process.nextTick <br></h3><br> ,     process.nextTick,   setImmediate?      Node.js  ? <br><br>    .     createServer,   EventEmitter,    ,     listen (  ),      . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> createServer = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> evEmitter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventEmitter() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">listen</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">port</span></span></span><span class="hljs-function"> =&gt;</span></span> { evEmitter.emit(<span class="hljs-string"><span class="hljs-string">'listening'</span></span>, port) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evEmitter } } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = createServer().listen(<span class="hljs-number"><span class="hljs-number">8080</span></span>) server.on(<span class="hljs-string"><span class="hljs-string">'listening'</span></span>, () =&gt; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'listening'</span></span>))</code> </pre><br>    ,  ,   8080,    listening   console.log  - . <br><br>  ,       ,      - . <br><br>    createServer,    .       listen,      ,        .        . <br><br>  ,    ,    .  Que peut-on faire?   process.nextTick:  evEmitter.emit('listening', port)  process.nextTick(() =&gt; evEmitter.emit('listening', port)). <br><br>   ,  <strong>process.nextTick     ,    </strong> .    EventEmitter,     . ,   ,      API,       .    process.nextTick,   emit    ,  userland  .      createServer,  ,  listen,    listening.     —    process.nextTick — !  ,     ,  . <br><br>     process.nextTick  .     ,         . <br><br>   ,  process.nextTick    ,  Promise.then  .     process.nextTick ,     —    ,   Event Loop,  Node.js. , ,   . <br><br> <strong> process.nextTick    </strong> ,   ghbvtybnm  setImmediate   ,        C++  ..  process.nextTick       . <br><br><h2> Async/await </h2><br>      API — async/await, - .    .    , async/await   Promise,     Event Loop      .     ,          . <br><br><h2>  Liens utiles </h2><br><ul><li>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Philip Roberts. What the heck is the event loop anyway?</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bert Belder. Everything you need to know about Node.js event loop.</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jake Archibald. In the Loop</a> . <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">The Node.js Event Loop, Timers, and process.nextTick()</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WHATWG Specification event loop processing model</a> <br></li></ul><br> <strong>,     !</strong> <br><br><blockquote>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Frontend Conf</a>     — 4  5   ,  .    ,        : <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Grid Layout    </a> /   ( .) <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Building decentralised apps with JS</a> /   (ING) <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> /   () <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">StoreWars (ngxs, redux, vuex)</a> /  ,   (Cinimex) <br></li></ul><br>  Venez, ce sera intéressant! <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr417461/">https://habr.com/ru/post/fr417461/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr417449/index.html">Jurassic World: pouvons-nous vraiment ressusciter des dinosaures?</a></li>
<li><a href="../fr417451/index.html">Cinq erreurs courantes pour les débutants</a></li>
<li><a href="../fr417453/index.html">Organisation de stages pour étudiants: râteau et astuces</a></li>
<li><a href="../fr417457/index.html">Frontend Conf Moscow - côté client entrant et sortant</a></li>
<li><a href="../fr417459/index.html">Connaissez votre JIT: plus près de la voiture</a></li>
<li><a href="../fr417463/index.html">Une rencontre inattendue. Chapitre 17</a></li>
<li><a href="../fr417465/index.html">Un aperçu des méthodes de liaison de texte</a></li>
<li><a href="../fr417469/index.html">Cinq raisons égoïstes de travailler de manière reproductible</a></li>
<li><a href="../fr417471/index.html">Simple Solder MK936 SMD. Station de soudage DIY pour composants CMS</a></li>
<li><a href="../fr417473/index.html">Stockage sécurisé avec DRBD9 et Proxmox (Partie 1: NFS)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>