<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üçò üë®‚Äçüëß‚Äçüëß üíñ Ivan Tulup: asynchrone en JS sous le capot üë©üèº‚Äçüî¨ üÜï üíä</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Connaissez-vous Ivan Tulup? Tr√®s probablement oui, vous ne savez pas encore de quel type de personne il s'agit, et vous devez faire tr√®s attention √† l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Ivan Tulup: asynchrone en JS sous le capot</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/417461/">  Connaissez-vous Ivan Tulup?  Tr√®s probablement oui, vous ne savez pas encore de quel type de personne il s'agit, et vous devez faire tr√®s attention √† l'√©tat de son syst√®me cardiovasculaire. <br><br>  √Ä ce sujet et comment l'asynchronisme fonctionne dans JS sous le capot, comment fonctionne la boucle d'√©v√©nement dans les navigateurs et Node.js, y a-t-il des diff√©rences et peut-√™tre des choses similaires ont √©t√© racont√©es par <strong>Mikhail Bashurov</strong> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" class="user_link">SaitoNakamura</a> ) dans son rapport sur RIT ++.  Nous sommes heureux de partager avec vous la transcription de cette pr√©sentation informative. <br><br><img src="https://habrastorage.org/webt/mv/fj/ah/mvfjah-dahl8fndi-w8rt4qkbxw.jpeg"><br><br>  <strong>√Ä propos de l'orateur:</strong> Mikhail Bashurov est un d√©veloppeur Web fullstack sur JS et .NET de Luxoft.  Il aime la belle interface utilisateur, les tests verts, la transpilation, la compilation, le compilateur permettant la technique et am√©liorer l'exp√©rience de d√©veloppement. <br><br>  <strong>Note de l'√©diteur:</strong> le rapport de Mikhail √©tait accompagn√© non seulement de diapositives, mais d'un projet de d√©monstration dans lequel vous pouvez cliquer sur les boutons et regarder ind√©pendamment l'ex√©cution des shuffles.  La meilleure option serait d'ouvrir la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pr√©sentation</a> dans un onglet adjacent et de s'y r√©f√©rer p√©riodiquement, mais le texte fournira √©galement des liens vers des pages sp√©cifiques.  Et maintenant, nous passons la parole √† l'orateur, profitez-en pour lire. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/bUx8wk4LdoY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><a name="habracut"></a><br><h2>  Grand-p√®re Ivan Tulup </h2><br>  J'ai eu une candidature pour Ivan Tulup. <br><br><img src="https://habrastorage.org/webt/hl/8x/lx/hl8xlx_fubycz-ivega_hinmhp0.png"><br><br>  Mais j'ai d√©cid√© d'emprunter une voie plus conformiste, alors rencontrez - le grand-p√®re Ivan Tulup! <br><br><img src="https://habrastorage.org/webt/qd/jc/dn/qdjcdntndkzeyiuw3zpwt4vos74.png"><br><br>  En fait, seulement deux choses doivent √™tre connues de lui: <br><br><ol><li>  Il aime jouer aux cartes. </li><li>  Comme tout le monde, il a un c≈ìur et il bat. </li></ol><br><h2>  Faits sur la crise cardiaque </h2><br>  Vous avez peut-√™tre entendu dire que les cas de maladies cardiaques et leur mortalit√© sont r√©cemment devenus plus fr√©quents.  La maladie cardiaque la plus courante est probablement une crise cardiaque, c'est-√†-dire une crise cardiaque. <br><br>  Qu'est-ce qui est int√©ressant avec la crise cardiaque? <br><br><ul><li>  Le plus souvent, cela se produit le lundi matin. </li><li>  Chez les personnes seules, le risque de crise cardiaque est deux fois plus √©lev√©.  Ici, peut-√™tre, le point est uniquement en corr√©lation, et non dans une relation causale.  Malheureusement (ou heureusement), il en est ainsi. </li><li>  Dix chefs d'orchestre sont d√©c√©d√©s d'une crise cardiaque pendant la conduite (travail apparemment tr√®s nerveux!). </li><li>  Une crise cardiaque est une n√©crose du muscle cardiaque caus√©e par un manque de circulation sanguine. </li></ul><br>  Nous avons une art√®re coronaire qui apporte du sang au muscle (myocarde).  Si le sang commence √† y circuler mal, le muscle meurt progressivement.  Naturellement, cela a un effet extr√™mement n√©gatif sur le c≈ìur et son travail. <br><br>  Le grand-p√®re Ivan Tulup a aussi un c≈ìur et il bat.  Mais notre c≈ìur pompe le sang, et le c≈ìur d'Ivan Tulup pompe notre code et nos peines. <br><br><h2>  Tasky: un grand cercle de circulation sanguine <br></h2><br>  Quelles sont les t√¢ches?  Qu'est-ce qui peut √™tre g√©n√©ralement paresseux dans un navigateur?  Pourquoi sont-ils n√©cessaires du tout? <br><br>  Par exemple, nous ex√©cutons du code √† partir d'un script.  C'est un battement de c≈ìur, et maintenant nous avons le flux sanguin.  Nous avons cliqu√© sur le bouton et nous sommes abonn√©s √† l'√©v√©nement - le gestionnaire d'√©v√©nements pour cet √©v√©nement a crach√© - le rappel que nous avons envoy√©.  Ils ont mis Timeout, Callback travaill√© - une autre t√¢che.  Et donc dans certaines parties, un battement de c≈ìur est une t√¢che. <br><br><img src="https://habrastorage.org/webt/vz/sb/0z/vzsb0znwotnkpldqmb2chhwblxs.png"><br><br>  Il existe de nombreuses sources diff√©rentes de chou, selon les sp√©cifications, il y en a un grand nombre.  Notre c≈ìur continue de battre, et pendant qu'il bat, tout va bien pour nous. <br><br><h3>  Boucle d'√©v√©nement dans le navigateur: version simplifi√©e <br></h3><br>  Cela peut √™tre repr√©sent√© dans un diagramme tr√®s simple. <br><br><img src="https://habrastorage.org/webt/hy/zf/2p/hyzf2pktcyzag0oroich978odpa.png"><br><br><ul><li>  Il y a une t√¢che, nous l'avons accomplie. </li><li>  Ensuite, nous ex√©cutons le rendu du navigateur. </li></ul><br>  Mais en fait, cela n'est pas n√©cessaire, car dans certains cas, le navigateur peut ne pas afficher entre deux t√¢ches. <br><br>  Cela peut se produire, par exemple, si le navigateur peut d√©cider de regrouper plusieurs d√©lais d'expiration ou plusieurs √©v√©nements de d√©filement.  Ou √† un moment donn√©, quelque chose ne va pas, et le navigateur d√©cide au lieu de 60 ips (fr√©quence d'images normale pour que tout se passe bien et en douceur) d'afficher 30 ips.  Ainsi, il aura beaucoup plus de temps pour ex√©cuter votre code et autres travaux utiles, il pourra effectuer plusieurs chocs. <br><br>  Par cons√©quent, le rendu n'est pas vraiment effectu√© apr√®s chaque t√¢che. <br><br><h3>  Tasky: classification <br></h3><br>  Il existe deux types d'op√©rations potentielles: <br><br><ol><li>  E / S li√©es; </li><li>  Li√© au processeur. </li></ol><br>  <strong>Le CPU</strong> est notre travail utile que nous faisons (croire, afficher, etc.) <br><br>  <strong>Les E / S li√©es</strong> sont les points auxquels nous pouvons partager nos t√¢ches.  Ce pourrait √™tre: <br><br><ul><li>  Timeout </li></ul>  Nous avons fait setTimeout 5000 ms, et nous attendons juste ces 5000 ms, mais nous pouvons faire d'autres travaux utiles.  Ce n'est que lorsque ce temps passe, que nous recevons un rappel et que nous y travaillons. <br><br><ul><li>  xhr / fetch. </li></ul>  Nous sommes all√©s en ligne.  Pendant que nous attendons une r√©ponse du r√©seau, nous attendons simplement, mais nous pouvons aussi faire quelque chose d'utile. <br><br><ul><li>  R√©seau (OBD). </li></ul>  Ou, par exemple, nous allons sur Network BD.  Nous parlons √©galement de Node.js, y compris, et si nous voulons aller quelque part vers le r√©seau √† partir de Node.js, veuillez - c'est la m√™me t√¢che potentielle li√©e aux E / S (entr√©e / sortie). <br><br><ul><li>  Fichier. </li></ul>  Lisez le fichier - ce n'est potentiellement pas une t√¢che li√©e au processeur.  Dans Node.js, il s'ex√©cute dans le pool de threads en raison d'une API Linux l√©g√®rement tordue, pour √™tre honn√™te. <br><br>  Alors CPUbound est: <br><br><ul><li>  Par exemple, lorsque nous faisons une boucle for of / for (;;) ou que nous traversons le tableau d'une mani√®re ou d'une autre en utilisant des m√©thodes suppl√©mentaires: filtre, carte, etc. </li><li>  JSON.parse ou JSON.stringify, c'est-√†-dire la s√©rialisation / d√©s√©rialisation des messages.  Tout cela se fait sur le CPU, nous ne pouvons pas attendre que tout soit ex√©cut√© par magie quelque part. </li><li>  Compter les hachages, c'est-√†-dire, par exemple, l'extraction de crypto. </li></ul><br>  Bien s√ªr, la crypto peut √©galement √™tre exploit√©e sur le GPU, mais je pense - GPU, CPU - vous comprenez cette analogie. <br><br><h3>  Tasky: arythmie et thrombus </h3><br>  En cons√©quence, il s'av√®re que notre c≈ìur bat: il fait une t√¢che, la deuxi√®me, la troisi√®me - jusqu'√† ce que nous fassions quelque chose de mal.  Par exemple, nous parcourons un tableau de 1 million d'√©l√©ments et comptons la somme.  Il semblerait que ce ne soit pas si difficile, mais cela peut prendre du temps tangible.  Si nous prenons constamment du temps tangible sans lib√©rer de t√¢che, notre rendu ne peut pas √™tre effectu√©.  Il a plan√© dans ce d√©sir, et tout - l'arythmie commence. <br><br>  Je pense que tout le monde comprend que l'arythmie est une maladie cardiaque plut√¥t d√©sagr√©able.  Mais vous pouvez toujours vivre avec lui.  Que se passe-t-il si vous placez une t√¢che qui suspend simplement la boucle d'√©v√©nement enti√®re dans une boucle sans fin?  Vous mettez en quelque sorte un caillot de sang dans la coronaire ou une autre art√®re, et tout deviendra compl√®tement triste.  Malheureusement, notre grand-p√®re Ivan Tulup va mourir. <br><br><h3>  Alors le grand-p√®re Ivan est mort ... <br></h3><br><img src="https://habrastorage.org/webt/8t/nq/gc/8tnqgc8lygwpsdvts0b3xpqgtta.png"><br><br>  Pour nous, cela signifie que l'onglet entier se bloque compl√®tement - vous ne pouvez pas cliquer sur quoi que ce soit, puis Chrome dit: "Aw, Snap!" <br><br>  C'est encore pire que les bugs du site Web en cas de probl√®me.  Mais si tout a raccroch√©, et m√™me, probablement, le processeur charg√© et l'utilisateur g√©n√©ralement bloqu√©, il ne reviendra probablement jamais sur votre site. <br><br>  Par cons√©quent, l'id√©e est la suivante: nous avons une t√¢che et nous n'avons pas besoin de nous accrocher √† cette t√¢che pendant tr√®s longtemps.  Nous devons le lib√©rer rapidement, afin que le navigateur, le cas √©ch√©ant, puisse effectuer un rendu (s'il le souhaite).  Si vous ne voulez pas - super, dansez! <br><br><h2>  D√©mo de Philip Roberts: Loupe de Philip Roberts <br></h2><br>  Prenons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un exemple</a> : <br><br><pre><code class="javascript hljs">$.on(<span class="hljs-string"><span class="hljs-string">'button'</span></span>, <span class="hljs-string"><span class="hljs-string">'click'</span></span>, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onClick</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'click'</span></span>); }); setTimeout(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">timeout</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-built_in"><span class="hljs-built_in">console</span></span> log(<span class="hljs-string"><span class="hljs-string">"timeout"</span></span>); }. <span class="hljs-number"><span class="hljs-number">5000</span></span>); <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(‚ÄúHello world<span class="hljs-string"><span class="hljs-string">");</span></span></code> </pre> <br>  L'essence est la suivante: nous avons un bouton, nous nous y abonnons (addEventListener), Timeout est appel√© pendant 5 secondes et imm√©diatement dans le console.log nous √©crivons "Bonjour, monde!", Dans setTimeout nous √©crivons Timeout, dans onClick nous √©crivons Click. <br><br>  Que se passera-t-il si nous l'ex√©cutons et plusieurs fois nous cliquons sur le bouton - quand le Timeout sera-t-il r√©ellement ex√©cut√©?  Voyons la d√©mo: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/bUx8wk4LdoY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Le code commence √† s'ex√©cuter, se met sur la pile, le Timeout dispara√Æt.  Pendant ce temps, nous avons cliqu√© sur le bouton.  Au bas de la file d'attente, plusieurs √©v√©nements ont √©t√© ajout√©s.  Pendant que Click est en cours d'ex√©cution, Timeout attend, bien que 5 secondes se soient √©coul√©es. <br><br>  Ici, onClick est rapide, mais si vous mettez une t√¢che plus longue, alors tout se fige, comme d√©j√† expliqu√©.  Ceci est un exemple tr√®s simplifi√©.  Voici un tour, mais dans les navigateurs, en fait, tout n'est pas le cas. <br><br>  Dans quel ordre les √©v√©nements sont-ils ex√©cut√©s - que dit la sp√©cification HTML? <br><br>  Elle dit ce qui suit: nous avons 2 concepts: <br><br><ol><li>  source de la t√¢che; </li><li>  file d'attente des t√¢ches. </li></ol><br>  La source de t√¢che est une sorte de t√¢che.  Cela peut √™tre une interaction utilisateur, c'est-√†-dire onClick, onChange - quelque chose avec lequel l'utilisateur interagit;  ou des minuteries, c'est-√†-dire setTimeout et setInterval, ou PostMessages;  ou m√™me des types compl√®tement sauvages comme la source de t√¢che Canvas Blob Serialization - √©galement un type distinct. <br><br>  La sp√©cification indique que pour la m√™me t√¢che, les t√¢ches seront garanties d'√™tre ex√©cut√©es dans l'ordre o√π elles sont ajout√©es.  Pour tout le reste, rien n'est garanti, car il peut y avoir un nombre illimit√© de files d'attente de t√¢ches.  Le navigateur d√©cide combien il y en aura.  √Ä l'aide de la file d'attente des t√¢ches et de leur cr√©ation, le navigateur peut hi√©rarchiser certaines t√¢ches. <br><br><h3>  Priorit√©s du navigateur et files d'attente de t√¢ches <br></h3><br><img src="https://habrastorage.org/webt/xv/fu/s9/xvfus9kn-18e_oxy00s_xwm6vdq.png"><br><br>  Imaginez que nous ayons 3 lignes: <br><br><ol><li>  interaction avec l'utilisateur; </li><li>  d√©lais </li><li>  publier des messages. </li></ol><br>  Le navigateur commence √† obtenir des t√¢ches √† partir de ces files d'attente: <br><br><ul><li>  Tout d'abord, il prend en <strong>charge</strong> l'interaction utilisateur - c'est tr√®s important - un battement de c≈ìur a disparu. <br></li><li>  Puis il prend <strong>postMessages</strong> - eh bien, postMessages est une priorit√© assez √©lev√©e, cool! <br></li><li>  Le suivant, <strong>onChange,</strong> est √©galement √† nouveau de l'interaction utilisateur en priorit√©. <br></li><li>  Le prochain <strong>onClick est</strong> envoy√©.  La file d'attente d'interaction avec l'utilisateur est termin√©e, nous avons montr√© √† l'utilisateur tout ce dont il avait besoin. <br></li><li>  Ensuite, nous prenons <strong>setInterval</strong> , ajoutons postMessages. <br></li><li>  <strong>setTimeout n'ex√©cutera que la plus r√©cente</strong> .  Il √©tait quelque part au bout de la ligne. <br></li></ul><br>  Il s'agit l√† encore d'un exemple tr√®s simplifi√© et, malheureusement, <strong>personne ne peut garantir comment cela fonctionnera dans les navigateurs</strong> , car ils d√©cident eux-m√™mes de tout cela.  Vous devez tester cela vous-m√™me si vous voulez savoir ce que c'est. <br><br>  Par exemple, postMessages a priorit√© sur setTimeout.  Vous avez peut-√™tre entendu parler d'une chose telle que setImmediate, qui, par exemple, dans les navigateurs IE, n'√©tait que native.  Mais il existe des polyfichiers qui sont principalement bas√©s non pas sur setTimeout, mais sur la cr√©ation d'un canal postMessages et sur son abonnement.  Cela fonctionne g√©n√©ralement plus rapidement car les navigateurs le priorisent. <br><br>  Eh bien, ces t√¢ches sont effectu√©es.  √Ä quel moment terminons-nous notre t√¢che et comprenons-nous que nous pouvons prendre la suivante, ou que nous pouvons rendre? <br><br><h3>  Pile </h3><br>  La pile est une structure de donn√©es simple qui fonctionne sur le principe du "dernier entr√© - premier sorti", c'est-√†-dire  "J'ai mis le dernier - tu as le premier <strong>.</strong> "  La contrepartie la plus proche, probablement r√©elle, est un jeu de cartes.  Par cons√©quent, notre grand-p√®re Ivan Tulup aime jouer aux cartes. <br><br><img src="https://habrastorage.org/webt/5b/03/dh/5b03dh5di0r9oktsyvekmflkey4.png"><br><br>  L'exemple ci-dessus, dans lequel il y a du code, le m√™me exemple peut √™tre pouss√© dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pr√©sentation</a> .  √Ä un certain endroit, nous appelons handleClick, entrez console.log, appelons showPopup et window.  confirmer.  Formons une pile. <br><br><ul><li>  Donc, nous prenons d'abord handleClick et poussons l'appel √† cette fonction sur la pile - super! </li><li>  Ensuite, nous entrons dans son corps et l'ex√©cutons. </li><li>  Nous mettons console.log sur la pile et l'ex√©cutons imm√©diatement, car tout est l√† pour l'ex√©cuter. </li><li>  Ensuite, nous mettons showConfirm - c'est un appel de fonction - super. </li><li>  Nous mettons des fonctions sur la pile - nous mettons son corps, c'est-√†-dire window.confirm. </li></ul><br>  Nous n'avons plus rien - nous le faisons.  Une fen√™tre appara√Ætra: ¬´√ätes-vous s√ªr?¬ª, Cliquez sur ¬´Oui¬ª, et tout quittera la pile.  Nous avons maintenant termin√© le corps showConfirm et le corps handleClick.  Notre pile est effac√©e et nous pouvons passer √† la t√¢che suivante.  Question: OK, je sais maintenant que vous devez tout casser en petits morceaux.  Comment puis-je, par exemple, faire cela dans le cas le plus √©l√©mentaire? <br><br><h3>  Partitionner un tableau en morceaux et les traiter de mani√®re asynchrone </h3><br>  Regardons l'exemple le plus ¬´frontal¬ª.  Je vous pr√©viens tout de suite: n'essayez pas de r√©p√©ter cela √† la maison - cela ne se compilera pas. <br><br><img src="https://habrastorage.org/webt/on/a4/kz/ona4kz7lojjan82vfis4dkoxvh0.png"><br><br>  Nous avons un grand, grand tableau, et nous voulons calculer quelque chose en fonction de celui-ci, par exemple, pour analyser certaines donn√©es binaires.  Nous pouvons simplement le diviser en morceaux: traiter cette pi√®ce, ceci et cela.  Nous s√©lectionnons la taille du morceau, par exemple, 10 000 √©l√©ments, nous consid√©rons combien de morceaux nous aurons.  Nous avons une fonction parseData qui va dans le CPU et peut vraiment faire quelque chose de lourd.  Ensuite, nous divisons le tableau en morceaux, d√©finissez setTimeout (() =&gt; parseData (tranche), 0). <br><br>  Dans ce cas, le navigateur pourra √† nouveau hi√©rarchiser l'interaction de l'utilisateur et effectuer le rendu entre les deux.  Autrement dit, vous lib√©rez au moins votre boucle d'√©v√©nement, et cela continue de fonctionner.  Votre c≈ìur continue de battre et c'est bien. <br><br>  Mais c'est vraiment un exemple tr√®s ¬´frontal¬ª.  Il existe de nombreuses API dans les navigateurs pour vous aider √† le faire de mani√®re plus sp√©cialis√©e. <br><br>  Outre setTimeout et setInterval, il existe des API qui vont au-del√† des limites, telles que, par exemple, requestAnimationFrame et requestIdleCallback. <br><br>  Beaucoup connaissent <strong>probablement requestAnimationFrame</strong> et l'utilisent d√©j√†.  Il est ex√©cut√© avant le rendu.  Son charme est que, d'une part, il essaie d'ex√©cuter toutes les 60 ips (ou 30 ips), et d'autre part, tout cela se fait imm√©diatement avant de cr√©er le mod√®le d'objet CSS, etc. <br><br><img src="https://habrastorage.org/webt/0-/hy/qt/0-hyqtkge9dm9ayeciqrrzgjors.png"><br><br>  Par cons√©quent, m√™me si vous avez plusieurs requestAnimationFrame, ils regrouperont en fait toutes les modifications et le cadre sortira complet.  Dans le cas de setTimeout, vous ne pouvez certainement pas obtenir une telle garantie.  Un setTimeout changera une chose, l'autre une autre, et entre le rendu peut glisser - vous aurez une secousse de l'√©cran ou autre chose.  RequestAnimationFrame est id√©al pour cela. <br><br>  En plus de cela, il existe √©galement <strong>requestIdleCallback.</strong>  Vous avez peut-√™tre entendu dire qu'il est utilis√© dans React v16.0 (Fibre).  RequestIdleCallback fonctionne de telle mani√®re que si le navigateur comprend qu'il a du temps entre les images (60 ips) pour faire quelque chose d'utile, et en m√™me temps, il a d√©j√† tout fait - ils ont fait la t√¢che, requestAnimationFrame a fait - cela semble cool, alors √ßa peut produire de petits quanta, disons, 50 ms chacun, vous pouvez donc faire quelque chose (mode IDLE). <br><br>  Ce n'est pas dans le sch√©ma ci-dessus, car il n'est situ√© √† aucun endroit particulier.  Le navigateur peut d√©cider de le placer avant le cadre, apr√®s le cadre, entre le requestAnimationFrame et le rendu, apr√®s la t√¢che, avant la t√¢che.  Personne ne peut garantir cela. <br><br>  Il vous est garanti que si vous avez du travail qui n'est pas li√© √† la modification du DOM (car alors requestAnimationFrame est une animation et ainsi de suite), alors qu'il n'est pas super prioritaire, mais tangible, alors requestIdleCallback est votre chemin. <br><br>  Donc, si nous avons une longue op√©ration li√©e au processeur, nous pouvons essayer de la diviser en morceaux. <br><br><ul><li>  S'il s'agit d'un changement DOM, utilisez <strong>requestAnimationFrame.</strong> <br></li><li>  S'il s'agit d'une t√¢che non prioritaire, de courte dur√©e et non difficile qui ne <strong>surchargera</strong> pas <strong>le</strong> processeur, alors <strong>requestIdleCallback.</strong> <br></li><li>  Si nous avons une grosse t√¢che puissante qui doit √™tre effectu√©e en permanence, nous allons au-del√† de la boucle d'√©v√©nement et utilisons WebWorkers.  Il n'y a pas d'autre moyen. <br></li></ul><br>  <strong>T√¢ches dans les navigateurs:</strong> <br><br><ol><li>  √âcrasez tout en petites t√¢ches. </li><li>  Il existe de nombreux types de t√¢ches. </li><li>  Les t√¢ches sont hi√©rarchis√©es par ces types via des files d'attente de sp√©cifications. </li><li>  Les navigateurs d√©cident en grande partie et la seule fa√ßon de comprendre comment cela fonctionne est de simplement v√©rifier si l'un ou l'autre code est en cours d'ex√©cution. </li><li>  Mais le cahier des charges n'est pas toujours respect√©! </li></ol><br>  Le probl√®me est que notre Ivan Tulup est un vieux grand-p√®re, car les impl√©mentations de la boucle d'√©v√©nement dans les navigateurs sont √©galement tr√®s anciennes.  Ils ont √©t√© cr√©√©s avant la r√©daction de la sp√©cification, de sorte que la sp√©cification est malheureusement respect√©e dans la mesure o√π.  M√™me si vous lisez √† quoi devrait ressembler la sp√©cification, personne ne garantit que tous les navigateurs la prennent en charge.  Assurez-vous donc de v√©rifier dans les navigateurs comment cela fonctionne r√©ellement. <br><br>  Le grand-p√®re Ivan Tulup dans les navigateurs est une personne peu pr√©visible, avec quelques fonctionnalit√©s int√©ressantes, vous devez vous en souvenir. <br><br><h2>  Terminator Santa: boucle de mascotte sur Node.js <br></h2><br>  Node.js ressemble plus √† quelqu'un comme √ßa. <br><br><img src="https://habrastorage.org/webt/bb/5u/bx/bb5ubx5cvdgtu2lilmk-rfmeajc.png"><br><br>  Parce que d'un c√¥t√© c'est le m√™me grand-p√®re avec une barbe, mais en m√™me temps tout est r√©parti en phases et il est clairement peint o√π ce qui se fait. <br><br>  <strong>Phases de la boucle d'√©v√©nement dans Node.js:</strong> <br><br><ul><li>  minuteries; <br></li><li>  rappel en attente; <br></li><li>  au ralenti, se pr√©parer; <br></li><li>  sondage; <br></li><li>  v√©rifier; <br></li><li>  fermer les rappels. <br></li></ul><br>  Tout sauf le dernier n'est pas tr√®s clair ce que cela signifie.  Les phases ont des noms si √©tranges, car sous le capot, comme nous le savons d√©j√†, nous avons Libuv pour gouverner tout le monde: <br><br><ul><li>  <em>Linux -</em> epoll / POSIX AIO; <br></li><li>  <em>BSD -</em> kqueue; <br></li><li>  <em>Windows -</em> IOCP; <br></li><li>  <em>Solaris -</em> ports d'√©v√©nements. <br></li></ul><br>  Des milliers d'entre eux tous! <br><br>  De plus, Libuv fournit √©galement la m√™me boucle d'√©v√©nement.  Il n'a pas les sp√©cificit√©s de Node.js, mais il y a des phases, et Node.js les utilise simplement.  Mais pour une raison quelconque, elle a pris les noms de l√†. <br><br>  Voyons ce que signifie r√©ellement chaque phase. <br><br><h4>  La phase Timers effectue: <br></h4><br><ul><li>  Minuteries pr√™tes pour le rappel; <br></li><li>  setTimeout et setInterval; <br></li><li>  Mais <strong>PAS</strong> setImmediate est une phase diff√©rente. <br></li></ul><br><h4>  Rappels de phase en attente <br></h4><br>  Avant cela, la phase de documentation appelait les rappels d'E / S.  Plus r√©cemment, cette documentation a √©t√© corrig√©e et elle a cess√© de se contredire.  Avant cela, √† un endroit, il √©tait √©crit que les rappels d'E / S √©taient ex√©cut√©s dans cette phase, dans une autre - celle de la phase d'interrogation.  Mais maintenant, tout y est √©crit sans √©quivoque et bien, alors lisez la documentation - quelque chose deviendra beaucoup plus compr√©hensible. <br><br>  Dans la phase de rappel en attente, les rappels de certaines op√©rations syst√®me (erreur TCP) sont ex√©cut√©s.  Autrement dit, si dans Unix il y a une erreur dans le socket TCP, dans ce cas, il ne veut pas le jeter imm√©diatement, mais dans le rappel, qui sera ex√©cut√© juste dans cette phase.  C‚Äôest tout ce que nous devons savoir sur elle.  Nous n'y sommes pratiquement pas int√©ress√©s. <br><br><h4>  Phase inactive, pr√©parer <br></h4><br>  Dans cette phase, nous ne pouvons rien faire du tout, nous allons donc l‚Äôoublier en principe. <br><br><img src="https://habrastorage.org/webt/xa/6l/n-/xa6ln-ao3qbubxteqecnh8lm5ke.png"><br><br><h4>  Phase de sondage <br></h4><br>  C'est la phase la plus int√©ressante de Node.js car elle fait le principal travail utile: <br><br><ul><li>  Effectue des rappels d'E / S (pas de phase de rappel en attente!). </li><li>  Attente d'√©v√©nements d'E / S; </li><li>  C'est cool de faire setImmediate; </li><li>  Pas de minuteries; </li></ul><br>  √Ä l'avenir, setImmediate s'ex√©cutera dans la prochaine phase de v√©rification, c'est-√†-dire garantie avant les temporisateurs. <br><br>  Et la phase d'interrogation contr√¥le √©galement le flux de la boucle d'√©v√©nements.  Par exemple, si nous n'avons pas de temporisateurs, il n'y a pas de setImmediate, c'est-√†-dire que personne n'a le temporisateur, setImmediate n'a pas appel√©, nous bloquons simplement dans cette phase et attendons l'√©v√©nement des E / S, si quelque chose nous arrive, s'il y a des rappels si nous nous sommes inscrits pour quelque chose. <br><br>  Comment un mod√®le non bloquant est-il impl√©ment√©?  Par exemple, au m√™me Epoll, nous pouvons nous abonner √† un √©v√©nement - ouvrir une socket et attendre que quelque chose y soit √©crit.  De plus, le deuxi√®me argument est le timeout, c'est-√†-dire  nous attendrons Epoll, mais si le d√©lai expire et que l'√©v√©nement des E / S ne se produit pas, il quittera le d√©lai.  Si un √©v√©nement nous vient du r√©seau (quelqu'un √©crit sur socket), il viendra. <br><br>  Par cons√©quent, la phase d'interrogation supprime le tas (le tas est une structure de donn√©es qui permet une livraison et une livraison bien tri√©es) du premier rappel, prend son d√©lai d'expiration, √©crit dans ce d√©lai et lib√®re tout.  Ainsi, m√™me si personne ne nous √©crit dans le socket, le d√©lai d'attente fonctionnera, retournera √† la phase d'interrogation et le travail se poursuivra. <br><br><blockquote>  Il est important de noter que dans la phase de sondage, il y a une limite sur le nombre de rappels √† la fois. <br></blockquote><br>  Il est triste que ce ne soit pas le cas dans les phases restantes.  Si vous ajoutez 10 milliards d'expiration, vous ajoutez 10 milliards d'expiration.  Par cons√©quent, la phase suivante est la phase de v√©rification. <br><br><h4>  Phase de v√©rification </h4><br>  C'est l√† que setImmediate s'ex√©cute.  La phase est belle dans la mesure o√π setImmediate, appel√© dans la phase d'interrogation, est garanti pour s'ex√©cuter plus t√¥t que le temporisateur.  Parce que le chronom√®tre ne sera activ√© que sur le tick suivant au tout d√©but, et plus t√¥t √† partir de la phase de sondage.  Par cons√©quent, nous ne pouvons pas avoir peur de la concurrence avec d'autres chronom√®tres et utiliser cette phase pour les choses que nous ne voulons pas pour une raison quelconque ex√©cuter dans un rappel. <br><br><h4>  Rappels de fermeture de phase </h4><br>  Cette phase n'ex√©cute pas tous nos rappels de fermeture de socket et d'autres types: <br><br><pre> <code class="javascript hljs">socket.on(<span class="hljs-string"><span class="hljs-string">'close'</span></span>, ‚Ä¶).</code> </pre><br>  Elle ne les ex√©cute que si cet √©v√©nement a vol√© de fa√ßon inattendue, par exemple, quelqu'un √† l'autre bout du fil a envoy√©: "Tout - fermez la prise - allez d'ici, Vasya!"  Ensuite, cette phase fonctionnera, car l'√©v√©nement est inattendu.  Mais cela ne nous affecte pas particuli√®rement. <br><br><h3>  Traitement asynchrone incorrect des morceaux dans Node.js </h3><br>  Que se passera-t-il si nous mettons le m√™me mod√®le que nous avons pris dans les navigateurs avec setTimeout sur Node.js - c'est-√†-dire que nous divisons le tableau en morceaux, pour chaque morceau que nous faisons setTimeout - 0. <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> bigArray = [<span class="hljs-number"><span class="hljs-number">1.</span></span><span class="hljs-number"><span class="hljs-number">.1</span></span>_000_000] <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> chunks = getChunks(bigArray) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> parseData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">slice</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">// parse binary data for (chunk of chunks) { setTimeout(() =&gt; parseData(slice), 0) }</span></span></code> </pre><br>  Pensez-vous que cela pose des probl√®mes? <br><br>  J'ai d√©j√† un peu avanc√© lorsque j'ai dit que si vous ajoutez 10 000 d√©lais d'attente (ou 10 milliards!), Il y aura 10 000 temporisateurs dans la file d'attente, et il les obtiendra et les ex√©cutera - il n'y a aucune protection contre cela: obtenez - ex√©cutez, obtenez - √† accomplir et ainsi de suite √† l'infini. <br><br>  Seule la phase d'interrogation, si nous obtenons constamment un √©v√©nement d'E / S, tout le temps que quelqu'un √©crit quelque chose dans le socket afin que nous puissions m√™me ex√©cuter des temporisations et setImmediate, il a une protection limite et d√©pend du syst√®me.  Autrement dit, il diff√©rera sur diff√©rents syst√®mes d'exploitation. <br><br>  Malheureusement, d'autres phases, y compris les minuteries et setImmediate, <strong>ne disposent pas d'une telle protection.</strong>  Par cons√©quent, si vous faites comme dans l'exemple, tout g√®lera et n'atteindra pas la phase d'interrogation pendant tr√®s longtemps. <br><br>  Mais pensez-vous que quelque chose changera si nous rempla√ßons setTimeout (() =&gt; parseData (tranche), 0) par setImmediate (() =&gt; parseData (tranche))?  - Naturellement, non, il n'y a pas non plus de protection sur la phase de contr√¥le. <br><br>  Pour r√©soudre ce probl√®me, vous pouvez appeler un <strong>traitement r√©cursif</strong> . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> parseData = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">slice</span></span></span><span class="hljs-function">) =&gt;</span></span> <span class="hljs-comment"><span class="hljs-comment">// parse binary data const recursiveAsyncParseData = (i) =&gt; { parseData(getChunk(i)) setImmediate(() =&gt; recursiveAsyncParseData(i + 1)) } recursiveAsyncParseData(0)</span></span></code> </pre><br>  L'essentiel est que nous avons pris la fonction parseData et √©crit son appel r√©cursif, mais pas seulement nous-m√™mes, mais via setImmediate.  Lorsque vous appelez cela dans la phase setImmediate, il passe au tick suivant, et non au tick courant.  Par cons√©quent, cela lib√©rera la boucle d'√©v√©nement, cela ira plus loin dans un cercle.  Autrement dit, nous avons recursiveAsyncParseData, o√π nous passons un certain index, obtenons le morceau par cet index, l'analysons - puis mettons la file d'attente setImmediate avec l'index suivant.  Cela arrivera √† notre prochain tick et nous pouvons traiter r√©cursivement tout cela. <br><br>  Certes, le probl√®me est qu'il s'agit toujours d'une sorte de t√¢che li√©e au processeur.  Peut-√™tre qu'elle va encore peser et prendre du temps dans Event Loop.  Il est fort probable que vous souhaitiez que vos Node.js soient purement li√©s aux E / S. <br>  Par cons√©quent, il vaut mieux utiliser d'autres choses, par exemple, le <strong>processus fork / thread pool.</strong> <br><br>  Maintenant, nous savons √† propos de Node.js que: <br><br><ul><li>  tout est distribu√© par phases - eh bien, nous le savons clairement; <br></li><li>  il y a une protection contre une phase de scrutin trop longue, mais pas le reste; <br></li><li>  des mod√®les de traitement r√©cursifs peuvent √™tre appliqu√©s afin de ne pas bloquer la boucle d'√©v√©nement; </li><li>  Mais il est pr√©f√©rable d'utiliser le processus fork, le pool de threads, le processus enfant </li></ul><br>  Vous devez √©galement √™tre prudent avec le pool de threads, car Node.js d√©marre les choses l√†-haut, en particulier la r√©solution DNS, car pour Linux, pour une raison quelconque, la fonction de r√©solution DNS n'est pas asynchrone.  Par cons√©quent, il doit √™tre ex√©cut√© dans ThreadPool.  Sur Windows, heureusement, non.  Mais l√†, vous pouvez lire des fichiers de mani√®re asynchrone.  Sous Linux, malheureusement, c'est impossible. <br><br>  √Ä mon avis, la limite standard est de 4 processus dans ThreadPool.  Par cons√©quent, si vous faites activement quelque chose l√†-bas, il sera en concurrence avec tout le monde - avec fs et autres.  Vous pouvez envisager d'augmenter ThreadPool, mais aussi tr√®s soigneusement.  Alors lisez quelque chose sur ce sujet. <br><br><h2>  Microt√¢che: circulation pulmonaire </h2><br>  Nous avons des t√¢ches dans Node.js et des t√¢ches dans les navigateurs.  Vous avez peut-√™tre d√©j√† entendu parler de microt√¢che.  Voyons ce que c'est et comment ils fonctionnent, et commen√ßons par les navigateurs. <br><br><h3>  Microt√¢che dans les navigateurs <br></h3><br>  Pour comprendre le fonctionnement de la microt√¢che, nous nous tournons vers l'algorithme de boucle d'√©v√©nements selon la norme whatwg, c'est-√†-dire, allons √† la sp√©cification et voyons √† quoi tout cela ressemble. <br><br><img src="https://habrastorage.org/webt/cb/kj/76/cbkj76j9xqsivioo2demagbbfty.png"><br><br>  Traduisant en langage humain, cela ressemble √† ceci: <br><br><ul><li>  Prenez la t√¢che gratuite de notre ligne </li><li>  Nous le r√©alisons </li><li>  Nous effectuons un point de contr√¥le des microt√¢ches - OK, nous ne savons toujours pas ce que c'est, mais nous nous en souvenons. </li><li>  Nous mettons √† jour le rendu (si n√©cessaire) et revenons √† la case d√©part. </li></ul><br><img src="https://habrastorage.org/webt/1h/rs/ce/1hrsceluhstlxrdjjr7ig2wh9l0.png"><br><br>  Ils sont effectu√©s √† l'endroit indiqu√© sur le sch√©ma, et dans plusieurs autres endroits, dont nous allons bient√¥t conna√Ætre.  Autrement dit, la t√¢che est termin√©e, les microt√¢ches sont ex√©cut√©es. <br><br><h3>  Sources de microtucks </h3><br><ul><li>  <strong>Promesse.alors.</strong> </li></ul><br>  Important - pas Promise lui-m√™me, √† savoir Promise.then.  Le rappel qui a √©t√© plac√© alors est une microt√¢che.  Si vous avez appel√© 10 alors - vous avez 10 microcars, 10 000 alors - 10 000 microcars. <br><br><ul><li>  <strong>Observateur de mutations.</strong> <br></li><li>  <strong>Object.observe</strong> , qui est obsol√®te et dont personne n'a besoin. <br></li></ul><br>  Combien utilisent l'observateur de mutation? <br><br>  Je pense que peu utilisent l'observateur de mutation.  Tr√®s probablement, Promise.then est plus utilis√©, c'est pourquoi nous le consid√©rerons dans l'exemple. <br><br>  <strong>Caract√©ristiques du point de contr√¥le des microt√¢ches:</strong> <br><br><ul><li>  <strong>Nous faisons tout</strong> - cela signifie que nous r√©alisons tous les microt√¢ches que nous avons dans la file d'attente jusqu'√† la fin.  Nous ne l√¢chons rien - nous prenons et faisons tout ce qui est, ils devraient √™tre micro, non? </li><li>  Vous pouvez toujours g√©n√©rer de nouvelles microt√¢ches dans le processus, et elles seront ex√©cut√©es dans le m√™me point de contr√¥le de microt√¢ches. </li><li>  Ce qui est √©galement important - ils sont ex√©cut√©s non seulement apr√®s l'ex√©cution de la t√¢che, mais √©galement apr√®s avoir effac√© la pile. </li></ul><br>  Ceci est un point int√©ressant.  Il s'av√®re qu'il est possible de g√©n√©rer de nouveaux microt√¢ches et nous les remplirons tous tous.  √Ä quoi cela peut-il nous conduire? <br><br><img src="https://habrastorage.org/webt/yr/i_/i9/yri_i9mhp2jz-6nyyj7pvfwl6yg.png"><br>  Nous avons deux c≈ìurs.  J'ai anim√© le premier c≈ìur avec l'animation JS, et le second avec l'animation CSS.  Il existe une autre fonctionnalit√© int√©ressante appel√©e starveMicrotasks.  Nous appelons Promise.resolve, puis mettons la m√™me fonction dans then. <br>  Voyez dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pr√©sentation</a> ce qui se passe si vous appelez cette fonction. <br><br>  Oui, le c≈ìur de JS s'arr√™tera, car nous ajoutons une microt√¢che, puis nous y ajoutons une microt√¢che, puis nous y ajoutons une microt√¢che ... Et ainsi de suite sans fin. <br><br>  Autrement dit, l'appel r√©cursif de microtucks va tout bloquer.  Mais il semblerait que j'ai tout asynchrone!  Il faut le laisser partir, j'ai appel√© setTimeout l√†-bas.  Non!  Malheureusement, vous devez √™tre prudent avec la microt√¢che, donc si vous utilisez un appel r√©cursif d'une mani√®re ou d'une autre, soyez prudent - vous pouvez tout bloquer. <br><br>  De plus, comme nous nous en souvenons, la microt√¢che est ex√©cut√©e √† la fin du nettoyage de la pile.  Nous nous souvenons de ce qu'est une pile.  Il s'av√®re que d√®s que nous sommes sortis de notre code, le rappel setTimeout a √©t√© ex√©cut√© - c'est tout - les microt√¢ches sont all√©es l√†.  Cela peut entra√Æner des effets secondaires int√©ressants. <br><br>  Prenons <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">un exemple</a> . <br><br><img src="https://habrastorage.org/webt/kf/e-/tq/kfe-tqsysmprki74ayahty-n9ke.png"><br><br>  Il y a un bouton et un r√©cipient gris dans lequel il se trouve.  Nous souscrivons au clic du bouton et du conteneur. ,   , ,       . <br><br>     2 : <br><br><ol><li> Promise.resolve; </li><li> .then,    console.log('RO') </li></ol><br>       ¬´FUS¬ª,      ‚Äì ¬´DAH!¬ª (    ). <br><br>   ,      ?      ,    ,   ¬´FUS RO DAH!¬ª  Super!  ,   . <br><br><img src="https://habrastorage.org/webt/3g/b6/w3/3gb6w3gi4es-fzxcicyk2batfm8.png"><br><br>       ,            ,        .   ‚Äì  . , -   ? <br><br><img src="https://habrastorage.org/webt/uo/-t/dx/uo-tdxdjrfwgt0vvse4a6vuqips.png"><br><br>  !         . <br><br><img src="https://habrastorage.org/webt/yk/ob/w3/ykobw30-vcw5h6t6vvlitwk-y2a.png"><br><br>  ,   . <br><br> ,      ,     ,     .  ,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a> . <br><br><ul><li>         ‚Äî buttonHandleClick,    . </li><li>    Promise.resolve.     .   ,      console.log('RO')  .   . </li><li>      console.log('FUS'). </li><li>   buttonHandleClick       .        . </li><li>   ,      (divHandleClick)    ,  ¬´DAH!¬ª. </li><li> HandleClick . </li></ul><br>  ,     .         ?     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a> : <br><br><ul><li>  button.click().     . </li><li>   button HandleClick. </li><li>  Promise.resolve  then.      , Promise.resolve . </li><li>    console.log   ¬´FUS¬ª. </li><li>    buttonHandleClick    ,    . </li></ul><br>     (click)  ,       ,    .     divHandleClick , ,  console.log('DAH!') .        ,      . <br><br>   , ,    button.click   . <br>        .   , ,   .  ,    ,    . <br><br>    :     ()       (  ).   - ,      ,   stopPropagation.  ,     ,  ,  ,   -   ,  . <br><br>  ,  -   ( junior-)     ‚Äî      ¬´¬ª,    promise,  ,    then  ,  -  .    ,  <strong>    ,    </strong> :   ,    ,  .   .        ,   -       . <br><br>    (  4)    ,        .     ,   ,  ,   ,      -   .           . <br><br> <strong>     , :</strong> <br><br><ul><li>      Event Loop.  C'est d√©sagr√©able. </li><li>         ,   . </li></ul><br>           ,    .  ‚Äî   ,     ,  . <br><br><h2>   Node.js <br></h2><br>   Node.js  Promise.then  process.nextTick.      ,    ‚Äî    .   ,   , ,   , . <br><br><h3> process.nextTick <br></h3><br> ,     process.nextTick,   setImmediate?      Node.js  ? <br><br>    .     createServer,   EventEmitter,    ,     listen (  ),      . <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> createServer = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> evEmitter = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EventEmitter() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-attr"><span class="hljs-attr">listen</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">port</span></span></span><span class="hljs-function"> =&gt;</span></span> { evEmitter.emit(<span class="hljs-string"><span class="hljs-string">'listening'</span></span>, port) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> evEmitter } } } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> server = createServer().listen(<span class="hljs-number"><span class="hljs-number">8080</span></span>) server.on(<span class="hljs-string"><span class="hljs-string">'listening'</span></span>, () =&gt; <span class="hljs-built_in"><span class="hljs-built_in">console</span></span>.log(<span class="hljs-string"><span class="hljs-string">'listening'</span></span>))</code> </pre><br>    ,  ,   8080,    listening   console.log  - . <br><br>  ,       ,      - . <br><br>    createServer,    .       listen,      ,        .        . <br><br>  ,    ,    .  Que peut-on faire?   process.nextTick:  evEmitter.emit('listening', port)  process.nextTick(() =&gt; evEmitter.emit('listening', port)). <br><br>   ,  <strong>process.nextTick     ,    </strong> .    EventEmitter,     . ,   ,      API,       .    process.nextTick,   emit    ,  userland  .      createServer,  ,  listen,    listening.     ‚Äî    process.nextTick ‚Äî !  ,     ,  . <br><br>     process.nextTick  .     ,         . <br><br>   ,  process.nextTick    ,  Promise.then  .     process.nextTick ,     ‚Äî    ,   Event Loop,  Node.js. , ,   . <br><br> <strong> process.nextTick    </strong> ,   ghbvtybnm  setImmediate   ,        C++  ..  process.nextTick       . <br><br><h2> Async/await </h2><br>      API ‚Äî async/await, - .    .    , async/await   Promise,     Event Loop      .     ,          . <br><br><h2>  Liens utiles </h2><br><ul><li>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  </a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> . <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Philip Roberts. What the heck is the event loop anyway?</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Bert Belder. Everything you need to know about Node.js event loop.</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Jake Archibald. In the Loop</a> . <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">The Node.js Event Loop, Timers, and process.nextTick()</a> <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">WHATWG Specification event loop processing model</a> <br></li></ul><br> <strong>,     !</strong> <br><br><blockquote>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Frontend Conf</a>     ‚Äî 4  5   ,  .    ,        : <br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Grid Layout    </a> /   ( .) <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Building decentralised apps with JS</a> /   (ING) <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> /   () <br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">StoreWars (ngxs, redux, vuex)</a> /  ,   (Cinimex) <br></li></ul><br>  Venez, ce sera int√©ressant! <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr417461/">https://habr.com/ru/post/fr417461/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr417449/index.html">Jurassic World: pouvons-nous vraiment ressusciter des dinosaures?</a></li>
<li><a href="../fr417451/index.html">Cinq erreurs courantes pour les d√©butants</a></li>
<li><a href="../fr417453/index.html">Organisation de stages pour √©tudiants: r√¢teau et astuces</a></li>
<li><a href="../fr417457/index.html">Frontend Conf Moscow - c√¥t√© client entrant et sortant</a></li>
<li><a href="../fr417459/index.html">Connaissez votre JIT: plus pr√®s de la voiture</a></li>
<li><a href="../fr417463/index.html">Une rencontre inattendue. Chapitre 17</a></li>
<li><a href="../fr417465/index.html">Un aper√ßu des m√©thodes de liaison de texte</a></li>
<li><a href="../fr417469/index.html">Cinq raisons √©go√Østes de travailler de mani√®re reproductible</a></li>
<li><a href="../fr417471/index.html">Simple Solder MK936 SMD. Station de soudage DIY pour composants CMS</a></li>
<li><a href="../fr417473/index.html">Stockage s√©curis√© avec DRBD9 et Proxmox (Partie 1: NFS)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>