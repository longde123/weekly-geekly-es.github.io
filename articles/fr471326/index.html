<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙅🏽 😚 🛌🏻 The Tale of the Dangerous std :: enable_shared_from_this, ou l'anti-modèle Zombie ☘️ ⏫ 🖐🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'article décrit le dangereux motif "Zombies", qui se produit naturellement dans certaines situations lors de l'utilisation de std :: enable_shared_fr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>The Tale of the Dangerous std :: enable_shared_from_this, ou l'anti-modèle Zombie</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471326/">  L'article décrit le dangereux motif "Zombies", qui se produit naturellement dans certaines situations lors de l'utilisation de std :: enable_shared_from_this.  Le matériau est quelque part à la jonction de la technologie et de l'architecture C ++ modernes. <br><a name="habracut"></a><br><h3>  Présentation </h3><br>  C ++ 11 a fourni au développeur de merveilleux outils pour travailler avec la mémoire - des pointeurs intelligents std :: unique_ptr et un tas de std :: shared_ptr + std :: faiblesse_ptr.  L'utilisation de pointeurs intelligents pour plus de commodité et de sécurité l'emporte de loin sur l'utilisation de pointeurs bruts.  Les pointeurs intelligents sont largement utilisés dans la pratique, comme  permettre au développeur de se concentrer sur des problèmes de niveau supérieur au suivi de l'exactitude de la création / suppression d'entités créées dynamiquement. <br>  Le modèle de classe std :: enable_shared_from_this fait également partie du standard, et cela semble plutôt étrange lorsque vous le rencontrez pour la première fois. <br>  L'article expliquera comment vous pouvez vous retrouver avec son utilisation. <br><br><h2>  Programme éducatif </h2><br><div class="spoiler">  <b class="spoiler_title">RAII et pointeurs intelligents</b> <div class="spoiler_text"> Le but direct des pointeurs intelligents est de prendre soin d'un <b>morceau de RAM</b> alloué sur le tas.  Les pointeurs intelligents implémentent l'idiome RAII (l'acquisition de ressources est l'initialisation) et peuvent facilement être adaptés pour prendre en charge d'autres types de ressources qui nécessitent une initialisation et une désinitialisation non triviale, telles que: <br>  - fichiers; <br>  - dossiers temporaires sur le disque; <br>  - connexions réseau (http, websockets); <br>  - fils d'exécution (fils); <br>  - mutex; <br>  - autre (ce qui suffit pour la fantaisie). <br>  Pour une telle généralisation, il suffit d'écrire une classe (en fait, parfois vous ne pouvez même pas écrire une classe, mais utilisez simplement deleter - mais aujourd'hui, le conte n'est pas à ce sujet), implémentant: <br>  - initialisation dans le constructeur ou dans une méthode distincte; <br>  - désinitialisation dans le destructeur, <br>  puis «envelopper» dans le pointeur intelligent approprié, selon le modèle de propriété requis - joint (std :: shared_ptr) ou sole (std :: unique_ptr).  Il en résulte un «RAII à deux couches»: un pointeur intelligent vous permet de transférer / partager la propriété de la ressource, et la classe d'utilisateurs initialise / désinitialise une ressource non standard. <br>  std :: shared_ptr utilise un mécanisme de comptage de liens.  La norme définit le compteur de liens forts (compte le nombre de copies existantes de std :: shared_ptr) et le compteur de liens faibles (compte le nombre de copies existantes de std :: faiblesse_ptr créées pour cette instance de std :: shared_ptr).  La présence d'au moins un lien fort garantit que la destruction n'a pas encore été effectuée.  Cette propriété std :: shared_ptr est largement utilisée pour garantir la validité d'un objet jusqu'à ce que son utilisation soit terminée dans toutes les parties du programme.  La présence d'un maillon faible n'empêche pas la destruction de l'objet et ne permet d'obtenir un maillon fort que jusqu'à sa destruction. <br>  RAII garantit que la libération d'une ressource est beaucoup plus fiable qu'un appel explicite à supprimer / supprimer [] / libre / fermer / réinitialiser / déverrouiller, car: <br>  - vous pouvez simplement oublier l'appel explicite; <br>  - un appel explicite peut être effectué par erreur plusieurs fois; <br>  - un défi explicite est difficile lors de la mise en œuvre de la propriété partagée d'une ressource; <br>  - le mécanisme de promotion de pile en c ++ garantit l'appel de destructeurs pour tous les objets qui sortent du domaine en cas d'exception. <br>  La garantie de désinitialisation dans l'idiome est si importante qu'elle mérite une bonne place au nom de l'idiome avec l'initialisation. <br>  Les pointeurs intelligents présentent également des inconvénients: <br>  - la présence de surcharge en termes de performances et de mémoire (pour la plupart des applications ce n'est pas significatif); <br>  - la possibilité de liens cycliques bloquant la libération de la ressource et entraînant sa fuite. <br>  Chaque développeur a sûrement lu plus d'une fois des liens circulaires et vu des exemples synthétiques de code problématique. <br>  Le danger peut sembler insignifiant pour les raisons suivantes: <br>  - si la mémoire fuit fréquemment et beaucoup - cela est notable dans sa consommation, et si rarement et peu - alors le problème a peu de chances de se manifester au niveau de l'utilisateur final; <br>  - utilise l'analyse de code dynamique pour les fuites (Valgrind, Clang LeakSanitizer, etc.); <br>  - "Je n’écris pas comme ça"; <br>  - «mon architecture est correcte»; <br>  "Notre code est en cours de révision." <br></div></div><br><div class="spoiler">  <b class="spoiler_title">std :: enable_shared_from_this</b> <div class="spoiler_text">  En C ++ 11, la classe d'assistance std :: enable_shared_from_this est introduite.  Pour un développeur qui construit avec succès du code sans std :: enable_shared_from_this, les utilisations potentielles de cette classe peuvent ne pas être évidentes. <br>  Que fait std :: enable_shared_from_this? <br>  Il permet aux fonctions membres de la classe qui est instanciée dans std :: shared_ptr de recevoir des copies supplémentaires fortes (shared_from_this ()) ou faibles (faibles_from_this (), à partir de C ++ 17) du std :: shared_ptr dans lequel il a été créé .  Vous ne pouvez pas appeler shared_from_this () et faible_from_this () à partir du constructeur et du destructeur. <br><br>  <b>Pourquoi si dur?</b>  <b>Vous pouvez simplement construire std :: shared_ptr &lt;T&gt; (this)</b> <br>  Non, tu ne peux pas.  Tous les std :: shared_ptrs qui se soucient de la même instance de la classe doivent utiliser une unité de comptage de liens.  Il n'y a aucun moyen de se passer de magie spéciale. <br><br>  Une condition préalable à l'utilisation de std :: enable_shared_from_this est de créer initialement un objet de classe dans std :: shared_ptr.  Créer sur la pile, allouer dynamiquement sur le tas, créer sur std :: unique_ptr - tout cela ne convient pas.  Seulement strictement dans std :: shared_ptr. <br><br>  <b>Est-il possible de limiter l'utilisateur dans la manière de créer des instances de la classe?</b> <br>  Oui tu peux.  Pour ce faire, il suffit: <br>  - fournir une méthode statique pour créer des instances initialement placées dans std :: shared_ptr; <br>  - mettre le constructeur en privé ou protégé; <br>  - interdire la sémantique de copie et de déplacement. <br>  La classe est entrée dans la cage, l'a verrouillée et a avalé la clé - désormais toutes ses instances ne vivront que dans std :: shared_ptr, et il n'y a aucun moyen légal de les faire sortir de là. <br>  Une telle restriction ne peut pas être qualifiée de bonne solution architecturale, mais cette méthode est entièrement conforme à la norme. <br>  De plus, vous pouvez utiliser l'idiome PIMPL: le seul utilisateur de la classe capricieuse - la façade - créera l'implémentation strictement dans std :: shared_ptr, et la façade elle-même sera déjà privée de restrictions de ce type. <br><br>  std :: enable_shared_from_this a des nuances importantes dans l'héritage, mais les discuter dépasse le cadre de cet article. <br></div></div><br><h2>  Aller droit au but </h2><br>  Tous les exemples de code fournis dans l'article sont publiés sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github</a> . <br>  Le code montre de mauvaises techniques déguisées en utilisation sûre habituelle du C ++ moderne <br><br><h3>  Simplecyclic </h3><br>  Il semble que rien ne présage de problèmes.  Une déclaration de classe semble simple et directe.  À l'exception d'un «petit» détail - pour une raison quelconque, l'héritage de std :: enable_shared_from_this est appliqué. <br><br><div class="spoiler">  <b class="spoiler_title">SimpleCyclic.h</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;functional&gt; namespace SimpleCyclic { class Cyclic final : public std::enable_shared_from_this&lt;Cyclic&gt; { public: static std::shared_ptr&lt;Cyclic&gt; create(); Cyclic(const Cyclic&amp;) = delete; Cyclic(Cyclic&amp;&amp;) = delete; Cyclic&amp; operator=(const Cyclic&amp;) = delete; Cyclic&amp; operator=(Cyclic&amp;&amp;) = delete; ~Cyclic(); void doSomething(); private: Cyclic(); std::function&lt;void(void)&gt; _fn; }; } // namespace SimpleCyclic</span></span></span></span></code> </pre> <br></div></div><br>  Et en cours d'exécution: <br><br><div class="spoiler">  <b class="spoiler_title">SimpleCyclic.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include "SimpleCyclic.h" namespace SimpleCyclic { Cyclic::Cyclic() = default; Cyclic::~Cyclic() { std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } std::shared_ptr&lt;Cyclic&gt; Cyclic::create() { return std::shared_ptr&lt;Cyclic&gt;(new Cyclic); } void Cyclic::doSomething() { _fn = [shis = shared_from_this()](){}; std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } } // namespace SimpleCyclic</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SimpleCyclic/SimpleCyclic.h"</span></span></span><span class="hljs-meta"> int main() { auto simpleCyclic = SimpleCyclic::Cyclic::create(); simpleCyclic-&gt;doSomething(); return 0; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sortie console</b> <div class="spoiler_text"><blockquote>  N12SimpleCyclic6CyclicE :: doSomething <br></blockquote><br></div></div><br>  Dans le corps de la fonction doSomething (), l'instance de classe <b>elle-même</b> créera une copie forte supplémentaire du std :: shared_ptr dans lequel elle a été placée.  Ensuite, à l'aide d'une capture généralisée, cette copie est placée dans une fonction lambda affectée au champ de données de classe sous le couvert d'une fonction std :: inoffensive.  Un appel à doSomething () entraîne une référence circulaire et l'instance de classe ne sera plus détruite même après la destruction de tous les liens forts externes. <br>  Il y a une fuite de mémoire.  Le destructeur cyclique SimpleCyclic :: Cyclic :: ~ n'est pas appelé. <br><br>  <b>L'instance de classe se «conserve».</b> <b><br></b>  <b>Le code s'est coincé dans un nœud.</b> <br><br><img src="https://habrastorage.org/webt/xp/jj/_a/xpjj_atj4bf0av8kar46ebxqqew.jpeg"><br>  (image prise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d'ici</a> ) <br><br>  <b>Et quoi, c'est l'anti-modèle "Zombie"?</b> <br>  Non, c'est juste une séance d'entraînement.  Le plus intéressant reste à venir. <br><br>  <b>Pourquoi le développeur a-t-il écrit cela?</b> <br>  Exemple synthétique.  Je n'ai connaissance d'aucune situation dans laquelle un tel code serait harmonieusement obtenu. <br><br>  <b>Alors, l'analyse de code dynamique est-elle restée silencieuse?</b> <br>  Non, Valgrind a honnêtement signalé une fuite de mémoire: <br><br><div class="spoiler">  <b class="spoiler_title">Post Valgrind</b> <div class="spoiler_text"><blockquote>  96 (64 directs, 32 indirects) octets en 1 bloc sont <b>définitivement perdus</b> dans le record de perte 29 de 46 <br>  dans SimpleCyclic :: Cyclic :: create () dans /Users/User/Projects/Zomby_antipattern_concept/SimpleCyclic/SimpleCyclic.cpp:15 <br>  1: malloc dans /usr/local/Cellar/valgrind/HEAD-60ab74a/lib/valgrind/vgpreload_memcheck-amd64-darwin.so <br>  2: nouvel opérateur (long non signé) dans /usr/lib/libc++abi.dylib <br>  3: SimpleCyclic :: Cyclic :: create () dans /Users/User/Projects/Zomby_antipattern_concept/SimpleCyclic/SimpleCyclic.cpp:15 <br>  4: principal dans /Users/User/Projects/Zomby_antipattern_concept/SimpleCyclic/main.cpphaps <br></blockquote><br></div></div><br><h3>  Pimplcyclic </h3><br>  Dans ce cas, le fichier d'en-tête semble complètement correct et concis.  Il a déclaré une façade qui stocke une certaine implémentation dans std :: shared_ptr.  L'héritage - y compris de std :: enable_shared_from_this - est manquant, contrairement à l'exemple précédent. <br><br><div class="spoiler">  <b class="spoiler_title">Pimplcyclic.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; namespace PimplCyclic { class Cyclic { public: Cyclic(); ~Cyclic(); private: class Impl; std::shared_ptr&lt;Impl&gt; _impl; }; } // namespace PimplCyclic</span></span></span></span></code> </pre><br></div></div><br>  Et en cours d'exécution: <br><br><div class="spoiler">  <b class="spoiler_title">Pimplcyclic.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;functional&gt; #include "PimplCyclic.h" namespace PimplCyclic { class Cyclic::Impl : public std::enable_shared_from_this&lt;Cyclic::Impl&gt; { public: ~Impl() { std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } void doSomething() { _fn = [shis = shared_from_this()](){}; std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } private: std::function&lt;void(void)&gt; _fn; }; Cyclic::Cyclic() : _impl(std::make_shared&lt;Impl&gt;()) { if (_impl) { _impl-&gt;doSomething(); } } Cyclic::~Cyclic() { std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } } // namespace PimplCyclic</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"PimplCyclic/PimplCyclic.h"</span></span></span><span class="hljs-meta"> int main() { auto pimplCyclic = PimplCyclic::Cyclic(); return 0; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sortie console</b> <div class="spoiler_text"><blockquote>  N11PimplCyclic6Cyclic4ImplE :: doSomething <br>  N11PimplCyclic6CyclicE :: ~ Cyclique <br></blockquote><br></div></div><br>  L'appel à Impl :: doSomething () crée une référence circulaire dans une instance de la classe Impl.  La façade est détruite correctement, mais la mise en œuvre fuit.  Le destructeur PimplCyclic :: Cyclic :: Impl :: ~ Impl n'est pas appelé. <br>  L'exemple est à nouveau synthétique, mais cette fois plus dangereux - tout le mauvais matériel se trouve dans la mise en œuvre et n'apparaît pas dans l'annonce. <br>  De plus, pour créer un lien circulaire, le code utilisateur ne nécessitait aucune action autre que la construction. <br>  L'analyse dynamique face à Valgrind, et cette fois a révélé une fuite: <br><br><div class="spoiler">  <b class="spoiler_title">Post Valgrind</b> <div class="spoiler_text"><blockquote>  96 octets en 1 blocs sont <b>définitivement perdus</b> dans le record de perte 29 de 46 <br>  dans PimplCyclic :: Cyclic :: Cyclic () dans /Users/User/Projects/Zomby_antipattern_concept/PimplCyclic/PimplCyclic.cpp:28 <br>  1: malloc dans /usr/local/Cellar/valgrind/HEAD-60ab74a/lib/valgrind/vgpreload_memcheck-amd64-darwin.so <br>  2: nouvel opérateur (long non signé) dans /usr/lib/libc++abi.dylib <br>  3: std :: __ 1 :: __ libcpp_allocate (unsigned long, unsigned long) dans /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/new:252 <br>  4: std :: __ 1 :: allocator &lt;std :: __ 1 :: __ shared_ptr_emplace &lt;PimplCyclic :: Cyclic :: Impl, std :: __ 1 :: allocator &lt;PimplCyclic :: Cyclic :: Impl &gt;&gt;&gt; allocate (unsigned long , void const *) dans /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory:1813 <br>  5: std :: __ 1 :: shared_ptr &lt;PimplCyclic :: Cyclic :: Impl&gt; std :: __ 1 :: shared_ptr &lt;PimplCyclic :: Cyclic :: Impl&gt; :: make_shared &lt;&gt; () dans /Applications/Xcode.app/Contents /Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory:4326 <br>  6: _ZNSt3__1L11make_sharedIN11PimplCyclic6Cyclic4ImplEJEEENS_9enable_ifIXntsr8is_arrayIT_EE5valueENS_10shared_ptrIS5_EEE4typeEDpOT0_ dans /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory:4706 <br>  7: PimplCyclic :: Cyclic :: Cyclic () dans /Users/User/Projects/Zomby_antipattern_concept/PimplCyclic/PimplCyclic.cpp:28 <br>  8: PimplCyclic :: Cyclic :: Cyclic () dans /Users/User/Projects/Zomby_antipattern_concept/PimplCyclic/PimplCyclic.cpp:29 <br>  9: principal dans /Users/User/Projects/Zomby_antipattern_concept/PimplCyclic/main.cpphaps <br></blockquote><br></div></div><br>  <b>C'est un peu suspect de voir Pimpl, dans lequel l'implémentation est stockée dans std :: shared_ptr.</b> <br>  Le classique Pimpl basé sur un pointeur brut est trop archaïque, et std :: unique_ptr a pour effet secondaire de répandre l'interdiction de copie sémantique sur la façade.  Une telle façade mettra en œuvre l'idiome de la propriété exclusive, qui peut ne pas correspondre à l'idée architecturale.  De l'utilisation de std :: shared_ptr pour stocker l'implémentation, nous concluons que la classe est conçue pour fournir une propriété partagée. <br><br>  <b>En quoi cela diffère-t-il de la fuite classique - allouer de la mémoire en appelant explicitement new sans suppression ultérieure?</b>  <b>De la même manière, tout serait beau dans l'interface et dans l'implémentation - un bug.</b> <br>  Nous discutons <b>des</b> moyens <b>modernes</b> de vous tirer une balle dans le pied. <br><br><h2>  Antipattern "Zombies" </h2><br>  Ainsi, d'après le matériel ci-dessus, il est clair: <br>  - les pointeurs intelligents peuvent être liés aux nœuds; <br>  - l'utilisation de std :: enable_shared_from_this peut y contribuer, car  permet à une instance d'une classe de se lier à un nœud sans presque aucune aide extérieure. <br><br>  <b>Et maintenant - attention - la question clé de l'article: le type de ressource enveloppé dans un pointeur intelligent est-il important?</b>  <b>Existe-t-il une différence entre un traitement de fichier RAII et une connexion HTTPS asynchrone?</b> <br><br><h3>  Simplezomby </h3><br>  Le code commun à tous les exemples ultérieurs de zombies a été déplacé vers la bibliothèque commune. <br><br>  Interface zombie abstraite avec le modeste nom Manager: <br><br><div class="spoiler">  <b class="spoiler_title">Commun / Manager.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; namespace Common { class Listener; class Manager { public: Manager() = default; Manager(const Manager&amp;) = delete; Manager(Manager&amp;&amp;) = delete; Manager&amp; operator=(const Manager&amp;) = delete; Manager&amp; operator=(Manager&amp;&amp;) = delete; virtual ~Manager() = default; virtual void runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) = 0; }; } // namespace Common</span></span></span></span></code> </pre><br></div></div><br>  Interface abstraite de l'auditeur, prête à accepter du texte thread-safe: <br><br><div class="spoiler">  <b class="spoiler_title">Common / Listener.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;memory&gt; namespace Common { class Listener { public: virtual ~Listener() = default; using Data = std::string; // thread-safe virtual void processData(const std::shared_ptr&lt;const Data&gt; data) = 0; }; } // namespace Common</span></span></span></span></code> </pre><br></div></div><br>  Écouteur qui affiche du texte sur la console.  Implémente le concept SingletonShared de mon article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Technique pour éviter les comportements indéfinis lors de l'appel d'un singleton</a> : <br><br><div class="spoiler">  <b class="spoiler_title">Common / Impl / WriteToConsoleListener.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;mutex&gt; #include "Common/Listener.h" namespace Common { class WriteToConsoleListener final : public Listener { public: WriteToConsoleListener(const WriteToConsoleListener&amp;) = delete; WriteToConsoleListener(WriteToConsoleListener&amp;&amp;) = delete; WriteToConsoleListener&amp; operator=(const WriteToConsoleListener&amp;) = delete; WriteToConsoleListener&amp; operator=(WriteToConsoleListener&amp;&amp;) = delete; ~WriteToConsoleListener() override; static std::shared_ptr&lt;WriteToConsoleListener&gt; instance(); // blocking void processData(const std::shared_ptr&lt;const Data&gt; data) override; private: WriteToConsoleListener(); std::mutex _mutex; }; } // namespace Common</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Common / Impl / WriteToConsoleListener.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include "WriteToConsoleListener.h" namespace Common { WriteToConsoleListener::WriteToConsoleListener() = default; WriteToConsoleListener::~WriteToConsoleListener() { auto lock = std::lock_guard(_mutex); std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } std::shared_ptr&lt;WriteToConsoleListener&gt; WriteToConsoleListener::instance() { static auto inst = std::shared_ptr&lt;WriteToConsoleListener&gt;(new WriteToConsoleListener); return inst; } void WriteToConsoleListener::processData(const std::shared_ptr&lt;const Data&gt; data) { if (data) { auto lock = std::lock_guard(_mutex); std::cout &lt;&lt; *data &lt;&lt; std::flush; } } } // namespace Common</span></span></span></span></code> </pre><br></div></div><br>  Et enfin, le premier zombie, le plus simple et le plus ingénu. <br><br><div class="spoiler">  <b class="spoiler_title">SimpleZomby.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;atomic&gt; #include &lt;thread&gt; #include "Common/Manager.h" namespace Common { class Listener; } // namespace Common namespace SimpleZomby { class Zomby final : public Common::Manager, public std::enable_shared_from_this&lt;Zomby&gt; { public: static std::shared_ptr&lt;Zomby&gt; create(); ~Zomby() override; void runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) override; private: Zomby(); using Semaphore = std::atomic&lt;bool&gt;; std::shared_ptr&lt;Common::Listener&gt; _listener; Semaphore _semaphore = false; std::thread _thread; }; } // namespace SimpleZomby</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">SimpleZomby.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sstream&gt; #include "SimpleZomby.h" #include "Common/Listener.h" namespace SimpleZomby { std::shared_ptr&lt;Zomby&gt; Zomby::create() { return std::shared_ptr&lt;Zomby&gt;(new Zomby()); } Zomby::Zomby() = default; Zomby::~Zomby() { _semaphore = false; if (_thread.joinable()) { _thread.detach(); } if (_listener) { std::ostringstream buf; buf &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; _listener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } void Zomby::runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) { if (_semaphore) { throw std::runtime_error("SimpleZomby::Zomby::runOnce() called twice"); } _listener = listener; _semaphore = true; _thread = std::thread([shis = shared_from_this()](){ while (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;_listener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;("SimpleZomby is alive!\n")); std::this_thread::sleep_for(std::chrono::seconds(1)); } }); } } // namespace SimpleZomby</span></span></span></span></code> </pre><br></div></div><br>  Un zombie exécute une fonction lambda dans un thread séparé, envoyant périodiquement une chaîne à l'auditeur.  Les fonctions lambda pour le travail ont besoin d'un sémaphore et d'un écouteur, qui sont des champs de la classe zombie.  La fonction lambda ne les capture pas en tant que champs séparés, mais utilise l'objet comme agrégateur.  La destruction d'une instance de la classe zombie avant la fin de la fonction lambda entraînera un comportement indéfini.  Pour éviter cela, la fonction lambda capture une copie forte de shared_from_this (). <br>  Dans le destructeur de zombies, le sémaphore est défini sur false, après quoi detach () est appelé pour le flux.  La définition du sémaphore indique au thread de s'arrêter. <br><br>  <b>Dans le destructeur, il fallait appeler non pas detach (), mais join ()!</b> <br>  ... et obtenez un destructeur qui bloque l'exécution pour une durée indéterminée, ce qui peut être inacceptable. <br><br>  <b>C'est donc une violation de RAII!</b>  <b>RAII ne devait quitter le destructeur qu'après avoir libéré la ressource!</b> <br>  Si strictement - alors oui, le destructeur de zombies ne libère pas la ressource, mais <b>garantit</b> seulement <b>que la libération sera effectuée</b> .  Parfois produit - peut-être bientôt, ou peut-être pas vraiment.  Et il est même possible que main termine le travail plus tôt - le thread sera alors effacé de force par le système d'exploitation.  Mais en fait, la ligne entre le «bon» et le «mauvais» RAII peut être très mince: par exemple, le «bon» RAII, qui appelle std :: filesystem :: remove () dans un destructeur pour un fichier temporaire, pourrait bien lui rendre le contrôle. le moment où la commande d'écriture sera toujours dans l'un des caches volatils et ne sera pas honnêtement écrite sur la plaque magnétique du disque dur. <br><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;chrono&gt; #include &lt;thread&gt; #include &lt;sstream&gt; #include "Common/Impl/WriteToConsoleListener.h" #include "SimpleZomby/SimpleZomby.h" int main() { auto writeToConsoleListener = Common::WriteToConsoleListener::instance(); { auto simpleZomby = SimpleZomby::Zomby::create(); simpleZomby-&gt;runOnce(writeToConsoleListener); std::this_thread::sleep_for(std::chrono::milliseconds(4500)); } // Zomby should be killed here { std::ostringstream buf; buf &lt;&lt; "============================================================\n" &lt;&lt; "| Zomby was killed |\n" &lt;&lt; "============================================================\n"; if (writeToConsoleListener) { writeToConsoleListener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } std::this_thread::sleep_for(std::chrono::milliseconds(5000)); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sortie console</b> <div class="spoiler_text"><blockquote>  SimpleZomby est vivant! <br>  SimpleZomby est vivant! <br>  SimpleZomby est vivant! <br>  SimpleZomby est vivant! <br>  SimpleZomby est vivant! <br>  =================================================== =========== <br>  |  Zomby a été tué | <br>  ==================================================== =========== <br>  SimpleZomby est vivant! <br>  SimpleZomby est vivant! <br>  SimpleZomby est vivant! <br>  SimpleZomby est vivant! <br>  SimpleZomby est vivant! <br></blockquote><br></div></div><br>  Ce qui peut être vu à la sortie du programme: <br>  - le zombie a continué à fonctionner même après avoir quitté le champ de visibilité; <br>  - aucun destructeur n'a été appelé pour les zombies ou WriteToConsoleListener. <br>  Une fuite de mémoire s'est produite. <br>  Il y a eu une fuite de ressources.  Et la ressource dans ce cas est le fil d'exécution. <br>  Le code qui devait s'arrêter a continué de fonctionner dans un thread séparé. <br>  Une fuite WriteToConsoleListener aurait pu être évitée en utilisant la technique SingletonWeak de mon article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Éviter le comportement indéterminé lors de l'appel d'un Singleton</a> , mais je ne l'ai pas fait intentionnellement. <br><br><img src="https://habrastorage.org/webt/mg/qu/e3/mgque3fstboi4ot2hvdwniafixe.jpeg"><br>  (image prise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d'ici</a> ) <br><br>  <b>Pourquoi des zombies?</b> <br>  Parce qu'il a été tué et qu'il est toujours en vie. <br><br>  <b>En quoi est-ce différent des références circulaires des exemples précédents?</b> <br>  Le fait qu'une ressource perdue n'est pas seulement un morceau de mémoire, mais quelque chose qui exécute indépendamment du code indépendamment du thread qui l'a lancée. <br><br>  <b>Est-il possible de détruire les "Zombies"?</b> <br>  Après avoir quitté la portée (c'est-à-dire après avoir détruit toutes les références externes fortes et faibles aux zombies) - c'est impossible.  Un zombie sera détruit quand il décidera de se détruire (oui, c'est quelque chose avec un comportement actif), peut-être jamais, c'est-à-dire  survivra jusqu'à ce que le système d'exploitation se nettoie à la fin de l'application.  Bien sûr, le code utilisateur peut avoir un certain effet sur la condition de sortie du code zombie, mais cet effet sera indirect et dépend de l'implémentation. <br><br>  <b>Et avant de quitter le champ d'application?</b> <br>  Vous pouvez explicitement appeler le destructeur de zombies, mais il est peu probable que vous évitiez un comportement indéfini en raison de la destruction répétée de l'objet par le destructeur de pointeur intelligent également - il s'agit d'un combat contre RAII.  Ou vous pouvez ajouter la fonction de désinitialisation explicite - et c'est un rejet de RAII. <br><br>  <b>En quoi est-ce différent du démarrage d'un thread suivi de detach ()?</b> <br>  Dans le cas des zombies, contrairement à un simple appel à detach (), il y a une idée d'arrêter le flux.  Seulement ça ne marche pas.  Avoir la bonne idée permet de masquer le problème. <br><br>  <b>L'exemple est-il toujours synthétique?</b> <br>  En partie.  Dans cet exemple simple, il n'y avait pas suffisamment de raisons d'utiliser shared_from_this () - par exemple, vous pourriez obtenir en capturant faibles_from_this () ou en capturant tous les champs obligatoires de la classe.  Mais avec la complexité de la tâche, l'équilibre peut basculer sur le côté <br>  shared_from_this (). <br><br>  <b>Valgrind, Valgrind!</b>  <b>Nous avons une ligne de défense supplémentaire contre les zombies!</b> <br>  Hélas et ah - mais Valgrind n'a pas révélé de fuite de mémoire.  Pourquoi - je ne sais pas.  Dans les diagnostics, il n'y a que des entrées <b>«éventuellement perdues»</b> qui indiquent les fonctions du système - à peu près la même et à peu près la même quantité que lors de l'élaboration d'une alimentation principale vide.  Il n'y a aucune référence de code utilisateur.  D'autres outils d'analyse dynamique pourraient faire mieux, mais si vous comptez toujours sur eux, lisez la suite. <br><br><h3>  Steppingzomby </h3><br>  Le code de cet exemple passe par les étapes resolDnsName ---&gt; connectTcp ---&gt; EstablSsl ---&gt; sendHttpRequest ---&gt; readHttpRhness, simulant le fonctionnement de la connexion HTTPS cliente en exécution asynchrone.  Chaque étape prend environ une seconde. <br><br><div class="spoiler">  <b class="spoiler_title">Steppingzomby.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;atomic&gt; #include &lt;thread&gt; #include "Common/Manager.h" namespace Common { class Listener; } // namespace Common namespace SteppingZomby { class Zomby final : public Common::Manager, public std::enable_shared_from_this&lt;Zomby&gt; { public: static std::shared_ptr&lt;Zomby&gt; create(); ~Zomby() override; void runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) override; private: Zomby(); using Semaphore = std::atomic&lt;bool&gt;; std::shared_ptr&lt;Common::Listener&gt; _listener; Semaphore _semaphore = false; std::thread _thread; void resolveDnsName(); void connectTcp(); void establishSsl(); void sendHttpRequest(); void readHttpReply(); }; } // namespace SteppingZomby</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Steppingzomby.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sstream&gt; #include &lt;string&gt; #include "SteppingZomby.h" #include "Common/Listener.h" namespace { void doSomething(Common::Listener&amp; listener, std::string&amp;&amp; callingFunctionName) { listener.processData(std::make_shared&lt;Common::Listener::Data&gt;(callingFunctionName + " started\n")); std::this_thread::sleep_for(std::chrono::milliseconds(1000)); listener.processData(std::make_shared&lt;Common::Listener::Data&gt;(callingFunctionName + " finished\n")); } } // namespace namespace SteppingZomby { Zomby::Zomby() = default; std::shared_ptr&lt;Zomby&gt; Zomby::create() { return std::shared_ptr&lt;Zomby&gt;(new Zomby()); } Zomby::~Zomby() { _semaphore = false; if (_thread.joinable()) { _thread.detach(); } if (_listener) { std::ostringstream buf; buf &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; _listener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } void Zomby::runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) { if (_semaphore) { throw std::runtime_error("SteppingZomby::Zomby::runOnce() called twice"); } _listener = listener; _semaphore = true; _thread = std::thread([shis = shared_from_this()](){ if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;resolveDnsName(); } if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;connectTcp(); } if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;establishSsl(); } if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;sendHttpRequest(); } if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;readHttpReply(); } }); } void Zomby::resolveDnsName() { doSomething(*_listener, std::string(typeid(*this).name()) + "::" + __func__); } void Zomby::connectTcp() { doSomething(*_listener, std::string(typeid(*this).name()) + "::" + __func__); } void Zomby::establishSsl() { doSomething(*_listener, std::string(typeid(*this).name()) + "::" + __func__); } void Zomby::sendHttpRequest() { doSomething(*_listener, std::string(typeid(*this).name()) + "::" + __func__); } void Zomby::readHttpReply() { doSomething(*_listener, std::string(typeid(*this).name()) + "::" + __func__); } } // namespace SteppingZomby</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;chrono&gt; #include &lt;thread&gt; #include &lt;sstream&gt; #include "SteppingZomby/SteppingZomby.h" #include "Common/Impl/WriteToConsoleListener.h" int main() { auto writeToConsoleListener = Common::WriteToConsoleListener::instance(); { auto steppingZomby = SteppingZomby::Zomby::create(); steppingZomby-&gt;runOnce(writeToConsoleListener); std::this_thread::sleep_for(std::chrono::milliseconds(1500)); } // Zombies should be killed here { std::ostringstream buf; buf &lt;&lt; "============================================================\n" &lt;&lt; "| Zomby was killed |\n" &lt;&lt; "============================================================\n"; if (writeToConsoleListener) { writeToConsoleListener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } std::this_thread::sleep_for(std::chrono::milliseconds(5000)); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sortie console</b> <div class="spoiler_text"><blockquote>  N13SteppingZomby5ZombyE :: resolDnsName démarré <br>  N13SteppingZomby5ZombyE :: resolDnsName terminé <br>  N13SteppingZomby5ZombyE :: connectTcp démarré <br>  =================================================== =========== <br>  |  Zomby a été tué | <br>  =================================================== =========== <br>  N13SteppingZomby5ZombyE :: connectTcp terminé <br>  N13SteppingZomby5ZombyE :: EstablSsl démarré <br>  N13SteppingZomby5ZombyE :: EstablSsl terminé <br>  N13SteppingZomby5ZombyE :: sendHttpRequest démarré <br>  N13SteppingZomby5ZombyE :: sendHttpRequest terminé <br>  N13SteppingZomby5ZombyE :: readHttpRéponse démarrée <br>  N13SteppingZomby5ZombyE :: readHttpRéfini <br>  N13SteppingZomby5ZombyE :: ~ Zomby <br>  N6Common22WriteToConsoleListenerE :: ~ WriteToConsoleListener <br></blockquote><br></div></div><br>  Comme dans l'exemple précédent, un appel à runOnce () a conduit à une référence circulaire. <br>  Mais cette fois, les destructeurs Zomby et WriteToConsoleListener <b>ont été</b> appelés.  Toutes les ressources ont été correctement libérées jusqu'à la fin de l'application.  Une fuite de mémoire ne s'est pas produite. <br><br>  <b>Quel est donc le problème?</b> <br>  Le problème est que le zombie a vécu trop longtemps - environ trois secondes et demie après la destruction de tous les liens externes forts et faibles avec lui.  Environ trois secondes de plus qu'il n'aurait dû vivre.  Et pendant tout ce temps, il s'est engagé à promouvoir la mise en œuvre de la connexion HTTPS - jusqu'à ce qu'il la mette fin.  Malgré le fait que le résultat n'était plus nécessaire.  Malgré le fait que la logique commerciale supérieure a essayé d'arrêter les zombies. <br><br>  <b>Eh bien, réfléchissez-y, vous avez la réponse dont vous n'avez pas besoin ...</b> <br>  Dans le cas d'une connexion HTTPS client, les conséquences <b>de notre côté</b> peuvent être les suivantes: <br>  - consommation de mémoire; <br>  - Consommation CPU; <br>  - Consommation du port TCP; <br>  - la bande passante du canal de communication (la demande et la réponse peuvent être un volume en mégaoctets); <br>  - des données inattendues peuvent perturber le fonctionnement de la logique métier de niveau supérieur - jusqu'à la transition vers la mauvaise branche d'exécution ou à un comportement indéfini, car  les mécanismes de traitement des réponses peuvent déjà être détruits. <br>  Et <b>du côté distant</b> (n'oubliez pas - la requête HTTPS était destinée à quelqu'un) - exactement le même gaspillage de ressources, en plus c'est possible: <br>  - publier des photos de chats sur un site Internet d'entreprise; <br>  - désactiver le chauffage au sol dans votre cuisine; <br>  - exécution d'un ordre commercial sur la bourse; <br>  - transfert d'argent depuis votre compte; <br>  - lancement d'un missile balistique intercontinental. <br>  La logique commerciale a essayé d'arrêter les zombies en supprimant tous les liens forts et faibles avec elle.  L'arrêt de l'avancement de la demande HTTPS <b>devait se produire</b> - il n'était pas encore trop tard, les données de niveau application n'avaient pas encore été envoyées. <br>  Mais les zombies ont décidé à leur manière. <br><br>  La logique métier peut créer de nouveaux objets à la place des zombies et essayer à nouveau de les détruire, multipliant ainsi la fuite des ressources. <br>  Dans le cas d'un processus continu (par exemple, une connexion Websocket), le gaspillage de ressources peut se poursuivre pendant des heures et s'il existe un mécanisme de reconnexion automatique dans l'implémentation lorsque la connexion est déconnectée, généralement jusqu'à l'arrêt du programme. <br><br>  <b>Valgrind?</b> <br>  Aucune chance.  Tout est correctement libéré et nettoyé.  Tard et pas du fil principal, mais complètement correct. <br><br><h3>  Boozdedzomby </h3><br>  Cet exemple utilise la bibliothèque boozd :: azzio, qui est une imitation de boost :: asio.  Malgré le fait que l'imitation soit assez grossière, elle nous permet de démontrer l'essence du problème.     io_context::async_read (   ,     ), : <br> — stream,     ; <br> — ,    ; <br> — callback-,       . <br>  io_context::async_read       callback,       (, ).        io_context::run() (     ,        ). <br><br><div class="spoiler"> <b class="spoiler_title">buffer.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;vector&gt; namespace boozd::azzio { using buffer = std::vector&lt;int&gt;; } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">stream.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;optional&gt; namespace boozd::azzio { class stream { public: virtual ~stream() = default; virtual std::optional&lt;int&gt; read() = 0; }; } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">io_context.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;functional&gt; #include &lt;optional&gt; #include "buffer.h" namespace boozd::azzio { class stream; class io_context { public: ~io_context(); enum class error_code {no_error, good_error, bad_error, unknown_error, known_error, well_known_error}; using handler = std::function&lt;void(error_code)&gt;; // Start an asynchronous operation to read a certain amount of data from a stream. // This function is used to asynchronously read a certain number of bytes of data from a stream. // The function call always returns immediately. void async_read(stream&amp; s, buffer&amp; b, handler&amp;&amp; handler); // Run the io_context object's event processing loop. void run(); private: using pack = std::tuple&lt;stream&amp;, buffer&amp;&gt;; using pack_optional = std::optional&lt;pack&gt;; using handler_optional = std::optional&lt;handler&gt;; pack_optional _pack_optional; handler_optional _handler_optional; }; } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">io_context.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;thread&gt; #include &lt;chrono&gt; #include "io_context.h" #include "stream.h" namespace boozd::azzio { io_context::~io_context() { std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } void io_context::async_read(stream&amp; s, buffer&amp; b, io_context::handler&amp;&amp; handler) { _pack_optional.emplace(s, b); _handler_optional.emplace(std::move(handler)); } void io_context::run() { if (_pack_optional &amp;&amp; _handler_optional) { auto&amp; [s, b] = *_pack_optional; using namespace std::chrono; auto start = steady_clock::now(); while (duration_cast&lt;milliseconds&gt;(steady_clock::now() - start).count() &lt; 1000) { if (auto read = s.read()) b.emplace_back(*read); std::this_thread::sleep_for(milliseconds(100)); } (*_handler_optional)(error_code::no_error); } } } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br>    boozd::azzio::stream,   : <br><br><div class="spoiler"> <b class="spoiler_title">impl/random_stream.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"boozd/azzio/stream.h"</span></span></span><span class="hljs-meta"> namespace boozd::azzio { class random_stream final : public stream { public: ~random_stream() override; std::optional</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;int&gt; read() override; }; } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">impl/random_stream.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include "random_stream.h" namespace boozd::azzio { boozd::azzio::random_stream::~random_stream() { std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } std::optional&lt;int&gt; random_stream::read() { if (!(rand() &amp; 0x1)) return rand(); return std::nullopt; } } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br> BoozdedZomby     -. -      async_read(),       boozd::azzio   run().     boozd::azzio        ( )      callback-.      ,    , -  shared_from_this. <br><br><div class="spoiler"> <b class="spoiler_title">BoozdedZomby.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;atomic&gt; #include &lt;thread&gt; #include "Common/Manager.h" #include "boozd/azzio/buffer.h" #include "boozd/azzio/io_context.h" #include "boozd/azzio/impl/random_stream.h" namespace Common { class Listener; } // namespace Common namespace BoozdedZomby { class Zomby final : public Common::Manager, public std::enable_shared_from_this&lt;Zomby&gt; { public: static std::shared_ptr&lt;Zomby&gt; create(); ~Zomby() override; void runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) override; private: Zomby(); using Semaphore = std::atomic&lt;bool&gt;; Semaphore _semaphore = false; std::shared_ptr&lt;Common::Listener&gt; _listener; boozd::azzio::random_stream _stream; boozd::azzio::buffer _buffer; boozd::azzio::io_context _context; std::thread _thread; }; } // namespace BoozdedZomby</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">BoozdedZomby.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;sstream&gt; #include "boozd/azzio/impl/random_stream.h" #include "BoozdedZomby.h" #include "Common/Listener.h" namespace BoozdedZomby { Zomby::Zomby() = default; std::shared_ptr&lt;Zomby&gt; Zomby::create() { return std::shared_ptr&lt;Zomby&gt;(new Zomby()); } Zomby::~Zomby() { _semaphore = false; if (_thread.joinable()) { _thread.detach(); } if (_listener) { std::ostringstream buf; buf &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; _listener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } void Zomby::runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) { if (_semaphore) { throw std::runtime_error("BoozdedZomby::Zomby::runOnce() called twice"); } _listener = listener; _semaphore = true; _thread = std::thread([shis = shared_from_this()]() { while (shis &amp;&amp; shis-&gt;_semaphore &amp;&amp; shis-&gt;_listener) { auto handler = [shis](auto errorCode) { if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; errorCode == boozd::azzio::io_context::error_code::no_error) { std::ostringstream buf; buf &lt;&lt; "BoozdedZomby has got a fresh data: "; for (auto const &amp;elem : shis-&gt;_buffer) buf &lt;&lt; elem &lt;&lt; ' '; buf &lt;&lt; std::endl; shis-&gt;_listener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } }; shis-&gt;_buffer.clear(); shis-&gt;_context.async_read(shis-&gt;_stream, shis-&gt;_buffer, handler); shis-&gt;_context.run(); } }); } } // namespace BoozdedZomby</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;chrono&gt; #include &lt;thread&gt; #include &lt;sstream&gt; #include "BoozdedZomby/BoozdedZomby.h" #include "Common/Impl/WriteToConsoleListener.h" int main() { auto writeToConsoleListener = Common::WriteToConsoleListener::instance(); { auto boozdedZomby = BoozdedZomby::Zomby::create(); boozdedZomby-&gt;runOnce(writeToConsoleListener); std::this_thread::sleep_for(std::chrono::milliseconds(4500)); } // Zombies should be killed here { std::ostringstream buf; buf &lt;&lt; "============================================================\n" &lt;&lt; "| Zomby was killed |\n" &lt;&lt; "============================================================\n"; if (writeToConsoleListener) { writeToConsoleListener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } std::this_thread::sleep_for(std::chrono::milliseconds(5000)); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><blockquote> BoozdedZomby has got a fresh data: 1144108930 101027544 1458777923 1115438165 74243042 <br> BoozdedZomby has got a fresh data: 143542612 1131570933 <br> BoozdedZomby has got a fresh data: 893351816 563613512 704877633 <br> BoozdedZomby has got a fresh data: 1551901393 1399125485 1899894091 937186357 590357944 357571490 <br> ============================================================ <br>  | Zomby was killed | <br> ============================================================ <br> BoozdedZomby has got a fresh data: 1927702196 130060903 1083454666 2118797801 2035308228 824938981 <br> BoozdedZomby has got a fresh data: 2020739063 1635339425 34075629 <br> BoozdedZomby has got a fresh data: 2146319451 500782188 1269406752 884936716 892053144 <br> BoozdedZomby has got a fresh data: 330111137 1723153177 1070477904 <br> BoozdedZomby has got a fresh data: 343098142 280090412 589673557 889688008 2014119113 388471006 <br></blockquote><br></div></div><br>    run_once()   .         .       ,     : <br> — boozdedZomby; <br> — writeToConsoleListener; <br> —   . <br>   . <br>   . <br><br> <b>     ?</b> <br>      .      .          boost::asio.  ,              —        ( ). <br><br> <b>Valgrind?</b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Passé. </font><font style="vertical-align: inherit;">Bien qu'il semble s'agir de détecter des fuites.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zombies à l'état sauvage </font></font></h2><br> <b> !    !</b> <br>   . <br> <a href="https://www.boost.org/doc/libs/master/libs/beast/example/http/client/async/"> HTTP-</a> <br> <a href=""> Websocket-</a> <br>    boost ,    BoozdedZomby + SteppingZomby.   ,     .         ,      production —       ,      . <br><br> <b>  ,   boost::asio::io_context!</b> <br> …    n  (, -),    . <br><br>  : <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">     </a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">    stackoverflow ,        </a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   ,      </a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">         </a> <br><br><h2>  Conclusion </h2><br> ,        «». <br><br>         ,       . <br><br>        std::thread    —          . <br><br>      ,   . <br><br>     event-driven,        (polling-based). <br><br>     . <br><br> ,  <b></b>           .       std::enable_shared_from_this,       (       —       ). ,        :            -    . <br><br>           ,    SteppingZomby.       —          shared_from_this (  ,   ,       —   1  6  ). <br><br>           —     ,  .   . <br><br>  ,   ,  .        std::enable_shared_from_this —  <b></b> . <br><br> PS:    —        . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr471326/">https://habr.com/ru/post/fr471326/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr471310/index.html">Mon opinion très subjective sur la formation professionnelle et pas seulement en informatique</a></li>
<li><a href="../fr471312/index.html">Préparation à la certification professionnelle du printemps. Botte de printemps</a></li>
<li><a href="../fr471318/index.html">Septembre Digest sur l'apprentissage automatique et l'intelligence artificielle</a></li>
<li><a href="../fr471320/index.html">Outils pour les développeurs de logiciels: framework ouvert et bibliothèques d'apprentissage automatique</a></li>
<li><a href="../fr471324/index.html">Les réseaux de neurones rêvent-ils de la Joconde?</a></li>
<li><a href="../fr471330/index.html">Histoires de l'ordinateur lunaire. 2e partie</a></li>
<li><a href="../fr471332/index.html">Histoires de l'ordinateur lunaire. 3e partie</a></li>
<li><a href="../fr471334/index.html">Pour mémoriser, mais pas pour entasser - apprendre «par cartes»</a></li>
<li><a href="../fr471336/index.html">Holivar. Histoire de Runet. Partie 6. Serrures: Lurk, Tape, 282nd et Chinese path</a></li>
<li><a href="../fr471340/index.html">Drimsim vs Mate 20 Pro Round! Mais pour qui?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>