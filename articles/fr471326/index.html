<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üôÖüèΩ üòö üõåüèª The Tale of the Dangerous std :: enable_shared_from_this, ou l'anti-mod√®le Zombie ‚òòÔ∏è ‚è´ üñêüèø</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="L'article d√©crit le dangereux motif "Zombies", qui se produit naturellement dans certaines situations lors de l'utilisation de std :: enable_shared_fr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>The Tale of the Dangerous std :: enable_shared_from_this, ou l'anti-mod√®le Zombie</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471326/">  L'article d√©crit le dangereux motif "Zombies", qui se produit naturellement dans certaines situations lors de l'utilisation de std :: enable_shared_from_this.  Le mat√©riau est quelque part √† la jonction de la technologie et de l'architecture C ++ modernes. <br><a name="habracut"></a><br><h3>  Pr√©sentation </h3><br>  C ++ 11 a fourni au d√©veloppeur de merveilleux outils pour travailler avec la m√©moire - des pointeurs intelligents std :: unique_ptr et un tas de std :: shared_ptr + std :: faiblesse_ptr.  L'utilisation de pointeurs intelligents pour plus de commodit√© et de s√©curit√© l'emporte de loin sur l'utilisation de pointeurs bruts.  Les pointeurs intelligents sont largement utilis√©s dans la pratique, comme  permettre au d√©veloppeur de se concentrer sur des probl√®mes de niveau sup√©rieur au suivi de l'exactitude de la cr√©ation / suppression d'entit√©s cr√©√©es dynamiquement. <br>  Le mod√®le de classe std :: enable_shared_from_this fait √©galement partie du standard, et cela semble plut√¥t √©trange lorsque vous le rencontrez pour la premi√®re fois. <br>  L'article expliquera comment vous pouvez vous retrouver avec son utilisation. <br><br><h2>  Programme √©ducatif </h2><br><div class="spoiler">  <b class="spoiler_title">RAII et pointeurs intelligents</b> <div class="spoiler_text"> Le but direct des pointeurs intelligents est de prendre soin d'un <b>morceau de RAM</b> allou√© sur le tas.  Les pointeurs intelligents impl√©mentent l'idiome RAII (l'acquisition de ressources est l'initialisation) et peuvent facilement √™tre adapt√©s pour prendre en charge d'autres types de ressources qui n√©cessitent une initialisation et une d√©sinitialisation non triviale, telles que: <br>  - fichiers; <br>  - dossiers temporaires sur le disque; <br>  - connexions r√©seau (http, websockets); <br>  - fils d'ex√©cution (fils); <br>  - mutex; <br>  - autre (ce qui suffit pour la fantaisie). <br>  Pour une telle g√©n√©ralisation, il suffit d'√©crire une classe (en fait, parfois vous ne pouvez m√™me pas √©crire une classe, mais utilisez simplement deleter - mais aujourd'hui, le conte n'est pas √† ce sujet), impl√©mentant: <br>  - initialisation dans le constructeur ou dans une m√©thode distincte; <br>  - d√©sinitialisation dans le destructeur, <br>  puis ¬´envelopper¬ª dans le pointeur intelligent appropri√©, selon le mod√®le de propri√©t√© requis - joint (std :: shared_ptr) ou sole (std :: unique_ptr).  Il en r√©sulte un ¬´RAII √† deux couches¬ª: un pointeur intelligent vous permet de transf√©rer / partager la propri√©t√© de la ressource, et la classe d'utilisateurs initialise / d√©sinitialise une ressource non standard. <br>  std :: shared_ptr utilise un m√©canisme de comptage de liens.  La norme d√©finit le compteur de liens forts (compte le nombre de copies existantes de std :: shared_ptr) et le compteur de liens faibles (compte le nombre de copies existantes de std :: faiblesse_ptr cr√©√©es pour cette instance de std :: shared_ptr).  La pr√©sence d'au moins un lien fort garantit que la destruction n'a pas encore √©t√© effectu√©e.  Cette propri√©t√© std :: shared_ptr est largement utilis√©e pour garantir la validit√© d'un objet jusqu'√† ce que son utilisation soit termin√©e dans toutes les parties du programme.  La pr√©sence d'un maillon faible n'emp√™che pas la destruction de l'objet et ne permet d'obtenir un maillon fort que jusqu'√† sa destruction. <br>  RAII garantit que la lib√©ration d'une ressource est beaucoup plus fiable qu'un appel explicite √† supprimer / supprimer [] / libre / fermer / r√©initialiser / d√©verrouiller, car: <br>  - vous pouvez simplement oublier l'appel explicite; <br>  - un appel explicite peut √™tre effectu√© par erreur plusieurs fois; <br>  - un d√©fi explicite est difficile lors de la mise en ≈ìuvre de la propri√©t√© partag√©e d'une ressource; <br>  - le m√©canisme de promotion de pile en c ++ garantit l'appel de destructeurs pour tous les objets qui sortent du domaine en cas d'exception. <br>  La garantie de d√©sinitialisation dans l'idiome est si importante qu'elle m√©rite une bonne place au nom de l'idiome avec l'initialisation. <br>  Les pointeurs intelligents pr√©sentent √©galement des inconv√©nients: <br>  - la pr√©sence de surcharge en termes de performances et de m√©moire (pour la plupart des applications ce n'est pas significatif); <br>  - la possibilit√© de liens cycliques bloquant la lib√©ration de la ressource et entra√Ænant sa fuite. <br>  Chaque d√©veloppeur a s√ªrement lu plus d'une fois des liens circulaires et vu des exemples synth√©tiques de code probl√©matique. <br>  Le danger peut sembler insignifiant pour les raisons suivantes: <br>  - si la m√©moire fuit fr√©quemment et beaucoup - cela est notable dans sa consommation, et si rarement et peu - alors le probl√®me a peu de chances de se manifester au niveau de l'utilisateur final; <br>  - utilise l'analyse de code dynamique pour les fuites (Valgrind, Clang LeakSanitizer, etc.); <br>  - "Je n‚Äô√©cris pas comme √ßa"; <br>  - ¬´mon architecture est correcte¬ª; <br>  "Notre code est en cours de r√©vision." <br></div></div><br><div class="spoiler">  <b class="spoiler_title">std :: enable_shared_from_this</b> <div class="spoiler_text">  En C ++ 11, la classe d'assistance std :: enable_shared_from_this est introduite.  Pour un d√©veloppeur qui construit avec succ√®s du code sans std :: enable_shared_from_this, les utilisations potentielles de cette classe peuvent ne pas √™tre √©videntes. <br>  Que fait std :: enable_shared_from_this? <br>  Il permet aux fonctions membres de la classe qui est instanci√©e dans std :: shared_ptr de recevoir des copies suppl√©mentaires fortes (shared_from_this ()) ou faibles (faibles_from_this (), √† partir de C ++ 17) du std :: shared_ptr dans lequel il a √©t√© cr√©√© .  Vous ne pouvez pas appeler shared_from_this () et faible_from_this () √† partir du constructeur et du destructeur. <br><br>  <b>Pourquoi si dur?</b>  <b>Vous pouvez simplement construire std :: shared_ptr &lt;T&gt; (this)</b> <br>  Non, tu ne peux pas.  Tous les std :: shared_ptrs qui se soucient de la m√™me instance de la classe doivent utiliser une unit√© de comptage de liens.  Il n'y a aucun moyen de se passer de magie sp√©ciale. <br><br>  Une condition pr√©alable √† l'utilisation de std :: enable_shared_from_this est de cr√©er initialement un objet de classe dans std :: shared_ptr.  Cr√©er sur la pile, allouer dynamiquement sur le tas, cr√©er sur std :: unique_ptr - tout cela ne convient pas.  Seulement strictement dans std :: shared_ptr. <br><br>  <b>Est-il possible de limiter l'utilisateur dans la mani√®re de cr√©er des instances de la classe?</b> <br>  Oui tu peux.  Pour ce faire, il suffit: <br>  - fournir une m√©thode statique pour cr√©er des instances initialement plac√©es dans std :: shared_ptr; <br>  - mettre le constructeur en priv√© ou prot√©g√©; <br>  - interdire la s√©mantique de copie et de d√©placement. <br>  La classe est entr√©e dans la cage, l'a verrouill√©e et a aval√© la cl√© - d√©sormais toutes ses instances ne vivront que dans std :: shared_ptr, et il n'y a aucun moyen l√©gal de les faire sortir de l√†. <br>  Une telle restriction ne peut pas √™tre qualifi√©e de bonne solution architecturale, mais cette m√©thode est enti√®rement conforme √† la norme. <br>  De plus, vous pouvez utiliser l'idiome PIMPL: le seul utilisateur de la classe capricieuse - la fa√ßade - cr√©era l'impl√©mentation strictement dans std :: shared_ptr, et la fa√ßade elle-m√™me sera d√©j√† priv√©e de restrictions de ce type. <br><br>  std :: enable_shared_from_this a des nuances importantes dans l'h√©ritage, mais les discuter d√©passe le cadre de cet article. <br></div></div><br><h2>  Aller droit au but </h2><br>  Tous les exemples de code fournis dans l'article sont publi√©s sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">github</a> . <br>  Le code montre de mauvaises techniques d√©guis√©es en utilisation s√ªre habituelle du C ++ moderne <br><br><h3>  Simplecyclic </h3><br>  Il semble que rien ne pr√©sage de probl√®mes.  Une d√©claration de classe semble simple et directe.  √Ä l'exception d'un ¬´petit¬ª d√©tail - pour une raison quelconque, l'h√©ritage de std :: enable_shared_from_this est appliqu√©. <br><br><div class="spoiler">  <b class="spoiler_title">SimpleCyclic.h</b> <div class="spoiler_text"><pre><code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;functional&gt; namespace SimpleCyclic { class Cyclic final : public std::enable_shared_from_this&lt;Cyclic&gt; { public: static std::shared_ptr&lt;Cyclic&gt; create(); Cyclic(const Cyclic&amp;) = delete; Cyclic(Cyclic&amp;&amp;) = delete; Cyclic&amp; operator=(const Cyclic&amp;) = delete; Cyclic&amp; operator=(Cyclic&amp;&amp;) = delete; ~Cyclic(); void doSomething(); private: Cyclic(); std::function&lt;void(void)&gt; _fn; }; } // namespace SimpleCyclic</span></span></span></span></code> </pre> <br></div></div><br>  Et en cours d'ex√©cution: <br><br><div class="spoiler">  <b class="spoiler_title">SimpleCyclic.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include "SimpleCyclic.h" namespace SimpleCyclic { Cyclic::Cyclic() = default; Cyclic::~Cyclic() { std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } std::shared_ptr&lt;Cyclic&gt; Cyclic::create() { return std::shared_ptr&lt;Cyclic&gt;(new Cyclic); } void Cyclic::doSomething() { _fn = [shis = shared_from_this()](){}; std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } } // namespace SimpleCyclic</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"SimpleCyclic/SimpleCyclic.h"</span></span></span><span class="hljs-meta"> int main() { auto simpleCyclic = SimpleCyclic::Cyclic::create(); simpleCyclic-&gt;doSomething(); return 0; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sortie console</b> <div class="spoiler_text"><blockquote>  N12SimpleCyclic6CyclicE :: doSomething <br></blockquote><br></div></div><br>  Dans le corps de la fonction doSomething (), l'instance de classe <b>elle-m√™me</b> cr√©era une copie forte suppl√©mentaire du std :: shared_ptr dans lequel elle a √©t√© plac√©e.  Ensuite, √† l'aide d'une capture g√©n√©ralis√©e, cette copie est plac√©e dans une fonction lambda affect√©e au champ de donn√©es de classe sous le couvert d'une fonction std :: inoffensive.  Un appel √† doSomething () entra√Æne une r√©f√©rence circulaire et l'instance de classe ne sera plus d√©truite m√™me apr√®s la destruction de tous les liens forts externes. <br>  Il y a une fuite de m√©moire.  Le destructeur cyclique SimpleCyclic :: Cyclic :: ~ n'est pas appel√©. <br><br>  <b>L'instance de classe se ¬´conserve¬ª.</b> <b><br></b>  <b>Le code s'est coinc√© dans un n≈ìud.</b> <br><br><img src="https://habrastorage.org/webt/xp/jj/_a/xpjj_atj4bf0av8kar46ebxqqew.jpeg"><br>  (image prise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d'ici</a> ) <br><br>  <b>Et quoi, c'est l'anti-mod√®le "Zombie"?</b> <br>  Non, c'est juste une s√©ance d'entra√Ænement.  Le plus int√©ressant reste √† venir. <br><br>  <b>Pourquoi le d√©veloppeur a-t-il √©crit cela?</b> <br>  Exemple synth√©tique.  Je n'ai connaissance d'aucune situation dans laquelle un tel code serait harmonieusement obtenu. <br><br>  <b>Alors, l'analyse de code dynamique est-elle rest√©e silencieuse?</b> <br>  Non, Valgrind a honn√™tement signal√© une fuite de m√©moire: <br><br><div class="spoiler">  <b class="spoiler_title">Post Valgrind</b> <div class="spoiler_text"><blockquote>  96 (64 directs, 32 indirects) octets en 1 bloc sont <b>d√©finitivement perdus</b> dans le record de perte 29 de 46 <br>  dans SimpleCyclic :: Cyclic :: create () dans /Users/User/Projects/Zomby_antipattern_concept/SimpleCyclic/SimpleCyclic.cpp:15 <br>  1: malloc dans /usr/local/Cellar/valgrind/HEAD-60ab74a/lib/valgrind/vgpreload_memcheck-amd64-darwin.so <br>  2: nouvel op√©rateur (long non sign√©) dans /usr/lib/libc++abi.dylib <br>  3: SimpleCyclic :: Cyclic :: create () dans /Users/User/Projects/Zomby_antipattern_concept/SimpleCyclic/SimpleCyclic.cpp:15 <br>  4: principal dans /Users/User/Projects/Zomby_antipattern_concept/SimpleCyclic/main.cpphaps <br></blockquote><br></div></div><br><h3>  Pimplcyclic </h3><br>  Dans ce cas, le fichier d'en-t√™te semble compl√®tement correct et concis.  Il a d√©clar√© une fa√ßade qui stocke une certaine impl√©mentation dans std :: shared_ptr.  L'h√©ritage - y compris de std :: enable_shared_from_this - est manquant, contrairement √† l'exemple pr√©c√©dent. <br><br><div class="spoiler">  <b class="spoiler_title">Pimplcyclic.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; namespace PimplCyclic { class Cyclic { public: Cyclic(); ~Cyclic(); private: class Impl; std::shared_ptr&lt;Impl&gt; _impl; }; } // namespace PimplCyclic</span></span></span></span></code> </pre><br></div></div><br>  Et en cours d'ex√©cution: <br><br><div class="spoiler">  <b class="spoiler_title">Pimplcyclic.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;functional&gt; #include "PimplCyclic.h" namespace PimplCyclic { class Cyclic::Impl : public std::enable_shared_from_this&lt;Cyclic::Impl&gt; { public: ~Impl() { std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } void doSomething() { _fn = [shis = shared_from_this()](){}; std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } private: std::function&lt;void(void)&gt; _fn; }; Cyclic::Cyclic() : _impl(std::make_shared&lt;Impl&gt;()) { if (_impl) { _impl-&gt;doSomething(); } } Cyclic::~Cyclic() { std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } } // namespace PimplCyclic</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"PimplCyclic/PimplCyclic.h"</span></span></span><span class="hljs-meta"> int main() { auto pimplCyclic = PimplCyclic::Cyclic(); return 0; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sortie console</b> <div class="spoiler_text"><blockquote>  N11PimplCyclic6Cyclic4ImplE :: doSomething <br>  N11PimplCyclic6CyclicE :: ~ Cyclique <br></blockquote><br></div></div><br>  L'appel √† Impl :: doSomething () cr√©e une r√©f√©rence circulaire dans une instance de la classe Impl.  La fa√ßade est d√©truite correctement, mais la mise en ≈ìuvre fuit.  Le destructeur PimplCyclic :: Cyclic :: Impl :: ~ Impl n'est pas appel√©. <br>  L'exemple est √† nouveau synth√©tique, mais cette fois plus dangereux - tout le mauvais mat√©riel se trouve dans la mise en ≈ìuvre et n'appara√Æt pas dans l'annonce. <br>  De plus, pour cr√©er un lien circulaire, le code utilisateur ne n√©cessitait aucune action autre que la construction. <br>  L'analyse dynamique face √† Valgrind, et cette fois a r√©v√©l√© une fuite: <br><br><div class="spoiler">  <b class="spoiler_title">Post Valgrind</b> <div class="spoiler_text"><blockquote>  96 octets en 1 blocs sont <b>d√©finitivement perdus</b> dans le record de perte 29 de 46 <br>  dans PimplCyclic :: Cyclic :: Cyclic () dans /Users/User/Projects/Zomby_antipattern_concept/PimplCyclic/PimplCyclic.cpp:28 <br>  1: malloc dans /usr/local/Cellar/valgrind/HEAD-60ab74a/lib/valgrind/vgpreload_memcheck-amd64-darwin.so <br>  2: nouvel op√©rateur (long non sign√©) dans /usr/lib/libc++abi.dylib <br>  3: std :: __ 1 :: __ libcpp_allocate (unsigned long, unsigned long) dans /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/new:252 <br>  4: std :: __ 1 :: allocator &lt;std :: __ 1 :: __ shared_ptr_emplace &lt;PimplCyclic :: Cyclic :: Impl, std :: __ 1 :: allocator &lt;PimplCyclic :: Cyclic :: Impl &gt;&gt;&gt; allocate (unsigned long , void const *) dans /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory:1813 <br>  5: std :: __ 1 :: shared_ptr &lt;PimplCyclic :: Cyclic :: Impl&gt; std :: __ 1 :: shared_ptr &lt;PimplCyclic :: Cyclic :: Impl&gt; :: make_shared &lt;&gt; () dans /Applications/Xcode.app/Contents /Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory:4326 <br>  6: _ZNSt3__1L11make_sharedIN11PimplCyclic6Cyclic4ImplEJEEENS_9enable_ifIXntsr8is_arrayIT_EE5valueENS_10shared_ptrIS5_EEE4typeEDpOT0_ dans /Applications/Xcode.app/Contents/Developer/Toolchains/XcodeDefault.xctoolchain/usr/include/c++/v1/memory:4706 <br>  7: PimplCyclic :: Cyclic :: Cyclic () dans /Users/User/Projects/Zomby_antipattern_concept/PimplCyclic/PimplCyclic.cpp:28 <br>  8: PimplCyclic :: Cyclic :: Cyclic () dans /Users/User/Projects/Zomby_antipattern_concept/PimplCyclic/PimplCyclic.cpp:29 <br>  9: principal dans /Users/User/Projects/Zomby_antipattern_concept/PimplCyclic/main.cpphaps <br></blockquote><br></div></div><br>  <b>C'est un peu suspect de voir Pimpl, dans lequel l'impl√©mentation est stock√©e dans std :: shared_ptr.</b> <br>  Le classique Pimpl bas√© sur un pointeur brut est trop archa√Øque, et std :: unique_ptr a pour effet secondaire de r√©pandre l'interdiction de copie s√©mantique sur la fa√ßade.  Une telle fa√ßade mettra en ≈ìuvre l'idiome de la propri√©t√© exclusive, qui peut ne pas correspondre √† l'id√©e architecturale.  De l'utilisation de std :: shared_ptr pour stocker l'impl√©mentation, nous concluons que la classe est con√ßue pour fournir une propri√©t√© partag√©e. <br><br>  <b>En quoi cela diff√®re-t-il de la fuite classique - allouer de la m√©moire en appelant explicitement new sans suppression ult√©rieure?</b>  <b>De la m√™me mani√®re, tout serait beau dans l'interface et dans l'impl√©mentation - un bug.</b> <br>  Nous discutons <b>des</b> moyens <b>modernes</b> de vous tirer une balle dans le pied. <br><br><h2>  Antipattern "Zombies" </h2><br>  Ainsi, d'apr√®s le mat√©riel ci-dessus, il est clair: <br>  - les pointeurs intelligents peuvent √™tre li√©s aux n≈ìuds; <br>  - l'utilisation de std :: enable_shared_from_this peut y contribuer, car  permet √† une instance d'une classe de se lier √† un n≈ìud sans presque aucune aide ext√©rieure. <br><br>  <b>Et maintenant - attention - la question cl√© de l'article: le type de ressource envelopp√© dans un pointeur intelligent est-il important?</b>  <b>Existe-t-il une diff√©rence entre un traitement de fichier RAII et une connexion HTTPS asynchrone?</b> <br><br><h3>  Simplezomby </h3><br>  Le code commun √† tous les exemples ult√©rieurs de zombies a √©t√© d√©plac√© vers la biblioth√®que commune. <br><br>  Interface zombie abstraite avec le modeste nom Manager: <br><br><div class="spoiler">  <b class="spoiler_title">Commun / Manager.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; namespace Common { class Listener; class Manager { public: Manager() = default; Manager(const Manager&amp;) = delete; Manager(Manager&amp;&amp;) = delete; Manager&amp; operator=(const Manager&amp;) = delete; Manager&amp; operator=(Manager&amp;&amp;) = delete; virtual ~Manager() = default; virtual void runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) = 0; }; } // namespace Common</span></span></span></span></code> </pre><br></div></div><br>  Interface abstraite de l'auditeur, pr√™te √† accepter du texte thread-safe: <br><br><div class="spoiler">  <b class="spoiler_title">Common / Listener.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;memory&gt; namespace Common { class Listener { public: virtual ~Listener() = default; using Data = std::string; // thread-safe virtual void processData(const std::shared_ptr&lt;const Data&gt; data) = 0; }; } // namespace Common</span></span></span></span></code> </pre><br></div></div><br>  √âcouteur qui affiche du texte sur la console.  Impl√©mente le concept SingletonShared de mon article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Technique pour √©viter les comportements ind√©finis lors de l'appel d'un singleton</a> : <br><br><div class="spoiler">  <b class="spoiler_title">Common / Impl / WriteToConsoleListener.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;mutex&gt; #include "Common/Listener.h" namespace Common { class WriteToConsoleListener final : public Listener { public: WriteToConsoleListener(const WriteToConsoleListener&amp;) = delete; WriteToConsoleListener(WriteToConsoleListener&amp;&amp;) = delete; WriteToConsoleListener&amp; operator=(const WriteToConsoleListener&amp;) = delete; WriteToConsoleListener&amp; operator=(WriteToConsoleListener&amp;&amp;) = delete; ~WriteToConsoleListener() override; static std::shared_ptr&lt;WriteToConsoleListener&gt; instance(); // blocking void processData(const std::shared_ptr&lt;const Data&gt; data) override; private: WriteToConsoleListener(); std::mutex _mutex; }; } // namespace Common</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Common / Impl / WriteToConsoleListener.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include "WriteToConsoleListener.h" namespace Common { WriteToConsoleListener::WriteToConsoleListener() = default; WriteToConsoleListener::~WriteToConsoleListener() { auto lock = std::lock_guard(_mutex); std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } std::shared_ptr&lt;WriteToConsoleListener&gt; WriteToConsoleListener::instance() { static auto inst = std::shared_ptr&lt;WriteToConsoleListener&gt;(new WriteToConsoleListener); return inst; } void WriteToConsoleListener::processData(const std::shared_ptr&lt;const Data&gt; data) { if (data) { auto lock = std::lock_guard(_mutex); std::cout &lt;&lt; *data &lt;&lt; std::flush; } } } // namespace Common</span></span></span></span></code> </pre><br></div></div><br>  Et enfin, le premier zombie, le plus simple et le plus ing√©nu. <br><br><div class="spoiler">  <b class="spoiler_title">SimpleZomby.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;atomic&gt; #include &lt;thread&gt; #include "Common/Manager.h" namespace Common { class Listener; } // namespace Common namespace SimpleZomby { class Zomby final : public Common::Manager, public std::enable_shared_from_this&lt;Zomby&gt; { public: static std::shared_ptr&lt;Zomby&gt; create(); ~Zomby() override; void runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) override; private: Zomby(); using Semaphore = std::atomic&lt;bool&gt;; std::shared_ptr&lt;Common::Listener&gt; _listener; Semaphore _semaphore = false; std::thread _thread; }; } // namespace SimpleZomby</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">SimpleZomby.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sstream&gt; #include "SimpleZomby.h" #include "Common/Listener.h" namespace SimpleZomby { std::shared_ptr&lt;Zomby&gt; Zomby::create() { return std::shared_ptr&lt;Zomby&gt;(new Zomby()); } Zomby::Zomby() = default; Zomby::~Zomby() { _semaphore = false; if (_thread.joinable()) { _thread.detach(); } if (_listener) { std::ostringstream buf; buf &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; _listener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } void Zomby::runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) { if (_semaphore) { throw std::runtime_error("SimpleZomby::Zomby::runOnce() called twice"); } _listener = listener; _semaphore = true; _thread = std::thread([shis = shared_from_this()](){ while (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;_listener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;("SimpleZomby is alive!\n")); std::this_thread::sleep_for(std::chrono::seconds(1)); } }); } } // namespace SimpleZomby</span></span></span></span></code> </pre><br></div></div><br>  Un zombie ex√©cute une fonction lambda dans un thread s√©par√©, envoyant p√©riodiquement une cha√Æne √† l'auditeur.  Les fonctions lambda pour le travail ont besoin d'un s√©maphore et d'un √©couteur, qui sont des champs de la classe zombie.  La fonction lambda ne les capture pas en tant que champs s√©par√©s, mais utilise l'objet comme agr√©gateur.  La destruction d'une instance de la classe zombie avant la fin de la fonction lambda entra√Ænera un comportement ind√©fini.  Pour √©viter cela, la fonction lambda capture une copie forte de shared_from_this (). <br>  Dans le destructeur de zombies, le s√©maphore est d√©fini sur false, apr√®s quoi detach () est appel√© pour le flux.  La d√©finition du s√©maphore indique au thread de s'arr√™ter. <br><br>  <b>Dans le destructeur, il fallait appeler non pas detach (), mais join ()!</b> <br>  ... et obtenez un destructeur qui bloque l'ex√©cution pour une dur√©e ind√©termin√©e, ce qui peut √™tre inacceptable. <br><br>  <b>C'est donc une violation de RAII!</b>  <b>RAII ne devait quitter le destructeur qu'apr√®s avoir lib√©r√© la ressource!</b> <br>  Si strictement - alors oui, le destructeur de zombies ne lib√®re pas la ressource, mais <b>garantit</b> seulement <b>que la lib√©ration sera effectu√©e</b> .  Parfois produit - peut-√™tre bient√¥t, ou peut-√™tre pas vraiment.  Et il est m√™me possible que main termine le travail plus t√¥t - le thread sera alors effac√© de force par le syst√®me d'exploitation.  Mais en fait, la ligne entre le ¬´bon¬ª et le ¬´mauvais¬ª RAII peut √™tre tr√®s mince: par exemple, le ¬´bon¬ª RAII, qui appelle std :: filesystem :: remove () dans un destructeur pour un fichier temporaire, pourrait bien lui rendre le contr√¥le. le moment o√π la commande d'√©criture sera toujours dans l'un des caches volatils et ne sera pas honn√™tement √©crite sur la plaque magn√©tique du disque dur. <br><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;chrono&gt; #include &lt;thread&gt; #include &lt;sstream&gt; #include "Common/Impl/WriteToConsoleListener.h" #include "SimpleZomby/SimpleZomby.h" int main() { auto writeToConsoleListener = Common::WriteToConsoleListener::instance(); { auto simpleZomby = SimpleZomby::Zomby::create(); simpleZomby-&gt;runOnce(writeToConsoleListener); std::this_thread::sleep_for(std::chrono::milliseconds(4500)); } // Zomby should be killed here { std::ostringstream buf; buf &lt;&lt; "============================================================\n" &lt;&lt; "| Zomby was killed |\n" &lt;&lt; "============================================================\n"; if (writeToConsoleListener) { writeToConsoleListener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } std::this_thread::sleep_for(std::chrono::milliseconds(5000)); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sortie console</b> <div class="spoiler_text"><blockquote>  SimpleZomby est vivant! <br>  SimpleZomby est vivant! <br>  SimpleZomby est vivant! <br>  SimpleZomby est vivant! <br>  SimpleZomby est vivant! <br>  =================================================== =========== <br>  |  Zomby a √©t√© tu√© | <br>  ==================================================== =========== <br>  SimpleZomby est vivant! <br>  SimpleZomby est vivant! <br>  SimpleZomby est vivant! <br>  SimpleZomby est vivant! <br>  SimpleZomby est vivant! <br></blockquote><br></div></div><br>  Ce qui peut √™tre vu √† la sortie du programme: <br>  - le zombie a continu√© √† fonctionner m√™me apr√®s avoir quitt√© le champ de visibilit√©; <br>  - aucun destructeur n'a √©t√© appel√© pour les zombies ou WriteToConsoleListener. <br>  Une fuite de m√©moire s'est produite. <br>  Il y a eu une fuite de ressources.  Et la ressource dans ce cas est le fil d'ex√©cution. <br>  Le code qui devait s'arr√™ter a continu√© de fonctionner dans un thread s√©par√©. <br>  Une fuite WriteToConsoleListener aurait pu √™tre √©vit√©e en utilisant la technique SingletonWeak de mon article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√âviter le comportement ind√©termin√© lors de l'appel d'un Singleton</a> , mais je ne l'ai pas fait intentionnellement. <br><br><img src="https://habrastorage.org/webt/mg/qu/e3/mgque3fstboi4ot2hvdwniafixe.jpeg"><br>  (image prise <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">d'ici</a> ) <br><br>  <b>Pourquoi des zombies?</b> <br>  Parce qu'il a √©t√© tu√© et qu'il est toujours en vie. <br><br>  <b>En quoi est-ce diff√©rent des r√©f√©rences circulaires des exemples pr√©c√©dents?</b> <br>  Le fait qu'une ressource perdue n'est pas seulement un morceau de m√©moire, mais quelque chose qui ex√©cute ind√©pendamment du code ind√©pendamment du thread qui l'a lanc√©e. <br><br>  <b>Est-il possible de d√©truire les "Zombies"?</b> <br>  Apr√®s avoir quitt√© la port√©e (c'est-√†-dire apr√®s avoir d√©truit toutes les r√©f√©rences externes fortes et faibles aux zombies) - c'est impossible.  Un zombie sera d√©truit quand il d√©cidera de se d√©truire (oui, c'est quelque chose avec un comportement actif), peut-√™tre jamais, c'est-√†-dire  survivra jusqu'√† ce que le syst√®me d'exploitation se nettoie √† la fin de l'application.  Bien s√ªr, le code utilisateur peut avoir un certain effet sur la condition de sortie du code zombie, mais cet effet sera indirect et d√©pend de l'impl√©mentation. <br><br>  <b>Et avant de quitter le champ d'application?</b> <br>  Vous pouvez explicitement appeler le destructeur de zombies, mais il est peu probable que vous √©vitiez un comportement ind√©fini en raison de la destruction r√©p√©t√©e de l'objet par le destructeur de pointeur intelligent √©galement - il s'agit d'un combat contre RAII.  Ou vous pouvez ajouter la fonction de d√©sinitialisation explicite - et c'est un rejet de RAII. <br><br>  <b>En quoi est-ce diff√©rent du d√©marrage d'un thread suivi de detach ()?</b> <br>  Dans le cas des zombies, contrairement √† un simple appel √† detach (), il y a une id√©e d'arr√™ter le flux.  Seulement √ßa ne marche pas.  Avoir la bonne id√©e permet de masquer le probl√®me. <br><br>  <b>L'exemple est-il toujours synth√©tique?</b> <br>  En partie.  Dans cet exemple simple, il n'y avait pas suffisamment de raisons d'utiliser shared_from_this () - par exemple, vous pourriez obtenir en capturant faibles_from_this () ou en capturant tous les champs obligatoires de la classe.  Mais avec la complexit√© de la t√¢che, l'√©quilibre peut basculer sur le c√¥t√© <br>  shared_from_this (). <br><br>  <b>Valgrind, Valgrind!</b>  <b>Nous avons une ligne de d√©fense suppl√©mentaire contre les zombies!</b> <br>  H√©las et ah - mais Valgrind n'a pas r√©v√©l√© de fuite de m√©moire.  Pourquoi - je ne sais pas.  Dans les diagnostics, il n'y a que des entr√©es <b>¬´√©ventuellement perdues¬ª</b> qui indiquent les fonctions du syst√®me - √† peu pr√®s la m√™me et √† peu pr√®s la m√™me quantit√© que lors de l'√©laboration d'une alimentation principale vide.  Il n'y a aucune r√©f√©rence de code utilisateur.  D'autres outils d'analyse dynamique pourraient faire mieux, mais si vous comptez toujours sur eux, lisez la suite. <br><br><h3>  Steppingzomby </h3><br>  Le code de cet exemple passe par les √©tapes resolDnsName ---&gt; connectTcp ---&gt; EstablSsl ---&gt; sendHttpRequest ---&gt; readHttpRhness, simulant le fonctionnement de la connexion HTTPS cliente en ex√©cution asynchrone.  Chaque √©tape prend environ une seconde. <br><br><div class="spoiler">  <b class="spoiler_title">Steppingzomby.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;atomic&gt; #include &lt;thread&gt; #include "Common/Manager.h" namespace Common { class Listener; } // namespace Common namespace SteppingZomby { class Zomby final : public Common::Manager, public std::enable_shared_from_this&lt;Zomby&gt; { public: static std::shared_ptr&lt;Zomby&gt; create(); ~Zomby() override; void runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) override; private: Zomby(); using Semaphore = std::atomic&lt;bool&gt;; std::shared_ptr&lt;Common::Listener&gt; _listener; Semaphore _semaphore = false; std::thread _thread; void resolveDnsName(); void connectTcp(); void establishSsl(); void sendHttpRequest(); void readHttpReply(); }; } // namespace SteppingZomby</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Steppingzomby.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;sstream&gt; #include &lt;string&gt; #include "SteppingZomby.h" #include "Common/Listener.h" namespace { void doSomething(Common::Listener&amp; listener, std::string&amp;&amp; callingFunctionName) { listener.processData(std::make_shared&lt;Common::Listener::Data&gt;(callingFunctionName + " started\n")); std::this_thread::sleep_for(std::chrono::milliseconds(1000)); listener.processData(std::make_shared&lt;Common::Listener::Data&gt;(callingFunctionName + " finished\n")); } } // namespace namespace SteppingZomby { Zomby::Zomby() = default; std::shared_ptr&lt;Zomby&gt; Zomby::create() { return std::shared_ptr&lt;Zomby&gt;(new Zomby()); } Zomby::~Zomby() { _semaphore = false; if (_thread.joinable()) { _thread.detach(); } if (_listener) { std::ostringstream buf; buf &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; _listener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } void Zomby::runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) { if (_semaphore) { throw std::runtime_error("SteppingZomby::Zomby::runOnce() called twice"); } _listener = listener; _semaphore = true; _thread = std::thread([shis = shared_from_this()](){ if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;resolveDnsName(); } if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;connectTcp(); } if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;establishSsl(); } if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;sendHttpRequest(); } if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; shis-&gt;_semaphore) { shis-&gt;readHttpReply(); } }); } void Zomby::resolveDnsName() { doSomething(*_listener, std::string(typeid(*this).name()) + "::" + __func__); } void Zomby::connectTcp() { doSomething(*_listener, std::string(typeid(*this).name()) + "::" + __func__); } void Zomby::establishSsl() { doSomething(*_listener, std::string(typeid(*this).name()) + "::" + __func__); } void Zomby::sendHttpRequest() { doSomething(*_listener, std::string(typeid(*this).name()) + "::" + __func__); } void Zomby::readHttpReply() { doSomething(*_listener, std::string(typeid(*this).name()) + "::" + __func__); } } // namespace SteppingZomby</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;chrono&gt; #include &lt;thread&gt; #include &lt;sstream&gt; #include "SteppingZomby/SteppingZomby.h" #include "Common/Impl/WriteToConsoleListener.h" int main() { auto writeToConsoleListener = Common::WriteToConsoleListener::instance(); { auto steppingZomby = SteppingZomby::Zomby::create(); steppingZomby-&gt;runOnce(writeToConsoleListener); std::this_thread::sleep_for(std::chrono::milliseconds(1500)); } // Zombies should be killed here { std::ostringstream buf; buf &lt;&lt; "============================================================\n" &lt;&lt; "| Zomby was killed |\n" &lt;&lt; "============================================================\n"; if (writeToConsoleListener) { writeToConsoleListener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } std::this_thread::sleep_for(std::chrono::milliseconds(5000)); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Sortie console</b> <div class="spoiler_text"><blockquote>  N13SteppingZomby5ZombyE :: resolDnsName d√©marr√© <br>  N13SteppingZomby5ZombyE :: resolDnsName termin√© <br>  N13SteppingZomby5ZombyE :: connectTcp d√©marr√© <br>  =================================================== =========== <br>  |  Zomby a √©t√© tu√© | <br>  =================================================== =========== <br>  N13SteppingZomby5ZombyE :: connectTcp termin√© <br>  N13SteppingZomby5ZombyE :: EstablSsl d√©marr√© <br>  N13SteppingZomby5ZombyE :: EstablSsl termin√© <br>  N13SteppingZomby5ZombyE :: sendHttpRequest d√©marr√© <br>  N13SteppingZomby5ZombyE :: sendHttpRequest termin√© <br>  N13SteppingZomby5ZombyE :: readHttpR√©ponse d√©marr√©e <br>  N13SteppingZomby5ZombyE :: readHttpR√©fini <br>  N13SteppingZomby5ZombyE :: ~ Zomby <br>  N6Common22WriteToConsoleListenerE :: ~ WriteToConsoleListener <br></blockquote><br></div></div><br>  Comme dans l'exemple pr√©c√©dent, un appel √† runOnce () a conduit √† une r√©f√©rence circulaire. <br>  Mais cette fois, les destructeurs Zomby et WriteToConsoleListener <b>ont √©t√©</b> appel√©s.  Toutes les ressources ont √©t√© correctement lib√©r√©es jusqu'√† la fin de l'application.  Une fuite de m√©moire ne s'est pas produite. <br><br>  <b>Quel est donc le probl√®me?</b> <br>  Le probl√®me est que le zombie a v√©cu trop longtemps - environ trois secondes et demie apr√®s la destruction de tous les liens externes forts et faibles avec lui.  Environ trois secondes de plus qu'il n'aurait d√ª vivre.  Et pendant tout ce temps, il s'est engag√© √† promouvoir la mise en ≈ìuvre de la connexion HTTPS - jusqu'√† ce qu'il la mette fin.  Malgr√© le fait que le r√©sultat n'√©tait plus n√©cessaire.  Malgr√© le fait que la logique commerciale sup√©rieure a essay√© d'arr√™ter les zombies. <br><br>  <b>Eh bien, r√©fl√©chissez-y, vous avez la r√©ponse dont vous n'avez pas besoin ...</b> <br>  Dans le cas d'une connexion HTTPS client, les cons√©quences <b>de notre c√¥t√©</b> peuvent √™tre les suivantes: <br>  - consommation de m√©moire; <br>  - Consommation CPU; <br>  - Consommation du port TCP; <br>  - la bande passante du canal de communication (la demande et la r√©ponse peuvent √™tre un volume en m√©gaoctets); <br>  - des donn√©es inattendues peuvent perturber le fonctionnement de la logique m√©tier de niveau sup√©rieur - jusqu'√† la transition vers la mauvaise branche d'ex√©cution ou √† un comportement ind√©fini, car  les m√©canismes de traitement des r√©ponses peuvent d√©j√† √™tre d√©truits. <br>  Et <b>du c√¥t√© distant</b> (n'oubliez pas - la requ√™te HTTPS √©tait destin√©e √† quelqu'un) - exactement le m√™me gaspillage de ressources, en plus c'est possible: <br>  - publier des photos de chats sur un site Internet d'entreprise; <br>  - d√©sactiver le chauffage au sol dans votre cuisine; <br>  - ex√©cution d'un ordre commercial sur la bourse; <br>  - transfert d'argent depuis votre compte; <br>  - lancement d'un missile balistique intercontinental. <br>  La logique commerciale a essay√© d'arr√™ter les zombies en supprimant tous les liens forts et faibles avec elle.  L'arr√™t de l'avancement de la demande HTTPS <b>devait se produire</b> - il n'√©tait pas encore trop tard, les donn√©es de niveau application n'avaient pas encore √©t√© envoy√©es. <br>  Mais les zombies ont d√©cid√© √† leur mani√®re. <br><br>  La logique m√©tier peut cr√©er de nouveaux objets √† la place des zombies et essayer √† nouveau de les d√©truire, multipliant ainsi la fuite des ressources. <br>  Dans le cas d'un processus continu (par exemple, une connexion Websocket), le gaspillage de ressources peut se poursuivre pendant des heures et s'il existe un m√©canisme de reconnexion automatique dans l'impl√©mentation lorsque la connexion est d√©connect√©e, g√©n√©ralement jusqu'√† l'arr√™t du programme. <br><br>  <b>Valgrind?</b> <br>  Aucune chance.  Tout est correctement lib√©r√© et nettoy√©.  Tard et pas du fil principal, mais compl√®tement correct. <br><br><h3>  Boozdedzomby </h3><br>  Cet exemple utilise la biblioth√®que boozd :: azzio, qui est une imitation de boost :: asio.  Malgr√© le fait que l'imitation soit assez grossi√®re, elle nous permet de d√©montrer l'essence du probl√®me.     io_context::async_read (   ,     ), : <br> ‚Äî stream,     ; <br> ‚Äî ,    ; <br> ‚Äî callback-,       . <br>  io_context::async_read       callback,       (, ).        io_context::run() (     ,        ). <br><br><div class="spoiler"> <b class="spoiler_title">buffer.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;vector&gt; namespace boozd::azzio { using buffer = std::vector&lt;int&gt;; } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">stream.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;optional&gt; namespace boozd::azzio { class stream { public: virtual ~stream() = default; virtual std::optional&lt;int&gt; read() = 0; }; } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">io_context.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;functional&gt; #include &lt;optional&gt; #include "buffer.h" namespace boozd::azzio { class stream; class io_context { public: ~io_context(); enum class error_code {no_error, good_error, bad_error, unknown_error, known_error, well_known_error}; using handler = std::function&lt;void(error_code)&gt;; // Start an asynchronous operation to read a certain amount of data from a stream. // This function is used to asynchronously read a certain number of bytes of data from a stream. // The function call always returns immediately. void async_read(stream&amp; s, buffer&amp; b, handler&amp;&amp; handler); // Run the io_context object's event processing loop. void run(); private: using pack = std::tuple&lt;stream&amp;, buffer&amp;&gt;; using pack_optional = std::optional&lt;pack&gt;; using handler_optional = std::optional&lt;handler&gt;; pack_optional _pack_optional; handler_optional _handler_optional; }; } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">io_context.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;thread&gt; #include &lt;chrono&gt; #include "io_context.h" #include "stream.h" namespace boozd::azzio { io_context::~io_context() { std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } void io_context::async_read(stream&amp; s, buffer&amp; b, io_context::handler&amp;&amp; handler) { _pack_optional.emplace(s, b); _handler_optional.emplace(std::move(handler)); } void io_context::run() { if (_pack_optional &amp;&amp; _handler_optional) { auto&amp; [s, b] = *_pack_optional; using namespace std::chrono; auto start = steady_clock::now(); while (duration_cast&lt;milliseconds&gt;(steady_clock::now() - start).count() &lt; 1000) { if (auto read = s.read()) b.emplace_back(*read); std::this_thread::sleep_for(milliseconds(100)); } (*_handler_optional)(error_code::no_error); } } } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br>    boozd::azzio::stream,   : <br><br><div class="spoiler"> <b class="spoiler_title">impl/random_stream.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"boozd/azzio/stream.h"</span></span></span><span class="hljs-meta"> namespace boozd::azzio { class random_stream final : public stream { public: ~random_stream() override; std::optional</span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;int&gt; read() override; }; } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">impl/random_stream.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include "random_stream.h" namespace boozd::azzio { boozd::azzio::random_stream::~random_stream() { std::cout &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; } std::optional&lt;int&gt; random_stream::read() { if (!(rand() &amp; 0x1)) return rand(); return std::nullopt; } } // namespace boozd::azzio</span></span></span></span></code> </pre><br></div></div><br> BoozdedZomby     -. -      async_read(),       boozd::azzio   run().     boozd::azzio        ( )      callback-.      ,    , -  shared_from_this. <br><br><div class="spoiler"> <b class="spoiler_title">BoozdedZomby.h</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">pragma</span></span></span><span class="hljs-meta"> once #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;memory&gt; #include &lt;atomic&gt; #include &lt;thread&gt; #include "Common/Manager.h" #include "boozd/azzio/buffer.h" #include "boozd/azzio/io_context.h" #include "boozd/azzio/impl/random_stream.h" namespace Common { class Listener; } // namespace Common namespace BoozdedZomby { class Zomby final : public Common::Manager, public std::enable_shared_from_this&lt;Zomby&gt; { public: static std::shared_ptr&lt;Zomby&gt; create(); ~Zomby() override; void runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) override; private: Zomby(); using Semaphore = std::atomic&lt;bool&gt;; Semaphore _semaphore = false; std::shared_ptr&lt;Common::Listener&gt; _listener; boozd::azzio::random_stream _stream; boozd::azzio::buffer _buffer; boozd::azzio::io_context _context; std::thread _thread; }; } // namespace BoozdedZomby</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">BoozdedZomby.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;iostream&gt; #include &lt;sstream&gt; #include "boozd/azzio/impl/random_stream.h" #include "BoozdedZomby.h" #include "Common/Listener.h" namespace BoozdedZomby { Zomby::Zomby() = default; std::shared_ptr&lt;Zomby&gt; Zomby::create() { return std::shared_ptr&lt;Zomby&gt;(new Zomby()); } Zomby::~Zomby() { _semaphore = false; if (_thread.joinable()) { _thread.detach(); } if (_listener) { std::ostringstream buf; buf &lt;&lt; typeid(*this).name() &lt;&lt; "::" &lt;&lt; __func__ &lt;&lt; std::endl; _listener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } void Zomby::runOnce(std::shared_ptr&lt;Common::Listener&gt; listener) { if (_semaphore) { throw std::runtime_error("BoozdedZomby::Zomby::runOnce() called twice"); } _listener = listener; _semaphore = true; _thread = std::thread([shis = shared_from_this()]() { while (shis &amp;&amp; shis-&gt;_semaphore &amp;&amp; shis-&gt;_listener) { auto handler = [shis](auto errorCode) { if (shis &amp;&amp; shis-&gt;_listener &amp;&amp; errorCode == boozd::azzio::io_context::error_code::no_error) { std::ostringstream buf; buf &lt;&lt; "BoozdedZomby has got a fresh data: "; for (auto const &amp;elem : shis-&gt;_buffer) buf &lt;&lt; elem &lt;&lt; ' '; buf &lt;&lt; std::endl; shis-&gt;_listener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } }; shis-&gt;_buffer.clear(); shis-&gt;_context.async_read(shis-&gt;_stream, shis-&gt;_buffer, handler); shis-&gt;_context.run(); } }); } } // namespace BoozdedZomby</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">main.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;chrono&gt; #include &lt;thread&gt; #include &lt;sstream&gt; #include "BoozdedZomby/BoozdedZomby.h" #include "Common/Impl/WriteToConsoleListener.h" int main() { auto writeToConsoleListener = Common::WriteToConsoleListener::instance(); { auto boozdedZomby = BoozdedZomby::Zomby::create(); boozdedZomby-&gt;runOnce(writeToConsoleListener); std::this_thread::sleep_for(std::chrono::milliseconds(4500)); } // Zombies should be killed here { std::ostringstream buf; buf &lt;&lt; "============================================================\n" &lt;&lt; "| Zomby was killed |\n" &lt;&lt; "============================================================\n"; if (writeToConsoleListener) { writeToConsoleListener-&gt;processData(std::make_shared&lt;Common::Listener::Data&gt;(buf.str())); } } std::this_thread::sleep_for(std::chrono::milliseconds(5000)); return 0; }</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">  </b> <div class="spoiler_text"><blockquote> BoozdedZomby has got a fresh data: 1144108930 101027544 1458777923 1115438165 74243042 <br> BoozdedZomby has got a fresh data: 143542612 1131570933 <br> BoozdedZomby has got a fresh data: 893351816 563613512 704877633 <br> BoozdedZomby has got a fresh data: 1551901393 1399125485 1899894091 937186357 590357944 357571490 <br> ============================================================ <br>  | Zomby was killed | <br> ============================================================ <br> BoozdedZomby has got a fresh data: 1927702196 130060903 1083454666 2118797801 2035308228 824938981 <br> BoozdedZomby has got a fresh data: 2020739063 1635339425 34075629 <br> BoozdedZomby has got a fresh data: 2146319451 500782188 1269406752 884936716 892053144 <br> BoozdedZomby has got a fresh data: 330111137 1723153177 1070477904 <br> BoozdedZomby has got a fresh data: 343098142 280090412 589673557 889688008 2014119113 388471006 <br></blockquote><br></div></div><br>    run_once()   .         .       ,     : <br> ‚Äî boozdedZomby; <br> ‚Äî writeToConsoleListener; <br> ‚Äî   . <br>   . <br>   . <br><br> <b>     ?</b> <br>      .      .          boost::asio.  ,              ‚Äî        ( ). <br><br> <b>Valgrind?</b> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pass√©. </font><font style="vertical-align: inherit;">Bien qu'il semble s'agir de d√©tecter des fuites.</font></font><br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Zombies √† l'√©tat sauvage </font></font></h2><br> <b> !    !</b> <br>   . <br> <a href="https://www.boost.org/doc/libs/master/libs/beast/example/http/client/async/"> HTTP-</a> <br> <a href=""> Websocket-</a> <br>    boost ,    BoozdedZomby + SteppingZomby.   ,     .         ,      production ‚Äî       ,      . <br><br> <b>  ,   boost::asio::io_context!</b> <br> ‚Ä¶    n  (, -),    . <br><br>  : <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">     </a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">    stackoverflow ,        </a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">   ,      </a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">         </a> <br><br><h2>  Conclusion </h2><br> ,        ¬´¬ª. <br><br>         ,       . <br><br>        std::thread    ‚Äî          . <br><br>      ,   . <br><br>     event-driven,        (polling-based). <br><br>     . <br><br> ,  <b></b>           .       std::enable_shared_from_this,       (       ‚Äî       ). ,        :            -    . <br><br>           ,    SteppingZomby.       ‚Äî          shared_from_this (  ,   ,       ‚Äî   1  6  ). <br><br>           ‚Äî     ,  .   . <br><br>  ,   ,  .        std::enable_shared_from_this ‚Äî  <b></b> . <br><br> PS:    ‚Äî        . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr471326/">https://habr.com/ru/post/fr471326/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr471310/index.html">Mon opinion tr√®s subjective sur la formation professionnelle et pas seulement en informatique</a></li>
<li><a href="../fr471312/index.html">Pr√©paration √† la certification professionnelle du printemps. Botte de printemps</a></li>
<li><a href="../fr471318/index.html">Septembre Digest sur l'apprentissage automatique et l'intelligence artificielle</a></li>
<li><a href="../fr471320/index.html">Outils pour les d√©veloppeurs de logiciels: framework ouvert et biblioth√®ques d'apprentissage automatique</a></li>
<li><a href="../fr471324/index.html">Les r√©seaux de neurones r√™vent-ils de la Joconde?</a></li>
<li><a href="../fr471330/index.html">Histoires de l'ordinateur lunaire. 2e partie</a></li>
<li><a href="../fr471332/index.html">Histoires de l'ordinateur lunaire. 3e partie</a></li>
<li><a href="../fr471334/index.html">Pour m√©moriser, mais pas pour entasser - apprendre ¬´par cartes¬ª</a></li>
<li><a href="../fr471336/index.html">Holivar. Histoire de Runet. Partie 6. Serrures: Lurk, Tape, 282nd et Chinese path</a></li>
<li><a href="../fr471340/index.html">Drimsim vs Mate 20 Pro Round! Mais pour qui?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>