<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîá üë®üèø‚Äçü§ù‚Äçüë®üèΩ üëéüèæ MVCC-3. Vers√µes de linha üë®üèø‚Äçüöí üë©üèæ‚Äçüíª ‚è±Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ent√£o, analisamos quest√µes relacionadas ao isolamento e fizemos uma digress√£o sobre a organiza√ß√£o de dados em um n√≠vel baixo . E finalmente chegou ao ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>MVCC-3. Vers√µes de linha</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/postgrespro/blog/445820/">  Ent√£o, analisamos quest√µes relacionadas ao <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">isolamento</a> e fizemos uma digress√£o sobre a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">organiza√ß√£o de dados em um n√≠vel baixo</a> .  E finalmente chegou ao mais interessante - √† vers√£o das linhas. <br><br><h1>  Manchete </h1><br>  Como j√° dissemos, cada linha pode estar presente simultaneamente no banco de dados em v√°rias vers√µes.  Uma vers√£o deve ser distinguida da outra de alguma forma.Para esse efeito, cada vers√£o possui duas marcas que determinam o "tempo" da a√ß√£o desta vers√£o (xmin e xmax).  Entre aspas - porque n√£o √© o tempo usado como tal, mas um contador incremental especial.  E esse contador √© o n√∫mero da transa√ß√£o. <br><br>  (Como sempre, √© realmente mais complicado: o n√∫mero da transa√ß√£o n√£o pode aumentar o tempo todo devido √† capacidade limitada de bits do contador. Mas consideraremos esses detalhes em detalhes quando chegarmos ao congelamento.) <br><a name="habracut"></a><br>  Quando a linha √© criada, xmin √© definido como o n√∫mero da transa√ß√£o que executou o comando INSERT e xmax n√£o √© preenchido. <br><br>  Quando uma linha √© exclu√≠da, o valor xmax da vers√£o atual √© marcado com o n√∫mero da transa√ß√£o que executou DELETE. <br><br>  Quando uma linha √© modificada com o comando UPDATE, duas opera√ß√µes s√£o realmente executadas: DELETE e INSERT.  Na vers√£o atual da linha, xmax √© definido igual ao n√∫mero da transa√ß√£o que executou UPDATE.  Em seguida, uma nova vers√£o da mesma linha √© criada;  seu valor xmin corresponde ao valor xmax da vers√£o anterior. <br><br>  Os campos xmin e xmax est√£o inclu√≠dos no cabe√ßalho da vers√£o da linha.  Al√©m desses campos, o cabe√ßalho cont√©m outros, por exemplo: <br><br><ul><li>  infomask - uma s√©rie de bits que definem as propriedades desta vers√£o.  Existem muitos deles;  os principais que consideraremos gradualmente. </li><li>  ctid - um link para a pr√≥xima vers√£o mais nova da mesma linha.  Na vers√£o mais recente e mais recente da cadeia, ctid refere-se a esta vers√£o.  O n√∫mero tem o formato (x, y), onde x √© o n√∫mero da p√°gina, y √© o n√∫mero de s√©rie do ponteiro na matriz. </li><li>  bitmap de valores indefinidos - marca as colunas desta vers√£o que cont√™m um valor indefinido (NULL).  NULL n√£o √© um dos valores usuais dos tipos de dados, portanto, o atributo deve ser armazenado separadamente. </li></ul><br>  Como resultado, o cabe√ßalho √© bastante grande - pelo menos 23 bytes por vers√£o da string e, geralmente, mais devido ao bitmap NULL.  Se a tabela for "estreita" (ou seja, cont√©m poucas colunas), a sobrecarga poder√° levar mais do que informa√ß√µes √∫teis. <br><br><h1>  Inserir </h1><br>  Vamos dar uma olhada em como as opera√ß√µes de string s√£o executadas em um n√≠vel baixo e come√ßar com a inser√ß√£o. <br><br>  Para experimentos, crie uma nova tabela com duas colunas e um √≠ndice em uma delas: <br><br><pre><code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> t( id <span class="hljs-type"><span class="hljs-type">serial</span></span>, s <span class="hljs-type"><span class="hljs-type">text</span></span> ); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INDEX</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> t(s);</code> </pre> <br>  Insira uma linha, depois de iniciar a transa√ß√£o. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'FOO'</span></span>);</code> </pre><br>  Aqui est√° o n√∫mero da nossa transa√ß√£o atual: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3664 (1 row)</code> </pre><br>  D√™ uma olhada no conte√∫do da p√°gina.  A fun√ß√£o heap_page_items da extens√£o pageinspect fornece informa√ß√µes sobre ponteiros e vers√µes de linha: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]------------------- lp | 1 lp_off | 8160 lp_flags | 1 lp_len | 32 t_xmin | 3664 t_xmax | 0 t_field3 | 0 t_ctid | (0,1) t_infomask2 | 2 t_infomask | 2050 t_hoff | 24 t_bits | t_oid | t_data | \x0100000009464f4f</code> </pre><br>  Observe que a palavra heap (heap) no PostgreSQL se refere a tabelas.  Esse √© outro uso estranho do termo - heap √© uma <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">estrutura de dados</a> conhecida que n√£o tem nada a ver com uma tabela.  Aqui, essa palavra √© usada no sentido de "tudo √© empilhado", em contraste com os √≠ndices ordenados. <br><br>  A fun√ß√£o exibe os dados "como est√£o" em um formato dif√≠cil de ler.  Para entender, deixaremos apenas uma parte da informa√ß√£o e a descriptografaremos: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-string"><span class="hljs-string">'(0,'</span></span>||lp||<span class="hljs-string"><span class="hljs-string">')'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> ctid, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> lp_flags <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'unused'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'normal'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'redirect to '</span></span>||lp_off <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> <span class="hljs-string"><span class="hljs-string">'dead'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> state, t_xmin <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> xmin, t_xmax <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> xmax, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">256</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmin_commited, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">512</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmin_aborted, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">1024</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmax_commited, (t_infomask &amp; <span class="hljs-number"><span class="hljs-number">2048</span></span>) &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> xmax_aborted, t_ctid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page_items(get_raw_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>)) \gx</code> </pre><pre> <code class="plaintext hljs">-[ RECORD 1 ]-+------- ctid | (0,1) state | normal xmin | 3664 xmax | 0 xmin_commited | f xmin_aborted | f xmax_commited | f xmax_aborted | t t_ctid | (0,1)</code> </pre><br>  Aqui est√° o que fizemos: <br><br><ul><li>  Adicionamos um zero ao n√∫mero do √≠ndice para traz√™-lo da mesma forma que t_ctid: (n√∫mero da p√°gina, n√∫mero do √≠ndice). </li><li>  Descriptografou o estado do ponteiro lp_flags.  Aqui est√° "normal" - isso significa que o ponteiro realmente se refere √† vers√£o da string.  Outros valores ser√£o considerados posteriormente. </li><li>  De todos os bits de informa√ß√£o, at√© agora apenas dois pares foram alocados.  Os bits xmin_committed e xmin_aborted indicam se a transa√ß√£o com o n√∫mero xmin est√° confirmada (cancelada).  Dois bits semelhantes se referem ao n√∫mero de transa√ß√£o xmax. </li></ul><br>  O que n√≥s vemos?  Quando voc√™ insere uma linha na p√°gina da tabela, um ponteiro aparece com o n√∫mero 1, referindo-se √† primeira e √∫nica vers√£o da linha. <br><br>  Na vers√£o da linha, o campo xmin √© preenchido com o n√∫mero da transa√ß√£o atual.  A transa√ß√£o ainda est√° ativa, portanto, os bits xmin_committed e xmin_aborted n√£o est√£o definidos. <br><br>  O campo ctid da vers√£o da linha se refere √† mesma linha.  Isso significa que n√£o existe uma vers√£o mais recente. <br><br>  O campo xmax √© preenchido com um n√∫mero fict√≠cio 0, porque esta vers√£o da linha n√£o √© exclu√≠da e √© relevante.  As transa√ß√µes n√£o prestar√£o aten√ß√£o a esse n√∫mero, porque o bit xmax_aborted est√° definido. <br><br>  Vamos dar mais um passo para melhorar a legibilidade adicionando bits de informa√ß√£o aos n√∫meros das transa√ß√µes.  E criaremos uma fun√ß√£o, pois precisaremos da solicita√ß√£o mais de uma vez: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> heap_page(relname <span class="hljs-type"><span class="hljs-type">text</span></span>, pageno <span class="hljs-type"><span class="hljs-type">integer</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span>(ctid tid, state <span class="hljs-type"><span class="hljs-type">text</span></span>, xmin <span class="hljs-type"><span class="hljs-type">text</span></span>, xmax <span class="hljs-type"><span class="hljs-type">text</span></span>, t_ctid tid) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $$<span class="pgsql"><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">SELECT</span></span></span><span class="pgsql"> (pageno,lp)::</span><span class="hljs-type"><span class="pgsql"><span class="hljs-type">text</span></span></span><span class="pgsql">::tid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> ctid, </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> lp_flags </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'unused'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'normal'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'redirect to '</span></span></span><span class="pgsql">||lp_off </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">3</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">'dead'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> state, t_xmin || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">256</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">512</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmin, t_xmax || </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">CASE</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">1024</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (c)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">WHEN</span></span></span><span class="pgsql"> (t_infomask &amp; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">2048</span></span></span><span class="pgsql">) &gt; </span><span class="hljs-number"><span class="pgsql"><span class="hljs-number">0</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">THEN</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">' (a)'</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ELSE</span></span></span><span class="pgsql"> </span><span class="hljs-string"><span class="pgsql"><span class="hljs-string">''</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">END</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">AS</span></span></span><span class="pgsql"> xmax, t_ctid </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">FROM</span></span></span><span class="pgsql"> heap_page_items(get_raw_page(relname,pageno)) </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">ORDER</span></span></span><span class="pgsql"> </span><span class="hljs-keyword"><span class="pgsql"><span class="hljs-keyword">BY</span></span></span><span class="pgsql"> lp; $$</span><span class="undefined"></span></span><span class="pgsql"><span class="undefined"></span></span> <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SQL</span></span>;</code> </pre><br>  Nesta forma, √© muito mais claro o que est√° acontecendo no cabe√ßalho da vers√£o da string: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3664 | 0 (a) | (0,1) (1 row)</code> </pre><br>  Informa√ß√µes semelhantes, mas substancialmente menos detalhadas, podem ser obtidas da pr√≥pria tabela, usando as pseudo-colunas xmin e xmax: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3664 | 0 | 1 | FOO (1 row)</code> </pre><br><h1>  Fixa√ß√£o </h1><br>  Ap√≥s a conclus√£o bem-sucedida da transa√ß√£o, voc√™ precisa se lembrar de seu status - observe que ela foi corrigida.  Para fazer isso, use uma estrutura chamada XACT (e antes da vers√£o 10 era CLOG (commit log) e esse nome ainda pode ser encontrado em locais diferentes). <br><br>  XACT n√£o √© uma tabela de cat√°logo do sistema;  Esses s√£o os arquivos no diret√≥rio PGDATA / pg_xact.  Neles, para cada transa√ß√£o, dois bits s√£o alocados: confirmados e abortados - exatamente o mesmo que no cabe√ßalho da vers√£o da linha.  Essas informa√ß√µes s√£o divididas em v√°rios arquivos apenas por conveni√™ncia. Voltaremos a esse problema quando considerarmos o congelamento.  E o trabalho com esses arquivos √© realizado p√°gina por p√°gina, como em todos os outros. <br><br>  Portanto, ao confirmar uma transa√ß√£o no XACT, o bit confirmado √© definido para esta transa√ß√£o.  E isso √© tudo o que acontece durante o commit (embora ainda n√£o falemos sobre o di√°rio de pr√©-registro). <br><br>  Quando qualquer outra transa√ß√£o acessa a p√°gina da tabela que acabamos de ver, ela ter√° que responder algumas perguntas. <br><br><ol><li>  A transa√ß√£o xmin foi conclu√≠da?  Caso contr√°rio, a vers√£o gerada da sequ√™ncia n√£o dever√° estar vis√≠vel. <br>  Essa verifica√ß√£o √© realizada olhando para outra estrutura, que est√° localizada na mem√≥ria compartilhada da inst√¢ncia e √© chamada ProcArray.  Ele cont√©m uma lista de todos os processos ativos e para cada um √© indicado o n√∫mero de sua transa√ß√£o atual (ativa). </li><li>  Se conclu√≠do, como - por fixa√ß√£o ou cancelamento?  Se cancelada, a vers√£o da sequ√™ncia tamb√©m n√£o dever√° estar vis√≠vel. <br>  √â exatamente para isso que serve o XACT.  Por√©m, embora as √∫ltimas p√°ginas XACT sejam armazenadas em buffers na RAM, n√£o √© necess√°rio verificar o XACT a cada vez.  Portanto, o status de uma transa√ß√£o, uma vez esclarecido, √© registrado nos bits xmin_committed e xmin_aborted da vers√£o da linha.  Se um desses bits for definido, o estado da transa√ß√£o xmin ser√° considerado conhecido e a pr√≥xima transa√ß√£o n√£o precisar√° mais acessar o XACT. </li></ol><br>  Por que esses bits n√£o s√£o definidos pela pr√≥pria transa√ß√£o que realiza a inser√ß√£o?  Quando uma inser√ß√£o ocorre, a transa√ß√£o ainda n√£o sabe se ser√° conclu√≠da com √™xito.  E, no momento da corre√ß√£o, j√° n√£o est√° claro quais linhas em que p√°ginas foram alteradas.  Pode haver muitas p√°ginas desse tipo, e memoriz√°-las √© uma desvantagem.  Al√©m disso, parte das p√°ginas pode ser enviada do cache do buffer para o disco;  l√™-los novamente para alterar os bits significaria uma desacelera√ß√£o significativa do commit. <br><br>  A desvantagem da economia √© que, ap√≥s as altera√ß√µes, qualquer transa√ß√£o (mesmo executando uma simples leitura - SELECT) pode come√ßar a alterar as p√°ginas de dados no cache do buffer. <br><br>  Ent√£o, conserte a mudan√ßa. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  Nada mudou na p√°gina (mas sabemos que o status da transa√ß√£o j√° est√° registrado no XACT): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3664 | 0 (a) | (0,1) (1 row)</code> </pre><br>  Agora a transa√ß√£o que acessa primeiro a p√°gina ter√° que determinar o status da transa√ß√£o xmin e grav√°-la nos bits de informa√ß√£o: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3664 (c) | 0 (a) | (0,1) (1 row)</code> </pre><br><h1>  Excluir </h1><br>  Quando uma linha √© exclu√≠da, o n√∫mero da transa√ß√£o de exclus√£o atual √© registrado no campo xmax da vers√£o atual e o bit xmax_aborted √© redefinido. <br><br>  Observe que o valor xmax definido correspondente √† transa√ß√£o ativa atua como um bloqueio de linha.  Se outra transa√ß√£o estiver prestes a atualizar ou excluir esta linha, ela ser√° for√ßada a aguardar a conclus√£o da transa√ß√£o xmax.  Falaremos mais sobre bloqueios mais tarde.  Por enquanto, apenas observamos que o n√∫mero de bloqueios de linha √© ilimitado.  Eles n√£o ocupam um lugar na RAM e o desempenho do sistema n√£o sofre com a quantidade.  √â verdade que transa√ß√µes ‚Äúlongas‚Äù t√™m outras desvantagens, mas mais sobre isso mais tarde. <br><br>  Exclua a linha. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">DELETE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3665 (1 row)</code> </pre><br>  Vemos que o n√∫mero da transa√ß√£o √© registrado no campo xmax, mas os bits de informa√ß√£o n√£o est√£o definidos: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+------+-------- (0,1) | normal | 3664 (c) | 3665 | (0,1) (1 row)</code> </pre><br><h1>  Cancelar </h1><br>  A revers√£o de altera√ß√µes funciona de maneira semelhante √† confirma√ß√£o, apenas no XACT para a transa√ß√£o que o bit anulado est√° definido.  O cancelamento √© t√£o r√°pido quanto confirmar.  Embora o comando seja chamado ROLLBACK, a altera√ß√£o n√£o √© revertida: tudo o que a transa√ß√£o conseguiu alterar nas p√°ginas de dados permanece inalterado. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+------+-------- (0,1) | normal | 3664 (c) | 3665 | (0,1) (1 row)</code> </pre><br>  Ao acessar a p√°gina, o status ser√° verificado e o bit de dica xmax_aborted ser√° definido na vers√£o da linha.  O pr√≥prio n√∫mero xmax permanece na p√°gina, mas ningu√©m o ver√°. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+----------+-------- (0,1) | normal | 3664 (c) | 3665 (a) | (0,1) (1 row)</code> </pre><br><h1>  Update </h1><br>  A atualiza√ß√£o funciona como se estivesse primeiro excluindo a vers√£o atual da linha e depois inserindo uma nova. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = <span class="hljs-string"><span class="hljs-string">'BAR'</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3666 (1 row)</code> </pre><br>  A solicita√ß√£o produz uma linha (nova vers√£o): <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 1 | BAR (1 row)</code> </pre><br>  Mas na p√°gina vemos as duas vers√µes: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3664 (c) | 3666 | (0,2) (0,2) | normal | 3666 | 0 (a) | (0,2) (2 rows)</code> </pre><br>  A vers√£o remota √© marcada com o n√∫mero da transa√ß√£o atual no campo xmax.  Al√©m disso, esse valor √© substitu√≠do pelo antigo, pois a transa√ß√£o anterior foi cancelada.  E o bit xmax_aborted √© redefinido, porque o status da transa√ß√£o atual ainda √© desconhecido. <br><br>  A primeira vers√£o da linha agora se refere √† segunda (campo t_ctid), como uma mais recente. <br><br>  Um segundo ponteiro e uma segunda linha aparecem na p√°gina de √≠ndice, vinculados √† segunda vers√£o na p√°gina da tabela. <br><br>  Como na exclus√£o, o valor xmax na primeira vers√£o da sequ√™ncia √© um sinal de que a sequ√™ncia est√° bloqueada. <br><br>  Bem, complete a transa√ß√£o. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1>  √çndices </h1><br>  At√© agora, falamos apenas de p√°ginas tabulares.  E o que acontece dentro dos √≠ndices? <br><br>  As informa√ß√µes nas p√°ginas de √≠ndice s√£o altamente dependentes do tipo espec√≠fico de √≠ndice.  E mesmo um tipo de √≠ndice possui diferentes tipos de p√°ginas.  Por exemplo, a √°rvore B possui uma p√°gina com metadados e p√°ginas "regulares". <br><br>  No entanto, uma p√°gina geralmente possui uma matriz de ponteiros para as linhas e as pr√≥prias linhas (como em uma p√°gina da tabela).  Al√©m disso, no final da p√°gina, h√° um local para dados especiais. <br><br>  Linhas em √≠ndices tamb√©m podem ter uma estrutura muito diferente, dependendo do tipo de √≠ndice.  Por exemplo, para uma √°rvore B, as linhas relacionadas √†s p√°ginas folha cont√™m o valor da chave de √≠ndice e um link (ctid) para a linha correspondente da tabela.  Em geral, um √≠ndice pode ser organizado de uma maneira completamente diferente. <br><br>  O ponto mais importante √© que n√£o h√° vers√µes de linha em nenhum tipo de √≠ndice.  Bem, ou podemos assumir que cada linha √© representada por exatamente uma vers√£o.  Em outras palavras, n√£o h√° campos xmin e xmax no cabe√ßalho da linha do √≠ndice.  Podemos assumir que os links do √≠ndice levam a todas as vers√µes tabulares das linhas - portanto, voc√™ s√≥ pode descobrir qual vers√£o a transa√ß√£o ver√° se olhar para a tabela.  (Como sempre, essa n√£o √© a verdade. Em alguns casos, o mapa de visibilidade permite otimizar o processo, mas consideraremos isso com mais detalhes posteriormente.) <br><br>  Ao mesmo tempo, na p√°gina de √≠ndice, encontramos indicadores para as duas vers√µes, a atual e a antiga: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> itemoffset, ctid <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> bt_page_items(<span class="hljs-string"><span class="hljs-string">'t_s_idx'</span></span>,<span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre><pre> <code class="plaintext hljs"> itemoffset | ctid ------------+------- 1 | (0,2) 2 | (0,1) (2 rows)</code> </pre><br><h1>  Transa√ß√µes virtuais </h1><br>  Na pr√°tica, o PostgreSQL usa otimiza√ß√µes para "salvar" os n√∫meros das transa√ß√µes. <br><br>  Se uma transa√ß√£o ler apenas dados, ela n√£o afetar√° a visibilidade das vers√µes de linha.  Portanto, a princ√≠pio, o processo de veicula√ß√£o emite uma transa√ß√£o de n√∫mero virtual (xid virtual).  O n√∫mero consiste em um identificador de processo e um n√∫mero seq√ºencial. <br><br>  A emiss√£o desse n√∫mero n√£o requer sincroniza√ß√£o entre todos os processos e, portanto, √© muito r√°pida.  Conheceremos outro motivo para usar n√∫meros virtuais quando falamos de congelamento. <br><br>  Os n√∫meros virtuais n√£o s√£o levados em considera√ß√£o nos instant√¢neos de dados. <br><br>  Em momentos diferentes, transa√ß√µes virtuais com n√∫meros que j√° foram usados ‚Äã‚Äãpodem aparecer no sistema, o que √© normal.  Mas esse n√∫mero n√£o pode ser gravado nas p√°ginas de dados, porque na pr√≥xima vez que voc√™ acessa a p√°gina, pode perder todo o significado. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_if_assigned();</code> </pre><pre> <code class="plaintext hljs"> txid_current_if_assigned -------------------------- (1 row)</code> </pre><br>  Se a transa√ß√£o come√ßar a alterar dados, receber√° um n√∫mero de transa√ß√£o real e exclusivo. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> accounts <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> amount = amount - <span class="hljs-number"><span class="hljs-number">1.00</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current_if_assigned();</code> </pre><pre> <code class="plaintext hljs"> txid_current_if_assigned -------------------------- 3667 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br><h1>  Transa√ß√µes aninhadas </h1><br><h2>  Economize pontos </h2><br>  O SQL define pontos de salvamento que permitem desfazer uma parte de uma transa√ß√£o sem interromp√™-la completamente.  Mas isso n√£o se enquadra no esquema acima, pois o status de uma transa√ß√£o √© √∫nico para todas as suas altera√ß√µes e, fisicamente, nenhum dado √© revertido. <br><br>  Para implementar essa funcionalidade, uma transa√ß√£o com um ponto de salvamento √© dividida em v√°rias <em>transa√ß√µes aninhadas</em> separadas (subtransa√ß√£o), cujo status pode ser controlado separadamente. <br><br>  As transa√ß√µes aninhadas t√™m seu pr√≥prio n√∫mero (maior que o n√∫mero da transa√ß√£o principal).  O status das transa√ß√µes aninhadas √© registrado da maneira usual no XACT, no entanto, o status final depende do status da transa√ß√£o principal: se for cancelada, todas as transa√ß√µes aninhadas tamb√©m ser√£o canceladas. <br><br>  As informa√ß√µes sobre o aninhamento de transa√ß√µes s√£o armazenadas em arquivos no diret√≥rio PGDATA / pg_subtrans.  Os arquivos s√£o acessados ‚Äã‚Äãatrav√©s de buffers na mem√≥ria compartilhada da inst√¢ncia, organizados da mesma maneira que os buffers XACT. <br><br>  N√£o confunda transa√ß√µes aninhadas e transa√ß√µes aut√¥nomas.  As transa√ß√µes aut√¥nomas n√£o dependem uma da outra e as aninhadas s√£o dependentes.  N√£o h√° transa√ß√µes aut√¥nomas no PostgreSQL usual e, talvez, para melhor: no caso de serem necess√°rias muito, muito raramente, e sua presen√ßa em outros DBMSs provoca abuso, do qual todos sofrem. <br><br>  Limpe a tabela, inicie a transa√ß√£o e insira a linha: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">TRUNCATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> t; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'FOO'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3669 (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO (1 row)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (1 row)</code> </pre><br>  Agora coloque um ponto de salvamento e insira outra linha. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SAVEPOINT</span></span> sp; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'XYZ'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> txid_current();</code> </pre><pre> <code class="plaintext hljs"> txid_current -------------- 3669 (1 row)</code> </pre><br>  Observe que a fun√ß√£o txid_current () retorna o n√∫mero da transa√ß√£o principal, n√£o aninhada. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3670 | 0 | 3 | XYZ (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (0,2) | normal | 3670 | 0 (a) | (0,2) (2 rows)</code> </pre><br>  Revertemos para o ponto de salvamento e inserimos a terceira linha. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">ROLLBACK</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TO</span></span> sp; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">INSERT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> t(s) <span class="hljs-keyword"><span class="hljs-keyword">VALUES</span></span> (<span class="hljs-string"><span class="hljs-string">'BAR'</span></span>); =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3671 | 0 | 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 | 0 (a) | (0,1) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 | 0 (a) | (0,3) (3 rows)</code> </pre><br>  Na p√°gina, continuamos a ver a linha adicionada pela transa√ß√£o aninhada cancelada. <br><br>  Corrigimos as altera√ß√µes. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> xmin, xmax, * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> xmin | xmax | id | s ------+------+----+----- 3669 | 0 | 2 | FOO 3671 | 0 | 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 (c) | 0 (a) | (0,1) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 (c) | 0 (a) | (0,3) (3 rows)</code> </pre><br>  Agora voc√™ pode ver claramente que cada transa√ß√£o aninhada tem seu pr√≥prio status. <br><br>  Observe que as transa√ß√µes aninhadas n√£o podem ser usadas explicitamente no SQL, ou seja, voc√™ n√£o pode iniciar uma nova transa√ß√£o sem concluir a atual.  Esse mecanismo √© usado implicitamente ao usar pontos de salvamento e tamb√©m ao lidar com exce√ß√µes do PL / pgSQL e em v√°rios outros casos mais ex√≥ticos. <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>;</code> </pre><pre> <code class="plaintext hljs">BEGIN</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>;</code> </pre><pre> <code class="plaintext hljs">WARNING: there is already a transaction in progress BEGIN</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">COMMIT</code> </pre><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">WARNING: there is no transaction in progress COMMIT</code> </pre><br><h2>  Erros e atomicidade das opera√ß√µes </h2><br>  O que acontece se ocorrer um erro durante a opera√ß√£o?  Por exemplo, assim: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = repeat(<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>/(id<span class="hljs-number"><span class="hljs-number">-4</span></span>));</code> </pre><pre> <code class="plaintext hljs">ERROR: division by zero</code> </pre><br>  Ocorreu um erro.  Agora a transa√ß√£o √© considerada abortada e nenhuma opera√ß√£o √© permitida nela: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs">ERROR: current transaction is aborted, commands ignored until end of transaction block</code> </pre><br>  E mesmo se voc√™ tentar confirmar as altera√ß√µes, o PostgreSQL reportar√° o cancelamento: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><pre> <code class="plaintext hljs">ROLLBACK</code> </pre><br>  Por que n√£o consigo continuar a transa√ß√£o ap√≥s uma falha?  O fato √© que um erro pode ocorrer para que tenhamos acesso a parte das altera√ß√µes - a atomicidade nem mesmo da transa√ß√£o, mas o operador seria violado.  Como no nosso exemplo, onde o operador conseguiu atualizar uma linha antes do erro: <br><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> heap_page(<span class="hljs-string"><span class="hljs-string">'t'</span></span>,<span class="hljs-number"><span class="hljs-number">0</span></span>);</code> </pre><pre> <code class="plaintext hljs"> ctid | state | xmin | xmax | t_ctid -------+--------+----------+-------+-------- (0,1) | normal | 3669 (c) | 3672 | (0,4) (0,2) | normal | 3670 (a) | 0 (a) | (0,2) (0,3) | normal | 3671 (c) | 0 (a) | (0,3) (0,4) | normal | 3672 | 0 (a) | (0,4) (4 rows)</code> </pre><br>  Devo dizer que no psql existe um modo que ainda permite continuar a transa√ß√£o ap√≥s uma falha, como se as a√ß√µes do operador incorreto fossem revertidas. <br><br><pre> <code class="pgsql hljs">=&gt; \<span class="hljs-keyword"><span class="hljs-keyword">set</span></span> ON_ERROR_ROLLBACK <span class="hljs-keyword"><span class="hljs-keyword">on</span></span> =&gt; <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span>; =&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">UPDATE</span></span> t <span class="hljs-keyword"><span class="hljs-keyword">SET</span></span> s = repeat(<span class="hljs-string"><span class="hljs-string">'X'</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>/(id<span class="hljs-number"><span class="hljs-number">-4</span></span>));</code> </pre><pre> <code class="plaintext hljs">ERROR: division by zero</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> t;</code> </pre><pre> <code class="plaintext hljs"> id | s ----+----- 2 | FOO 4 | BAR (2 rows)</code> </pre><br><pre> <code class="pgsql hljs">=&gt; <span class="hljs-keyword"><span class="hljs-keyword">COMMIT</span></span>;</code> </pre><br>  √â f√°cil adivinhar que, nesse modo, o psql realmente define um ponto de salvaguarda impl√≠cito na frente de cada comando e, em caso de falha, inicia uma revers√£o para ele.  Esse modo n√£o √© usado por padr√£o, pois a defini√ß√£o de pontos de salvamento (mesmo sem reverter para eles) est√° associada a uma sobrecarga significativa. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Para ser continuado.</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt445820/">https://habr.com/ru/post/pt445820/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt445804/index.html">Encapsulamento para samurais reais ou as nuances associadas √† palavra-chave interna em C #</a></li>
<li><a href="../pt445806/index.html">Como a intelig√™ncia artificial est√° mudando a ci√™ncia</a></li>
<li><a href="../pt445808/index.html">N√≥s odiamos e ca√ßamos: a vida perigosa de um cracker de v√≠rus que est√° fazendo inimigos poderosos</a></li>
<li><a href="../pt445814/index.html">Como um rob√¥ de entrega mudou os h√°bitos culin√°rios dos estudantes americanos</a></li>
<li><a href="../pt445816/index.html">Como vimos a renderiza√ß√£o do servidor e o que aconteceu</a></li>
<li><a href="../pt445822/index.html">Por que Jaop? Porqu√™ Raquete?</a></li>
<li><a href="../pt445824/index.html">Gera√ß√£o de c√≥digo no Dart. Parte 1. No√ß√µes b√°sicas</a></li>
<li><a href="../pt445826/index.html">Andamos pela cidade com sabedoria - 2: andamos pela cidade em c√≠rculos usando o algoritmo gen√©tico</a></li>
<li><a href="../pt445828/index.html">Espectro solar chin√™s</a></li>
<li><a href="../pt445832/index.html">Radia√ß√£o: o assassino invis√≠vel e suas filhas ou um pouco sobre rad√¥nio</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>