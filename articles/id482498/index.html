<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🎷 🏞️ 😤 Sejarah evolusi antarmuka di Jawa 🧐 👩🏼‍⚕️ 🥤</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Antarmuka di Jawa telah berkembang pesat selama bertahun-tahun. Mari kita lihat perubahan apa yang terjadi dalam proses pengembangannya. 

 Antarmuka ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sejarah evolusi antarmuka di Jawa</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482498/"><img src="https://habrastorage.org/webt/db/rm/ac/dbrmacgcmj4awxvvosnyra8kmmo.png" alt="gambar"><br><br>  Antarmuka di Jawa telah berkembang pesat selama bertahun-tahun.  Mari kita lihat perubahan apa yang terjadi dalam proses pengembangannya. <br><a name="habracut"></a><br><h2>  Antarmuka asli </h2><br>  Antarmuka di Java 1.0 cukup sederhana dibandingkan dengan apa yang ada sekarang.  Mereka hanya dapat berisi dua jenis elemen: konstanta dan metode abstrak publik. <br><br><h3>  Bidang Konstan </h3><br>  Antarmuka dapat berisi bidang, seperti kelas reguler, tetapi dengan beberapa perbedaan: <br><br><ul><li>  Bidang harus diinisialisasi. </li><li>  Bidang dianggap final statis publik </li><li>  Pengubah publik, statis dan final tidak perlu ditentukan secara eksplisit (mereka "diletakkan" secara default) </li></ul><br><pre><code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> MY_CONSTANT = <span class="hljs-number"><span class="hljs-number">9</span></span>; }</code> </pre> <br>  Meskipun ini tidak ditentukan secara eksplisit, bidang MY_CONSTANT dianggap sebagai konstanta akhir statis publik.  Anda dapat menambahkan pengubah ini, tetapi ini tidak perlu. <br><br><h2>  Metode abstrak </h2><br>  Elemen terpenting dari sebuah antarmuka adalah metodenya.  Metode antarmuka juga berbeda dari metode kelas biasa: <br><br><ul><li>  Metode tidak memiliki tubuh </li><li>  Implementasi metode disediakan oleh kelas yang mengimplementasikan antarmuka ini. </li><li>  Metode dianggap publik dan abstrak bahkan jika tidak ditentukan secara eksplisit. </li><li>  Metode tidak bisa final, karena kombinasi pengubah abstrak dan final tidak diizinkan di Jawa </li></ul><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; <span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomethingCompletelyDifferent</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; }</code> </pre><br><h2>  Bersarang </h2><br>  Java 1.1 memperkenalkan konsep kelas yang dapat ditempatkan di dalam kelas lain.  Kelas semacam itu terdiri dari dua jenis: statis dan non-statis.  Antarmuka juga dapat berisi antarmuka dan kelas lainnya. <br><br>  Bahkan jika ini tidak ditentukan secara eksplisit, antarmuka dan kelas tersebut dianggap publik dan statis. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... } interface MyOtherInterface { //... } }</span></span></code> </pre><br><h3>  Enumerasi dan Anotasi </h3><br>  Dua tipe lagi diperkenalkan di Java 5: Enumeration and Annotations.  Mereka juga dapat ditempatkan di dalam antarmuka. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> MyEnum { FOO, BAR; } <span class="hljs-meta"><span class="hljs-meta">@interface</span></span> MyAnnotation { <span class="hljs-comment"><span class="hljs-comment">//... } }</span></span></code> </pre><br><h2>  Jenis Generik </h2><br>  Java 5 memperkenalkan konsep generik, tipe generik.  Singkatnya: generik memungkinkan Anda untuk menggunakan tipe generik alih-alih menentukan tipe tertentu.  Dengan demikian, Anda dapat menulis kode yang berfungsi dengan sejumlah jenis berbeda tanpa mengorbankan keamanan dan tanpa memberikan implementasi yang terpisah untuk masing-masing jenis. <br><br>  Dalam antarmuka yang dimulai pada Java 5, Anda dapat menentukan tipe generik dan kemudian menggunakannya sebagai jenis nilai balik metode atau sebagai tipe argumen ke metode. <br><br>  Antarmuka Box berfungsi baik jika Anda menggunakannya untuk menyimpan objek seperti String, Integer, List, Shoe, atau lainnya. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Box</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">T</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(T item)</span></span></span></span>; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ShoeBox</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Box</span></span></span><span class="hljs-class">&lt;</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Shoe</span></span></span><span class="hljs-class">&gt; </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">insert</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Shoe item)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//... } }</span></span></code> </pre><br><h2>  Metode statis </h2><br>  Dimulai dengan Java 8, Anda dapat memasukkan metode statis di antarmuka.  Pendekatan ini telah mengubah cara antarmuka bekerja untuk kita.  Mereka sekarang bekerja sangat berbeda dari cara mereka bekerja sebelum Java 8. Awalnya, semua metode di antarmuka abstrak.  Ini berarti bahwa antarmuka hanya menyediakan tanda tangan, tetapi bukan implementasi.  Implementasi diserahkan kepada kelas yang mengimplementasikan antarmuka Anda. <br><br>  Saat menggunakan metode statis di antarmuka, Anda juga perlu menyediakan implementasi dari tubuh metode.  Untuk menggunakan metode ini di antarmuka, cukup gunakan kata kunci statis.  Metode statis dianggap publik secara default. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// This works static int foo() { return 0; } // This does not work, // static methods in interfaces need body static int bar(); }</span></span></code> </pre><br><h3>  Warisan Metode Statis </h3><br>  Tidak seperti metode statis biasa, metode statis di antarmuka tidak diwariskan.  Ini berarti bahwa jika Anda ingin memanggil metode seperti itu, Anda harus memanggilnya langsung dari antarmuka, dan bukan dari kelas yang mengimplementasikannya. <br><br><pre> <code class="java hljs">MyInterface.staticMethod();</code> </pre><br>  Perilaku ini sangat berguna untuk menghindari beberapa masalah warisan.  Bayangkan Anda memiliki kelas yang mengimplementasikan dua antarmuka.  Setiap antarmuka memiliki metode statis dengan nama dan tanda tangan yang sama.  Yang mana yang harus digunakan terlebih dahulu? <br><br><h3>  Mengapa ini bermanfaat? </h3><br>  Bayangkan Anda memiliki antarmuka dan serangkaian metode pembantu yang bekerja dengan kelas yang mengimplementasikan antarmuka ini. <br><br>  Secara tradisional, telah ada pendekatan untuk menggunakan kelas pendamping.  Selain antarmuka, kelas utilitas dibuat dengan nama yang sangat mirip yang berisi metode statis milik antarmuka. <br><br>  Anda dapat menemukan contoh menggunakan pendekatan ini secara langsung di JDK: antarmuka java.util.Collection dan kelas utilitas java.util.Collections yang menyertainya. <br><br>  Dengan metode statis di antarmuka, pendekatan ini tidak lagi relevan, tidak diperlukan dan tidak disarankan.  Sekarang Anda dapat memiliki semuanya di satu tempat. <br><br><h2>  Metode standar </h2><br>  Metode default mirip dengan metode statis karena Anda juga harus menyediakan badan untuknya.  Untuk mendeklarasikan metode default, cukup gunakan kata kunci default. <br><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre><br>  Tidak seperti metode statis, metode secara default diwarisi oleh kelas yang mengimplementasikan antarmuka.  Yang penting, kelas-kelas tersebut dapat mendefinisikan kembali perilaku mereka jika perlu. <br><br>  Meski ada satu pengecualian.  Antarmuka tidak dapat memiliki metode default dengan tanda tangan yang sama dengan metode toString, equals, dan hashCode dari kelas Object.  Lihatlah jawaban Brian Goetz untuk memahami validitas solusi semacam itu: <a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2013-March/008435.html">Izinkan metode default untuk mengganti metode Object.</a> <br><br><h3>  Mengapa ini bermanfaat? </h3><br>  Gagasan menerapkan metode langsung di antarmuka sepertinya tidak sepenuhnya benar.  Jadi mengapa fungsi ini pertama kali diperkenalkan? <br><br>  Antarmuka memiliki satu masalah.  Segera setelah Anda memberikan API Anda kepada orang lain, itu akan selamanya "membatu" (tidak dapat diubah tanpa rasa sakit). <br><br>  Secara tradisional, Java menganggap kompatibilitas sangat serius.  Metode default menyediakan cara untuk memperluas antarmuka yang ada dengan metode baru.  Yang paling penting, metode default sudah menyediakan implementasi spesifik.  Ini berarti bahwa kelas yang mengimplementasikan antarmuka Anda tidak perlu menerapkan metode baru.  Tetapi, jika perlu, metode default dapat diganti kapan saja jika implementasinya tidak lagi sesuai.  Jadi, singkatnya, Anda dapat memberikan fungsionalitas baru ke kelas yang ada yang mengimplementasikan antarmuka Anda, sambil mempertahankan kompatibilitas. <br><br><h3>  Konflik </h3><br>  Mari kita bayangkan bahwa kita memiliki kelas yang mengimplementasikan dua antarmuka.  Antarmuka ini memiliki metode default dengan nama dan tanda tangan yang sama. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ }</code> </pre><br>  Sekarang metode default yang sama dengan tanda tangan yang sama diwarisi dari dua antarmuka yang berbeda.  Setiap antarmuka memiliki implementasi metode ini sendiri. <br><br>  Jadi, bagaimana kelas kita tahu yang mana dari dua implementasi yang berbeda untuk digunakan? <br><br>  Dia tidak akan tahu.  Kode di atas akan menghasilkan kesalahan kompilasi.  Jika Anda perlu membuatnya bekerja, maka Anda perlu mengganti metode yang bertentangan di kelas Anda. <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">default</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">doSomething</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">implements</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">A</span></span></span><span class="hljs-class">, </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">B</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Without this the compilation fails @Override public int doSomething() { return 256; } }</span></span></code> </pre><br><h2>  Metode pribadi </h2><br>  Dengan munculnya Java 8 dan pengenalan metode default dan metode statis, antarmuka sekarang memiliki kemampuan untuk mengandung tidak hanya tanda tangan metode, tetapi juga implementasinya.  Saat menulis implementasi seperti itu, disarankan agar metode yang rumit dibagi menjadi yang lebih sederhana.  Kode semacam itu lebih mudah digunakan kembali, dipelihara, dan dipahami. <br><br>  Untuk tujuan ini, Anda akan menggunakan metode pribadi, karena mereka dapat berisi semua detail implementasi yang tidak boleh terlihat dan digunakan dari luar. <br><br>  Sayangnya di Java 8, sebuah antarmuka tidak dapat berisi metode pribadi.  Ini berarti Anda dapat menggunakan: <br><br><ol><li>  Teknik tubuh yang panjang, rumit dan sulit dipahami. </li><li>  Metode pembantu yang merupakan bagian dari antarmuka.  Ini melanggar prinsip enkapsulasi dan mencemari API publik dari kelas antarmuka dan implementasi. </li></ol><br>  Untungnya, mulai di <a href="http://openjdk.java.net/jeps/213">Java 9, Anda dapat menggunakan metode pribadi di antarmuka</a> .  Mereka memiliki fitur-fitur berikut: <br><br><ul><li>  metode pribadi memiliki tubuh, mereka tidak abstrak </li><li>  mereka bisa statis atau non-statis </li><li>  mereka tidak diwarisi oleh kelas yang mengimplementasikan antarmuka dan antarmuka </li><li>  mereka dapat memanggil metode antarmuka lainnya </li><li>  metode pribadi dapat memanggil metode pribadi lainnya, abstrak, statis, atau standar </li><li>  metode statis privat hanya dapat memanggil metode statis statis dan privat lainnya </li></ul><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">interface</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyInterface</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">staticMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">42</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">nonStaticMethod</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>; } }</code> </pre><br><h2>  Urutan kronologis </h2><br>  Berikut ini adalah daftar perubahan menurut versi Java: <br><br><h4>  Java 1.1 </h4><br>  Kelas Bersarang <br><br>  Antarmuka Bersarang <br><br><h4>  Java 5 </h4><br>  Jenis Generik <br><br>  Transfer Tertutup <br><br>  Anotasi bersarang <br><br><h4>  Java 8 </h4><br>  Metode standar <br><br>  Metode statis <br><br><h4>  Jawa 9 </h4><br>  Metode pribadi </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id482498/">https://habr.com/ru/post/id482498/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id482486/index.html">Apa itu Misra dan bagaimana cara memasaknya</a></li>
<li><a href="../id482490/index.html">Apa itu MISRA dan cara memasaknya</a></li>
<li><a href="../id482492/index.html">Emisi pencairan permafrost dan gas rumah kaca</a></li>
<li><a href="../id482494/index.html">Perbarui Hasil Survei</a></li>
<li><a href="../id482496/index.html">Hasil: 9 terobosan teknologi utama tahun 2019</a></li>
<li><a href="../id482500/index.html">Python atau R: Manakah Pilihan Yang Lebih Baik Untuk Ilmu Data?</a></li>
<li><a href="../id482502/index.html">5,8 juta IOPS: mengapa begitu banyak?</a></li>
<li><a href="../id482504/index.html">Posting dengan posting: hasil kami untuk 2019</a></li>
<li><a href="../id482506/index.html">Entri Data dalam STM32F4xx dari Parallel ADC via DCMI</a></li>
<li><a href="../id482508/index.html">2019 tentang Habré dalam angka: ada lebih banyak pos, minus sama, komentar lebih aktif</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>