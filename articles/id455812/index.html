<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤟🏼 🧛🏿 👨‍👩‍👦‍👦 Membangun Arsitektur Layanan Mikro di Golang dan gRPC, Bagian 2 (buruh pelabuhan) 🤵 🍼 👩🏼‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Sudah waktunya untuk menangani wadah 
 Pertama-tama, kami menggunakan gambar Linux Alpine terbaru. Linux Alpine adalah distribusi Linux ringan yang di...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membangun Arsitektur Layanan Mikro di Golang dan gRPC, Bagian 2 (buruh pelabuhan)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/455812/"><h3>  Sudah waktunya untuk menangani wadah </h3><br>  Pertama-tama, kami menggunakan gambar Linux Alpine terbaru.  Linux Alpine adalah distribusi Linux ringan yang dirancang dan dioptimalkan untuk menjalankan aplikasi web di Docker.  Dengan kata lain, Linux Alpine memiliki cukup dependensi dan fungsionalitas untuk menjalankan sebagian besar aplikasi.  Ini berarti ukuran gambar sekitar 8 MB! <br><br>  Dibandingkan dengan, katakanlah ... mesin virtual Ubuntu dengan kapasitas sekitar 1 GB, itu sebabnya gambar Docker menjadi lebih alami untuk layanan microser dan cloud computing. <br><br>  Jadi, sekarang saya berharap Anda melihat nilai dalam kontainerisasi, dan kita bisa mulai "Dockerising" layanan pertama kami.  Ayo buat Dockerfile <b>$ touch consignment-service / Dockerfile</b> . <br><br><img src="https://habrastorage.org/webt/xf/a7/ex/xfa7exynloocyeogmno3p3le27m.jpeg"><br><a name="habracut"></a><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian pertama</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Repositori EwanValentine asli</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Artikel asli</a> <br><br>  Di Dockerfile, tambahkan berikut ini: <br><br><pre><code class="plaintext hljs">FROM alpine:latest RUN mkdir /app WORKDIR /app ADD consignment-service /app/consignment-service CMD ["./consignment-service"]</code> </pre> <br>  Lalu kami membuat direktori baru untuk meng-host aplikasi kami.  Kemudian kami menambahkan biner terkompilasi kami ke wadah Docker kami dan menjalankannya. <br><br>  Sekarang, mari kita perbarui catatan pembuatan Makefile kami untuk membuat gambar Docker. <br><br><pre> <code class="plaintext hljs">build: ... GOOS=linux GOARCH=amd64 go build docker build -t consignment .</code> </pre><br>  Kami menambahkan dua langkah lagi, dan saya ingin menjelaskannya lebih terinci.  Pertama-tama, kami membuat biner Go kami.  Namun, Anda akan melihat dua variabel lingkungan sebelum kami menjalankan $ go build.  GOOS dan GOARCH memungkinkan Anda mengkompilasi silang biner Anda untuk sistem operasi lain.  Karena saya mengembangkan untuk Macbook, saya tidak bisa mengkompilasi go executable dan kemudian menjalankannya dalam wadah Docker yang menggunakan Linux.  Biner akan benar-benar tidak berarti dalam wadah Docker Anda dan itu akan menimbulkan kesalahan. <br><br>  Langkah kedua yang saya tambahkan adalah proses pembangunan buruh pelabuhan.  Docker akan membaca Dockerfile Anda dan membuat gambar bernama layanan-konsinyasi, titik menunjukkan jalur direktori, jadi di sini kami hanya ingin proses build untuk melihat direktori saat ini. <br><br>  Saya akan menambahkan entri baru ke Makefile kami: <br><br><pre> <code class="plaintext hljs">run: docker run -p 50051:50051 shippy-service-consignment</code> </pre><br>  Di sini kami meluncurkan gambar buruh pelabuhan kami dengan membuka port 50051. Karena Docker beroperasi pada lapisan jaringan yang terpisah, Anda perlu mengarahkan ulang port tersebut.  Misalnya, jika Anda ingin memulai layanan ini pada port 8080, Anda harus mengubah argumen -p ke 8080: 50051.  Anda juga dapat menjalankan kontainer di latar belakang dengan menyertakan flag -d.  Misalnya, <b>buruh pelabuhan menjalankan -d -p 50051: 50051-layanan konsinyasi</b> . <br><br>  Jalankan <b>$ make run</b> , lalu di panel terminal yang terpisah lagi <b>$ pergi jalankan main.go</b> dan periksa apakah masih berfungsi. <br><br>  Saat Anda menjalankan $ docker build, Anda menyematkan kode dan runtime di gambar.  Gambar Docker adalah gambar portabel dari lingkungan Anda dan dependensinya.  Anda dapat berbagi gambar Docker dengan mempostingnya ke Docker Hub.  Yang mirip dengan npm atau repositori yum untuk gambar buruh pelabuhan.  Ketika Anda mendefinisikan FROM di Dockerfile Anda, Anda memberi tahu Docker untuk menarik gambar ini dari repositori Docker untuk digunakan sebagai basis.  Anda kemudian dapat memperluas dan mendefinisikan kembali bagian-bagian dari file dasar ini, mendefinisikannya kembali sesuai keinginan.  Kami tidak akan mempublikasikan gambar buruh pelabuhan kami, tetapi merasa bebas untuk menelusuri repositori buruh pelabuhan dan perhatikan bahwa hampir semua perangkat lunak telah dikemas dalam wadah.  Beberapa hal yang benar-benar luar biasa merosot. <br><br>  Setiap iklan di Dockerfile di-cache saat pertama kali dibuat.  Ini menghilangkan kebutuhan untuk membangun kembali seluruh runtime setiap kali Anda membuat perubahan.  Docker cukup pintar untuk mengetahui detail mana yang telah berubah dan mana yang perlu dibangun kembali.  Ini membuat proses pembuatannya sangat cepat. <br><br>  Cukup tentang wadahnya!  Mari kita kembali ke kode kita. <br><br>  Saat membuat layanan gRPC, ada banyak kode standar untuk membuat koneksi, dan Anda perlu melakukan hard-code lokasi alamat layanan di klien atau layanan lain sehingga dapat terhubung ke sana.  Ini sulit karena ketika Anda memulai layanan di cloud, mereka mungkin tidak menggunakan host yang sama, atau alamat atau ip dapat berubah setelah layanan dipekerjakan kembali. <br><br>  Di sinilah layanan penemuan berperan.  Layanan penemuan memperbarui direktori semua layanan Anda dan lokasi mereka.  Setiap layanan terdaftar pada saat runtime dan tidak terdaftar di dekat.  Setiap layanan kemudian diberi nama atau pengenal.  Dengan demikian, bahkan jika itu mungkin memiliki alamat IP baru atau alamat host, asalkan nama layanan tetap sama, Anda tidak perlu memperbarui panggilan ke layanan ini dari layanan lain. <br><br>  Sebagai aturan, ada banyak pendekatan untuk masalah ini, tetapi, seperti kebanyakan hal dalam pemrograman, jika seseorang telah mengatasi masalah ini, tidak masuk akal untuk menemukan kembali roda.  @ Chuhnk (Asim Aslam), pencipta <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Go-micro</a> , memecahkan masalah ini dengan kejelasan yang fantastis dan kemudahan penggunaan.  Dia seorang diri menghasilkan perangkat lunak yang fantastis.  Tolong pertimbangkan untuk membantunya jika Anda menyukai apa yang Anda lihat! <br><br><h3>  Lakukan mikro </h3><br>  Go-micro adalah kerangka kerja layanan mikro yang kuat yang ditulis dalam Go, untuk digunakan, sebagian besar, dengan Go.  Namun, Anda dapat menggunakan Sidecar untuk berinteraksi dengan bahasa lain. <br><br>  Go-micro memiliki fitur yang berguna untuk membuat layanan microser di Go.  Tetapi kita akan mulai dengan mungkin masalah yang paling umum yang dia selesaikan, dan ini adalah penemuan sebuah layanan. <br><br>  Kami perlu membuat beberapa pembaruan untuk layanan kami agar dapat bekerja dengan go-micro.  Go-micro terintegrasi sebagai plugin Protoc, dalam hal ini menggantikan plugin gRPC standar yang saat ini kami gunakan.  Jadi, mari kita mulai dengan mengganti ini di Makefile kita. <br><br>  Pastikan untuk menginstal dependensi go-mikro: <br><br><pre> <code class="plaintext hljs">go get -u github.com/micro/protobuf/{proto,protoc-gen-go}</code> </pre> <br>  Perbarui Makefile kami untuk menggunakan plugin go-micro alih-alih plugin gRPC: <br><br><pre> <code class="plaintext hljs">build: protoc -I. --go_out=plugins=micro:. \ proto/consignment/consignment.proto GOOS=linux GOARCH=amd64 go build docker build -t consignment . run: docker run -p 50051:50051 shippy-service-consignment</code> </pre><br>  Sekarang kita perlu memperbarui shippy-service-consignment / main.go kita untuk menggunakan go-micro.  Ini abstrak sebagian besar kode gRPC kami sebelumnya.  Ini dengan mudah memproses pendaftaran dan mempercepat penulisan layanan. <br><br><div class="spoiler">  <b class="spoiler_title">shippy-service-consignment / main.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// shippy-service-consignment/main.go package main import ( "fmt" //  protobuf  pb "github.com/EwanValentine/shippy/consignment-service/proto/consignment" "github.com/micro/go-micro" "context" ) //repository -   type repository interface { Create(*pb.Consignment) (*pb.Consignment, error) GetAll() []*pb.Consignment } // Repository -    , //       type Repository struct { consignments []*pb.Consignment } func (repo *Repository) Create(consignment *pb.Consignment) (*pb.Consignment, error) { updated := append(repo.consignments, consignment) repo.consignments = updated return consignment, nil } func (repo *Repository) GetAll() []*pb.Consignment { return repo.consignments } //         //       proto. //           . type service struct { repo repository } // CreateConsignment -        , //    create,      //     gRPC. func (s *service) CreateConsignment(ctx context.Context, req *pb.Consignment, res *pb.Response) error { // Save our consignment consignment, err := s.repo.Create(req) if err != nil { return err } // Return matching the `Response` message we created in our // protobuf definition. res.Created = true res.Consignment = consignment return nil } //GetConsignments -         func (s *service) GetConsignments(ctx context.Context, req *pb.GetRequest, res *pb.Response) error { consignments := s.repo.GetAll() res.Consignments = consignments return nil } func main() { repo := &amp;Repository{} //     Go-micro srv := micro.NewService( //           proto micro.Name("shippy.service.consignment"), ) // Init will parse the command line flags. srv.Init() //   pb.RegisterShippingServiceHandler(srv.Server(), &amp;service{repo}) //   log.Println(" ") if err := srv.Run(); err != nil { fmt.Println(err) } }</span></span></code> </pre><br></div></div><br>  Perubahan utama di sini adalah cara kami membuat server gRPC kami, yang telah disarikan dengan rapi dari mico.NewService (), yang menangani pendaftaran layanan kami.  Dan akhirnya, fungsi service.Run (), yang memproses koneksi itu sendiri.  Seperti sebelumnya, kami mendaftarkan implementasi kami, tetapi kali ini dengan metode yang sedikit berbeda. <br><br>  Perubahan terbesar kedua menyangkut metode layanan itu sendiri: argumen dan jenis respons sedikit dimodifikasi untuk menerima baik permintaan dan struktur respons sebagai argumen, dan sekarang hanya mengembalikan kesalahan.  Dalam metode kami, kami mengatur respons yang masuk ke proses mikro. <br><br>  Akhirnya, kami tidak lagi memprogram port.  Go-micro harus dikonfigurasi menggunakan variabel lingkungan atau argumen baris perintah.  Untuk mengatur alamat, gunakan MICRO_SERVER_ADDRESS =: 50051.  Secara default, Micro menggunakan mdns (multicast dns) sebagai broker penemuan layanan untuk penggunaan lokal.  Biasanya Anda tidak menggunakan mdns untuk menemukan layanan di lingkungan produksi, tetapi kami ingin menghindari menjalankan sesuatu seperti Konsul atau etcd secara lokal untuk pengujian.  Lebih lanjut tentang ini nanti. <br><br>  Mari perbarui Makefile kami untuk mencerminkan ini. <br><br><pre> <code class="plaintext hljs">build: protoc -I. --go_out=plugins=micro:. \ proto/consignment/consignment.proto GOOS=linux GOARCH=amd64 go build docker build -t consignment . run: docker run -p 50051:50051 \ -e MICRO_SERVER_ADDRESS=:50051 \ shippy-service-consignment</code> </pre><br>  -e adalah flag variabel lingkungan, memungkinkan Anda untuk mengirimkan variabel lingkungan ke wadah Docker Anda.  Anda harus memiliki bendera untuk setiap variabel, misalnya -e ENV = pementasan -e DB_HOST = localhost, dll. <br><br>  Sekarang, jika Anda menjalankan $ make run, Anda akan memiliki layanan Dockerised dengan penemuan layanan.  Jadi, mari perbarui alat Cli kami untuk menggunakan ini. <br><br><div class="spoiler">  <b class="spoiler_title">konsinyasi-cli</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"encoding/json"</span></span> <span class="hljs-string"><span class="hljs-string">"io/ioutil"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"os"</span></span> <span class="hljs-string"><span class="hljs-string">"context"</span></span> pb <span class="hljs-string"><span class="hljs-string">"github.com/EwanValentine/shippy-service-consignment/proto/consignment"</span></span> micro <span class="hljs-string"><span class="hljs-string">"github.com/micro/go-micro"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( address = <span class="hljs-string"><span class="hljs-string">"localhost:50051"</span></span> defaultFilename = <span class="hljs-string"><span class="hljs-string">"consignment.json"</span></span> ) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">parseFile</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(file </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(*pb.Consignment, error)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> consignment *pb.Consignment data, err := ioutil.ReadFile(file) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> err != <span class="hljs-literal"><span class="hljs-literal">nil</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, err } json.Unmarshal(data, &amp;consignment) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> consignment, err } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { service := micro.NewService(micro.Name(<span class="hljs-string"><span class="hljs-string">"shippy.cli.consignment"</span></span>)) service.Init() client := pb.NewShippingServiceClient(<span class="hljs-string"><span class="hljs-string">"shippy.service.consignment"</span></span>, service.Client()) <span class="hljs-comment"><span class="hljs-comment">// Contact the server and print out its response. file := defaultFilename if len(os.Args) &gt; 1 { file = os.Args[1] } consignment, err := parseFile(file) if err != nil { log.Fatalf("Could not parse file: %v", err) } r, err := client.CreateConsignment(context.Background(), consignment) if err != nil { log.Fatalf("Could not greet: %v", err) } log.Printf("Created: %t", r.Created) getAll, err := client.GetConsignments(context.Background(), &amp;pb.GetRequest{}) if err != nil { log.Fatalf("Could not list consignments: %v", err) } for _, v := range getAll.Consignments { log.Println(v) } }</span></span></code> </pre><br></div></div><br>  Di sini, kami mengimpor perpustakaan go-micro untuk membuat klien dan mengganti kode koneksi yang ada dengan kode klien go-mikro, yang menggunakan izin layanan alih-alih langsung terhubung ke alamat. <br><br>  Namun, jika Anda menjalankan ini, itu tidak akan berhasil.  Ini karena kami sekarang meluncurkan layanan kami di wadah Docker, yang memiliki mdns sendiri, terpisah dari host mdns yang saat ini kami gunakan.  Cara termudah untuk memperbaikinya adalah memastikan bahwa baik layanan dan klien berjalan di dockerland, sehingga keduanya bekerja pada host yang sama dan menggunakan lapisan jaringan yang sama.  Jadi, mari kita buat make konsinyasi-cli / Makefile dan buat beberapa entri. <br><br><pre> <code class="plaintext hljs">build: GOOS=linux GOARCH=amd64 go build docker build -t shippy-cli-consignment . run: docker run shippy-cli-consignment</code> </pre><br>  Seperti sebelumnya, kami ingin membangun biner untuk Linux.  Saat kami meluncurkan gambar buruh pelabuhan kami, kami ingin meneruskan variabel lingkungan untuk memberikan perintah go-micro untuk menggunakan mdns. <br><br>  Sekarang mari kita buat Dockerfile untuk alat CLI kami: <br><br><pre> <code class="plaintext hljs">FROM alpine:latest RUN mkdir -p /app WORKDIR /app ADD consignment.json /app/consignment.json ADD consignment-cli /app/consignment-cli CMD ["./shippy-cli-consignment"]</code> </pre><br>  Ini sangat mirip dengan Dockerfile layanan kami, kecuali bahwa itu juga mengekstrak file data json kami. <br><br>  Sekarang ketika Anda menjalankan $ make run di shippy-cli-cli-consignment Anda, Anda akan melihat Created: true, sama seperti sebelumnya. <br><br>  Sekarang, sepertinya saatnya untuk melihat fitur Docker baru: pembuatan multi-tahap.  Ini memungkinkan kita untuk menggunakan beberapa gambar Docker dalam satu Dockerfile. <br><br>  Ini sangat berguna dalam kasus kami, karena kami dapat menggunakan satu gambar untuk membuat file biner kami dengan semua dependensi yang benar.  Dan kemudian gunakan gambar kedua untuk meluncurkannya.  Mari kita coba ini, saya akan meninggalkan komentar rinci bersama dengan kode: <br><div class="spoiler">  <b class="spoiler_title">layanan konsinyasi / Dockerfile</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"># consignment-service/Dockerfile #     golang,    #     .    `as builder`, #     ,      . FROM golang:alpine as builder RUN apk --no-cache add git #         gopath WORKDIR /app/shippy-service-consignment #       COPY . . RUN go mod download #     ,   #       Alpine. RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o shippy-service-consignment #      FROM, #   Docker        . FROM alpine:latest # ,    -     RUN apk --no-cache add ca-certificates #   ,     . RUN mkdir /app WORKDIR /app #   ,       , #         `builder` #       , #    ,    , #      . ! COPY --from=builder /app/shippy-service-consignment/shippy-service-consignment . #     !        #        # run time . CMD ["./shippy-service-consignment"]</code> </pre><br></div></div><br>  Sekarang saya akan pindah ke file Docker lain dan mengambil pendekatan baru ini.  Oh, dan jangan lupa menghapus $ go build dari Makefiles Anda! <br><br><h3>  Layanan kapal </h3><br>  Mari kita buat layanan kedua.  Kami memiliki layanan (shippy-service-konsignment), yang berkaitan dengan koordinasi batch kontainer dengan kapal, yang paling cocok untuk batch ini.  Untuk mencocokkan batch kami, kami harus mengirim berat dan jumlah kontainer ke layanan kapal baru kami, yang kemudian akan menemukan kapal yang mampu menangani batch ini. <br><br>  Buat direktori baru di root <b>$ mkdir Anda kapal-layanan</b> direktori, sekarang buat subdirektori untuk definisi layanan protobuf baru kami, <b>$ mkdir -p shippy-service-ship / proto / vessel</b> .  Sekarang mari kita buat file protobuf baru, <b>$ touch shippy-service-vessel / proto / vessel / vessel.proto</b> . <br><br>  Karena definisi protobuf memang merupakan inti dari desain perangkat lunak kami, mari kita mulai dengan itu. <br><br><div class="spoiler">  <b class="spoiler_title">kapal / kapal. foto</b> <div class="spoiler_text"><pre> <code class="plaintext hljs">// shippy-service-vessel/proto/vessel/vessel.proto syntax = "proto3"; package vessel; service VesselService { rpc FindAvailable(Specification) returns (Response) {} } message Vessel { string id = 1; int32 capacity = 2; int32 max_weight = 3; string name = 4; bool available = 5; string owner_id = 6; } message Specification { int32 capacity = 1; int32 max_weight = 2; } message Response { Vessel vessel = 1; repeated Vessel vessels = 2; }</code> </pre><br></div></div><br>  Seperti yang Anda lihat, ini sangat mirip dengan layanan pertama kami.  Kami membuat layanan dengan satu metode rpc yang disebut FindAvailable.  Ini mengambil jenis Spesifikasi dan mengembalikan jenis Respons.  Jenis Respon mengembalikan jenis Kapal atau beberapa kapal menggunakan bidang berulang. <br><br>  Sekarang kita perlu membuat Makefile untuk menangani logika build dan skrip startup kita.  <b>$ touch shippy-service-vessel / Makefile</b> .  Buka file ini dan tambahkan yang berikut: <br><br><pre> <code class="plaintext hljs">// vessel-service/Makefile build: protoc -I. --go_out=plugins=micro:. \ proto/vessel/vessel.proto docker build -t shippy-service-vessel . run: docker run -p 50052:50051 -e MICRO_SERVER_ADDRESS=:50051 shippy-service-vessel</code> </pre><br>  Ini hampir identik dengan Makefile pertama yang kami buat untuk layanan konsinyasi kami, namun perhatikan bahwa nama-nama layanan dan port telah sedikit berubah.  Kami tidak dapat meluncurkan dua wadah dok pada port yang sama, jadi kami menggunakan penerusan port Dockers sehingga layanan ini mengalihkan dari 50051 ke 50052 di jaringan host. <br><br>  Sekarang kita membutuhkan Dockerfile menggunakan format multi-tahap baru: <br><br><pre> <code class="plaintext hljs"># vessel-service/Dockerfile FROM golang:alpine as builder RUN apk --no-cache add git WORKDIR /app/shippy-service-vessel COPY . . RUN go mod download RUN CGO_ENABLED=0 GOOS=linux go build -a -installsuffix cgo -o shippy-service-vessel FROM alpine:latest RUN apk --no-cache add ca-certificates RUN mkdir /app WORKDIR /app COPY --from=builder /app/shippy-service-vessel . CMD ["./shippy-service-vessel"]</code> </pre><br>  Akhirnya, kita dapat menulis implementasi kita: <br><br><div class="spoiler">  <b class="spoiler_title">layanan kapal / main.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">// vessel-service/main.go package main import ( "context" "errors" "fmt" pb "github.com/EwanValentine/shippy/vessel-service/proto/vessel" "github.com/micro/go-micro" ) type Repository interface { FindAvailable(*pb.Specification) (*pb.Vessel, error) } type VesselRepository struct { vessels []*pb.Vessel } // FindAvailable -     , //           , //      . func (repo *VesselRepository) FindAvailable(spec *pb.Specification) (*pb.Vessel, error) { for _, vessel := range repo.vessels { if spec.Capacity &lt;= vessel.Capacity &amp;&amp; spec.MaxWeight &lt;= vessel.MaxWeight { return vessel, nil } } //     return nil, errors.New("     ") } //    grpc type service struct { repo repository } func (s *service) FindAvailable(ctx context.Context, req *pb.Specification, res *pb.Response) error { //     vessel, err := s.repo.FindAvailable(req) if err != nil { return err } //       res.Vessel = vessel return nil } func main() { vessels := []*pb.Vessel{ &amp;pb.Vessel{Id: "vessel001", Name: "Boaty McBoatface", MaxWeight: 200000, Capacity: 500}, } repo := &amp;VesselRepository{vessels} srv := micro.NewService( micro.Name("shippy.service.vessel"), ) srv.Init() //    pb.RegisterVesselServiceHandler(srv.Server(), &amp;service{repo}) if err := srv.Run(); err != nil { fmt.Println(err) } }</span></span></code> </pre><br></div></div><br>  Sekarang mari kita beralih ke bagian yang menarik.  Ketika kami membuat pengiriman, kami perlu mengubah layanan penanganan kargo kami untuk menghubungi layanan pencarian kapal, menemukan kapal dan memperbarui parameter ship_id dalam pengiriman yang dibuat: <br><br><div class="spoiler">  <b class="spoiler_title">shippy / konsinyasi-layanan / main.go</b> <div class="spoiler_text"><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"context"</span></span> <span class="hljs-string"><span class="hljs-string">"fmt"</span></span> <span class="hljs-string"><span class="hljs-string">"log"</span></span> <span class="hljs-string"><span class="hljs-string">"sync"</span></span> pb <span class="hljs-string"><span class="hljs-string">"github.com/EwanValentine/shippy-service-consignment/proto/consignment"</span></span> vesselProto <span class="hljs-string"><span class="hljs-string">"github.com/EwanValentine/shippy-service-vessel/proto/vessel"</span></span> <span class="hljs-string"><span class="hljs-string">"github.com/micro/go-micro"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ( port = <span class="hljs-string"><span class="hljs-string">":50051"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> repository <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Create(*pb.Consignment) (*pb.Consignment, error) GetAll() []*pb.Consignment } <span class="hljs-comment"><span class="hljs-comment">// Repository -    , //       type Repository struct { mu sync.RWMutex consignments []*pb.Consignment } //Create -     func (repo *Repository) Create(consignment *pb.Consignment) (*pb.Consignment, error) { repo.mu.Lock() updated := append(repo.consignments, consignment) repo.consignments = updated repo.mu.Unlock() return consignment, nil } //GetAll -       func (repo *Repository) GetAll() []*pb.Consignment { return repo.consignments } //         //       proto. //            type service struct { repo repository vesselClient vesselProto.VesselServiceClient } // CreateConsignment -         create, //     ,     gRPC. func (s *service) CreateConsignment(ctx context.Context, req *pb.Consignment, res *pb.Response) error { //         , //    vesselResponse, err := s.vesselClient.FindAvailable(context.Background(), &amp;vesselProto.Specification{ MaxWeight: req.Weight, Capacity: int32(len(req.Containers)), }) log.Printf(" : %s \n", vesselResponse.Vessel.Name) if err != nil { return err } //     id  req.VesselId = vesselResponse.Vessel.Id //      consignment, err := s.repo.Create(req) if err != nil { return err } res.Created = true res.Consignment = consignment return nil } // GetConsignments -         func (s *service) GetConsignments(ctx context.Context, req *pb.GetRequest, res *pb.Response) error { consignments := s.repo.GetAll() res.Consignments = consignments return nil } func main() { //   repo := &amp;Repository{} //  micro srv := micro.NewService( micro.Name("shippy.service.consignment"), ) srv.Init() vesselClient := vesselProto.NewVesselServiceClient("shippy.service.vessel", srv.Client()) //      gRPC. pb.RegisterShippingServiceHandler(srv.Server(), &amp;service{repo, vesselClient}) //   if err := srv.Run(); err != nil { fmt.Println(err) } }</span></span></code> </pre><br></div></div><br>  Di sini kami membuat contoh klien untuk layanan kapal kami, yang memungkinkan kami untuk menggunakan nama layanan, yaitu  shipy.service.vessel untuk memanggil layanan kapal sebagai klien dan berinteraksi dengan metodenya.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam hal ini, hanya satu metode (FindAvailable). Kami mengirimkan berat batch bersama dengan jumlah kontainer yang ingin kami kirimkan, sebagai spesifikasi untuk layanan kapal. Yang mengembalikan kami sesuai dengan spesifikasi kapal ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perbarui file konsinyasi-cli / consignment.json, hapus kode_kapal, karena kami ingin mengonfirmasi bahwa layanan pencarian kapal kami berfungsi. Selain itu, mari tambahkan beberapa wadah lagi dan tambah beratnya.</font></font> Sebagai contoh: <br><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"  "</span></span>, <span class="hljs-attr"><span class="hljs-attr">"weight"</span></span>: <span class="hljs-number"><span class="hljs-number">55000</span></span>, <span class="hljs-attr"><span class="hljs-attr">"containers"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"customer_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"user_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"origin"</span></span>: <span class="hljs-string"><span class="hljs-string">"--"</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"customer_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_002"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"user_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"origin"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> }, { <span class="hljs-attr"><span class="hljs-attr">"customer_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_003"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"user_id"</span></span>: <span class="hljs-string"><span class="hljs-string">"_001"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"origin"</span></span>: <span class="hljs-string"><span class="hljs-string">""</span></span> } ] }</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sekarang jalankan </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">$ make build &amp;&amp; make run</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dalam pengiriman-cli. </font><font style="vertical-align: inherit;">Anda harus melihat jawaban dengan daftar barang yang dibuat. </font><font style="vertical-align: inherit;">Di pesta Anda, Anda akan melihat bahwa parameter vessel_id diatur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, kami memiliki dua microservices yang saling berhubungan dan antarmuka baris perintah! </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di bagian selanjutnya dari seri ini, kami akan mempertimbangkan menyimpan beberapa data ini menggunakan MongoDB. </font><font style="vertical-align: inherit;">Kami juga akan menambahkan layanan ketiga dan menggunakan komposisi buruh pelabuhan untuk mengelola ekosistem kontainer kami yang tumbuh secara lokal. </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagian I </font></font></a> <br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repositori EwanValentine Asli</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id455812/">https://habr.com/ru/post/id455812/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id455794/index.html">Pengantar Spring, atau bagaimana jika seluruh proyek adalah @Autowired dan @Component, dan Anda tidak mengerti apa itu</a></li>
<li><a href="../id455796/index.html">Pemrograman Berorientasi Objek di Jawa dan Python: Persamaan dan Perbedaan</a></li>
<li><a href="../id455800/index.html">Matriks 1.0 - Rilis Protokol Pesan Desentralisasi</a></li>
<li><a href="../id455802/index.html">Cara merakit Olimpiade melalui buletin email. Case Black Star</a></li>
<li><a href="../id455806/index.html">Kelahiran dan kematian album: kami memahami bagaimana format musik telah berubah selama 100 tahun terakhir</a></li>
<li><a href="../id455816/index.html">Cara membuat aksi keren untuk Google Assistant. Lifehacks dari Just AI</a></li>
<li><a href="../id455820/index.html">Analisis kinerja VM di VMware vSphere. Bagian 2: Memori</a></li>
<li><a href="../id455826/index.html">Penyiraman Otomatis yang dikendalikan dari jarak jauh</a></li>
<li><a href="../id455828/index.html">Para ilmuwan telah menemukan bentuk sinkronisasi baru yang eksotis</a></li>
<li><a href="../id455830/index.html">Pandangan melalui mata pengembang .NET. Minggu # 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>