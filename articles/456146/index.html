<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤾🏿 🤱🏿 🤱🏿 DevOps en desarrollo: automatización de código de aplicación web 🕴🏾 🛌🏾 🖕🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Buen día, querido Habrazhiteli! 

 Hoy DevOps está en la ola del éxito. En casi cualquier conferencia dedicada a la automatización, puede escuchar al ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>DevOps en desarrollo: automatización de código de aplicación web</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456146/">  Buen día, querido Habrazhiteli! <br><br>  Hoy DevOps está en la ola del éxito.  En casi cualquier conferencia dedicada a la automatización, puede escuchar al orador que dice "implementamos DevOps aquí y allá, aplicamos esto y aquello, se hizo mucho más fácil llevar a cabo proyectos, etc., etc.".  Y es encomiable.  Pero, por regla general, la implementación de DevOps en muchas empresas termina en la etapa de automatización de las operaciones de TI, y muy pocas personas hablan sobre la implementación de DevOps directamente en el proceso de desarrollo. <br><br>  Me gustaría corregir este pequeño malentendido.  DevOps puede entrar en desarrollo a través de la formalización de la base del código, por ejemplo, al escribir una GUI para la API REST. <br><br>  En este artículo, me gustaría compartir con ustedes la solución al caso no estándar que encontró nuestra empresa: pudimos automatizar la formación de la interfaz de la aplicación web.  Te contaré cómo llegamos a esta tarea y qué utilizamos para resolverla.  No creemos que nuestro enfoque sea el único verdadero, pero realmente nos gusta. <br><br>  Espero que este material sea interesante y útil para usted. <br><br>  Bueno, empecemos! <br><a name="habracut"></a><br><h2>  Antecedentes </h2><br>  Esta historia comenzó hace aproximadamente un año: era un hermoso día de verano y nuestro departamento de desarrollo estaba creando la próxima aplicación web.  En la agenda estaba la tarea de introducir una nueva característica en la aplicación: era necesario agregar la capacidad de crear ganchos personalizados. <br><br><img src="https://habrastorage.org/webt/qi/lf/ot/qilfotaamoa_fpuerti3np8chlm.png" alt="El proceso de agregar nuevas características en arquitectura antigua"><br><br>  En ese momento, la arquitectura de nuestra aplicación web se creó de tal manera que para implementar una nueva característica, teníamos que hacer lo siguiente: <br><br><ol><li>  En el back-end: cree un modelo para una nueva entidad (ganchos), describa los campos de este modelo, describa toda la lógica de acciones que el modelo puede realizar, etc. <br></li><li>  En el front-end: cree una clase de presentación que corresponda al nuevo modelo en la API, describa manualmente todos los campos que tiene este modelo, agregue todos los tipos de acciones que puede ejecutar esta vista, etc. <br></li></ol><br>  Resulta que simultáneamente en dos lugares a la vez, era necesario hacer cambios muy similares en el código, de una forma u otra, "duplicando" entre sí.  Y esto, como saben, no es bueno, porque con más cambios, los desarrolladores tendrían que hacer cambios en el mismo lugar en dos lugares al mismo tiempo. <br><br>  Supongamos que necesitamos cambiar el tipo del campo "nombre" de "cadena" a "área de texto".  Para hacer esto, necesitaremos hacer esta enmienda en el código del modelo en el servidor, y luego hacer cambios similares al código de presentación en el cliente. <br><br>  ¿Es muy complicado? <br><br>  Anteriormente, soportábamos este hecho, ya que muchas aplicaciones no eran muy grandes y había un lugar para "duplicar" el código en el servidor y el cliente.  Pero ese mismo día de verano, antes de la introducción de la nueva función, algo hizo clic dentro de nosotros y nos dimos cuenta de que ya no podíamos trabajar así.  El enfoque actual era muy irrazonable y requería mucho tiempo y trabajo.  Además, la "duplicación" de código en el back-end y el front-end podría generar errores inesperados en el futuro: los desarrolladores podrían hacer cambios en el servidor y olvidarse de hacer cambios similares en el cliente, y entonces todo no iría bien De acuerdo al plan. <br><br><h2>  ¿Cómo evitar la duplicación de código?  Busca una solución </h2><br>  Comenzamos a preguntarnos cómo podemos optimizar el proceso de introducción de nuevas características. <br><br>  Nos hicimos la pregunta: "¿Podemos evitar de inmediato la duplicación de cambios en la representación del modelo en el front-end, después de cualquier cambio en su estructura en el back-end?" <br><br>  Pensamos y respondimos: "No, no podemos". <br><br>  Luego nos hicimos otra pregunta: "Bien, ¿cuál es la razón de tal duplicación de código?" <br><br>  Y luego nos dimos cuenta: el problema, de hecho, es que nuestro front-end no recibe datos sobre la estructura API actual.  El front-end no sabe nada sobre los modelos que existen en la API hasta que nosotros mismos lo informemos. <br><br>  Y entonces se nos ocurrió la idea: ¿qué pasaría si construimos la arquitectura de la aplicación de tal manera que: <br><br><ul><li>  El front-end recibido de la API no solo los datos del modelo, sino también la estructura de estos modelos; </li><li>  Representaciones de front-end dinámicamente formadas basadas en la estructura de modelos; </li><li>  Cualquier cambio en la estructura de la API se muestra automáticamente en el front-end. </li></ul><br>  La implementación de una nueva característica llevará mucho menos tiempo, ya que requerirá cambios solo en el lado del back-end, y el front-end recogerá automáticamente todo y lo presentará al usuario correctamente. <br><br><h2>  La versatilidad de la nueva arquitectura. </h2><br>  Y luego, decidimos pensar un poco más ampliamente: ¿la nueva arquitectura es adecuada solo para nuestra aplicación actual, o podemos usarla en otro lugar? <br><br><img src="https://habrastorage.org/webt/og/ay/ju/ogayjuenpbmvwxxlrxpm09banza.png" alt="Características comunes a muchas aplicaciones web"><br><br>  De hecho, de una forma u otra, casi todas las aplicaciones tienen parte de una funcionalidad similar: <br><br><ul><li>  casi todas las aplicaciones tienen usuarios, y en este sentido, es necesario tener una funcionalidad asociada con el registro y la autorización del usuario; </li><li>  Casi todas las aplicaciones tienen varios tipos de vistas: hay una vista para ver una lista de objetos de un modelo, hay una vista para ver un registro detallado de un solo objeto modelo individual; </li><li>  Casi todos los modelos tienen atributos similares en tipo: datos de cadena, números, etc., y en este sentido, debe poder trabajar con ellos tanto en el back-end como en el front-end. </li></ul><br>  Y dado que nuestra compañía a menudo desarrolla aplicaciones web personalizadas, pensamos: ¿por qué necesitamos reinventar la rueda cada vez y desarrollar una funcionalidad similar cada vez desde cero, si podemos escribir un marco una vez que describa todo lo básico, común para muchos aplicaciones, cosas, y luego, creando un nuevo proyecto, use desarrollos listos para usar como dependencias y, si es necesario, cámbielos declarativamente en un nuevo proyecto. <br><br>  Por lo tanto, en el transcurso de una larga discusión, tuvimos la idea de crear VSTUtils, un marco que: <br><br><ol><li>  Contenía la funcionalidad básica, más similar a la mayoría de las aplicaciones; </li><li>  Se permite generar front-end sobre la marcha, en función de la estructura de la API. </li></ol><br><h2>  ¿Cómo hacer amigos back-end y front-end? </h2><br>  Bueno, entonces tenemos que hacer, pensamos.  Ya teníamos un back-end, también un front-end, pero ni el servidor ni el cliente tenían una herramienta que pudiera informar o recibir datos sobre la estructura de la API. <br><br>  En la búsqueda de una solución a este problema, nos fijamos en la especificación <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">OpenAPI</a> , que, según la descripción de los modelos y las relaciones entre ellos, genera un gran JSON que contiene toda esta información. <br><br>  Y pensamos que, en teoría, al inicializar la aplicación en el cliente, el front-end puede recibir este JSON de la API y construir todas las vistas necesarias sobre la base.  Solo queda enseñar a nuestro front-end a hacer todo esto. <br><br>  Y después de un tiempo le enseñamos. <br><br><h2>  Versión 1.0: lo que salió de ella </h2><br>  La arquitectura del marco VSTUtils de las primeras versiones constaba de 3 partes condicionales y se parecía a esto: <br><br><ol><li>  <b>Back end:</b> <br><ul><li>  <u>Django y Python</u> son todos lógicos relacionados con el modelo.  Basado en el modelo base de Django, hemos creado varias clases de modelos principales de VSTUtils.  Todas las acciones que estos modelos pueden realizar las implementamos usando Python; <br></li><li>  <u>Django REST Framework</u> : generación de API REST.  Según la descripción de los modelos, se forma una API REST, gracias a la cual se comunican el servidor y el cliente; <br></li></ul></li><li>  <b>Capa intermedia entre back-end y front-end:</b> <br><ul><li>  <u>OpenAPI</u> - Generación JSON con una descripción de la estructura API.  Una vez que se han descrito todos los modelos en el back-end, se crean vistas para ellos.  Agregar cada una de las vistas introduce la información necesaria en el JSON resultante: <br><div class="spoiler">  <b class="spoiler_title">Ejemplo JSON - Esquema OpenAPI</b> <div class="spoiler_text"><pre><code class="json hljs">{ // ,     (, ), //   -  , //  -     . definitions: { //    Hook. Hook: { // ,     (, ), //   -   , //  -       (,    ..). properties: { id: { title: <span class="hljs-string"><span class="hljs-string">"Id"</span></span>, type: <span class="hljs-string"><span class="hljs-string">"integer"</span></span>, readOnly: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, }, name: { title: <span class="hljs-string"><span class="hljs-string">"Name"</span></span>, type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, minLength:<span class="hljs-number"><span class="hljs-number">1</span></span>, maxLength: <span class="hljs-number"><span class="hljs-number">512</span></span>, }, type: { title: <span class="hljs-string"><span class="hljs-string">"Type"</span></span>, type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, enum: [<span class="hljs-string"><span class="hljs-string">"HTTP"</span></span>,<span class="hljs-string"><span class="hljs-string">"SCRIPT"</span></span>], }, when: { title: <span class="hljs-string"><span class="hljs-string">"When"</span></span>, type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, enum: [<span class="hljs-string"><span class="hljs-string">"on_object_add"</span></span>,<span class="hljs-string"><span class="hljs-string">"on_object_upd"</span></span>,<span class="hljs-string"><span class="hljs-string">"on_object_del"</span></span>], }, enable: { title:<span class="hljs-string"><span class="hljs-string">"Enable"</span></span>, type:<span class="hljs-string"><span class="hljs-string">"boolean"</span></span>, }, recipients: { title: <span class="hljs-string"><span class="hljs-string">"Recipients"</span></span>, type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, minLength: <span class="hljs-number"><span class="hljs-number">1</span></span>, } }, // ,     ,    . required: [<span class="hljs-string"><span class="hljs-string">"type"</span></span>,<span class="hljs-string"><span class="hljs-string">"recipients"</span></span>], } }, // ,     (, ), //   -   ( URL), //  -     . paths: { //      '/hook/'. '/hook/': { //    get    /hook/. //  ,       Hook. get: { operationId: <span class="hljs-string"><span class="hljs-string">"hook_list"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"Return all hooks."</span></span>, // ,       ,     . parameters: [ { name: <span class="hljs-string"><span class="hljs-string">"id"</span></span>, in: <span class="hljs-string"><span class="hljs-string">"query"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"A unique integer value (or comma separated list) identifying this instance."</span></span>, required: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, }, { name: <span class="hljs-string"><span class="hljs-string">"name"</span></span>, in: <span class="hljs-string"><span class="hljs-string">"query"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"A name string value (or comma separated list) of instance."</span></span>, required: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, }, { name: <span class="hljs-string"><span class="hljs-string">"type"</span></span>, in: <span class="hljs-string"><span class="hljs-string">"query"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"Instance type."</span></span>, required: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, type: <span class="hljs-string"><span class="hljs-string">"string"</span></span>, }, ], // ,     (, ), //   -   ; //  -   . responses: { 200: { description: <span class="hljs-string"><span class="hljs-string">"Action accepted."</span></span>, schema: { properties: { results: { type: <span class="hljs-string"><span class="hljs-string">"array"</span></span>, items: { //   ,       . $ref: <span class="hljs-string"><span class="hljs-string">"#/definitions/Hook"</span></span>, }, }, }, }, }, 400: { description: <span class="hljs-string"><span class="hljs-string">"Validation error or some data error."</span></span>, schema: { $ref: <span class="hljs-string"><span class="hljs-string">"#/definitions/Error"</span></span>, }, }, 401: { // ... }, 403: { // ... }, 404: { // ... }, }, tags: [<span class="hljs-string"><span class="hljs-string">"hook"</span></span>], }, //    post    /hook/. //  ,       Hook. post: { operationId: <span class="hljs-string"><span class="hljs-string">"hook_add"</span></span>, description: <span class="hljs-string"><span class="hljs-string">"Create a new hook."</span></span>, parameters: [ { name: <span class="hljs-string"><span class="hljs-string">"data"</span></span>, in: <span class="hljs-string"><span class="hljs-string">"body"</span></span>, required: <span class="hljs-literal"><span class="hljs-literal">true</span></span>, schema: { $ref: <span class="hljs-string"><span class="hljs-string">"#/definitions/Hook"</span></span>, }, }, ], responses: { 201: { description: <span class="hljs-string"><span class="hljs-string">"Action accepted."</span></span>, schema: { $ref: <span class="hljs-string"><span class="hljs-string">"#/definitions/Hook"</span></span>, }, }, 400: { description: <span class="hljs-string"><span class="hljs-string">"Validation error or some data error."</span></span>, schema: { $ref: <span class="hljs-string"><span class="hljs-string">"#/definitions/Error"</span></span>, }, }, 401: { // ... }, 403: { // ... }, 404: { // ... }, }, tags: [<span class="hljs-string"><span class="hljs-string">"hook"</span></span>], }, } } }</code> </pre> </div></div></li></ul></li><li>  <b>Front-end:</b> <br><ul><li>  <u>JavaScript</u> es un mecanismo que analiza un esquema OpenAPI y genera vistas.  Este mecanismo se inicia una vez, cuando la aplicación se inicializa en el cliente.  Al enviar una solicitud a la API, recibe el JSON solicitado en respuesta con una descripción de la estructura de la API y, al analizarlo, crea todos los objetos JS necesarios que contienen los parámetros de las representaciones del modelo.  Esta solicitud de API es bastante pesada, por lo que la almacenamos en caché y la solicitamos nuevamente solo al actualizar la versión de la aplicación; </li><li>  <u>Libs JavaScript SPA</u> : representación de vistas y enrutamiento entre ellas.  Estas bibliotecas fueron escritas por uno de nuestros desarrolladores front-end.  Cuando un usuario accede a una página en particular, el motor de representación dibuja la página en función de los parámetros almacenados en los objetos de representación JS. </li></ul></li></ol><br>  Por lo tanto, lo que tenemos: tenemos un back-end que describe toda la lógica asociada con los modelos.  Luego, OpenAPI ingresa al juego, que, según la descripción de los modelos, genera JSON con una descripción de la estructura API.  A continuación, el testigo se transmite al cliente, que, al analizar el JAP OpenAPI generado, genera automáticamente una interfaz web. <br><br><h2>  Incorporación de características en la aplicación en la nueva arquitectura: cómo funciona </h2><br>  ¿Recuerdas la tarea de agregar ganchos personalizados?  Así es como lo implementaríamos en una aplicación basada en VSTUtils: <br><br><img src="https://habrastorage.org/webt/ud/yr/af/udyrafi5o5grqlzqovkat8ursko.png" alt="El proceso de agregar nuevas características a la nueva arquitectura"><br><br>  Ahora, gracias a VSTUtils, no necesitamos escribir nada desde cero.  Esto es lo que hacemos para agregar la capacidad de crear ganchos personalizados: <br><br><ol><li>  En el back-end: tomamos y heredamos de la clase más adecuada en VSTUtils, agregamos nuevas funcionalidades específicas al nuevo modelo; </li><li>  En el frente: <br><ul><li>  Si la vista para este modelo no es diferente de la vista básica de VSTUtils, entonces no hacemos nada, todo se muestra automáticamente correctamente; </li><li>  Si necesita cambiar de alguna manera el comportamiento de la vista, utilizando el mecanismo de señal, expandimos declarativamente o cambiamos completamente el comportamiento básico de la vista. <br></li></ul></li></ol><br>  Como resultado, obtuvimos una solución bastante buena, logramos nuestro objetivo, nuestro front-end se generó automáticamente.  El proceso de introducción de nuevas funciones en los proyectos existentes se ha acelerado notablemente: las versiones comenzaron a lanzarse cada 2 semanas, mientras que anteriormente lanzamos versiones cada 2-3 meses con un número mucho menor de nuevas características.  Me gustaría señalar que el equipo de desarrollo se ha mantenido igual, fue la nueva arquitectura de la aplicación la que nos dio los frutos. <br><br><h2>  Versión 1.0: nuestros corazones exigen un cambio </h2><br>  Pero, como saben, no hay límite para la perfección, y VSTUtils no fue la excepción. <br><br>  A pesar de que pudimos automatizar la formación del front-end, el resultado no fue la solución directa que originalmente queríamos. <br><br>  La arquitectura de la aplicación del lado del cliente no fue pensada a fondo, y resultó no tan flexible como podría ser: <br><br><ul><li>  el proceso de introducir sobrecargas funcionales no siempre fue conveniente; </li><li>  El mecanismo de análisis de OpenAPI no fue óptimo; </li><li>  La representación de las representaciones y el enrutamiento entre ellas se realizó mediante bibliotecas autoescritas, que tampoco nos convenían por una serie de razones: <br><ul><li>  Estas bibliotecas no estaban cubiertas por pruebas; </li><li>  no había documentación para estas bibliotecas; </li><li>  no tenían ninguna comunidad; en caso de detección de errores en ellos o la partida del empleado que los escribió, el soporte para dicho código sería muy difícil. </li></ul></li></ul><br>  Y dado que en nuestra empresa nos adherimos al enfoque de DevOps y tratamos de estandarizar y formalizar nuestro código tanto como sea posible, en febrero de este año decidimos llevar a cabo una refactorización global del marco front-end VSTUtils.  Tuvimos varias tareas: <br><br><ul><li>  para formar no solo clases de presentación en el front-end, sino también clases de modelos, nos dimos cuenta de que sería más correcto separar los datos (y su estructura) de su presentación.  Además, la presencia de varias abstracciones en forma de representación y modelo facilitaría enormemente la adición de sobrecargas de la funcionalidad básica en proyectos basados ​​en VSTUtils; </li><li>  use un marco probado con una gran comunidad (Angular, React, Vue) para renderizar y enrutar; esto nos permitirá regalar todo el dolor de cabeza con soporte para el código relacionado con el renderizado y el enrutamiento dentro de nuestra aplicación. </li></ul><br><h2>  Refactorización: elección del marco JS </h2><br>  Entre los frameworks JS más populares: Angular, React, Vue, nuestra elección recayó en Vue porque: <br><br><ul><li>  La base del código de Vue pesa menos que React y Angular; <br><br>  <i>Cuadro comparativo de tamaño de marco comprimido</i> <br><div class="scrollable-table"><table><tbody><tr><th>  Marco </th><th>  Tamaño, kb </th></tr><tr><td>  Angular 2 </td><td>  111 </td></tr><tr><td>  Angular 2 + RX </td><td>  143 </td></tr><tr><td>  Angular 1.4.5 </td><td>  51 </td></tr><tr><td>  Reaccionar 0.14.5 + Reaccionar DOM </td><td>  40 </td></tr><tr><td>  Reaccionar 0.14.5 + Reaccionar DOM + Redux </td><td>  42 </td></tr><tr><td>  Reaccionar 15.3.0 + Reaccionar DOM </td><td>  43 </td></tr><tr><td>  Vue 2.4.2 </td><td>  21 </td></tr></tbody></table></div></li><li>  El proceso de representación de la página de Vue lleva <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">menos</a> tiempo que React y Angular; <br><img src="https://habrastorage.org/webt/lo/eu/6m/loeu6mow9u1qbcz3nbanmldjmwu.png" alt="comparar la velocidad de representación de la página con diferentes marcos de javascript en relación con javascript puro"></li><li>  El umbral de entrada en Vue es mucho más bajo que en React y Angular; </li><li>  Sintaxis de plantillas nativamente comprensible; </li><li>  Documentación elegante y detallada disponible en varios idiomas, incluido el ruso; </li><li>  Un ecosistema desarrollado que proporciona, además de la biblioteca central de Vue, bibliotecas para enrutamiento y para crear un almacén de datos reactivo. </li></ul><br><h2>  Versión 2.0: el resultado de la refactorización frontal </h2><br>  El proceso de refactorización global del front-end de VSTUtils tomó aproximadamente 4 meses y esto es lo que terminamos con: <br><br><img src="https://habrastorage.org/webt/6a/wr/9k/6awr9kuruhmeq9gey-isefn_21u.png" alt="nueva arquitectura frontal VSTUtils"><br><br>  El marco front-end de VSTUtils todavía consta de dos bloques grandes: el primero analiza el esquema OpenAPI, el segundo representa las vistas y el enrutamiento entre ellos, pero ambos bloques han sufrido una serie de cambios significativos. <br><br>  El mecanismo que analiza el esquema OpenAPI ha sido completamente reescrito.  El enfoque para analizar este esquema ha cambiado.  Intentamos hacer que la arquitectura front-end sea lo más similar posible a la arquitectura back-end.  Ahora, en el lado del cliente, no solo tenemos una única abstracción en forma de representaciones, ahora también tenemos abstracciones en forma de modelos y conjuntos de consultas: <br><br><ul><li>  Los objetos de la clase Modelo y sus descendientes son objetos correspondientes a las abstracciones del lado del servidor de los Modelos Django.  Los objetos de este tipo contienen datos sobre la estructura del modelo (nombre del modelo, campos del modelo, etc.); </li><li>  Los objetos de la clase QuerySet y sus descendientes son objetos correspondientes a la abstracción Django QuerySets del lado del servidor.  Los objetos de este tipo contienen métodos que le permiten realizar solicitudes de API (agregar, modificar, recibir, eliminar datos de objetos modelo); </li><li>  objetos de la clase Ver: objetos que almacenan datos sobre cómo representar el modelo en una página en particular, qué plantilla usar para "renderizar" la página, qué otras representaciones de los modelos puede vincular esta página, etc. </li></ul><br>  La unidad responsable de la representación y el enrutamiento también ha cambiado significativamente.  Abandonamos las bibliotecas JS SPA auto-escritas a favor de Vue.js.  Hemos desarrollado nuestros propios componentes Vue que componen todas las páginas de nuestra aplicación web.  El enrutamiento entre vistas se realiza utilizando la biblioteca vue-router, y usamos vuex como almacenamiento reactivo del estado de la aplicación. <br><br>  También me gustaría señalar que, en el lado frontal, la implementación de las clases Model, QuerySet y View no depende de los medios de representación y enrutamiento, es decir, si de repente queremos cambiar de Vue a otro marco, por ejemplo, React o algo nuevo, entonces todo lo que tenemos que hacer es reescribir los componentes Vue a los componentes del nuevo marco, reescribir el enrutador, el repositorio, y eso es todo: el marco VSTUtils volverá a funcionar.  La implementación de las clases Model, QuerySet y View seguirá siendo la misma, ya que no depende de Vue.js.  Creemos que esta es una muy buena ayuda para posibles cambios futuros. <br><br><h2>  Para resumir </h2><br>  Por lo tanto, la renuencia a escribir código "duplicado" resultó en la tarea de automatizar la formación del front-end de una aplicación web, que se resolvió creando el marco VSTUtils.  Logramos construir la arquitectura de la aplicación web para que el back-end y el front-end se complementen armoniosamente y cualquier cambio en la estructura de la API se detecte y se muestre correctamente en el cliente. <br><br>  Los beneficios que hemos recibido al formalizar la arquitectura de la aplicación web: <br><br><ul><li>  Los lanzamientos de aplicaciones que se ejecutan sobre la base de VSTUtils comenzaron a aparecer 2 veces más a menudo.  Esto se debe al hecho de que ahora para introducir una nueva característica, a menudo, necesitamos agregar código solo en el back-end, el front-end se generará automáticamente, lo que ahorra tiempo; </li><li>  Actualización simplificada de la funcionalidad básica.  Dado que ahora toda la funcionalidad básica se ensambla en un marco, para actualizar algunas dependencias importantes o mejorar la funcionalidad básica, necesitamos realizar cambios en un solo lugar: en la base de código VSTUtils.  Al actualizar la versión de VSTUtils en proyectos secundarios, todas las innovaciones se recogerán automáticamente; </li><li>  Encontrar nuevos empleados se ha vuelto más fácil.  De acuerdo, es mucho más fácil encontrar un desarrollador para una pila de tecnología formalizada (Django, Vue) que buscar una persona que acepte trabajar con una grabadora desconocida.  Resultados de búsqueda para desarrolladores que mencionaron Django o Vue en HeadHunter en sus CV (en todas las regiones): <br><ul><li>  Django: se encontraron 3.454 hojas de vida para 3.136 solicitantes; </li><li>  Vue: se encontraron 4.092 currículums para 3.747 solicitantes de empleo. </li></ul></li></ul><br>  Las desventajas de tal formalización de la arquitectura de una aplicación web incluyen lo siguiente: <br><br><ul><li>  Debido al análisis del esquema OpenAPI, la inicialización de la aplicación en el cliente tarda un poco más que antes (aproximadamente 20-30 milisegundos más); </li><li>  Indización de búsqueda sin importancia.  El hecho es que en este momento no estamos utilizando la representación del servidor en el marco de VSTUtils, y todo el contenido de la aplicación se forma en la forma final que ya está en el cliente.  Pero para nuestros proyectos, a menudo no se necesitan resultados de búsqueda altos y para nosotros no es tan crítico. </li></ul><br>  En esto mi historia llega a su fin, ¡gracias por su atención! <br><br><h2>  Enlaces utiles </h2><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Especificación OpenAPI</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Repositorio VSTUtils</a> ; </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Un proyecto de ejemplo creado sobre la base de VSTUtils</a> . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/456146/">https://habr.com/ru/post/456146/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../456132/index.html">Acerca de la grabación de errores o Buscar un gato</a></li>
<li><a href="../456134/index.html">¡Confía pero verifica! Cómo probar su modelo utilizando la nube de IBM (Watson OpenScale)</a></li>
<li><a href="../456136/index.html">¿Por qué hacemos Enterprise Service Mesh?</a></li>
<li><a href="../456140/index.html">Conoce Codeception 3.0</a></li>
<li><a href="../456144/index.html">KubeCon EU 2019: 10 hallazgos clave</a></li>
<li><a href="../456148/index.html">Noticias de la semana: Facebook rechaza a Huawei en aplicaciones, Aurora OS en lugar de Android, minando sanciones</a></li>
<li><a href="../456150/index.html">Petty little joy # 4: Radón - calidad del código medida en números</a></li>
<li><a href="../456152/index.html">Patrones de diseño de niveles para juegos 2D</a></li>
<li><a href="../456154/index.html">Características principales de UX y MVP al crear un producto</a></li>
<li><a href="../456156/index.html">Es por eso que se necesita álgebra escolar.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>