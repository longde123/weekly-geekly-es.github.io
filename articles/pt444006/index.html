<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üöø ü•Ä ‚úåüèª Consola de jogos fa√ßa-voc√™-mesmo DIY üóûÔ∏è ‚ôÄÔ∏è üïò</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Este post √© uma introdu√ß√£o ao meu projeto de consoles de v√≠deo em console "caseiros", feitos a partir do zero. Eu fui inspirado por consoles retr√¥ e a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Consola de jogos fa√ßa-voc√™-mesmo DIY</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444006/"><p><img src="https://habrastorage.org/getpro/habr/post_images/0b1/45a/7c0/0b145a7c0f4c0821cdb77654ef2a8cd3.jpg" alt="imagem"></p><br><p>  Este post √© uma introdu√ß√£o ao meu projeto de consoles de v√≠deo em console "caseiros", feitos a partir do zero.  Eu fui inspirado por consoles retr√¥ e amostras modernas, mas consegui minha pr√≥pria arquitetura.  Meus amigos sempre me diziam que eu deveria falar sobre o meu projeto, e n√£o fazer tudo exclusivamente "por mim", ent√£o aqui estou publicando este post. </p><a name="habracut"></a><br><p>  <strong>Aten√ß√£o, esta √© uma tradu√ß√£o</strong> </p><br><h1 id="kak-vsyo-nachalos">  Como tudo come√ßou </h1><br><p>  Chamo-me Sergio Vieira, cresci em Portugal nas d√©cadas de 80 e 90, tenho uma longa nostalgia pelo jogo retro, especialmente pelos consoles de terceira e quarta gera√ß√£o. </p><br><p>  H√° alguns anos, decidi entender melhor a eletr√¥nica e tentar criar meu pr√≥prio prefixo. </p><br><p>  Por profiss√£o, sou programador e n√£o tinha nenhuma experi√™ncia como engenheiro eletr√¥nico, exceto por (e n√£o deve ser considerado) atualiza√ß√µes independentes do meu destkop. </p><br><p>  Embora eu n√£o tivesse experi√™ncia, me disse "por que n√£o?", Comprei v√°rios livros, v√°rios kits eletr√¥nicos e comecei a estudar com base em meus sentimentos sobre o que valia a pena estudar. </p><br><p>  Eu queria criar um prefixo semelhante √†queles que me causam sentimentos nost√°lgicos, queria algo entre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">NES</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Super Nintendo</a> , ou talvez entre o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Sega Master System</a> e o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mega Drive</a> . </p><br><p>  Esses consoles tinham uma CPU, um chip de v√≠deo original (eles n√£o eram chamados de GPU na √©poca) e um chip de √°udio, √†s vezes embutido e √†s vezes externo. </p><br><p>  Os jogos foram distribu√≠dos em cartuchos, que em geral eram extens√µes de ferro, √†s vezes apenas chips de ROM e √†s vezes possu√≠am componentes adicionais. </p><br><p>  O plano original era criar um prefixo com as seguintes caracter√≠sticas: </p><br><ul><li>  Sem emula√ß√£o, jogos e programas devem funcionar em hardware real, n√£o necessariamente o mesmo daqueles tempos, mas r√°pido o suficiente para a tarefa e nada mais. </li><li>  Com uma CPU retro real. </li><li>  Com sa√≠da de TV anal√≥gica. </li><li>  Com som </li><li>  Com suporte para controlador duplo </li><li>  Becks de rolagem e sprites de anima√ß√£o </li><li>  Com recursos para suportar jogos de plataforma como Mario e, claro, todos os tipos de outros jogos. </li><li>  Com o download de jogos e programas de cart√µes SD. </li></ul><br><p>  Por que cart√µes SD, e n√£o cartuchos, bem, basicamente √© muito mais pr√°tico, voc√™ pode copi√°-los do seu computador.  E cartuchos significariam, em primeiro lugar, mais ferro no decodificador e, em segundo lugar, produzir ferro para cada programa. </p><br><h1 id="proizvodstvo">  Produ√ß√£o </h1><br><h2 id="video-signal">  Sinal de v√≠deo </h2><br><p>  A primeira coisa que fiz foi gerar um sinal de v√≠deo. </p><br><p>  Qualquer console do per√≠odo que tirei como amostra tinha v√°rios chips gr√°ficos propriet√°rios, o que significa que todos tinham especifica√ß√µes diferentes. <br>  Por esse motivo, n√£o queria usar um chip gr√°fico pronto, queria que meu console tivesse especifica√ß√µes gr√°ficas exclusivas.  E como n√£o conseguia fabricar meu pr√≥prio chip gr√°fico e, na √©poca, ainda n√£o conseguia usar o FPGA, decidi me limitar √† gera√ß√£o de sinal gr√°fico gerada por software usando um microcontrolador de 8 bits e 20 megahertz. </p><br><p>  Isso n√£o √© demais, e apenas uma solu√ß√£o poderosa o suficiente para gr√°ficos do n√≠vel em que eu estava interessado. </p><br><p>  Ent√£o comecei a usar o microcontrolador Atmega644 a uma pureza de 20 MHz para gerar um sinal de v√≠deo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PAL</a> para a TV.  Eu tive que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">superar</a> o protocolo PAL porque o pr√≥prio chip n√£o sabe como faz√™-lo. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d7b/8ee/74d/d7b8ee74dbd4c844e65f2a1766e33a0a.jpg" alt="Teste imageVPU 1"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/96b/d85/e5c/96bd85e5c323152604a68bb3c8341f69.jpg" alt="Teste 2 da imagemVPU"></p><br><p>  O microcontrolador produz uma cor de 8 bits (RGB332, 3 bits vermelho, 3 bits verde e 2 azul) e o DAC passivo converte tudo em RGB.  Felizmente em Portugal, quase todas as TVs est√£o equipadas com um conector SCART e suportam entrada RGB. </p><br><h2 id="pravilnaya-graficheskaya-podsistema">  O subsistema gr√°fico correto </h2><br><p>  Como o microcontrolador √© bastante poderoso, e eu decidi us√°-lo exclusivamente para gerar um sinal de v√≠deo (eu o chamei de VPU - Video Processing Unit), ent√£o decidi organizar um buffer duplo ao mesmo tempo. </p><br><p>  Aconteceu que o segundo microcontrolador (PPU, Picture Processing Unit, chip Atmega1284 tamb√©m a 20 MHz) gerou uma imagem no chip de RAM 1 (eu o chamei de VRAM1), e o primeiro enviou o conte√∫do do segundo chip (VRAM2) para a TV ao mesmo tempo. </p><br><p>  Ap√≥s um quadro e dois quadros no sistema PAL serem de 1/25 de segundo, o VPU alterna os VRAMs e eles s√£o trocados, o PPU gera uma imagem em VRAM2 e o VPU despeja VRAM1 na sa√≠da da TV. </p><br><p>  A placa de v√≠deo acabou sendo muito complicada, porque eu tive que usar hardware externo para que ambos os microcontroladores pudessem usar os dois m√≥dulos de mem√≥ria e acelerar o acesso √† RAM, porque ela tamb√©m possui batidas de bits, ent√£o eu tive que adicionar 74 chips da s√©rie como contadores, seletores de linha, transceptores etc. . </p><br><p>  O firmware para VPU e PPU tamb√©m se mostrou complicado, porque eu tive que escrever muito c√≥digo para obter a velocidade m√°xima dos gr√°ficos.  No in√≠cio, tudo foi escrito em assembler, depois parte foi reescrita em C. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/7a2/43d/c87/7a243dc873ceaf16fe0e2d183d388dd1.jpg" alt="imageVideo Board 1"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/2a9/c59/cca/2a9c59cca5b2d64f25abdfd2f59912e5.jpg" alt="imageVideo Board 2"></p><br><p>  Como resultado, a PPU gera uma imagem de 224x192 pixels, que √© ent√£o enviada √† TV via VPU.  Voc√™ pode encontrar uma resolu√ß√£o baixa, mas na verdade √© quase o mesmo que os consoles da √©poca tinham, geralmente 256x224.  Uma resolu√ß√£o um pouco mais baixa, mas me permitiu adicionar mais recursos que o sistema consegue calcular em um quadro. </p><br><p>  Como nos velhos tempos, a PPU possui sua pr√≥pria mec√¢nica r√≠gida que voc√™ deve poder usar.  O apoio (apoio) √© renderizado a partir de caracteres de 8x8 pixels, tamb√©m chamados de blocos.  Acontece que o tamanho do plano de fundo √© de 28x24 pe√ßas. </p><br><p>  Para que o suporte possa rolar suavemente, pixel por pixel, eu fiz isso. Existem quatro telas virtuais, cada uma das pe√ßas 28x24 que ficam na mem√≥ria sequencialmente e s√£o enroladas uma na outra, na imagem fica mais clara. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/666/41c/c14/66641cc14e799a0e4269d4b130490465.png" alt="imageBackground"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/500/971/e16/500971e169f1364520eb5004529cca3e.png" alt="imageVirtual Background"></p><br><p>  No topo do plano de fundo, o PPU pode renderizar 64 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">sprites com</a> 8 ou 16 pixels de altura ou largura, ou seja, 1, 2 ou 4 blocos e tamb√©m podem ser invertidos horizontalmente e / ou verticalmente. </p><br><p>  Na parte de tr√°s, tamb√©m √© poss√≠vel renderizar uma sobreposi√ß√£o com um buffer de 28x6 pe√ßas, destinado a renderizar HUDs, pontua√ß√µes para n√£o interferir nos sprites principais e na rolagem das costas. </p><br><p>  Um recurso "avan√ßado" √© que o suporte pode ser rolado n√£o inteiramente, mas cada linha separadamente, o que permite todos os tipos de efeitos interessantes, como telas divididas ou quase <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">paralaxe</a> . </p><br><p>  H√° tamb√©m uma tabela de atributos que permite definir cada bloco com um valor de 0 a 3 e, em seguida, voc√™ pode especificar uma p√°gina de blocos para todos os blocos com um atributo ou incrementar seu valor simb√≥lico.  Isso √© conveniente quando h√° partes do backup que precisam ser alteradas regularmente e a CPU n√£o precisa calcular cada bloco individualmente, basta dizer algo como: "todos os blocos com atributo 1, aumentam o valor num√©rico do seu personagem em 2", tais coisas podem ser implementadas por diferentes t√©cnicas observe, por exemplo, em blocos de blocos em Mario, onde o ponto de interroga√ß√£o √© animado ou em jogos onde h√° uma cachoeira na qual todos os blocos est√£o mudando constantemente, criando o efeito de queda de √°gua. </p><br><h2 id="cpu">  CPU </h2><br><p>  Quando minha placa de v√≠deo funcionou, comecei a trabalhar com a CPU como <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Zilog 80</a> para meu decodificador. </p><br><p>  Uma das raz√µes pelas quais o Z80 foi escolhido, al√©m de ser uma CPU retro legal, √© a capacidade de endere√ßar dois espa√ßos de 16 bits, um para mem√≥ria e o segundo para portas de E / S, o menos lend√°rio <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">6502</a> , por exemplo, n√£o pode , ele pode endere√ßar apenas espa√ßo de 16 bits e √© necess√°rio mape√°-lo na mem√≥ria, al√©m de v√°rios dispositivos externos, v√≠deo, √°udio, joysticks, gerador de n√∫meros aleat√≥rios de hardware etc.  √â mais conveniente ter dois espa√ßos de endere√ßo, um totalmente fornecido at√© 64 kilobytes de c√≥digo e dados na mem√≥ria e o segundo para acesso a dispositivos externos. </p><br><p>  Primeiro, conectei a CPU √† EEPROM na qual meu programa de teste estava localizado e tamb√©m a conex√£o atrav√©s do espa√ßo de E / S ao microcontrolador que instalei para que eu pudesse me comunicar com o meu computador via <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">RS232</a> e monitorar como a CPU e tudo o mais funcionava.  Esse microcontrolador Atmega324, operando a 20 MHz, chamo de unidade de microcontrolador IO MCU - entrada / sa√≠da, √© respons√°vel por controlar o acesso a controladores de jogos (joysticks), leitor de cart√µes SD, teclado <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">PS / 2</a> e comunicador via RS232. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0e9/3fa/89a/0e93fa89aa467f7d400b032ba4932c1c.jpg" alt="imageCPU Board 1"></p><br><p>  A CPU se conecta a um chip de mem√≥ria de 128 kilobytes, dos quais apenas 56 kilobytes est√£o dispon√≠veis, √© claro que isso n√£o faz sentido, mas eu poderia obter apenas chips de 128 ou 32 kilobytes.  Descobriu-se que a mem√≥ria consiste em 8 kilobytes de ROM e 56 kilobytes de RAM. </p><br><p>  Depois disso, atualizei o firmware do IO MCU usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">esta biblioteca</a> e obtive suporte para leitores de cart√£o SD. </p><br><p>  Agora a CPU pode percorrer os diret√≥rios, ver o que est√° neles, abrir e ler arquivos.  Tudo isso √© feito escrevendo e lendo para endere√ßos espec√≠ficos no espa√ßo de E / S. </p><br><h2 id="podklyuchenie-cpu-k-ppu">  Conecte a CPU √† PPU </h2><br><p>  A pr√≥xima coisa que fiz foi a conex√£o entre a CPU e a PPU.  Para fazer isso, apliquei uma "solu√ß√£o simples" que era comprar RAM de porta dupla, esse √© um chip de RAM que pode ser conectado diretamente a dois barramentos diferentes.  Isso permite que ele se livre de chips adicionais, como seletores de linha, e, al√©m disso, permite acesso quase simult√¢neo √† mem√≥ria de ambos os chips.  Outra PPU pode acessar diretamente a CPU em cada quadro, ativando suas <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">interrup√ß√µes n√£o mascar√°veis</a> .  Acontece que a CPU recebe uma interrup√ß√£o em cada quadro, o que √© √∫til para v√°rias tarefas de temporiza√ß√£o e para entender quando √© hora de fazer uma atualiza√ß√£o gr√°fica. </p><br><p>  Cada quadro de intera√ß√£o da CPU, PPU e VPU ocorre de acordo com o seguinte esquema: </p><br><ol><li>  A PPU copia as informa√ß√µes da mem√≥ria da PPU para a mem√≥ria interna. </li><li>  A PPU envia um sinal de interrup√ß√£o para a CPU. </li><li>  Ao mesmo tempo: <br><ul><li>  A CPU salta para a fun√ß√£o de interrup√ß√£o e come√ßa a atualizar a mem√≥ria PPU com um novo estado gr√°fico.  O programa deve retornar da interrup√ß√£o at√© o pr√≥ximo bloco. </li><li>  O PPU renderiza uma imagem com base nas informa√ß√µes previamente copiadas para um dos VRAM. </li><li>  O VPU envia uma imagem de outro VRAM para a sa√≠da da TV. </li></ul></li></ol><br><p>  Na mesma √©poca, comecei a dar suporte a controladores de jogos, no come√ßo eu queria usar os controles da Nintendo, mas seus soquetes s√£o propriet√°rios e geralmente dif√≠ceis de encontrar, ent√£o decidi usar controladores de 6 bot√µes compat√≠veis com Mega Drive / Genesis, pois eles t√™m soquetes DB-9 padr√£o que est√£o por toda parte. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/9ed/e06/12a/9ede0612a51808d0d5e92c5765e9f4fd.jpg" alt="imageJoint Board 1"></p><br><h2 id="napisanie-pervoy-nastoyaschey-igry">  Escrevendo o primeiro jogo real </h2><br><p>  Naquele momento, eu j√° tinha uma CPU capaz de controlar PPU, trabalhando com joysticks, lendo cart√µes SD ... era hora de <a href="">escrever o primeiro jogo</a> , √© claro, no montador Z80, levava v√°rios dias do tempo livre. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/2Pcrg1fesBk" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2 id="dobavlyaem-dinamicheskuyu-grafiku">  Adicionar gr√°ficos din√¢micos </h2><br><p>  Tudo estava super, eu tinha meu pr√≥prio console de jogo, mas isso n√£o foi suficiente para mim, porque no jogo eu tive que usar gr√°ficos costurados na mem√≥ria PPU e era imposs√≠vel desenhar pe√ßas para um jogo espec√≠fico, e isso s√≥ podia ser alterado com a atualiza√ß√£o da ROM.  Comecei a pensar em como adicionar mais mem√≥ria para que a CPU carregasse caracteres para os blocos e, em seguida, a PPU poderia ler tudo a partir da√≠ e como faz√™-lo mais facilmente, porque o prefixo j√° era complicado e grande. </p><br><p>  E eu vim com o seguinte: apenas a PPU ter√° acesso a essa nova mem√≥ria e a CPU carregar√° dados l√° atrav√©s da PPU e, enquanto esse processo de carregamento estiver em andamento, essa mem√≥ria n√£o poder√° ser usada para desenhar, mas ser√° poss√≠vel desenhar a partir da ROM nesse momento. </p><br><p>  Ap√≥s o t√©rmino do carregamento, a CPU mudar√° a mem√≥ria ROM interna para essa nova mem√≥ria, que chamei de RAM de caracteres (CHR-RAM) e, nesse modo, a PPU come√ßar√° a desenhar gr√°ficos din√¢micos, provavelmente essa n√£o √© a melhor solu√ß√£o, mas funciona.  Como resultado, uma nova mem√≥ria foi instalada com 128 kilobytes e pode armazenar 1024 caracteres de 8x8 pixels cada para o plano de fundo e o mesmo n√∫mero de caracteres para sprites. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ff8/47a/b6b/ff847ab6b2ae65bd21c0426283d2c6a7.jpg" alt="imageJoint Board 2"></p><br><h2 id="i-nakonec-zvuk">  E finalmente o som </h2><br><p>  As m√£os alcan√ßaram o som por √∫ltimo.  No come√ßo, eu queria um som como o que est√° no <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Uzebox</a> , ou seja, que o microcontrolador gera 4 canais de som PWM. </p><br><p>  No entanto, descobri que posso obter facilmente os chips antigos e pedi v√°rios chips de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">s√≠ntese FM</a> YM3438, esses caras s√£o totalmente compat√≠veis com o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">YM2612</a> usado no Mega Drive / Genesis.  Ao instal√°-los, voc√™ pode obter Mega Drive de m√∫sica de qualidade e efeitos sonoros produzidos pelo microcontrolador. </p><br><p>  Eu instalei outro microcontrolador e chamei de SPU (Sound Processor Unit), ele controla o YM3438 e pode gerar sons sozinho.  A CPU controla-o atrav√©s de uma mem√≥ria de porta dupla, desta vez com apenas 2 kilobytes. </p><br><p>  Como na unidade gr√°fica, a unidade de som possui 128 kilobytes de mem√≥ria para armazenar amostras de PCM e patches de som, a CPU carrega dados nessa mem√≥ria acessando a SPU.  Acontece que a CPU diz √† SPU para executar comandos a partir dessa mem√≥ria ou atualiza os comandos para a SPU a cada quadro. </p><br><p>  A CPU controla quatro canais PWM atrav√©s de quatro buffers circulares na mem√≥ria da SPU.  O SPU passa por esses buffers e executa os comandos gravados neles.  H√° tamb√©m um desses buffer para o chip de s√≠ntese FM. </p><br><p>  No total, como no gr√°fico, a intera√ß√£o entre a CPU e a SPU segue o esquema: </p><br><ol><li>  A SPU copia dados da SPU para a mem√≥ria interna. </li><li>  O SPU est√° aguardando uma interrup√ß√£o do PPU (isto √© para sincroniza√ß√£o) </li><li>  Ao mesmo tempo <br><ul><li>  A CPU atualiza os buffers de canal PWM e os buffers de sintetizador de FM. </li><li>  A SPU executa comandos em buffers de acordo com os dados na mem√≥ria interna. </li><li>  Junto com tudo isso, o SPU atualiza os sons PWM com uma frequ√™ncia de 16 kilohertz. </li></ul></li></ol><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d83/946/43e/d8394643e24f2c0771493bfbe1081157.jpg" alt="imageSound Board 1"></p><br><h1 id="chto-vyshlo-v-itoge">  O que saiu no final </h1><br><p>  Depois que todos os blocos estavam prontos, alguns foram para a t√°bua de p√£o. <br>  No bloco da CPU, consegui desenvolver e solicitar uma placa de circuito impresso personalizada, n√£o sei se vale a pena para os outros m√≥dulos, acho que tive muita sorte por minha placa de circuito impresso funcionar imediatamente. </p><br><p>  Na t√°bua de p√£o agora (at√© agora) h√° apenas som. <br>  Veja como est√° hoje: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5b1/41e/828/5b141e82873999d9ce5a327d77770133.jpg" alt="imageConsole 1"></p><br><h2 id="arhitektura">  Arquitetura </h2><br><p>  O diagrama ilustra os componentes em cada bloco e como eles interagem entre si.  A √∫nica coisa que n√£o √© mostrada √© o sinal da PPU para a CPU em cada quadro como uma interrup√ß√£o e o mesmo sinal que vai para a SPU. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/4cb/b3a/9d1/4cbb3a9d121465d904518aceaee47045.png" alt="imageArquitetura"></p><br><ul><li>  CPU: Zilog Z80 a 10 MHz </li><li>  CPU-ROM: 8KB EEPROM, cont√©m c√≥digo do carregador de inicializa√ß√£o </li><li>  CPU-RAM: 128KB RAM (56KB dispon√≠vel), c√≥digo e dados para programas / jogos </li><li>  IO MCU: Atmega324, √© a interface entre a CPU e o RS232, o teclado PS / 2, joysticks e o sistema de arquivos do cart√£o SD </li><li>  PPU-RAM: 4 kilobytes de mem√≥ria de porta dupla, mem√≥ria intermedi√°ria entre CPU e PPU </li><li>  CHR-RAM: 128KB de RAM, armazena blocos din√¢micos para suporte (substrato) e sprites (em caracteres de 8x8 pixels). </li><li>  VRAM1, VRAM2: 128KB RAM (43008 est√° realmente dispon√≠vel), eles s√£o usados ‚Äã‚Äãpara o buffer de quadros, escrevem PPU e l√™em VPU a partir deles. </li><li>  PPU (Picture Processing Unit): Atmega1284, desenha um quadro no buffer de moldura. </li><li>  VPU (Unidade de processamento de v√≠deo): Atmega324, l√™ o buffer de quadros e gera sinal e sincroniza√ß√£o RGB e PAL. </li><li>  SPU-RAM: RAM de 2 portas de 2 KB, serve como interface entre a CPU e a SPU. </li><li>  SNDRAM: 128KB RAM, armazena patches PWM, amostras PCM e blocos de instru√ß√µes para o sintetizador de FM. </li><li>  YM3438: YM3438, chip de s√≠ntese FM. </li><li>  SPU (Sound Processing Unit): Atmega644, gera sons usando o princ√≠pio de modula√ß√£o por largura de pulso (PWM) e controla o YM3438. </li></ul><br><h2 id="okonchatelnye-specifikacii">  Especifica√ß√µes finais </h2><br><p>  <strong>CPU:</strong> </p><br><ul><li>  CPU de 8 bits Zilog Z80 a uma frequ√™ncia de 10Mhz. </li><li>  ROM de 8 KB para o carregador de inicializa√ß√£o. </li><li>  56KB de RAM. </li></ul><br><p>  <strong>IO:</strong> </p><br><ul><li>  Lendo dados do leitor de cart√£o SD FAT16 / FAT32. </li><li>  Leitura / grava√ß√£o na porta RS232. </li><li>  2 controladores de jogo compat√≠veis com MegaDrive / Genesis. </li><li>  Teclado PS2. </li></ul><br><p>  <strong>V√≠deo:</strong> </p><br><ul><li>  Resolu√ß√£o 224x192 pixels. </li><li>  25 quadros por segundo (meio FPS do PAL). </li><li>  256 cores (RGB332). </li><li>  Plano de fundo virtual 2x2 (448x384 pixels), com rolagem bidirecional baseada em pixels, com base em quatro p√°ginas em tela cheia. </li><li>  64 sprites com largura e altura de 8 ou 16 pixels, com a possibilidade de virar vertical e horizontal. </li><li>  O plano de fundo e os sprites consistem em caracteres de 8x8 pixels cada. </li><li>  Mem√≥ria de v√≠deo simb√≥lica de 1024 caracteres para o fundo e 1024 para sprites. </li><li>  64 rolagem horizontal independente ao longo de linhas definidas </li><li>  8 rolagem vertical independente ao longo de linhas definidas </li><li>  Sobreposi√ß√£o de 224x48 pixels com transpar√™ncia opcional das teclas de cores. </li><li>  Tabela de atributos em segundo plano. </li><li>  RGB e PAL composto via conector SCART. </li></ul><br><p>  <strong>Som:</strong> </p><br><ul><li>  PWM para 8 bits e 4 canais, com formas de onda incorporadas: quadrada, senoidal, serra, ru√≠do, etc. </li><li>  Amostras de 8 bits e 8 kHz em um dos canais PWM. </li><li>  O chip de s√≠ntese FM YM3438 √© carregado com instru√ß√µes na frequ√™ncia de 50 hertz. </li></ul><br><h1 id="razrabotka-dlya-pristavki">  Desenvolvimento para o console </h1><br><p>  Para o console, um carregador de inicializa√ß√£o foi gravado.  O carregador de inicializa√ß√£o √© colocado na CPU da ROM e pode levar at√© 8 kilobytes.  Ele usa os primeiros 256 bytes de RAM.  O carregador √© a primeira coisa que a CPU executa.  √â necess√°rio mostrar os programas localizados no cart√£o SD. </p><br><p>  Esses programas est√£o em arquivos que cont√™m c√≥digo compilado e tamb√©m podem conter gr√°ficos e som. </p><br><p>  Depois de selecionar um programa, ele √© carregado na mem√≥ria da CPU, mem√≥ria CHR e mem√≥ria SPU.  Ap√≥s o qual o c√≥digo do programa √© executado.  O tamanho m√°ximo do c√≥digo carregado no console √© de 56 kilobytes, al√©m dos primeiros 256 bytes, e √© claro que voc√™ precisa levar em considera√ß√£o o espa√ßo para a pilha e os dados. <br>  E esse carregador de inicializa√ß√£o e outros programas criados para esse console foram criados da mesma maneira descrita abaixo. </p><br><h2 id="memoryio-mapping">  Mapeamento de mem√≥ria / E / S </h2><br><p>  O que √© importante ao desenvolver esse prefixo √© levar em considera√ß√£o como a CPU acessa os v√°rios blocos e aloca corretamente o espa√ßo de endere√ßo para entrada de entrada e espa√ßo de endere√ßo de mem√≥ria. </p><br><p>  A CPU acessa a mem√≥ria de acesso aleat√≥rio do carregador de inicializa√ß√£o atrav√©s do espa√ßo de endere√ßo da mem√≥ria. </p><br><p>  Espa√ßo de endere√ßo de mem√≥ria <br><img src="https://habrastorage.org/getpro/habr/post_images/f37/a98/86a/f37a9886acd53a6204b02a3f11b190b6.png" alt="Mapeamento de imagem"></p><br><p>  E para PPU-RAM, SPU-RAM e IO MCU atrav√©s do espa√ßo de endere√ßo de E / S. </p><br><p>  Espa√ßo de endere√ßo de E / S <br><img src="https://habrastorage.org/getpro/habr/post_images/799/634/0c0/7996340c05682ff9eb4d060e6cc361c1.png" alt="mapeamento imageIO"></p><br><p>  Como voc√™ pode ver na tabela, os endere√ßos para todos os dispositivos, IO MCU, PPU e SPU s√£o alocados dentro do espa√ßo de endere√ßo de E / S. </p><br><h2 id="upravlenie-ppu">  Gerenciamento de PPU </h2><br><p>  A partir das informa√ß√µes da tabela, √© poss√≠vel observar que, para o controle PPU, √© necess√°rio gravar na mem√≥ria PPU dispon√≠vel nos endere√ßos 1000h-1FFFh no espa√ßo de endere√ßo de E / S. </p><br><p>  Aloca√ß√£o de espa√ßo de endere√ßo PPU </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ab3/304/1ca/ab33041ca0ac1a8d427cae75dcb736ff.png" alt="Mapeamento imagePPU"></p><br><p>  O status da PPU pode assumir os seguintes valores: </p><br><ol><li>  Modo de gr√°ficos incorporados </li><li>  Modo de gr√°ficos din√¢micos (CHR-RAM) </li><li>  Modo de grava√ß√£o na mem√≥ria CHR </li><li>  A grava√ß√£o est√° conclu√≠da, aguardando a confirma√ß√£o do modo da CPU </li></ol><br><p>  Aqui, por exemplo, como voc√™ pode trabalhar com sprites: <br>  O prefixo pode desenhar 64 sprites por vez.      CPU    -   1004h-1143h (320 ),     5   (5 * 64 = 320): </p><br><ol><li>   ,     : Active, Flipped_X, Flipped_Y, PageBit0, PageBit1, AboveOverlay, Width16, Height16. </li><li>  ,     (  ). </li><li>    (    ‚Äî ) </li><li>   X </li><li>   Y </li></ol><br><p> ,   ,    Active  1,    X  Y   ,  32/32       ,        . </p><br><p>         . </p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Por exemplo, se precisarmos mostrar o sprite n√∫mero 10, o endere√ßo ser√° 4145 (1004h + (5 x 9)), escreva o valor 1 para ativa√ß√£o e as coordenadas, por exemplo, x = 100 e y = 120, escreva o valor 100 no endere√ßo 4148 e endere√ßo 4149 valor 120. </font></font></p><br><h2 id="ispolzuem-assembler"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Usando assembler </font></font></h2><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Um dos m√©todos de programa√ß√£o para o console √© o assembler. </font></font></p><br><p><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Aqui est√° um exemplo de como mostrar um sprite e anim√°-lo para que ele se mova e afaste as bordas da tela. </font></font></p><br><pre><code class="plaintext hljs">ORG 2100h PPU_SPRITES: EQU $1004 SPRITE_CHR: EQU 72 SPRITE_COLORKEY: EQU $1F SPRITE_INIT_POS_X: EQU 140 SPRITE_INIT_POS_Y: EQU 124 jp main DS $2166-$ nmi: ;    (NMI) ld bc, PPU_SPRITES + 3 ld a, (sprite_dir) and a, 1 jr z, subX in a, (c) ;  X inc a out (c), a cp 248 jr nz, updateY ld a, (sprite_dir) xor a, 1 ld (sprite_dir), a jp updateY subX: in a, (c) ;  X dec a out (c), a cp 32 jr nz, updateY ld a, (sprite_dir) xor a, 1 ld (sprite_dir), a updateY: inc bc ld a, (sprite_dir) and a, 2 jr z, subY in a, (c) ;  Y inc a out (c), a cp 216 jr nz, moveEnd ld a, (sprite_dir) xor a, 2 ld (sprite_dir), a jp moveEnd subY: in a, (c) ;  Y dec a out (c), a cp 32 jr nz, moveEnd ld a, (sprite_dir) xor a, 2 ld (sprite_dir), a moveEnd: ret main: ld bc, PPU_SPRITES ld a, 1 out (c), a ;   0 inc bc ld a, SPRITE_CHR out (c), a ;    0 inc bc ld a, SPRITE_COLORKEY out (c), a ;     0 inc bc ld a, SPRITE_INIT_POS_X out (c), a ;     0 inc bc ld a, SPRITE_INIT_POS_Y out (c), a ;   Y  0 mainLoop: jp mainLoop sprite_dir: DB 0</code> </pre> <br><p>  <strong><em>Usando a linguagem C</em></strong> </p><br><p>  Voc√™ tamb√©m pode usar a linguagem C, para isso precisamos do compilador SDCC e de alguns utilit√°rios adicionais. </p><br><p>  O c√≥digo C pode ser mais lento, mas a escrita √© mais r√°pida e f√°cil. </p><br><p>  Aqui est√° um exemplo de c√≥digo que faz o mesmo que o c√≥digo do assembler acima, ele usa uma biblioteca que ajuda a fazer chamadas para PPU: </p><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;console.h&gt; #define SPRITE_CHR 72 #define SPRITE_COLORKEY 0x1F #define SPRITE_INIT_POS_X 140 #define SPRITE_INIT_POS_Y 124 struct s_sprite sprite = { 1, SPRITE_CHR, SPRITE_COLORKEY, SPRITE_INIT_POS_X, SPRITE_INIT_POS_Y }; uint8_t sprite_dir = 0; void nmi() { if (sprite_dir &amp; 1) { sprite.x++; if (sprite.x == 248) { sprite_dir ^= 1; } } else { sprite.x--; if (sprite.x == 32) { sprite_dir ^= 1; } } if (sprite_dir &amp; 2) { sprite.y++; if (sprite.y == 216) { sprite_dir ^= 2; } } else { sprite.y--; if (sprite.x == 32) { sprite_dir ^= 2; } } set_sprite(0, sprite); } void main() { while(1) { } }</span></span></span></span></code> </pre> <br><h2 id="dinamicheskaya-grafika">  Gr√°ficos din√¢micos </h2><br><p>  (Nos gr√°ficos personalizados originais. Aprox. Por.) </p><br><p>  No prefixo ROM, uma p√°gina de blocos para backup e outra p√°gina de sprites prontos s√£o costuradas); por padr√£o, voc√™ s√≥ pode usar esses gr√°ficos fixos, mas pode mudar para din√¢mico. </p><br><p>  Meu objetivo era que todos os gr√°ficos necess√°rios em formato bin√°rio fossem imediatamente carregados na RAM do CHR, e o c√≥digo no gerenciador de inicializa√ß√£o da ROM pode fazer isso.  Para fazer isso, fiz v√°rias fotos do tamanho correto com diferentes s√≠mbolos √∫teis: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ed7/636/39c/ed763639cda1cf8ba163c3c30d2f0ec7.png" alt="imageSample componentes de ladrilho"></p><br><p>  Como a mem√≥ria de gr√°ficos din√¢micos consiste em 4 p√°ginas com 256 caracteres de 8x8 pixels cada e 4 p√°ginas dos mesmos caracteres para sprites, converti as imagens para o formato PNG, excluindo as duplicadas: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/052/39d/5e9/05239d5e93c3578b8b720eedbc1c9169.png" alt="imageSample ficha de personagem"></p><br><p>  E ent√£o ele usou uma ferramenta auto-escrita para traduzir tudo para o formato bin√°rio RGB332 com blocos 8x8. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a4c/8e7/4c6/a4c8e74c68c44e8f0f122002ebb021da.png" alt="linha de comando imageGraphics"></p><br><p>  Como resultado, temos arquivos com caracteres, em que todos os caracteres passam sequencialmente um ap√≥s o outro e cada um ocupa 64 bytes. </p><br><h2 id="zvuk">  Som </h2><br><p>  Amostras RAW de onda convertidas em amostras PCM de 8 bits e 8 quilohertz. </p><br><p>  Patches para efeitos sonoros no PWM e na m√∫sica s√£o escritos com instru√ß√µes especiais. </p><br><p>  Quanto ao chip de s√≠ntese Yamaha YM3438 FM, encontrei um programa chamado DefleMask que produz m√∫sica sincronizada com PAL para o chip Genesis YM2612, compat√≠vel com o YM3438. </p><br><p>  O DefleMask exporta m√∫sicas no formato VGM e eu as converto com outro utilit√°rio propriet√°rio em meu pr√≥prio formato bin√°rio. </p><br><p>  Todos os bin√°rios dos tr√™s tipos de som s√£o combinados em um arquivo bin√°rio, que meu carregador de inicializa√ß√£o pode ler e carregar na mem√≥ria de som SDN RAM. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/aee/fb5/fd5/aeefb5fd5918b0653557889b2b00972a.png" alt="linha de comando imageSound"></p><br><h2 id="linkovka-okonchatelnogo-fayla">  Link para o arquivo final </h2><br><p>  C√≥digo execut√°vel bin√°rio, gr√°ficos e som s√£o combinados em um arquivo PRG.  O arquivo PRG possui um cabe√ßalho no qual tudo √© descrito, se h√° dados de √°udio e gr√°ficos, quanto eles ocupam e os pr√≥prios dados. </p><br><p>  Esse arquivo pode ser gravado no cart√£o SD e o carregador de inicializa√ß√£o do console o considera e baixa tudo para os locais apropriados e inicia o c√≥digo execut√°vel do programa. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/465/33e/43c/46533e43c8bca14c9cf9c36247b154eb.png" alt="linha de comando imagePRG"></p><br><h2 id="emulyator">  Emulador </h2><br><p>  Eu escrevi um emulador do meu console em C ++ usando <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">wxWidgets</a> para facilitar o desenvolvimento para ele. </p><br><p>  A CPU √© emulada pela biblioteca <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">libz80</a> . </p><br><p>  Recursos foram adicionados ao emulador para depura√ß√£o, eu posso par√°-lo a qualquer momento e fazer a depura√ß√£o do assembly passo a passo, h√° um mapeamento para o c√≥digo-fonte em C. se esse idioma foi usado para o jogo. </p><br><p>  De acordo com o gr√°fico, posso olhar para a mem√≥ria de v√≠deo, nas tabelas de s√≠mbolos e na pr√≥pria mem√≥ria CHR. </p><br><p>  Aqui est√° um exemplo de um programa em execu√ß√£o em um emulador com as ferramentas de depura√ß√£o ativadas. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/090/b54/70d/090b5470d7476d47c7212452716e9d11.gif" alt="imageEmulator Demo"></p><br><h1 id="demka-programmirovaniya">  Demonstra√ß√£o de programa√ß√£o </h1><br><p>  Esses v√≠deos foram filmados com uma c√¢mera de smartphone voltada para a tela CRT da TV, pe√ßo desculpas pela qualidade imperfeita da imagem. </p><br><p>  O int√©rprete BASIC program√°vel a partir do teclado PS / 2, ap√≥s o primeiro programa, mostro como gravar diretamente na mem√≥ria PPU atrav√©s do espa√ßo de endere√ßo de E / S, ativando e movendo o sprite: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/2UNjKx4uZGY" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Uma demonstra√ß√£o dos gr√°ficos, neste v√≠deo, programaticamente, fa√ßa o download de 64 sprites de 16x16, no contexto de um plano de fundo com rolagem din√¢mica e uma sobreposi√ß√£o que se move abaixo e acima dos sprites: </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/OA0q3_Krgxc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  A demonstra√ß√£o de som mostra os recursos do som YM3438 e PWM, os dados sonoros dessa demonstra√ß√£o, a m√∫sica FM e os sons PWM juntos ocupam quase todos os 128 kilobytes dispon√≠veis de mem√≥ria sonora. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/xDsTGmqxLzM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  Tetris, quase exclusivamente os recursos de fundo, m√∫sica no YM3438, efeitos sonoros nos patches PWM foram usados ‚Äã‚Äãpara gr√°ficos. </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/E77XZUwKd54" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h1 id="zaklyuchenie">  Conclus√£o </h1><br><p>  Este projeto √© realmente um sonho tornado realidade, eu trabalho nele h√° v√°rios anos, com interrup√ß√µes, olhando para o meu tempo livre, nunca pensei que fosse t√£o longe na cria√ß√£o do meu pr√≥prio console de videogame retro.  Naturalmente, n√£o √© perfeito, eu certamente n√£o sou um especialista em eletr√¥nica, obviamente havia muitos elementos no decodificador e, sem d√∫vida, algu√©m poderia fazer melhor e provavelmente alguns dos leitores est√£o pensando nisso. </p><br><p>  Mas ainda assim, no processo de trabalhar neste projeto, aprendi muito sobre eletr√¥nicos, consoles de jogos e design de computadores, linguagem assembly e outras coisas interessantes e, mais importante, recebi uma grande satisfa√ß√£o jogando jogos que eu mesmo escrevi em hardware que eu mesmo desenvolvi e coletado. </p><br><p>  Eu tenho planos para fazer consoles / computadores e muito mais.  Na verdade, j√° estou fazendo um novo decodificador, ele est√° quase pronto e √© um decodificador retro simplificado baseado em uma placa FPGA e em v√°rios componentes adicionais (em uma quantidade muito menor do que neste projeto, certamente), a ideia √© ser muito mais barata e repet√≠vel. </p><br><p>  Embora eu tenha escrito muito sobre esse projeto aqui, sem d√∫vida muito mais pode ser discutido, eu apenas mencionei como o mecanismo de som funciona, como a CPU interage com ele e muito mais pode ser feito sobre o sistema gr√°fico e outras entradas / sa√≠das e todo o console seria contar. </p><br><p>  Observando a rea√ß√£o dos leitores, posso escrever mais artigos com foco em atualiza√ß√µes, detalhes sobre blocos de prefixos individuais ou outros projetos. </p><br><h2 id="proekty-sayty-kanaly-youtube-kotorye-vdohnovlyali-menya-i-pomogali-mne-s-tehnicheskimi-znaniyami">  Projetos, sites, canais do Youtube que me inspiraram e me ajudaram com o conhecimento t√©cnico: </h2><br><p>  Esses sites / canais n√£o apenas inspiraram, mas tamb√©m me ajudaram a encontrar solu√ß√µes para problemas complexos que surgiram durante o trabalho neste projeto. </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Uzebox</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Ben ryves</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Retroleum</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Z80.info</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">EEVBlog</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Mec√¢nica de jogo retr√¥</a> </li></ul><br><p>  Obrigado por ler at√© aqui.  :) </p><br><p>  Se voc√™ tiver perguntas ou coment√°rios, escreva nos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">coment√°rios abaixo</a> (Artigo original em ingl√™s no Github. Aprox. Por.) </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt444006/">https://habr.com/ru/post/pt444006/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt443996/index.html">An√∫ncio do TypeScript 3.4 RC</a></li>
<li><a href="../pt443998/index.html">Novo recorde mundial para o c√°lculo do n√∫mero de pi: 31,4 trilh√µes de caracteres</a></li>
<li><a href="../pt444000/index.html">Por onde come√ßar ao contratar funcion√°rios pela primeira vez</a></li>
<li><a href="../pt444002/index.html">O primeiro assistente de voz ‚Äúneutro em g√™nero‚Äù do mundo apresentado no SXSW IT Festival</a></li>
<li><a href="../pt444004/index.html">CLRium # 5: Tudo sobre o GC e mais. Pedro e Moscou</a></li>
<li><a href="../pt444010/index.html">Imagens de cont√™iner do .NET Core agora publicadas no Registro de Cont√™iner da Microsoft</a></li>
<li><a href="../pt444014/index.html">Microsoft abre escola de neg√≥cios para aprender estrat√©gias, cultura e responsabilidade de IA</a></li>
<li><a href="../pt444016/index.html">Obtenha mais com o Microsoft Game Stack</a></li>
<li><a href="../pt444018/index.html">Como uma altera√ß√£o na configura√ß√£o do PostgreSQL melhora o desempenho lento da consulta 50 vezes</a></li>
<li><a href="../pt444020/index.html">Kart na URSS: como o hobby dos pilotos americanos se tornou um enorme hobby de bricolage na Uni√£o Sovi√©tica</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>