<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌕 👨🏾‍🚒 🤦🏿 Indexation de milliards de vecteurs de texte 💜 🆒 ☝️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Lors de l'extraction d'informations, la tâche se pose souvent de trouver de tels fragments de texte. Dans le cadre d'une recherche, une requête peut ê...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Indexation de milliards de vecteurs de texte</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/mailru/blog/479692/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/id/dd/fg/idddfg6zku7xq-zv9f0m8xemyiy.jpeg"></div><br>  Lors de l'extraction d'informations, la tâche se pose souvent de trouver de <i>tels</i> fragments de texte.  Dans le cadre d'une recherche, une requête peut être générée par l'utilisateur (par exemple, le texte que l'utilisateur saisit dans le moteur de recherche) ou par le système lui-même.  Souvent, nous devons faire correspondre une requête entrante avec des requêtes déjà indexées.  Dans cet article, nous verrons comment vous pouvez créer un système qui résout ce problème par rapport à des milliards de demandes sans dépenser une fortune sur l'infrastructure du serveur. <br><a name="habracut"></a><br>  Tout d'abord, nous définissons formellement le problème: <br><br><blockquote>  Étant donné un ensemble fixe de requêtes <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-2">Q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-1"> Q </script>  demande entrante <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-3"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4">q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-2"> q </script>  et entier <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-5"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6">k</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-3"> k </script>  .  Besoin de trouver un tel sous-ensemble de requêtes <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-7"><span class="noError" id="MJXp-Span-8" style="display: inline-block;">R&nbsp;=&nbsp;\&nbsp;left&nbsp;\&nbsp;{q0,&nbsp;q1,&nbsp;...,&nbsp;qk&nbsp;\&nbsp;right&nbsp;\}&nbsp;\&nbsp;sous-ensemble&nbsp;Q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-4"> R = \ left \ {q0, q1, ..., qk \ right \} \ sous-ensemble Q </script>  à chaque demande <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-9"><span class="MJXp-msubsup" id="MJXp-Span-10"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-11" style="margin-right: 0.05em;">q</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-12" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-13">i</span></span></span><span class="MJXp-mtext" id="MJXp-Span-14">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-15">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-16">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-17">R</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-5"> q_ {i} \ en R </script>  était plus comme <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-18"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-19">q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-6"> q </script>  que toute autre demande <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-20"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-21">Q</span><span class="MJXp-mo" id="MJXp-Span-22" style="margin-left: 0.267em; margin-right: 0.267em;">∖</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23">R</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-7"> Q ∖ R </script>  . </blockquote><br>  Par exemple, avec cet ensemble de requêtes <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-24"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-25">Q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-8"> Q </script>  : <br><br><pre><code class="plaintext hljs">{tesla cybertruck, beginner bicycle gear, eggplant dishes, tesla new car, how expensive is cybertruck, vegetarian food, shimano 105 vs ultegra, building a carbon bike, zucchini recipes}</code> </pre> <br>  et <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-26"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-27">k</span><span class="MJXp-mo" id="MJXp-Span-28" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mn" id="MJXp-Span-29">3</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-9"> k = 3 </script>  Vous pouvez vous attendre à ce résultat: <br><br><div class="scrollable-table"><table><tbody><tr><th>  Demande d'entrée <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-30"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-31">q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-10"> q </script><br></th><th>  Requêtes similaires <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-32"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-33">R</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-11"> R </script><br></th></tr><tr><td>  ramassage tesla <br></td><td>  {tesla cybertruck, tesla new car, combien coûte le cybertruck} <br></td></tr><tr><td>  meilleur vélo 2019 <br></td><td>  {shimano 105 vs ultegra, les vélos en carbone sont-ils meilleurs, l'équipement de vélo} <br></td></tr><tr><td>  cuisiner avec des légumes <br></td><td>  {plats d'aubergines, recettes de courgettes, plats végétariens} <br></td></tr></tbody></table></div><br>  Veuillez noter que nous n'avons pas encore défini de critère de <i>similitude</i> .  Dans ce contexte, cela peut signifier presque n'importe quoi, mais cela se résume généralement à une certaine forme de similitude basée sur des mots clés ou des vecteurs.  En utilisant la similitude basée sur les mots clés, nous pouvons trouver deux requêtes similaires si elles contiennent suffisamment de mots communs.  Par exemple, les requêtes «ouverture d'un restaurant à munich» et «meilleur restaurant de munich» sont similaires car elles contiennent les mots «restaurant» et «munich».  Et les requêtes «meilleur restaurant de munich» et «où manger à munich» sont déjà moins similaires, car elles n'ont qu'un seul mot commun.  Cependant, quelqu'un qui cherche un restaurant à Munich serait mieux si la deuxième paire de demandes s'avérait similaire.  Et en cela, nous allons aider la comparaison basée sur des vecteurs. <br><br><h1>  Représentation vectorielle des mots </h1><br>  La représentation vectorielle des mots est une technique d'apprentissage automatique utilisée dans le traitement du langage naturel pour convertir du texte ou des mots en vecteurs.  Déplacer la tâche dans l'espace vectoriel, nous pouvons utiliser des opérations mathématiques avec des vecteurs - additionner et calculer les distances.  Pour établir des liens entre des mots similaires, vous pouvez utiliser des méthodes traditionnelles de regroupement vectoriel.  <i>La signification de</i> ces opérations dans l'espace de mots d'origine n'est peut-être pas évidente, mais l'avantage est que nous avons maintenant accès à un large éventail d'outils mathématiques.  Si vous êtes intéressé par des détails sur les vecteurs de mots et leur application, lisez à propos de <a href="https://arxiv.org/pdf/1301.3781.pdf">word2vec</a> et <a href="https://nlp.stanford.edu/pubs/glove.pdf">GloVe</a> . <br><br>  Nous avons un moyen de générer des vecteurs à partir de mots, nous allons maintenant les collecter en vecteurs de texte (vecteurs de documents ou d'expressions).  La façon la plus simple de le faire est d'ajouter (ou de faire la moyenne) les vecteurs de tous les mots du texte. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/692/bc5/b0c/692bc5b0ccbbe7a89392528365645708.png"><br>  <i><sup>Figure 1: vecteurs de requête.</sup></i> <br><br>  Vous pouvez maintenant déterminer la similitude de deux morceaux de texte (ou requêtes) en les représentant dans l'espace vectoriel et en calculant la distance entre les vecteurs.  En règle générale, une distance angulaire est utilisée pour cela. <br><br>  Par conséquent, la représentation vectorielle des mots permet une correspondance textuelle d'un type différent, qui complète la correspondance basée sur des mots clés.  Vous pouvez explorer la similitude sémantique des demandes (par exemple, "meilleur restaurant de munich" et "où manger à munich"), comme nous ne pouvions pas le faire auparavant. <br><br><h1>  Recherche approximative du voisin le plus proche </h1><br>  Maintenant, nous pouvons affiner notre problème de correspondance de requête d'origine: <br><br><blockquote>  Étant donné un ensemble fixe de vecteurs de requête <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-34"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-35">Q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-12"> Q </script>  vecteur entrant <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-36"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-37">q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-13"> q </script>  et entier <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-38"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-39">k</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-14"> k </script>  .  Vous devez trouver un tel sous-ensemble de vecteurs <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-40"><span class="noError" id="MJXp-Span-41" style="display: inline-block;">R&nbsp;=&nbsp;\&nbsp;left&nbsp;\&nbsp;{q0,&nbsp;q1,&nbsp;...,&nbsp;qk&nbsp;\&nbsp;right&nbsp;\}&nbsp;\&nbsp;sous-ensemble&nbsp;Q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-15"> R = \ left \ {q0, q1, ..., qk \ right \} \ sous-ensemble Q </script>  de sorte que la distance angulaire de <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-42"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-43">q</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-16"> q </script>  à chaque vecteur <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-44"><span class="MJXp-msubsup" id="MJXp-Span-45"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-46" style="margin-right: 0.05em;">q</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-47" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-48">i</span></span></span><span class="MJXp-mtext" id="MJXp-Span-49">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-50">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-51">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-52">R</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-17-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-17"> q_ {i} \ en R </script>  était plus courte que la distance à tout autre vecteur <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-53"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-54">Q</span><span class="MJXp-mo" id="MJXp-Span-55" style="margin-left: 0.267em; margin-right: 0.267em;">∖</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-56">R</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-18-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-18"> Q ∖ R </script>  . </blockquote><br>  C'est ce qu'on appelle la tâche de trouver le plus proche voisin.  Il existe un <a href="https://ru.wikipedia.org/wiki/%25D0%2597%25D0%25B0%25D0%25B4%25D0%25B0%25D1%2587%25D0%25B0_%25D0%25BF%25D0%25BE%25D0%25B8%25D1%2581%25D0%25BA%25D0%25B0_%25D0%25B1%25D0%25BB%25D0%25B8%25D0%25B6%25D0%25B0%25D0%25B9%25D1%2588%25D0%25B5%25D0%25B3%25D0%25BE_%25D1%2581%25D0%25BE%25D1%2581%25D0%25B5%25D0%25B4%25D0%25B0">certain nombre d'algorithmes</a> pour sa solution rapide dans les espaces de faible dimension.  Mais lorsque nous travaillons avec des représentations vectorielles de mots, nous opérons généralement avec des vecteurs de haute dimension (100-1000 dimensions).  Et ici, les méthodes mentionnées ne fonctionnent plus. <br><br>  Il n'existe aucun moyen approprié de déterminer rapidement les voisins les plus proches dans des espaces de grande dimension.  Par conséquent, nous simplifions le problème en permettant l'utilisation de résultats approximatifs: au lieu de toujours renvoyer <i>les</i> vecteurs <i>les</i> plus proches, nous nous contenterons seulement de certains des voisins les plus proches ou <i>dans une certaine mesure</i> proches.  C'est ce qu'on appelle la recherche approximative de la tâche des voisins les plus proches et c'est un domaine de recherche active. <br><br><h3>  Petit monde hiérarchique </h3><br>  Le graphique hiérarchique du petit monde navigable ( <a href="https://arxiv.org/abs/1603.09320">HNSW</a> ) est l'un des algorithmes les plus rapides pour la recherche approximative des voisins les plus proches.  L'index de recherche dans HNSW est une structure à plusieurs niveaux dans laquelle chaque niveau est un graphe de proximité.  Chaque nœud de graphe correspond à l'un des vecteurs de requête. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/42e/55e/4b7/42e55e4b72cd088b45e5aff56159f7fb.png"><br>  <sup><i>Figure 2: Graphique de proximité à plusieurs niveaux.</i></sup> <br>  La recherche de voisins les plus proches dans HNSW utilise la méthode de zoom avant.  Il commence dans le nœud d'entrée du plus haut niveau et effectue récursivement une traversée de graphe gourmande à chaque niveau jusqu'à ce qu'il atteigne un minimum local en bas. <br><br>  Les détails sur l'algorithme et la technique de recherche sont bien décrits dans les travaux scientifiques.  Il est important de se rappeler que chaque cycle de recherche des voisins les plus proches consiste à parcourir les nœuds des graphes avec calcul des distances entre les vecteurs.  Nous examinerons ces étapes ci-dessous pour utiliser cette méthode pour créer un index à grande échelle. <br><br><h1>  La difficulté d'indexer des milliards de requêtes </h1><br>  Supposons que nous devons indexer 4 milliards de vecteurs de requête à 200 dimensions, chaque dimension étant représentée par un nombre à virgule flottante de quatre octets (4 milliards suffisent pour rendre la tâche intéressante, mais vous pouvez toujours stocker les ID de nœud dans des nombres normaux à quatre octets) .  Un calcul approximatif nous indique que la taille des vecteurs seuls sera d'environ 3 To.  Comme la plupart des bibliothèques existantes utilisent une capacité RAM pour une recherche approximative des voisins les plus proches, nous aurons besoin d'un très grand serveur pour pousser au moins des vecteurs dans la RAM.  Veuillez noter que cela ne prend pas en compte l'index de recherche supplémentaire, qui est nécessaire pour la plupart des méthodes. <br><br>  Dans toute l'histoire du développement de notre moteur de recherche, nous avons utilisé plusieurs approches différentes pour résoudre ce problème.  Examinons certains d'entre eux. <br><br><h3>  Sous-ensemble de données </h3><br>  La première et la plus simple approche, qui ne nous a pas permis de résoudre complètement le problème, a été de limiter le nombre de vecteurs dans l'indice.  En prenant un dixième des données, nous avons créé un index qui nécessite - surprise - 10% de mémoire.  Cependant, la qualité de la recherche s'est détériorée, car nous avons maintenant opéré avec moins de requêtes. <br><br><h3>  Quantification </h3><br>  Ici, nous avons utilisé toutes les données, mais nous les avons réduites en utilisant la <a href="https://ru.wikipedia.org/wiki/%25D0%259A%25D0%25B2%25D0%25B0%25D0%25BD%25D1%2582%25D0%25BE%25D0%25B2%25D0%25B0%25D0%25BD%25D0%25B8%25D0%25B5">quantification</a> (nous avons utilisé différentes techniques de quantification, par exemple, la quantification des produits, mais nous n'avons pas pu atteindre la qualité de travail souhaitée avec cette quantité de données).  En arrondissant certaines erreurs, nous avons pu remplacer tous les nombres à quatre octets dans les vecteurs d'origine par des versions quantifiées à un octet.  La quantité de RAM pour les vecteurs a diminué de 75%.  Cependant, nous avions encore besoin de 750 Go de mémoire (sans compter la taille de l'index lui-même), et c'est toujours un très grand serveur. <br><br><h1>  Résolution des problèmes de mémoire avec Granne </h1><br>  Les approches décrites avaient leurs avantages, mais elles nécessitaient beaucoup de ressources et donnaient une mauvaise qualité de recherche.  Bien <a href="http://ann-benchmarks.com/">qu'il existe des bibliothèques</a> qui répondent en moins de 1 ms, nous pourrions sacrifier la vitesse en échange d'exigences matérielles plus faibles. <br><br>  <a href="https://github.com/granne/granne">Granne</a> (graphique-based voisins les plus proches) est une bibliothèque HNSW développée et utilisée par Cliqz pour rechercher de telles requêtes.  Il a du code open source, mais la bibliothèque est toujours en développement actif.  Une version améliorée sera publiée sur <a href="https://crates.io/">crates.io</a> en 2020.  Il est écrit en rouille avec des inserts en Python, conçu pour gérer des milliards de vecteurs en utilisant la compétitivité.  Du point de vue des vecteurs de requête, il est intéressant de noter que Granne dispose d'un mode spécial qui nécessite beaucoup moins de mémoire par rapport aux autres bibliothèques. <br><br><h3>  Représentation compacte des vecteurs de requête </h3><br>  Réduire la taille des vecteurs de requête nous apportera de nombreux avantages.  Pour ce faire, revenons en arrière et envisageons de créer des vecteurs.  Étant donné que les requêtes sont composées de mots et que les vecteurs de requête sont des sommes de vecteurs de mots, nous pouvons explicitement refuser de stocker des vecteurs de requête et les calculer si nécessaire. <br><br>  Vous pouvez stocker des requêtes sous forme d'ensembles de mots et utiliser la table de recherche pour trouver les vecteurs correspondants.  Cependant, nous évitons la redirection en stockant chaque requête sous la forme d'une liste d'ID entiers correspondant aux vecteurs de mots dans la requête.  Par exemple, enregistrez la requête «meilleur restaurant de munich» sous <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-57"><span class="MJXp-mo" id="MJXp-Span-58" style="margin-left: 0em; margin-right: 0em;">[</span><span class="MJXp-mrow" id="MJXp-Span-59"><span class="MJXp-msubsup" id="MJXp-Span-60"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-61" style="margin-right: 0.05em;">i</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-62" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-63">b</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-64">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-65">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-66">t</span></span></span></span><span class="MJXp-mo" id="MJXp-Span-67" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mrow" id="MJXp-Span-68"><span class="MJXp-msubsup" id="MJXp-Span-69"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-70" style="margin-right: 0.05em;">i</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-71" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-72">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-73">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-74">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-75">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-76">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-77">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-78">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-79">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-80">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-81">t</span></span></span></span><span class="MJXp-mo" id="MJXp-Span-82" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mrow" id="MJXp-Span-83"><span class="MJXp-msubsup" id="MJXp-Span-84"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-85" style="margin-right: 0.05em;">i</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-86" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-87">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-88">f</span></span></span></span><span class="MJXp-mo" id="MJXp-Span-89" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mrow" id="MJXp-Span-90"><span class="MJXp-msubsup" id="MJXp-Span-91"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-92" style="margin-right: 0.05em;">i</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-93" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-94">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-95">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-96">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-97">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-98">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-99">h</span></span></span></span><span class="MJXp-mo" id="MJXp-Span-100" style="margin-left: 0em; margin-right: 0em;">]</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-19"> [{i_ {best}}, {i_ {restaurant}}, {i_ {of}}, {i_ {munich}}] </script>  où <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-101"><span class="MJXp-mrow" id="MJXp-Span-102"><span class="MJXp-msubsup" id="MJXp-Span-103"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-104" style="margin-right: 0.05em;">i</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-105" style="vertical-align: -0.4em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-106">b</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-107">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-108">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-109">t</span></span></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-20-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-20"> {i_ {best}} </script>  - c'est l'ID de vecteur du mot «meilleur», etc. Supposons que nous ayons moins de 16 millions de vecteurs de mots (plus que ce montant coûtera 1 octet par mot), alors vous pouvez utiliser 3 octets pour représenter tous les ID de mot.  Autrement dit, au lieu de stocker 800 octets (ou 200 octets dans le cas de vecteurs quantifiés), nous ne stockerons que 12 octets pour cette demande (ce n'est pas tout à fait vrai. Comme les demandes se composent d'un nombre différent de mots, nous devons également stocker l'offset de la liste dans l'index des mots. Pour cela nécessitera 5 octets par demande). <br><br>  Quant aux vecteurs de mots, nous en avons tous besoin.  Cependant, le nombre de mots est beaucoup plus petit que le nombre de requêtes pouvant être créées en combinant ces mots.  Et cela signifie que la taille des mots n'est pas si importante.  Si vous stockez des vecteurs de mots sous forme de versions à virgule flottante de quatre octets dans un tableau simple <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-110"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-111">v</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-21-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-21"> v </script>  , nous avons besoin de moins de 1 Go pour chaque million de mots.  Ce volume peut facilement tenir dans la RAM.  Maintenant, le vecteur de requête ressemble à ceci: <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-112"><span class="noError" id="MJXp-Span-113" style="display: inline-block;">{v&nbsp;_&nbsp;{{i_&nbsp;{best}}}}&nbsp;+&nbsp;{v&nbsp;_&nbsp;{{i_&nbsp;{restaurant}}}&nbsp;+&nbsp;{v&nbsp;_&nbsp;{{i_&nbsp;{of}}}&nbsp;+&nbsp;{v&nbsp;_&nbsp;{{i_&nbsp;{munich}}}}}</span></span></span><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-22-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-22"> {v _ {{i_ {best}}}} + {v _ {{i_ {restaurant}}} + {v _ {{i_ {of}}} + {v _ {{i_ {munich}}}}} </script>  . <br><br>  La taille finale de la soumission de la requête dépend du nombre total de mots dans la requête.  Pour 4 milliards de requêtes, cela représente environ 80 Go (y compris les vecteurs de mots).  En d'autres termes, par rapport aux vecteurs de mots d'origine, la taille a diminué de 97% et par rapport aux vecteurs quantifiés - de 90%. <br><br>  Et encore une chose.  Pour une recherche, nous devons visiter environ 200-300 nœuds du graphique.  Chaque nœud a 20 à 30 voisins.  Donc, nous devons calculer la distance entre le vecteur de requête d'entrée et les vecteurs 4000-9000 dans l'index.  Et de plus, nous devons générer des vecteurs.  Combien de temps faut-il pour créer des vecteurs de requête à la volée? <br><br>  Il s'avère qu'avec un processeur assez récent, ce problème peut être résolu en quelques millisecondes.  Une requête qui s'exécutait en 1 ms s'exécute maintenant en 5 ms environ.  Mais ensuite, nous avons réduit la quantité de mémoire pour les vecteurs de 90%.  Nous avons accepté avec plaisir un tel compromis. <br><br><h3>  Affichage en mémoire des vecteurs et index </h3><br>  Ci-dessus, nous avons résolu le problème de la réduction de la quantité de mémoire pour les vecteurs.  Mais après avoir résolu ce problème, la structure de l'indice elle-même est devenue un facteur limitant.  Vous devez maintenant réduire sa taille. <br><br>  À Granne, la structure du graphe est stockée de manière compacte sous la forme d'une liste d'adjacence avec un nombre variable de voisins pour chaque nœud.  Autrement dit, la mémoire n'est guère gaspillée en métadonnées.  La taille de la structure d'index dépend en grande partie des paramètres de conception et des propriétés du graphique.  Néanmoins, pour avoir une idée de la taille de l'index, il suffit de dire que nous pouvons construire un index pour 4 milliards de vecteurs avec une taille totale d'environ 240 Go.  Cela peut être acceptable pour une utilisation en mémoire sur un grand serveur, mais cela peut être mieux fait. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e73/daa/0de/e73daa0dea90e3e84afe9aaec7bd6a8e.jpg"><br>  <sup><i>Figure 3: Deux dispositions différentes en RAM et SSD.</i></sup> <br><br>  Une propriété importante de Granne est la possibilité d' <a href="https://ru.wikipedia.org/wiki/Mmap">afficher les</a> vecteurs d'index et de requête <a href="https://ru.wikipedia.org/wiki/Mmap">en mémoire</a> .  Cela nous permet de charger l'index paresseusement et de partager la mémoire avec plusieurs processus.  Les fichiers d'index et de requête sont divisés en fichiers d'affichage distincts en mémoire et peuvent être utilisés dans différentes dispositions en RAM et sur SSD.  Si les exigences pour le délai sont légèrement plus faibles, alors en plaçant l'index sur le SSD, les requêtes en RAM, nous maintenons une vitesse acceptable sans consommation excessive de mémoire.  À la fin de l'article, nous verrons à quoi ressemble ce compromis. <br><br><h3>  Amélioration de la localisation des données </h3><br>  Dans notre configuration actuelle, lorsque l'index est sur un SSD, chaque demande nécessite jusqu'à 200-300 lectures à partir du disque.  Vous pouvez essayer d'augmenter la localité des données en disposant les éléments dont les vecteurs sont si proches que leurs nœuds HNSW sont situés dans l'index également non loin les uns des autres.  La localisation des données améliore les performances, car une seule opération de lecture (généralement extraite de 4 Ko) est plus susceptible de contenir d'autres nœuds nécessaires pour parcourir le graphique.  Et cela, à son tour, réduit le nombre de récupérations de données par recherche. <br><br><img src="https://habrastorage.org/getpro/habr/post_images/1f8/1d2/2f4/1f81d22f418256c704bb12b7514e68a1.jpg"><br>  <sup><i>Figure 4: La localisation des données réduit la récupération d'informations.</i></sup> <br><br>  Il convient de noter que la réorganisation des éléments n'affecte pas les résultats de la recherche, c'est une façon de l'accélérer.  Autrement dit, l'ordre peut être quelconque, mais toutes les options n'accélèrent pas la recherche.  Il est très difficile de trouver l'ordre optimal.  Cependant, l'heuristique que nous avons utilisée avec succès est de trier les requêtes par le mot le plus <i>important</i> dans chaque requête. <br><br><h1>  Conclusion </h1><br>  Nous utilisons Granne pour créer et maintenir des index de plusieurs milliards de dollars avec des vecteurs de requête afin de rechercher des requêtes similaires avec une consommation de mémoire relativement faible.  Le tableau ci-dessous montre les exigences pour différentes méthodes.  Soyez sceptique quant aux valeurs absolues des retards pendant la recherche, car ils dépendent fortement de ce qui est considéré comme une réponse acceptable.  Cependant, ces informations décrivent les performances relatives des méthodes. <br><br><div class="scrollable-table"><table><tbody><tr><th></th><th>  Valeur initiale <br></th><th>  Quantification <br></th><th>  Granne (RAM uniquement) <br></th><th>  Granne (RAM + SSD) <br></th></tr><tr><td>  <b>La mémoire</b> <br></td><td>  3000 + 240 Go <br></td><td>  750 + 240 Go <br></td><td>  80 + 240 Go <br></td><td>  80-150 Go * <br></td></tr><tr><td>  <b>SSD</b> <br></td><td>  - </td><td>  - </td><td>  - </td><td>  240 Go <br></td></tr><tr><td>  <b>Retard</b> <br></td><td>  1 ms <br></td><td>  1 ms <br></td><td>  5 ms <br></td><td>  10-50 ms <br></td></tr></tbody></table></div><br>  <i>* L'allocation d'un index mémoire supérieur à la quantité requise a conduit à la mise en cache de certains nœuds (fréquemment visités), ce qui a réduit le retard dans la recherche.</i>  <i>Aucun cache interne n'a été utilisé pour cela, uniquement des outils de système d'exploitation internes (noyau Linux).</i> <br><br>  Il convient de noter que certaines des optimisations mentionnées dans l'article ne sont pas applicables pour résoudre le problème général de trouver des voisins les plus proches avec des vecteurs indécomposables.  Cependant, ils sont applicables dans toutes les situations où des éléments peuvent être générés à partir de moins de pièces (comme c'est le cas avec les mots et les requêtes).  Sinon, vous pouvez toujours utiliser Granne avec les vecteurs sources, cela prend juste plus de mémoire, comme avec les autres bibliothèques. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr479692/">https://habr.com/ru/post/fr479692/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr479682/index.html">Rapport d'utilisation des conteneurs Sysdig 2019: nouveaux Kubernetes et détails de sécurité</a></li>
<li><a href="../fr479684/index.html">Comment collecter des clés basse fréquence pour le référencement: 4 façons non triviales</a></li>
<li><a href="../fr479686/index.html">Tendances clés de l'externalisation informatique après 2020</a></li>
<li><a href="../fr479688/index.html">Dans quels pays et villes les développeurs gagnent-ils plus si l'on considère les taxes et le coût de la vie?</a></li>
<li><a href="../fr479690/index.html">Zork et Z-Machine: comment les développeurs ont transféré le jeu des mainframes aux ordinateurs personnels 8 bits</a></li>
<li><a href="../fr479696/index.html">Quelques mots sur Alter Table, ou comment ne pas le faire</a></li>
<li><a href="../fr479700/index.html">CIMON-2: (un) Doomsday, ou comment IBM Watson a grimpé au-dessus des nuages</a></li>
<li><a href="../fr479702/index.html">Toaster, My Circle et Freelansim font partie de Habr</a></li>
<li><a href="../fr479704/index.html">Escalade de privilèges dans le client EA Origin Windows (CVE-2019-19247 et CVE-2019-19248)</a></li>
<li><a href="../fr479708/index.html">Article non officiel sur le changement de marque de Habr + Competition</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>