<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòû üíáüèª üåú Turmverteidigung in Einheit schaffen: Feinde üò∏ üò£ üç•</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="[ Erster Teil: Fliesen und den Weg finden ] 



- Platzierung feindlicher Sch√∂pfungspunkte. 
- Das Erscheinen von Feinden und ihre Bewegung √ºber das F...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Turmverteidigung in Einheit schaffen: Feinde</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/452756/">  <i>[ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Erster Teil: Fliesen und den Weg finden</a> ]</i> <br><br><ul><li>  Platzierung feindlicher Sch√∂pfungspunkte. </li><li>  Das Erscheinen von Feinden und ihre Bewegung √ºber das Feld. </li><li>  Gleichm√§√üige Bewegung mit konstanter Geschwindigkeit. </li><li>  √Ñndere die Gr√∂√üe, Geschwindigkeit und Platzierung von Feinden. </li></ul><br>  Dies ist der zweite Teil eines Tutorials zu einem einfachen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Tower Defense-</a> Spiel.  Es untersucht den Prozess der Schaffung von Feinden und deren Bewegung zum n√§chsten Endpunkt. <br><br>  Dieses Tutorial wurde in Unity 2018.3.0f2 erstellt. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2db/cf3/311/2dbcf331117740aa403cb12a757ae6fd.jpg" width="512" height="256"></div><br>  <i>Feinde auf dem Weg zum Endpunkt.</i> <br><a name="habracut"></a><br><h2>  Punkte der feindlichen Sch√∂pfung (Spawn) </h2><br>  Bevor wir anfangen, Feinde zu erschaffen, m√ºssen wir entscheiden, wo wir sie auf dem Spielfeld platzieren sollen.  Dazu erstellen wir Spawnpunkte. <br><br><h3>  Kachelinhalt </h3><br>  Ein Spawnpunkt ist eine andere Art von <code>GameTileContentType</code> . <code>GameTileContentType</code> Sie daher einen Eintrag in <code>GameTileContentType</code> . <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> GameTileContentType { Empty, Destination, Wall, SpawnPoint }</code> </pre> <br>  Und dann erstellen Sie ein Fertighaus, um es zu visualisieren.  Ein Duplikat des Fertighauses des Startpunkts ist f√ºr uns durchaus geeignet. √Ñndern Sie einfach die Art des Inhalts und geben Sie ihm ein anderes Material.  Ich habe es orange gemacht. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e39/522/28d/e3952228dacd6801a6f5d2fb53826cc2.png" width="320" height="104"></div><br>  <i>Spawnpunktkonfiguration.</i> <br><br>  F√ºgen Sie der Content Factory Unterst√ºtzung f√ºr Spawnpunkte hinzu und verkn√ºpfen Sie sie mit dem Fertighaus. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] GameTileContent spawnPointPrefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTileContent </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTileContentType type</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (type) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Destination: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(destinationPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Empty: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(emptyPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.Wall: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(wallPrefab); <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> GameTileContentType.SpawnPoint: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Get(spawnPointPrefab); } Debug.Assert(<span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-string"><span class="hljs-string">"Unsupported type: "</span></span> + type); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/10f/036/a17/10f036a17ae271cf7b7f7c9694e01782.png" width="320" height="142"></div><br>  <i>Fabrik mit Unterst√ºtzung f√ºr Spawnpunkte.</i> <br><br><h3>  Spawnpunkte aktivieren oder deaktivieren </h3><br>  Die Methode zum Umschalten des <code>GameBoard</code> wird wie bei anderen Umschaltmethoden dem <code>GameBoard</code> .  Spawnpunkte wirken sich jedoch nicht auf die Suche nach dem Pfad aus, sodass wir nach der √Ñnderung nicht nach neuen Pfaden suchen m√ºssen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleSpawnPoint</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.SpawnPoint) { tile.Content = contentFactory.Get(GameTileContentType.Empty); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.SpawnPoint); } }</code> </pre> <br>  Das Spiel macht nur Sinn, wenn wir Feinde haben und diese Spawnpunkte ben√∂tigen.  Daher muss das Spielfeld mindestens einen Spawnpunkt enthalten.  Wir werden in Zukunft auch Zugriff auf die Spawnpunkte ben√∂tigen, wenn wir Feinde hinzuf√ºgen. Verwenden wir also die Liste, um alle Kacheln mit diesen Punkten zu verfolgen.  Wir werden die Liste aktualisieren, wenn wir den Status des Spawnpunkts √§ndern und verhindern, dass der letzte Spawnpunkt entfernt wird. <br><br><pre> <code class="cs hljs"> List&lt;GameTile&gt; spawnPoints = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;GameTile&gt;(); ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToggleSpawnPoint</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.SpawnPoint) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (spawnPoints.Count &gt; <span class="hljs-number"><span class="hljs-number">1</span></span>) { spawnPoints.Remove(tile); tile.Content = contentFactory.Get(GameTileContentType.Empty); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile.Content.Type == GameTileContentType.Empty) { tile.Content = contentFactory.Get(GameTileContentType.SpawnPoint); spawnPoints.Add(tile); } }</code> </pre> <br>  Die <code>Initialize</code> Methode sollte jetzt den Spawnpunkt festlegen, um den anf√§nglichen korrekten Status des Feldes zu erstellen.  F√ºgen wir einfach die erste Kachel ein, die sich in der unteren linken Ecke befindet. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Vector2Int size, GameTileContentFactory contentFactory </span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ ToggleDestination(tiles[tiles.Length / <span class="hljs-number"><span class="hljs-number">2</span></span>]); ToggleSpawnPoint(tiles[<span class="hljs-number"><span class="hljs-number">0</span></span>]); }</code> </pre> <br>  Wir werden jetzt den Status der <code>Input.GetKey</code> , aber wenn Sie die linke Umschalttaste gedr√ºckt halten (der Tastenanschlag wird von der <code>Input.GetKey</code> Methode √ºberpr√ºft), wechselt der Status des Endpunkts <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleAlternativeTouch</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile tile = board.GetTile(TouchRay); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tile != <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Input.GetKey(KeyCode.LeftShift)) { board.ToggleDestination(tile); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { board.ToggleSpawnPoint(tile); } } }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2f9/cd6/22b/2f9cd622bf1aa41023e5204e1f4caa9a.png" width="230" height="230"></div><br>  <i>Feld mit Spawnpunkten.</i> <br><br><h3>  Erhalte Zugang zu Spawnpunkten </h3><br>  Das Feld befasst sich mit all seinen Kacheln, aber Feinde sind nicht seine Verantwortung.  Wir werden es erm√∂glichen, √ºber die gemeinsame <code>GetSpawnPoint</code> Methode mit einem Indexparameter auf seine <code>GetSpawnPoint</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetSpawnPoint</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> index</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> spawnPoints[index]; }</code> </pre> <br>  Um zu wissen, welche Indizes korrekt sind, werden Informationen zur Anzahl der Spawnpunkte ben√∂tigt. Daher werden wir sie mithilfe der allgemeinen Getter-Eigenschaft allgemein machen. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> SpawnPointCount =&gt; spawnPoints.Count;</code> </pre> <br><h2>  Feindliche Brut </h2><br>  Das Laichen eines Feindes √§hnelt dem Erstellen des Inhalts eines Pl√§ttchens.  Wir erstellen eine vorgefertigte Instanz durch die Fabrik, die wir dann auf dem Feld platzieren. <br><br><h3>  Fabriken </h3><br>  Wir werden eine Fabrik f√ºr Feinde schaffen, die alles, was sie schafft, auf ihre eigene B√ºhne stellt.  Diese Funktionalit√§t ist in der bereits vorhandenen Factory √ºblich. <code>GameObjectFactory</code> wir den Code daf√ºr in die allgemeine Basisklasse <code>GameObjectFactory</code> .  Wir ben√∂tigen nur eine <code>CreateGameObjectInstance</code> Methode mit einem gemeinsamen Prefab-Parameter, der eine Instanz erstellt und zur√ºckgibt und auch die gesamte Szene verwaltet.  Wir machen die <code>protected</code> Methode, das hei√üt, sie wird nur der Klasse und allen Typen zur Verf√ºgung stehen, die von ihr erben.  Das ist alles, was die Klasse tut, es ist nicht als voll funktionsf√§hige Fabrik gedacht.  Daher markieren wir es als <code>abstract</code> , wodurch wir keine Instanzen seiner Objekte erstellen k√∂nnen. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine.SceneManagement; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">abstract</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameObjectFactory</span></span> : <span class="hljs-title"><span class="hljs-title">ScriptableObject</span></span> { Scene scene; <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> T CreateGameObjectInstance&lt;T&gt; (T prefab) <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> T : MonoBehaviour { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!scene.isLoaded) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (Application.isEditor) { scene = SceneManager.GetSceneByName(name); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!scene.isLoaded) { scene = SceneManager.CreateScene(name); } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { scene = SceneManager.CreateScene(name); } } T instance = Instantiate(prefab); SceneManager.MoveGameObjectToScene(instance.gameObject, scene); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; } }</code> </pre> <br>  √Ñndern Sie die <code>GameTileContentFactory</code> so, dass sie diese Art von Factory <code>GameTileContentFactory</code> und <code>CreateGameObjectInstance</code> in ihrer <code>Get</code> Methode verwendet, und entfernen Sie dann den Szenensteuerungscode daraus. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [CreateAssetMenu] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">GameTileContentFactory</span></span> : <span class="hljs-title"><span class="hljs-title">GameObjectFactory</span></span> { ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">//Scene contentScene; ‚Ä¶ GameTileContent Get (GameTileContent prefab) { GameTileContent instance = CreateGameObjectInstance(prefab); instance.OriginFactory = this; //MoveToFactoryScene(instance.gameObject); return instance; } //void MoveToFactoryScene (GameObject o) { // ‚Ä¶ //} }</span></span></code> </pre> <br>  Erstellen Sie anschlie√üend einen neuen <code>EnemyFactory</code> Typ, der mithilfe der <code>Get</code> Methode und der zugeh√∂rigen <code>Reclaim</code> Methode eine Instanz eines <code>Enemy</code> Fertighauses erstellt. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [CreateAssetMenu] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemyFactory</span></span> : <span class="hljs-title"><span class="hljs-title">GameObjectFactory</span></span> { [SerializeField] Enemy prefab = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Enemy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Enemy instance = CreateGameObjectInstance(prefab); instance.OriginFactory = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Reclaim</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Enemy enemy</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(enemy.OriginFactory == <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>, <span class="hljs-string"><span class="hljs-string">"Wrong factory reclaimed!"</span></span>); Destroy(enemy.gameObject); } }</code> </pre> <br>  Der neue <code>Enemy</code> Typ musste zun√§chst nur die urspr√ºngliche Fabrik im <code>Enemy</code> behalten. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Enemy</span></span> : <span class="hljs-title"><span class="hljs-title">MonoBehaviour</span></span> { EnemyFactory originFactory; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> EnemyFactory OriginFactory { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> =&gt; originFactory; <span class="hljs-keyword"><span class="hljs-keyword">set</span></span> { Debug.Assert(originFactory == <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Redefined origin factory!"</span></span>); originFactory = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } } }</code> </pre> <br><h3>  Fertighaus </h3><br>  Feinde brauchen eine Visualisierung, die alles sein kann - ein Roboter, eine Spinne, ein Geist, etwas Einfacheres, zum Beispiel ein W√ºrfel, den wir verwenden.  Im Allgemeinen verf√ºgt der Feind jedoch √ºber ein 3D-Modell beliebiger Komplexit√§t.  Um die bequeme Unterst√ºtzung zu gew√§hrleisten, verwenden wir das Stammobjekt f√ºr die vorgefertigte feindliche Hierarchie, an die nur die <code>Enemy</code> Komponente angeh√§ngt ist. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7c6/348/428/7c6348428b50732e0a13efcdadfc9fff.png" width="320" height="160"></div><br>  <i>Fertige Wurzel</i> <br><br>  Erstellen wir dieses Objekt als einziges untergeordnetes Element, das die Wurzel des Modells bildet.  Es muss Werte f√ºr Transformationseinheiten haben. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ce7/691/330/ce7691330dd6c6813d2a64398c582c2a.png" width="320" height="120"></div><br>  <i>Die Wurzel des Modells.</i> <br><br>  Die Aufgabe dieser Modellwurzel besteht darin, das 3D-Modell relativ zum lokalen Ursprungspunkt der feindlichen Koordinaten zu positionieren, sodass er es als Referenzpunkt betrachtet, √ºber dem der Feind steht oder h√§ngt.  In unserem Fall ist das Modell ein Standardw√ºrfel in halber Gr√∂√üe, dem ich eine dunkelblaue Farbe geben werde.  Wir machen es zu einem Kind der Modellwurzel und setzen die Y-Position auf 0,25, so dass es auf dem Boden steht. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/65b/7a3/808/65b7a3808f469e2723b344afccd94f8f.png" width="320" height="206"></div><br>  <i>W√ºrfelmodell</i> <br><br>  Das Fertighaus des Feindes besteht also aus drei verschachtelten Objekten: der Fertighauswurzel, der Modellwurzel und dem W√ºrfel.  Es mag wie eine B√ºste f√ºr einen einfachen W√ºrfel erscheinen, aber mit einem solchen System k√∂nnen Sie jeden Feind bewegen und animieren, ohne sich um seine Eigenschaften sorgen zu m√ºssen. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/62a/0c9/abb/62a0c9abb59605150235ba6cec73eeb2.png" width="225" height="74"></div><br>  <i>Die Fertighierarchie des Feindes.</i> <br><br>  Erstellen wir eine feindliche Fabrik und weisen ihr ein Fertighaus zu. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ae3/ee2/345/ae3ee23456931ac6f989a763deb8b7b1.png" width="320" height="88"></div><br>  <i>Asset Factory.</i> <br><br><h3>  Feinde auf das Spielfeld bringen </h3><br>  Um Feinde auf das Spielfeld zu bringen, muss das <code>Game</code> einen Link zur Fabrik der Feinde erhalten.  Da wir viele Feinde ben√∂tigen, f√ºgen wir eine Konfigurationsoption hinzu, um die Laichgeschwindigkeit anzupassen, ausgedr√ºckt in der Anzahl der Feinde pro Sekunde.  Ein akzeptabler Bereich ist 0,1‚Äì10 mit einem Standardwert von 1. <br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] EnemyFactory enemyFactory = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; [SerializeField, Range(<span class="hljs-number"><span class="hljs-number">0.1f</span></span>, <span class="hljs-number"><span class="hljs-number">10f</span></span>)] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> spawnSpeed = <span class="hljs-number"><span class="hljs-number">1f</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/201/56b/338/20156b3384b45ab95d7aef5ed5397480.png" width="320" height="144"></div><br>  <i>Spiel mit einer feindlichen Fabrik und Laichgeschwindigkeit 4.</i> <br><br>  Wir werden den Fortschritt des Laichens in <code>Update</code> verfolgen und ihn um die Geschwindigkeit mal die Deltazeit erh√∂hen.  Wenn der Prggress-Wert 1 √ºberschreitet, dekrementieren wir ihn und spawnen den Feind mit der neuen <code>SpawnEnemy</code> Methode.  Wir machen so lange weiter, bis der Fortschritt 1 √ºberschreitet, falls die Geschwindigkeit zu hoch und die Frame-Zeit sehr lang ist, so dass nicht mehrere Feinde gleichzeitig erstellt werden. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> spawnProgress; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ spawnProgress += spawnSpeed * Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (spawnProgress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { spawnProgress -= <span class="hljs-number"><span class="hljs-number">1f</span></span>; SpawnEnemy(); } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Ist es nicht notwendig, den Fortschritt in FixedUpdate zu aktualisieren?</b> <div class="spoiler_text">  Ja, es ist m√∂glich, aber f√ºr das Tower Defense-Spiel werden keine so genauen Timings ben√∂tigt.  Wir werden einfach den Status des Spiels in jedem Frame aktualisieren und daf√ºr sorgen, dass es f√ºr jedes Zeitdelta gut genug funktioniert. </div></div><br>  Lass <code>SpawnEnemy</code> einen zuf√§lligen <code>SpawnEnemy</code> vom Spielfeld erhalten und einen Feind in diesem Pl√§ttchen erschaffen.  Wir werden <code>Enemy</code> die <code>SpawnOn</code> Methode geben, um sich richtig zu <code>SpawnOn</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnEnemy</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { GameTile spawnPoint = board.GetSpawnPoint(Random.Range(<span class="hljs-number"><span class="hljs-number">0</span></span>, board.SpawnPointCount)); Enemy enemy = enemyFactory.Get(); enemy.SpawnOn(spawnPoint); }</code> </pre> <br>  Im <code>SpawnOn</code> muss <code>SpawnOn</code> nur seine eigene Position gleich der Mitte der Kachel setzen.  Da das Fertigmodell korrekt positioniert ist, befindet sich der feindliche W√ºrfel oben auf diesem Pl√§ttchen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnOn</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { transform.localPosition = tile.transform.localPosition; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b5/74a/ce9/8b574ace93bd2c7f7829d41f9208a138.png" width="230" height="230"></div><br>  <i>Gegner erscheinen an Spawnpunkten.</i> <br><br><h2>  Feinde bewegen </h2><br>  Nachdem der Feind aufgetaucht ist, muss er beginnen, sich auf dem Weg zum n√§chsten Endpunkt zu bewegen.  Um dies zu erreichen, m√ºssen Sie Feinde animieren.  Wir beginnen mit einem einfachen sanften Gleiten von Kachel zu Kachel und erschweren dann deren Bewegung. <br><br><h3>  Sammlung von Feinden </h3><br>  Um den Status von Feinden zu aktualisieren, verwenden wir denselben Ansatz wie in der Tutorials-Reihe " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Objektverwaltung"</a> .  Wir f√ºgen <code>Enemy</code> allgemeine <code>GameUpdate</code> Methode hinzu, die Informationen dar√ºber zur√ºckgibt, ob er lebt, was zu diesem Zeitpunkt immer der Fall sein wird.  Lassen Sie ihn vorerst nur entsprechend dem Delta der Zeit vorw√§rts gehen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { transform.localPosition += Vector3.forward * Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Au√üerdem m√ºssen wir eine Liste lebender Feinde f√ºhren und alle aktualisieren, um sie von der Liste der toten Feinde zu entfernen.  Wir k√∂nnen den gesamten Code in ein <code>Game</code> einf√ºgen, ihn jedoch isolieren und einen <code>EnemyCollection</code> Typ erstellen.  Dies ist eine serialisierbare Klasse, die von nichts erbt.  Wir geben ihm eine allgemeine Methode zum Hinzuf√ºgen eines Feindes und eine andere Methode zum Aktualisieren der gesamten Sammlung. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Collections.Generic; [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">EnemyCollection</span></span> { List&lt;Enemy&gt; enemies = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;Enemy&gt;(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Add</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Enemy enemy</span></span></span><span class="hljs-function">)</span></span> { enemies.Add(enemy); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; enemies.Count; i++) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!enemies[i].GameUpdate()) { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> lastIndex = enemies.Count - <span class="hljs-number"><span class="hljs-number">1</span></span>; enemies[i] = enemies[lastIndex]; enemies.RemoveAt(lastIndex); i -= <span class="hljs-number"><span class="hljs-number">1</span></span>; } } } }</code> </pre> <br>  Jetzt reicht das <code>Game</code> aus, um nur eine solche Sammlung zu erstellen, sie in jedem Frame zu aktualisieren und erstellte Feinde hinzuzuf√ºgen.  Wir werden die Feinde sofort nach dem m√∂glichen Laichen eines neuen Feindes aktualisieren, so dass die Aktualisierung sofort erfolgt. <br><br><pre> <code class="cs hljs"> EnemyCollection enemies = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> EnemyCollection(); ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Update</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ enemies.GameUpdate(); } ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnEnemy</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ enemies.Add(enemy); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/25f/eb8/dc6/25feb8dc6f0d3a5a66be43f311cd7818.png" width="230" height="230"></div><br>  <i>Feinde bewegen sich vorw√§rts.</i> <br><br><h3>  Bewegung auf dem Weg </h3><br>  Feinde bewegen sich bereits, folgen aber bisher nicht dem Weg.  Dazu m√ºssen sie wissen, wohin sie als n√§chstes gehen m√ºssen.  Geben Sie <code>GameTile</code> gemeinsame Getter-Eigenschaft, um die n√§chste Kachel auf dem Pfad <code>GameTile</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> GameTile NextTileOnPath =&gt; nextOnPath;</code> </pre> <br>  Wenn die Feinde die Kachel kennen, von der Sie aussteigen m√∂chten, und die Kachel, in die Sie gelangen m√ºssen, k√∂nnen Sie den Start- und Endpunkt bestimmen, um eine Kachel zu bewegen.  Der Feind kann die Position zwischen diesen beiden Punkten interpolieren und ihre Bewegung verfolgen.  Nachdem der Umzug abgeschlossen ist, wird dieser Vorgang f√ºr die n√§chste Kachel wiederholt.  Die Wege k√∂nnen sich aber jederzeit √§ndern.  Anstatt zu bestimmen, wohin wir uns im Verlauf der Bewegung weiter bewegen sollen, bewegen wir uns einfach weiter entlang der geplanten Route und √ºberpr√ºfen sie, bis wir die n√§chste Kachel erreichen. <br><br>  Lassen Sie <code>Enemy</code> beide Kacheln verfolgen, damit sie nicht von einer Pfad√§nderung betroffen sind.  Er wird auch Positionen verfolgen, damit wir sie nicht in jedem Frame empfangen m√ºssen, und den Bewegungsprozess verfolgen. <br><br><pre> <code class="cs hljs"> GameTile tileFrom, tileTo; Vector3 positionFrom, positionTo; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> progress;</code> </pre> <br>  Initialisieren Sie diese Felder in <code>SpawnOn</code> .  Der erste Punkt ist das Pl√§ttchen, von dem aus sich der Feind bewegt, und der Endpunkt ist das n√§chste Pl√§ttchen auf dem Weg.  Dies setzt voraus, dass das n√§chste Pl√§ttchen existiert, es sei denn, der Feind wurde am Endpunkt erstellt, was unm√∂glich sein sollte.  Dann zwischenspeichern wir die Positionen der Kacheln und setzen den Fortschritt zur√ºck.  Wir m√ºssen hier nicht die Position des Feindes <code>GameUpdate</code> , da seine <code>GameUpdate</code> Methode im selben Frame aufgerufen wird. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnOn</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">//transform.localPosition = tile.transform.localPosition; Debug.Assert(tile.NextTileOnPath != null, "Nowhere to go!", this); tileFrom = tile; tileTo = tile.NextTileOnPath; positionFrom = tileFrom.transform.localPosition; positionTo = tileTo.transform.localPosition; progress = 0f; }</span></span></code> </pre> <br>  Das Fortschrittsinkrement wird in <code>GameUpdate</code> .  F√ºgen wir ein konstantes Zeitdelta hinzu, damit sich die Feinde mit einer Geschwindigkeit von einem Pl√§ttchen pro Sekunde bewegen.  Wenn der Fortschritt abgeschlossen ist, verschieben wir die Daten so, dass <code>To</code> zum Wert <code>From</code> wird und das neue <code>To</code> die n√§chste Kachel auf dem Pfad ist.  Dann verringern wir den Fortschritt.  Wenn die Daten relevant werden, interpolieren wir die Position des Feindes zwischen <code>From</code> und <code>To</code> .  Da der Interpolator ein Fortschritt ist, liegt sein Wert notwendigerweise im Bereich von 0 und 1, sodass wir s <code>Vector3.LerpUnclamped</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { progress += Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (progress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { tileFrom = tileTo; tileTo = tileTo.NextTileOnPath; positionFrom = positionTo; positionTo = tileTo.transform.localPosition; progress -= <span class="hljs-number"><span class="hljs-number">1f</span></span>; } transform.localPosition = Vector3.LerpUnclamped(positionFrom, positionTo, progress); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br>  Dies zwingt die Feinde, dem Pfad zu folgen, wirkt jedoch nicht, wenn sie den Endpunkt erreichen.  Bevor Sie die Positionen von <code>From</code> und <code>To</code> √§ndern, m√ºssen Sie daher die n√§chste Kachel auf dem Pfad mit <code>null</code> .  Wenn ja, dann haben wir den Endpunkt erreicht und der Feind hat die Bewegung beendet.  Wir f√ºhren Reclaim daf√ºr aus und geben <code>false</code> . <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (progress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { tileFrom = tileTo; tileTo = tileTo.NextTileOnPath; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tileTo == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { OriginFactory.Reclaim(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span>; } positionFrom = positionTo; positionTo = tileTo.transform.localPosition; progress -= <span class="hljs-number"><span class="hljs-number">1f</span></span>; }</code> </pre> <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Feinde folgen dem k√ºrzesten Weg.</i> <br><br>  Feinde bewegen sich jetzt von der Mitte eines Pl√§ttchens zum anderen.  Es ist zu bedenken, dass sie ihren Bewegungszustand nur in der Mitte der Kacheln √§ndern und daher nicht sofort auf √Ñnderungen im Feld reagieren k√∂nnen.  Dies bedeutet, dass sich manchmal Feinde durch die gerade gesetzten W√§nde bewegen.  Sobald sie sich auf die Zelle zubewegen, wird sie nichts mehr aufhalten.  Deshalb brauchen Mauern auch echte Wege. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Feinde reagieren auf wechselnde Pfade.</i> <br><br><h3>  Bewegung von Kante zu Kante </h3><br>  Die Bewegung zwischen den Kachelmitte und ein scharfer Richtungswechsel sehen f√ºr ein abstraktes Spiel, bei dem die Feinde W√ºrfel bewegen, normal aus, aber normalerweise sieht die sanfte Bewegung sch√∂ner aus.  Der erste Schritt zu seiner Implementierung besteht nicht darin, sich entlang der Zentren zu bewegen, sondern entlang der Kanten der Kacheln. <br><br>  Der Randpunkt zwischen benachbarten Kacheln kann durch Mitteln ihrer Positionen ermittelt werden.  Anstatt es bei jedem Schritt f√ºr jeden Feind zu berechnen, berechnen wir es nur, wenn wir den Pfad in <code>GameTile.GrowPathTo</code> .  <code>ExitPoint</code> Sie es mithilfe der <code>ExitPoint</code> Eigenschaft zur Verf√ºgung. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Vector3 ExitPoint { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } ‚Ä¶ <span class="hljs-function"><span class="hljs-function">GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ neighbor.ExitPoint = (neighbor.transform.localPosition + transform.localPosition) * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> neighbor.Content.Type != GameTileContentType.Wall ? neighbor : <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Der einzige Sonderfall ist die letzte Zelle, deren Ausgangspunkt der Mittelpunkt sein wird. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BecomeDestination</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { distance = <span class="hljs-number"><span class="hljs-number">0</span></span>; nextOnPath = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; ExitPoint = transform.localPosition; }</code> </pre> <br>  √Ñndern Sie <code>Enemy</code> so, dass Ausgangspunkte und keine Kachelzentren verwendet werden. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { progress += Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (progress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { ‚Ä¶ positionTo = tileFrom.ExitPoint; progress -= <span class="hljs-number"><span class="hljs-number">1f</span></span>; } transform.localPosition = Vector3.Lerp(positionFrom, positionTo, progress); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnOn</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ positionTo = tileFrom.ExitPoint; progress = <span class="hljs-number"><span class="hljs-number">0f</span></span>; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Feinde bewegen sich zwischen den R√§ndern.</i> <br><br>  Ein Nebeneffekt dieser √Ñnderung ist, dass Feinde, die sich aufgrund einer √Ñnderung des Pfades drehen, eine Sekunde lang bewegungslos bleiben. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  <i>Beim Drehen h√∂ren die Feinde auf.</i> <br><br><h3>  Orientierung </h3><br>  Obwohl sich die Feinde auf den Wegen bewegen, bis sie ihre Ausrichtung √§ndern.  Damit sie in die Bewegungsrichtung schauen k√∂nnen, m√ºssen sie die Richtung des Pfades kennen, dem sie folgen.  Wir werden dies auch bei der Suche nach Wegen feststellen, damit dies nicht von den Feinden getan werden muss. <br><br>  Wir haben vier Richtungen: Nord, Ost, S√ºd und West.  Z√§hlen wir sie auf. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Direction { North, East, South, West }</code> </pre> <br>  Dann geben wir die <code>GameTile</code> Eigenschaft an, um die Richtung ihres Pfades zu speichern. <br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Direction PathDirection { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; }</code> </pre> <br>  F√ºgen Sie <code>GrowTo</code> einen Richtungsparameter <code>GrowTo</code> , der die Eigenschaft festlegt.  Da wir einen Weg von Ende zu Anfang wachsen, ist die Richtung entgegengesetzt zu der Richtung, von der aus wir den Weg wachsen. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathNorth</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(north, Direction.South); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathEast</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(east, Direction.West); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathSouth</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(south, Direction.North); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathWest</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> =&gt; GrowPathTo(west, Direction.East); <span class="hljs-function"><span class="hljs-function">GameTile </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GrowPathTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile neighbor, Direction direction</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ neighbor.PathDirection = direction; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> neighbor.Content.Type != GameTileContentType.Wall ? neighbor : <span class="hljs-literal"><span class="hljs-literal">null</span></span>; }</code> </pre> <br>  Wir m√ºssen Richtungen in Kurven umwandeln, die als Quaternionen ausgedr√ºckt werden.  Es w√§re praktisch, wenn wir nur <code>GetRotation</code> f√ºr die Richtung aufrufen <code>GetRotation</code> Lassen Sie uns dies tun, indem Sie eine Erweiterungsmethode erstellen.  F√ºgen Sie die allgemeine statische Methode <code>DirectionExtensions</code> , geben Sie ihr ein Array zum Zwischenspeichern der erforderlichen Quaternionen sowie die <code>GetRotation</code> Methode, um den entsprechenden Richtungswert zur√ºckzugeben.  In diesem Fall ist es sinnvoll, die Erweiterungsklasse in dieselbe Datei wie den Aufz√§hlungstyp zu stellen. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Direction { North, East, South, West } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">DirectionExtensions</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Quaternion[] rotations = { Quaternion.identity, Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">90f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">180f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>), Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, <span class="hljs-number"><span class="hljs-number">270f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>) }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Quaternion </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetRotation</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Direction direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> rotations[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction]; } }</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">Was ist eine Erweiterungsmethode?</b> <div class="spoiler_text">  Eine Erweiterungsmethode ist eine statische Methode innerhalb einer statischen Klasse, die sich wie eine Instanzmethode eines Typs verh√§lt.  Dieser Typ kann eine Klasse, eine Schnittstelle, eine Struktur, ein primitiver Wert oder eine Aufz√§hlung sein.  Das erste Argument f√ºr die Erweiterungsmethode muss das <code>this</code> .  Es definiert den Wert des Typs und der Instanz, mit denen die Methode arbeiten wird.  Dieser Ansatz bedeutet, dass eine Erweiterung der Eigenschaften nicht m√∂glich ist. <br><br>  K√∂nnen Sie auf diese Weise Methoden zu irgendetwas hinzuf√ºgen?  Ja, genauso wie Sie jede statische Methode schreiben k√∂nnen, deren Parameter ein beliebiger Typ ist. </div></div><br>  Jetzt k√∂nnen wir den <code>Enemy</code> beim Laichen und jedes Mal, wenn wir ein neues Pl√§ttchen betreten, drehen.  Nach dem Aktualisieren der Daten gibt uns die Kachel <code>From</code> die Richtung vor. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { progress += Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (progress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { ‚Ä¶ transform.localRotation = tileFrom.PathDirection.GetRotation(); progress -= <span class="hljs-number"><span class="hljs-number">1f</span></span>; } transform.localPosition = Vector3.LerpUnclamped(positionFrom, positionTo, progress); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnOn</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { ‚Ä¶ transform.localRotation = tileFrom.PathDirection.GetRotation(); progress = <span class="hljs-number"><span class="hljs-number">0f</span></span>; }</code> </pre> <br><h3>  Richtungswechsel </h3><br>  Anstatt die Richtung sofort zu √§ndern, ist es besser, Werte zwischen Windungen zu interpolieren, √§hnlich wie wir zwischen Positionen interpoliert haben.  Um von einer Ausrichtung zur anderen zu gelangen, m√ºssen wir die Richtungs√§nderung kennen, die durchgef√ºhrt werden muss: ohne sich zu drehen, nach rechts zu drehen, nach links zu drehen oder zur√ºck zu drehen.  Wir f√ºgen dazu eine Aufz√§hlung hinzu, die wiederum in derselben Datei wie die <code>Direction</code> abgelegt werden kann, da sie klein und eng miteinander verbunden sind. <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> Direction { North, East, South, West } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">enum</span></span> DirectionChange { None, TurnRight, TurnLeft, TurnAround }</code> </pre> <br>  F√ºgen Sie eine weitere Erweiterungsmethode hinzu, diesmal <code>GetDirectionChangeTo</code> , die eine Richtungs√§nderung von der aktuellen Richtung zur n√§chsten zur√ºckgibt.  Wenn die Richtungen √ºbereinstimmen, gibt es keine Verschiebung.  Wenn der n√§chste mehr als der aktuelle ist, biegen Sie rechts ab.  Da sich die Anweisungen jedoch wiederholen, ist die gleiche Situation gegeben, wenn die n√§chste drei weniger als die aktuelle ist.  Bei einer Linkskurve ist es dasselbe, nur Addition und Subtraktion wechseln die Pl√§tze.  Der einzige verbleibende Fall ist ein Zur√ºck. <br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> DirectionChange </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetDirectionChangeTo</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Direction current, Direction next </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current == next) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DirectionChange.None; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current + <span class="hljs-number"><span class="hljs-number">1</span></span> == next || current - <span class="hljs-number"><span class="hljs-number">3</span></span> == next) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DirectionChange.TurnRight; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (current - <span class="hljs-number"><span class="hljs-number">1</span></span> == next || current + <span class="hljs-number"><span class="hljs-number">3</span></span> == next) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DirectionChange.TurnLeft; } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> DirectionChange.TurnAround; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir drehen nur in einer Dimension, daher reicht uns eine lineare Interpolation der Winkel. </font><font style="vertical-align: inherit;">F√ºgen Sie eine weitere Erweiterungsmethode hinzu, mit der der Richtungswinkel in Grad ermittelt wird.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">float</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetAngle</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Direction direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">float</span></span>)direction * <span class="hljs-number"><span class="hljs-number">90f</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt m√ºssen Sie </font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die Richtung, Richtungs√§nderung und Winkel verfolgen, zwischen denen Sie eine Interpolation durchf√ºhren m√ºssen.</font></font><br><br><pre> <code class="cs hljs"> Direction direction; DirectionChange directionChange; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> directionAngleFrom, directionAngleTo;</code> </pre> <br> <code>SpawnOn</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn es schwieriger wird, verschieben wir den Code f√ºr die Statusvorbereitung auf eine andere Methode. </font><font style="vertical-align: inherit;">Wir werden den Anfangszustand des Feindes als Einf√ºhrungszustand bezeichnen, also werden wir ihn nennen </font></font><code>PrepareIntro</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">In diesem Zustand bewegt sich der Feind von der Mitte zum Rand seines urspr√ºnglichen Pl√§ttchens, sodass keine Richtungs√§nderung erfolgt. </font><font style="vertical-align: inherit;">Die Winkel </font></font><code>From</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">die gleichen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SpawnOn</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">GameTile tile</span></span></span><span class="hljs-function">)</span></span> { Debug.Assert(tile.NextTileOnPath != <span class="hljs-literal"><span class="hljs-literal">null</span></span>, <span class="hljs-string"><span class="hljs-string">"Nowhere to go!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); tileFrom = tile; tileTo = tile.NextTileOnPath; <span class="hljs-comment"><span class="hljs-comment">//positionFrom = tileFrom.transform.localPosition; //positionTo = tileFrom.ExitPoint; //transform.localRotation = tileFrom.PathDirection.GetRotation(); progress = 0f; PrepareIntro(); } void PrepareIntro () { positionFrom = tileFrom.transform.localPosition; positionTo = tileFrom.ExitPoint; direction = tileFrom.PathDirection; directionChange = DirectionChange.None; directionAngleFrom = directionAngleTo = direction.GetAngle(); transform.localRotation = direction.GetRotation(); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In dieser Phase erstellen wir so etwas wie eine kleine Zustandsmaschine. </font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Verschieben Sie den Statuscode zur </font><font style="vertical-align: inherit;">Vereinfachung </font><font style="vertical-align: inherit;">auf eine neue Methode </font></font><code>PrepareNextState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir werden nur die √Ñnderungen der Kacheln belassen </font></font><code>From</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, weil wir sie hier verwenden, um zu √ºberpr√ºfen, ob der Feind den Pfad beendet hat.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { progress += Time.deltaTime; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (progress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">//positionFrom = positionTo; //positionTo = tileFrom.ExitPoint; //transform.localRotation = tileFrom.PathDirection.GetRotation(); progress -= 1f; PrepareNextState(); } ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie in einen neuen Zustand wechseln, m√ºssen Sie immer die Position √§ndern, eine Richtungs√§nderung suchen, die aktuelle Richtung aktualisieren und den Winkel </font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">auf verschieben </font></font><code>From</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wir machen keine Wende mehr.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareNextState</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { positionFrom = positionTo; positionTo = tileFrom.ExitPoint; directionChange = direction.GetDirectionChangeTo(tileFrom.PathDirection); direction = tileFrom.PathDirection; directionAngleFrom = directionAngleTo; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Andere Aktionen h√§ngen von einer Richtungs√§nderung ab. </font><font style="vertical-align: inherit;">F√ºgen wir f√ºr jede Option eine Methode hinzu. </font><font style="vertical-align: inherit;">Wenn wir uns vorw√§rts bewegen, </font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">stimmt </font><font style="vertical-align: inherit;">der Winkel </font><font style="vertical-align: inherit;">mit der Richtung des Pfades der aktuellen Zelle √ºberein. </font><font style="vertical-align: inherit;">Au√üerdem m√ºssen wir die Rotation so einstellen, dass der Feind geradeaus schaut.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareForward</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { transform.localRotation = direction.GetRotation(); directionAngleTo = direction.GetAngle(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Falle einer Wende drehen wir nicht sofort. </font><font style="vertical-align: inherit;">Wir m√ºssen in einen anderen Winkel interpolieren: 90 ¬∞ mehr, um nach rechts zu drehen, 90 ¬∞ weniger, um nach links zu drehen, und 180 ¬∞ mehr, um zur√ºckzudrehen. </font><font style="vertical-align: inherit;">Um zu vermeiden, dass aufgrund einer √Ñnderung der Winkelwerte von 359 ¬∞ auf 0 ¬∞ in die falsche Richtung gedreht wird, sollte der Winkel </font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">relativ zur aktuellen Richtung angegeben werden. </font><font style="vertical-align: inherit;">Wir m√ºssen uns keine Sorgen machen, dass der Winkel kleiner als 0 ¬∞ oder gr√∂√üer als 360 ¬∞ wird, da wir </font></font><code>Quaternion.Euler</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">damit umgehen k√∂nnen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnRight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + <span class="hljs-number"><span class="hljs-number">90f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnLeft</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom - <span class="hljs-number"><span class="hljs-number">90f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnAround</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + <span class="hljs-number"><span class="hljs-number">180f</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Am Ende k√∂nnen </font></font><code>PrepareNextState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir die </font></font><code>switch</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Richtung √§ndern, um zu entscheiden, welche der vier Methoden aufgerufen werden soll.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareNextState</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (directionChange) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DirectionChange.None: PrepareForward(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DirectionChange.TurnRight: PrepareTurnRight(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> DirectionChange.TurnLeft: PrepareTurnLeft(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: PrepareTurnAround(); <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Am Ende m√ºssen </font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir √ºberpr√ºfen, ob sich die Richtung ge√§ndert hat. </font><font style="vertical-align: inherit;">Wenn ja, interpolieren Sie zwischen den beiden Ecken und stellen Sie die Drehung ein.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ transform.localPosition = Vector3.LerpUnclamped(positionFrom, positionTo, progress); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (directionChange != DirectionChange.None) { <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> angle = Mathf.LerpUnclamped( directionAngleFrom, directionAngleTo, progress ); transform.localRotation = Quaternion.Euler(<span class="hljs-number"><span class="hljs-number">0f</span></span>, angle, <span class="hljs-number"><span class="hljs-number">0f</span></span>); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-literal"><span class="hljs-literal">true</span></span>; }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feinde drehen sich.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kurvenbewegung </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen die Bewegung verbessern, indem wir Feinde beim Drehen entlang einer Kurve bewegen. </font><font style="vertical-align: inherit;">Anstatt von Rand zu Rand zu gehen, lassen Sie sie einen viertel Kreis laufen. </font><font style="vertical-align: inherit;">Der Mittelpunkt dieses Kreises liegt in einer Ecke, die den Kacheln gemeinsam ist, </font></font><code>From</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und </font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">an derselben Kante, entlang der der Feind die Kachel betreten hat </font></font><code>From</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d7/8a6/3a5/1d78a63a58d34a1d8cc9ff56a0b23cc3.png" width="256" height="256"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eine Viertelkreisdrehung nach rechts. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir k√∂nnen dies realisieren, indem wir den Feind mithilfe der Trigonometrie in einem Bogen bewegen und gleichzeitig drehen. </font><font style="vertical-align: inherit;">Dies kann jedoch vereinfacht werden, indem nur die Rotation verwendet wird und der lokale Ursprung der feindlichen Koordinaten vor√ºbergehend in den Mittelpunkt des Kreises verschoben wird. </font><font style="vertical-align: inherit;">Dazu m√ºssen wir die Position des feindlichen Modells √§ndern, damit wir einen </font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Link zu diesem Modell geben, auf den √ºber das Konfigurationsfeld zugegriffen werden kann.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField</span></span>] Transform model = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>;</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/72b/13c/28e/72b13c28ed9d6a8d34f3e17536e964cd.png" width="320" height="56"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feind in Bezug auf das Modell. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In Vorbereitung auf das Vorw√§rts- oder R√ºckw√§rtsbewegen sollte sich das Modell zur Standardposition bewegen, zum lokalen Ursprung der feindlichen Koordinaten. </font><font style="vertical-align: inherit;">Andernfalls muss das Modell um die H√§lfte der Ma√üeinheit verschoben werden - den Radius des Rotationskreises, weit vom Wendepunkt entfernt.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareForward</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { transform.localRotation = direction.GetRotation(); directionAngleTo = direction.GetAngle(); model.localPosition = Vector3.zero; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnRight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + <span class="hljs-number"><span class="hljs-number">90f</span></span>; model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnLeft</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom - <span class="hljs-number"><span class="hljs-number">90f</span></span>; model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnAround</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + <span class="hljs-number"><span class="hljs-number">180f</span></span>; model.localPosition = Vector3.zero; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt muss der Feind selbst zum Wendepunkt gebracht werden. </font><font style="vertical-align: inherit;">Dazu muss es auch um die halbe Ma√üeinheit verschoben werden, der genaue Versatz h√§ngt jedoch von der Richtung ab. </font><font style="vertical-align: inherit;">F√ºgen wir dem </font></font><code>Direction</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">eine zus√§tzliche Erweiterungsmethode hinzu </font></font><code>GetHalfVector</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> Vector3[] halfVectors = { Vector3.forward * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, Vector3.right * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, Vector3.back * <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, Vector3.left * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> }; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> Vector3 </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHalfVector</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Direction direction</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> halfVectors[(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>)direction]; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> F√ºgen Sie den entsprechenden Vektor hinzu, wenn Sie nach rechts oder links drehen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnRight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + <span class="hljs-number"><span class="hljs-number">90f</span></span>; model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">-0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); transform.localPosition = positionFrom + direction.GetHalfVector(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnLeft</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom - <span class="hljs-number"><span class="hljs-number">90f</span></span>; model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(<span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); transform.localPosition = positionFrom + direction.GetHalfVector(); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und beim Zur√ºckdrehen sollte die Position der √ºbliche Ausgangspunkt sein. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnAround</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + <span class="hljs-number"><span class="hljs-number">180f</span></span>; model.localPosition = Vector3.zero; transform.localPosition = positionFrom; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Au√üerdem k√∂nnen wir bei der Berechnung des Austrittspunkts die </font></font><code>GameTile.GrowPathTo</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">H√§lfte des Vektors verwenden, sodass wir keinen Zugriff auf die beiden Positionen der Kacheln ben√∂tigen.</font></font><br><br><pre> <code class="cs hljs"> neighbor.ExitPoint = neighbor.transform.localPosition + direction.GetHalfVector();</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn wir jetzt die Richtung √§ndern, m√ºssen wir die Position nicht mehr interpolieren </font></font><code>Enemy.GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, da die Drehung an der Bewegung beteiligt ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (directionChange == DirectionChange.None) { transform.localPosition = Vector3.LerpUnclamped(positionFrom, positionTo, progress); } <span class="hljs-comment"><span class="hljs-comment">//if (directionChange != DirectionChange.None) { else { float angle = Mathf.LerpUnclamped( directionAngleFrom, directionAngleTo, progress ); transform.localRotation = Quaternion.Euler(0f, angle, 0f); } return true; }</span></span></code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feinde biegen sich sanft um Ecken.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Konstante Geschwindigkeit </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bis zu diesem Zeitpunkt war die Geschwindigkeit von Feinden immer gleich einem Pl√§ttchen pro Sekunde, unabh√§ngig davon, wie sie sich innerhalb des Pl√§ttchens bewegen. </font><font style="vertical-align: inherit;">Die zur√ºckgelegte Strecke h√§ngt jedoch von ihrem Zustand ab, sodass ihre Geschwindigkeit, ausgedr√ºckt in Einheiten pro Sekunde, variiert. </font><font style="vertical-align: inherit;">Damit diese Geschwindigkeit konstant ist, m√ºssen wir die Geschwindigkeit des Fortschritts je nach Zustand √§ndern. </font><font style="vertical-align: inherit;">F√ºgen Sie daher das Fortschrittsmultiplikatorfeld hinzu und skalieren Sie damit das Delta in </font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> progress, progressFactor; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { progress += Time.deltaTime * progressFactor; ‚Ä¶ }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn sich der Fortschritt jedoch je nach Status √§ndert, kann der verbleibende Fortschrittswert nicht direkt f√ºr den n√§chsten Status verwendet werden. </font><font style="vertical-align: inherit;">Bevor wir uns auf einen neuen Zustand vorbereiten, m√ºssen wir daher den Fortschritt normalisieren und den neuen Multiplikator bereits in einem neuen Zustand anwenden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { progress += Time.deltaTime * progressFactor; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (progress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { ‚Ä¶ <span class="hljs-comment"><span class="hljs-comment">//progress -= 1f; progress = (progress - 1f) / progressFactor; PrepareNextState(); progress *= progressFactor; } ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Vorw√§rtsbewegen erfordert keine √Ñnderungen, daher wird der Faktor 1 verwendet. Wenn der Feind nach rechts oder links dreht, passiert er ein Viertel eines Kreises mit einem Radius von ¬Ω, sodass die zur√ºckgelegte Strecke ¬ºœÄ betr√§gt. </font></font><code>progress</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gleich eins geteilt durch diesen Wert. </font><font style="vertical-align: inherit;">Das Zur√ºckdrehen sollte nicht zu lange dauern. Verdoppeln Sie den Fortschritt, sodass es eine halbe Sekunde dauert. </font><font style="vertical-align: inherit;">Schlie√ülich deckt die Einf√ºhrungsbewegung nur die H√§lfte der Kachel ab. Um eine konstante Geschwindigkeit aufrechtzuerhalten, muss der Fortschritt ebenfalls verdoppelt werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareForward</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnRight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (Mathf.PI * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnLeft</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (Mathf.PI * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnAround</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = <span class="hljs-number"><span class="hljs-number">2f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareIntro</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = <span class="hljs-number"><span class="hljs-number">2f</span></span>; }</code> </pre> <br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Warum ist der Abstand gleich 1/4 * pi?</font></font></b> <div class="spoiler_text"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Umfang betr√§gt das 2œÄ-fache des Radius. </font><font style="vertical-align: inherit;">Wenn Sie nach rechts oder links drehen, wird nur ein Viertel dieser L√§nge abgedeckt, und der Radius betr√§gt ¬Ω, sodass der Abstand ¬ΩœÄ √ó ¬Ω betr√§gt.</font></font></div></div><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Endzustand </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da wir einen Einf√ºhrungszustand haben, f√ºgen wir einen letzten hinzu. </font><font style="vertical-align: inherit;">Feinde verschwinden derzeit unmittelbar nach Erreichen des Endpunkts, aber wir verschieben ihr Verschwinden, bis sie die Mitte des Endpl√§ttchens erreichen. </font><font style="vertical-align: inherit;">Lassen Sie uns eine Methode daf√ºr erstellen </font></font><code>PrepareOutro</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die Vorw√§rtsbewegung einstellen, aber nur bis zur Mitte der Kachel mit doppeltem Fortschritt, um eine konstante Geschwindigkeit aufrechtzuerhalten.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareOutro</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { positionTo = tileFrom.transform.localPosition; directionChange = DirectionChange.None; directionAngleTo = direction.GetAngle(); model.localPosition = Vector3.zero; transform.localRotation = direction.GetRotation(); progressFactor = <span class="hljs-number"><span class="hljs-number">2f</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um </font></font><code>GameUpdate</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">den Feind nicht zu fr√ºh zu zerst√∂ren, werden wir die Kachelverschiebung entfernen. </font><font style="vertical-align: inherit;">Er wird es jetzt tun </font></font><code>PrepareNextState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Daher wird </font><font style="vertical-align: inherit;">erst nach dem Ende des Endzustands </font><font style="vertical-align: inherit;">nach </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">R√ºckgaben </font></font><code>true</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gesucht.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GameUpdate</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { progress += Time.deltaTime * progressFactor; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (progress &gt;= <span class="hljs-number"><span class="hljs-number">1f</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//tileFrom = tileTo; //tileTo = tileTo.NextTileOnPath; if (tileTo == null) { OriginFactory.Reclaim(this); return false; } ‚Ä¶ } ‚Ä¶ }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In beginnen </font></font><code>PrepareNextState</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">wir mit der Verschiebung der Kacheln. </font><font style="vertical-align: inherit;">Nach dem Festlegen der Position </font></font><code>From</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, jedoch vor dem Festlegen der Position, </font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pr√ºfen wir, ob die Kachel dem </font></font><code>To</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wert entspricht </font></font><code>null</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Wenn ja, bereiten Sie den Endzustand vor und √ºberspringen Sie den Rest der Methode.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareNextState</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { tileFrom = tileTo; tileTo = tileTo.NextTileOnPath; positionFrom = positionTo; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (tileTo == <span class="hljs-literal"><span class="hljs-literal">null</span></span>) { PrepareOutro(); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span>; } positionTo = tileFrom.ExitPoint; ‚Ä¶ }</code> </pre> <br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Feinde mit konstanter Geschwindigkeit und Endzustand.</font></font></i> <br><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Feindliche Variabilit√§t </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben einen Strom von Feinden, und sie sind alle der gleiche W√ºrfel, der sich mit der gleichen Geschwindigkeit bewegt. </font><font style="vertical-align: inherit;">Das Ergebnis ist eher eine lange Schlange als einzelne Feinde. </font><font style="vertical-align: inherit;">Machen wir sie anders, indem wir ihre Gr√∂√üe, Verschiebung und Geschwindigkeit zuf√§llig bestimmen.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Float-Wertebereich </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden die Parameter der Feinde √§ndern und ihre Eigenschaften zuf√§llig aus dem Wertebereich ausw√§hlen. </font><font style="vertical-align: inherit;">Die Struktur </font></font><code>FloatRange</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, die wir im Artikel </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Objektverwaltung, Formen konfigurieren erstellt</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> haben </font><font style="vertical-align: inherit;">, ist </font><font style="vertical-align: inherit;">hier hilfreich. </font><font style="vertical-align: inherit;">Kopieren Sie sie also. </font><font style="vertical-align: inherit;">Die einzigen √Ñnderungen waren das Hinzuf√ºgen eines Konstruktors mit einem Parameter und das √ñffnen des Zugriffs auf Minimum und Maximum mithilfe von Readonly-Eigenschaften, sodass das Intervall unver√§nderlich war.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [System.Serializable] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> FloatRange { [SerializeField] <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> min, max; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Min =&gt; min; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Max =&gt; max; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> RandomValueInRange { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> Random.Range(min, max); } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FloatRange</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">value</span></span></span></span></span><span class="hljs-function">)</span></span> { min = max = <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FloatRange</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> min, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> max</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.min = min; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.max = max &lt; min ? min : max; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wir kopieren auch das Attribut, das darauf gesetzt ist, um das Intervall zu begrenzen. </font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">FloatRangeSliderAttribute</span></span> : <span class="hljs-title"><span class="hljs-title">PropertyAttribute</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Min { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Max { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">set</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">FloatRangeSliderAttribute</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> min, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> max</span></span></span><span class="hljs-function">)</span></span> { Min = min; Max = max &lt; min ? min : max; } }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir brauchen nur die Visualisierung des Schiebereglers, also kopieren Sie ihn </font></font><code>FloatRangeSliderDrawer</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">in den </font></font><em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Editor-</font></font></em><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ordner </font><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEditor; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> UnityEngine; [CustomPropertyDrawer(<span class="hljs-keyword"><span class="hljs-keyword">typeof</span></span>(FloatRangeSliderAttribute))] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">FloatRangeSliderDrawer</span></span> : <span class="hljs-title"><span class="hljs-title">PropertyDrawer</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OnGUI</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params"> Rect position, SerializedProperty property, GUIContent label </span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> originalIndentLevel = EditorGUI.indentLevel; EditorGUI.BeginProperty(position, label, property); position = EditorGUI.PrefixLabel( position, GUIUtility.GetControlID(FocusType.Passive), label ); EditorGUI.indentLevel = <span class="hljs-number"><span class="hljs-number">0</span></span>; SerializedProperty minProperty = property.FindPropertyRelative(<span class="hljs-string"><span class="hljs-string">"min"</span></span>); SerializedProperty maxProperty = property.FindPropertyRelative(<span class="hljs-string"><span class="hljs-string">"max"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> minValue = minProperty.floatValue; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> maxValue = maxProperty.floatValue; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> fieldWidth = position.width / <span class="hljs-number"><span class="hljs-number">4f</span></span> - <span class="hljs-number"><span class="hljs-number">4f</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> sliderWidth = position.width / <span class="hljs-number"><span class="hljs-number">2f</span></span>; position.width = fieldWidth; minValue = EditorGUI.FloatField(position, minValue); position.x += fieldWidth + <span class="hljs-number"><span class="hljs-number">4f</span></span>; position.width = sliderWidth; FloatRangeSliderAttribute limit = attribute <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> FloatRangeSliderAttribute; EditorGUI.MinMaxSlider( position, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> minValue, <span class="hljs-keyword"><span class="hljs-keyword">ref</span></span> maxValue, limit.Min, limit.Max ); position.x += sliderWidth + <span class="hljs-number"><span class="hljs-number">4f</span></span>; position.width = fieldWidth; maxValue = EditorGUI.FloatField(position, maxValue); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (minValue &lt; limit.Min) { minValue = limit.Min; } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maxValue &lt; minValue) { maxValue = minValue; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (maxValue &gt; limit.Max) { maxValue = limit.Max; } minProperty.floatValue = minValue; maxProperty.floatValue = maxValue; EditorGUI.EndProperty(); EditorGUI.indentLevel = originalIndentLevel; } }</code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Modellma√üstab </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir werden zun√§chst die Gr√∂√üe des Feindes √§ndern. </font><font style="vertical-align: inherit;">F√ºgen Sie der </font></font><code>EnemyFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Option die Skalierungseinstellungen hinzu. </font><font style="vertical-align: inherit;">Das Skalierungsintervall sollte nicht zu gro√ü sein, aber ausreichen, um kleine und gigantische Arten von Feinden zu erzeugen. </font><font style="vertical-align: inherit;">Alles innerhalb von 0,5‚Äì2 mit einem Standardwert von 1. Wir werden in diesem Intervall eine zuf√§llige Skala ausw√§hlen </font></font><code>Get</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und diese durch eine neue Methode an den Feind weitergeben </font></font><code>Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, FloatRangeSlider(0.5f, 2f)</span></span>] FloatRange scale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">1f</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Enemy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Enemy instance = CreateGameObjectInstance(prefab); instance.OriginFactory = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; instance.Initialize(scale.RandomValueInRange); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Methode </font></font><code>Enemy.Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">legt einfach den Ma√üstab ihres Modells fest, der f√ºr alle Dimensionen gleich ist.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale</span></span></span><span class="hljs-function">)</span></span> { model.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(scale, scale, scale); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1a7/cc3/f08/1a7cc3f082406d5c8672125ceb94913c.png" width="320" height="60" alt="Inspektor"></div><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffe/396/7cf/ffe3967cfcfb6391269a5a7691317c60.png" width="230" height="230" alt="Szene"></div><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Skalenbereich reicht von 0,5 bis 1,5.</font></font></i> <br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pfadversatz </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um die Gleichm√§√üigkeit des Feindflusses weiter zu zerst√∂ren, k√∂nnen wir ihre relative Position innerhalb der Kacheln √§ndern. Sie bewegen sich vorw√§rts, so dass die Verschiebung in diese Richtung nur den Zeitpunkt ihrer Bewegung √§ndert, was nicht sehr auff√§llig ist. Deshalb werden wir sie zur Seite verschieben, weg von dem idealen Pfad, der durch die Mitte der Kacheln f√ºhrt. F√ºgen Sie dem </font></font><code>EnemyFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Intervall </font><font style="vertical-align: inherit;">einen </font><font style="vertical-align: inherit;">Pfadversatz hinzu und √ºbergeben Sie den zuf√§lligen Versatz an die Methode </font></font><code>Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Der Versatz kann negativ oder positiv sein, jedoch niemals mehr als ¬Ω, da dies den Feind auf ein benachbartes Pl√§ttchen bewegen w√ºrde. Au√üerdem m√∂chten wir nicht, dass Feinde √ºber die Kacheln hinausgehen, denen sie folgen, sodass das Intervall tats√§chlich geringer ist, z. B. 0,4, aber die wahren Grenzen h√§ngen von der Gr√∂√üe des Feindes ab.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, FloatRangeSlider(-0.4f, 0.4f)</span></span>] FloatRange pathOffset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Enemy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Enemy instance = CreateGameObjectInstance(prefab); instance.OriginFactory = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; instance.Initialize( scale.RandomValueInRange, pathOffset.RandomValueInRange ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da sich die Verschiebung des Pfades auf den zur√ºckgelegten Pfad auswirkt, m√ºssen </font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie ihn verfolgen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> pathOffset; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathOffset</span></span></span><span class="hljs-function">)</span></span> { model.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(scale, scale, scale); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.pathOffset = pathOffset; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wenn Sie sich genau gerade bewegen (w√§hrend der einf√ºhrenden, letzten oder normalen Vorw√§rtsbewegung), wenden wir den Versatz einfach direkt auf das Modell an. </font><font style="vertical-align: inherit;">Das gleiche passiert, wenn Sie umkehren. </font><font style="vertical-align: inherit;">Mit einer Rechts- oder Linkskurve verschieben wir das Modell bereits, was relativ zur Verschiebung des Pfades wird.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareForward</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { transform.localRotation = direction.GetRotation(); directionAngleTo = direction.GetAngle(); model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(pathOffset, <span class="hljs-number"><span class="hljs-number">0f</span></span>); progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnRight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + <span class="hljs-number"><span class="hljs-number">90f</span></span>; model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(pathOffset - <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); transform.localPosition = positionFrom + direction.GetHalfVector(); progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (Mathf.PI * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnLeft</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom - <span class="hljs-number"><span class="hljs-number">90f</span></span>; model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(pathOffset + <span class="hljs-number"><span class="hljs-number">0.5f</span></span>, <span class="hljs-number"><span class="hljs-number">0f</span></span>); transform.localPosition = positionFrom + direction.GetHalfVector(); progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (Mathf.PI * <span class="hljs-number"><span class="hljs-number">0.25f</span></span>); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnAround</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + <span class="hljs-number"><span class="hljs-number">180f</span></span>; model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(pathOffset, <span class="hljs-number"><span class="hljs-number">0f</span></span>); transform.localPosition = positionFrom; progressFactor = <span class="hljs-number"><span class="hljs-number">2f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareIntro</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(pathOffset, <span class="hljs-number"><span class="hljs-number">0f</span></span>); transform.localRotation = direction.GetRotation(); progressFactor = <span class="hljs-number"><span class="hljs-number">2f</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareOutro</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(pathOffset, <span class="hljs-number"><span class="hljs-number">0f</span></span>); transform.localRotation = direction.GetRotation(); progressFactor = <span class="hljs-number"><span class="hljs-number">2f</span></span>; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Da die Verschiebung des Pfades w√§hrend der Drehung den Radius √§ndert, m√ºssen wir den Prozess der Berechnung des Fortschrittsmultiplikators √§ndern. </font><font style="vertical-align: inherit;">Der Pfadversatz muss von ¬Ω subtrahiert werden, um den Radius der Kurve nach rechts zu erhalten, und im Fall einer Kurve nach links addiert werden.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnRight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (Mathf.PI * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * (<span class="hljs-number"><span class="hljs-number">0.5f</span></span> - pathOffset)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnLeft</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (Mathf.PI * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * (<span class="hljs-number"><span class="hljs-number">0.5f</span></span> + pathOffset)); }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir erhalten auch den Wenderadius beim Drehen um 180 ¬∞. In diesem Fall decken wir den halben Kreis mit einem Radius ab, der dem Versatz des Pfades entspricht, sodass der Abstand das œÄ-fache des Versatzes betr√§gt. Dies funktioniert jedoch nicht, wenn die Verschiebung Null ist und bei kleinen Verschiebungen die Windungen zu schnell sind. Um sofortige Kurven zu vermeiden, k√∂nnen wir den minimalen Radius erzwingen, um die Geschwindigkeit zu berechnen, z. B. 0,2.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnAround</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { directionAngleTo = directionAngleFrom + (pathOffset &lt; <span class="hljs-number"><span class="hljs-number">0f</span></span> ? <span class="hljs-number"><span class="hljs-number">180f</span></span> : <span class="hljs-number"><span class="hljs-number">-180f</span></span>); model.localPosition = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(pathOffset, <span class="hljs-number"><span class="hljs-number">0f</span></span>); transform.localPosition = positionFrom; progressFactor = <span class="hljs-number"><span class="hljs-number">1f</span></span> / (Mathf.PI * Mathf.Max(Mathf.Abs(pathOffset), <span class="hljs-number"><span class="hljs-number">0.2f</span></span>)); }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1db/8b2/b16/1db8b2b164cba05ff6f8fe7ffa0eed71.png" width="320" height="40" alt="Inspektor"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Pfadversatz liegt im Bereich von ‚Äì0,25‚Äì0,25.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Beachten Sie, dass Feinde jetzt ihre relative Pfadverschiebung niemals √§ndern, selbst wenn sie sich drehen. Daher hat die Gesamtl√§nge des Pfades f√ºr jeden Feind seine eigene. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Um zu verhindern, dass Feinde benachbarte Kacheln erreichen, muss auch deren maximal m√∂gliche Gr√∂√üe ber√ºcksichtigt werden. Ich habe die Gr√∂√üe nur auf einen Maximalwert von 1 begrenzt, sodass der maximal zul√§ssige Versatz f√ºr den W√ºrfel 0,25 betr√§gt. Wenn die maximale Gr√∂√üe 1,5 betrug, sollte die maximale Verschiebung auf 0,125 reduziert werden.</font></font><br><br><h3>  Geschwindigkeit </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das Letzte, was wir zuf√§llig ausw√§hlen, ist die Geschwindigkeit der Feinde. </font><font style="vertical-align: inherit;">Wir f√ºgen ein weiteres Intervall hinzu </font></font><code>EnemyFactory</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">und √ºbertragen den Wert auf die erstellte Kopie des Feindes. </font><font style="vertical-align: inherit;">Machen wir es zum zweiten Argument der Methode </font></font><code>Initialize</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Feinde sollten nicht zu langsam oder zu schnell sein, damit das Spiel nicht trivial einfach oder unm√∂glich schwierig wird. </font><font style="vertical-align: inherit;">Begrenzen wir das Intervall auf 0,2‚Äì5. </font><font style="vertical-align: inherit;">Die Geschwindigkeit wird in Einheiten pro Sekunde ausgedr√ºckt, was nur Kacheln pro Sekunde entspricht, wenn Sie sich vorw√§rts bewegen.</font></font><br><br><pre> <code class="cs hljs"> [<span class="hljs-meta"><span class="hljs-meta">SerializeField, FloatRangeSlider(0.2f, 5f)</span></span>] FloatRange speed = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">1f</span></span>); [SerializeField, FloatRangeSlider(<span class="hljs-number"><span class="hljs-number">-0.4f</span></span>, <span class="hljs-number"><span class="hljs-number">0.4f</span></span>)] FloatRange pathOffset = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FloatRange(<span class="hljs-number"><span class="hljs-number">0f</span></span>); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> Enemy </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Get</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { Enemy instance = CreateGameObjectInstance(prefab); instance.OriginFactory = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>; instance.Initialize( scale.RandomValueInRange, speed.RandomValueInRange, pathOffset.RandomValueInRange ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> instance; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt muss ich </font></font><code>Enemy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">verfolgen und beschleunigen.</font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> speed; ‚Ä¶ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Initialize</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> scale, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> speed, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">float</span></span></span></span><span class="hljs-function"><span class="hljs-params"> pathOffset</span></span></span><span class="hljs-function">)</span></span> { model.localScale = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Vector3(scale, scale, scale); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.speed = speed; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.pathOffset = pathOffset; }</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn wir die Geschwindigkeit nicht explizit eingestellt haben, haben wir einfach immer den Wert 1 verwendet. Jetzt m√ºssen wir nur noch die Abh√§ngigkeit des Fortschrittsmultiplikators von der Geschwindigkeit erstellen. </font></font><br><br><pre> <code class="cs hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareForward</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = speed; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnRight</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = speed / (Mathf.PI * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * (<span class="hljs-number"><span class="hljs-number">0.5f</span></span> - pathOffset)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnLeft</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = speed / (Mathf.PI * <span class="hljs-number"><span class="hljs-number">0.5f</span></span> * (<span class="hljs-number"><span class="hljs-number">0.5f</span></span> + pathOffset)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareTurnAround</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = speed / (Mathf.PI * Mathf.Max(Mathf.Abs(pathOffset), <span class="hljs-number"><span class="hljs-number">0.2f</span></span>)); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareIntro</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = <span class="hljs-number"><span class="hljs-number">2f</span></span> * speed; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">PrepareOutro</span></span></span><span class="hljs-function"> (</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { ‚Ä¶ progressFactor = <span class="hljs-number"><span class="hljs-number">2f</span></span> * speed; }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/0b8/e55/eeb/0b8e55eeb25d36349f606f0da60d3720.png" width="320" height="60"></div><br><iframe width="560" height="315" src="https://www.youtube.com/embed/https://translate" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Geschwindigkeit im Bereich von 0,75 bis 1,25. </font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Wir haben also einen wundersch√∂nen Strom von Feinden, die sich zum Endpunkt bewegen. </font><font style="vertical-align: inherit;">Im n√§chsten Tutorial lernen wir, wie man mit ihnen umgeht. </font><font style="vertical-align: inherit;">M√∂chten Sie wissen, wann es ver√∂ffentlicht wird? </font><font style="vertical-align: inherit;">Folgen Sie meiner Seite auf </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Patreon</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font></font><br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Repository </font></font></a> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">PDF-Artikel</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de452756/">https://habr.com/ru/post/de452756/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de452746/index.html">Das Buch "Die Kunst des Programmierens in R. Eintauchen in Big Data"</a></li>
<li><a href="../de452748/index.html">Prinzipien zur Entwicklung moderner Anwendungen aus NGINX. Teil 1</a></li>
<li><a href="../de452750/index.html">Nextcloud innerhalb und au√üerhalb von OpenLiteSpeed: Reverse Proxy konfigurieren</a></li>
<li><a href="../de452752/index.html">Hausgemachte BigData. Teil 1. Spark-Streaming-Praxis in einem AWS-Cluster</a></li>
<li><a href="../de452754/index.html">19% der beliebtesten Docker-Images haben kein Root-Passwort</a></li>
<li><a href="../de452760/index.html">Vitamin D. Trinken oder nicht trinken, das ist die Frage. (Oder eine Geschichte dar√ºber, wie ich eine Analyse bestanden habe, die mir nicht verschrieben wurde)</a></li>
<li><a href="../de452762/index.html">MVCC-7. Automatische Reinigung</a></li>
<li><a href="../de452764/index.html">[Peter] Treffen von JUG.ru mit Sergei Melnikov - Profiling mit superluminaler Geschwindigkeit: Theorie und Praxis</a></li>
<li><a href="../de452766/index.html">Progressive Streaming-Technologie oder das Ansehen von 4k-Videos √ºber das Netzwerk ohne Friese</a></li>
<li><a href="../de452768/index.html">So gestalten Sie ein Produkt, wenn Sie sich f√ºr den Eintritt in den ausl√§ndischen Markt entscheiden</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>