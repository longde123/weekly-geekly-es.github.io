<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🌿 🍑 🍷 Presque tout ce que vous vouliez savoir sur la virgule flottante dans ARM, mais aviez peur de demander 🛄 ❔ 🚰</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Dans cet article, je veux parler du travail en virgule flottante pour les processeurs avec une architecture ARM. Je pense que cet artic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Presque tout ce que vous vouliez savoir sur la virgule flottante dans ARM, mais aviez peur de demander</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/embox/blog/418295/"><img src="https://habrastorage.org/webt/uz/l3/0w/uzl30wgy6ecwi5eg7gmrtrdbzd4.jpeg" align="right" width="320">  Bonjour, Habr!  Dans cet article, je veux parler du travail en virgule flottante pour les processeurs avec une architecture ARM.  Je pense que cet article sera utile principalement pour ceux qui portent leur système d'exploitation sur l'architecture ARM et en même temps, ils ont besoin d'un support pour le matériel à virgule flottante (ce que nous avons fait pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Embox</a> , qui utilisait auparavant une implémentation logicielle d'opérations à virgule flottante). <br><br>  Commençons donc. <br><a name="habracut"></a><br><h2>  Drapeaux du compilateur </h2><br>  Pour prendre en charge la virgule flottante, vous devez transmettre les indicateurs corrects au compilateur.  Une recherche rapide <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de</a> nous mène à l'idée que deux options sont particulièrement importantes: -mfloat-abi et -mfpu.  L'option -mfloat-abi définit l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ABI</a> pour les opérations en virgule flottante et peut avoir l'une des trois valeurs: «soft», «softfp» et «hard».  L'option 'soft', comme son nom l'indique, indique au compilateur d'utiliser les appels de fonction intégrés pour programmer le point flottant (cette option a été utilisée auparavant).  Les deux «softfp» et «hard» restants seront considérés un peu plus tard, après avoir considéré l'option -mfpu. <br><br><h2>  -Mppu flag et version VFP </h2><br>  L'option -mfpu, telle qu'écrite dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation en ligne de gcc</a> , vous permet de spécifier le type de matériel et peut prendre les options suivantes: <br><blockquote>  'auto', 'vfpv2', 'vfpv3', 'vfpv3-fp16', 'vfpv3-d16', 'vfpv3-d16-fp16', 'vfpv3xd', 'vfpv3xd-fp16', 'neon-vfpv3', 'neon -fp16 ',' vfpv4 ',' vfpv4-d16 ',' fpv4-sp-d16 ',' neon-vfpv4 ',' fpv5-d16 ',' fpv5-sp-d16 ',' fp-armv8 ',' neon -fp-armv8 'et' crypto-neon-fp-armv8 '.  Et «néon» est identique à «néon-vfpv3», et «vfp» est «vfpv2». </blockquote>  Mon compilateur (arm-none-eabi-gcc (15: 5.4.1 + svn241155-1) 5.4.1 20160919) produit une liste légèrement différente, mais cela ne change pas l'essence de la question.  Dans tous les cas, nous devons comprendre comment tel ou tel indicateur affecte le compilateur, et bien sûr, quel indicateur doit être utilisé quand. <br><br>  J'ai commencé à comprendre la plate-forme basée sur le processeur imx6, mais nous allons la reporter un peu de temps, car le coprocesseur néon a des fonctionnalités dont je parlerai plus tard, et nous commencerons par un cas plus simple - de la plate-forme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">intégrateur / cp</a> , <br>  Je n'ai pas la carte elle-même, donc le débogage a été fait sur l'émulateur qemu.  Dans qemu, la plate-forme Interator / cp est basée sur le processeur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ARM926EJ-S</a> , qui à son tour prend en charge le coprocesseur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">VFP9-S</a> .  Ce coprocesseur est conforme à la version 2 de l'architecture à virgule flottante (VFPv2).  En conséquence, vous devez définir -mfpu = vfpv2, mais cette option ne figurait pas dans la liste des options de mon compilateur.  Sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Internet,</a> j'ai rencontré une option de compilation avec les drapeaux -mcpu = arm926ej-s -mfpu = vfpv3-d16, je l'ai installée et tout a été compilé pour moi.  Lorsque j'ai commencé, j'ai reçu une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exception d'instruction non définie</a> , qui était prévisible, car le coprocesseur était <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">éteint</a> . <br><br>  Afin de permettre au coprocesseur de fonctionner, vous devez définir le bit EN [30] dans le registre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FPEXC</a> .  Cela se fait à l'aide de la commande VMSR. <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Enable FPU extensions */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"VMSR FPEXC, %0"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"r"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &lt;&lt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">30</span></span></span></span><span class="hljs-function"><span class="hljs-params">);</span></span></span></span></code> </pre> <br>  En fait, la commande VMSR est traitée par le coprocesseur et lève une exception si le coprocesseur n'est pas activé, mais l'accès à ce registre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ne le provoque pas</a> .  Certes, contrairement aux autres, l'accès à ce registre n'est possible qu'en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mode privilégié</a> . <br><br>  Après que le coprocesseur a été autorisé à fonctionner, nos tests de fonctions mathématiques ont commencé à passer.  Mais lorsque j'ai activé l'optimisation (-O2), l'exception d'instruction non définie mentionnée précédemment a été déclenchée.  Et il est apparu sur l'instruction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vmov</a> qui a été appelée dans le code plus tôt, mais qui a été exécutée avec succès (sans exception).  Enfin, j'ai trouvé à la fin de la page l'expression «Les instructions qui copient les constantes immédiates sont disponibles dans VFPv3» (c'est-à-dire que les opérations avec des constantes sont prises en charge à partir de VFPv3).  Et j'ai décidé de vérifier quelle version est publiée dans mon émulateur.  La version est enregistrée dans le registre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FPSID</a> .  De la documentation, il s'ensuit que la valeur du registre doit être 0x41011090.  Cela correspond à 1 dans le domaine de l'architecture [19..16] c'est-à-dire VFPv2.  En fait, après avoir fait une impression au démarrage, j'ai obtenu ceci <br><br><pre> <code class="hljs pgsql"> unit: initializing embox.arch.arm.fpu.vfp9_s: VPF <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>: Hardware FP support Implementer = <span class="hljs-number"><span class="hljs-number">0x41</span></span> (ARM) Subarch: VFPv2 Part number = <span class="hljs-number"><span class="hljs-number">0x10</span></span> Variant = <span class="hljs-number"><span class="hljs-number">0x09</span></span> Revision = <span class="hljs-number"><span class="hljs-number">0x00</span></span></code> </pre> <br>  Après avoir lu attentivement que 'vfp' est alias 'vfpv2', j'ai mis le bon drapeau, cela a fonctionné.  Revenant à la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">page</a> où j'ai vu la combinaison de drapeaux -mcpu = arm926ej-s -mfpu = vfpv3-d16, je note que je n'ai pas fait assez attention, car -mfloat-abi = soft apparaît dans la liste des drapeaux.  Autrement dit, il n'y a pas de support matériel dans ce cas.  Plus précisément, -mfpu n'a d'importance que si une valeur autre que «soft» est définie sur -mfloat-abi. <br><br><h2>  Assembleur </h2><br>  Il est temps de parler d'assembleur.  Après tout, je devais prendre en charge l'exécution, et, par exemple, le compilateur, bien sûr, ne connaît pas le changement de contexte. <br><br><h3>  Registres </h3><br>  Commençons par la description des registres.  VFP vous permet d'effectuer des opérations avec des nombres à virgule flottante 32 bits (s0..s31) et 64 bits (d0..d15) .La correspondance entre ces registres est illustrée dans l'image ci-dessous. <br><br><img src="https://habrastorage.org/webt/jr/lo/w0/jrlow0oljuvwjd0y5bb-qkxlyh4.png"><br><br>  Q0-Q15 sont des registres 128 bits d'anciennes versions pour travailler avec SIMD, plus à leur sujet plus tard. <br><br><h3>  Système de commande </h3><br>  Bien sûr, le plus souvent, le travail avec les registres VFP doit être confié au compilateur, mais au moins vous devez écrire le changement de contexte manuellement.  Si vous avez déjà une compréhension approximative de la syntaxe des instructions d'assembleur pour travailler avec des registres à usage général, le traitement des nouvelles instructions ne devrait pas être difficile.  Le plus souvent, le préfixe «v» est simplement ajouté. <br><br><pre> <code class="hljs powershell">vmov d0, r0, r1 /*  r0  r1, ..  d0 <span class="hljs-number"><span class="hljs-number">64</span></span> ,   r0<span class="hljs-literal"><span class="hljs-literal">-1</span></span>  <span class="hljs-number"><span class="hljs-number">32</span></span> */ vmov r0, r1, d0 vadd d0, d1, d2 vldr d0, r0 vstm r0!, {d0<span class="hljs-literal"><span class="hljs-literal">-d15</span></span>} vldm r0!, {d0<span class="hljs-literal"><span class="hljs-literal">-d15</span></span>}</code> </pre> <br>  Et ainsi de suite.  Une liste complète des commandes se trouve sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le site Web d'ARM</a> . <br><br>  Et bien sûr, n'oubliez pas la version VFP pour qu'il n'y ait pas de situations comme celle décrite ci-dessus. <br><br><h2>  Drapeau -mfloat-abi 'softfp' et 'hard' </h2><br>  Retour à -mfloat-abi.  Si vous lisez la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> , nous verrons: <br><blockquote>  'softfp' permet la génération de code à l'aide d'instructions matérielles à virgule flottante, mais utilise toujours les conventions d'appel soft-float.  'hard' permet la génération d'instructions à virgule flottante et utilise des conventions d'appel spécifiques aux FPU. </blockquote>  Autrement dit, nous parlons de passer des arguments à une fonction.  Mais au moins, il n’était pas très clair pour moi quelle est la différence entre les conventions d’appel «flottant» et «spécifiques aux FPU».  En supposant que le boîtier rigide utilise des registres à virgule flottante et le boîtier softfp utilise des registres entiers, j'ai trouvé une confirmation sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wiki Debian</a> .  Et bien que ce soit pour les coprocesseurs NEON, mais cela n'a pas d'importance.  Un autre point intéressant est qu'avec l'option softfp, le compilateur peut, mais n'est pas obligé d'utiliser le support matériel: <br><blockquote>  "Le compilateur peut faire des choix intelligents quant au moment et s'il génère des instructions FPU émulées ou réelles en fonction du type de FPU choisi (-mfpu =)" </blockquote>  Pour plus de clarté, j'ai décidé d'expérimenter et j'ai été très surpris, car avec l'optimisation -O0 désactivée, la différence était très faible et ne s'appliquait pas aux endroits où la virgule flottante était réellement utilisée.  En supposant que le compilateur pousse simplement tout sur la pile, plutôt que d'utiliser des registres, j'ai activé l'optimisation -O2 et j'ai de nouveau été surpris, car avec l'optimisation, le compilateur a commencé à utiliser des registres matériels à virgule flottante pour les options matérielles et sotffp, et la différence est, comme et dans le cas de -O0, c'était très insignifiant.  En conséquence, pour moi, j'ai expliqué cela par le fait que le compilateur résout le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">problème</a> associé au fait que si vous copiez des données entre des registres à virgule flottante et des entiers, les performances chuteront considérablement.  Et le compilateur, lors de l'optimisation, commence à utiliser toutes les ressources à sa disposition. <br><br>  Lorsqu'on m'a demandé quel drapeau utiliser 'softfp' ou 'hard', j'ai répondu moi-même comme suit: partout où il y a déjà des parties compilées avec le drapeau 'softfp', vous devez utiliser 'hard'.  S'il y en a, vous devez utiliser 'softfp'. <br><br><h2>  Changement de contexte </h2><br>  Étant donné qu'Embox prend en charge le multitâche préemptif, pour fonctionner correctement lors de l'exécution, une implémentation du changement de contexte était naturellement nécessaire.  Pour ce faire, vous devez enregistrer les registres du coprocesseur.  Il y a quelques nuances.  Premièrement: il s'est avéré que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les commandes d'opération de pile pour les virgules flottantes (vstm / vldm) ne prennent pas en charge tous les modes</a> .  Deuxièmement: ces opérations ne prennent pas en charge le travail avec plus de seize registres 64 bits.  Si vous devez charger / enregistrer plus de registres à la fois, vous devez utiliser deux instructions. <br><br>  Je vais donner une autre petite optimisation.  En fait, la sauvegarde et la restauration de 256 octets de registres VFP à chaque fois ne sont pas du tout nécessaires (les registres à usage général n'occupent que 64 octets, donc la différence est significative).  Une optimisation évidente n'effectuera ces opérations que si le processus utilise en principe ces registres. <br><br>  Comme je l'ai déjà mentionné, lorsque le coprocesseur VFP est éteint, une tentative d'exécution de l'instruction correspondante entraînera une exception «Instruction non définie».  Dans le gestionnaire de cette exception, vous devez vérifier la cause de l'exception et s'il s'agit d'utiliser un coprocesseur VPF, le processus est marqué comme utilisant le coprocesseur VFP. <br><br>  En conséquence, la sauvegarde / restauration du contexte déjà écrite a été complétée par des macros <br><br><pre> <code class="hljs tex">#define ARM_FPU_CONTEXT_SAVE_INC(tmp, stack) <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>vmrs tmp, FPEXC ; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>stmia stack!, {tmp}; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ands tmp, tmp, #1&lt;&lt;30; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>beq fpu_out_save_inc; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>vstmia stack!, {d0-d15}; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>fpu_out_save_inc: #define ARM_FPU_CONTEXT_LOAD_INC(tmp, stack) <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ldmia stack!, {tmp}; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>vmsr FPEXC, tmp; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ands tmp, tmp, #1&lt;&lt;30; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>beq fpu_out_load_inc; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>vldmia stack!, {d0-d15}; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>fpu_out_load_inc:</code> </pre> <br>  Pour vérifier l'exactitude de l'opération de changement de contexte dans des conditions à virgule flottante, nous avons écrit un test dans lequel nous multiplions dans un thread dans une boucle et divisons dans un autre, puis comparons les résultats. <br><br><pre> <code class="cpp hljs">EMBOX_TEST_SUITE(<span class="hljs-string"><span class="hljs-string">"FPU context consistency test. Must be compiled with -02"</span></span>); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TICK_COUNT 10 static float res_out[2][TICK_COUNT]; static void *fpu_context_thr1_hnd(void *arg) { float res = 1.0f; int i; for (i = 0; i </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; TICK_COUNT; ) { res_out[0][i] = res; if (i == 0 || res_out[1][i - 1] &gt; 0) { i++; } if (res &gt; 0.000001f) { res /= 1.01f; } sleep(0); } return NULL; } static void *fpu_context_thr2_hnd(void *arg) { float res = 1.0f; int i = 0; for (i = 0; i &lt; TICK_COUNT; ) { res_out[1][i] = res; if (res_out[0][i] != 0) { i++; } if (res &lt; 1000000.f) { res *= 1.01f; } sleep(0); } return NULL; } TEST_CASE("Test FPU context consistency") { pthread_t threads[2]; pthread_t tid = 0; int status; status = pthread_create(&amp;threads[0], NULL, fpu_context_thr1_hnd, &amp;tid); if (status != 0) { test_assert(0); } status = pthread_create(&amp;threads[1], NULL, fpu_context_thr2_hnd, &amp;tid); if (status != 0) { test_assert(0); } pthread_join(threads[0], (void**)&amp;status); pthread_join(threads[1], (void**)&amp;status); test_assert(res_out[0][0] != 0 &amp;&amp; res_out[1][0] != 0); for (int i = 1; i &lt; TICK_COUNT; i++) { test_assert(res_out[0][i] &lt; res_out[0][i - 1]); test_assert(res_out[1][i] &gt; res_out[1][i - 1]); } }</span></span></span></span></code> </pre> <br>  Le test a réussi avec succès lorsque l'optimisation a été désactivée, nous avons donc indiqué dans la description du test qu'il devait être compilé avec l'optimisation, EMBOX_TEST_SUITE ("Test de cohérence du contexte FPU. Doit être compilé avec -02");  même si nous savons que les tests ne doivent pas reposer <br><br><h2>  Coprocesseur NEON et SIMD </h2><br>  Il est temps de dire pourquoi j'ai reporté l'histoire sur imx6.  Le fait est qu'il est basé sur le noyau Cortex-A9 et contient le coprocesseur NEON le plus avancé (https://developer.arm.com/technologies/neon).  NEON n'est pas seulement VFPv3, mais c'est aussi un coprocesseur SIMD.  VFP et NEON utilisent les mêmes registres.  VFP utilise des registres 32 bits et 64 bits pour le fonctionnement, et NEON utilise des registres 64 bits et 128 bits, ces derniers étant simplement désignés Q0-Q16.  En plus des valeurs entières et des nombres à virgule flottante, NEON est également capable de travailler avec un anneau polynomial de 16 ou 8e degré modulo 2. <br><br>  Le mode vfp pour NEON n'est presque pas différent du coprocesseur vfp9-s démonté.  Bien sûr, il est préférable de spécifier les options vfpv3 ou vfpv3-d32 pour -mfpu pour une meilleure optimisation, car il dispose de 32 registres 64 bits.  Et pour activer le coprocesseur, vous devez donner accès aux coprocesseurs c10 et c11.  cela se fait à l'aide de commandes <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Allow access to c10 &amp; c11 coprocessors */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"mrc p15, 0, %0, c1, c0, 2"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=r"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (val) :)</span></span></span></span>; val |= <span class="hljs-number"><span class="hljs-number">0xf</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"mcr p15, 0, %0, c1, c0, 2"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"r"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (val))</span></span></span></span>;</code> </pre> <br>  mais il n'y a pas d'autres différences fondamentales. <br><br>  Une autre chose si vous spécifiez -mfpu = neon, dans ce cas, le compilateur peut utiliser des instructions SIMD. <br><br><h2>  Utilisation de SIMD en C </h2><br>  Pour &lt;&lt; enregistrer &gt;&gt; les valeurs manuellement par registre, vous pouvez inclure "arm_neon.h" et utiliser les types de données correspondants: <br>  float32x4_t pour quatre flottants 32 bits dans un registre, uint8x8_t pour huit entiers 8 bits et ainsi de suite.  Pour accéder à une seule valeur, nous l'appelons tableau, addition, multiplication, affectation, etc.  comme pour les variables ordinaires, par exemple: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32x4_t</span></span> a = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}, b = {<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">uint32x4_t</span></span> c = a * b; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(“Result=[%d, %d, %d, %d]\n”, c[<span class="hljs-number"><span class="hljs-number">0</span></span>], c[<span class="hljs-number"><span class="hljs-number">1</span></span>], c[<span class="hljs-number"><span class="hljs-number">2</span></span>], c[<span class="hljs-number"><span class="hljs-number">3</span></span>]);</code> </pre> <br>  Bien sûr, l'utilisation de la vectorisation automatique est plus facile.  Pour la vectorisation automatique, ajoutez l'indicateur -ftree-vectorize à GCC. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">simd_test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a[LEN], b[LEN], c[LEN]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; LEN; i++) { a[i] = i; b[i] = LEN - i; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; LEN; i++) { c[i] = a[i] + b[i]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; LEN; i++) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"c[i] = %d\n"</span></span>, c[i]); } }</code> </pre> <br>  La boucle d'addition génère le code suivant: <br><br><pre> <code class="hljs delphi"><span class="hljs-number"><span class="hljs-number">600059</span></span>a0: f4610adf vld1.<span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-comment"><span class="hljs-comment">{d16-d17}</span></span>, [r1 :<span class="hljs-number"><span class="hljs-number">64</span></span>] <span class="hljs-number"><span class="hljs-number">600059</span></span>a4: e2833010 add r3, r3, <span class="hljs-string"><span class="hljs-string">#16</span></span> <span class="hljs-number"><span class="hljs-number">600059</span></span>a8: e28d0a03 add r0, sp, <span class="hljs-string"><span class="hljs-string">#12288</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span>x3000 <span class="hljs-number"><span class="hljs-number">600059</span></span>ac: e2811010 add r1, r1, <span class="hljs-string"><span class="hljs-string">#16</span></span> <span class="hljs-number"><span class="hljs-number">600059</span></span>b0: f4622adf vld1.<span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-comment"><span class="hljs-comment">{d18-d19}</span></span>, [r2 :<span class="hljs-number"><span class="hljs-number">64</span></span>] <span class="hljs-number"><span class="hljs-number">600059</span></span>b4: e2822010 add r2, r2, <span class="hljs-string"><span class="hljs-string">#16</span></span> <span class="hljs-number"><span class="hljs-number">600059</span></span>b8: f26008e2 vadd.i32 q8, q8, q9 <span class="hljs-number"><span class="hljs-number">600059</span></span>bc: ed430b04 vstr d16, [r3, #-<span class="hljs-number"><span class="hljs-number">16</span></span>] <span class="hljs-number"><span class="hljs-number">600059</span></span>c0: ed431b02 vstr d17, [r3, #-<span class="hljs-number"><span class="hljs-number">8</span></span>] <span class="hljs-number"><span class="hljs-number">600059</span></span>c4: e1530000 cmp r3, r0 <span class="hljs-number"><span class="hljs-number">600059</span></span>c8: <span class="hljs-number"><span class="hljs-number">1</span></span>afffff4 bne <span class="hljs-number"><span class="hljs-number">600059</span></span>a0 &lt;foo+<span class="hljs-number"><span class="hljs-number">0</span></span>x58&gt; <span class="hljs-number"><span class="hljs-number">600059</span></span>cc: e28d5dbf add r5, sp, <span class="hljs-string"><span class="hljs-string">#12224</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span>x2fc0 <span class="hljs-number"><span class="hljs-number">600059</span></span>d0: e2444004 sub r4, r4, <span class="hljs-string"><span class="hljs-string">#4</span></span> <span class="hljs-number"><span class="hljs-number">600059</span></span>d4: e285503c add r5, r5, <span class="hljs-string"><span class="hljs-string">#60</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span>x3c</code> </pre> <br>  Après avoir effectué des tests de code parallélisé, nous avons constaté qu'un simple ajout dans une boucle, à condition que les variables soient indépendantes, donne une accélération jusqu'à 7 fois.  De plus, nous avons décidé de voir dans quelle mesure la parallélisation affecte les tâches réelles, avons pris MESA3d avec son émulation logicielle et mesuré le nombre de fps avec différents drapeaux, nous avons obtenu un gain de 2 images par seconde (15 contre 13), c'est-à-dire que l'accélération est d'environ 15-20% . <br><br>  Je vais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">donner</a> un autre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemple d'accélération en utilisant des commandes NEON</a> , pas les nôtres, mais de ARM. <br><br>  La copie de la mémoire est jusqu'à 50% plus rapide que la normale.  De vrais exemples sont là dans l'assembleur. <br><br>  Cycle de copie normal: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">WordCopy</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">LDR</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r3</span></span>, <span class="hljs-selector-attr"><span class="hljs-selector-attr">[r1]</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">STR</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r3</span></span>, <span class="hljs-selector-attr"><span class="hljs-selector-attr">[r0]</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SUBS</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r2</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">r2</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">BGE</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">WordCopy</span></span></code> </pre> <br>  boucle avec des commandes et registres néon: <br><br><pre> <code class="hljs erlang-repl">NEONCopyPLD PLD [r1, #<span class="hljs-number"><span class="hljs-number">0</span></span>xC0] VLDM r1!,{d0-d7} VSTM r0!,{d0-d7} SUBS r2,r2,#<span class="hljs-number"><span class="hljs-number">0</span></span>x40 BGE NEONCopyPLD</code> </pre> <br>  Il est clair que la copie sur 64 octets est plus rapide que 4 octets, et une telle copie donnera une augmentation de 10%, mais les 40% restants semblent donner le travail du coprocesseur. <br><br><h2>  Cortex-m </h2><br>  Travailler avec des FPU dans Cortex-M n'est pas très différent de celui décrit ci-dessus.  Par exemple, voici à quoi ressemble la macro ci-dessus pour enregistrer le contexte fpu-shny <br><br><pre> <code class="hljs tex">#define ARM_FPU_CONTEXT_SAVE_INC(tmp, stack) <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ldr tmp, =CPACR; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ldr tmp, [tmp]; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>tst tmp, #0xF00000; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>beq fpu_out_save_inc; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>vstmia stack!, {s0-s31}; fpu_out_save_inc:</code> </pre> <br>  De plus, la commande vstmia utilise uniquement les registres s0-s31 et les registres de contrôle sont accessibles différemment.  Par conséquent, je n'entrerai pas dans trop de détails, je ne vous expliquerai que les diff.  Nous avons donc pris en charge la découverte de STM32F7 avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cortex-m7</a> pour cela, respectivement, nous devons définir l'indicateur -mfpu = fpv5-sp-d16.  Veuillez noter que dans les versions mobiles, vous devez regarder de plus près la version du coprocesseur, car le même cortex-m peut avoir des options différentes.  Donc, si votre option n'est pas en double précision, mais en simple, alors il peut ne pas y avoir de registres D0-D16, comme nous l'avons dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">stm32f4discovery</a> , c'est pourquoi la variante avec les registres S0-S31 est utilisée.  Pour ce contrôleur, nous utilisons -mfpu = fpv4-sp-d16. <br><br>  La principale différence est l'accès aux registres de contrôle du contrôleur, ils sont situés directement dans l'espace d'adressage du noyau principal, et pour différents types ils sont différents <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cortex-m4</a> pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cortex-m7</a> . <br><br><h2>  Conclusion </h2><br>  Sur ce, je terminerai ma courte histoire sur la virgule flottante pour ARM.  Je note que les microcontrôleurs modernes sont très puissants et conviennent non seulement pour le contrôle, mais aussi pour le traitement de signaux ou de divers types d'informations multimédias.  Afin d'utiliser efficacement tout ce pouvoir, vous devez comprendre comment il fonctionne.  J'espère que cet article a aidé à comprendre cela un peu mieux. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr418295/">https://habr.com/ru/post/fr418295/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr418285/index.html">Les climatologues ont montré comment l'humanité affecte les variations saisonnières de la température atmosphérique</a></li>
<li><a href="../fr418287/index.html">Liste de contrôle obligatoire pour le développement de la conception UX d'une application mobile</a></li>
<li><a href="../fr418289/index.html">Comment les solutions informatiques aident à organiser la tarification dynamique en magasin</a></li>
<li><a href="../fr418291/index.html">DEFCON 19. Conférence «Volez tout, tuez tout le monde, provoquez un effondrement financier complet»! Rue Jason E.</a></li>
<li><a href="../fr418293/index.html">Test automatisé de l'interface Web chez Virto Commerce</a></li>
<li><a href="../fr418297/index.html">Courte critique du smartphone Neffos N1</a></li>
<li><a href="../fr418301/index.html">La grande confrontation de Mars en 2018: comment observer et à quoi s'attendre</a></li>
<li><a href="../fr418303/index.html">Vanessa-Automation - un outil pour tester des solutions applicatives sur la plateforme 1C: Enterprise</a></li>
<li><a href="../fr418305/index.html">Combien d'objets Python émet-il lors de l'exécution de scripts?</a></li>
<li><a href="../fr418307/index.html">Outils d'apprentissage automatique Apple</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>