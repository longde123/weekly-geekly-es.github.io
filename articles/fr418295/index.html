<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üåø üçë üç∑ Presque tout ce que vous vouliez savoir sur la virgule flottante dans ARM, mais aviez peur de demander üõÑ ‚ùî üö∞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Dans cet article, je veux parler du travail en virgule flottante pour les processeurs avec une architecture ARM. Je pense que cet artic...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Presque tout ce que vous vouliez savoir sur la virgule flottante dans ARM, mais aviez peur de demander</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/embox/blog/418295/"><img src="https://habrastorage.org/webt/uz/l3/0w/uzl30wgy6ecwi5eg7gmrtrdbzd4.jpeg" align="right" width="320">  Bonjour, Habr!  Dans cet article, je veux parler du travail en virgule flottante pour les processeurs avec une architecture ARM.  Je pense que cet article sera utile principalement pour ceux qui portent leur syst√®me d'exploitation sur l'architecture ARM et en m√™me temps, ils ont besoin d'un support pour le mat√©riel √† virgule flottante (ce que nous avons fait pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Embox</a> , qui utilisait auparavant une impl√©mentation logicielle d'op√©rations √† virgule flottante). <br><br>  Commen√ßons donc. <br><a name="habracut"></a><br><h2>  Drapeaux du compilateur </h2><br>  Pour prendre en charge la virgule flottante, vous devez transmettre les indicateurs corrects au compilateur.  Une recherche rapide <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">de</a> nous m√®ne √† l'id√©e que deux options sont particuli√®rement importantes: -mfloat-abi et -mfpu.  L'option -mfloat-abi d√©finit l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ABI</a> pour les op√©rations en virgule flottante et peut avoir l'une des trois valeurs: ¬´soft¬ª, ¬´softfp¬ª et ¬´hard¬ª.  L'option 'soft', comme son nom l'indique, indique au compilateur d'utiliser les appels de fonction int√©gr√©s pour programmer le point flottant (cette option a √©t√© utilis√©e auparavant).  Les deux ¬´softfp¬ª et ¬´hard¬ª restants seront consid√©r√©s un peu plus tard, apr√®s avoir consid√©r√© l'option -mfpu. <br><br><h2>  -Mppu flag et version VFP </h2><br>  L'option -mfpu, telle qu'√©crite dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation en ligne de gcc</a> , vous permet de sp√©cifier le type de mat√©riel et peut prendre les options suivantes: <br><blockquote>  'auto', 'vfpv2', 'vfpv3', 'vfpv3-fp16', 'vfpv3-d16', 'vfpv3-d16-fp16', 'vfpv3xd', 'vfpv3xd-fp16', 'neon-vfpv3', 'neon -fp16 ',' vfpv4 ',' vfpv4-d16 ',' fpv4-sp-d16 ',' neon-vfpv4 ',' fpv5-d16 ',' fpv5-sp-d16 ',' fp-armv8 ',' neon -fp-armv8 'et' crypto-neon-fp-armv8 '.  Et ¬´n√©on¬ª est identique √† ¬´n√©on-vfpv3¬ª, et ¬´vfp¬ª est ¬´vfpv2¬ª. </blockquote>  Mon compilateur (arm-none-eabi-gcc (15: 5.4.1 + svn241155-1) 5.4.1 20160919) produit une liste l√©g√®rement diff√©rente, mais cela ne change pas l'essence de la question.  Dans tous les cas, nous devons comprendre comment tel ou tel indicateur affecte le compilateur, et bien s√ªr, quel indicateur doit √™tre utilis√© quand. <br><br>  J'ai commenc√© √† comprendre la plate-forme bas√©e sur le processeur imx6, mais nous allons la reporter un peu de temps, car le coprocesseur n√©on a des fonctionnalit√©s dont je parlerai plus tard, et nous commencerons par un cas plus simple - de la plate-forme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">int√©grateur / cp</a> , <br>  Je n'ai pas la carte elle-m√™me, donc le d√©bogage a √©t√© fait sur l'√©mulateur qemu.  Dans qemu, la plate-forme Interator / cp est bas√©e sur le processeur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ARM926EJ-S</a> , qui √† son tour prend en charge le coprocesseur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">VFP9-S</a> .  Ce coprocesseur est conforme √† la version 2 de l'architecture √† virgule flottante (VFPv2).  En cons√©quence, vous devez d√©finir -mfpu = vfpv2, mais cette option ne figurait pas dans la liste des options de mon compilateur.  Sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Internet,</a> j'ai rencontr√© une option de compilation avec les drapeaux -mcpu = arm926ej-s -mfpu = vfpv3-d16, je l'ai install√©e et tout a √©t√© compil√© pour moi.  Lorsque j'ai commenc√©, j'ai re√ßu une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exception d'instruction non d√©finie</a> , qui √©tait pr√©visible, car le coprocesseur √©tait <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">√©teint</a> . <br><br>  Afin de permettre au coprocesseur de fonctionner, vous devez d√©finir le bit EN [30] dans le registre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FPEXC</a> .  Cela se fait √† l'aide de la commande VMSR. <br><br><pre><code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Enable FPU extensions */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"VMSR FPEXC, %0"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"r"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">1</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &lt;&lt; </span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">30</span></span></span></span><span class="hljs-function"><span class="hljs-params">);</span></span></span></span></code> </pre> <br>  En fait, la commande VMSR est trait√©e par le coprocesseur et l√®ve une exception si le coprocesseur n'est pas activ√©, mais l'acc√®s √† ce registre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ne le provoque pas</a> .  Certes, contrairement aux autres, l'acc√®s √† ce registre n'est possible qu'en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mode privil√©gi√©</a> . <br><br>  Apr√®s que le coprocesseur a √©t√© autoris√© √† fonctionner, nos tests de fonctions math√©matiques ont commenc√© √† passer.  Mais lorsque j'ai activ√© l'optimisation (-O2), l'exception d'instruction non d√©finie mentionn√©e pr√©c√©demment a √©t√© d√©clench√©e.  Et il est apparu sur l'instruction <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vmov</a> qui a √©t√© appel√©e dans le code plus t√¥t, mais qui a √©t√© ex√©cut√©e avec succ√®s (sans exception).  Enfin, j'ai trouv√© √† la fin de la page l'expression ¬´Les instructions qui copient les constantes imm√©diates sont disponibles dans VFPv3¬ª (c'est-√†-dire que les op√©rations avec des constantes sont prises en charge √† partir de VFPv3).  Et j'ai d√©cid√© de v√©rifier quelle version est publi√©e dans mon √©mulateur.  La version est enregistr√©e dans le registre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FPSID</a> .  De la documentation, il s'ensuit que la valeur du registre doit √™tre 0x41011090.  Cela correspond √† 1 dans le domaine de l'architecture [19..16] c'est-√†-dire VFPv2.  En fait, apr√®s avoir fait une impression au d√©marrage, j'ai obtenu ceci <br><br><pre> <code class="hljs pgsql"> unit: initializing embox.arch.arm.fpu.vfp9_s: VPF <span class="hljs-keyword"><span class="hljs-keyword">info</span></span>: Hardware FP support Implementer = <span class="hljs-number"><span class="hljs-number">0x41</span></span> (ARM) Subarch: VFPv2 Part number = <span class="hljs-number"><span class="hljs-number">0x10</span></span> Variant = <span class="hljs-number"><span class="hljs-number">0x09</span></span> Revision = <span class="hljs-number"><span class="hljs-number">0x00</span></span></code> </pre> <br>  Apr√®s avoir lu attentivement que 'vfp' est alias 'vfpv2', j'ai mis le bon drapeau, cela a fonctionn√©.  Revenant √† la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">page</a> o√π j'ai vu la combinaison de drapeaux -mcpu = arm926ej-s -mfpu = vfpv3-d16, je note que je n'ai pas fait assez attention, car -mfloat-abi = soft appara√Æt dans la liste des drapeaux.  Autrement dit, il n'y a pas de support mat√©riel dans ce cas.  Plus pr√©cis√©ment, -mfpu n'a d'importance que si une valeur autre que ¬´soft¬ª est d√©finie sur -mfloat-abi. <br><br><h2>  Assembleur </h2><br>  Il est temps de parler d'assembleur.  Apr√®s tout, je devais prendre en charge l'ex√©cution, et, par exemple, le compilateur, bien s√ªr, ne conna√Æt pas le changement de contexte. <br><br><h3>  Registres </h3><br>  Commen√ßons par la description des registres.  VFP vous permet d'effectuer des op√©rations avec des nombres √† virgule flottante 32 bits (s0..s31) et 64 bits (d0..d15) .La correspondance entre ces registres est illustr√©e dans l'image ci-dessous. <br><br><img src="https://habrastorage.org/webt/jr/lo/w0/jrlow0oljuvwjd0y5bb-qkxlyh4.png"><br><br>  Q0-Q15 sont des registres 128 bits d'anciennes versions pour travailler avec SIMD, plus √† leur sujet plus tard. <br><br><h3>  Syst√®me de commande </h3><br>  Bien s√ªr, le plus souvent, le travail avec les registres VFP doit √™tre confi√© au compilateur, mais au moins vous devez √©crire le changement de contexte manuellement.  Si vous avez d√©j√† une compr√©hension approximative de la syntaxe des instructions d'assembleur pour travailler avec des registres √† usage g√©n√©ral, le traitement des nouvelles instructions ne devrait pas √™tre difficile.  Le plus souvent, le pr√©fixe ¬´v¬ª est simplement ajout√©. <br><br><pre> <code class="hljs powershell">vmov d0, r0, r1 /*  r0  r1, ..  d0 <span class="hljs-number"><span class="hljs-number">64</span></span> ,   r0<span class="hljs-literal"><span class="hljs-literal">-1</span></span>  <span class="hljs-number"><span class="hljs-number">32</span></span> */ vmov r0, r1, d0 vadd d0, d1, d2 vldr d0, r0 vstm r0!, {d0<span class="hljs-literal"><span class="hljs-literal">-d15</span></span>} vldm r0!, {d0<span class="hljs-literal"><span class="hljs-literal">-d15</span></span>}</code> </pre> <br>  Et ainsi de suite.  Une liste compl√®te des commandes se trouve sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le site Web d'ARM</a> . <br><br>  Et bien s√ªr, n'oubliez pas la version VFP pour qu'il n'y ait pas de situations comme celle d√©crite ci-dessus. <br><br><h2>  Drapeau -mfloat-abi 'softfp' et 'hard' </h2><br>  Retour √† -mfloat-abi.  Si vous lisez la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> , nous verrons: <br><blockquote>  'softfp' permet la g√©n√©ration de code √† l'aide d'instructions mat√©rielles √† virgule flottante, mais utilise toujours les conventions d'appel soft-float.  'hard' permet la g√©n√©ration d'instructions √† virgule flottante et utilise des conventions d'appel sp√©cifiques aux FPU. </blockquote>  Autrement dit, nous parlons de passer des arguments √† une fonction.  Mais au moins, il n‚Äô√©tait pas tr√®s clair pour moi quelle est la diff√©rence entre les conventions d‚Äôappel ¬´flottant¬ª et ¬´sp√©cifiques aux FPU¬ª.  En supposant que le bo√Ætier rigide utilise des registres √† virgule flottante et le bo√Ætier softfp utilise des registres entiers, j'ai trouv√© une confirmation sur le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">wiki Debian</a> .  Et bien que ce soit pour les coprocesseurs NEON, mais cela n'a pas d'importance.  Un autre point int√©ressant est qu'avec l'option softfp, le compilateur peut, mais n'est pas oblig√© d'utiliser le support mat√©riel: <br><blockquote>  "Le compilateur peut faire des choix intelligents quant au moment et s'il g√©n√®re des instructions FPU √©mul√©es ou r√©elles en fonction du type de FPU choisi (-mfpu =)" </blockquote>  Pour plus de clart√©, j'ai d√©cid√© d'exp√©rimenter et j'ai √©t√© tr√®s surpris, car avec l'optimisation -O0 d√©sactiv√©e, la diff√©rence √©tait tr√®s faible et ne s'appliquait pas aux endroits o√π la virgule flottante √©tait r√©ellement utilis√©e.  En supposant que le compilateur pousse simplement tout sur la pile, plut√¥t que d'utiliser des registres, j'ai activ√© l'optimisation -O2 et j'ai de nouveau √©t√© surpris, car avec l'optimisation, le compilateur a commenc√© √† utiliser des registres mat√©riels √† virgule flottante pour les options mat√©rielles et sotffp, et la diff√©rence est, comme et dans le cas de -O0, c'√©tait tr√®s insignifiant.  En cons√©quence, pour moi, j'ai expliqu√© cela par le fait que le compilateur r√©sout le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">probl√®me</a> associ√© au fait que si vous copiez des donn√©es entre des registres √† virgule flottante et des entiers, les performances chuteront consid√©rablement.  Et le compilateur, lors de l'optimisation, commence √† utiliser toutes les ressources √† sa disposition. <br><br>  Lorsqu'on m'a demand√© quel drapeau utiliser 'softfp' ou 'hard', j'ai r√©pondu moi-m√™me comme suit: partout o√π il y a d√©j√† des parties compil√©es avec le drapeau 'softfp', vous devez utiliser 'hard'.  S'il y en a, vous devez utiliser 'softfp'. <br><br><h2>  Changement de contexte </h2><br>  √âtant donn√© qu'Embox prend en charge le multit√¢che pr√©emptif, pour fonctionner correctement lors de l'ex√©cution, une impl√©mentation du changement de contexte √©tait naturellement n√©cessaire.  Pour ce faire, vous devez enregistrer les registres du coprocesseur.  Il y a quelques nuances.  Premi√®rement: il s'est av√©r√© que <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les commandes d'op√©ration de pile pour les virgules flottantes (vstm / vldm) ne prennent pas en charge tous les modes</a> .  Deuxi√®mement: ces op√©rations ne prennent pas en charge le travail avec plus de seize registres 64 bits.  Si vous devez charger / enregistrer plus de registres √† la fois, vous devez utiliser deux instructions. <br><br>  Je vais donner une autre petite optimisation.  En fait, la sauvegarde et la restauration de 256 octets de registres VFP √† chaque fois ne sont pas du tout n√©cessaires (les registres √† usage g√©n√©ral n'occupent que 64 octets, donc la diff√©rence est significative).  Une optimisation √©vidente n'effectuera ces op√©rations que si le processus utilise en principe ces registres. <br><br>  Comme je l'ai d√©j√† mentionn√©, lorsque le coprocesseur VFP est √©teint, une tentative d'ex√©cution de l'instruction correspondante entra√Ænera une exception ¬´Instruction non d√©finie¬ª.  Dans le gestionnaire de cette exception, vous devez v√©rifier la cause de l'exception et s'il s'agit d'utiliser un coprocesseur VPF, le processus est marqu√© comme utilisant le coprocesseur VFP. <br><br>  En cons√©quence, la sauvegarde / restauration du contexte d√©j√† √©crite a √©t√© compl√©t√©e par des macros <br><br><pre> <code class="hljs tex">#define ARM_FPU_CONTEXT_SAVE_INC(tmp, stack) <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>vmrs tmp, FPEXC ; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>stmia stack!, {tmp}; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ands tmp, tmp, #1&lt;&lt;30; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>beq fpu_out_save_inc; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>vstmia stack!, {d0-d15}; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>fpu_out_save_inc: #define ARM_FPU_CONTEXT_LOAD_INC(tmp, stack) <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ldmia stack!, {tmp}; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>vmsr FPEXC, tmp; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ands tmp, tmp, #1&lt;&lt;30; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>beq fpu_out_load_inc; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>vldmia stack!, {d0-d15}; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>fpu_out_load_inc:</code> </pre> <br>  Pour v√©rifier l'exactitude de l'op√©ration de changement de contexte dans des conditions √† virgule flottante, nous avons √©crit un test dans lequel nous multiplions dans un thread dans une boucle et divisons dans un autre, puis comparons les r√©sultats. <br><br><pre> <code class="cpp hljs">EMBOX_TEST_SUITE(<span class="hljs-string"><span class="hljs-string">"FPU context consistency test. Must be compiled with -02"</span></span>); <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> TICK_COUNT 10 static float res_out[2][TICK_COUNT]; static void *fpu_context_thr1_hnd(void *arg) { float res = 1.0f; int i; for (i = 0; i </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; TICK_COUNT; ) { res_out[0][i] = res; if (i == 0 || res_out[1][i - 1] &gt; 0) { i++; } if (res &gt; 0.000001f) { res /= 1.01f; } sleep(0); } return NULL; } static void *fpu_context_thr2_hnd(void *arg) { float res = 1.0f; int i = 0; for (i = 0; i &lt; TICK_COUNT; ) { res_out[1][i] = res; if (res_out[0][i] != 0) { i++; } if (res &lt; 1000000.f) { res *= 1.01f; } sleep(0); } return NULL; } TEST_CASE("Test FPU context consistency") { pthread_t threads[2]; pthread_t tid = 0; int status; status = pthread_create(&amp;threads[0], NULL, fpu_context_thr1_hnd, &amp;tid); if (status != 0) { test_assert(0); } status = pthread_create(&amp;threads[1], NULL, fpu_context_thr2_hnd, &amp;tid); if (status != 0) { test_assert(0); } pthread_join(threads[0], (void**)&amp;status); pthread_join(threads[1], (void**)&amp;status); test_assert(res_out[0][0] != 0 &amp;&amp; res_out[1][0] != 0); for (int i = 1; i &lt; TICK_COUNT; i++) { test_assert(res_out[0][i] &lt; res_out[0][i - 1]); test_assert(res_out[1][i] &gt; res_out[1][i - 1]); } }</span></span></span></span></code> </pre> <br>  Le test a r√©ussi avec succ√®s lorsque l'optimisation a √©t√© d√©sactiv√©e, nous avons donc indiqu√© dans la description du test qu'il devait √™tre compil√© avec l'optimisation, EMBOX_TEST_SUITE ("Test de coh√©rence du contexte FPU. Doit √™tre compil√© avec -02");  m√™me si nous savons que les tests ne doivent pas reposer <br><br><h2>  Coprocesseur NEON et SIMD </h2><br>  Il est temps de dire pourquoi j'ai report√© l'histoire sur imx6.  Le fait est qu'il est bas√© sur le noyau Cortex-A9 et contient le coprocesseur NEON le plus avanc√© (https://developer.arm.com/technologies/neon).  NEON n'est pas seulement VFPv3, mais c'est aussi un coprocesseur SIMD.  VFP et NEON utilisent les m√™mes registres.  VFP utilise des registres 32 bits et 64 bits pour le fonctionnement, et NEON utilise des registres 64 bits et 128 bits, ces derniers √©tant simplement d√©sign√©s Q0-Q16.  En plus des valeurs enti√®res et des nombres √† virgule flottante, NEON est √©galement capable de travailler avec un anneau polynomial de 16 ou 8e degr√© modulo 2. <br><br>  Le mode vfp pour NEON n'est presque pas diff√©rent du coprocesseur vfp9-s d√©mont√©.  Bien s√ªr, il est pr√©f√©rable de sp√©cifier les options vfpv3 ou vfpv3-d32 pour -mfpu pour une meilleure optimisation, car il dispose de 32 registres 64 bits.  Et pour activer le coprocesseur, vous devez donner acc√®s aux coprocesseurs c10 et c11.  cela se fait √† l'aide de commandes <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/* Allow access to c10 &amp; c11 coprocessors */</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"mrc p15, 0, %0, c1, c0, 2"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"=r"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (val) :)</span></span></span></span>; val |= <span class="hljs-number"><span class="hljs-number">0xf</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">20</span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">asm</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">volatile</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"mcr p15, 0, %0, c1, c0, 2"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> : : </span></span><span class="hljs-string"><span class="hljs-function"><span class="hljs-params"><span class="hljs-string">"r"</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (val))</span></span></span></span>;</code> </pre> <br>  mais il n'y a pas d'autres diff√©rences fondamentales. <br><br>  Une autre chose si vous sp√©cifiez -mfpu = neon, dans ce cas, le compilateur peut utiliser des instructions SIMD. <br><br><h2>  Utilisation de SIMD en C </h2><br>  Pour &lt;&lt; enregistrer &gt;&gt; les valeurs manuellement par registre, vous pouvez inclure "arm_neon.h" et utiliser les types de donn√©es correspondants: <br>  float32x4_t pour quatre flottants 32 bits dans un registre, uint8x8_t pour huit entiers 8 bits et ainsi de suite.  Pour acc√©der √† une seule valeur, nous l'appelons tableau, addition, multiplication, affectation, etc.  comme pour les variables ordinaires, par exemple: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32x4_t</span></span> a = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>}, b = {<span class="hljs-number"><span class="hljs-number">5</span></span>, <span class="hljs-number"><span class="hljs-number">6</span></span>, <span class="hljs-number"><span class="hljs-number">7</span></span>, <span class="hljs-number"><span class="hljs-number">8</span></span>}; <span class="hljs-keyword"><span class="hljs-keyword">uint32x4_t</span></span> c = a * b; <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(‚ÄúResult=[%d, %d, %d, %d]\n‚Äù, c[<span class="hljs-number"><span class="hljs-number">0</span></span>], c[<span class="hljs-number"><span class="hljs-number">1</span></span>], c[<span class="hljs-number"><span class="hljs-number">2</span></span>], c[<span class="hljs-number"><span class="hljs-number">3</span></span>]);</code> </pre> <br>  Bien s√ªr, l'utilisation de la vectorisation automatique est plus facile.  Pour la vectorisation automatique, ajoutez l'indicateur -ftree-vectorize √† GCC. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">simd_test</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a[LEN], b[LEN], c[LEN]; <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; LEN; i++) { a[i] = i; b[i] = LEN - i; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; LEN; i++) { c[i] = a[i] + b[i]; } <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; LEN; i++) { <span class="hljs-built_in"><span class="hljs-built_in">printf</span></span>(<span class="hljs-string"><span class="hljs-string">"c[i] = %d\n"</span></span>, c[i]); } }</code> </pre> <br>  La boucle d'addition g√©n√®re le code suivant: <br><br><pre> <code class="hljs delphi"><span class="hljs-number"><span class="hljs-number">600059</span></span>a0: f4610adf vld1.<span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-comment"><span class="hljs-comment">{d16-d17}</span></span>, [r1 :<span class="hljs-number"><span class="hljs-number">64</span></span>] <span class="hljs-number"><span class="hljs-number">600059</span></span>a4: e2833010 add r3, r3, <span class="hljs-string"><span class="hljs-string">#16</span></span> <span class="hljs-number"><span class="hljs-number">600059</span></span>a8: e28d0a03 add r0, sp, <span class="hljs-string"><span class="hljs-string">#12288</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span>x3000 <span class="hljs-number"><span class="hljs-number">600059</span></span>ac: e2811010 add r1, r1, <span class="hljs-string"><span class="hljs-string">#16</span></span> <span class="hljs-number"><span class="hljs-number">600059</span></span>b0: f4622adf vld1.<span class="hljs-number"><span class="hljs-number">64</span></span> <span class="hljs-comment"><span class="hljs-comment">{d18-d19}</span></span>, [r2 :<span class="hljs-number"><span class="hljs-number">64</span></span>] <span class="hljs-number"><span class="hljs-number">600059</span></span>b4: e2822010 add r2, r2, <span class="hljs-string"><span class="hljs-string">#16</span></span> <span class="hljs-number"><span class="hljs-number">600059</span></span>b8: f26008e2 vadd.i32 q8, q8, q9 <span class="hljs-number"><span class="hljs-number">600059</span></span>bc: ed430b04 vstr d16, [r3, #-<span class="hljs-number"><span class="hljs-number">16</span></span>] <span class="hljs-number"><span class="hljs-number">600059</span></span>c0: ed431b02 vstr d17, [r3, #-<span class="hljs-number"><span class="hljs-number">8</span></span>] <span class="hljs-number"><span class="hljs-number">600059</span></span>c4: e1530000 cmp r3, r0 <span class="hljs-number"><span class="hljs-number">600059</span></span>c8: <span class="hljs-number"><span class="hljs-number">1</span></span>afffff4 bne <span class="hljs-number"><span class="hljs-number">600059</span></span>a0 &lt;foo+<span class="hljs-number"><span class="hljs-number">0</span></span>x58&gt; <span class="hljs-number"><span class="hljs-number">600059</span></span>cc: e28d5dbf add r5, sp, <span class="hljs-string"><span class="hljs-string">#12224</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span>x2fc0 <span class="hljs-number"><span class="hljs-number">600059</span></span>d0: e2444004 sub r4, r4, <span class="hljs-string"><span class="hljs-string">#4</span></span> <span class="hljs-number"><span class="hljs-number">600059</span></span>d4: e285503c add r5, r5, <span class="hljs-string"><span class="hljs-string">#60</span></span> ; <span class="hljs-number"><span class="hljs-number">0</span></span>x3c</code> </pre> <br>  Apr√®s avoir effectu√© des tests de code parall√©lis√©, nous avons constat√© qu'un simple ajout dans une boucle, √† condition que les variables soient ind√©pendantes, donne une acc√©l√©ration jusqu'√† 7 fois.  De plus, nous avons d√©cid√© de voir dans quelle mesure la parall√©lisation affecte les t√¢ches r√©elles, avons pris MESA3d avec son √©mulation logicielle et mesur√© le nombre de fps avec diff√©rents drapeaux, nous avons obtenu un gain de 2 images par seconde (15 contre 13), c'est-√†-dire que l'acc√©l√©ration est d'environ 15-20% . <br><br>  Je vais <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">donner</a> un autre <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exemple d'acc√©l√©ration en utilisant des commandes NEON</a> , pas les n√¥tres, mais de ARM. <br><br>  La copie de la m√©moire est jusqu'√† 50% plus rapide que la normale.  De vrais exemples sont l√† dans l'assembleur. <br><br>  Cycle de copie normal: <br><br><pre> <code class="hljs css"><span class="hljs-selector-tag"><span class="hljs-selector-tag">WordCopy</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">LDR</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r3</span></span>, <span class="hljs-selector-attr"><span class="hljs-selector-attr">[r1]</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">STR</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r3</span></span>, <span class="hljs-selector-attr"><span class="hljs-selector-attr">[r0]</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">SUBS</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">r2</span></span>, <span class="hljs-selector-tag"><span class="hljs-selector-tag">r2</span></span>, <span class="hljs-selector-id"><span class="hljs-selector-id">#4</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">BGE</span></span> <span class="hljs-selector-tag"><span class="hljs-selector-tag">WordCopy</span></span></code> </pre> <br>  boucle avec des commandes et registres n√©on: <br><br><pre> <code class="hljs erlang-repl">NEONCopyPLD PLD [r1, #<span class="hljs-number"><span class="hljs-number">0</span></span>xC0] VLDM r1!,{d0-d7} VSTM r0!,{d0-d7} SUBS r2,r2,#<span class="hljs-number"><span class="hljs-number">0</span></span>x40 BGE NEONCopyPLD</code> </pre> <br>  Il est clair que la copie sur 64 octets est plus rapide que 4 octets, et une telle copie donnera une augmentation de 10%, mais les 40% restants semblent donner le travail du coprocesseur. <br><br><h2>  Cortex-m </h2><br>  Travailler avec des FPU dans Cortex-M n'est pas tr√®s diff√©rent de celui d√©crit ci-dessus.  Par exemple, voici √† quoi ressemble la macro ci-dessus pour enregistrer le contexte fpu-shny <br><br><pre> <code class="hljs tex">#define ARM_FPU_CONTEXT_SAVE_INC(tmp, stack) <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ldr tmp, =CPACR; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>ldr tmp, [tmp]; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>tst tmp, #0xF00000; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>beq fpu_out_save_inc; <span class="hljs-tag"><span class="hljs-tag">\</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name"> </span></span></span></span>vstmia stack!, {s0-s31}; fpu_out_save_inc:</code> </pre> <br>  De plus, la commande vstmia utilise uniquement les registres s0-s31 et les registres de contr√¥le sont accessibles diff√©remment.  Par cons√©quent, je n'entrerai pas dans trop de d√©tails, je ne vous expliquerai que les diff.  Nous avons donc pris en charge la d√©couverte de STM32F7 avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cortex-m7</a> pour cela, respectivement, nous devons d√©finir l'indicateur -mfpu = fpv5-sp-d16.  Veuillez noter que dans les versions mobiles, vous devez regarder de plus pr√®s la version du coprocesseur, car le m√™me cortex-m peut avoir des options diff√©rentes.  Donc, si votre option n'est pas en double pr√©cision, mais en simple, alors il peut ne pas y avoir de registres D0-D16, comme nous l'avons dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">stm32f4discovery</a> , c'est pourquoi la variante avec les registres S0-S31 est utilis√©e.  Pour ce contr√¥leur, nous utilisons -mfpu = fpv4-sp-d16. <br><br>  La principale diff√©rence est l'acc√®s aux registres de contr√¥le du contr√¥leur, ils sont situ√©s directement dans l'espace d'adressage du noyau principal, et pour diff√©rents types ils sont diff√©rents <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cortex-m4</a> pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">cortex-m7</a> . <br><br><h2>  Conclusion </h2><br>  Sur ce, je terminerai ma courte histoire sur la virgule flottante pour ARM.  Je note que les microcontr√¥leurs modernes sont tr√®s puissants et conviennent non seulement pour le contr√¥le, mais aussi pour le traitement de signaux ou de divers types d'informations multim√©dias.  Afin d'utiliser efficacement tout ce pouvoir, vous devez comprendre comment il fonctionne.  J'esp√®re que cet article a aid√© √† comprendre cela un peu mieux. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr418295/">https://habr.com/ru/post/fr418295/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr418285/index.html">Les climatologues ont montr√© comment l'humanit√© affecte les variations saisonni√®res de la temp√©rature atmosph√©rique</a></li>
<li><a href="../fr418287/index.html">Liste de contr√¥le obligatoire pour le d√©veloppement de la conception UX d'une application mobile</a></li>
<li><a href="../fr418289/index.html">Comment les solutions informatiques aident √† organiser la tarification dynamique en magasin</a></li>
<li><a href="../fr418291/index.html">DEFCON 19. Conf√©rence ¬´Volez tout, tuez tout le monde, provoquez un effondrement financier complet¬ª! Rue Jason E.</a></li>
<li><a href="../fr418293/index.html">Test automatis√© de l'interface Web chez Virto Commerce</a></li>
<li><a href="../fr418297/index.html">Courte critique du smartphone Neffos N1</a></li>
<li><a href="../fr418301/index.html">La grande confrontation de Mars en 2018: comment observer et √† quoi s'attendre</a></li>
<li><a href="../fr418303/index.html">Vanessa-Automation - un outil pour tester des solutions applicatives sur la plateforme 1C: Enterprise</a></li>
<li><a href="../fr418305/index.html">Combien d'objets Python √©met-il lors de l'ex√©cution de scripts?</a></li>
<li><a href="../fr418307/index.html">Outils d'apprentissage automatique Apple</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>