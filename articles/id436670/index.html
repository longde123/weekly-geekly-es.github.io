<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😾 🚬 👶🏻 Cara menggulung pembaruan dalam produksi secara otomatis ♊️ 🎦 👩🏿‍✈️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Meluncurkan versi baru dalam operasi tempur selalu merupakan peristiwa yang menegangkan. Apalagi jika prosesnya melibatkan banyak operasi manual. Fakt...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Cara menggulung pembaruan dalam produksi secara otomatis</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/microsoft/blog/436670/">  Meluncurkan versi baru dalam operasi tempur selalu merupakan peristiwa yang menegangkan.  Apalagi jika prosesnya melibatkan banyak operasi manual.  Faktor manusia adalah hal yang mengerikan.  "Akan menyenangkan untuk mengotomatisasi proses ini" - ide ini setua seluruh dunia TI.  Dan ada istilah untuk ini - Penyebaran Berkelanjutan.  Ya, masalahnya adalah, tidak ada cara unik untuk mengonfigurasi penerapan berkelanjutan ini.  Sangat banyak proses ini terkait dengan tumpukan teknologi proyek dan lingkungannya. <br><br>  Pada artikel ini saya ingin berbagi pengalaman praktis dalam menyiapkan pembaruan sistem otomatis tanpa mengganggu operasinya untuk lingkungan teknologi tertentu, yaitu: ASP.NET MVC + Azure SQL + aplikasi kerangka kerja Entitas dalam mode Code Pertama, aplikasi ini digunakan di Azure sebagai Layanan Aplikasi , dan perakitan dan penyebaran dilakukan melalui Azure DevOps (sebelumnya Visual Studio Team Services). <br><br><img src="https://habrastorage.org/webt/ji/6o/8j/ji6o8j6s6ignpfqyorvdmaxcotk.jpeg"><a name="habracut"></a><br><br>  Sekilas, semuanya sangat sederhana, Azure App Service memiliki konsep slot penempatan - unduh versi baru di sana dan nyalakan.  Tetapi akan sederhana jika proyek didasarkan pada DBMS non-relasional, di mana tidak ada skema data yang kaku.  Dalam hal ini, ya - hanya versi baru yang mengambil traffic dan voila.  Tetapi dengan DBMS relasional, semuanya agak lebih rumit. <br><br>  Faktor utama yang mencegah kami menerapkan penyebaran berkelanjutan untuk tumpukan teknologi kami adalah sebagai berikut: <br><br><ul><li>  Versi aplikasi yang lama tidak dapat berfungsi dengan struktur basis data yang baru </li><li>  Memperbarui struktur basis data dapat memakan waktu yang cukup lama dan tidak selalu memungkinkan menggunakan aplikasi itu sendiri melalui mekanisme migrasi otomatis. </li></ul><br>  Saya akan jelaskan.  Misalkan Anda menggunakan versi baru di slot paralel atau di pusat data cadangan dan memulai aplikasi migrasi.  Misalkan kita memiliki tiga migrasi dan, horor, dua telah bergulir, dan yang ketiga telah jatuh.  Pada saat ini, tidak ada yang akan terjadi pada server yang berfungsi, Entity Framework tidak memeriksa versi untuk setiap permintaan, tetapi Anda mungkin tidak akan dapat dengan cepat menyelesaikan masalah.  Pada saat ini, beban pada aplikasi dapat meningkat, dan platform akan meluncurkan instance tambahan aplikasi untuk Anda, dan itu ... secara alami tidak akan dimulai, karena struktur basis data telah berubah.  Sebagian besar pengguna akan mulai menerima kesalahan.  Dengan demikian, risiko aplikasi migrasi otomatis menjadi besar. <br><br><img src="https://habrastorage.org/webt/zv/kf/xv/zvkfxv1rthfzrgpmduxbjkv8ods.png"><br><br>  Adapun poin kedua, migrasi Anda mungkin berisi beberapa jenis perintah yang waktu eksekusi melebihi 30 detik dan prosedur standar akan habis.  Nah, selain poin-poin ini, saya pribadi tidak suka fakta bahwa selama migrasi otomatis Anda dipaksa untuk meningkatkan bagian dari infrastruktur ke versi baru.  Dan jika untuk mode dengan slot di Azure ini tidak begitu menakutkan, maka untuk mode dengan pusat data cadangan, Anda mendapatkan bagian dari infrastruktur dengan aplikasi yang dikenal tidak beroperasi.  Itu semua berbahaya, itu akan menembak pada saat yang paling tidak tepat. <br><br><h2>  Apa yang harus dilakukan </h2><br>  Mari kita mulai dengan yang paling sulit - dengan database.  Jadi, alangkah baiknya jika entah bagaimana secara otomatis memperbarui struktur basis data sehingga versi lama aplikasi terus bekerja.  Selain itu, akan lebih baik untuk mempertimbangkan fakta bahwa ada pembaruan seperti itu di mana perintah terpisah dapat dieksekusi untuk waktu yang cukup lama, yang berarti kita perlu memperbarui basis data tidak menggunakan mekanisme bawaan tetapi dengan menjalankan skrip SQL terpisah.  Pertanyaan: bagaimana menyiapkannya?  Anda dapat membuat proses manual ini.  Jika Anda memiliki peran manajer rilis terpisah di tim, Anda bisa memaksanya untuk menjalankan perintah di Visual Studio: <br><br><pre><code class="cpp hljs">update-database -script</code> </pre> <br>  Dia akan menghasilkan skrip, dan orang ini akan meletakkan skrip ini di folder proyek tertentu.  Tetapi Anda harus mengakui, ini masih merepotkan, pertama, faktor manusia, dan kedua, kesulitan yang tidak perlu jika ada lebih dari satu migrasi antar rilis.  Atau karena alasan tertentu, satu rilis dilewati pada sistem target.  Kami harus membuat semacam taman rumit dengan melacak migrasi mana yang sudah ada dan yang perlu diluncurkan.  Ini sulit dan, yang paling penting, ini adalah sepeda yang sama yang telah dibuat dalam mekanisme migrasi. <br><br>  Dan akan benar untuk membangun pembuatan skrip dan proses eksekusi ke dalam proses perhitungan rilis.  Untuk menghasilkan skrip migrasi, Anda bisa menggunakan utilitas migrate.exe, yang disertakan dengan Entity Framework.  Saya menarik perhatian Anda pada fakta bahwa Anda memerlukan Entity Framework versi 6.2 atau lebih tinggi, karena opsi pembuatan skrip muncul di utilitas ini hanya pada bulan April 2017.  Panggilan utilitas terlihat seperti ini: <br><br><pre> <code class="cpp hljs">migrate.exe Context.dll /connectionString=<span class="hljs-string"><span class="hljs-string">"Data Source=localhost;Initial Catalog=myDB;User Id=sa;Password=myPassword;"</span></span> /connectionProviderName=<span class="hljs-string"><span class="hljs-string">"System.Data.SqlClient"</span></span> /sc /startUpDirectory=<span class="hljs-string"><span class="hljs-string">"c:\projects\MyProject\bin\Release"</span></span> /verbose</code> </pre> <br>  Nama rakitan ditunjukkan di mana Konteks Anda berada, string koneksi ke database target, penyedia, dan, yang sangat penting, direktori awal, yang berisi rakitan dengan konteks dan rakitan Entity Framework.  Jangan bereksperimen dengan nama-nama direktori kerja, lebih sederhana.  Kami menemukan fakta bahwa migrate.exe tidak dapat membaca direktori, dengan nama yang ada spasi dan karakter non-huruf. <br><br>  Di sini perlu untuk melakukan penyimpangan penting.  Faktanya adalah bahwa setelah menjalankan perintah di atas, satu skrip SQL akan dihasilkan berisi semua perintah untuk semua migrasi yang perlu diterapkan ke database target.  Untuk Microsoft SQL Server, ini tidak terlalu baik.  Faktanya adalah bahwa server mengeksekusi perintah tanpa pemisah GO sebagai paket tunggal, dan beberapa operasi tidak dapat dilakukan bersama dalam satu paket tunggal. <br><br>  Misalnya, dalam beberapa kasus, menambahkan bidang ke tabel dan segera membuat indeks pada tabel ini dengan bidang baru tidak berfungsi.  Tetapi ini tidak cukup, beberapa perintah memerlukan pengaturan lingkungan tertentu ketika menjalankan skrip.  Pengaturan tersebut diaktifkan secara default ketika Anda terhubung ke SQL Server melalui SQL Server Management Studio, tetapi ketika skrip dieksekusi melalui utilitas konsol SQLCMD, mereka harus diatur secara manual.  Untuk memperhitungkan semua ini, Anda harus memodifikasi proses pembuatan skrip migrasi dengan file.  Untuk melakukan ini, buat kelas tambahan di sebelah konteks tanggal, yang melakukan semua yang Anda butuhkan: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MigrationScriptBuilder</span></span></span><span class="hljs-class"> :</span></span> SqlServerMigrationSqlGenerator { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> override IEnumerable&lt;MigrationStatement&gt; Generate(IEnumerable&lt;MigrationOperation&gt; migrationOperations, <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> providerManifestToken) { var statements = base.Generate(migrationOperations, providerManifestToken); var result = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> List&lt;MigrationStatement&gt;(); result.Add(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MigrationStatement { Sql = <span class="hljs-string"><span class="hljs-string">"SET QUOTED_IDENTIFIER ON;"</span></span> }); foreach (var item in statements) { item.BatchTerminator = <span class="hljs-string"><span class="hljs-string">"GO"</span></span>; result.Add(item); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result; } }</code> </pre><br>  Dan agar Kerangka Entitas dapat menggunakannya, daftarkan di kelas Konfigurasi, yang biasanya terletak di folder Migrasi: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Configuration</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ SetSqlGenerator(<span class="hljs-string"><span class="hljs-string">"System.Data.SqlClient"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MigrationScriptBuilder()); …. }</code> </pre><br>  Setelah itu, skrip migrasi yang dihasilkan akan berisi GO di antara setiap pernyataan, dan pada awal file akan berisi SET QUOTED_IDENTIFIER ON; <br><br>  Hore, persiapan sudah selesai, masih untuk mengkonfigurasi proses itu sendiri.  Secara umum, sebagai bagian dari proses rilis di Azure DevOps (VSTS / TFS), ini sudah cukup sederhana.  Kita perlu membuat skrip PowerShell seperti ini: <br><br><pre> <code class="cpp hljs">param ( [<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>] [Parameter(Mandatory=$<span class="hljs-literal"><span class="hljs-literal">true</span></span>)] $dbserver, [<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>] [Parameter(Mandatory=$<span class="hljs-literal"><span class="hljs-literal">true</span></span>)] $dbname, [<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>] [Parameter(Mandatory=$<span class="hljs-literal"><span class="hljs-literal">true</span></span>)] $dbserverlogin, [<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>] [Parameter(Mandatory=$<span class="hljs-literal"><span class="hljs-literal">true</span></span>)] $dbserverpassword, [<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>] [Parameter(Mandatory=$<span class="hljs-literal"><span class="hljs-literal">true</span></span>)] $rootPath, [<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>] [Parameter(Mandatory=$<span class="hljs-literal"><span class="hljs-literal">true</span></span>)] $buildAliasName, [<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>] [Parameter(Mandatory=$<span class="hljs-literal"><span class="hljs-literal">true</span></span>)] $contextFilesLocation, ) Write-Host <span class="hljs-string"><span class="hljs-string">"Generating migration script..."</span></span> $fullpath=<span class="hljs-string"><span class="hljs-string">"$rootPath\$buildAliasName\$contextFilesLocation"</span></span> Write-Host $fullpath &amp; <span class="hljs-string"><span class="hljs-string">"$fullpath\migrate.exe"</span></span> Context.dll /connectionProviderName=<span class="hljs-string"><span class="hljs-string">"System.Data.SqlClient"</span></span> /connectionString=<span class="hljs-string"><span class="hljs-string">"Server=tcp:$dbserver.database.windows.net,1433;Initial Catalog=$dbname;Persist Security Info=False;User ID=$dbserverlogin;Password=$dbserverpassword;MultipleActiveResultSets=False;Encrypt=True;TrustServerCertificate=False;Connection Timeout=30;"</span></span> /startUpDirectory=$fullpath /verbose /scriptFile=<span class="hljs-number"><span class="hljs-number">1.</span></span>SQL Write-Host <span class="hljs-string"><span class="hljs-string">"Running migration script..."</span></span> &amp; <span class="hljs-string"><span class="hljs-string">"SQLCMD"</span></span> -S <span class="hljs-string"><span class="hljs-string">"$dbserver.database.windows.net"</span></span> -U $dbserverlogin@$dbserver -P $dbserverpassword -d $dbname -i <span class="hljs-number"><span class="hljs-number">1.</span></span>SQL Write-Host <span class="hljs-string"><span class="hljs-string">"====Finished with migration script===="</span></span></code> </pre><br>  Dan tambahkan unit eksekusi skrip PowerShell ke proses perhitungan rilis.  Blok dan pengaturannya mungkin terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/2u/j4/vg/2uj4vgqd6vsvkmwpbdx2afxinho.png"><br><br>  Pengaturan PowerShell terlihat seperti ini: <br><br><img src="https://habrastorage.org/webt/p4/lg/47/p4lg47g_ympywrtn6ewk-wmgp8g.png"><br><br>  Penting untuk tidak lupa menambahkan file migrate.exe ke proyek dari folder &lt;YourProject&gt; /packages/EntityFramework.6.2.0/tools/ dan atur properti Copy Always ke sana sehingga utilitas ini disalin ke direktori output ketika proyek dibangun dan Anda dapat mengaksesnya di Rilis Azure DevOps. <br><br>  <b>Nuansa itu</b> .  Jika proyek Anda juga menggunakan WebJob saat menggunakan untuk Layanan Aplikasi Azure, maka menambahkan Migrate.exe ke proyek Anda tidak aman.  Kami dihadapkan dengan fakta bahwa di folder tempat WebJob Anda diterbitkan, platform Azure memulai dengan bodoh file exe pertama yang muncul.  Dan jika WebJob Anda secara alfabetis biaya migrate.exe nanti (dan kami lakukan), maka ia mencoba menjalankan migrate.exe alih-alih proyek Anda! <br><br>  Jadi, kami mempelajari cara memperbarui versi database dengan membuat skrip selama proses rilis, hal yang sederhana adalah: matikan pemeriksaan versi migrasi sehingga jika ada kegagalan dalam proses eksekusi skrip, versi lama kode kami terus berfungsi.  Saya pikir tidak perlu mengatakan bahwa migrasi Anda harus tidak merusak.  Yaitu  perubahan pada struktur basis data seharusnya tidak mengganggu kinerja versi sebelumnya, tetapi lebih baik dari dua versi sebelumnya.  Untuk menonaktifkan verifikasi, Anda hanya perlu menambahkan blok berikut ke Web.config: <br><br><pre> <code class="cpp hljs"> &lt;entityFramework&gt; &lt;contexts&gt; &lt;context type=<span class="hljs-string"><span class="hljs-string">"&lt;full namespace for your DataContext class&gt;, MyAssembly"</span></span> disableDatabaseInitialization=<span class="hljs-string"><span class="hljs-string">"true"</span></span>/&gt; &lt;/contexts&gt; &lt;/entityFramework&gt;</code> </pre><br>  Di mana <code>full namespace for your DataContext class</code> adalah namespace penuh untuk keturunan Anda dari DbContext, dan MyAssembly adalah nama majelis tempat konteks Anda berada. <br><br>  Dan akhirnya, sangat diinginkan bagi kami untuk memastikan aplikasi ini memanas sebelum mengalihkan pengguna ke versi baru.  Untuk melakukan ini, tambahkan blok khusus ke web.config dengan tautan yang secara otomatis keluar dari aplikasi Anda selama proses inisialisasi: <br><br><pre> <code class="cpp hljs"> &lt;system.webServer&gt; &lt;applicationInitialization doAppInitAfterRestart=<span class="hljs-string"><span class="hljs-string">"true"</span></span>&gt; &lt;add initializationPage=<span class="hljs-string"><span class="hljs-string">"/"</span></span> hostName=<span class="hljs-string"><span class="hljs-string">""</span></span> /&gt; &lt;/applicationInitialization&gt; &lt;/system.webServer&gt;</code> </pre><br>  Anda dapat menambahkan beberapa tautan hanya dengan menambahkan <code>/&gt;</code> Ada argumen bahwa di Azure, ketika berpindah slot, platform menunggu aplikasi diinisialisasi dan baru kemudian mengalihkan lalu lintas ke versi baru. <br><br><h2>  Tapi bagaimana dengan proyek di .NET Core? </h2><br>  Semuanya jauh lebih sederhana dan pada saat yang sama berbeda.  Skrip migrasi dapat dibuat menggunakan alat biasa, tetapi tidak didasarkan pada perakitan yang selesai, tetapi berdasarkan pada file proyek.  Dengan demikian, skrip harus dibentuk sebagai bagian dari proses perakitan proyek dan harus dimasukkan sebagai artefak perakitan.  Dalam hal ini, skrip akan berisi semua perintah semua migrasi dari awal waktu.  Tidak ada masalah dalam hal ini, karena skrip idempoten, yaitu  itu dapat diterapkan ke basis target berulang kali tanpa konsekuensi.  Ini memiliki konsekuensi lain yang bermanfaat: kita tidak perlu memodifikasi proses pembuatan skrip untuk memisahkan perintah menjadi paket, semuanya sudah dilakukan untuk ini. <br><br>  Secara khusus, langkah-langkah prosesnya terlihat seperti ini.  Dalam proses pembuatan, tambahkan tugas: <br><br><img src="https://habrastorage.org/webt/uy/rx/xj/uyrxxj48kzjdv85qlcugbuhnhge.png"><br><br>  Kami mengonfigurasinya untuk menghasilkan file dengan migrasi: <br><br><img src="https://habrastorage.org/webt/hr/mu/om/hrmuom6-wjvv4xak07ewe2_bsxw.png"><br><br>  Jangan lupa untuk menambahkan skrip ke proyek PowerShell yang akan melakukan migrasi (dijelaskan di atas) dan file migrasi itu sendiri.  Akibatnya, setelah membangun proyek, artefak mungkin terlihat seperti ini (selain arsip aktual bersama majelis, ada skrip PS tambahan dan skrip SQL dengan migrasi): <br><br><img src="https://habrastorage.org/webt/hj/m9/j4/hjm9j4emze4vu_ceybuwjkyrafe.png"><br><br>  Tetap hanya dalam langkah Rilis yang tepat untuk mengkonfigurasi pelaksanaan skrip PowerShell ini dengan cara yang sama seperti yang dijelaskan di atas. <br><br><h2>  Tentang penulis </h2><br><img src="https://habrastorage.org/webt/ok/i5/ug/oki5uge-jvjl3pkerhoipjvjvyc.jpeg" align="left" width="120">  Pavel Kutakov adalah pakar teknologi cloud, pengembang dan arsitek sistem perangkat lunak di berbagai sektor bisnis - mulai dari IP perbankan yang beroperasi di seluruh dunia dari AS hingga Papua Nugini, hingga solusi cloud untuk operator lotere nasional. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id436670/">https://habr.com/ru/post/id436670/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id436658/index.html">Masa depan ritel: tren digital utama berdasarkan NRF Retail's Big Show 2019</a></li>
<li><a href="../id436660/index.html">Peta Jalan Kode VS 2019 - DRAFT</a></li>
<li><a href="../id436662/index.html">1 Februari 2019 situs Anda mungkin berhenti berfungsi</a></li>
<li><a href="../id436664/index.html">Memperkenalkan Seri Standup Komunitas .NET</a></li>
<li><a href="../id436668/index.html">Bisakah statistik dibaca dengan sejumlah kecil data?</a></li>
<li><a href="../id436674/index.html">Reverse Engineering Fantastic Dizzy</a></li>
<li><a href="../id436676/index.html">Bagaimana cara DDoS seluruh negara</a></li>
<li><a href="../id436682/index.html">Jangan membuat JL (DSL) Anda sendiri untuk memperluas fungsionalitas aplikasi</a></li>
<li><a href="../id436684/index.html">Hari Jadi Android 10 (Q). Apa yang diketahui sekarang?</a></li>
<li><a href="../id436686/index.html">JPEG dari dunia 3D. Apa itu glTF?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>