<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🥞 👩🏼‍🤝‍👨🏻 🌆 Karat untuk pengembang web - mulai cepat dan penerbangan cepat ✋🏽 👨🏽‍🍳 💮</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Halo semuanya! Hari ini saya ingin berbagi pengalaman saya dalam mempelajari bahasa dan implementasi cepat dari proyek jaringan beban tinggi menggunak...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Karat untuk pengembang web - mulai cepat dan penerbangan cepat</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/bitrix/blog/477342/">  Halo semuanya!  Hari ini saya ingin berbagi pengalaman saya dalam mempelajari bahasa dan implementasi cepat dari proyek jaringan beban tinggi menggunakan koneksi jaringan asinkron non-blocking yang sekarang sangat populer dan populer dalam bahasa Rust yang baru, indah, elegan, dan sangat efektif. <br>  Saya akan memberikan penekanan khusus pada posting pada penjelasan yang cepat dan jelas tentang kemampuan bahasa dan platform untuk spesialis yang memiliki pengalaman luas dalam pengembangan web, karena saya sendiri.  Ada kesalahpahaman bahwa kurva entri di Rust sangat, sangat curam.  Tetapi saya akan menunjukkan bahwa ini jauh dari kasus.  Tuang kopi dan pergi! <br><a name="habracut"></a><br><h3>  Sejarah Singkat Nilai-Nilai Pemrograman </h3><br>  Agar materi tersebut berada di kepala dan hati, menyenangkan untuk mengingat secara singkat apa yang ingin dilakukan orang dalam pemrograman selama 50 tahun terakhir dan apa yang akhirnya mereka dapatkan.  Jangan tersinggung, hanya pendapat subjektif pribadi dan holivar, didukung oleh 20 tahun pengalaman pembangunan. <br><br><h4>  Bahasa Tingkat Rendah: C, C ++ </h4><br>  Jelas bahwa Anda dapat menulis program segera dalam bentuk angka pada kode mesin dan banyak yang melakukannya pada ZX Spectrum, BK0010-01 dan pada PC - kode tersebut ternyata sangat cepat :-) Tetapi kita adalah orang-orang, banyak informasi yang tidak sesuai di kepala kita, kita terganggu dan karenanya bahkan penemuan assembler tidak banyak membantu - kode pada tingkat rendah seperti itu sangat jarang ditulis dan sangat akurat dan, kemungkinan besar, jika Anda tidak mengembangkan driver, mikrokontroler atau sistem embedded yang rumit, ini tidak akan berguna dalam kehidupan. <br><img src="https://habrastorage.org/webt/gs/zf/28/gszf28trxey6oz6aag_dgh4u_lu.jpeg"><br><br>  Pada awal 70-an, Bell Labs menemukan bahasa C, yang berakar berkat sintaksis singkat dan abstraksi yang sangat "murah", hampir menjadi "assembler portabel".  Jelaslah bahwa jika Anda mengambil amandel, menulis selama 10 tahun pada malam C, tidak makan daging, berdoa dan tidak terganggu oleh jejaring sosial dan seks yang adil, Anda dapat menulis program yang sangat berguna dan cepat, seperti <a href="https://www.gnu.org/">GNU dengan</a> fasih bersaksi, permainan produktif yang sangat baik, tercinta, tetapi bukan alternatif dalam kualitas Windows, dan masih banyak lagi contoh yang bisa diberikan. <br>  Tapi sisi lain dari koin terus membuat dirinya terasa - secara teratur membuka lubang keamanan (seluruh industri untuk "lubang dalam perangkat lunak" telah dibuat), yang disebabkan oleh lubang dalam konsep bahasa C itu sendiri - kompiler seperti banteng yang tidak bertanggung jawab, dengan kekuatan luar biasa, orgasme yang intens dan memori pendek.  Kelalaian apa pun - dan Anda tidak bisa begitu saja menghentikan program (mendereferensi pointer nol, membebaskan pointer ganda, keluar dari array), tetapi merusak data secara tidak dapat dibatalkan dan tidak menyadarinya untuk waktu yang lama sampai klien mulai menelepon dan ketika sudah terlambat ("perilaku tidak terdefinisi", berbeda dari kompiler ke kompiler). <br><br>  Björn Straustrup hanya semakin membingungkan situasi di awal tahun delapan puluhan, menambahkan kemampuan OOP ke C. Meskipun popularitasnya sangat besar, C ++, secara umum, dipandang sebagai serangkaian percobaan pemrograman, dengan demikian, dengan hasil keberhasilan yang berbeda, termasuk  mematikan  Kadang-kadang bahkan tampaknya tidak ada arti dalam C ++ sejak awal, atau secara bertahap hilang, memunculkan tumpukan konsep-konsep yang rumit dan saling bertentangan secara obyektif, yang semakin lama semakin meningkat dengan setiap standar baru.  Terlepas dari tujuan sempurna “abstraksi tanpa biaya”, memungkinkan Anda untuk mendapatkan kode cepat, untuk membuat solusi yang andal, seperti dalam C, syarat-syarat berikut diperlukan: <br><ul><li>  berpengalaman, dari kata "sangat", tim (tahun latihan, "biarawan" pemrograman) </li><li>  penganalisa kode statis yang baik </li><li>  departemen pengujian (dalam kode mungkin ada lubang yang ditinggalkan oleh kompiler yang tidak bertanggung jawab, yang dapat membuat mereka merasa untuk waktu yang lama) </li><li>  persyaratan yang disetujui oleh semua anggota tim yang dipantau dengan cermat (pointer mentah, enkapsulasi ketat, disiplin paling parah untuk variabel penamaan, menginisialisasi objek, dll tidak digunakan) </li></ul><br><br>  Jelas bahwa kepatuhan terhadap persyaratan ini, terutama dalam konteks meningkatnya kebutuhan bisnis akan "kode yang bekerja tanpa kejutan mendadak," sangat mahal.  Kode dalam proyek tersebut ditulis untuk waktu yang lama, perlu diuji untuk waktu yang lama dan hati-hati, tetapi, kadang-kadang, tanpa C / C ++, sebelum penemuan Rust, itu benar-benar sulit dilakukan. <br><br>  Sekali lagi, ringkasan C / C ++ - kami memiliki kompiler yang kuat, tetapi "tidak bertanggung jawab" dengan "abstraksi saat ini," yang membantu pengembang sangat sedikit.  Akibatnya, semua masalah diteruskan ke pundak programmer.  Jika setidaknya satu programmer dalam tim tidak berpengalaman, tidak terlalu berhati-hati dan tidak tahu semua seluk-beluk dari kompiler (pada kenyataannya, tidak ada yang tahu semua seluk-beluk dan pengguna menemukan mereka nanti) - tunggu masalah.  Tetapi kemudian program ini bekerja dengan cepat dan mungkin dengan benar :-) Ini, tentu saja, menelurkan seluruh pasar "kruk" - analisa statis, yang, pada gilirannya, harus dibayar oleh Pelanggan.  Muncul pertanyaan - mungkinkah menulis kompiler yang lebih ketat dan aman yang membantu pengembang dan melahirkan program tanpa kejutan dan lubang keamanan tingkat rendah? <br><br><h4>  Java, C #, Kotlin </h4><br>  Situasi dengan kontrol yang terus terang lemah dari "perilaku tidak terbatas" dan persyaratan yang sangat tinggi untuk pengembang di C / C ++ menimbulkan keinginan untuk menciptakan lingkungan pengembangan yang aman, termasuk  untuk Internet, dapat diakses oleh sebagian besar pendatang.  Jadi di akhir tahun 90-an Jawa muncul. <br>  Pada prinsipnya, sekarang siapa pun dengan tingkat pelatihan yang berbeda dapat menulis apa saja dan apa saja dan ITU BEKERJA dan tidak dimasukkan ke dalam program - tidak ada "lubang" tingkat rendah dalam keamanan dan crash spontan (hampir, tetapi mereka sudah disebabkan oleh bug dalam mesin virtual dan diperbaiki secara terpusat).  Hanya ada "lubang" logis atau kode lambat tersembunyi (lahir dari ketidaktahuan algoritma, konsep biaya algoritmik dan melambat ketika volume data meningkat), yang tidak begitu menakutkan lagi dan memungkinkan Anda membuat program dengan cepat, dan jika perlu, menulis ulang potongan kecil dengan tim C / C yang berkualifikasi C ++. <br>  Hal-hal menarik dan berharga yang dibawa dunia Jawa adalah sebagai berikut: <br><ul><li>  kode ini ditulis sekali untuk mesin virtual yang berfungsi pada arsitektur apa pun (windows, linux, mac) </li><li>  pengembang tidak lagi mengelola memori secara langsung, seperti dalam C / C ++ - ini diteruskan ke pundak "pengumpul sampah";  ini menghilangkan risiko perilaku yang tidak terdefinisi, korupsi data yang tersembunyi, dan potensi celah keamanan tingkat rendah </li><li>  kode dikompilasi dengan cepat, saat program sedang berjalan (Just_In_Time kompilasi), karena  diketahui bahwa hanya sebagian kecil yang aktif dan sering dijalankan dalam program, sehingga tidak masuk akal untuk mengkompilasi semuanya </li><li>  menjadi lebih mudah untuk menulis kode multi-thread efisien, seperti  model memori ditentukan secara ketat (jauh lebih awal dari pada C ++), tetapi lebih lanjut tentang itu, tidak semua masalah dengan "keandalan logis beberapa utas" diselesaikan (kebuntuan, misalnya, atau perlombaan data, masih dimungkinkan) </li></ul><br><br>  Tentu saja, munculnya platform yang bersahabat memungkinkan untuk menulis banyak program yang berguna dan tidak berguna, yang langsung dimanfaatkan oleh bisnis.  Dan dukungan untuk kompatibilitas mundur di Jawa selama 15 tahun atau lebih telah membuat teknologi begitu populer di dunia perusahaan. <br><br>  Ya, saya juga memiliki analogi dengan bir dan alkohol yang tidak beralkohol. <br><br>  Namun, jauh dari langsung, masalah berikut keluar di Jawa: <br><ul><li>  karena "lubang" logis dalam sistem pengetikan, yang diwarisi dari C / C ++, tipe "Null" masuk ke Jawa, yang hingga hari ini menyebabkan banyak masalah dan terus-menerus menyebabkan crash pada programmer "tidak terlalu berpengalaman" yang tidak tahu tentang tipe <a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html">opsional</a> dan tidak tertarik pada monad dari pemrograman fungsional </li><li>  Proyek Java, kadang-kadang bekerja sedikit lebih lambat, membutuhkan pesanan dengan magnitudo lebih banyak RAM daripada C / C ++ yang dibutuhkan oleh pengumpul sampah (kami memiliki beberapa proyek yang menghabiskan puluhan atau ratusan gigabyte RAM);  ini sering bukan masalah langsung, seperti  Harga RAM turun, tetapi "sedimen tetap" </li><li>  Meskipun kompilasi jit dan investasi besar dalam mempercepat pengumpul sampah (yang banyak dan baru muncul secara teratur dan terus-menerus mengatakan: "coba GC baru, itu jauh lebih baik"), selama 20 tahun beberapa proyek Jawa yang kaya telah bekerja dengan jeda reguler selama beberapa detik, yang tidak bisa dihilangkan dengan cara apa pun (ada pengumpulan sampah paksa, dan seperti sekrup di GC tidak berputar, pengumpul sampah tidak punya waktu untuk membersihkan semuanya, bahkan bekerja secara paralel dan bahkan menghabiskan lebih banyak sumber daya daripada program itu sendiri) </li><li>  diketahui bahwa aplikasi Java GUI terkadang membeku dan melambat, menyebabkan kemarahan pengguna, karena pengumpulan sampah yang sama dan tidak ada harapan dan tidak diharapkan </li><li>  sintaks bahasanya sangat verbose dan redundan (Anda perlu menulis dan kemudian membaca kata-kata "public static functon" alih-alih, katakanlah, "pub fn" atau "def"), memaksa kadang-kadang untuk mematahkan jari pada kuku dan menyebabkan rasa sakit objektif dan perdarahan dari mata. </li><li>  penurunan tajam dalam persyaratan untuk tingkat kualifikasi pengembang dan kurva entri yang cukup rendah memunculkan banyak kode "tingkat kesegaran yang aneh", yang terus-menerus membuat dirinya terasa sepanjang hidup saya dengan bau busuk yang mengesankan </li></ul><br><br>  Setelah membaca, harus jelas bahwa semuanya tidak dapat ditulis dalam Java, itu akan ditulis cukup lambat, maka secara teratur akan melambat dan menggantung selama satu detik di bawah beban, kadang-kadang "makan" banyak RAM (biasanya setidaknya setengah dari RAM di server dimakan), permainan produktif Anda tidak akan dapat melakukannya juga, tetapi beberapa bagian dari logika bisnis yang tidak terlalu menuntut kinerja dan RAM, terutama yang multi-threaded, sangat mungkin, berguna, dan oleh karena itu kami melihat popularitas teknologi di dunia usaha.  Dan kami sendiri secara teratur dan aktif menggunakan Java untuk layanan perusahaan. <br><br><h4>  C #, Scala, Kotlin </h4><br>  "Dan kapan itu tentang Rust?" - tunggu sebentar, kamu perlu sedikit persiapan untuk memakan kesemek manis ini.  Jika Anda tidak berbicara tentang fitur-fitur teknologi lainnya, Anda tidak akan mengerti mengapa Rust muncul dan mengapa itu begitu <a href="https://www.rust-lang.org/production">populer dan diminati</a> . <br><br>  Jadi, mencoba membuat Java lebih baik dan lebih progresif, Microsoft, sebagai penulis TurboPascal / Delphi, pada awal nol muncul dengan C # dan konsep .NET.  Secara obyektif, menurut banyak pakar terkemuka, dan di ruang merokok pengembang, "C #" lebih seksi dari Jawa, meskipun, tentu saja, sejauh ini, meskipun Mono, ia sangat melekat pada Microsoft dengan semua arus masuk dan konsekuensi :-) <br><br>  Scala tidak diragukan lagi merupakan langkah maju yang besar  bahasa, tentu saja, ternyata musykil dan canggih secara ilmiah, mengambil banyak hal yang berguna dan tidak berguna dari dunia pemrograman fungsional.  Tetapi ada sesuatu yang tidak begitu jelas dengan popularitas.  Namun, <a href="https://ru.wikipedia.org/wiki/Apache_Spark">Apache Spark</a> sangat bagus dan populer, tidak ada yang perlu dikatakan. <br><br>  Kotlin populer karena  membuat Java lebih efisien dan lebih mudah bagi pemula, terutama pada platform seluler yang tidak punya waktu untuk serius mempelajari pemrograman :-) <br><br>  Tetapi masalah utama dalam C # (pada platform .NET), serta dalam Scala, Kotlin dan dalam bahasa JVM lainnya - tetap ada.  Pengumpul sampah, Carl, membuat beban yang terlihat di server dan menghentikan eksekusi kode selama beberapa detik di bawah beban dan persyaratan RAM yang rakus!  Dan berapa banyak lagi bahasa dengan pengumpul sampah dan kompilasi jit tidak akan muncul, masalah ini akan tetap ada dan belum ada harapan, bahkan dalam teori. <br><br><h4>  Scripting </h4><br>  "Tapi bagaimana dengan PHP?"  Ya, sekarang mari kita bicara tentang scripting.  Tampaknya, mengapa dia?  Sekitar akhir 80-an, menjadi jelas bahwa jika Anda perlu dengan cepat menyelesaikan masalah menggunakan kode, tidak harus super cepat, dan aman, tanpa perilaku yang tidak ditentukan dan lubang tingkat rendah, Anda dapat menulis skrip.  Skrip ditulis sebelumnya, dalam bash, perl, awk, tetapi ternyata dengan python Anda dapat menulis skrip besar, terutama skrip ilmiah, dan selama bertahun-tahun! <br><br>  Lua menemukan ceruknya dalam gamedev dan pembelajaran mesin ( <a href="http://torch.ch/">Torch</a> ), JavaScript - dalam pengembangan web baik di sisi browser maupun di sisi <a href="https://ru.wikipedia.org/wiki/Node.js">server</a> (mereka masih tahu bahwa <a href="https://www.rust-lang.org/static/pdfs/Rust-npm-Whitepaper.pdf">otorisasi dalam infrastruktur "npm"</a> Node.js ditulis ulang dari Node.js dan Golang berkarat?).  Python - dalam pembelajaran mesin dan analisis data, serta dalam skrip sistem.  Dan PHP - sangat cocok dengan tugas-tugas server untuk pengembangan web. <br><img src="https://habrastorage.org/webt/sj/eg/0e/sjeg0ebs9dgz9eb42wsglwralv8.jpeg"><br><br>  Keuntungan dari scripting sudah jelas: <br><ul><li>  Kode yang aman dan efisien tanpa perilaku yang tidak ditentukan dan lubang keamanan tingkat rendah, menggunakan algoritma populer dan struktur data (daftar, kamus, antrian), dibuat dalam hitungan menit secara harfiah </li><li>  Awal yang sangat cepat dan kurva entri yang lembut.  Butuh beberapa hari untuk mencari tahu dan menulis skrip python yang berguna, mengubah logika nginx melalui skrip di Lua, atau melakukan integrasi toko online di PHP </li><li>  Jika Anda menulis skrip dengan disiplin, mengamati CodeStyle dan seketat mungkin, Anda dapat dengan cepat menyelesaikan masalah kompleks dan membuat produk perangkat lunak besar: sejumlah besar pustaka ilmiah di python, sistem manajemen bisnis dan situs dalam PHP, platform jaringan saraf Torch di LuaJit, skrip permainan dengan sangat game terkenal dan populer, dll. </li><li>  Beberapa jenis pemrograman multi-threaded, di mana I / O adalah bottleneck, cukup efisien diselesaikan dengan python.  Dan menggunakan fitur python terbaru dengan futures seperti "async / menunggu" itu bahkan lebih mudah untuk memecahkan masalah pemrosesan sejumlah besar soket jaringan </li><li>  Sangat elegan, tugas memproses secara sinkron sejumlah besar soket, bahkan tanpa multithreading, diselesaikan di Node.js di luar kotak </li><li>  Buat halaman web, gunakan banyak pustaka unix, pergi ke database masih mudah dan nyaman menggunakan PHP dan produk-produk berdasarkan itu </li><li>  Pada python, PHP, JavaScript, sangat mudah untuk menguji hipotesis dan membuat prototipe dalam hitungan jam, bukan bulan </li><li>  Untuk analitik dan pemrosesan data, biasanya sangat nyaman menggunakan python / R bersamaan dengan sejumlah besar pustaka berkualitas tinggi (panda, scikit-learn, seaborn, matplotlib ...) </li></ul><br><br>  Namun, Anda tidak dapat mengetahui potensi kerugian dari skrip: <br><ul><li>  Level entri yang rendah dan kecepatan penulisan yang sangat cepat kadang-kadang, dengan tidak adanya kontrol yang tepat atas pengembang, menciptakan banyak kode yang tidak efisien dan sulit dipertahankan pada platform apa pun </li><li>  Tidak adanya kompiler, sistem tipe dan pengetikan statis memerlukan pemeriksaan dinamis parameter yang diteruskan ke fungsi dan metode untuk tipe dan cakupan kode berkualitas tinggi dengan autotest.  Kalau tidak, setiap perubahan dalam kode dapat merusak program dan klien, dan bukan pengembang, akan menjadi yang pertama tahu tentang hal itu (ya, saya tahu tentang TypeScript, tetapi ini adalah kruk dan tapal mati) </li><li>  Secara obyektif dan jelas, dalam bahasa tanpa pengetikan dan kompilasi statis, di mana banyak hal terjadi dalam runtime, Anda tidak dapat menggunakan banyak optimasi, dan karenanya, dalam beberapa tugas, skrip perintah kerja dengan magnitudo lebih lambat dan menghabiskan sumber daya berkali-kali lebih banyak.  Meskipun ada upaya untuk mengimplementasikan kompilasi jit dalam python (pypy), PHP (hhvm), JavaScript (terjemahan ke dalam kode mesin, wow, Node.js v8), LuaJIT - jangan menipu diri sendiri: semua ini terlihat seperti kruk yang lemah efektif.  Alasannya adalah, dan perlu dipahami sekali dan untuk semua, bahwa karena pengetikan bahasa yang disengaja lemah, skrip tidak mungkin pernah berhasil menulis runtime yang efektif, mendekati dalam kecepatan untuk mengetik Java / C # yang jauh lebih kuat. </li><li>  Dan dengan python, sepertinya tidak akan pernah ada multithreading yang efisien, seperti pada Java / C #, karena GIL </li></ul><br><br>  Namun sejak itu  di sebagian besar aplikasi bisnis, termasuk  sistem manajemen situs, CRM, dll.  Karena sebagian besar waktu eksekusi kode dihabiskan untuk query ke database, keuntungan dari jit Java / C # sangat diratakan oleh kecepatan penulisan solusi dalam PHP / python / JavaScript, dan secara pribadi, saya akan memilih 10-20 baris dalam PHP untuk membuat aplikasi web dari 10.000 string dan banyak jeroan ayam itik di Jawa / Spring.  Dan PHP7 entah bagaimana overclock sehingga berjalan lebih cepat daripada python3 ;-) <br><br>  Kesimpulan apa yang bisa dibuat di sini?  Tidak perlu menyelesaikan semua masalah, seperti yang sekarang populer, hanya dengan scripting - dalam beberapa kasus masuk akal untuk mengambil alat lain yang lebih cocok, jika ada alasan bagus untuk ini: <br><ul><li>  beban jaringan sangat tinggi dan multithreading "ekstrem", ribuan - puluhan ribu soket jaringan, dll. </li><li>  pembatasan penggunaan RAM dan perangkat keras </li><li>  pemrosesan dan komputasi data intensif, matriks dengan jutaan entitas, GPU (meskipun python / numpy / panda dapat membantu di sini) </li></ul><br><br>  Seringkali di perusahaan kami mempraktikkan pendekatan ini: <br><ul><li>  cepat membuat keputusan dalam PHP / python / JavaScript / Node.js, luncurkan pertempuran dan mulailah memecahkan masalah pelanggan </li><li>  kami menjalankan fitur, peluang, meningkatkan layanan </li><li>  dalam kasus yang jarang terjadi, dari pengalaman, biasanya tidak lebih awal dari setelah beberapa tahun, beberapa layanan yang sudah stabil dalam fungsionalitas ditulis ulang dalam C / C ++ / Java / Golang / Rust </li></ul><br>  Oleh karena itu, lebih baik untuk memulai, sebagai aturan, dengan scripting, memulai pertempuran, dan kemudian, jika Anda membutuhkannya secara langsung, Anda perlu mengambil alat lain dan ini berjalan, biasanya sangat lancar dan tanpa risiko. <br><br><h4>  Pemrograman Fungsional, Lisp, Haskell, F # </h4><br>  Banyak, sepanjang karier seorang pengembang, tidak pernah datang ke sini, tetapi sia-sia.  Sangat berguna untuk memahami mengapa FP (pemrograman fungsional) muncul dan mengapa di beberapa daerah sangat populer. <br><br>  Saya akan menjelaskannya secara sederhana.  Ada masalah yang tidak terpecahkan dalam matematika sebagai <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D1%2580%25D0%25BE%25D0%25B1%25D0%25BB%25D0%25B5%25D0%25BC%25D0%25B0_%25D0%25BE%25D1%2581%25D1%2582%25D0%25B0%25D0%25BD%25D0%25BE%25D0%25B2%25D0%25BA%25D0%25B8">"masalah terputus-putus"</a> .  Jika Anda memasukkannya ke dalam kata-kata yang sangat sederhana dan sangat tidak ketat, tetapi jelas, maka Anda tidak dapat menemukan algoritma yang membuktikan bahwa program akan bekerja tanpa bug.  Mengapa  Karena pada awalnya, orang-orang mulai pemrograman secara agresif dan imperatif, menggunakan: <br><ul><li>  variabel yang bisa berubah </li><li>  siklus dengan kondisi </li><li>  efek samping </li></ul><br>  Dan mereka mulai membuat kesalahan.  Kami melihat ini sekarang, mengamati sejumlah besar bug baik di web, dan di aplikasi desktop dan seluler.  Dan tidak peduli bagaimana Anda menutupi kode dengan autotests, bug masih terus bocor, tersebar di lantai dan cekikikan. <br>  Untuk menghentikan mimpi buruk ini dari permulaan perangkat lunak kereta dan tanpa ampun, pada akhir 50-an, arah pemrograman fungsional dan <a href="https://ru.wikipedia.org/wiki/%25D0%259B%25D0%25B8%25D1%2581%25D0%25BF">bahasa Lisp muncul</a> .  Sekarang keluarga bahasa ini mewakili, kurang lebih memadai, <a href="https://ru.wikipedia.org/wiki/Haskell">Haskell</a> . <br><br>  Terlepas dari kenyataan bahwa sejumlah besar kemungkinan kesalahan dalam kode benar-benar dihilangkan karena: <br><ul><li>  <a href="https://ru.wikipedia.org/wiki/%25D0%2590%25D0%25BB%25D0%25B3%25D0%25B5%25D0%25B1%25D1%2580%25D0%25B0%25D0%25B8%25D1%2587%25D0%25B5%25D1%2581%25D0%25BA%25D0%25B8%25D0%25B9_%25D1%2582%25D0%25B8%25D0%25BF_%25D0%25B4%25D0%25B0%25D0%25BD%25D0%25BD%25D1%258B%25D1%2585">tipe data aljabar</a> dan pencocokan pola pada mereka </li><li>  tidak adanya siklus (hanya melalui rekursi) dan variabel yang bisa berubah dalam jangkauan lengan yang terulur (kruk cara menyiasatinya, tentu saja, <a href="https://wiki.haskell.org/Mutable_variable">dapat ditemukan</a> ) </li><li>  pengetikan statis yang sangat ketat dan, pada saat yang sama, keluaran otomatis tipe <a href="https://ru.wikipedia.org/wiki/%25D0%2592%25D1%258B%25D0%25B2%25D0%25BE%25D0%25B4_%25D1%2582%25D0%25B8%25D0%25BF%25D0%25BE%25D0%25B2">Hindley-Milner yang</a> sangat nyaman </li><li>  fitur yang sangat kuat, dengan pembagian menjadi "murni" dan "dengan efek samping", dengan kemungkinan <a href="https://wiki.haskell.org/Currying">penggunaan parsial</a> </li><li>  mengamankan dukungan pemrograman bersamaan </li><li>  dukungan untuk combinator melalui monads untuk semua kesempatan (lebih lanjut tentang itu di bagian Karat) </li></ul><br><br> Haskell       «» —     ,  ,  ,             : <a href="https://en.wikipedia.org/wiki/Category_theory"> </a> .    Haskell    «»,      ,    ,    ,        .          Haskell    . <br><br> , ,      —  Haskell ,  ,  ,              Java/C#. <br><br>    ,     . Haskell  ,   , ,     ,      .  ,          «»   —  Haskell    . <br><br><h4>  «C/C++» — Golang, D </h4><br>  ,    ,      C/C++ (,         Forth). <a href="https://losst.ru/pochemu-linus-torvalds-ne-lyubit-c"> </a>    C++  ,       ,         <a href="https://wiki.dlang.org/Language_History_and_Future">   D</a> (   —    ,     ). <br><br> ,       -    /C++    c  <a href="https://ru.wikipedia.org/wiki/%25D0%259F%25D0%25BE%25D0%25BB%25D1%2583%25D1%2587%25D0%25B5%25D0%25BD%25D0%25B8%25D0%25B5_%25D1%2580%25D0%25B5%25D1%2581%25D1%2583%25D1%2580%25D1%2581%25D0%25B0_%25D0%25B5%25D1%2581%25D1%2582%25D1%258C_%25D0%25B8%25D0%25BD%25D0%25B8%25D1%2586%25D0%25B8%25D0%25B0%25D0%25BB%25D0%25B8%25D0%25B7%25D0%25B0%25D1%2586%25D0%25B8%25D1%258F">RAII</a>     ,      .     2009   Google   <a href="https://en.wikipedia.org/wiki/Go_(programming_language)">Golang</a> . <br>     ,  Golang         , , ,       . Golang         Java/C# (     )  ,  <a href="https://stackoverflow.com/questions/7823725/what-kind-of-garbage-collection-does-go-use"> </a> …  ,   Golang: <br><ul><li>    «green threads» ( ),       python </li><li>    ,  ,  (,  Docker ) :-) </li></ul><br>       .   Node.js  python  . <br><br> , Golang        , Google vs Sun/Oracle,   ,   ,  ,    :-) ,   «  Java/C#»         ,       —    .  Docker  Golang         .      Golang —            Java/C#,     ,   . <br><img src="https://habrastorage.org/webt/m7/1e/sc/m71escomzu8jtn2z-xrre4vyq5g.jpeg"><br><br>     , , <a href="https://oxozle.com/2017/05/10/sravnenie-arc-i-garbage-collector/">Swift</a> , c « »     .       macOS. <br><br><h3>   — Rust! </h3><br>    ,      ,   40-50      , ,         ,   «zero-cost» , , -  -  :-)     , ,    (Java/C#),   ,    (C/C++),   -,         —  .         ,     ? <br><br>  — .  , , ,     50      ,    2010   Mozilla Research.   ,    : <br><ul><li>  «zero-cost»  ( C/C++    ), ..       ,   ,   ------ <a href="https://doc.rust-lang.org/stable/book/ch13-00-functional-features.html"></a>  «  » (,   ,       ) </li><li>     <a href="https://doc.rust-lang.org/stable/cargo/">cargo</a> ,        </li><li>       (* —     ):    ,     —        «   »,    , , ,    </li><li>   ,   ,                 (  ,      ,         GC , -  runtime,     ) </li><li>         -,   Null (!),                 </li><li>     Haskell  pattern-matching  ,                Enumeration (Golang, ,       ) </li><li>           (   Java,   ) </li><li>        ( Golang   —  ;  Java/C#/Erlang  ..    ,    ) </li><li> <a href="https://doc.rust-lang.org/stable/book/ch19-06-macros.html"></a>    ,      (   C/C++) </li></ul><br><br> ,   ,    -.    ?  !      ,       50 . , , «»    ,                ,  . <br><br> Rust    «» , ,        Haskell   . <br>  Rust    , , , Java :-) —  Nulls,     pattern-matching  ,    generics  traits     .      .    ,    ,         , «  Haskell»,     . <br><br>      . <br><br><h4>       ? </h4><br>   !       , «» («ownership»)       .     «  » ( «lifetime»,   Rust book,    ),  <a href="https://doc.rust-lang.org/stable/book/ch04-01-what-is-ownership.html">  </a> (   ,    ). <br>     /,            .     /,             . <br>            C++,   -  move-.    ,       rust   ,      . <br><br><h4>   zero-cost ? </h4><br>       ,      traits,    .   , ,   Golang.        , , -     pattern-matching,      (    Golang,  ).  /         .        :         .      <a href="https://doc.rust-lang.org/stable/book/ch04-02-references-and-borrowing.html"></a> («borrowing»).      ,      (  «read-write locks»,  ).  , ,        ,        ,    . <br>           <a href="https://doc.rust-lang.org/stable/book/ch04-03-slices.html">slice</a> ,  , , .    —   « » , ,            ;   ,           . <br><br><h4>     </h4><br>       : <br><ul><li>  ,  <a href="https://doc.rust-lang.org/stable/book/ch03-01-variables-and-mutability.html">   </a> </li><li>     (   ,      <a href="https://doc.rust-lang.org/stable/book/ch19-01-unsafe-rust.html">  </a> ) </li><li>      ,   ---,    <a href="https://doc.rust-lang.org/stable/book/ch13-04-performance.html">  </a> </li><li>   ,       ,    ,          </li></ul><br><br>   ,           ( ,  )     <a href="https://en.wikipedia.org/wiki/Substructural_type_system"> </a>      … .                 / ,    C/C++      .       . <br><br><h4>   </h4><br>               ,      - ,     -    .  -  ,    .       Sync/Send,    ,       :  ,   , ,   . <br><br>         ,         ,       1-2         futures  <a href="https://tokio.rs/">  </a> .   ,   Node.js  python  async/await,      ,          .    ,    ? <br><br><h4>  unit    </h4><br> ,         unit           . <a href="https://doc.rust-lang.org/stable/book/ch11-00-testing.html">    </a>   . <br><br><h4>    — cargo </h4><br>    Java, «Maven   <a href="https://doc.rust-lang.org/stable/cargo/">cargo</a> »     ,     :  ,    . , ,   ,   . <br><br><h4> Heap   </h4><br>  ,        ,           heap. ,    ,       ( )  «  » ( «lifetime»).    ,     <a href="https://doc.rust-lang.org/stable/book/ch15-00-smart-pointers.html"> </a> ( Swift).     ,     —  ,    heap              .    —         ,      . <br><br><h4>      </h4><br>    ,     , ,         . ,    (2   )      , , ,      ,   <a href="https://tokio.rs/">   </a> , <a href="https://rust-lang-nursery.github.io/rust-cookbook/cli/arguments.html"></a>       <a href="https://lib.rs/crates/rusoto_sqs">AmazonWebServices</a>    c tls/ssl,            . <br> ,  , ,  ,      , -   .        <a href="https://doc.rust-lang.org/stable/book/ch10-03-lifetime-syntax.html">«  » ( «lifetimes»)</a>   . <br> ,            .    IntelliJ <a href="https://intellij-rust.github.io/">   rust</a> ,        .      Notepad++ —          . <br><br><h4>     Rust </h4><br><ul><li> Memahami bahwa Anda benar-benar perlu menulis kode sistem yang sangat cepat, bekerja di bawah beban tinggi dan mengkonsumsi sumber daya minimum dan tanpa overhead seperti pengumpul sampah.  Jika tidak, tulis skrip dengan python / PHP / Node.js dan kembali ke tugas setelah 2-3 tahun (dalam 97% kasus Anda tidak harus kembali). </li><li>  Jangan takut pada Rust.  Sorotan utama dari bahasa ini adalah kompiler yang sangat cerdas dan matematis yang TIDAK akan meleset dari kode berbahaya dan salah.  Dengan coba-coba, menghindari sudut yang tajam, Anda akan belajar cara memprogram menggunakan kompiler secara ketat dan aman :-) </li><li>  Mulai belajar bahasa dengan " <a href="https://doc.rust-lang.org/stable/book/title-page.html">Karat buku</a> ".  Buku yang indah dan seksi yang mudah dibaca dan menyenangkan untuk dibaca.  Tetapi lebih baik membacanya 2 kali, "menyelesaikan" semua contoh. </li><li>  " <a href="https://rust-lang-nursery.github.io/rust-cookbook/">Buku masak karat</a> " sangat membantu.  Juga diinginkan untuk “menyelesaikannya” dan melihat bagaimana kodenya bekerja, untuk merasakannya. </li><li>  Ada literatur tentang Rust untuk pengguna tingkat lanjut, seperti <a href="https://doc.rust-lang.org/stable/nomicon/">Rustonimicon</a> , tetapi saya tidak menyarankan Anda <a href="https://doc.rust-lang.org/stable/nomicon/">repot</a> - <a href="https://doc.rust-lang.org/stable/nomicon/">repot</a> dengan hal-hal teknis yang benar-benar rumit. </li></ul><br><img src="https://habrastorage.org/webt/o7/tb/h4/o7tbh4gcbhpj467i9pkm7muais4.jpeg"><br><br>  Pahami sekali lagi - untuk menguasai teknologi, Anda harus mulai menulis kode yang bermanfaat bagi perusahaan.  Kompiler Rust sangat cerdas sehingga memberikan jaminan (pada kenyataannya, sangat penting, kompiler C ++ tidak tahu bagaimana melakukannya) dan tidak mengkompilasi kode berbahaya / rusak memori, jadi bereksperimen sebanyak yang Anda inginkan dan Anda akan mendapatkan kode dengan cepat dan aman dan bahkan lebih baik Anda akan mulai pemrograman: - ) <br><br><h4>  Detail Implementasi Proyek </h4><br>  Saya akan mengungkapkan sedikit detail dari proyek ini.  Amazon SQS menumpahkan ratusan paket data per detik.  Antrian dibaca, diurai secara lokal oleh pekerja, setiap pesan diproses oleh broker dan dialihkan ke server eksternal lain.  Ada beberapa server eksternal.  Awalnya, solusi diimplementasikan melalui skrip: skrip, mengambil proses dalam sistem operasi, membaca pesan, diproses dan dikirim melalui jaringan.  Pada beberapa server besi yang kuat (8 core, 16 GB RAM), ratusan skrip diluncurkan (masing-masing!), Secara simultan membaca dari SQS, memproses dan mengirim data.  Sederhana, andal, tetapi asupan zat besi mulai mengganggu.  Biaya besi terus meningkat. <br><br>  Karat sebagian besar menggunakan perpustakaan standar dan modul dari kargo: <br><ul><li>  rusoto_sqs - untuk bekerja dengan Layanan Web Amazon, tanpa pertanyaan, berfungsi sesuai kebutuhan di luar kotak </li><li>  rustls - untuk tl, termasuk.  interaksi dengan layanan TLS dari Google, Apple dan penggunaan sertifikat klien </li><li>  signal-hook - untuk mencegat kill dan membawa ke akhir transaksi untuk mengirim data </li><li>  futures, tokio-rustls - “lazy”, multithreaded, asynchronous bekerja dengan soket TLS jaringan, ala Node.js </li><li>  argumen baris perintah clap - parsing </li><li>  serde_json - formasi json, tidak ada yang menarik di sini </li></ul><br><br>  Sayangnya, itu bukan tanpa menggunakan blok "tidak aman" dan "std :: mem :: transmute" - pustaka standar tidak dapat menemukan alat untuk mem-parsing data biner ke dalam pohon. <br><br>  Yang utama, jika Anda bisa menyebutnya begitu, "memasukkan" terjadi dalam kompilasi - perpustakaan tidak dikompilasi pada CentOS6 karena "assembler usang" dalam binutils, tetapi tidak ada masalah pada CentOS7. <br><br>  Kesan umum adalah bahwa pengembangan pada Rust lebih menyerupai, "scripting ketat" daripada pemrograman sistem, tidak lebih lama dari scripting atau pengembangan web, baik dalam hal sumber daya dan pengujian.  Dalam hal ini, kompilasi statis yang ketat, tidak adanya pengumpul sampah dan tipe data aljabar. <br><br>  Perasaan keseluruhan sangat positif.  Namun, bukannya beberapa server besi (8 core, 16 GB RAM), masalahnya mulai diselesaikan dengan satu proses (dengan puluhan utas) yang memakan tidak lebih dari 5 GB RAM dan menciptakan beban yang tidak terlalu mencolok pada core, dengan lalu lintas di wilayah 0,5-1 gigabit . <br><br><h3>  Kesimpulan </h3><br>  Yah, itu berakhir lama, tapi, semoga, menginspirasi dan berguna tentang teknologi yang efektif.  Sekarang Anda tahu alat lain dan Anda bisa lebih aman menggunakannya jika perlu.  Kami meninjau sejarah perkembangan bahasa pemrograman, kemampuan dan fiturnya, dan mungkin telah membuat atau akan menarik kesimpulan yang tepat.  Semoga berhasil dengan proyek Anda dan suasana hati yang baik, tidak, bagus! <br><br>  PS: <br>  * - Ya, saya hampir lupa.  Tentu saja, Anda perlu berbicara tentang blok yang tidak aman.  Di blok ini Anda dapat: <ul><li>  untuk memprogram hal-hal yang tidak tersedia dalam karat biasa - dereference pointer "mentah" dan melakukan beberapa hal yang lebih berbahaya, kadang-kadang diperlukan dalam pemrograman sistem.  Tapi semuanya tidak begitu menakutkan: </li><li>  blok yang tidak aman terlihat dan tidak ada sama sekali, atau kode yang bertanggung jawab terkonsentrasi di dalamnya </li><li>  Perpustakaan standar karat diuji secara menyeluruh, yang berarti kami percaya bahwa blok yang tidak aman berfungsi di dalamnya </li><li>  perpustakaan populer dalam kargo juga diuji secara menyeluruh (semuanya dibangun untuk unit dan pengujian integrasi dalam karat) dan oleh karena itu mereka dapat dengan aman diambil dan digunakan </li></ul><br>  Yaitu  di blok "tidak aman" Anda tidak dapat terlibat dalam pesta pora yang sewenang-wenang, tersedia di C - tetapi hanya dengan jenis aktivitas berbahaya <a href="https://doc.rust-lang.org/stable/book/ch19-01-unsafe-rust.html">tertentu</a> .  Karena itu, Anda dapat dan harus tidur nyenyak :-) </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id477342/">https://habr.com/ru/post/id477342/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id477326/index.html">Kesederhanaan Cupang</a></li>
<li><a href="../id477328/index.html">Alasan untuk memperkenalkan analisa kode statis PVS-Studio ke dalam proses pengembangan</a></li>
<li><a href="../id477332/index.html">Hackney Pipeline: Hackathon untuk data markup dari Ozon, Yandex.Tolki dan Netology</a></li>
<li><a href="../id477336/index.html">Komputasi tanpa server berdasarkan OpenWhisk, bagian 1</a></li>
<li><a href="../id477338/index.html">OWASP Moscow (Russia) meetup 12/19 CFP</a></li>
<li><a href="../id477344/index.html">JIRA: aturan untuk persiapan tepat waktu perangkat lunak lezat. TLDR 1: Batas Peluang</a></li>
<li><a href="../id477348/index.html">Habr Weekly # 28 / Berbicara di depan umum tidak menakutkan, Starship meledak, Tesla menunjukkan CYBRTRCK, Peregrine Falcon diretas</a></li>
<li><a href="../id477350/index.html">Aplikasi pertama (Longsor - kerangka kerja aplikasi untuk Java)</a></li>
<li><a href="../id477352/index.html">Lisensi untuk situs dan layanan Internet di Tiongkok</a></li>
<li><a href="../id477354/index.html">Pertanyaan untuk wawancara - dari kandidat ke majikan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>