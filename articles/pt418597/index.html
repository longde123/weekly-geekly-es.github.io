<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>😴 🙈 🕛 Funções para documentar bancos de dados PostgreSQL. Parte três 👨🏼‍🤝‍👨🏻 📺 👡</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Esta é a terceira parte do artigo que descreve funções definidas pelo usuário para trabalhar com diretórios do sistema: pg_class, pg_attribute, pg_con...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Funções para documentar bancos de dados PostgreSQL. Parte três</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418597/">  Esta é a terceira parte do artigo que descreve funções definidas pelo usuário para trabalhar com diretórios do sistema: pg_class, pg_attribute, pg_constraints etc. <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/zc/rx/ta/zcrxta08dnfat5cqpgid4lyq7by.png"></div><br>  Esta seção do artigo discute funções que retornam as <b>características de sequências, tabelas herdadas</b> e as <b>características especiais de atributos de tabela</b> . <br><a name="habracut"></a><br><p>  <b>Veja também</b> <br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Funções para documentar bancos de dados PostgreSQL.</a></b>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte um</a> ;</b> <br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Funções para documentar bancos de dados PostgreSQL.</a></b>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte dois</a> ;</b> <br>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Funções para documentar bancos de dados PostgreSQL.</a></b>  <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O fim (parte quatro)</a> .</b> <br><br>  A primeira metade do artigo fornece comentários sobre a implementação de funções.  O segundo é o código fonte das funções.  Para os leitores que estão interessados ​​apenas nos textos originais, sugerimos seguir imediatamente para o <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Apêndice</a> . <br><br></p><h3>  Estrutura de uma função que retorna uma lista de características de seqüências de tabela </h3><br><img src="https://habrastorage.org/webt/i6/dw/f_/i6dwf_jd0ofjr-vqmeide0l1vws.png"><br>  <i>Fig.</i>  <i>2. Funções das quais as funções admtf_Table_Sequences dependem</i> <br><br>  <strong>Tabela 11. Objetivo das funções.</strong> <br><br><table width="95" border="1"><tbody><tr><th width="5">  Não. </th><th width="10">  Título </th><th width="40">  Nomeação </th></tr><tr><td width="5">  1 </td><td width="10">  admtf_Sequence_Features </td><td width="40">  A função retorna uma lista de características da sequência da tabela. </td></tr><tr><td width="5">  2 </td><td width="10">  admtf_Table_Sequences </td><td width="40">  A função retorna uma lista de sequências de tabelas do banco de dados e suas características. </td></tr></tbody></table><br><h3>  Função <b>Admtf_Sequence_Features</b> - lista de características de sequência do banco de dados </h3><br><a name="tfSeqF_def"></a><p>  A função admtf_Sequence_Features retorna uma lista de características SEQUENCE do banco de dados.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O código-fonte pode ser visualizado e baixado aqui</a> . </p><br><p>  A função <b>admtf_Sequence_Features</b> retorna uma lista de características de sequência do banco de dados ( <b>SEQUENCE</b> ) </p>  . <br><p>  Como parâmetros, a função assume o nome da sequência ( <b>a_SequenceName</b> ) e o nome do esquema no qual a sequência é criada ( <b>a_SchemaName</b> ). </p><br><p>  A necessidade da função <b>admtf_Sequence_Features</b> surgiu porque as principais características da sequência são realmente armazenadas em uma tabela cujo nome corresponde ao nome da sequência e os dados são extraídos usando a <b>instrução SELECT</b> .  Nesse caso, o nome da sequência, o nome do esquema e o comentário à sequência são armazenados nos <b>diretórios</b> <b>pg_class</b> , <b>pg_namespace</b> e <b>pg_description</b> . </p><br><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> kr_road_network_vertices_pgr_id_seq;</code> </pre> <br><p>  <b><i>Observação 6</i></b> </p><br><p>  <b>O PostgreSQL</b> 10 separou as características da sequência e as características de seus estados.  Para isso, foi introduzido o diretório <b>pg_sequence</b> com características de sequência, contendo o valor inicial ( <b>start_value</b> ), incremento ( <b>increment_by</b> ) e o valor máximo ( <b>max_value</b> ) da sequência.  O último valor retornado pela sequência ( <b>last_value</b> ) foi deixado na "tabela" com o nome da sequência. </p><p></p><p>  <strong>O fim da observação.</strong> </p><br><p>  A apresentação de cada sequência como um análogo da tabela, creio, é ditada pela necessidade de armazenar o último valor usado da sequência ( <b>last_value</b> ), que é uma característica do estado da sequência, mas não a própria sequência. </p><br><p>  A entrada de sequência no diretório <b>pg_class</b> difere da entrada da tabela pelo valor do tipo de relação (relkind = <font color="red">'S'</font> ). </p><br><p>  Para extrair as características de uma sequência arbitrária, você deve usar o SQL dinâmico. </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> <span class="hljs-string"><span class="hljs-string">'SELECT last_value,start_value,increment_by,max_value FROM '</span></span>|| <span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_SchemaName)||<span class="hljs-string"><span class="hljs-string">'.'</span></span>||<span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_SequenceName) <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> v_SequenceLastValue,v_SequenceStartValue, v_SequenceIncrementBy,v_SequenceMaxValue ;</code> </pre><br><br>  <strong>Tabela 12. O resultado da execução da função admtf_Sequence_Features ('public', 'kr_road_network_vertices_pgr_id_seq').</strong> <br><br><table width="25"><tbody><tr><th width="5">  Título </th><th width="5">  Comentário </th><th width="10">  Atual </th><th width="5">  Iniciar </th><th width="5">  Incrementar </th><th width="10">  O fim </th></tr><tr><td width="15">  kr_road_network <br>  _vertices_pgr_id <br>  _seq </td><td width="20">  Sequência </td><td width="10">  138023 </td><td width="5">  1 </td><td width="5">  1 </td><td width="10">  9223372036854775807 </td></tr></tbody></table><br><h3>  Função admtf_Table_Sequences lista de sequências de tabelas do banco de dados e suas características </h3><br><a name="tfTableS_def"></a><p>  A função <b>admtf_Table_Sequences</b> retorna uma lista de sequências ( <b>SEQUENCE</b> ) da tabela do banco de dados, gerando os valores de seus campos e as características dessas sequências.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O código-fonte pode ser visualizado e baixado aqui</a> , e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">aqui está uma versão de uma função que não usa um cursor</a> . </p><br><p>  Como parâmetros, a função assume o nome da tabela de origem ( <b>a_TableName</b> ) e o nome do esquema no qual a tabela é criada ( </p><p>  a_SchemaName </p>  ) <br><img src="https://habrastorage.org/webt/io/cc/ib/ioccibem_rgf_rjzsnmd5va1xt0.png"><br><div class="spoiler">  <b class="spoiler_title">o código fonte do operador na figura</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> pseq.relname <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> SequenceName,snsp.nspname <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> SequenceSchemaName, <span class="hljs-keyword"><span class="hljs-keyword">COALESCE</span></span>(dsc.description,<span class="hljs-string"><span class="hljs-string">',    '</span></span> ||da.attname) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> SequenceDescription, d.depType <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> DependcyType,da.attname <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> AttributeName <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_depend d <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_class pseq <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> d.objid = pseq.oid <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_namespace snsp <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> pseq.relnamespace=snsp.oid <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OUTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_Description dsc <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> pseq.oid=dsc.objoid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> dsc.objsubid=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_class tbl <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> d.refobjid = tbl.oid <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_namespace nsp <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tbl.relnamespace=nsp.oid <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_attribute da <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> da.attrelid= d.refobjid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> da.attnum= d.refobjsubid <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(nsp.nspname)=<span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_SchemaName) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(tbl.relname)=<span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_TableOID) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> tbl.relkind = <span class="hljs-string"><span class="hljs-string">'r'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pseq.relkind = <span class="hljs-string"><span class="hljs-string">'S'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> pseq.relname;</code> </pre><br></div></div><br><p>  Uma descrição de uma única sequência é uma combinação de um registro em <b>pg_class</b> descrevendo-o como uma relação física e uma tabela condicional com o nome da sequência contendo dados sobre as características específicas da sequência </p><br><p>  As informações sobre o relacionamento entre a sequência e a tabela de origem são armazenadas no diretório do sistema <b>pg_depend</b> . </p><br><br>  <strong>Tabela 13. Atributos do diretório <b>pg_depend</b> necessários para implementar a função.</strong> <br><table width="25"><tbody><tr><th width="5">  Título </th><th width="5">  Descrição do produto </th></tr><tr><td width="10">  objid </td><td width="20">  OID da sequência no diretório pg_class </td></tr><tr><td width="10">  objsubid </td><td width="20">  Este campo contém zero </td></tr><tr><td width="10">  refobjid </td><td width="20">  OID da tabela nos campos em que a sequência é usada </td></tr><tr><td width="10">  refobjsubid </td><td width="20">  Número do atributo da tabela cujos valores são preenchidos usando uma sequência </td></tr></tbody></table><br><p>  Além disso, a função acessa os dados do catálogo <b>pg_namespace</b> e <b>pg_description</b> para extrair os diagramas e comentários da sequência e da tabela de origem. </p><br><p>  Para determinar o atributo de uma tabela cujos valores são preenchidos usando uma sequência, a função acessa o diretório <b>pg_attribute</b> na condição: <b>attrelid = refobjid AND attnum = refobjsubid</b> .  (Nessa condição, os nomes dos atributos do diretório <b>pg_depend</b> são indicados à direita do sinal de igual). </p><br><p>  As características especiais das seqüências de tabela são recuperadas em um loop chamando <b>admtf_Sequence_Features</b> .  O ciclo é usado porque mais de uma sequência pode ser atribuída para preencher os campos da tabela. </p><br>  <strong>Tabela 14. O resultado da execução da função admtf_Table_Sequences ('public', 'kr_road_network_vertices_pgr').</strong> <br><br><table width="25"><tbody><tr><th width="5">  Título </th><th width="5">  Comentário </th><th width="5">  Iniciar </th><th width="5">  Incrementar </th><th width="10">  O fim </th><th width="10">  O campo </th></tr><tr><td width="15">  kr_road_network <br>  _vertices_pgr_id <br>  _seq </td><td width="20">  Sequência que gera valores de campo de ID </td><td width="5">  1 </td><td width="5">  1 </td><td width="10">  9223372036854775807 </td><td width="10">  id </td></tr></tbody></table><br><a name="tfTableS_woc_def"></a><h4>  Versão sem cursor </h4><br><p>  Em um ambiente <b>PostgreSQL</b> cuja versão é menor que 10, é provavelmente impossível implementar a função <b>admtf_Table_Sequences</b> sem usar um cursor. <br>  Mas os sortudos proprietários da versão 10 podem passar sem um cursor, porque  eles têm o diretório <b>pg_sequence</b> à sua disposição.  Nesse caso, todas as características da sequência podem ser recuperadas com uma única <b>instrução SELECT</b> . </p><br><p>  Na implementação de função especificada, usando a função de janela <b>RANK () OVER (PARTITION BY pseq.relname)</b> , é calculado o número de sequência da sequência usada para preencher a tabela de origem. </p><br><img src="https://habrastorage.org/webt/1z/qa/r7/1zqar7uba-68o2ya1l_o37ph5jc.png"><br><div class="spoiler">  <b class="spoiler_title">o código fonte do operador na figura</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RANK</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">OVER</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">PARTITION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> pseq.relname) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> SequenceNo, pseq.relname <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> SequenceName,snsp.nspname <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> SequenceSchemaName, <span class="hljs-keyword"><span class="hljs-keyword">COALESCE</span></span>(dsc.description,<span class="hljs-string"><span class="hljs-string">',    '</span></span> ||da.attname) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> SequenceDescription, seq.seqstart <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> SequenceStartValue,seq.seqincrement <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> SequenceIncrementBy, seq.seqmax <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> SequenceMaxValue, d.depType <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> DependcyType,da.attname <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> AttributeName <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_depend d <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_class pseq <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> d.objid = pseq.oid <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_sequence seq <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> seq.seqrelid= pseq.oid <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_namespace snsp <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> pseq.relnamespace=snsp.oid <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OUTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_Description dsc <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> pseq.oid=dsc.objoid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> dsc.objsubid=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_class tbl <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> d.refobjid = tbl.oid <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_namespace nsp <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tbl.relnamespace=nsp.oid <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_attribute da <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> da.attrelid= d.refobjid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> da.attnum= d.refobjsubid <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(nsp.nspname)=<span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_SchemaName) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(tbl.relname)=<span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_TableOID) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> tbl.relkind = <span class="hljs-string"><span class="hljs-string">'r'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> pseq.relkind = <span class="hljs-string"><span class="hljs-string">'S'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> pseq.relname;</code> </pre><br></div></div><br><p>  <strong>Observação 7</strong> </p>  . <br><p>  Esta versão da função não retorna o último valor gerado pela sequência ( <b>last_value</b> ). </p><p></p><p>  <strong>O fim da observação.</strong> </p><br><h3>  Função Admtf_Table_InheritanceChildrens - lista de características de tabelas herdadas </h3><br><a name="tfTableIC_def"></a><p>  A função <b>admtf_Table_InheritanceChildrens</b> retorna uma lista de características das tabelas herdadas ( <b>INHERITS</b> ) da tabela do banco de dados.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O código-fonte pode ser visualizado e baixado aqui</a> . </p><br><p>  Como parâmetros, a função assume o nome da tabela de origem ( <b>a_TableName</b> ) e o nome do esquema no qual a tabela é criada ( <b>a_SchemaName</b> ). </p><br><p>  A descrição de uma única tabela herdada está na entrada em <b>pg_class</b> .  Mas, para procurar tabelas herdadas pelo nome da tabela de origem, é necessário usar o catálogo do sistema <b>pg_depend</b> . </p><br>  <strong>Tabela 15. Atributos do diretório <b>pg_depend</b> necessários para implementar a função.</strong> <br><table width="25"><tbody><tr><th width="5">  Título </th><th width="5">  Descrição do produto </th></tr><tr><td width="10">  objid </td><td width="20">  OID da tabela herdada no diretório pg_class </td></tr><tr><td width="10">  refobjid </td><td width="20">  OID da tabela de origem </td></tr></tbody></table><br><img src="https://habrastorage.org/webt/pa/ew/kl/paewklf4g7qvftdb99sss0efwqc.png"><br><div class="spoiler">  <b class="spoiler_title">o código fonte do operador na figura</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> rtbl.relname,rnspc.nspname,rdsc.description,rtbl.relnatts::<span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span>, rtbl.relchecks::<span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span>, rtbl.relhaspkey,rtbl.relhasindex,rtbl.relhassubclass, rtbl.reltuples::<span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class tbl <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_namespace nspc <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tbl.relnamespace = nspc.oid <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OUTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_Description dsc <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tbl.oid=dsc.objoid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> dsc.objsubid=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_depend dp <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tbl.oid=dp.refobjid <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_class rtbl <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> rtbl.OID=dp.objid <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_namespace rnspc <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> rtbl.relnamespace = rnspc.oid <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OUTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_Description rdsc <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> rtbl.oid=rdsc.objoid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> rdsc.objsubid=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(nspc.nspname)=<span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_SchemaName) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(tbl.relname)=<span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_TableOID) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> tbl.relkind = <span class="hljs-string"><span class="hljs-string">'r'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> rtbl.relkind = <span class="hljs-string"><span class="hljs-string">'r'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> rtbl.relname;</code> </pre><br></div></div><br><p>  Além disso, a função acessa os dados do diretório <b>pg_namespace</b> e <b>pg_description</b> para extrair esquemas e comentários para as tabelas herdada e de origem. </p><br>  <strong>Tabela 16. O resultado da execução da função admtf_Table_InheritanceChildrens ('public', 'np_house').</strong> <br><br><table width="95" border="1"><tbody><tr><th width="10">  Título </th><th width="20">  Comentário </th><th width="5">  Atributos </th><th width="5">  ?  chave primária </th><th width="5">  ?  índices </th><th width="5">  ?  descendentes </th><th width="5">  Número de registros </th></tr><tr><td width="10">  np_house 04201 000000 </td><td width="20">  Casas em assentamentos (distrito de Achinsky) </td><td width="5">  15 </td><td width="5">  f </td><td width="5">  f </td><td width="5">  f </td><td width="5">  5651 </td></tr><tr><td width="10">  np_house 4208 000 000 </td><td width="20">  Casas em assentamentos (distrito de Bogotolsky) </td><td width="5">  15 </td><td width="5">  f </td><td width="5">  f </td><td width="5">  f </td><td width="5">  4314 </td></tr></tbody></table><br><p>  O número de registros na tabela gerada é selecionado no atributo reltuple do diretório pg_class.  E embora esse valor geralmente corresponda exatamente ao número real de entradas na tabela, ainda é um valor estimado.  Portanto, convém obter o valor exato como resultado.  Por exemplo, como mostrado na figura. </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">EXECUTE</span></span> <span class="hljs-string"><span class="hljs-string">'SELECT COUNT(*) FROM '</span></span>||<span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_SchemaName)||<span class="hljs-string"><span class="hljs-string">'.'</span></span>||<span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_TableName) <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> v_TableNumberOfRowCalc;</code> </pre><br><p>  Mas, primeiro, para cumprir esta declaração no texto, a função <b>admtf_Table_InheritanceChildrens</b> precisará usar um cursor. </p><br><p>  Em segundo lugar, eu gostaria que a função exibisse o número estimado e o número exato de entradas da tabela. </p><br><p>  Portanto, a função possui outro parâmetro opcional - o modo de obter o número de entradas da tabela ( <b>a_Mode</b> ), que <b>utiliza</b> os valores "estimativa" ( <font color="red">estimativa</font> ) ou "exatamente" ( <font color="red">exatamente</font> ). </p><br><a name="fnTableRC_def"></a><br><p>  Além disso, a função <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">admfn_Table_RowCount</a> foi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">criada</a> , que retorna o número exato de entradas da tabela e o atributo reltuple é substituído na lista de retorno <b>SELECT</b> com a seguinte construção. </p><br><img src="https://habrastorage.org/webt/3f/t_/xf/3ft_xftbnboqxguantdpivkdtva.png"><br><div class="spoiler">  <b class="spoiler_title">o código fonte do operador na figura</b> <div class="spoiler_text"><pre> <code class="sql hljs">CASE WHEN a_Mode = 'exactly' THEN admfn_Table_RowCount(rnspc.nspname,rtbl.relname) ELSE reltuples <span class="hljs-keyword"><span class="hljs-keyword">END</span></span></code> </pre><br></div></div><br><p>  Como resultado, a função retornará o valor estimado do indicador "número de entradas da tabela" se o parâmetro <b>a_Mode</b> não <b>especificar o</b> requisito para retornar o valor exato. </p><br><h3>  Estrutura de uma função que retorna uma lista de características de atributos da tabela </h3><br><img src="https://habrastorage.org/webt/hi/du/at/hiduatp-_vtmifufs_u53_roz2q.png"><br>  <i>Fig.</i>  <i>3. Funções que admtf_Attribute_Features Chamadas</i> <br><img src="https://habrastorage.org/webt/ip/3e/rx/ip3erx3a2sj9_kkoeriysoppfom.png"><br><div class="spoiler">  <b class="spoiler_title">versão em texto da tabela na figura</b> <div class="spoiler_text">  <strong>Tabela 17. Objetivo das funções.</strong> <br><br><table width="95" border="1"><tbody><tr><th width="5">  Não. </th><th width="10">  Título </th><th width="40">  Nomeação </th></tr><tr><td width="5">  1 </td><td width="10">  admtf_Attribute_PKFeatures </td><td width="40">  A função retorna o atributo de presença do atributo na chave primária (PRIMARY KEY), bem como algumas de suas características como parte dessa chave. </td></tr><tr><td width="5">  2 </td><td width="10">  admtf_Attribute_FKFeatures </td><td width="40">  A função retorna o atributo de presença do atributo na chave estrangeira (FOREIGN KEY), bem como algumas de suas características como parte dessa chave. </td></tr><tr><td width="5">  3 </td><td width="10">  admtf_Attribute_Features </td><td width="40">  A função retorna uma lista de características de atributos da tabela. </td></tr></tbody></table><br></div></div><br><h3>  Função <b>admtf_Attribute_PKFeatures</b> - - se o atributo está presente na chave primária </h3><br><a name="tfAttPK_def"></a><br><p>  A função <b>admtf_Attribute_PKFeatures</b> retorna um sinal da presença de um atributo de tabela na chave primária (PRIMARY KEY) da tabela e, se estiver presente, qual é o número de série nessa chave, pois  chave primária pode ser composta. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O código-fonte pode ser visualizado e baixado aqui</a> . </p><br><p>  Como parâmetros, a função pega o OID da tabela de origem ( <b>a_TableOID</b> ) e o número de série do atributo desejado ( <b>a_AttributeNo</b> ). </p><br><p>  A função extrai os dados <b>necessários</b> da <b>entrada do</b> diretório <b>pg_constraint que</b> contém as restrições (CONSTRAINT) da tabela de origem, incluindo a restrição de chave primária.  O OID da tabela desejada é armazenado no campo <b>conrelid</b> , a descrição da chave primária é armazenada em um registro no qual o campo contype contém o valor <font color="red">'' p '</font> </p>  . <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INTO</span></span> v_PKAttributeList,rs_isAttributePK conkey,<span class="hljs-built_in"><span class="hljs-built_in">ARRAY</span></span>[a_AttributeNo]&lt;@conkey <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_constraint c <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c.contype=<span class="hljs-string"><span class="hljs-string">'p'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> c.conrelid=a_TableOID;</code> </pre><br><p>  O campo <b>conkey</b> , encontrado dessa maneira, contém uma matriz de números de atributos que compõem a chave primária.  Portanto, para verificar a presença do atributo de origem na chave primária, basta calcular a expressão lógica <b>ARRAY [a_AttributeNo] &lt;@ conkey</b> . </p><br><p>  Se o atributo estiver presente na chave primária, seu número de sequência será calculado no loop. </p><br><h3>  Função <b>admtf_Attribute_FKFeatures</b> - se o atributo está presente na chave estrangeira </h3><br><a name="tfAttFK_def"></a><br><p>  A função <b>admtf_Attribute_FKFeatures</b> retorna um sinal da presença de um atributo da tabela em uma ou mais chaves estrangeiras (FOREIGN KEY) da tabela e, se estiver presente, quais são os números de sequência nessas chaves, porque  chave estrangeira pode ser composta. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O código-fonte pode ser visualizado e baixado aqui</a> . </p><br><p>  Como parâmetros, a função pega o OID da tabela de origem ( <b>a_TableOID</b> ) e o número de série do atributo desejado ( <b>a_AttributeNo</b> ). </p><br><p>  A função recupera os dados <b>necessários</b> da <b>entrada do</b> diretório <b>pg_constraint que</b> contém o CONSTRAINT da tabela de origem, incluindo, entre outros, restrições de chave estrangeira.  O OID da tabela desejada é armazenado no campo <b>conrelid</b> , a descrição da chave primária é armazenada em um registro no qual o campo contype contém o valor <font color="red">'' f '</font> </p>  . <br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_constraint c <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> c.contype=<span class="hljs-string"><span class="hljs-string">'f '</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> c.conrelid=a_TableOID <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> <span class="hljs-built_in"><span class="hljs-built_in">ARRAY</span></span>[a_AttributeNo]&lt;@conkey <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> c.oid;</code> </pre><br><p>  O campo <b>conkey</b> , encontrado dessa maneira, contém uma matriz de números de atributos que compõem a chave estrangeira.  Portanto, para verificar a presença do atributo de origem na chave estrangeira, basta calcular a expressão lógica <b>ARRAY [a_AttributeNo] &lt;@ conkey</b> . </p><br><p>  Se o atributo estiver presente na chave estrangeira, no loop uma matriz de seus números de sequência é formada nas chaves estrangeiras que o contêm.  Além disso, mais duas matrizes são formadas a partir dos nomes das tabelas e seus atributos, que são referenciados pelo atributo source nas chaves estrangeiras que a contêm. </p><br><p>  Os nomes de tabela são recuperados da <b>entrada do</b> diretório <b>pg_class</b> pelo identificador (OID) recuperado do campo confrelid da entrada da chave estrangeira. </p><br><p>  Para obter o nome do atributo da tabela externa, use uma matriz de números de série do campo </p><p>  confkey </p>  (difere da matriz acima pela letra " <b>f</b> " no nome).  O número de série do atributo da tabela externa à qual o atributo externo corresponde é extraído dessa matriz.  Por esse número de série do atributo da tabela externa e seu OID, localizado no diretório pg_attribute, há uma entrada para a descrição do atributo e seu nome é recuperado. <br><h3>  Função <b>Admtf_Attribute_Features</b> - lista de características de atributos da tabela </h3><br><a name="tfAttF_def"></a><p>  As funções <b>admtf_Attribute_Features</b> retornam uma lista das seguintes características de atributo da tabela.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">O código-fonte pode ser visualizado e baixado aqui</a> . </p><br><img src="https://habrastorage.org/webt/tu/bz/me/tubzmeucr-nzriafiuufgbv31ew.png"><br><div class="spoiler">  <b class="spoiler_title">A versão em texto da tabela na figura</b> <div class="spoiler_text"><table width="95" border="1"><tbody><tr><th width="5">  Não. </th><th width="10">  Título </th><th width="10">  Tipo </th><th width="40">  Nomeação </th></tr><tr><td width="5">  1 </td><td width="10">  AttributeName </td><td width="10">  nome </td><td width="40">  O nome do atributo de origem. </td></tr><tr><td width="5">  2 </td><td width="10">  UserTypeName </td><td width="10">  VARCHAR (256) </td><td width="40">  Tipo de atributo de origem personalizado </td></tr><tr><td width="5">  3 </td><td width="10">  Typename </td><td width="10">  VARCHAR (256) </td><td width="40">  Tipo base do atributo de origem </td></tr><tr><td width="5">  4 </td><td width="10">  isNotNULL </td><td width="10">  BOOLEAN </td><td width="40">  ?  Validade nula </td></tr><tr><td width="5">  5 </td><td width="10">  isAttributePK </td><td width="10">  BOOLEAN </td><td width="40">  ?  participação em PK </td></tr><tr><td width="5">  6 </td><td width="10">  ColumnPKNo </td><td width="10">  SMALLINT </td><td width="40">  Número de série do atributo em PK </td></tr><tr><td width="5">  7 </td><td width="10">  Descrição do produto </td><td width="10">  TEXTO </td><td width="40">  Comentar no atributo de origem </td></tr><tr><td width="5">  8 </td><td width="10">  isAttributeFK </td><td width="10">  BOOLEAN </td><td width="40">  ?  participação no FK </td></tr><tr><td width="5">  9 </td><td width="10">  FKeyName </td><td width="10">  nome [] </td><td width="40">  Uma matriz de nomes de tabela de restrição na qual a chave estrangeira é definida </td></tr><tr><td width="5">  10 </td><td width="10">  ColumnFKNo </td><td width="10">  SMALLINT [] </td><td width="40">  Matriz de números de sequência de atributos em chaves estrangeiras de uma tabela </td></tr><tr><td width="5">  11 </td><td width="10">  FKTableName </td><td width="10">  nome [] </td><td width="40">  Matriz de tabelas referenciadas por chaves estrangeiras </td></tr><tr><td width="5">  12 </td><td width="10">  FKTableColumnName </td><td width="10">  nome [] </td><td width="40">  Matriz de nomes de atributos em tabelas externas correspondentes ao atributo de origem </td></tr></tbody></table><br></div></div><br><p>  Como parâmetros, a função pega o OID da tabela de origem ( <b>a_TableOID</b> ) e o número de série do atributo desejado ( <b>a_AttributeNo</b> ). <br>  Os valores dos <b>campos</b> <b>AttributeName</b> e <b>isNotNULL</b> são recuperados da <b>entrada do</b> diretório <b>pg_attribute</b> correspondente aos valores dos parâmetros de entrada. </p><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> attr.attname, attr.attnotnull <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_attribute <span class="hljs-keyword"><span class="hljs-keyword">attr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> attr.attrelid =a_TableOID <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> attr.attnum=a_AttributeNo; <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> rs_isAttributePK,rs_ColumnPKNo <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> admtf_Attribute_PKFeatures (a_TableOID,a_AttributeNo); <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> rs_isAttributeFK,rs_FKeyName,rs_ColumnFKNo, rs_FKTableName,rs_FKTableColumnName <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> admtf_Attribute_FKFeatures (a_TableOID,a_AttributeNo);</code> </pre><br><p>  Os valores dos <b>campos isAttributePK</b> e <b>ColumnPKNo são</b> retornados pela função <b>admtf_Attribute_PKFeatures</b> . </p><br><p>  Os valores dos <b>campos isAttributeFK</b> , <b>FKeyName</b> , <b>ColumnFKNo</b> , <b>FKTableName</b> , <b>FKTableColumnName são</b> retornados pela função <b>admtf_Attribute_FKFeatures</b> . </p><br><p>  Uma chamada para <b>admtf_Attribute_Features ((SELECT OID FROM pg_class WHERE relname = 'street'), 2 :: SMALLINT)</b> produzirá o seguinte resultado. </p><br>  <strong>Tabela 18. Resultado da execução da função admtf_Attribute_Features</strong> <br><table width="95" border="1"><tbody><tr><th width="10">  AttributeName </th><th width="10">  UserTypeName </th><th width="10">  Typename </th><th width="10">  isNotNULL </th><th width="10">  isAttributePK </th><th width="10">  ColumnPKNo </th></tr><tr><td width="10">  localityid </td><td width="10">  localityid </td><td width="10">  inteiro </td><td>  inteiro </td><td>  inteiro </td><td width="2">  inteiro </td></tr></tbody></table><br><br><table width="95" border="1"><tbody><tr><th width="10">  Descrição do produto </th><th width="10">  isAttributeFK </th><th width="10">  FKeyName </th><th width="10">  ColumnFKNo </th><th width="10">  FKTableName </th><th width="10">  FKTableColumnName </th></tr><tr><td width="10">  ID da comunidade </td><td width="10">  t </td><td width="10">  {fk_street_locality} </td><td>  {2} </td><td>  {localidade} </td><td width="2">  {localityid} </td></tr></tbody></table><br><a name="Script2"></a><h2>  APÊNDICE 1. Scripts </h2><br><a name="tfSeqF"></a><h3>  Criando a função admtf_Sequence_Features </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Comentários sobre o código fonte da função podem ser encontrados aqui.</a> <br><div class="spoiler">  <b class="spoiler_title">código de função</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> admtf_Sequence_Features (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,a_SequenceName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>); <span class="hljs-comment"><span class="hljs-comment">/****************************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/*     ,   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/****************************************************************************/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> admtf_Sequence_Features (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-string"><span class="hljs-string">'public'</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> a_SequenceName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> (rs_SequenceName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,rs_SequenceDescription <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>,rs_NumberOfAttribute <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span>,rs_SequenceLastValue <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span>, rs_SequenceStartValue <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span>,rs_SequenceIncrementBy <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span>,rs_SequenceMaxValue <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c_SequenceKind <span class="hljs-keyword"><span class="hljs-keyword">CONSTANT</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CHAR</span></span>:=<span class="hljs-string"><span class="hljs-string">'S'</span></span>; v_SequenceOID OID; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_SequenceName NAME; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_SequenceDescription TEXT; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_SequenceStartValue BIGINT; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> v_SequenceIncrementBy BIGINT; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_SequenceMaxValue BIGINT; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> v_SequenceLastValue BIGINT; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> v_SequenceNumberOfRowCalc INTEGER; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-comment"><span class="hljs-comment">--************************************************************************ BEGIN SELECT INTO rs_SequenceName,rs_SequenceDescription,rs_NumberOfAttribute tbl.relname, COALESCE(dsc.description,'') AS r_SequenceDescription, tbl.relnatts::INTEGER,tbl.relchecks::INTEGER,tbl.relhaspkey, tbl.relhasindex,tbl.relhassubclass,tbl.reltuples::INTEGER FROM pg_class tbl INNER JOIN pg_namespace nspc ON tbl.relnamespace = nspc.oid LEFT OUTER JOIN pg_Description dsc ON tbl.oid=dsc.objoid AND dsc.objsubid=0 WHERE nspc.nspname=LOWER(a_SchemaName) AND tbl.relkind=c_SequenceKind AND tbl.relname =LOWER(a_SequenceName); IF FOUND THEN EXECUTE 'SELECT last_value,start_value,increment_by,max_value FROM '||LOWER(a_SchemaName)||'.'||LOWER(a_SequenceName) INTO v_SequenceLastValue,v_SequenceStartValue, v_SequenceIncrementBy,v_SequenceMaxValue ; RETURN QUERY SELECT rs_SequenceName,rs_SequenceDescription, rs_NumberOfAttribute,v_SequenceLastValue, v_SequenceStartValue,v_SequenceIncrementBy, v_SequenceMaxValue; END IF; RETURN; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Sequence_Features(a_SchemaName NAME,a_SequenceName NAME) IS '    ,  '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; BEGIN TRANSACTION; DROP FUNCTION IF EXISTS admtf_Sequence_Features (a_SchemaName VARCHAR(256),a_SequenceName VARCHAR(256)); /****************************************************************************/ /*     ,   */ /****************************************************************************/ CREATE OR REPLACE FUNCTION admtf_Sequence_Features (a_SchemaName VARCHAR(256) default 'public', /*     */ a_SequenceName VARCHAR(256) default NULL /*   */ ) RETURNS TABLE (rs_SequenceName VARCHAR(256),rs_SequenceDescription TEXT, rs_NumberOfAttribute INTEGER,rs_SequenceLastValue BIGINT, rs_SequenceStartValue BIGINT,rs_SequenceIncrementBy BIGINT, rs_SequenceMaxValue BIGINT) AS $BODY$ DECLARE c_SequenceKind CONSTANT CHAR:='S'; --******************************************************** BEGIN RETURN QUERY SELECT sf.rs_SequenceName::VARCHAR(256), sf.rs_SequenceDescription::TEXT, sf.rs_NumberOfAttribute::INTEGER, sf.rs_SequenceLastValue::BIGINT, sf.rs_SequenceStartValue::BIGINT, sf.rs_SequenceIncrementBy::BIGINT, sf.rs_SequenceMaxValue::BIGINT FROM admtf_Sequence_Features(a_SchemaName::NAME,a_SequenceName::NAME) sf; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Sequence_Features(a_SchemaName VARCHAR(256),a_SequenceName VARCHAR(256)) IS '    ,  '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; SELECT * FROM admtf_Sequence_Features('public'::VARCHAR(255),'k_dorogi_dijkstra_seq_seq'::VARCHAR(255)); SELECT * FROM admtf_Sequence_Features('public'::NAME,'kr_road_network_vertices_pgr_id_seq'::NAME);</span></span></code> </pre><br></div></div><br><a name="tfTableS"></a><br><h3>  Criando a função admtf_Table_Sequences </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Comentários sobre o código fonte da função podem ser encontrados aqui.</a> <br><div class="spoiler">  <b class="spoiler_title">código de função</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> admtf_Table_Sequences (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>, a_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*********************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    ,     */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*********************************************************************/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> admtf_Table_Sequences (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-string"><span class="hljs-string">'public'</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> a_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> (r_SequenceNumber <span class="hljs-built_in"><span class="hljs-built_in">SMALLINT</span></span>,r_SequenceName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>, r_SequenceSchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_SequenceDescription <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, r_SequenceStartValue <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span>,r_SequenceIncrementBy <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span>, r_SequenceMaxValue <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span>,r_DependType <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>, r_RefTableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_RefTableSchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>, r_RefAttributeName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> v_TableOID <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span>;<span class="hljs-comment"><span class="hljs-comment">/* OID */</span></span> v_Sequence RECORD;<span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_SequenceOID INTEGER;<span class="hljs-comment"><span class="hljs-comment">/* OID */</span></span> v_SequenceName NAME; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_SequenceSchemaName NAME; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> v_SequenceDescription TEXT; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_SequenceStartValue BIGINT; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> v_SequenceIncrementBy BIGINT; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_SequenceMaxValue BIGINT; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> v_DependcyType NAME; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> v_AttributeName NAME; <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> v_SequenceNumber SMALLINT; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> c_Delimiter CONSTANT VARCHAR(2):=','; <span class="hljs-comment"><span class="hljs-comment">--********************************************************************* BEGIN v_SequenceNumber:=0; FOR v_Sequence IN SELECT pseq.relname AS SequenceName, snsp.nspname AS SequenceSchemaName, COALESCE(dsc.description,',    '||da.attname) AS SequenceDescription, d.depType AS DependcyType,da.attname AS AttributeName FROM pg_depend d INNER JOIN pg_class pseq ON d.objid = pseq.oid INNER JOIN pg_namespace snsp ON pseq.relnamespace=snsp.oid LEFT OUTER JOIN pg_Description dsc ON pseq.oid=dsc.objoid AND dsc.objsubid=0 INNER JOIN pg_class tbl ON d.refobjid = tbl.oid INNER JOIN pg_namespace nsp ON tbl.relnamespace=nsp.oid INNER JOIN pg_attribute da ON da.attrelid= d.refobjid AND d.refobjsubid=da.attnum WHERE tbl.relkind = 'r' AND pseq.relkind = 'S' AND LOWER(nsp.nspname)=LOWER(a_SchemaName) AND LOWER(tbl.relname)=LOWER(a_TableName) ORDER BY pseq.relname LOOP v_SequenceNumber:=v_SequenceNumber+1; v_SequenceName:=v_Sequence.SequenceName; v_SequenceSchemaName:=v_Sequence.SequenceSchemaName; v_DependcyType:=v_Sequence.DependcyType; v_AttributeName:=v_Sequence.AttributeName; v_SequenceDescription:=v_Sequence.SequenceDescription; SELECT INTO v_SequenceStartValue,v_SequenceIncrementBy, v_SequenceMaxValue rs_SequenceStartValue,rs_SequenceIncrementBy, rs_SequenceMaxValue FROM admtf_Sequence_Features(v_SequenceSchemaName,v_SequenceName); RETURN QUERY SELECT v_SequenceNumber,v_SequenceName, v_SequenceSchemaName,v_SequenceDescription, v_SequenceStartValue,v_SequenceIncrementBy, v_SequenceMaxValue,v_DependcyType, a_TableName,a_SchemaName,v_AttributeName; END LOOP; RETURN; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Table_Sequences(a_SchemaName NAME, a_TableName NAME) IS '  ,    '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; BEGIN TRANSACTION; DROP FUNCTION IF EXISTS admtf_Table_Sequences (a_SchemaName VARCHAR(256), a_TableName VARCHAR(256)); /**********************************************************************/ /*    ,     */ /**********************************************************************/ CREATE OR REPLACE FUNCTION admtf_Table_Sequences (a_SchemaName VARCHAR(256) default 'public', /*     */ a_TableName VARCHAR(256) default NULL /*   */ ) RETURNS TABLE (r_SequenceNumber SMALLINT,r_SequenceName VARCHAR(256), r_SequenceSchemaName VARCHAR(256),r_SequenceDescription TEXT, r_SequenceStartValue BIGINT,r_SequenceIncrementBy BIGINT, r_SequenceMaxValue BIGINT,r_DependType VARCHAR(256), r_RefTableName VARCHAR(256),r_RefTableSchemaName VARCHAR(256), r_RefAttributeName VARCHAR(256)) AS $BODY$ DECLARE c_Delimiter CONSTANT VARCHAR(2):=','; --****************************************************** BEGIN RETURN QUERY SELECT ts.r_SequenceNumber::SMALLINT, ts.r_SequenceName::VARCHAR(256), ts.r_SequenceSchemaName::VARCHAR(256) , ts.r_SequenceDescription::TEXT, ts.r_SequenceStartValue::BIGINT, ts.r_SequenceIncrementBy::BIGINT, ts.r_SequenceMaxValue::BIGINT, ts.r_DependType::VARCHAR(256), ts.r_RefTableName::VARCHAR(256), ts.r_RefTableSchemaName::VARCHAR(256), ts.r_RefAttributeName::VARCHAR(256) FROM admtf_Table_Sequences(a_SchemaName::NAME,a_TableName::NAME) ts; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Table_Sequences(a_SchemaName VARCHAR(256), a_TableName VARCHAR(256)) IS '  ,    '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; SELECT * FROM admtf_Table_Sequences('public'::VARCHAR(255),'kr_road_network_vertices_pgr'::VARCHAR(255)); SELECT * FROM admtf_Table_Sequences('public'::NAME,'kr_road_network_vertices_pgr'::NAME);</span></span></code> </pre><br></div></div><br><a name="tfTableS_woc"></a><h3>   admtf_Table_Sequences   (PostgreSQL 10) </h3><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">       .</a> <br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> admtf_Table_Sequences (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>, a_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>); <span class="hljs-comment"><span class="hljs-comment">/*********************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/*    ,     */</span></span> <span class="hljs-comment"><span class="hljs-comment">/**********************************************************************/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> admtf_Table_Sequences (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-string"><span class="hljs-string">'public'</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> a_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> (r_SequenceNumber <span class="hljs-built_in"><span class="hljs-built_in">SMALLINT</span></span>,r_SequenceName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>, r_SequenceSchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_SequenceDescription <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, r_SequenceStartValue <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span>,r_SequenceIncrementBy <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span>, r_SequenceMaxValue <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span>,r_DependType <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>, r_RefTableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,r_RefTableSchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>, r_RefAttributeName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> v_TableOID <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* OID */</span></span> v_Sequence RECORD; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_SequenceOID INTEGER; <span class="hljs-comment"><span class="hljs-comment">/* OID */</span></span> v_SequenceName NAME; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_SequenceSchemaName NAME; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> v_SequenceDescription TEXT; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_SequenceStartValue BIGINT; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> v_SequenceIncrementBy BIGINT; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_SequenceMaxValue BIGINT; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> v_DependcyType NAME; <span class="hljs-comment"><span class="hljs-comment">/*        */</span></span> v_AttributeName NAME; <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> v_SequenceNumber SMALLINT; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> c_Delimiter CONSTANT VARCHAR(2):=','; <span class="hljs-comment"><span class="hljs-comment">--****************************************************************** BEGIN v_SequenceNumber:=0; FOR v_Sequence IN SELECT pseq.relname AS SequenceName, snsp.nspname AS SequenceSchemaName, COALESCE(dsc.description,',    '||da.attname) AS SequenceDescription, d.depType AS DependcyType,da.attname AS AttributeName FROM pg_depend d INNER JOIN pg_class pseq ON d.objid = pseq.oid INNER JOIN pg_namespace snsp ON pseq.relnamespace=snsp.oid LEFT OUTER JOIN pg_Description dsc ON pseq.oid=dsc.objoid AND dsc.objsubid=0 INNER JOIN pg_class tbl ON d.refobjid = tbl.oid INNER JOIN pg_namespace nsp ON tbl.relnamespace=nsp.oid INNER JOIN pg_attribute da ON da.attrelid= d.refobjid ND d.refobjsubid=da.attnum WHERE tbl.relkind = 'r' AND pseq.relkind = 'S' AND LOWER(nsp.nspname)=LOWER(a_SchemaName) AND LOWER(tbl.relname)=LOWER(a_TableName) ORDER BY pseq.relname LOOP v_SequenceNumber:=v_SequenceNumber+1; v_SequenceName:=v_Sequence.SequenceName; v_SequenceSchemaName:=v_Sequence.SequenceSchemaName; v_DependcyType:=v_Sequence.DependcyType; v_AttributeName:=v_Sequence.AttributeName; v_SequenceDescription:=v_Sequence.SequenceDescription; SELECT INTO v_SequenceStartValue,v_SequenceIncrementBy,v_SequenceMaxValue rs_SequenceStartValue,rs_SequenceIncrementBy,rs_SequenceMaxValue FROM admtf_Sequence_Features(v_SequenceSchemaName,v_SequenceName); RETURN QUERY SELECT v_SequenceNumber,v_SequenceName, v_SequenceSchemaName,v_SequenceDescription, v_SequenceStartValue,v_SequenceIncrementBy, v_SequenceMaxValue,v_DependcyType, a_TableName,a_SchemaName,v_AttributeName; END LOOP; RETURN; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Table_Sequences(a_SchemaName NAME, a_TableName NAME) IS '  ,    '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; BEGIN TRANSACTION; DROP FUNCTION IF EXISTS admtf_Table_Sequences (a_SchemaName VARCHAR(256), a_TableName VARCHAR(256)); /**********************************************************************/ /*    ,     */ /**********************************************************************/ CREATE OR REPLACE FUNCTION admtf_Table_Sequences (a_SchemaName VARCHAR(256) default 'public', /*     */ a_TableName VARCHAR(256) default NULL /*   */ ) RETURNS TABLE (r_SequenceNumber SMALLINT,r_SequenceName VARCHAR(256), r_SequenceSchemaName VARCHAR(256),r_SequenceDescription TEXT, r_SequenceStartValue BIGINT,r_SequenceIncrementBy BIGINT, r_SequenceMaxValue BIGINT,r_DependType VARCHAR(256), r_RefTableName VARCHAR(256),r_RefTableSchemaName VARCHAR(256), r_RefAttributeName VARCHAR(256)) AS $BODY$ DECLARE c_Delimiter CONSTANT VARCHAR(2):=','; --******************************************************* BEGIN RETURN QUERY SELECT ts.r_SequenceNumber::SMALLINT, ts.r_SequenceName::VARCHAR(256), ts.r_SequenceSchemaName::VARCHAR(256), ts.r_SequenceDescription::TEXT, ts.r_SequenceStartValue::BIGINT, ts.r_SequenceIncrementBy::BIGINT, ts.r_SequenceMaxValue::BIGINT, ts.r_DependType::VARCHAR(256), ts.r_RefTableName::VARCHAR(256), ts.r_RefTableSchemaName::VARCHAR(256), ts.r_RefAttributeName::VARCHAR(256) FROM admtf_Table_Sequences(a_SchemaName::NAME,a_TableName::NAME) ts; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Table_Sequences(a_SchemaName VARCHAR(256), a_TableName VARCHAR(256)) IS '  ,    '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; SELECT * FROM admtf_Table_Sequences('public'::VARCHAR(255), 'kr_road_network_vertices_pgr'::VARCHAR(255)); SELECT * FROM admtf_Table_Sequences('public'::NAME, 'kr_road_network_vertices_pgr'::NAME);</span></span></code> </pre><br></div></div><br><a name="fnTableRC"></a><br><h3>   admfn_Table_RowCount </h3><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">       .</a> <br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> admfn_Table_RowCount (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,a_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>); <span class="hljs-comment"><span class="hljs-comment">/******************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> <span class="hljs-comment"><span class="hljs-comment">/******************************************************/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> admfn_Table_RowCount (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-string"><span class="hljs-string">'public'</span></span>,<span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> a_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> v_TableNumberOfRowCalc <span class="hljs-built_in"><span class="hljs-built_in">BIGINT</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> v_Found BOOLEAN; <span class="hljs-comment"><span class="hljs-comment">--*********************************************************** BEGIN IF a_SchemaName ~ E'^[a-z_0-9]+$' AND a_TableName ~ E'^[a-z_0-9]+$' THEN EXECUTE 'SELECT count(*) FROM ' ||a_SchemaName ||'.'|| a_TableName INTO v_TableNumberOfRowCalc; ELSE SELECT INTO v_Found true FROM pg_class tbl INNER JOIN pg_namespace nspc ON tbl.relnamespace = nspc.oid WHERE tbl.relkind='r' AND tbl.relname=a_TableName AND nspc.nspname=a_SchemaName; IF FOUND THEN EXECUTE 'SELECT count(*) FROM ' || CASE WHEN a_SchemaName ~ E'^[a-z_0-9]+$' THEN a_SchemaName ELSE quote_ident(a_SchemaName) END ||'.'|| CASE WHEN a_TableName ~ E'^[a-z_0-9]+$' THEN a_TableName ELSE quote_ident(a_TableName) END INTO v_TableNumberOfRowCalc; ELSE SELECT INTO v_Found true FROM pg_class tbl INNER JOIN pg_namespace nspc ON tbl.relnamespace = nspc.oid WHERE tbl.relkind='r' AND LOWER(tbl.relname)= LOWER(a_TableName) AND nspc.nspname=LOWER(a_SchemaName); IF FOUND THEN EXECUTE 'SELECT count(*) FROM ' || a_SchemaName ||'.'||a_TableName INTO v_TableNumberOfRowCalc; END IF; END IF; END IF; RETURN v_TableNumberOfRowCalc; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admfn_Table_RowCount(a_SchemaName NAME,a_TableName NAME) IS '    '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION;BEGIN TRANSACTION; DROP FUNCTION IF EXISTS admfn_Table_RowCount (a_SchemaName VARCHAR(256),a_TableName VARCHAR(256)); /********************************************************************/ /*       */ /********************************************************************/ CREATE OR REPLACE FUNCTION admfn_Table_RowCount (a_SchemaName VARCHAR(256) default 'public',/*     */ a_TableName VARCHAR(256) default NULL /*   */ ) RETURNS BIGINT AS $BODY$ DECLARE v_TableNumberOfRowCalc BIGINT; /*  */ --********************************************************* BEGIN RETURN admfn_Table_RowCount(a_SchemaName::NAME,a_TableName::NAME); END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admfn_Table_RowCount(a_SchemaName VARCHAR(256),a_TableName VARCHAR(256)) IS '    '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; SELECt admfn_Table_RowCount('public'::NAME,'Street'::NAME); SELECt admfn_Table_RowCount('public'::VARCHAR(256),'Street'::VARCHAR(256));</span></span></code> </pre><br></div></div><br><a name="tfTableIC"></a><h3>   admtf_Table_InheritanceChildrens </h3><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">       .</a> <br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> admtf_Table_InheritanceChildrens (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,a_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,a_Mode <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>)); <span class="hljs-comment"><span class="hljs-comment">/************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> <span class="hljs-comment"><span class="hljs-comment">/************************************************************/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> admtf_Table_InheritanceChildrens (a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-string"><span class="hljs-string">'public'</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> a_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> a_Mode <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-string"><span class="hljs-string">'estimate'</span></span> <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> (rs_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,rs_TableDescription <span class="hljs-built_in"><span class="hljs-built_in">TEXT</span></span>, rs_NumberOfAttribute <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span>,rs_NumberOfChecks <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span>, rs_hasPKey <span class="hljs-built_in"><span class="hljs-built_in">BOOLEAN</span></span>,rs_hasIndex <span class="hljs-built_in"><span class="hljs-built_in">BOOLEAN</span></span>, rs_hasSubClass <span class="hljs-built_in"><span class="hljs-built_in">BOOLEAN</span></span>,rs_NumberOfRow <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> c_TableKind <span class="hljs-keyword"><span class="hljs-keyword">CONSTANT</span></span> <span class="hljs-built_in"><span class="hljs-built_in">CHAR</span></span>:=<span class="hljs-string"><span class="hljs-string">'r'</span></span>; c_ExactlyMode CONSTANT VARCHAR(10):='exactly'; c_EstimateMode CONSTANT VARCHAR(10):='estimate'; v_TableOID OID; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_SchemaName NAME; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> v_TableName NAME; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_TableDescription TEXT; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> v_TableNumberOfRowCalc INTEGER; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> v_InheritanceRECORD RECORD; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> v_InheritanceOID OID; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">RETURN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">QUERY</span></span> <span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> rtbl.relname,rdsc.description,rtbl.relnatts::<span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span>, rtbl.relchecks::<span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span>,rtbl.relhaspkey,rtbl.relhasindex, rtbl.relhassubclass, <span class="hljs-keyword"><span class="hljs-keyword">CASE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHEN</span></span> a_Mode=c_ExactlyMode <span class="hljs-keyword"><span class="hljs-keyword">THEN</span></span> admfn_Table_RowCount(rnspc.nspname,rtbl.relname)::<span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ELSE</span></span> rtbl.reltuples::<span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> pg_class tbl <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_namespace nspc <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tbl.relnamespace = nspc.oid <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OUTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_Description dsc <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tbl.oid=dsc.objoid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> dsc.objsubid=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_depend dp <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> tbl.oid=dp.refobjid <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_class rtbl <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> rtbl.OID=dp.objid <span class="hljs-keyword"><span class="hljs-keyword">INNER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_namespace rnspc <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> rtbl.relnamespace = rnspc.oid <span class="hljs-keyword"><span class="hljs-keyword">LEFT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OUTER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">JOIN</span></span> pg_Description rdsc <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> rtbl.oid=rdsc.objoid <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> rdsc.objsubid=<span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WHERE</span></span> nspc.nspname=<span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_SchemaName) <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> tbl.relkind=c_TableKind <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> rtbl.relkind=c_TableKind <span class="hljs-keyword"><span class="hljs-keyword">AND</span></span> tbl.relname =<span class="hljs-keyword"><span class="hljs-keyword">LOWER</span></span>(a_TableName) <span class="hljs-keyword"><span class="hljs-keyword">ORDER</span></span> <span class="hljs-keyword"><span class="hljs-keyword">BY</span></span> rtbl.relname; <span class="hljs-keyword"><span class="hljs-keyword">END</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">LANGUAGE</span></span> plpgsql; <span class="hljs-keyword"><span class="hljs-keyword">COMMENT</span></span> <span class="hljs-keyword"><span class="hljs-keyword">ON</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> admtf_Table_InheritanceChildrens(a_SchemaName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,a_TableName <span class="hljs-keyword"><span class="hljs-keyword">NAME</span></span>,a_Mode <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">10</span></span>)) <span class="hljs-keyword"><span class="hljs-keyword">IS</span></span> <span class="hljs-string"><span class="hljs-string">'    '</span></span>; <span class="hljs-comment"><span class="hljs-comment">--ROLLBACK TRANSACTION; COMMIT TRANSACTION; BEGIN TRANSACTION; DROP FUNCTION IF EXISTS admtf_Table_InheritanceChildrens (a_SchemaName VARCHAR(256),a_TableName VARCHAR(256),a_TableName NAME,a_Mode VARCHAR(10)); /************************************************************************/ /*       */ /************************************************************************/ CREATE OR REPLACE FUNCTION admtf_Table_InheritanceChildrens (a_SchemaName VARCHAR(256) default 'public',/*     */ a_TableName VARCHAR(256) default NULL,/*   */ a_Mode VARCHAR(10) default 'estimate' /*     */ ) RETURNS TABLE (rs_TableName VARCHAR(256),rs_TableDescription TEXT, rs_NumberOfAttribute INTEGER,rs_NumberOfChecks INTEGER, rs_hasPKey BOOLEAN,rs_hasIndex BOOLEAN, rs_hasSubClass BOOLEAN,rs_NumberOfRow INTEGER) AS $BODY$ DECLARE c_TableKind CONSTANT CHAR:='r'; BEGIN RETURN QUERY SELECT tic.rs_TableName::VARCHAR(256),tic.rs_TableDescription::TEXT, tic.rs_NumberOfAttribute::INTEGER,tic.rs_NumberOfChecks::INTEGER, tic.rs_hasPKey::BOOLEAN,tic.rs_hasIndex::BOOLEAN, tic.rs_hasSubClass::BOOLEAN,tic.rs_NumberOfRow::INTEGER FROM admtf_Table_InheritanceChildrens(a_SchemaName::NAME, a_TableName::NAME,a_Mode::VARCHAR(10)) tic; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Table_InheritanceChildrens(a_SchemaName VARCHAR(256),a_TableName VARCHAR(256),a_Mode VARCHAR(10)) IS '    '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; SELECT * FROM admtf_Table_InheritanceChildrens('public'::NAME,'np_house'::NAME); SELECT * FROM admtf_Table_InheritanceChildrens('public'::VARCHAR(256),'np_house'::VARCHAR(256));</span></span></code> </pre><br></div></div><br><a name="tfAttPK"></a><h3>   admtf_Attribute_PKFeatures </h3><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">       .</a> <br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> admtf_Attribute_PKFeatures (a_TableOID <span class="hljs-keyword"><span class="hljs-keyword">OID</span></span>,a_AttributeNo <span class="hljs-built_in"><span class="hljs-built_in">SMALLINT</span></span>); <span class="hljs-comment"><span class="hljs-comment">/***************************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/*        . */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   ,          */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-comment"><span class="hljs-comment">/***************************************************************************/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> admtf_Attribute_PKFeatures (a_TableOID <span class="hljs-keyword"><span class="hljs-keyword">OID</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> a_AttributeNo <span class="hljs-built_in"><span class="hljs-built_in">SMALLINT</span></span> <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> (rs_isAttributePK <span class="hljs-built_in"><span class="hljs-built_in">BOOLEAN</span></span>,rs_PKeyName <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>,rs_ColumnPKNo <span class="hljs-built_in"><span class="hljs-built_in">SMALLINT</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> C_PKAttributeList_NDims <span class="hljs-keyword"><span class="hljs-keyword">CONSTANT</span></span> <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span>:=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> v_PKAttributeList SMALLINT[]; <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> v_PKAttributeIndx INTEGER; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> v_PKAttributeLBound INTEGER; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> v_PKAttributeUBound INTEGER; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-comment"><span class="hljs-comment">--********************************************************************** BEGIN rs_isAttributePK:=false; rs_ColumnPKNo:=NULL; SELECT INTO rs_PKeyName,v_PKAttributeList,rs_isAttributePK conname,conkey,ARRAY[a_AttributeNo]&lt;@conkey FROM pg_constraint c WHERE c.contype='p' and c.conrelid=a_TableOID; IF FOUND AND rs_isAttributePK THEN --      v_PKAttributeLBound:=array_lower(v_PKAttributeList,C_PKAttributeList_NDims); v_PKAttributeUBound:=array_upper(v_PKAttributeList,C_PKAttributeList_NDims); v_PKAttributeIndx:=v_PKAttributeLBound; WHILE v_PKAttributeIndx &lt;= v_PKAttributeUBound AND a_AttributeNo&lt;&gt;v_PKAttributeList[v_PKAttributeIndx] LOOP v_PKAttributeIndx:=v_PKAttributeIndx+1; END LOOP; IF v_PKAttributeIndx&lt;=v_PKAttributeUBound THEN rs_ColumnPKNo:=v_PKAttributeIndx; END IF; END IF; RETURN QUERY SELECT rs_isAttributePK,rs_PKeyName,rs_ColumnPKNo; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Attribute_PKFeatures(a_TableOID OID,a_AttributeNo SMALLINT) IS '              '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; SELECT * FROM admtf_Attribute_PKFeatures((SELECT OID FROM pg_class WHERE relname='street'),3::SMALLINT);</span></span></code> </pre><br></div></div><br><a name="tfAttFK"></a><h3>   admtf_Attribute_FKFeatures </h3><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">       .</a> <br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> admtf_Attribute_FKFeatures (a_TableOID <span class="hljs-keyword"><span class="hljs-keyword">OID</span></span>,a_AttributeNo <span class="hljs-built_in"><span class="hljs-built_in">SMALLINT</span></span>); <span class="hljs-comment"><span class="hljs-comment">/****************************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/*        . */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   ,         */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*   . */</span></span> <span class="hljs-comment"><span class="hljs-comment">/****************************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/****************************************************************************/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> admtf_Attribute_FKFeatures (a_TableOID <span class="hljs-keyword"><span class="hljs-keyword">OID</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> a_AttributeNo <span class="hljs-built_in"><span class="hljs-built_in">SMALLINT</span></span> <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> (rs_isAttributeFK <span class="hljs-built_in"><span class="hljs-built_in">BOOLEAN</span></span>,rs_FKeyName <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>[],rs_ColumnFKNo <span class="hljs-built_in"><span class="hljs-built_in">SMALLINT</span></span>[],rs_FKTableName <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>[],rs_FKTableColumnName <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>[]) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> C_FKAttributeList_NDims <span class="hljs-keyword"><span class="hljs-keyword">CONSTANT</span></span> <span class="hljs-built_in"><span class="hljs-built_in">INTEGER</span></span>:=<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> v_FKAttributeList SMALLINT[]; <span class="hljs-comment"><span class="hljs-comment">/*       */</span></span> v_RefAttributeList SMALLINT[]; <span class="hljs-comment"><span class="hljs-comment">/*     , */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> v_FKAttributeIndx INTEGER; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> v_RefAttributeListIndx INTEGER; <span class="hljs-comment"><span class="hljs-comment">/*     , */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> v_FKAttributeLBound INTEGER; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> v_FKAttributeUBound INTEGER; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> v_FKConstraintIndx INTEGER; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> v_FKeyName name; <span class="hljs-comment"><span class="hljs-comment">/*   , */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> v_FKTableName name; <span class="hljs-comment"><span class="hljs-comment">/*  ,     */</span></span> v_FKTableColumnName name; <span class="hljs-comment"><span class="hljs-comment">/*    , */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> v_RefAttributeNo SMALLINT; <span class="hljs-comment"><span class="hljs-comment">/*     , */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> v_Constraint pg_constraint%ROWTYPE; <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> <span class="hljs-comment"><span class="hljs-comment">/*  (CONSTRANT) */</span></span> <span class="hljs-comment"><span class="hljs-comment">--****************************************************************************************************** BEGIN rs_isAttributeFK:=false; rs_ColumnFKNo:=NULL; v_FKConstraintIndx:=0; FOR v_Constraint IN SELECT * FROM pg_constraint c WHERE c.contype='f' and c.conrelid=a_TableOID AND ARRAY[a_AttributeNo]&lt;@conkey ORDER BY c.oid LOOP v_FKConstraintIndx:=v_FKConstraintIndx+1; rs_isAttributeFK:=true; v_FKeyName:=v_Constraint.conname; v_FKAttributeList:=v_Constraint.conkey; v_RefAttributeList:=v_Constraint.confkey; v_FKAttributeLBound:=array_lower(v_FKAttributeList,C_FKAttributeList_NDims); v_FKAttributeUBound:=array_upper(v_FKAttributeList,C_FKAttributeList_NDims); v_FKAttributeIndx:=v_FKAttributeLBound; WHILE v_FKAttributeIndx &lt;= v_FKAttributeUBound AND a_AttributeNo&lt;&gt;v_FKAttributeList[v_FKAttributeIndx] LOOP v_FKAttributeIndx:=v_FKAttributeIndx+1; END LOOP; rs_FKeyName[v_FKConstraintIndx]:=v_FKeyName; rs_ColumnFKNo[v_FKConstraintIndx]:=v_FKAttributeIndx; SELECT INTO v_FKTableName ftbl.relname FROM pg_class ftbl WHERE ftbl.oid=v_Constraint.confrelid; rs_FKTableName[v_FKConstraintIndx]:=v_FKTableName; v_RefAttributeNo:=v_RefAttributeList[v_FKAttributeIndx]; v_FKTableColumnName:=NULL; SELECT INTO v_FKTableColumnName attname FROM pg_attribute a WHERE a.attrelid=v_Constraint.confrelid AND a.attnum=v_RefAttributeNo; rs_FKTableColumnName[v_FKConstraintIndx]:=v_FKTableColumnName; END LOOP; RETURN QUERY SELECT rs_isAttributeFK,rs_FKeyName,rs_ColumnFKNo, rs_FKTableName,rs_FKTableColumnName; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Attribute_FKFeatures(a_TableOID OID,a_AttributeNo SMALLINT) IS '              '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; SELECT * FROM admtf_Attribute_FKFeatures((SELECT OID FROM pg_class WHERE relname='street'),4::SMALLINT);</span></span></code> </pre><br></div></div><br><a name="tfAttF"></a><br><h3>   admtf_Attribute_Features </h3><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">       .</a> <br><div class="spoiler"> <b class="spoiler_title"> </b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">BEGIN</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TRANSACTION</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">DROP</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> <span class="hljs-keyword"><span class="hljs-keyword">IF</span></span> <span class="hljs-keyword"><span class="hljs-keyword">EXISTS</span></span> admtf_Attribute_Features (a_TableOID <span class="hljs-keyword"><span class="hljs-keyword">OID</span></span>,a_AttributeNo <span class="hljs-built_in"><span class="hljs-built_in">SMALLINT</span></span>); <span class="hljs-comment"><span class="hljs-comment">/****************************************************************************/</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-comment"><span class="hljs-comment">/****************************************************************************/</span></span> <span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">OR</span></span> <span class="hljs-keyword"><span class="hljs-keyword">REPLACE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">FUNCTION</span></span> admtf_Attribute_Features (a_TableOID <span class="hljs-keyword"><span class="hljs-keyword">OID</span></span>, <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> a_AttributeNo <span class="hljs-built_in"><span class="hljs-built_in">SMALLINT</span></span><span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">RETURNS</span></span> <span class="hljs-keyword"><span class="hljs-keyword">TABLE</span></span> (rsa_AttributeName <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>,rsa_UserTypeName <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">256</span></span>),rsa_TypeName <span class="hljs-built_in"><span class="hljs-built_in">VARCHAR</span></span>(<span class="hljs-number"><span class="hljs-number">256</span></span>),rsa_isNotNULL <span class="hljs-built_in"><span class="hljs-built_in">BOOLEAN</span></span>,rsa_isAttributePK <span class="hljs-built_in"><span class="hljs-built_in">BOOLEAN</span></span>, rsa_ColumnPKNo <span class="hljs-built_in"><span class="hljs-built_in">SMALLINT</span></span>,rsa_Description <span class="hljs-built_in"><span class="hljs-built_in">Text</span></span>,rsa_isAttributeFK <span class="hljs-built_in"><span class="hljs-built_in">BOOLEAN</span></span>,rsa_FKeyName <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>[],rsa_ColumnFKNo <span class="hljs-built_in"><span class="hljs-built_in">SMALLINT</span></span>[],rsa_FKTableName <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>[],rsa_FKTableColumnName <span class="hljs-keyword"><span class="hljs-keyword">name</span></span>[]) <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> $<span class="hljs-keyword"><span class="hljs-keyword">BODY</span></span>$ <span class="hljs-keyword"><span class="hljs-keyword">DECLARE</span></span> v_Return_Error <span class="hljs-built_in"><span class="hljs-built_in">Integer</span></span> := <span class="hljs-number"><span class="hljs-number">0</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  */</span></span> <span class="hljs-comment"><span class="hljs-comment">--********************************************************************* BEGIN SELECT INTO rsa_AttributeName,rsa_UserTypeName,rsa_TypeName, rsa_isNotNULL,rsa_Description attr.attname, CASE WHEN COALESCE(typ.typbasetype,0)&gt;0 THEN typ.typname::VARCHAR(100) ELSE ''END AS r_UserTypeName, FORMAT_TYPE(COALESCE(NULLIF(typ.typbasetype,0),typ.oid), COALESCE(NULLIF(typ.typtypmod,-1),attr.atttypmod))::VARCHAR(256) AS r_TypeName, attr.attnotnull AS r_isNotNULL, dsc.description AS r_Description FROM pg_attribute attr LEFT OUTER JOIN pg_type typ ON attr.atttypid=typ.oid LEFT OUTER JOIN pg_type btyp ON typ.typbasetype=btyp.oid LEFT OUTER JOIN pg_description dsc ON dsc.objoid=attr.attrelid AND dsc.objsubid=attr.attnum WHERE attr.attrelid =a_TableOID AND attr.attnum=a_AttributeNo; SELECT INTO rsa_isAttributePK,rsa_ColumnPKNo rs_isAttributePK,rs_ColumnPKNo FROM admtf_Attribute_PKFeatures(a_TableOID,a_AttributeNo); SELECT INTO rsa_isAttributeFK,rsa_FKeyName,rsa_ColumnFKNo,rsa_FKTableName, rsa_FKTableColumnName rs_isAttributeFK,rs_FKeyName, rs_ColumnFKNo,rs_FKTableName,rs_FKTableColumnName FROM admtf_Attribute_FKFeatures(a_TableOID,a_AttributeNo); RETURN QUERY SELECT rsa_AttributeName,rsa_UserTypeName,rsa_TypeName,rsa_isNotNULL, rsa_isAttributePK,rsa_ColumnPKNo,rsa_Description,rsa_isAttributeFK, rsa_FKeyName,rsa_ColumnFKNo,rsa_FKTableName,rsa_FKTableColumnName; END $BODY$ LANGUAGE plpgsql; COMMENT ON FUNCTION admtf_Attribute_Features(a_TableOID OID,a_AttributeNo SMALLINT) IS '   '; --ROLLBACK TRANSACTION; COMMIT TRANSACTION; SELECT * FROM admtf_Attribute_Features ((SELECT OID FROM pg_class WHERE relname='street'),2::SMALLINT);</span></span></code> </pre><br></div></div><br><h3>  Veja também </h3><br> <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">     PostgreSQL.  </a> ;</b> <br> <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">     PostgreSQL.  </a> .</b> <br> <b><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">     PostgreSQL. ( )</a> .</b> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt418597/">https://habr.com/ru/post/pt418597/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt418585/index.html">Construindo um mapa cross-country local do robô</a></li>
<li><a href="../pt418587/index.html">Novos clientes 3CX para Android e iOS com codec OPUS e PUSH para vários dispositivos</a></li>
<li><a href="../pt418589/index.html">O resumo de materiais frescos do mundo do front-end da última semana n ° 324 (23 a 29 de julho de 2018)</a></li>
<li><a href="../pt418591/index.html">Bug Bounty Kyivstar: recompensa pelo acesso de administrador aos serviços Jira, AWS, Apple, Google Developer, Bitbucket - $ 50</a></li>
<li><a href="../pt418593/index.html">Nem todos os fones de ouvido sem fio são igualmente úteis ou algumas palavras sobre o problema do codec</a></li>
<li><a href="../pt418599/index.html">5 fontes de dados que transformam dados do APM em análise de desempenho de aplicativos</a></li>
<li><a href="../pt418601/index.html">Toda a verdade sobre o RTOS. Artigo # 7 Núcleo SE: Introdução</a></li>
<li><a href="../pt418603/index.html">Smartwatch Matrix PowerWatch que nunca precisa ser carregado</a></li>
<li><a href="../pt418605/index.html">Analistas: capitalização da Microsoft pode chegar a US $ 1 trilhão</a></li>
<li><a href="../pt418607/index.html">Escolhendo um fornecedor no Wi-Fi corporativo</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>