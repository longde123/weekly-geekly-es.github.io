<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍡 🛢️ 🖕 去分配机制 🚶 📚 🏧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="当我第一次尝试了解Go中的内存分配工具如何工作时，我想处理的东西似乎就像一个神秘的黑匣子。 与其他任何技术一样，这里最重要的事情隐藏在许多抽象层的后面，您需要通过这些抽象层来理解某些内容。 

  

 该材料的作者（我们正在翻译的翻译）决定深入探讨Go中的内存分配方法，并对其进行讨论。 

 物理...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>去分配机制</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/442648/"> 当我第一次尝试了解Go中的内存分配工具如何工作时，我想处理的东西似乎就像一个神秘的黑匣子。 与其他任何技术一样，这里最重要的事情隐藏在许多抽象层的后面，您需要通过这些抽象层来理解某些内容。 <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/tv/0k/gh/tv0kghio2zhsc-og7bjd-mtl41q.jpeg"></a> <br><br> 该材料的作者（我们正在翻译的翻译）决定深入探讨Go中的内存分配方法，并对其进行讨论。 <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">物理和虚拟内存</font> </h2><br> 所有分配内存的方法都必须使用虚拟内存的地址空间，该地址空间由操作系统控制。 让我们看一下内存的工作原理，从最低级别开始-从内存单元开始。 <br> 这是如何想象RAM单元的方法。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e22/5e5/74c/e225e574c2649eb0bf9f5dd9cb1edadb.png"></div><br>  <i><font color="#999999">内存单元布局</font></i> <br><br> 如果非常简单地想象一个存储单元及其周围是什么，那么我们得到以下信息： <br><br><ol><li> 地址线（晶体管充当开关）是访问电容器（数据线）的通道。 </li><li> 当信号出现在地址线（红线）中时，数据线允许您将数据写入存储单元，即，对电容器充电，从而可以在其中存储对应于1的逻辑值。 </li><li>当地址线（绿线）中没有信号时，电容器被隔离并且其电荷不变。 要写入单元0，必须选择其地址并通过数据线提交逻辑0，即，将数据线与负号相连，从而使电容器放电。 </li><li> 当处理器需要从内存中读取值时，信号将沿着地址线发送（开关闭合）。 如果电容器已充电，则信号通过数据线（读取1），否则信号不通过数据线（读取0）。 </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e8d/33a/100/e8d33a100b5dbf94d34e794785670f24.png"></div><br>  <i><font color="#999999">物理内存与处理器交互的方案</font></i> <br><br> 数据总线负责在处理器和物理内存之间传输数据。 <br><br> 现在让我们谈谈地址线和可寻址字节。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d24/e38/542/d24e38542de230b449750b26641f5e8c.png"></div><br>  <i><font color="#999999">处理器和物理内存之间的总线地址线</font></i> <br><br><ol><li>  RAM中的每个字节都分配有一个唯一的数字标识符（地址）。 应该注意的是，存在于存储器中的物理字节的数量不等于地址线的数量。 </li><li> 每条地址线可以指定一个1位的值，因此它表示某个字节的地址中的一位。 </li><li> 我们的电路有32条地址线。 结果，每个可寻址字节使用32位数字作为其地址。  [00000000000000000000000000000000]-最低的内存地址。  [11111111111111111111111111111111111111]-最高的内存地址。 </li><li> 由于每个字节都有一个32位地址，因此我们的地址空间由2 <sup>32个</sup>可寻址字节（4 GB）组成。 </li></ol><br> 结果，可寻址字节的数量取决于地址线的总数。 例如，如果有64条地址线（x86-64处理器），则可以寻址2 <sup>个64</sup>字节（16艾字节）的内存，但是大多数使用64位指针的体系结构实际上都使用48位地址线（AMD64）和42位地址线（英特尔），理论上允许计算机配备256 TB的物理内存（Linux允许在x86-64体系结构上使用4级地址页时，为进程分配最多128 TB的地址空间，Windows允许您分配最多192 TB）。 <br> 由于物理RAM的大小受到限制，因此每个进程都在其自己的“沙盒”中运行-在所谓的“虚拟地址空间”（称为虚拟内存）中。 <br><br> 虚拟地址空间中的字节地址与处理器用来访问物理内存的地址不匹配。 结果，我们需要一个允许我们将虚拟地址转换为物理地址的系统。 看一下虚拟内存地址的外观。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9d0/09b/354/9d009b354ada519bf1280ea96e139e64.jpg"></div><br>  <i><font color="#999999">虚拟地址空间表示</font></i> <br><br> 结果，当处理器执行引用存储器地址的指令时，第一步是将逻辑地址转换为线性地址。 该转换由存储器管理单元执行。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/56a/330/ba9/56a330ba9d27daeb5737e013c0c15156.png"></div><br>  <i><font color="#999999">虚拟内存和物理内存之间关系的简化表示</font></i> <br><br> 由于逻辑地址太大而无法方便地单独使用它们（这取决于各种因素），因此内存被组织为称为页的结构。 在这种情况下，虚拟地址空间被分成小区域，页面，在大多数操作系统中，页面大小为4 KB，尽管通常可以更改此大小。 这是虚拟内存中内存管理的最小单位。 虚拟内存不存储任何内容，它只是设置程序的地址空间与物理内存之间的对应关系。 <br><br> 进程仅看到虚拟内存地址。 如果程序需要更多的动态内存（也称为堆内存或“堆”），会发生什么？ 这是一个简单的汇编代码示例，其中从系统请求其他动态分配的内存： <br><br><pre><code class="plaintext hljs">_start:        mov $12, %rax #    brk        mov $0, %rdi # 0 -  ,            syscall b0:        mov %rax, %rsi #  rsi    ,           mov %rax, %rdi #     ...        add $4, %rdi # ..  4 ,           mov $12, %rax #    brk        syscall</code> </pre> <br> 这是如何以图表形式表示的方法。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c22/962/904/c229629041c7612e254d89d146fcc4ef.png"></div><br>  <i><font color="#999999">增加动态分配的内存</font></i> <br><br> 该程序使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">brk</a>系统调用（sbrk / mmap等）请求额外的内存。 内核会更新有关虚拟内存的信息，但是物理内存中尚未出现新页面，因此虚拟内存和物理内存之间存在差异。 <br><br><h2>  <font color="#3AC1EF">内存分配器</font> </h2><br> 概括地说，在讨论了使用虚拟地址空间的问题之后，讨论了如何请求额外的动态内存（堆上的内存）之后，我们将更容易讨论分配内存的方法。 <br><br> 如果堆具有足够的内存来满足我们的代码请求，则内存分配器可以执行这些请求而无需访问内核。 否则，他必须使用系统调用（例如，使用brk）来增加堆的大小，同时请求较大的内存块。 对于malloc，“大”表示由<code>MMAP_THRESHOLD</code>参数描述的大小，默认情况下为128 Kb。 <br><br> 但是，内存分配器比简单分配内存承担更多责任。 他最重要的职责之一是减少内部和外部内存碎片，并尽快分配内存块。 假设我们的程序使用<code>malloc(size)</code>形式的函数顺序执行分配内存连续块的请求，然后使用<code>free(pointer)</code>形式的函数释放该内存。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/944/8a0/779/9448a077982dfb81e4c982c1228cad15.png"></div><br>  <i><font color="#999999">外部碎片演示</font></i> <br><br> 在上一个图中，在步骤p4，尽管可用内存总量允许这样做，但我们没有足够的顺序定位的存储块来满足分配六个这样的块的请求。 这种情况导致内存碎片。 <br><br> 如何减少内存碎片？ 这个问题的答案取决于特定的内存分配算法，该算法使用哪种基础库来处理内存。 <br><br> 现在，我们来看一下Go内存分配机制所基于的TCMalloc内存分配工具。 <br><br><h2>  <font color="#3AC1EF">TCM分配</font> </h2><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">TCMalloc</a>基于将内存划分为多个级别以减少内存碎片的想法。 在TCMalloc内部，内存管理分为两部分：使用线程内存和使用堆。 <br><br><h3>  <font color="#3AC1EF">▍线程记忆</font> </h3><br> 存储器的每一页都分为一定大小的片段序列，这些片段根据大小级别进行选择。 这减少了碎片。 结果，每个线程都可以使用小对象的缓存，从而可以为小于或等于32 KB的对象非常有效地分配内存。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/331/901/7c8/3319017c8657e4b75a25003357d4b4f4.png"></div><br>  <i><font color="#999999">流缓存</font></i> <br><br><h3>  <font color="#3AC1EF">▍束</font> </h3><br>  TCMalloc托管堆是页面的集合，其中一组连续页面可以表示为页面范围（跨度）。 当您需要为大于32 KB的对象分配内存时，将使用堆来分配内存。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/48c/f49/707/48cf497071e18b1539c18e6c2057e85d.png"></div><br>  <i><font color="#999999">堆和处理页面</font></i> <br><br> 当没有足够的空间将小对象放置在内存中时，它们将转向堆以获取内存。 如果堆没有足够的可用内存，则从操作系统请求其他内存。 <br><br> 结果，提出的使用内存的模型支持用户空间内存池；其使用显着提高了分配和释放内存的效率。 <br><br> 应该注意的是，Go内存分配工具最初是基于TCMalloc的，但是与之略有不同。 <br><br><h2>  <font color="#3AC1EF">转到内存分配器</font> </h2><br> 我们知道Go运行时计划在逻辑处理器上运行goroutine。 类似地，Go使用的TCMalloc版本将内存页面分为多个块，这些块的大小对应于存在67个特定大小类。 <br><br> 如果您不熟悉Go计划程序<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">，则</a>可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在此处</a>阅读有关它的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">信息</a> 。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/824/d5c/0df/824d5c0dfac562629662650924292583.png"></div><br>  <i><font color="#999999">围棋班</font></i> <br><br> 由于Go中的最小页面大小为8192字节（8 Kb），因此，如果将这样的页面划分为1 KB的块，那么我们将获得8个这样的块。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/150/865/6ba/1508656ba4a4c009624468a164d41e5b.png"></div><br>  <i><font color="#999999">8 KB的页面大小分为与1 KB的类大小相对应的块</font></i> <br><br>  Go中类似的页面序列是使用称为mspan的结构来控制的。 <br><br><h3>  <font color="#3AC1EF">ms结构mspan</font> </h3><br>  mspan结构是一个双向链接列表，该对象包含页面的起始地址，有关页面大小和其中包含的页面数的信息。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dbd/cae/fc0/dbdcaefc090a443369d33c2cde7e06ae.png"></div><br>  <i><font color="#999999">Mspan结构</font></i> <br><br><h3>  <font color="#3AC1EF">▍mcache结构</font> </h3><br> 与TCMalloc一样，Go为每个逻辑处理器提供了一个本地线程缓存，称为mcache。 结果，如果goroutine需要内存，则可以直接从mcache获取它。 为此，您无需执行锁定，因为在任何给定时间，一个逻辑处理器上仅执行一个goroutin。 <br><br>  mcache结构以高速缓存的形式包含各种大小类的mspan结构。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/478/7bb/459/4787bb4597d56f89b474189c5e86441b.png"></div><br>  <i><font color="#999999">Go中逻辑处理器，mcache和mspan之间的交互</font></i> <br><br> 由于每个逻辑处理器都有自己的mcache，因此从mcache分配内存时不需要锁。 <br><br> 每个大小类都可以由以下对象之一表示： <br><br><ul><li> 扫描对象是包含指针的对象。 </li><li>  Noscan对象是没有指针的对象。 </li></ul><br> 这种方法的优势之一是，在执行垃圾回收时，无需绕过noscan对象，因为它们不包含为其分配内存的对象。 <br><br> 什么进入mcache？ 大小不超过32 KB的对象将使用相应大小类的mspan直接转到mcache。 <br><br> 如果mcache没有空闲单元会怎样？ 然后，它们从称为mcentral的mspan对象列表中获得所需大小级别的新mspan。 <br><br><h3>  <font color="#3AC1EF">▍中心结构</font> </h3><br> 中心结构收集特定大小级别的所有页面范围。 每个中心对象包含两个mspan对象列表。 <br><br><ol><li> 没有空闲对象或mcache中的mspan的mspan对象的列表。 </li><li> 具有可用对象的mspan对象列表。 </li></ol><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6dc/b88/7f9/6dcb887f9c717bb1f24735daa4b50aa7.png"></div><br>  <i><font color="#999999">中心结构</font></i> <br><br> 每个中心结构都存在于堆结构中。 <br><br><h3>  <font color="#3AC1EF">▍堆结构</font> </h3><br>  mheap结构由在Go中处理堆管理的对象表示。 只有这样的全局对象拥有一个虚拟地址空间。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c8e/b07/01b/c8eb0701bbe46523e2735e695db97115.png"></div><br>  <i><font color="#999999">堆结构</font></i> <br><br> 从上图可以看到，mheap结构包含一组mcentral结构。 该数组包含所有大小类的中心结构。 <br><br><pre> <code class="plaintext hljs">central [numSpanClasses]struct { mcentral mcentral   pad     [sys.CacheLineSize unsafe.Sizeof(mcentral{})%sys.CacheLineSize]byte }</code> </pre> <br> 由于每个大小类都有一个中心结构，因此当mcache向mcentral请求mspan结构时，将在单个mcentral级别上应用锁，结果是，可以同时处理来自其他mcache的请求，该请求将具有其他大小的mspan结构。 <br><br> 对齐（填充）可确保中心结构彼此分隔开对应于<code>CacheLineSize</code>值的字节数。 结果，每个<code>mcentral.lock</code>都有自己的缓存行，从而避免了与错误的内存共享相关的问题。 <br><br> 如果中心列表为空会怎样？ 然后，mcentral从mheap接收一系列页面，以分配所需大小级别的内存片段。 <br><br><ul><li>  <code>free[_MaxMHeapList]mSpanList</code>是<code>free[_MaxMHeapList]mSpanList</code>的数组。 每个spanList中的mspan结构由1〜127（_MaxMHeapList-1）页组成。 例如，free [3]是包含3个页面的mspan结构的链接列表。 在这种情况下，“空闲”一词表示我们正在谈论的是未分配内存的空列表。 与空列表相反，列表可以是分配了内存（忙）的列表。 </li><li>  <code>freelarge mSpanList</code>是可用的mspan结构的列表。 每个元素（即mspan）的页面数大于127。为了支持此列表，使用了mtreap数据结构。 繁忙的mspan结构的列表称为busylarge。 </li></ul><br> 大于32 Kb的对象被视为大对象，它们的内存直接从mheap分配。 使用锁定执行为此类对象分配内存的请求，因此，在给定的时间点，仅可以从一个逻辑处理器处理类似的请求。 <br><br><h2>  <font color="#3AC1EF">为对象分配内存的过程</font> </h2><br><ul><li> 如果对象的大小超过32 Kb，则认为它很大，它的内存直接从mheap分配。 </li><li> 如果对象的大小小于16 Kb，则使用称为微小分配器的mcache机制。 </li><li> 如果对象的大小在16-32 Kb的范围内，则表明要使用哪个大小类（sizeClass），然后在mcache中分配合适的块。 </li><li> 如果sizeClass中没有与mcache相对应的块，则调用mcentral。 </li><li> 如果mcentral没有空闲块，则它们调用mheap并搜索最合适的mspan。 如果事实证明应用程序所需的内存大小大于可能分配的内存大小，则将处理请求的内存大小，以便有可能返回程序所需要的尽可能多的页面，形成新的mspan结构。 </li><li> 如果应用程序的虚拟内存仍然不足，则将访问操作系统以获取一组新的页面（请求至少1 MB的内存）。 </li></ul><br> 实际上，在操作系统级别，Go要求分配更大的内存（称为arenas）。 同时分配大块内存使您可以在分配给应用程序的内存量和对性能的高成本访问之间找到折衷方案。 <br><br> 堆上请求的内存是从竞技场分配的。 考虑这种机制。 <br><br><h2>  <font color="#3AC1EF">虚拟内存去</font> </h2><br> 用一个用Go编写的简单程序看一下内存使用情况： <br><br><pre> <code class="plaintext hljs">func main() {   for {} }</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c33/4cd/dee/c334cddee46f32a66d3528b08deda48e.png"></div><br>  <i><font color="#999999">程序流程信息</font></i> <br><br> 即使是这样简单的程序，虚拟地址空间也大约为100 MB，而RSS索引仅为696 Kb。 首先，让我们尝试找出造成这种差异的原因。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f34/2a7/f41/f342a7f41d8ff7fbf3b5f081415c5ab4.png"></div><br>  <i><font color="#999999">地图和地图信息</font></i> <br><br> 在这里，您可以看到存储区，其大小大约等于2 MB，64 MB，32 MB。 这是什么样的记忆？ <br><br><h3>  <font color="#3AC1EF">▍竞技场</font> </h3><br> 事实证明，Go中的虚拟内存由一组竞技场组成。 用于堆的初始内存大小对应一个域，即-64 MB（与Go 1.11.5有关）。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9dd/17e/ba9/9dd17eba9a4c5acf9371052d62d902d9.png"></div><br>  <i><font color="#999999">各种系统中当前的竞技场规模</font></i> <br><br> 结果，程序的当前需求所需的存储器被一小部分地分配。 此过程从一个64 MB的竞技场开始。 <br><br> 我们在这里谈论的那些数字指标不应该用于某些绝对值和不变值。 他们可以改变。 例如，在之前的Go中，Go预先预留了一个连续的虚拟空间，在64位系统上，竞技场大小为512 GB（想想如果实际内存需求如此之大以至于mmap会拒绝相应的请求会发生什么，那会很有趣？） <br><br> 实际上，我们将一堆竞技场称为一堆。 在Go中，竞技场被视为内存的碎片，分为8192字节（8 Kb）大小的块。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/55b/927/7e0/55b9277e0c55876b1bbf11bb1b869c9e.png"></div><br>  <i><font color="#999999">一个64 MB的竞技场</font></i> <br><br>  Go具有更多其他类型的块-span和bitmap。 它们的内存在堆外部分配，它们存储竞技场元数据。 它们主要用于垃圾收集。 <br> 这是内存分配机制在Go中的工作原理概述。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b01/61f/13f/b0161f13f6bc905731f0bfb339fd3a10.png"></div><br>  <i><font color="#999999">Go中的内存分配机制概述</font></i> <br><br><h2>  <font color="#3AC1EF">总结</font> </h2><br> 通常，应该指出的是，在本材料中，我们以非常笼统的术语描述了使用Go内存的子系统。  Go中的内存子系统的主要思想是使用各种结构和不同级别的缓存来分配内存。 这考虑了为其分配内存的对象的大小。 <br><br> 由于这种方法避免了阻塞，因此以多层结构的形式表示从操作系统接收到的连续内存地址的单个块可以提高内存分配机制的效率。 资源分配，考虑到需要存储在内存中的对象的大小，可以减少碎片，并且在释放内存之后，可以加快垃圾回收的速度。 <br><br>  <b>亲爱的读者们！</b> 您是否遇到过由于Go编写的程序中的内存故障而引起的问题？ <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN442648/">https://habr.com/ru/post/zh-CN442648/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN442638/index.html">基于Prometheus指标的Kubernetes应用扩展</a></li>
<li><a href="../zh-CN442640/index.html">完美的错误：在Flash中使用类型混淆。 第一部分</a></li>
<li><a href="../zh-CN442642/index.html">三月份阅读内容：针对营销人员，管理人员，开发人员和设计师的22本新书</a></li>
<li><a href="../zh-CN442644/index.html">大多数非编程技能可提高开发人员价值</a></li>
<li><a href="../zh-CN442646/index.html">Kubernetes网络：入口</a></li>
<li><a href="../zh-CN442650/index.html">React应用程序的分析和优化</a></li>
<li><a href="../zh-CN442652/index.html">使用Fastify和Preact快速原型化Web应用程序</a></li>
<li><a href="../zh-CN442654/index.html">切换到Next.js并加快歧管网站首页的加载7.5倍</a></li>
<li><a href="../zh-CN442658/index.html">使用CSS的8个技巧：视差，粘页脚等</a></li>
<li><a href="../zh-CN442660/index.html">调和牛顿与量子世界的数学</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>