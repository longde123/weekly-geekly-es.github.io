<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔖 🌈 😱 学习去：编写具有端到端加密的p2p Messenger 🐟 🔎 🈚️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="另一个P2P Messenger 


 仅阅读评论和语言文档不足以学习如何在其上编写或多或少有用的应用程序。 


 确保合并，您需要创建一些有趣的东西，以便将这些开发成果用于其他任务。 





 本文面向对围棋语言和对等网络感兴趣的初学者。 
 对于可以提出合理想法或建设性批评的专业人员。 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>学习去：编写具有端到端加密的p2p Messenger</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437686/"><h1 id="yet-another-p2p-messenger"> 另一个P2P Messenger </h1><br><p> 仅阅读评论和语言文档不足以学习如何在其上编写或多或少有用的应用程序。 </p><br><p> 确保合并，您需要创建一些有趣的东西，以便将这些开发成果用于其他任务。 </p><br><p><img src="https://habrastorage.org/webt/kt/bm/3r/ktbm3rsivunfcdcvcyqvnm14f5u.png" alt="ReactJs聊天界面示例"></p><br><p> 本文面向对围棋语言和对等网络感兴趣的初学者。 <br> 对于可以提出合理想法或建设性批评的专业人员。 </p><a name="habracut"></a><br><p> 我在Java，PHP，JS，Python中使用不同程度的沉浸程度已经进行了一段时间的编程。 <br> 而且每种编程语言在其领域都是不错的。 </p><br><p>  Go的主要领域是创建分布式服务微服务。 <br> 通常，微服务是执行其高度专业化功能的小型程序。 </p><br><p>但是微服务仍应能够相互通信，因此创建微服务的工具应允许轻松，轻松地进行网络连接。 <br> 为了测试这一点，我们将编写一个组织去中心化对等网络（Peer-To-Peer）的应用程序，最简单的是p2p Messenger（顺便说一句，这个单词有俄语同义词吗？）。 </p><br><p> 在代码中，我积极发明自行车并踩踏耙子，以感受戈朗，得到建设性的批评和合理的建议。 </p><br><h2 id="chto-delaem"> 我们该怎么办 </h2><br><p> 对等（peer）-Messenger的唯一实例。 </p><br><p> 我们的使者应该能够： </p><br><ul><li> 寻找附近的盛宴 </li><li> 与其他同伴建立联系 </li><li> 加密与对等方的数据交换 </li><li> 接收来自用户的消息 </li><li> 向用户显示消息 </li></ul><br><p> 为了使任务更加有趣，让我们全部通过一个网络端口进行。 </p><br><p><img src="https://habrastorage.org/webt/5b/zo/8g/5bzo8g4eqogveeure4lzgngo5ma.png" alt="信使的条件方案"></p><br><p> 如果通过HTTP拉该端口，我们将获得一个React应用程序，该应用程序通过建立Web套接字连接来拉同一个端口。 </p><br><p> 如果您通过HTTP而不是从本地计算机拉端口，则我们将显示标语。 </p><br><p> 如果另一个对等方连接到该端口，则使用端到端加密建立永久连接。 </p><br><h2 id="opredelyaem-tip-vhodyaschego-soedineniya"> 确定传入连接的类型 </h2><br><p> 首先，打开端口进行监听，我们将等待新的连接。 </p><br><pre><code class="go hljs">net.ListenTCP(<span class="hljs-string"><span class="hljs-string">"tcp"</span></span>, tcpAddr)</code> </pre> <br><p> 在新连接上，读取前4个字节。 </p><br><p> 我们获取HTTP动词列表，然后将其4个字节进行比较。 </p><br><p> 现在，我们确定是否从本地计算机建立了连接，如果没有建立连接，我们将显示一条横幅并挂断。 </p><br><pre> <code class="go hljs"> buf, err := readWriter.Peek(<span class="hljs-number"><span class="hljs-number">4</span></span>) <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ItIsHttp(buf) { handleHttp(readWriter, conn, p) } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { peer := proto.NewPeer(conn) p.HandleProto(readWriter, peer) } <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !strings.EqualFold(s, <span class="hljs-string"><span class="hljs-string">"127"</span></span>) &amp;&amp; !strings.EqualFold(s, <span class="hljs-string"><span class="hljs-string">"[::"</span></span>) { response.Body = ioutil.NopCloser(strings.NewReader(<span class="hljs-string"><span class="hljs-string">"Peer To Peer Messenger. see https://github.com/easmith/p2p-messenger"</span></span>)) }</code> </pre> <br><p> 如果连接是本地连接，那么我们将使用与请求相对应的文件进行响应。 </p><br><p> 然后，我决定自己编写处理程序，尽管我可以使用标准库中提供的处理程序。 </p><br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">//   func processRequest(request *http.Request, response *http.Response) {/*    */} //     fileServer := http.FileServer(http.Dir("./front/build/")) fileServer.ServeHTTP(NewMyWriter(conn), request)</span></span></code> </pre> <br><p> 如果请求路径<code>/ws</code> ，那么我们尝试建立一个websocket连接。 </p><br><p> 由于我在处理文件请求时组装了自行车，因此我将使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">gorilla / websocket库</a>来处理ws连接。 </p><br><p> 为此，创建<code>MyWriter</code>并在其中实现方法以对应于接口<code>http.ResponseWriter</code>和<code>http.Hijacker</code> 。 </p><br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">// w - MyWriter func handleWs(w http.ResponseWriter, r *http.Request, p *proto.Proto) { c, err := upgrader.Upgrade(w, r, w.Header()) /*          */ }</span></span></code> </pre> <br><h2 id="obnaruzhenie-pirov"> 对等检测 </h2><br><p> 为了在局域网中搜索对等体，我们将使用UDP多播。 </p><br><p> 我们会将带有有关我们自己的信息的数据包发送到多播IP地址。 </p><br><pre> <code class="go hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">startMeow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p *proto.Proto)</span></span></span></span> { conn, err := net.DialUDP(<span class="hljs-string"><span class="hljs-string">"udp"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, addr) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { _, err := conn.Write([]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>(fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"meow:%v:%v"</span></span>, hex.EncodeToString(p.PubKey), p.Port))) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> time.Sleep(<span class="hljs-number"><span class="hljs-number">1</span></span> * time.Second) } }</code> </pre> <br><p> 并与多播IP分开侦听所有UDP数据包。 </p><br><pre> <code class="go hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">listenMeow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(address </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">, p *proto.Proto, handler </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">func</span></span></span></span><span class="hljs-function"><span class="hljs-params">(p *proto.Proto, peerAddress </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> conn, err := net.ListenMulticastUDP(<span class="hljs-string"><span class="hljs-string">"udp"</span></span>, <span class="hljs-literal"><span class="hljs-literal">nil</span></span>, addr) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> _, src, err := conn.ReadFromUDP(buffer) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-comment"><span class="hljs-comment">// connectToPeer handler(p, peerAddress) }</span></span></code> </pre> <br><p> 因此，我们宣布自己，并了解其他盛宴的出现。 </p><br><p> 可以在IP级别上进行组织，甚至在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">IPv4包</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">官方文档中，也</a>仅将多播数据包作为代码示例给出。 </p><br><h2 id="protokol-vzaimodeystviya-pirov"> 对等交互协议 </h2><br><p> 我们将同伴之间的所有通信都封装在一个信封（信封）中。 </p><br><p> 在任何信封上总是有一个发送者和一个接收者，为此我们将添加一条命令（他随身携带），一个标识符（到目前为止这是一个随机数，但可以作为内容的哈希值），内容的长度和信封本身的内容-消息或命令参数。 </p><br><p><img src="https://habrastorage.org/webt/3b/yx/yc/3byxycyif222uk2jslbya9qb1bs.png" alt="信封字节"></p><br><p> 该命令（或内容的类型）已成功放置在信封的最开始，并且我们定义了一个4字节的命令列表，该列表与HTTP动词的名称不相交。 </p><br><p> 在传输过程中，整个信封被序列化为字节数组。 </p><br><h3 id="rukopozhatie"> 握手 </h3><br><p> 建立连接后，盛宴立即伸出手进行握手，提供其名称，公共密钥和临时公共密钥以生成共享会话密钥。 </p><br><p> 作为响应，对等方收到一组相似的数据，注册在其列表中找到的对等方，并计算（CalcSharedSecret）公共会话密钥。 </p><br><pre> <code class="go hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">handShake</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(p *proto.Proto, conn net.Conn)</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">proto</span></span></span><span class="hljs-function">.</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Peer</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> peer := proto.NewPeer(conn) <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> p.SendName(peer) <span class="hljs-comment"><span class="hljs-comment">/*     */</span></span> envelope, err := proto.ReadEnvelope(bufio.NewReader(conn)) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><h3 id="obmen-pirami"> 盛宴交流 </h3><br><p> 握手后，对等方交换其对等方列表=） </p><br><p> 为此，将发送带有LIST命令的信封，并在其内容中放置一个JSON对等体列表。 <br> 作为回应，我们得到了类似的信封。 </p><br><p> 我们在新列表中找到，并尝试与每个列表建立联系，握手，交流盛宴等... </p><br><h3 id="obmen-polzovatelskimi-soobscheniyami"> 用户消息 </h3><br><p> 自定义消息对我们来说是最大的价值，因此我们将对每个连接进行加密和签名。 </p><br><h4 id="o-shifrovanii"> 关于加密 </h4><br><p> 在来自crypto软件包的标准（google）golang库中，实现了许多不同的算法（没有GOST标准）。 </p><br><p> 我认为最方便的签名是Ed25519曲线。 我们将使用ed25519库对消息进行签名。 </p><br><p> 从一开始，我就考虑过使用从ed25519获得的密钥对不仅用于签名，还用于生成会话密钥。 </p><br><p> 但是，用于签名的密钥不适用于计算共享密钥-您仍然需要想到它们： </p><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CreateKeyExchangePair</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(publicKey [32]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">, privateKey [32]</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { pub, priv, err := ed25519.GenerateKey(<span class="hljs-literal"><span class="hljs-literal">nil</span></span>) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>(publicKey[:], pub[:]) <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>(privateKey[:], priv[:]) curve25519.ScalarBaseMult(&amp;publicKey, &amp;privateKey) <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> <br><p> 因此，决定生成临时密钥，并且一般来说，这是正确的方法，不会使攻击者有机会获得通用密钥。 </p><br><p> 对于数学爱好者，以下是Wiki链接： <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><em>Diffie</em>协议—椭圆曲线上的Hellman_</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">数字签名EdDSA</a> </p><br><p> 共享密钥的生成是非常标准的：首先，对于新连接，我们生成临时密钥，我们将带有公共密钥的信封发送到套接字。 </p><br><p> 另一侧的操作相同，但顺序不同：它接收带有公钥的信封，生成自己的对，然后将公钥发送到套接字。 </p><br><p> 现在，每个参与者都有别人的公共和私人临时密钥。 </p><br><p> 乘以它们，我们就得到了相同的密钥，我们将用它来加密消息。 </p><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//CalcSharedSecret Calculate shared secret func CalcSharedSecret(publicKey []byte, privateKey []byte) (secret [32]byte) { var pubKey [32]byte var privKey [32]byte copy(pubKey[:], publicKey[:]) copy(privKey[:], privateKey[:]) curve25519.ScalarMult(&amp;secret, &amp;privKey, &amp;pubKey) return }</span></span></code> </pre> <br><p> 我们将使用已建立的AES算法以块耦合模式（CBC）对消息进行加密。 </p><br><p> 所有这些实现都可以在golang文档中轻松找到。 </p><br><p> 唯一的改进是使用零字节自动填充消息，以确保其长度乘以加密块的长度（16字节）。 </p><br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">//Encrypt the message func Encrypt(content []byte, key []byte) []byte { padding := len(content) % aes.BlockSize if padding != 0 { repeat := bytes.Repeat([]byte("\x00"), aes.BlockSize-(padding)) content = append(content, repeat...) } /* ... */ } //Decrypt encrypted message func Decrypt(encrypted []byte, key []byte) []byte { /* ... */ encrypted = bytes.Trim(encrypted, string([]byte("\x00"))) return encrypted }</span></span></code> </pre> <br><p> 早在2013年，作为Pavel Durov竞赛的一部分，他实现了AES（与CBC类似的模式）来加密Telegram中的消息。 </p><br><p> 当时，电报<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">中</a>使用了最常见的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Diffie-Hellman协议</a>来生成临时密钥。 </p><br><p> 并且为了从假连接中排除负载，在每次密钥交换之前，客户端解决了分解问题。 </p><br><h2 id="gui"> 图形用户界面 </h2><br><p> 我们需要显示一个对等方的列表和与之相关的消息列表，还需要通过增加对等方名称旁边的计数器来响应新消息。 </p><br><p> 这里没有麻烦-ReactJS + websocket。 </p><br><p>  Web套接字消息本质上是唯一的信封，只有它们不包含密文。 </p><br><p> 它们都是<code>WsCmd</code>类型的“继承人”，并且在传输时以JSON序列化。 </p><br><pre> <code class="go hljs"> <span class="hljs-comment"><span class="hljs-comment">//Serializable interface to detect that can to serialised to json type Serializable interface { ToJson() []byte } func toJson(v interface{}) []byte { json, err := json.Marshal(v) /*  err */ return json } /* ... */ //WsCmd WebSocket command type WsCmd struct { Cmd string `json:"cmd"` } //WsMessage WebSocket command: new Message type WsMessage struct { WsCmd From string `json:"from"` To string `json:"to"` Content string `json:"content"` } //ToJson convert to JSON bytes func (v WsMessage) ToJson() []byte { return toJson(v) } /* ... */</span></span></code> </pre> <br><p> 因此，一个HTTP请求到达根目录（“ /”），现在显示其前端，在“ front / build”目录中查找并给出index.html </p><br><p> 界面已经好了，现在用户可以选择：在浏览器或单独的窗口-WebView中运行它。 </p><br><p> 对于最后使用的选项<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">zserge / webview</a> </p><br><pre> <code class="go hljs"> e := webview.Open(<span class="hljs-string"><span class="hljs-string">"Peer To Peer Messenger"</span></span>, fmt.Sprintf(<span class="hljs-string"><span class="hljs-string">"http://localhost:%v"</span></span>, initParams.Port), <span class="hljs-number"><span class="hljs-number">800</span></span>, <span class="hljs-number"><span class="hljs-number">600</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre> <br><p> 要使用它构建应用程序，您需要安装另一个系统 </p><br><pre> <code class="bash hljs"> sudo apt install libwebkit2gtk-4.0-dev</code> </pre> <br><p> 在考虑GUI的过程中，我发现许多用于GTK，QT的库，并且控制台界面看起来非常怪异-我认为这是一个非常有趣的主意-https: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//github.com/jroimartin/gocui</a> 。 </p><br><h2 id="zapusk-messendzhera"> 信使发射 </h2><br><h3 id="ustanovka-golang">  Golang安装 </h3><br><p> 当然，您首先需要安装go。 <br> 为此，我强烈建议您使用<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">golang.org/doc/install</a>说明。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">bash脚本的</a>简化说明 </p><br><h3 id="zagruzka-prilozheniya-v-gopath"> 在GOPATH中下载应用程序 </h3><br><p> 如此安排，所有库甚至您的项目都应位于所谓的GOPATH中。 </p><br><p> 默认情况下，这是$ HOME / go。  Go允许您使用简单的命令从公共存储库中提取源代码： </p><br><pre> <code class="bash hljs"> go get github.com/easmith/p2p-messenger</code> </pre> <br><p> 现在，在您的<code>$HOME/go/src/github.com/easmith/p2p-messenger</code>将显示master分支<code>$HOME/go/src/github.com/easmith/p2p-messenger</code>源 </p><br><h3 id="ustanovka-npm-i-sborka-fronta">  Npm安装和前部组装 </h3><br><p> 就像我在上面写的那样，我们的GUI是一个Web应用程序，在ReactJs上有一个前端，因此前端仍然需要组装。 </p><br><p>  Nodejs + npm-像往常一样。 </p><br><p> 以防万一，这是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Ubuntu</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">说明</a> </p><br><p> 现在我们以标准的方式启动前部组件 </p><br><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> front npm update npm run build</code> </pre> <br><p> 前面准备好了！ </p><br><h3 id="zapusk"> 发射 </h3><br><p> 让我们回到根源，启动我们的使者盛宴。 </p><br><p> 在启动时，我们可以指定对等体的名称，端口，文件以及其他对等体的地址以及一个标志，指示是否启动WebView。 </p><br><p> 缺省情况下， <code>$USER@$HOSTNAME</code>用作对<code>$USER@$HOSTNAME</code>名称和端口35035。 </p><br><p> 因此，我们开始与本地网络上的朋友聊天。 </p><br><pre> <code class="bash hljs"> go run app.go -name Snowden</code> </pre> <br><h2 id="otzyv-o-programmirovanii-na-golang"> 有关Golang编程的反馈 </h2><br><ul><li> 我想指出的最重要的事情是： <strong>在执行过程中，它立即可以实现我的预期</strong> 。 <br> 您几乎需要的所有内容都在标准库中。 </li><li> 但是，当我在GOPATH以外的目录中启动该项目时遇到了困难。 <br> 我用GoLand编写代码。 首先，使用自动导入库自动格式化代码很尴尬。 </li><li>  <strong>IDE</strong>中有<strong>很多代码生成器</strong> ，这些<strong>代码生成</strong>器使我们能够专注于开发而不是代码集。 </li><li> 您很快<strong>就习惯</strong>了频繁的错误处理，但是当您意识到正常情况是根据错误的字符串表示来分析错误的本质时，就会遇到麻烦。 <br><pre> <code class="go hljs">err != io.EOF</code> </pre> </li><li> 使用os库，情况会好一些。 这样的构造有助于理解问题的实质。 <br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> os.IsNotExist(err) { <span class="hljs-comment"><span class="hljs-comment">/* ... */</span></span> }</code> </pre> </li><li> 开箱即用，go可以教我们正确编写代码和编写测试。 <br> 还有一些。 我们已经使用<code>ToJson()</code>方法描述了该接口。 <br> 因此，文档生成器不会继承实现此方法的方法的描述，因此，为了消除不必要的警告，您必须将文档复制到每个已实现的方法（proto / mtypes.go）中。 </li><li> 最近，我已经习惯了Java中log4j的功能，因此没有足够好的logger。 <br> 可能值得一看的是使用添加程序和格式化程序的github美丽日志记录的广阔之处。 </li><li> 数组异常工作。 <br> 例如，串联通过<code>append</code>函数发生，并且通过<code>copy</code>任意长度的数组转换为固定长度的数组。 </li><li>  <code>switch-case</code>工作方式类似于<code>if-elseif-else</code>但这是一种有趣的方法，但又需要面对面： <br> 如果我们想要常规的<code>switch-case</code>行为，则需要对每种情况进行检查。 <br> 您也可以使用<code>goto</code> ，但是请不要使用！ </li><li> 没有三元运算符，通常这不方便。 </li></ul><br><h2 id="chto-dalshe"> 接下来是什么？ </h2><br><p> 因此，实现了最简单的对等Messenger。 </p><br><p> 锥体塞满了，进一步可以改善用户功能：发送文件，图片，音频，表情符号等。 </p><br><p> 而且您不能发明协议，而使用Google协议缓冲区， <br> 使用以太坊智能合约连接区块链并保护自己免受垃圾邮件的侵害。 </p><br><p> 在智能合约上，组织群聊，频道，名称系统，头像和用户个人资料。 </p><br><p> 还必须运行种子对等方，实现NAT绕过，并在对等方之间发送消息。 </p><br><p> 结果，您得到了一个很好的替代电报/电话，您只需要将所有朋友转移到那里=） </p><br><h2 id="poleznosti"> 有用性 </h2><br><div class="spoiler">  <b class="spoiler_title">一些链接</b> <div class="spoiler_text"><p> 在Messenger的工作过程中，我发现了一些对于初学者go开发人员来说很有趣的页面。 <br> 我与您分享： </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">golang.org/doc/-</a>语言文档，所有内容都很简单，清晰并带有示例。 可以使用以下命令在本地运行相同的文档 </p><br><pre> <code class="bash hljs">godoc -HTTP=:6060</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">gobyexample.com-</a>简单示例的集合 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">golang</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">book.ru-</a>俄语中的一本好书 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">github.com/dariubs/GoBooks</a>是有关Go的书籍的集合。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">awesome</a> - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">go.com-</a>有趣的库，框架和应用程序列表。 分类或多或少，但其中许多描述非常稀缺，这不利于通过Ctrl + F进行搜索 </p></div></div></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN437686/">https://habr.com/ru/post/zh-CN437686/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN437674/index.html">无人驾驶车辆的3D对象识别方法。 Yandex报告</a></li>
<li><a href="../zh-CN437676/index.html">利用大学和企业加速器在美国启动B2B初创企业</a></li>
<li><a href="../zh-CN437680/index.html">我在YouTube上的DIY收藏</a></li>
<li><a href="../zh-CN437682/index.html">编写另一个Kubernetes模板工具</a></li>
<li><a href="../zh-CN437684/index.html">最高算法-有偏纲</a></li>
<li><a href="../zh-CN437688/index.html">OpenSceneGraph：基本编程技术</a></li>
<li><a href="../zh-CN437694/index.html">分析实用程序Files.walkFileTree（）;</a></li>
<li><a href="../zh-CN437696/index.html">＃283移动开发人员的有趣材料摘要（1月21日至27日）</a></li>
<li><a href="../zh-CN437698/index.html">WIPO翻译专利翻译服务-我的经验</a></li>
<li><a href="../zh-CN437702/index.html">Google求职面试解析：同义查询</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>