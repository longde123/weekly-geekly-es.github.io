<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🚀 👂🏼 🙎 Concatenación de cadenas o código de bytes de parche 🍙 🕢 ‼️</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Recientemente leí un artículo sobre la optimización del rendimiento del código Java, en particular, la concatenación de cadenas. La pregunta seguía ah...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Concatenación de cadenas o código de bytes de parche</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/416479/">  Recientemente leí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">un artículo</a> sobre la optimización del rendimiento del código Java, en particular, la concatenación de cadenas.  La pregunta seguía ahí: por qué cuando se usa StringBuilder en el código debajo del corte, el programa se ejecuta más lentamente que con una simple adición.  En este caso, + = durante la compilación se convierte en llamadas StringBuilder.append (). <br><br>  Inmediatamente tuve el deseo de resolver el problema. <br><a name="habracut"></a><br><pre><code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// ~20 000 000    public String stringAppend() { String s = "foo"; s += ", bar"; s += ", baz"; s += ", qux"; s += ", bar"; s += ", bar"; s += ", bar"; s += ", bar"; s += ", bar"; s += ", bar"; s += ", baz"; s += ", qux"; s += ", baz"; s += ", qux"; s += ", baz"; s += ", qux"; s += ", baz"; s += ", qux"; s += ", baz"; s += ", qux"; s += ", baz"; s += ", qux"; return s; } // ~7 000 000    public String stringAppendBuilder() { StringBuilder sb = new StringBuilder(); sb.append("foo"); sb.append(", bar"); sb.append(", bar"); sb.append(", baz"); sb.append(", qux"); sb.append(", baz"); sb.append(", qux"); sb.append(", baz"); sb.append(", qux"); sb.append(", baz"); sb.append(", qux"); sb.append(", baz"); sb.append(", qux"); sb.append(", baz"); sb.append(", qux"); sb.append(", baz"); sb.append(", qux"); sb.append(", baz"); sb.append(", qux"); sb.append(", baz"); sb.append(", qux"); sb.append(", baz"); sb.append(", qux"); return sb.toString(); }</span></span></code> </pre> <br>  Entonces todo mi razonamiento se redujo al hecho de que esta es una magia inexplicable dentro de la JVM, y dejé de tratar de darme cuenta de lo que estaba sucediendo.  Sin embargo, durante la siguiente discusión sobre las diferencias entre plataformas en la velocidad de trabajar con cadenas, mi amigo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=" class="user_link">yegorf1 y yo</a> decidimos averiguar por qué y cómo sucede exactamente esta magia. <br><br><h4>  Oracle Java SE </h4><br>  <i>upd: se realizaron pruebas en Java 8</i> <br>  La solución obvia es recopilar el código fuente en bytecode y luego mirar su contenido.  Entonces lo hicimos.  En los comentarios hubo sugerencias de que la aceleración está relacionada con la optimización: las líneas constantes obviamente deberían estar pegadas en el nivel de compilación.  Resultó que esto no es así.  Aquí hay una parte del bytecode descompilado con javap: <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> java.lang.<span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stringAppend</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; Code: <span class="hljs-number"><span class="hljs-number">0</span></span>: ldc #<span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-comment"><span class="hljs-comment">// String foo 2: astore_1 3: new #3 // class java/lang/StringBuilder 6: dup 7: invokespecial #4 // Method java/lang/StringBuilder."&lt;init&gt;":()V 10: aload_1 11: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 14: ldc #6 // String , bar 16: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span></code> </pre> <br>  Puede notar que no se han realizado optimizaciones.  Extraño, ¿no es así?  Bien, veamos el bytecode de la segunda función. <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> java.lang.<span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stringAppendBuilder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; Code: <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> #<span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-comment"><span class="hljs-comment">// class java/lang/StringBuilder 3: dup 4: invokespecial #4 // Method java/lang/StringBuilder."&lt;init&gt;":()V 7: astore_1 8: aload_1 9: ldc #2 // String foo 11: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 14: pop 15: aload_1 16: ldc #6 // String , bar 18: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span></code> </pre> <br>  Aquí de nuevo, no hay optimizaciones?  Además, echemos un vistazo a las instrucciones en 8, 14 y 15 bytes.  Allí sucede algo extraño: primero, una referencia a un objeto de la clase StringBuilder se carga en la pila, luego se arroja desde la pila y se vuelve a cargar.  La solución más simple viene a la mente: <br><br><pre> <code class="java hljs"> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> java.lang.<span class="hljs-function"><span class="hljs-function">String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">stringAppendBuilder</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span>; Code: <span class="hljs-number"><span class="hljs-number">0</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> #<span class="hljs-number"><span class="hljs-number">41</span></span> <span class="hljs-comment"><span class="hljs-comment">// class java/lang/StringBuilder 3: dup 4: invokespecial #4 // Method java/lang/StringBuilder."&lt;init&gt;":()V 7: astore_1 8: aload_1 9: ldc #2 // String foo 11: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder; 14: ldc #6 // String , bar 16: invokevirtual #5 // Method java/lang/StringBuilder.append:(Ljava/lang/String;)Ljava/lang/StringBuilder;</span></span></code> </pre> <br>  Desechando instrucciones innecesarias, obtenemos un código que funciona 1.5 veces más rápido que la versión stringAppend, en la que esta optimización ya se ha llevado a cabo.  Por lo tanto, la culpa de la "magia" es el compilador de bytecode incompleto, que no puede realizar optimizaciones bastante simples. <br><br><h4>  Android ART </h4><br>  <i>upd: el código fue construido bajo sdk 28 con las herramientas de compilación</i> <br>  Entonces, resultó que el problema está relacionado con la implementación del compilador de Java en el código de bytes para la pila JVM.  Aquí recordamos la existencia de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ART, que es parte del Proyecto de Código Abierto de Android</a> .  Esta máquina virtual, o más bien, el compilador de código de bytes en código nativo, fue escrita en una <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">demanda</a> de Oracle, lo que nos da todas las razones para creer que las diferencias con la implementación de Oracle son significativas.  Además, debido a los detalles de los procesadores ARM, esta máquina virtual es un registro, no una pila. <br><br>  Echemos un vistazo a Smali (una de las representaciones de bytecode en ART): <br><br><pre> <code class="hljs rust"># <span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> methods .method public stringAppend()Ljava/lang/<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>; .registers <span class="hljs-number"><span class="hljs-number">4</span></span> .prologue .line <span class="hljs-number"><span class="hljs-number">6</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>-string/jumbo v0, <span class="hljs-string"><span class="hljs-string">"foo"</span></span> .line <span class="hljs-number"><span class="hljs-number">7</span></span> .local v0, <span class="hljs-string"><span class="hljs-string">"s"</span></span>:Ljava/lang/<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>; new-instance v1, Ljava/lang/StringBuilder; invoke-direct {v1}, Ljava/lang/StringBuilder;-&gt;&lt;init&gt;()V invoke-<span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> {v1, v0}, Ljava/lang/StringBuilder;-&gt;append(Ljava/lang/<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>;)Ljava/lang/StringBuilder; <span class="hljs-keyword"><span class="hljs-keyword">move</span></span>-result-object v1 <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>-string/jumbo v2, <span class="hljs-string"><span class="hljs-string">", bar"</span></span> invoke-<span class="hljs-keyword"><span class="hljs-keyword">virtual</span></span> {v1, v2}, Ljava/lang/StringBuilder;-&gt;append(Ljava/lang/<span class="hljs-built_in"><span class="hljs-built_in">String</span></span>;)Ljava/lang/StringBuilder; <span class="hljs-keyword"><span class="hljs-keyword">move</span></span>-result-object v1 <span class="hljs-comment"><span class="hljs-comment">//... .method public stringAppendBuilder()Ljava/lang/String; .registers 3 .prologue .line 13 new-instance v0, Ljava/lang/StringBuilder; invoke-direct {v0}, Ljava/lang/StringBuilder;-&gt;&lt;init&gt;()V .line 14 .local v0, "sb":Ljava/lang/StringBuilder; const-string/jumbo v1, "foo" invoke-virtual {v0, v1}, Ljava/lang/StringBuilder;-&gt;append(Ljava/lang/String;)Ljava/lang/StringBuilder; .line 15 const-string/jumbo v1, ", bar" invoke-virtual {v0, v1}, Ljava/lang/StringBuilder;-&gt;append(Ljava/lang/String;)Ljava/lang/StringBuilder; //...</span></span></code> </pre><br>  En esta variante stringAppendBuilder no hay más problemas con la pila: la máquina es un registro y, en principio, no pueden ocurrir.  Sin embargo, esto no interfiere con la existencia de cosas absolutamente mágicas: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">move</span></span>-result-<span class="hljs-keyword"><span class="hljs-keyword">object</span></span> v1</code> </pre> <br>  Esta cadena en stringAppend no hace nada: el enlace al objeto StringBuilder que necesitamos ya está en el registro v1.  Sería lógico suponer que stringAppend funcionará más lentamente.  Esto se confirma experimentalmente: el resultado es similar al resultado de la versión "parcheada" del programa para la pila JVM: StringBuilder funciona casi una vez y media más rápido. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/es416479/">https://habr.com/ru/post/es416479/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../es416469/index.html">Sincronización de billetera Bitcoin</a></li>
<li><a href="../es416471/index.html">El origen azul de Jeff Bezos planea aterrizar en la luna para 2023</a></li>
<li><a href="../es416473/index.html">Interfaz de la ciudad: fichas táctiles en las aceras</a></li>
<li><a href="../es416475/index.html">El rover de oportunidad sigue en silencio debido a la tormenta de polvo en Marte</a></li>
<li><a href="../es416477/index.html">Aprendizaje automático y desarrollo móvil</a></li>
<li><a href="../es416481/index.html">Yuri Akkermann: "Uno de los principios fundamentales de la Alianza FIDO es garantizar la privacidad"</a></li>
<li><a href="../es416483/index.html">Juego de rol: el formato más antiguo de un mundo completamente gratuito en juegos</a></li>
<li><a href="../es416485/index.html">SpaceX está trabajando para crear un pequeño "submarino" para salvar a los adolescentes de una cueva en Tailandia</a></li>
<li><a href="../es416487/index.html">Radio Astron cumple 7 años</a></li>
<li><a href="../es416489/index.html">Vida extraterrestre: sobre la corrección de la ecuación de Drake y el gran filtro</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>