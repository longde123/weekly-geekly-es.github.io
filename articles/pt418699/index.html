<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>✍🏻 🧑🏻 🌐 Criando uma máquina de arcade emulador. Parte 3 🚥 🧝🏿 🎈</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Partes um e dois . 

 Emulador de processador 8080 
 Shell do emulador 
 Agora você deve ter todo o conhecimento necessário para começar a criar um em...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Criando uma máquina de arcade emulador. Parte 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418699/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ec/e50/f3a/4ece50f3a555bfb39878326ec26addd5.jpg" alt="imagem"></div><br>  Partes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">um</a> e <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">dois</a> . <br><br><h1>  Emulador de processador 8080 </h1><br><h1>  Shell do emulador </h1><br>  Agora você deve ter todo o conhecimento necessário para começar a criar um emulador de processador 8080. <br><br>  <em>Vou tentar deixar meu código o mais claro possível, cada código operacional é implementado separadamente.</em>  <em>Quando você se sentir confortável com isso, poderá reescrevê-lo para otimizar o desempenho ou reutilizar o código.</em> <br><br>  Para começar, vou criar uma estrutura de memória que conterá campos para tudo o que me pareceu necessário ao escrever um desmontador.  Também haverá um local para um buffer de memória, que será a RAM. <br><a name="habracut"></a><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConditionCodes</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> z:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> s:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> p:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> cy:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> ac:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pad:<span class="hljs-number"><span class="hljs-number">3</span></span>; } ConditionCodes; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State8080</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> b; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> c; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> d; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> e; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> h; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> l; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> sp; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *memory; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConditionCodes</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cc</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> int_enable; } State8080;</code> </pre> <br>  Agora crie um procedimento com uma chamada de erro que encerre o programa com um erro.  Será algo parecido com isto: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnimplementedInstruction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State8080* state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// pc    ,     printf ("Error: Unimplemented instruction\n"); exit(1); } int Emulate8080Op(State8080* state) { unsigned char *opcode = &amp;state-&gt;memory[state-&gt;pc]; switch(*opcode) { case 0x00: UnimplementedInstruction(state); break; case 0x01: UnimplementedInstruction(state); break; case 0x02: UnimplementedInstruction(state); break; case 0x03: UnimplementedInstruction(state); break; case 0x04: UnimplementedInstruction(state); break; /*....*/ case 0xfe: UnimplementedInstruction(state); break; case 0xff: UnimplementedInstruction(state); break; } state-&gt;pc+=1; //  }</span></span></code> </pre> <br>  Vamos implementar alguns códigos de operação. <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Emulate8080Op</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State8080* state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *opcode = &amp;state-&gt;memory[state-&gt;pc]; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(*opcode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">//NOP -  ! case 0x01: //LXI B, state-&gt;c = opcode[1]; state-&gt;b = opcode[2]; state-&gt;pc += 2; //   2  break; /*....*/ case 0x41: state-&gt;b = state-&gt;c; break; //MOV B,C case 0x42: state-&gt;b = state-&gt;d; break; //MOV B,D case 0x43: state-&gt;b = state-&gt;e; break; //MOV B,E } state-&gt;pc+=1; }</span></span></code> </pre> <br>  Lá vai você.  Para cada opcode, alteramos o estado e a memória, como faria um comando executado em um 8080 real. <br><br>  O 8080 possui cerca de 7 tipos, dependendo de como você os classifica: <br><br><ul><li>  Transferência de dados </li><li>  Aritmética </li><li>  Logical </li><li>  Ramos </li><li>  Stack </li><li>  Entrada-saída </li><li>  Especial </li></ul><br>  Vamos olhar para cada um deles individualmente. <br><br><h1>  Grupo aritmético </h1><br>  As instruções aritméticas são muitos dos 256 opcodes do processador 8080, que incluem vários tipos de adição e subtração.  A maioria das instruções aritméticas trabalha com o registro A e salva o resultado em A. (O registro A também é chamado de acumulador). <br><br>  É interessante notar que esses comandos afetam os códigos de condição.  Os códigos de estado (também chamados de sinalizadores) são configurados dependendo do resultado do comando executado.  Nem todos os comandos afetam sinalizadores e nem todas as equipes que afetam sinalizadores afetam todos os sinalizadores de uma só vez. <br><br><h3>  Flags 8080 </h3><br>  Em um processador 8080, os sinalizadores são chamados Z, S, P, CY e AC. <br><br><ul><li>  Z (zero, zero) assume o valor 1 quando o resultado é zero </li><li>  S (sinal) assume o valor 1 quando o bit 7 (o bit mais significativo, o bit mais significativo, MSB) do comando matemático é fornecido </li><li>  P (paridade, paridade) é definido quando o resultado é par e é redefinido quando é ímpar </li><li>  CY (carry) assume o valor 1 quando, como resultado do comando, é realizada uma transferência ou empréstimo para um bit de ordem superior </li><li>  AC (transporte auxiliar) é usado principalmente para matemática BCD (decimal com código binário).  Para mais detalhes, consulte o manual, em Space Invaders, esse sinalizador não é usado. </li></ul><br>  Os códigos de estado são usados ​​em comandos de ramificação condicional, por exemplo, JZ executa ramificação apenas se o sinalizador Z estiver definido. <br><br>  A maioria das instruções possui três formas: para registros, valores imediatos e memória.  Vamos implementar algumas instruções para entender seus formulários e ver como é trabalhar com códigos de estado.  (Observe que eu não implemento o sinalizador de transferência auxiliar porque ele não é usado. Se eu o implementei, não poderia testá-lo.) <br><br><h4>  Formulário de Registro </h4><br>  Aqui está um exemplo de implementação de duas instruções com um formulário de registro;  no primeiro, implantei o código para facilitar o trabalho e, no segundo, é apresentado um formulário mais compacto que faz a mesma coisa. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span>: <span class="hljs-comment"><span class="hljs-comment">//ADD B { //      , //      uint16_t answer = (uint16_t) state-&gt;a + (uint16_t) state-&gt;b; //  :    , //    , //      if ((answer &amp; 0xff) == 0) state-&gt;cc.z = 1; else state-&gt;cc.z = 0; //  :   7 , //    , //      if (answer &amp; 0x80) state-&gt;cc.s = 1; else state-&gt;cc.s = 0; //   if (answer &gt; 0xff) state-&gt;cc.cy = 1; else state-&gt;cc.cy = 0; //    state-&gt;cc.p = Parity( answer &amp; 0xff); state-&gt;a = answer &amp; 0xff; } //  ADD     case 0x81: //ADD C { uint16_t answer = (uint16_t) state-&gt;a + (uint16_t) state-&gt;c; state-&gt;cc.z = ((answer &amp; 0xff) == 0); state-&gt;cc.s = ((answer &amp; 0x80) != 0); state-&gt;cc.cy = (answer &gt; 0xff); state-&gt;cc.p = Parity(answer&amp;0xff); state-&gt;a = answer &amp; 0xff; }</span></span></code> </pre> <br>  Eu emulo comandos matemáticos de 8 bits com um número de 16 bits.  Isso facilita o rastreamento de casos em que os cálculos geram uma carga. <br><br><h4>  Formulário para valores imediatos </h4><br>  O formulário para valores imediatos é quase o mesmo, exceto que o byte após o comando é a fonte do adicionado.  Como “opcode” é um ponteiro para o comando atual na memória, opcode [1] será imediatamente o próximo byte. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xC6</span></span>: <span class="hljs-comment"><span class="hljs-comment">//ADI  { uint16_t answer = (uint16_t) state-&gt;a + (uint16_t) opcode[1]; state-&gt;cc.z = ((answer &amp; 0xff) == 0); state-&gt;cc.s = ((answer &amp; 0x80) != 0); state-&gt;cc.cy = (answer &gt; 0xff); state-&gt;cc.p = Parity(answer&amp;0xff); state-&gt;a = answer &amp; 0xff; }</span></span></code> </pre> <br><h4>  Forma para memória </h4><br>  No formulário de memória, um byte será adicionado ao qual o endereço armazenado em um par de registros HL indica. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x86</span></span>: <span class="hljs-comment"><span class="hljs-comment">//ADD M { uint16_t offset = (state-&gt;h&lt;&lt;8) | (state-&gt;l); uint16_t answer = (uint16_t) state-&gt;a + state-&gt;memory[offset]; state-&gt;cc.z = ((answer &amp; 0xff) == 0); state-&gt;cc.s = ((answer &amp; 0x80) != 0); state-&gt;cc.cy = (answer &gt; 0xff); state-&gt;cc.p = Parity(answer&amp;0xff); state-&gt;a = answer &amp; 0xff; }</span></span></code> </pre> <br><h3>  Anotações </h3><br>  As demais instruções aritméticas são implementadas de maneira semelhante.  Adições: <br><br><ul><li>  Em diferentes versões com transporte (ADC, ACI, SBB, SUI), de acordo com o manual de referência, usamos bits de transporte nos cálculos. </li><li>  INX e DCX afetam pares de registradores; esses comandos não afetam sinalizadores. </li><li>  DAD é outro comando de um par de registros, afeta apenas a bandeira de transporte </li><li>  INR e DCR não afetam o sinalizador de transporte </li></ul><br><h1>  Grupo de filiais </h1><br>  Depois de lidar com os códigos de estado, o grupo de filiais ficará claro o suficiente para você.  Existem dois tipos de ramificação - transições (JMP) e chamadas (CALL).  O JMP apenas define o PC para o valor do destino do salto.  CALL é usado para rotinas, grava o endereço de retorno na pilha e atribui ao PC o endereço de destino.  RET retorna de CALL, recebendo o endereço da pilha e gravando-o no PC. <br><br>  JMP e CALL apenas vão para endereços absolutos que são codificados em bytes após o código de operação. <br><br><h3>  Jmp </h3><br>  O comando JMP ramifica incondicionalmente no endereço de destino.  Também existem comandos de ramificação condicional para todos os códigos de status (exceto para AC): <br><br><ul><li>  JNZ e JZ para zero </li><li>  JNC e JC para migração </li><li>  JPO e JPE para paridade </li><li>  JP (mais) e JM (menos) para o sinal </li></ul><br>  Aqui está uma implementação de alguns deles: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xc2</span></span>: <span class="hljs-comment"><span class="hljs-comment">//JNZ  if (0 == state-&gt;cc.z) state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; else //    state-&gt;pc += 2; break; case 0xc3: //JMP  state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; break;</span></span></code> </pre> <br><h3>  CHAMADA e RET </h3><br>  CALL envia o endereço da instrução para a pilha após a chamada e depois pula para o endereço de destino.  O RET recebe o endereço da pilha e o salva no PC.  Versões condicionais do CALL e RET existem para todos os estados. <br><br><ul><li>  CZ, CNZ, RZ, RNZ para zero </li><li>  CNC, CC, RNC, RC para transferência </li><li>  CPO, CPE, RPO, RPE para paridade </li><li>  CP, CM, RP, RM para sinal </li></ul><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xcd</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CALL  { uint16_t ret = state-&gt;pc+2; state-&gt;memory[state-&gt;sp-1] = (ret &gt;&gt; 8) &amp; 0xff; state-&gt;memory[state-&gt;sp-2] = (ret &amp; 0xff); state-&gt;sp = state-&gt;sp - 2; state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; } break; case 0xc9: //RET state-&gt;pc = state-&gt;memory[state-&gt;sp] | (state-&gt;memory[state-&gt;sp+1] &lt;&lt; 8); state-&gt;sp += 2; break;</span></span></code> </pre> <br><h3>  Anotações </h3><br><ul><li>  O comando PCHL salta incondicionalmente para um endereço em um par de registros HL. </li><li>  Não incluí o RST discutido anteriormente neste grupo.  Ele grava o endereço de retorno na pilha e salta para o endereço predefinido na parte inferior da memória. </li></ul><br><h1>  Grupo lógico </h1><br>  Este grupo executa operações lógicas (consulte a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">primeira postagem do</a> tutorial).  Por sua natureza, eles são semelhantes a um grupo aritmético, pois a maioria das operações trabalha com o registro A (unidade) e a maioria das operações afeta sinalizadores.  Todas as operações são executadas em valores de 8 bits; nesse grupo, não há comandos que afetem pares de registradores. <br><br><h3>  Operações booleanas </h3><br>  AND, OR, NOT (CMP) e "exclusivo ou" (XOR) são chamados de operações booleanas.  OU e AND eu expliquei anteriormente.  O comando NOT (para o processador 8080 é chamado de CMA, ou acumulador de complemento) simplesmente altera os valores dos bits - todas as unidades se tornam zeros e zeros se tornam um. <br><br>  Eu percebo o XOR como um "reconhecedor de diferenças".  Sua tabela de verdade é assim: <br><br><table><tbody><tr><td>  x </td><td>  y </td><td>  Resultado </td></tr><tr><td>  0 0 </td><td>  0 0 </td><td>  0 0 </td></tr><tr><td>  0 0 </td><td>  1 </td><td>  1 </td></tr><tr><td>  1 </td><td>  0 0 </td><td>  1 </td></tr><tr><td>  1 </td><td>  1 </td><td>  0 0 </td></tr></tbody></table><br>  AND, OR e XOR têm um formulário para registros, memória e valores imediatos.  (O CMP possui apenas um comando que diferencia maiúsculas de minúsculas).  Aqui está uma implementação de um par de códigos de operação: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x2F</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CMA (not) state-&gt;a = ~state-&gt;a //  ,  CMA     break; case 0xe6: //ANI  { uint8_t x = state-&gt;a &amp; opcode[1]; state-&gt;cc.z = (x == 0); state-&gt;cc.s = (0x80 == (x &amp; 0x80)); state-&gt;cc.p = parity(x, 8); state-&gt;cc.cy = 0; //  ,  ANI  CY state-&gt;a = x; state-&gt;pc++; //   } break;</span></span></code> </pre> <br><h3>  Comandos de mudança cíclica </h3><br>  Esses comandos alteram a ordem dos bits nos registradores.  Um deslocamento para a direita os move um pouco para a direita e um deslocamento para a esquerda - um pouco para a esquerda: <br><br> <code>  (0b00010000) = 0b00001000</code> <br> <br> <code>  (0b00000001) = 0b00000010</code> <br> <br>  Eles parecem não ter valor, mas na realidade não é assim.  Eles podem ser usados ​​para multiplicar e dividir por potências de dois.  Tome o deslocamento à esquerda como exemplo.  <code>0b00000001</code> é decimal 1, e <code>0b00000001</code> -lo para a esquerda torna <code>0b00000010</code> , ou seja, 2. Se executarmos outro deslocamento para a esquerda, obtemos <code>0b00000100</code> , ou seja, 4. Outro deslocamento para a esquerda e multiplicamos por 8. Isso funcionará com qualquer por números: 5 ( <code>0b00000101</code> ) quando deslocado para a esquerda, fornece 10 ( <code>0b00001010</code> ).  Outro deslocamento à esquerda fornece 20 ( <code>0b00010100</code> ).  Uma mudança para a direita faz o mesmo, mas para a divisão. <br><br>  O 8080 não possui um comando de multiplicação, mas pode ser implementado usando esses comandos.  Se você entender como fazer isso, receberá pontos de bônus.  Uma vez que essa pergunta me foi feita em uma entrevista.  (Fiz, embora demorei alguns minutos.) <br><br>  Esses comandos giram o inversor ciclicamente e afetam apenas o sinalizador de transporte.  Aqui estão alguns comandos: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x0f</span></span>: <span class="hljs-comment"><span class="hljs-comment">//RRC { uint8_t x = state-&gt;a; state-&gt;a = ((x &amp; 1) &lt;&lt; 7) | (x &gt;&gt; 1); state-&gt;cc.cy = (1 == (x&amp;1)); } break; case 0x1f: //RAR { uint8_t x = state-&gt;a; state-&gt;a = (state-&gt;cc.cy &lt;&lt; 7) | (x &gt;&gt; 1); state-&gt;cc.cy = (1 == (x&amp;1)); } break;</span></span></code> </pre> <br><h3>  Comparação </h3><br>  A tarefa do CMP e CPI é apenas definir sinalizadores (para ramificação).  Eles fazem isso subtraindo sinalizadores, mas não armazenando o resultado. <br><br><ul><li>  Igualmente: se dois números são iguais, o sinalizador Z é definido, pois a subtração um do outro dá zero. </li><li>  Maior que: se A for maior que o valor que está sendo comparado, o sinalizador CY será apagado (já que a subtração pode ser feita sem empréstimo). </li><li>  Menor: se A for menor que o valor comparado, o sinalizador CY é definido (porque A deve concluir o empréstimo para concluir a subtração). </li></ul><br>  Existem versões desses comandos para registros, memória e valores imediatos.  A implementação é uma subtração simples sem salvar o resultado: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xfe</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CPI  { uint8_t x = state-&gt;a - opcode[1]; state-&gt;cc.z = (x == 0); state-&gt;cc.s = (0x80 == (x &amp; 0x80)); //  ,    p -   state-&gt;cc.p = parity(x, 8); state-&gt;cc.cy = (state-&gt;a &lt; opcode[1]); state-&gt;pc++; } break;</span></span></code> </pre> <br><h3>  CMC e STC </h3><br>  Eles completam o grupo lógico.  Eles são usados ​​para definir e limpar a bandeira de transporte. <br><br><h1>  Grupo de entrada-saída e comandos especiais </h1><br>  Esses comandos não podem ser atribuídos a nenhuma outra categoria.  Vou mencioná-los por completo, mas parece-me que teremos que retornar a eles novamente quando começarmos a emular o hardware dos Space Invaders. <br><br><ul><li>  EI e DI ativam ou desativam a capacidade do processador de lidar com interrupções.  Adicionei o sinalizador interrupt_enabled à estrutura de estado do processador e o configurei / redefinii usando esses comandos. </li><li>  Parece que RIM e SIM são usados ​​principalmente para E / S serial.  Se você estiver interessado, pode ler o manual, mas esses comandos não são utilizados no Space Invaders.  Eu não vou imitá-los. </li><li>  HLT é uma parada.  Acho que não precisamos imitá-lo, mas você pode chamar seu código de saída (ou sair (0)) quando vir este comando. </li><li>  IN e OUT são comandos que o equipamento do processador 8080 usa para se comunicar com equipamento externo.  Enquanto os estivermos implementando, eles não farão nada além de pular seus bytes de dados.  (Mais tarde retornaremos a eles). </li><li>  NOP é "sem operação".  Uma aplicação do NOP é controlar o tempo do painel (são necessários quatro ciclos de CPU para executar). </li></ul><br>  Outra aplicação do NOP é a modificação do código.  Digamos que precisamos alterar o código ROM do jogo.  Não podemos excluir apenas opcodes desnecessários, porque não queremos alterar todos os comandos CALL e JMP (eles estarão incorretos se pelo menos uma parte do código for movida).  Com o NOP, podemos nos livrar do código.  <em>Adicionar código é muito mais difícil!</em>  <em>Você pode adicioná-lo localizando espaço em algum lugar da ROM e alterando o comando para JMP.</em> <br><br><h1>  Grupo de pilhas </h1><br>  Já completamos a mecânica da maioria das equipes no grupo de pilhas.  Se você fez o trabalho comigo, esses comandos serão fáceis de implementar. <br><br><h3>  PUSH e POP </h3><br>  PUSH e POP funcionam apenas com pares de registradores.  PUSH grava um par de registradores na pilha, e o POP pega 2 bytes do topo da pilha e os grava em um par de registradores. <br><br>  Existem quatro opcodes para PUSH e POP, um para cada um dos pares: BC, DE, HL e PSW.  PSW é um par especial de registros de sinalizadores de unidade e códigos de status.  Aqui está a minha implementação de PUSH e POP para BC e PSW.  Não há comentários - não acho que exista algo particularmente complicado aqui. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xc1</span></span>: <span class="hljs-comment"><span class="hljs-comment">//POP B { state-&gt;c = state-&gt;memory[state-&gt;sp]; state-&gt;b = state-&gt;memory[state-&gt;sp+1]; state-&gt;sp += 2; } break; case 0xc5: //PUSH B { state-&gt;memory[state-&gt;sp-1] = state-&gt;b; state-&gt;memory[state-&gt;sp-2] = state-&gt;c; state-&gt;sp = state-&gt;sp - 2; } break; case 0xf1: //POP PSW { state-&gt;a = state-&gt;memory[state-&gt;sp+1]; uint8_t psw = state-&gt;memory[state-&gt;sp]; state-&gt;cc.z = (0x01 == (psw &amp; 0x01)); state-&gt;cc.s = (0x02 == (psw &amp; 0x02)); state-&gt;cc.p = (0x04 == (psw &amp; 0x04)); state-&gt;cc.cy = (0x05 == (psw &amp; 0x08)); state-&gt;cc.ac = (0x10 == (psw &amp; 0x10)); state-&gt;sp += 2; } break; case 0xf5: //PUSH PSW { state-&gt;memory[state-&gt;sp-1] = state-&gt;a; uint8_t psw = (state-&gt;cc.z | state-&gt;cc.s &lt;&lt; 1 | state-&gt;cc.p &lt;&lt; 2 | state-&gt;cc.cy &lt;&lt; 3 | state-&gt;cc.ac &lt;&lt; 4 ); state-&gt;memory[state-&gt;sp-2] = psw; state-&gt;sp = state-&gt;sp - 2; } break;</span></span></code> </pre> <br><h3>  SPHL e XTHL </h3><br>  Existem mais duas equipes no grupo de pilhas - SPHL e XTHL. <br><br><ul><li>  <code>SPHL</code> move o HL para o SP (forçando o SP a obter um novo endereço). </li><li>  <code>XTHL</code> troca o que está no topo da pilha pelo que está em um par de registros HL.  Por que você precisaria fazer isso?  Eu não sei </li></ul><br><h1>  Um pouco mais sobre números binários </h1><br>  Ao escrever um programa de computador, uma das decisões que você precisa tomar é escolher o tipo de dados usado para os números - se você deseja que eles sejam negativos e qual deve ser o tamanho máximo deles.  Para o emulador de CPU, precisamos do tipo de dados para corresponder ao tipo de dados da CPU de destino. <br><br><h3>  Assinado e não assinado </h3><br>  Quando começamos a falar sobre números hexadecimais, os consideramos sem sinal - ou seja, cada dígito binário do número hexadecimal tinha um valor positivo e cada um era considerado uma potência de dois (unidades, dois, quatro, etc.). <br><br>  Lidamos com a questão do armazenamento em computador de números negativos.  Se você souber que os dados em questão têm um sinal, ou seja, eles podem ser negativos, você poderá reconhecer um número negativo pelo bit mais significativo do número (bit mais significativo, MSB).  Se o tamanho dos dados for de um byte, cada número com um determinado valor de bit MSB será negativo e cada um com um MSB zero será positivo. <br><br>  O valor de um número negativo é armazenado como um código adicional.  Se temos um número assinado e o MSB é igual a um, e queremos descobrir qual é esse número, podemos convertê-lo da seguinte forma: execute “NOT” binário para números hexadecimais e adicione um. <br><br>  Por exemplo, para um número hexadecimal 0x80, o bit MSB é definido, ou seja, é negativo.  O "NÃO" binário do número 0x80 é 0x7f, ou decimal 127. 127 + 1 = 128. Ou seja, 0x80 em decimal é -128.  Segundo exemplo: 0xC5.  Não (0xC5) = 0x3A = decimal 58 +1 = decimal 59. Ou seja, 0xC5 é decimal -59. <br><br>  O que é surpreendente em números com código adicional é que podemos realizar cálculos com eles, assim como com números não assinados, e eles ainda <em>funcionarão</em> .  O computador não precisa fazer nada de especial com sinais.  Vou mostrar alguns exemplos que provam isso. <br><br><pre>  Exemplo 1<font></font>
<font></font>
      binário hexadecimal decimal    
       -3 0xFD 1111 1101    
    + 10 0x0A +0000 1010    
    ----- -----------    
        7 0x07 1 0000 0111    
                        ^ Isso é gravado no bit de transporte<font></font>
<font></font>
    Exemplo 2    <font></font>
<font></font>
      binário hexadecimal decimal    
      -59 0xC5 1100 0101    
    + 33 0x21 +0010 0001    
    ----- -----------    
      -26 0xE6 1110 0110 </pre><br><br>  No Exemplo 1, vemos que a adição de 10 e -3 resulta em 7. O resultado da adição foi transferido para que o sinalizador C. No Exemplo 2, o resultado da adição foi negativo, portanto decodificamos isso: Not (0xE6) = 0x19 = 25 + 1 = 26. <code>0xE6 = -26</code> Explosão do cérebro! <br><br>  Se você quiser, leia mais sobre o código adicional na <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Wikipedia</a> . <br><br><h3>  Tipos de dados </h3><br>  Em C, há um relacionamento entre os tipos de dados e o número de bytes usados ​​para esse tipo.  De fato, estamos interessados ​​apenas em números inteiros.  Os tipos de dados C padrão / old school são char, int e long, assim como seus amigos char não assinado, int não assinado e não assinado por muito tempo.  O problema é que, em plataformas diferentes e em compiladores diferentes, esses tipos podem ter tamanhos diferentes. <br><br>  Portanto, é melhor selecionar um tipo de dados para nossa plataforma que declare explicitamente o tamanho dos dados.  Se sua plataforma possui stdint.h, você pode usar int8_t, uint8_t, etc. <br><br>  O tamanho de um número inteiro determina o número máximo que pode ser armazenado nele.  No caso de números inteiros não assinados, você pode armazenar números de 0 a 255 em 8 bits. Se você converter em hexadecimal, será de 0x00 a 0xFF.  Como 0xFF possui “todos os bits definidos” e corresponde ao decimal 255, é completamente lógico que o intervalo de um número inteiro não assinado de byte único seja de 0 a 255.  Intervalos nos dizem que todos os tamanhos de números inteiros funcionarão exatamente da mesma maneira - os números correspondem ao número obtido quando todos os bits são definidos. <br><br><table><tbody><tr><th>  Tipo </th><th>  Intervalo </th><th>  Hex </th></tr><tr><td>  8 bits não assinado </td><td>  0-255 </td><td>  0x0-0xFF </td></tr><tr><td>  Assinado de 8 bits </td><td>  -128-127 </td><td>  0x80-0x7F </td></tr><tr><td>  16 bits não assinado </td><td>  0-65535 </td><td>  0x0-0xFFFF </td></tr><tr><td>  Assinado de 16 bits </td><td>  -32768-32767 </td><td>  0x8000-0x7FFF </td></tr><tr><td>  32 bits não assinado </td><td>  0-4294967295 </td><td>  0x0-0xFFFFFFFFFF </td></tr><tr><td>  Assinado de 32 bits </td><td>  -2147483648-2147483647 </td><td>  0x80000000-0x7FFFFFFF </td></tr></tbody></table><br>  Ainda mais interessante é que -1 em cada tipo de dado assinado é um número que possui todos os bits definidos (0xFF para byte assinado, 0xFFFF para número assinado de 16 bits e 0xFFFFFFFF para número assinado de 32 bits).  Se os dados forem considerados sem sinal, então, para todos os bits fornecidos, o número máximo possível para esse tipo de dado é obtido. <br><br>  Para emular os registros do processador, selecionamos o tipo de dados correspondente ao tamanho desse registro.  Provavelmente vale a pena selecionar tipos não assinados por padrão e convertê-los quando você precisar considerá-los assinados.  Por exemplo, usamos o tipo de dados uint8_t para representar um registro de 8 bits. <br><br><h3>  Dica: use um depurador para converter tipos de dados </h3><br>  Se o gdb estiver instalado na sua plataforma, é muito conveniente usá-lo para trabalhar com números binários.  Abaixo, mostrarei um exemplo - na sessão mostrada abaixo, as linhas que começam com # são comentários que adicionei posteriormente. <br><br> <code>#  /c,   gdb      <br> (gdb) print /c 0xFD <br> $1 = -3 '?' <br> <br> #  /x,   gdb    hex <br> #   "p"  "print" <br> (gdb) p /c 0xA <br> $2 = 10 '\n' <br> <br> #    2  " " <br> (gdb) p /c 0xC5 <br> $3 = -59 '?' <br> (gdb) p /c 0xC5+0x21 <br> $4 = -26 '?' <br> <br> #  print  ,  gdb    <br> (gdb) p 0x21 <br> $9 = 33 <br> <br> #     ,     gdb, <br> #  ,      <br> (gdb) p 0xc5 <br> $5 = 197 # <br> (gdb) p /c 0xc5 <br> $3 = -59 '?' # <br> (gdb) p 0xfd <br> $6 = 253 <br> <br> #        (   32- ) <br> (gdb) p /x -3 <br> $7 = 0xfffffffd <br> <br> #   1     <br> (gdb) print (char) 0xff <br> $1 = -1 '?' <br> #   1     <br> (gdb) print (unsigned char) 0xff <br> $2 = 255 '?'</code> <br> <br>  Quando trabalho com números hexadecimais, sempre o faço em gdb - e isso acontece quase todos os dias.  Muito mais fácil do que abrir a calculadora de um programador com uma GUI.  Nas máquinas Linux (e Mac OS X), para iniciar uma sessão de gdb, basta abrir um terminal e inserir "gdb".  Se você usar o Xcode no OS X, depois de iniciar o programa, poderá usar o console dentro do Xcode (aquele no qual a saída printf é emitida).<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> No Windows, o depurador gdb está disponível no Cygwin. </font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Terminação do emulador de CPU </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Depois de receber todas essas informações, você está pronto para uma longa jornada. </font><font style="vertical-align: inherit;">Você deve decidir como implementar o emulador - crie uma emulação 8080 completa ou implemente apenas os comandos necessários para concluir o jogo. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se você decidir fazer uma emulação completa, precisará de mais algumas ferramentas. </font><font style="vertical-align: inherit;">Vou falar sobre eles na próxima seção. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outra maneira é emular apenas as instruções usadas pelo jogo. </font><font style="vertical-align: inherit;">Continuaremos preenchendo a enorme construção de switch que criamos na seção Shell do Emulador. </font><font style="vertical-align: inherit;">Repetiremos o seguinte processo até termos um único comando não realizado:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inicie o emulador com ROM Space Invaders </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A chamada </font></font><code>UnimplementedInstruction()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sai se o comando não estiver pronto</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Emule esta instrução </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Goto 1 </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">A primeira coisa que fiz ao começar a escrever meu emulador foi adicionar código do meu desmontador. </font><font style="vertical-align: inherit;">Então, eu pude emitir um comando que deve ser executado da seguinte maneira:</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Emulate8080Op</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State8080* state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *opcode = &amp;state-&gt;memory[state-&gt;pc]; Disassemble8080Op(state-&gt;memory, state-&gt;pc); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (*opcode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>: <span class="hljs-comment"><span class="hljs-comment">//NOP /* ... */ } /*    */ printf("\tC=%d,P=%d,S=%d,Z=%d\n", state-&gt;cc.cy, state-&gt;cc.p, state-&gt;cc.s, state-&gt;cc.z); printf("\tA $%02x B $%02x C $%02x D $%02x E $%02x H $%02x L $%02x SP %04x\n", state-&gt;a, state-&gt;b, state-&gt;c, state-&gt;d, state-&gt;e, state-&gt;h, state-&gt;l, state-&gt;sp); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Também adicionei código no final para exibir todos os registros e sinalizadores de estado. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Boas notícias: para nos aprofundarmos no programa para 50 mil equipes, precisamos apenas de um subconjunto dos códigos de operação 8080. Vou até fornecer uma lista de códigos de operação que precisam ser implementados:</font></font><br><br><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Opcode </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> A equipe </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x00 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nop </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x01 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LXI B, D16 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x05 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DCR B </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x06 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI B, D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x09 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pai b </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x0d </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DCR C </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x0e </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI C, D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x0f </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rrc </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x11 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LXI D, D16 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x13 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inx d </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x19 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pai d </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x1a </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LDAX D </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x21 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LXI H, D16 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x23 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inx h </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x26 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI H, D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x29 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pai h </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x31 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LXI SP, D16 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x32 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> STA adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x36 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI M, D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x3a </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lda adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x3e </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI A, D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x56 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV D, M </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x5e </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV E, M </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x66 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV H, M </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x6f </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV L, A </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x77 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV M, A </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x7a </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV A, D </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x7b </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV A, E </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x7c </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV A, H </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x7e </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV A, M </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xa7 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ANA A </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xaf </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> XRA A </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pop b </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc2 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jnz adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jmp adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PUSH B </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc6 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ADI D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc9 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ret </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xcd </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Call adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xd1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pop d </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xd3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> OUT D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xd5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PUSH D </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xe1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pop h </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xe5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PUSH H </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xe6 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ANI D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xeb </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Xchg </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xf1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> POP PSW </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xf5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PUSH PSW </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xfb </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ei </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xfe </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CPI D8 </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Estas são apenas 50 instruções e 10 delas são movimentos que são implementados trivialmente. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Depuração </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mas tenho más notícias. </font><font style="vertical-align: inherit;">Seu emulador quase certamente não funcionará corretamente, e é muito difícil encontrar erros nesse código. </font><font style="vertical-align: inherit;">Se você souber qual comando está se comportando mal (por exemplo, uma transição ou uma chamada que vá para código sem sentido), tente corrigir o erro examinando seu código. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Além de examinar o código, há outra maneira de corrigir o problema - comparando seu emulador com um que funcione exatamente. </font><font style="vertical-align: inherit;">Assumimos que outro emulador sempre funcione corretamente, e todas as diferenças são erros no seu emulador. </font><font style="vertical-align: inherit;">Por exemplo, você pode usar meu emulador. </font><font style="vertical-align: inherit;">Você pode executá-los manualmente em paralelo. </font><font style="vertical-align: inherit;">Você pode economizar tempo se integrar meu código ao seu projeto para obter o seguinte processo:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crie um estado para o seu emulador </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Crie um estado para o meu </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Para a próxima equipe </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chamando seu emulador com seu estado </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Chamando a minha com minha fortuna </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compare nossos dois estados </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Procurando erros em quaisquer diferenças </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ir para 3 </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Outra maneira é usar manualmente </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">este site</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Este é um emulador de processador Javascript 8080 que inclui até Invasores de Espaço ROM. </font><font style="vertical-align: inherit;">Aqui está o processo:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Reinicie a emulação do Space Invaders clicando no botão Space Invaders </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pressione o botão "Executar 1" para executar o comando. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Executamos o seguinte comando em nosso emulador </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Compare o status do processador com o seu </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Se as condições coincidirem, vá para 2 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se as condições não corresponderem, sua emulação de instrução está incorreta. </font><font style="vertical-align: inherit;">Corrija-o e inicie novamente a partir da etapa 1.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu usei esse método no começo para depurar meu emulador 8080. Não vou mentir - o processo pode ser longo. Como resultado, muitos dos meus problemas acabaram sendo erros de digitação e de copiar e colar, que após a detecção foram muito fáceis de corrigir. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se você executar passo a passo seu código, a maioria das 30 mil instruções será executada em um ciclo de cerca de US $ 1a5f. Se você observar o </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">javascript</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> no </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;">emulador</font></a><font style="vertical-align: inherit;"> , poderá ver que esse código copia dados para a tela. Estou certo de que esse código é chamado com frequência. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Após a primeira renderização da tela, após 50 mil comandos, o programa fica preso nesse loop infinito:</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-number"><span class="hljs-number">0</span></span>ada LDA <span class="hljs-meta"><span class="hljs-meta">$20</span></span>c0 <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-keyword"><span class="hljs-keyword">add</span></span> ANA A <span class="hljs-number"><span class="hljs-number">0</span></span>ade JNZ <span class="hljs-meta"><span class="hljs-meta">$0</span></span>ada</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Espera até que o valor na memória em $ 20c0 mude para zero. </font><font style="vertical-align: inherit;">Como o código nesse loop não altera exatamente $ 20c0, ele deve ser um sinal de outro lugar. </font><font style="vertical-align: inherit;">É hora de falar sobre como emular o "ferro" de uma máquina de arcade. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Antes de avançarmos para a próxima seção, verifique se o emulador de CPU cai nesse loop infinito. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para referência, veja </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">minhas fontes</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Emulação 8080 completa </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Uma lição que me custou muito: não implemente equipes que você não pode testar. </font><font style="vertical-align: inherit;">Essa é uma boa regra geral para qualquer software em desenvolvimento. </font><font style="vertical-align: inherit;">Se você não checar a equipe, ela será quebrada. </font><font style="vertical-align: inherit;">E quanto mais você se afasta de sua implementação, mais difícil será encontrar problemas. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Existe outra solução se você deseja criar um emulador 8080 completo e garantir que ele funcione. </font><font style="vertical-align: inherit;">Descobri um </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">código para o 8080</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> chamado cpudiag.asm, projetado para testar cada comando do processador 8080. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Apresento esse processo depois do primeiro por vários motivos:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu queria que a descrição desse processo fosse repetida para outro processador. </font><font style="vertical-align: inherit;">Eu não acho que o análogo do cpudiag.asm exista para todos os processadores.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como você pode ver, o processo é bastante meticuloso. </font><font style="vertical-align: inherit;">Eu acho que um iniciante na depuração de código assembler terá grandes dificuldades se essas etapas não estiverem listadas.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Foi assim que usei esse teste com meu emulador. </font><font style="vertical-align: inherit;">Você pode usá-lo ou criar uma maneira melhor de integrá-lo.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Montagem de teste </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Eu tentei algumas coisas, mas como resultado, decidi usar </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esta página legal</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Colei o texto cpudiag.asm no painel esquerdo e a compilação foi concluída sem problemas. </font><font style="vertical-align: inherit;">Levei um minuto para descobrir como baixar o resultado, mas clicando no botão "Criar código bonito" no canto inferior esquerdo, baixei um arquivo chamado test.bin, que é o código 8080 compilado. Pude verificar isso usando meu desmontador. </font></font><br><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baixe cpudiag.asm</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> do espelho no meu site. </font></font><br><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baixe cpudiag.bin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (código compilado 8080) do meu site.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Carregando um teste no meu emulador </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em vez de carregar invasores. * Arquivos, eu carrego esse binário. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pequenas dificuldades surgem aqui. Primeiramente, existe uma linha no código do assembler de origem </font></font><code>ORG 00100H</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ou seja, significa que o arquivo inteiro é compilado com a suposição de que a primeira linha de código está no hexadecimal 0x100. Eu nunca tinha escrito código no assembler 8080 antes, então não sabia o que essa linha faz. Levei apenas um minuto para descobrir que todos os endereços das filiais estavam incorretos e era necessário que a memória iniciasse em 0x100. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segundo, desde que meu emulador começa do zero, primeiro devo fazer a transição para o código real. Depois de inserir o valor hexadecimal na memória no endereço zero </font></font><code>JMP $0100</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, lidei com isso. (Ou você pode apenas inicializar o PC com um valor de 0x100.)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Em terceiro lugar, encontrei um bug no código compilado. </font><font style="vertical-align: inherit;">Acho que o motivo é o processamento incorreto da última linha de código </font></font><code>STACK EQU TEMPP+256</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, mas não tenho certeza. </font><font style="vertical-align: inherit;">Seja como for, a pilha durante a compilação foi localizada em US $ 6ad, e os primeiros PUSH começaram a reescrever o código. </font><font style="vertical-align: inherit;">Sugeri que a variável também fosse deslocada em 0x100, como o restante do código, então a corrigi inserindo "0x7" na linha de código que inicializa o ponteiro da pilha. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por fim, como não implementei o DAA ou a migração auxiliar no meu emulador, modifiquei o código para ignorar essa verificação (apenas a ignoramos usando o JMP).</font></font><br><br><pre> <code class="cpp hljs"> ReadFileIntoMemoryAt(state, <span class="hljs-string"><span class="hljs-string">"/Users/kpmiller/Desktop/invaders/cpudiag.bin"</span></span>, <span class="hljs-number"><span class="hljs-number">0x100</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  ,   JMP 0x100 state-&gt;memory[0]=0xc3; state-&gt;memory[1]=0; state-&gt;memory[2]=0x01; //Fix the stack pointer from 0x6ad to 0x7ad // this 0x06 byte 112 in the code, which is // byte 112 + 0x100 = 368 in memory state-&gt;memory[368] = 0x7; //  DAA state-&gt;memory[0x59c] = 0xc3; //JMP state-&gt;memory[0x59d] = 0xc2; state-&gt;memory[0x59e] = 0x05;</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> O teste está tentando concluir </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Obviamente, este teste depende da ajuda do CP / M OS. Descobri que o CP / M tem um código de US $ 0005 que imprime mensagens no console e alterei minha emulação de CHAMADA para lidar com esse comportamento. Não sei se tudo deu certo, mas funcionou para as duas mensagens que o programa está tentando imprimir. Minha emulação CALL para executar este teste é assim:</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xcd</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CALL  #ifdef FOR_CPUDIAG if (5 == ((opcode[2] &lt;&lt; 8) | opcode[1])) { if (state-&gt;c == 9) { uint16_t offset = (state-&gt;d&lt;&lt;8) | (state-&gt;e); char *str = &amp;state-&gt;memory[offset+3]; // - while (*str != '$') printf("%c", *str++); printf("\n"); } else if (state-&gt;c == 2) { //    ,   ,    printf ("print char routine called\n"); } } else if (0 == ((opcode[2] &lt;&lt; 8) | opcode[1])) { exit(0); } else #endif { uint16_t ret = state-&gt;pc+2; state-&gt;memory[state-&gt;sp-1] = (ret &gt;&gt; 8) &amp; 0xff; state-&gt;memory[state-&gt;sp-2] = (ret &amp; 0xff); state-&gt;sp = state-&gt;sp - 2; state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; } break;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Com este teste, encontrei vários problemas no meu emulador. Não tenho certeza de quais deles estariam envolvidos no jogo, mas, se estivessem, seria muito difícil encontrá-los. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fui em frente e implementei todos os opcodes (com exceção do DAA e seus amigos). Demorei de 3 a 4 horas para resolver problemas nos meus desafios e implementar novos. Definitivamente, era mais rápido que o processo manual que descrevi acima - antes de encontrar esse teste, passei mais de 4 horas no processo manual. Se você conseguir descobrir essa explicação, recomendo usar esse método em vez de comparar manualmente. No entanto, conhecer o processo manual também é uma grande habilidade e, se você quiser emular outro processador, retorne a ele.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se você não pode executar esse processo ou parece muito complicado, definitivamente vale a pena escolher a abordagem descrita acima com dois emuladores diferentes executando dentro do seu programa. </font><font style="vertical-align: inherit;">Quando vários milhões de comandos aparecerem no programa e as interrupções forem adicionadas, será impossível comparar manualmente dois emuladores.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt418699/">https://habr.com/ru/post/pt418699/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt418687/index.html">Revolução de 3,5 ": detalhes de um pequeno boom de disquetes com vapores</a></li>
<li><a href="../pt418689/index.html">Como criar bibliotecas de componentes no Figma, economizando um orçamento, usando o exemplo de um leilão online</a></li>
<li><a href="../pt418691/index.html">Rancheiro: Kubernetes em 5 minutos em bare metal</a></li>
<li><a href="../pt418693/index.html">Por que a felicidade é tão difícil de detectar no cérebro</a></li>
<li><a href="../pt418695/index.html">Guerras antipirataria - O império contra-ataca</a></li>
<li><a href="../pt418701/index.html">Estudamos analisadores sintáticos para o idioma russo</a></li>
<li><a href="../pt418705/index.html">Futex Basics</a></li>
<li><a href="../pt418707/index.html">KDispatcher - Eventbus leve e conveniente para o uso diário</a></li>
<li><a href="../pt418709/index.html">Precisa se forçar: drivers e barreiras de interface</a></li>
<li><a href="../pt418711/index.html">Registros gerenciados por token 1.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>