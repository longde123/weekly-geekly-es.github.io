<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©üèΩ‚Äçü§ù‚Äçüë©üèº ‚öìÔ∏è üë©üèº‚Äçüç≥ Shaders de jeu 3D pour d√©butants üë®‚Äç‚öñÔ∏è üëî üë©üèø‚Äçü§ù‚Äçüë®üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vous voulez apprendre √† ajouter des textures, des √©clairages, des ombres, des cartes normales, des objets lumineux, une occlusion ambiante et d'autres...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Shaders de jeu 3D pour d√©butants</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453300/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba2/494/983/ba2494983fe869e14d259f717aa8fc19.gif" alt="image"></div><br>  Vous voulez apprendre √† ajouter des textures, des √©clairages, des ombres, des cartes normales, des objets lumineux, une occlusion ambiante et d'autres effets √† votre jeu 3D?  Super!  Cet article pr√©sente un ensemble de techniques d'ombrage qui peuvent √©lever le niveau des graphismes de votre jeu √† de nouveaux sommets.  J'explique chaque technique de telle mani√®re que vous pouvez appliquer / porter ces informations sur n'importe quelle pile d'outils, que ce soit Godot, Unity ou autre. <br><br>  Comme ¬´colle¬ª entre les shaders, j'ai d√©cid√© d'utiliser le magnifique moteur de jeu Panda3D et OpenGL Shading Language (GLSL).  Si vous utilisez la m√™me pile, vous obtiendrez un avantage suppl√©mentaire - vous apprendrez √† utiliser des techniques d'ombrage sp√©cifiquement dans Panda3D et OpenGL. <br><a name="habracut"></a><br><h2>  La pr√©paration </h2><br>  Vous trouverez ci-dessous le syst√®me que j'ai utilis√© pour d√©velopper et tester l'exemple de code. <br><br><h3>  Mercredi </h3><br>  L'exemple de code a √©t√© d√©velopp√© et test√© dans l'environnement suivant: <br><br><ul><li>  Linux manjaro 4.9.135-1-MANJARO </li><li>  Cha√Æne de rendu OpenGL: GeForce GTX 970 / PCIe / SSE2 </li><li>  Cha√Æne de version OpenGL: 4.6.0 NVIDIA 410.73 </li><li>  g ++ (GCC) 8.2.1 20180831 </li><li>  Panda3D 1.10.1-1 </li></ul><br><h3>  Mat√©riaux </h3><br>  Chacun des mat√©riaux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Blender</a> utilis√©s pour cr√©er <code>mill-scene.egg</code> a deux textures. <br><br>  La premi√®re texture est une carte normale, la seconde est une carte diffuse.  Si un objet utilise les normales de ses sommets, une carte normale ¬´bleu clair¬ª est utilis√©e.  Du fait que tous les mod√®les ont les m√™mes cartes dans les m√™mes positions, les shaders peuvent √™tre g√©n√©ralis√©s et appliqu√©s au n≈ìud racine du graphe de la sc√®ne. <br><br>  Notez que le graphique de sc√®ne est une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">fonctionnalit√© de</a> l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">impl√©mentation du</a> moteur Panda3D. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19f/9c0/14f/19f9c014f06aee0e2204aa95f87c6306.png"></div><br>  Voici une carte normale √† une couleur contenant uniquement la couleur <code>[red = 128, green = 128, blue = 255]</code> . <br><br>  Cette couleur indique l'unit√© normale, indiquant dans le sens positif de l'axe z <code>[0, 0, 1]</code> . <br><br><pre> <code class="cpp hljs">[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] = [ round((<span class="hljs-number"><span class="hljs-number">0</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * <span class="hljs-number"><span class="hljs-number">255</span></span>) , round((<span class="hljs-number"><span class="hljs-number">0</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * <span class="hljs-number"><span class="hljs-number">255</span></span>) , round((<span class="hljs-number"><span class="hljs-number">1</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * <span class="hljs-number"><span class="hljs-number">255</span></span>) ] = [<span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>] = [ round(<span class="hljs-number"><span class="hljs-number">128</span></span> / <span class="hljs-number"><span class="hljs-number">255</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) , round(<span class="hljs-number"><span class="hljs-number">128</span></span> / <span class="hljs-number"><span class="hljs-number">255</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) , round(<span class="hljs-number"><span class="hljs-number">255</span></span> / <span class="hljs-number"><span class="hljs-number">255</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) ] = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br>  Ici, nous voyons l'unit√© normale <code>[0, 0, 1]</code> convertie en bleu clair <code>[128, 128, 255]</code> , et le bleu uni converti en unit√© normale. <br><br>  Ceci est d√©crit plus en d√©tail dans la section sur les techniques normales de superposition de carte. <br><br><h3>  Panda3d </h3><br>  Dans cet exemple de code, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Panda3D est</a> utilis√© comme ¬´colle¬ª entre les shaders.  Cela n'affecte pas les techniques d√©crites ci-dessous, c'est-√†-dire que vous pouvez utiliser les informations √©tudi√©es ici dans n'importe quelle pile ou moteur de jeu s√©lectionn√©.  Panda3D offre certaines commodit√©s.  Dans l'article dont j'ai parl√©, vous pouvez soit trouver leur homologue dans votre pile, soit les recr√©er vous-m√™me s'ils ne sont pas sur la pile. <br><br>  Il convient de noter que le <code>gl-coordinate-system default</code> , <code>textures-power-2 down</code> et <code>textures-auto-power-2 1</code> ont √©t√© ajout√©s √† <code>config.prc</code> .  Ils ne sont pas contenus dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">configuration Panda3D</a> standard. <br><br>  Par d√©faut, Panda3D utilise un syst√®me de coordonn√©es droitier avec un axe z vers le haut, tandis qu'OpenGL utilise un syst√®me de coordonn√©es droitier avec un axe y vers le haut. <br><br>  <code>gl-coordinate-system default</code> vous permet de vous d√©barrasser des transformations entre deux syst√®mes de coordonn√©es √† l'int√©rieur des shaders. <br><br>  <code>textures-auto-power-2 1</code> nous permet d'utiliser des tailles de texture qui ne sont pas des puissances de deux, si le syst√®me les prend en charge. <br><br>  Cela est pratique lors de l'ex√©cution de SSAO ou de la mise en ≈ìuvre d'autres techniques dans un √©cran / fen√™tre, car la taille de l'√©cran / fen√™tre n'est g√©n√©ralement pas une puissance de deux. <br><br>  <code>textures-power-2 down</code> r√©duit la taille des textures √† une puissance de deux si le syst√®me ne prend en charge que les textures de tailles √©gales √† deux. <br><br><h2>  Exemple de code de g√©n√©ration </h2><br>  Si vous souhaitez ex√©cuter l'exemple de code, vous devez d'abord le g√©n√©rer. <br><br>  Panda3D fonctionne sur Linux, Mac et Windows. <br><br><h3>  Linux </h3><br>  Commencez par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">installer le</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">SDK Panda3D</a> pour votre distribution. <br><br>  Trouvez o√π se trouvent les en-t√™tes et les biblioth√®ques Panda3D.  Ils se trouvent tr√®s probablement dans <code>/usr/include/panda3d/</code> et dans <code>/usr/lib/panda3d/</code> . <br><br>  Ensuite, clonez ce r√©f√©rentiel et acc√©dez √† son r√©pertoire. <br><br> <code>git clone https://github.com/lettier/3d-game-shaders-for-beginners.git <br> cd 3d-game-shaders-for-beginners</code> <br> <br>  Compilez maintenant le code source dans un fichier de sortie. <br><br> <code>g++ \ <br> -c main.cxx \ <br> -o 3d-game-shaders-for-beginners.o \ <br> -std=gnu++11 \ <br> -O2 \ <br> -I/usr/include/python2.7/ \ <br> -I/usr/include/panda3d/</code> <br> <br>  Apr√®s avoir cr√©√© le fichier de sortie, cr√©ez un fichier ex√©cutable en associant le fichier de sortie √† ses d√©pendances. <br><br> <code>g++ \ <br> 3d-game-shaders-for-beginners.o \ <br> -o 3d-game-shaders-for-beginners \ <br> -L/usr/lib/panda3d \ <br> -lp3framework \ <br> -lpanda \ <br> -lpandafx \ <br> -lpandaexpress \ <br> -lp3dtoolconfig \ <br> -lp3dtool \ <br> -lp3pystub \ <br> -lp3direct \ <br> -lpthread</code> <br> <br>  Voir le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">manuel Panda3D pour</a> plus d'informations. <br><br><h3>  Mac </h3><br>  Commencez par installer le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">SDK Panda3D</a> pour Mac. <br><br>  Trouvez o√π se trouvent les en-t√™tes et les biblioth√®ques de Panda3D. <br><br>  Ensuite, clonez le r√©f√©rentiel et acc√©dez √† son r√©pertoire. <br><br> <code>git clone https://github.com/lettier/3d-game-shaders-for-beginners.git <br> cd 3d-game-shaders-for-beginners</code> <br> <br>  Compilez maintenant le code source dans un fichier de sortie.  Vous devez trouver o√π se trouvent les r√©pertoires include dans Python 2.7 et Panda3D. <br><br> <code>clang++ \ <br> -c main.cxx \ <br> -o 3d-game-shaders-for-beginners.o \ <br> -std=gnu++11 \ <br> -g \ <br> -O2 \ <br> -I/usr/include/python2.7/ \ <br> -I/Developer/Panda3D/include/</code> <br> <br>  Apr√®s avoir cr√©√© le fichier de sortie, cr√©ez un fichier ex√©cutable en associant le fichier de sortie √† ses d√©pendances. <br><br>  Vous devez trouver o√π se trouvent les biblioth√®ques Panda3D. <br><br> <code>clang++ \ <br> 3d-game-shaders-for-beginners.o \ <br> -o 3d-game-shaders-for-beginners \ <br> -L/Developer/Panda3D/lib \ <br> -lp3framework \ <br> -lpanda \ <br> -lpandafx \ <br> -lpandaexpress \ <br> -lp3dtoolconfig \ <br> -lp3dtool \ <br> -lp3pystub \ <br> -lp3direct \ <br> -lpthread</code> <br> <br>  Voir le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">manuel Panda3D pour</a> plus d'informations. <br><br><h3>  Windows </h3><br>  Commencez par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">installer le</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">SDK Panda3D</a> pour Windows. <br><br>  Trouvez o√π se trouvent les en-t√™tes et les biblioth√®ques Panda3D. <br><br>  Clonez ce r√©f√©rentiel et acc√©dez √† son r√©pertoire. <br><br> <code>git clone https://github.com/lettier/3d-game-shaders-for-beginners.git <br> cd 3d-game-shaders-for-beginners</code> <br> <br>  Voir le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">manuel Panda3D pour</a> plus d'informations. <br><br><h2>  Lancer la d√©mo </h2><br>  Apr√®s avoir cr√©√© l'exemple de code, vous pouvez ex√©cuter le fichier ex√©cutable ou la d√©mo.  C'est ainsi qu'ils fonctionnent sous Linux ou Mac. <br><br> <code>./3d-game-shaders-for-beginners</code> <br> <br>  Et donc ils fonctionnent sous Windows: <br><br> <code>3d-game-shaders-for-beginners.exe</code> <br> <br><h3>  Contr√¥le clavier </h3><br>  La d√©mo dispose d'un contr√¥le au clavier qui vous permet de d√©placer la cam√©ra et de changer l'√©tat de divers effets. <br><br><h3>  Mouvement </h3><br><ul><li>  <code>w</code> - p√©n√©trer profond√©ment dans la sc√®ne. </li><li>  <code>a</code> - faites pivoter la sc√®ne dans le sens des aiguilles d'une montre. </li><li>  <code>s</code> - √©loignez-vous de la sc√®ne. </li><li>  <code>d</code> - faire pivoter la sc√®ne dans le sens antihoraire. </li></ul><br><h3>  Effets commutables </h3><br><ul><li>  <code>y</code> - activer SSAO. </li><li>  <code>Shift</code> + <code>y</code> - d√©sactiver SSAO. </li><li>  <code>u</code> - inclusion de circuits. </li><li>  <code>Shift</code> + <code>u</code> - d√©sactiver les contours. </li><li>  <code>i</code> - activer la floraison. </li><li>  <code>Shift</code> + <code>i</code> - d√©sactiver la floraison. </li><li>  <code>o</code> - activer les cartes normales. </li><li>  <code>Shift</code> + <code>o</code> - d√©sactiver les cartes normales. </li><li>  <code>p</code> - inclusion de brouillard. </li><li>  <code>Shift</code> + <code>p</code> - d√©sactiver le brouillard. </li><li>  <code>h</code> - l'inclusion de la profondeur de champ. </li><li>  <code>Shift</code> + <code>h</code> - d√©sactiver la profondeur de champ. </li><li>  <code>j</code> - activer la post√©risation. </li><li>  <code>Shift</code> + <code>j</code> - d√©sactiver la post√©risation </li><li>  <code>k</code> - activer la pixellisation. </li><li>  <code>Shift</code> + <code>k</code> - d√©sactiver la pixelisation. </li><li>  <code>l</code> - aff√ªtage. </li><li>  <code>Shift</code> + <code>l</code> - d√©sactiver la nettet√©. </li><li>  <code>n</code> inclusion de grain de film. </li><li>  <code>Shift</code> + <code>n</code> - d√©sactive le grain du film. </li></ul><br><h2>  Syst√®me de r√©f√©rence </h2><br>  Avant de commencer √† √©crire des shaders, vous devez vous familiariser avec les syst√®mes de r√©f√©rence ou syst√®mes de coordonn√©es suivants.  Tous se r√©sument √† la provenance des coordonn√©es actuelles de l'origine de la r√©f√©rence <code>(0, 0, 0)</code> .  D√®s que nous le d√©couvrons, nous pouvons les transformer en utilisant une sorte de matrice ou un autre espace vectoriel.  En r√®gle g√©n√©rale, si la sortie d'un shader ne semble pas correcte, la cause est la confusion des syst√®mes de coordonn√©es. <br><br><h3>  Mod√®le </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e06/9ce/863/e069ce863ffc7bd3b94394dc20b25687.gif"></div><br>  Le syst√®me de coordonn√©es du mod√®le ou de l'objet est relatif √† l'origine du mod√®le.  Dans les programmes de mod√©lisation tridimensionnelle, par exemple, dans Blender, il est g√©n√©ralement plac√© au centre du mod√®le. <br><br><h3>  Le monde </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0a/9de/1f7/d0a9de1f741bb90174efd93d174ef1f9.gif"></div><br>  L'espace mondial est relatif √† l'origine de la sc√®ne / niveau / univers que vous avez cr√©√©. <br><br><h3>  Revue </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd2/15b/b6e/bd215bb6ee79a6904eba3f6ad4ff56d3.gif"></div><br>  L'espace de coordonn√©es de la vue est relatif √† la position de la cam√©ra active. <br><br><h3>  Coupure </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d77/505/a34/d77505a349f37a695f77625400857d58.png"></div><br>  Espace de d√©tourage par rapport au centre du cadre de la cam√©ra.  Toutes les coordonn√©es sont homog√®nes et sont dans l'intervalle <code>(-1, 1)</code> .  X et y sont parall√®les au film de la cam√©ra et la coordonn√©e z est la profondeur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc7/0be/d7c/dc70bed7ca78c39cc9f538b127d7176e.gif"></div><br>  Tous les sommets qui ne se trouvent pas dans les limites de la pyramide de visibilit√© ou du volume de visibilit√© de la cam√©ra sont coup√©s ou supprim√©s.  Nous voyons comment cela se produit avec un cube tronqu√© derri√®re par le plan √©loign√© de la cam√©ra, et avec un cube situ√© sur le c√¥t√©. <br><br><h3>  √âcran </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5b/47d/336/e5b47d33660b9c1744faa12fec8ef256.png"></div><br>  L'espace d'√©cran est (g√©n√©ralement) relatif au coin inf√©rieur gauche de l'√©cran.  X passe de z√©ro √† la largeur de l'√©cran.  Y passe de z√©ro √† la hauteur de l'√©cran. <br><br><h2>  GLSL </h2><br>  Au lieu de travailler avec un pipeline de fonctions fixes, nous utiliserons un pipeline de rendu GPU programmable.  Puisqu'il est programmable, nous devons lui-m√™me lui passer le code du programme sous forme de shaders.  Un shader est un programme (g√©n√©ralement petit) cr√©√© avec une syntaxe ressemblant au langage C. Un pipeline de rendu GPU programmable se compose de diff√©rentes √©tapes qui peuvent √™tre programm√©es √† l'aide de shaders.  Diff√©rents types de shaders comprennent les vertex shaders, les tessellation shaders, les shaders g√©om√©triques, fragmentaires et informatiques.  Pour utiliser les techniques d√©crites dans l'article, il nous suffit d'utiliser vertex et fragment <br>  √©tapes. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 void main() {}</span></span></code> </pre> <br>  Voici le shader GLSL minimal, compos√© du num√©ro de version GLSL et de la fonction principale. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform mat4 p3d_ModelViewProjectionMatrix; in vec4 p3d_Vertex; void main() { gl_Position = p3d_ModelViewProjectionMatrix * p3d_Vertex; }</span></span></code> </pre> <br>  Voici le vertex shader GLSL tronqu√©, qui transforme le sommet d'entr√©e en espace de d√©coupage et affiche cette nouvelle position comme une position de sommet uniforme. <br><br>  La proc√©dure <code>main</code> ne renvoie rien, car elle est <code>void</code> , et la variable <code>gl_Position</code> est la sortie en ligne. <br><br>  Deux mots cl√©s m√©ritent d'√™tre mentionn√©s: <code>uniform</code> et <code>in</code> . <br><br>  Le mot-cl√© <code>uniform</code> signifie que cette variable globale est la m√™me pour tous les sommets.  Panda3D d√©finit lui-m√™me <code>p3d_ModelViewProjectionMatrix</code> et pour chaque sommet, il s'agit de la m√™me matrice. <br><br>  Le mot cl√© <code>in</code> signifie que cette variable globale est pass√©e au shader.  Un vertex shader obtient chaque vertex compos√© de la g√©om√©trie, auquel un vertex shader est attach√©. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 out vec4 fragColor; void main() { fragColor = vec4(0, 1, 0, 1); }</span></span></code> </pre> <br>  Voici le shader de fragment GLSL d√©coup√©, affichant le vert opaque comme couleur du fragment. <br><br>  N'oubliez pas qu'un fragment n'affecte qu'un seul pixel d'√©cran, mais plusieurs fragments peuvent affecter un pixel. <br><br>  Faites attention au mot cl√© out. <br><br>  Le mot cl√© <code>out</code> signifie que cette variable globale est d√©finie par le shader. <br><br>  Le nom <code>fragColor</code> facultatif, vous pouvez donc en choisir un autre. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b4/276/b2d/8b4276b2d7e735cc05484e80e0c046e8.gif"></div><br>  Voici la sortie des deux shaders illustr√©s ci-dessus. <br><br><h2>  Rendu de texture </h2><br>  Au lieu de rendre / dessiner directement sur l'√©cran, l'exemple de code utilise une technique pour <br>  le nom "rendu en texture" (rendu en texture).  Pour effectuer un rendu sur une texture, vous devez configurer le tampon d'image et y lier la texture.  Vous pouvez lier plusieurs textures √† un seul tampon d'image. <br><br>  Les textures li√©es au tampon de trame stockent les vecteurs renvoy√©s par le fragment shader.  Habituellement, ces vecteurs sont des vecteurs de couleur <code>(r, g, b, a)</code> , mais ils peuvent √™tre des positions ou des vecteurs normaux <code>(x, y, z, w)</code> .  Pour chaque texture li√©e, un ombrage de fragment peut g√©n√©rer un vecteur distinct.  Par exemple, on peut d√©duire en un seul passage la position et la normale du sommet. <br><br>  La majeure partie de l'exemple de code qui fonctionne avec Panda3D est li√©e √† la d√©finition <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">des textures de tampon de trame</a> .  Pour simplifier les choses, chaque fragment de shader dans l'exemple de code n'a qu'une seule sortie.  Cependant, pour garantir une fr√©quence d'images √©lev√©e (FPS), nous devons produire autant d'informations que possible √† chaque passage de rendu. <br><br>  Voici deux structures de texture pour le tampon de trame de l'exemple de code. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ac9/d2b/d50/ac9d2bd50cd1c0bc991ffe7569bf5432.gif"></div><br>  La premi√®re structure transforme une sc√®ne de moulin √† eau en une texture de tampon de trame √† l'aide d'une vari√©t√© de vertex et de shaders de fragments.  Cette structure passe par chacun des sommets de la sc√®ne avec le moulin et le long des fragments correspondants. <br><br>  Dans cette structure, l'exemple de code fonctionne comme suit. <br><br><ul><li>  Enregistre les donn√©es de g√©om√©trie (par exemple, la position ou le sommet normal) pour une utilisation future. </li><li>  Enregistre les donn√©es de mat√©riau (par exemple, couleur diffuse) pour une utilisation future. </li><li>  Cr√©e une liaison UV de diff√©rentes textures (diffuses, normales, ombr√©es, etc.). </li><li>  Calcule l'√©clairage ambiant, diffus, r√©fl√©chi et √©mis. </li><li>  Rend le brouillard. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e5/554/0c2/7e55540c20fe190246f3180b3f06a731.png"></div><br>  La deuxi√®me structure est une cam√©ra orthogonale visant un rectangle en forme d'√©cran. <br>  Cette structure ne traverse que quatre pics et leurs fragments correspondants. <br><br>  Dans la deuxi√®me structure, l'exemple de code effectue les actions suivantes: <br><br><ul><li>  Traite la sortie d'une autre texture de tampon de trame. </li><li>  Combine diff√©rentes textures de tampon de trame en une seule. </li></ul><br>  Dans l'exemple de code, nous pouvons voir la sortie d'une texture de tampon d'image, d√©finissant l'image correspondante sur true et false sur toutes les autres. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... bool showPositionBuffer = false; bool showNormalBuffer = false; bool showSsaoBuffer = false; bool showSsaoBlurBuffer = false; bool showMaterialDiffuseBuffer = false; bool showOutlineBuffer = false; bool showBaseBuffer = false; bool showSharpenBuffer = false; bool showBloomBuffer = false; bool showCombineBuffer = false; bool showCombineBlurBuffer = false; bool showDepthOfFieldBuffer = false; bool showPosterizeBuffer = false; bool showPixelizeBuffer = false; bool showFilmGrainBuffer = true; // ...</span></span></code> </pre> <br><h2>  Texturation </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d1c/0eb/1c6/d1c0eb1c650b9b05e2372b33259ed8a6.gif"></div><br>  La texturation est la liaison d'une couleur ou d'un autre vecteur √† un fragment en utilisant les coordonn√©es UV.  Les valeurs de U et V varient de z√©ro √† un.  Chaque sommet re√ßoit une coordonn√©e UV et elle est affich√©e dans le vertex shader. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/519/487/fee/519487fee2bb16357b225ce32649fb91.png"></div><br>  Le fragment shader obtient la coordonn√©e UV interpol√©e.  L'interpolation signifie que la coordonn√©e UV du fragment se situe quelque part entre les coordonn√©es UV des sommets qui composent la face du triangle. <br><br><h3>  Vertex shader </h3><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform mat4 p3d_ModelViewProjectionMatrix; in vec2 p3d_MultiTexCoord0; in vec4 p3d_Vertex; out vec2 texCoord; void main() { texCoord = p3d_MultiTexCoord0; gl_Position = p3d_ModelViewProjectionMatrix * p3d_Vertex; }</span></span></code> </pre> <br>  Ici, nous voyons que le vertex shader d√©livre les coordonn√©es de la texture au fragment shader.  Notez qu'il s'agit d'un vecteur √† deux dimensions: une valeur pour U et une pour V. <br><br><h3>  Shader de fragment </h3><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform sampler2D p3d_Texture0; in vec2 texCoord; out vec2 fragColor; void main() { texColor = texture(p3d_Texture0, texCoord); fragColor = texColor; }</span></span></code> </pre> <br>  Ici, nous voyons que le shader de fragment recherche la couleur dans sa coordonn√©e UV et l'affiche comme la couleur du fragment. <br><br><h4>  Texture de remplissage d'√©cran </h4><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform sampler2D screenSizedTexture; out vec2 fragColor; void main() { vec2 texSize = textureSize(texture, 0).xy; vec2 texCoord = gl_FragCoord.xy / texSize; texColor = texture(screenSizedTexture, texCoord); fragColor = texColor; }</span></span></code> </pre> <br>  Lors du rendu d'une texture, le maillage est un rectangle plat avec le m√™me rapport hauteur / largeur que l'√©cran.  Par cons√©quent, nous pouvons calculer les coordonn√©es UV, en ne connaissant que <br><br>  A) la largeur et la hauteur de la texture avec la taille de l'√©cran superpos√©e au rectangle en utilisant les coordonn√©es UV, et <br>  B) les coordonn√©es x et y du fragment. <br><br>  Pour lier x √† U, vous devez diviser x par la largeur de la texture entrante.  De m√™me, pour lier y √† V, vous devez diviser y par la hauteur de la texture entrante.  Vous verrez que cette technique est utilis√©e dans l'exemple de code. <br><br><h2>  Eclairage </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f98/05e/0ca/f9805e0ca9717c961dd9618f49475381.gif"></div><br>  Pour d√©terminer l'√©clairage, il est n√©cessaire de calculer et de combiner les aspects de l'√©clairage ambiant, diffus, r√©fl√©chi et √©mis.  L'exemple de code utilise l'√©clairage Phong. <br><br><h3>  Vertex shader </h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform struct p3d_LightSourceParameters { vec4 color ; vec4 ambient ; vec4 diffuse ; vec4 specular ; vec4 position ; vec3 spotDirection ; float spotExponent ; float spotCutoff ; float spotCosCutoff ; float constantAttenuation ; float linearAttenuation ; float quadraticAttenuation ; vec3 attenuation ; sampler2DShadow shadowMap ; mat4 shadowViewMatrix ; } p3d_LightSource[NUMBER_OF_LIGHTS]; // ...</span></span></code> </pre><br>  Pour chaque source de lumi√®re, √† l'exception de la lumi√®re ambiante, Panda3D nous fournit une structure pratique qui est disponible pour les vertex et les shaders de fragments.  La chose la plus pratique est une carte d'ombres et une matrice pour visualiser les ombres afin de convertir les sommets en un espace d'ombres ou d'√©clairage. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vertexPosition = p3d_ModelViewMatrix * p3d_Vertex; // ... for (int i = 0; i &lt; p3d_LightSource.length(); ++i) { vertexInShadowSpaces[i] = p3d_LightSource[i].shadowViewMatrix * vertexPosition; } // ...</span></span></code> </pre> <br>  En commen√ßant par le vertex shader, nous devons transformer et supprimer le sommet de l'espace de visualisation en ombre ou espace d'√©clairage pour chaque source de lumi√®re dans la sc√®ne.  Cela sera utile √† l'avenir pour que le fragment shader rende les ombres.  Un espace d'ombre ou d'√©clairage est un espace dans lequel chaque coordonn√©e est relative √† la position de la source lumineuse (l'origine est la source lumineuse). <br><br><h3>  Shader de fragment </h3><br>  Le fragment shader fait la majeure partie du calcul d'√©clairage. <br><br><h4>  Mati√®re </h4><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform struct { vec4 ambient ; vec4 diffuse ; vec4 emission ; vec3 specular ; float shininess ; } p3d_Material; // ...</span></span></code> </pre> <br>  Panda3D nous fournit du mat√©riel (sous la forme d'une structure) pour le maillage ou le mod√®le que nous rendons actuellement. <br><br><h4>  Sources d'√©clairage multiples </h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 diffuseSpecular = vec4(0.0, 0.0, 0.0, 0.0); // ...</span></span></code> </pre> <br>  Avant de faire le tour des sources d'√©clairage de la sc√®ne, nous allons cr√©er un lecteur qui contiendra √† la fois des couleurs diffuses et r√©fl√©chies. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... for (int i = 0; i &lt; p3d_LightSource.length(); ++i) { // ... } // ...</span></span></code> </pre> <br>  Nous pouvons maintenant faire le tour des sources lumineuses dans un cycle, en calculant les couleurs diffuses et r√©fl√©chies pour chacune. <br><br><h4>  Vecteurs li√©s √† l'√©clairage </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/307/035/ce7/307035ce7bf5a52b8f25c7aeb862b9d4.gif"></div><br>  Voici quatre vecteurs de base n√©cessaires pour calculer les couleurs diffuses et r√©fl√©chies introduites par chaque source de lumi√®re.  Le vecteur de direction d'√©clairage est une fl√®che bleue pointant vers la source de lumi√®re.  Le vecteur normal est une fl√®che verte pointant verticalement vers le haut.  Le vecteur de r√©flexion est une fl√®che bleue qui refl√®te le vecteur de direction de la lumi√®re.  Le vecteur ≈ìil ou vue est la fl√®che orange pointant vers la cam√©ra. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 lightDirection = p3d_LightSource[i].position.xyz - vertexPosition.xyz * p3d_LightSource[i].position.w; // ...</span></span></code> </pre> <br>  La direction de l'√©clairage est le vecteur de la position du sommet √† la position de la source lumineuse. <br><br>  S'il s'agit d'un √©clairage directionnel, Panda3D met <code>p3d_LightSource[i].position.w</code> z√©ro <code>p3d_LightSource[i].position.w</code> .  L'√©clairage directionnel n'a pas de position, seulement une direction.  Par cons√©quent, s'il s'agit d'un √©clairage directionnel, la direction de l'√©clairage sera une direction n√©gative ou oppos√©e √† la source, car pour l'√©clairage directionnel, Panda3D d√©finit <code>p3d_LightSource[i].position.xyz</code> sur <code>-direction</code> . <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... normal = normalize(vertexNormal); // ...</span></span></code> </pre> <br>  La normale au sommet doit √™tre un vecteur unitaire.  Les vecteurs unitaires ont une valeur √©gale √† un. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 unitLightDirection = normalize(lightDirection); vec3 eyeDirection = normalize(-vertexPosition.xyz); vec3 reflectedDirection = normalize(-reflect(unitLightDirection, normal)); // ...</span></span></code> </pre> <br>  Ensuite, nous avons besoin de trois vecteurs suppl√©mentaires. <br><br>  Nous avons besoin d'un produit scalaire avec la participation de la direction d'√©clairage, il est donc pr√©f√©rable de le normaliser.  Cela nous donne une distance ou une magnitude √©gale √† l'unit√© (vecteur unitaire). <br><br>  La direction de vue est oppos√©e √† la position du sommet / fragment, car la position du sommet / fragment est relative √† la position de la cam√©ra.  N'oubliez pas que la position du sommet / fragment est dans l'espace de visualisation.  Par cons√©quent, au lieu de passer de la cam√©ra (≈ìil) au sommet / fragment, nous passons du sommet / fragment √† la cam√©ra (≈ìil). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Le vecteur de r√©flexion</a> est une r√©flexion de la direction d'√©clairage normale √† la surface.  Lorsque le "rayon" de lumi√®re touche la surface, il se refl√®te sous le m√™me angle auquel il est tomb√©.  L'angle entre le vecteur de direction de l'illumination et la normale est appel√© "angle d'incidence".  L'angle entre le vecteur de r√©flexion et la normale est appel√© "angle de r√©flexion". <br><br>  Vous devez changer le signe du vecteur de lumi√®re r√©fl√©chie, car il doit pointer dans la m√™me direction que le vecteur de l'≈ìil.  N'oubliez pas que la direction de l'≈ìil va du haut / fragment √† la position de la cam√©ra.  Nous utiliserons le vecteur de r√©flexion pour calculer la luminosit√© de la lumi√®re r√©fl√©chie. <br><br><h4>  √âclairage diffus </h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float diffuseIntensity = max(dot(normal, unitLightDirection), 0.0); if (diffuseIntensity &gt; 0) { // ... } // ...</span></span></code> </pre> <br>  La luminosit√© de l'√©clairage diffus est le produit scalaire de la normale √† la surface et de la direction d'√©clairage d'un vecteur unique.  Le produit scalaire peut aller de moins un √† un.  Si les deux vecteurs pointent dans la m√™me direction, alors la luminosit√© est l'unit√©.  Dans tous les autres cas, ce sera inf√©rieur √† l'unit√©. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/168/5bc/5e7/1685bc5e759e638b5c2bcc4a6c56bbd3.gif"></div><br>  Si le vecteur d'√©clairage se rapproche de la m√™me direction que la normale, alors la luminosit√© de l'√©clairage diffus tend √† l'unit√©. <br><br>  Si la luminosit√© de l'√©clairage diffus est inf√©rieure ou √©gale √† z√©ro, vous devez passer √† la source de lumi√®re suivante. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 diffuse = vec4 ( clamp ( diffuseTex.rgb * p3d_LightSource[i].diffuse.rgb * diffuseIntensity , 0 , 1 ) , 1 ); diffuse.r = clamp(diffuse.r, 0, diffuseTex.r); diffuse.g = clamp(diffuse.g, 0, diffuseTex.g); diffuse.b = clamp(diffuse.b, 0, diffuseTex.b); // ...</span></span></code> </pre> <br>  Nous pouvons maintenant calculer la couleur diffuse introduite par cette source.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la luminosit√© de l'√©clairage diffus est √©gale √† l'unit√©, alors la couleur diffuse sera un m√©lange de la couleur de la texture diffuse et de la couleur de l'√©clairage. </font><font style="vertical-align: inherit;">√Ä toute autre luminosit√©, la couleur diffuse sera plus sombre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notez que je limite la couleur diffuse afin qu'elle ne soit pas plus lumineuse que la couleur de la texture diffuse. </font><font style="vertical-align: inherit;">Cela √©vitera une surexposition de la sc√®ne.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lumi√®re r√©fl√©chie </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Apr√®s un √©clairage diffus, la r√©flexion est calcul√©e. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/989/ade/77c/989ade77c01b7137f437f97fe83ccd17.gif"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 specular = clamp ( vec4(p3d_Material.specular, 1) * p3d_LightSource[i].specular * pow ( max(dot(reflectedDirection, eyeDirection), 0) , p3d_Material.shininess ) , 0 , 1 ); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La luminosit√© de la lumi√®re r√©fl√©chie est le produit scalaire entre le vecteur ≈ìil et le vecteur r√©flexion. </font><font style="vertical-align: inherit;">Comme dans le cas de la luminosit√© d'un √©clairage diffus, si deux vecteurs pointent dans la m√™me direction, alors la luminosit√© de l'√©clairage r√©fl√©chi est √©gale √† l'unit√©. </font><font style="vertical-align: inherit;">Toute autre luminosit√© r√©duira la quantit√© de couleur r√©fl√©chie introduite par cette source de lumi√®re.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2e/046/570/c2e046570e770e1804544d6ae67ae2f8.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le lustre du mat√©riau d√©termine la quantit√© de diffusion de la lumi√®re r√©fl√©chie. </font><font style="vertical-align: inherit;">Il est g√©n√©ralement d√©fini dans un programme de simulation, par exemple dans Blender. </font><font style="vertical-align: inherit;">Dans Blender, on parle de duret√© sp√©culaire.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Projecteurs </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float unitLightDirectionDelta = dot ( normalize(p3d_LightSource[i].spotDirection) , -unitLightDirection ); if (unitLightDirectionDelta &gt;= p3d_LightSource[i].spotCosCutoff) { // ... } // ... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce code ne permet pas √† l'√©clairage d'affecter les fragments √† l'ext√©rieur du c√¥ne ou de la pyramide du projecteur. </font><font style="vertical-align: inherit;">Heureusement, Panda3D peut </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d√©finir</font></font></a> <code>spotDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><code>spotCosCutoff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">travailler avec des </font><font style="vertical-align: inherit;">lumi√®res directionnelles et ponctuelles. </font><font style="vertical-align: inherit;">Les projecteurs ont √† la fois une position et une direction. </font><font style="vertical-align: inherit;">Cependant, l'√©clairage directionnel n'a qu'une direction et les sources ponctuelles n'ont qu'une position. </font><font style="vertical-align: inherit;">Cependant, ce code fonctionne pour les trois types d'√©clairage sans qu'il soit n√©cessaire de confondre les instructions if.</font></font><br><br><pre> <code class="cpp hljs">spotCosCutoff = cosine(<span class="hljs-number"><span class="hljs-number">0.5</span></span> * spotlightLensFovAngle);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si dans le cas d'un √©clairage de projection, le produit scalaire du vecteur "fragment-source d'√©clairage" et du vecteur de direction du projecteur est inf√©rieur au cosinus de la moiti√© de l'angle du champ de vision du </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">projecteur, le shader ne prend pas en compte l'influence de cette source. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notez que vous devez changer le signe </font></font><code>unitLightDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>unitLightDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">va du fragment au projecteur, et nous devons passer du projecteur au fragment, car il </font></font><code>spotDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">va directement au centre de la pyramide du projecteur √† une certaine distance de la position du projecteur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le cas d'un √©clairage directionnel et ponctuel, Panda3D d√©finit la </font></font><code>spotCosCutoff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valeur sur -1. Rappelons que le produit scalaire varie dans la plage de -1 √† 1. Par cons√©quent, peu importe ce qu'il sera </font></font><code>unitLightDirectionDelta</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, car il est toujours sup√©rieur ou √©gal √† -1.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... diffuse *= pow(unitLightDirectionDelta, p3d_LightSource[i].spotExponent); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme le code </font></font><code>unitLightDirectionDelta</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ce code fonctionne √©galement pour les trois types de sources lumineuses. </font><font style="vertical-align: inherit;">Dans le cas des projecteurs, il rendra les fragments plus brillants √† l'approche du centre de la pyramide des projecteurs. </font><font style="vertical-align: inherit;">Pour les sources de lumi√®re directionnelles et ponctuelles, la valeur </font></font><code>spotExponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est nulle. </font><font style="vertical-align: inherit;">Rappelons que toute valeur √† la puissance de z√©ro est √©gale √† l'unit√©, de sorte que la couleur diffuse est √©gale √† elle-m√™me, multipli√©e par un, c'est-√†-dire qu'elle ne change pas.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ombres </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float shadow = textureProj ( p3d_LightSource[i].shadowMap , vertexInShadowSpaces[i] ); diffuse.rgb *= shadow; specular.rgb *= shadow; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panda3D simplifie l'utilisation des ombres car il cr√©e une carte des ombres et une matrice de transformation des ombres pour chaque source de lumi√®re dans la sc√®ne. Pour cr√©er vous-m√™me une matrice de transformation, vous devez collecter une matrice qui convertit les coordonn√©es de l'espace de visualisation en espace d'√©clairage (les coordonn√©es sont relatives √† la position de la source lumineuse). Pour cr√©er vous-m√™me une carte d'ombre, vous devez rendre la sc√®ne du point de vue de la source de lumi√®re dans la texture du tampon d'image. La texture du tampon de trame doit contenir la distance entre la source de lumi√®re et les fragments. C'est ce qu'on appelle une ¬´carte de profondeur¬ª. Enfin, vous devez transf√©rer manuellement vers le shader votre carte de profondeur maison en tant que </font></font><code>uniform sampler2DShadow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et la matrice de transformation d'ombre en tant que </font></font><code>uniform mat4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Nous allons donc recr√©er ce que Panda3D fait automatiquement pour nous.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'extrait de code illustr√© est utilis√© </font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ce qui est diff√©rent de la fonction indiqu√©e ci-dessus </font></font><code>texture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">divise d'abord </font></font><code>vertexInShadowSpaces[i].xyz</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par </font></font><code>vertexInShadowSpaces[i].w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Elle l'utilise ensuite </font></font><code>vertexInShadowSpaces[i].xy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour trouver la profondeur stock√©e dans la carte d'ombre. Ensuite, elle utilise </font></font><code>vertexInShadowSpaces[i].z</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour comparer la profondeur du haut avec la profondeur de la carte d'ombre dans </font></font><code>vertexInShadowSpaces[i].xy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Si la comparaison r√©ussit, elle en </font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">renvoie un. Sinon, il renvoie z√©ro. Z√©ro signifie que ce sommet / fragment est dans l'ombre et un signifie que le sommet / fragment n'est pas dans l'ombre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notez </font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qu'il peut √©galement renvoyer une valeur de z√©ro √† un, selon la configuration de la carte fant√¥me. Dans cet exemple</font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Effectue plusieurs tests de profondeur bas√©s sur des profondeurs adjacentes et renvoie une moyenne pond√©r√©e. </font><font style="vertical-align: inherit;">Cette moyenne pond√©r√©e peut donner de la douceur aux ombres.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Att√©nuation </font></font></h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/381/e8d/bfb/381e8dbfb118dac85b139d0c1ec41bad.png"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float lightDistance = length(lightDirection); float attenuation = 1 / ( p3d_LightSource[i].constantAttenuation + p3d_LightSource[i].linearAttenuation * lightDistance + p3d_LightSource[i].quadraticAttenuation * (lightDistance * lightDistance) ); diffuse.rgb *= attenuation; specular.rgb *= attenuation; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La distance √† la source lumineuse est simplement la grandeur ou la longueur du vecteur de direction d'√©clairage. </font><font style="vertical-align: inherit;">Notez que nous n'utilisons pas la direction d'√©clairement normalis√©e, car une telle distance serait √©gale √† l'unit√©. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La distance √† la source lumineuse est n√©cessaire pour calculer l'att√©nuation. </font><font style="vertical-align: inherit;">L'att√©nuation signifie que l'effet de la lumi√®re loin de la source diminue. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Param√®tres </font></font><code>constantAttenuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>linearAttenuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>quadraticAttenuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vous pouvez d√©finir toutes les valeurs. </font><font style="vertical-align: inherit;">Cela vaut la peine de commencer par </font></font><code>constantAttenuation = 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>linearAttenuation = 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>quadraticAttenuation = 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Avec de tels param√®tres, la position de la source lumineuse est √©gale √† l'unit√© et tend √† z√©ro en s'√©loignant d'elle.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> √âclairage couleur final </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... diffuseSpecular += (diffuse + specular); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour calculer la couleur finale de l'√©clairage, vous devez ajouter la couleur diffuse et r√©fl√©chie. </font><font style="vertical-align: inherit;">Il est n√©cessaire d'ajouter cela au lecteur dans un cycle de contournement des sources lumineuses dans la sc√®ne.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ambiant </font></font></h4><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform sampler2D p3d_Texture1; // ... uniform struct { vec4 ambient ; } p3d_LightModel; // ... in vec2 diffuseCoord; // ... vec4 diffuseTex = texture(p3d_Texture1, diffuseCoord); // ... vec4 ambient = p3d_Material.ambient * p3d_LightModel.ambient * diffuseTex; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le composant d'√©clairage ambiant dans le mod√®le d'√©clairage est bas√© sur la couleur ambiante du mat√©riau, la couleur de l'√©clairage ambiant et la couleur de la texture diffuse. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il ne doit jamais y avoir plus d'une source de lumi√®re ambiante, ce calcul ne doit donc √™tre effectu√© qu'une seule fois, contrairement aux calculs des couleurs diffuses et r√©fl√©chies accumul√©es pour chaque source de lumi√®re. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Veuillez noter que la couleur de la lumi√®re ambiante est utile lors de l'ex√©cution de SSAO.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tout mettre ensemble </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 outputColor = ambient + diffuseSpecular + p3d_Material.emission; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La couleur finale est la somme de la couleur ambiante, de la couleur diffuse, de la couleur r√©fl√©chie et de la couleur √©mise. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code source </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.frag</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cartes normales </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d1/6bb/9de/6d16bb9deae1520429083896b7492a3f.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'utilisation de cartes normales vous permet d'ajouter de nouvelles pi√®ces √† la surface sans g√©om√©trie suppl√©mentaire. </font><font style="vertical-align: inherit;">En r√®gle g√©n√©rale, lorsque vous travaillez dans un programme de mod√©lisation 3D, des versions haute et basse poly du maillage sont cr√©√©es. </font><font style="vertical-align: inherit;">Ensuite, les normales des sommets du maillage poly √©lev√© sont prises et int√©gr√©es dans la texture. </font><font style="vertical-align: inherit;">Cette texture est une carte normale. </font><font style="vertical-align: inherit;">Ensuite, √† l'int√©rieur du shader de fragment, nous rempla√ßons les normales des sommets du maillage poly faible par les normales du maillage poly √©lev√© cuites dans la carte normale. </font><font style="vertical-align: inherit;">Pour cette raison, lors de l'√©clairage d'un maillage, il semblera qu'il a plus de polygones qu'il ne l'est r√©ellement. </font><font style="vertical-align: inherit;">Cela vous permet de maintenir un FPS √©lev√©, tout en transmettant la plupart des d√©tails de la version haute poly.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e1/92b/4ae/8e192b4ae48d96a65b92456ba640c7d0.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ici, nous voyons la transition d'un mod√®le poly √©lev√© √† un mod√®le poly faible, puis √† un mod√®le poly faible avec une carte normale superpos√©e. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/987/20d/ee1/98720dee1f77246721e1905abf2ebea4.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, n'oubliez pas que superposer une carte normale n'est qu'une illusion. </font><font style="vertical-align: inherit;">Sous un certain angle, la surface redevient plate.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vertex shader </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform mat3 p3d_NormalMatrix; // ... in vec3 p3d_Normal; // ... in vec3 p3d_Binormal; in vec3 p3d_Tangent; // ... vertexNormal = normalize(p3d_NormalMatrix * p3d_Normal); binormal = normalize(p3d_NormalMatrix * p3d_Binormal); tangent = normalize(p3d_NormalMatrix * p3d_Tangent); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En commen√ßant par le vertex shader, nous devons sortir le vecteur normal, le vecteur binormal et le vecteur tangent vers le fragment shader. </font><font style="vertical-align: inherit;">Ces vecteurs sont utilis√©s dans le fragment shader pour transformer la normale de la carte normale de l'espace tangent √† l'espace de visualisation. </font></font><br><br> <code>p3d_NormalMatrix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">convertit les vecteurs normaux du vecteur sommet, binormal et tangent en espace de visualisation. </font><font style="vertical-align: inherit;">N'oubliez pas que dans l'espace de visualisation, toutes les coordonn√©es sont relatives √† la position de la cam√©ra.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[p3d_NormalMatrix] sont les principaux √©l√©ments de transposition inverse 3x3 de ModelViewMatrix. </font><font style="vertical-align: inherit;">Cette structure est utilis√©e pour convertir le vecteur normal en coordonn√©es de l'espace d'observation.</font></font><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Source</a> </blockquote><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... in vec2 p3d_MultiTexCoord0; // ... out vec2 normalCoord; // ... normalCoord = p3d_MultiTexCoord0; // ...</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b40/f21/575/b40f21575482aa633de61643a1c497aa.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous devons √©galement sortir les coordonn√©es UV de la carte normale dans le fragment shader. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader de fragment </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rappelons que le sommet normal a √©t√© utilis√© pour calculer l'√©clairage. </font><font style="vertical-align: inherit;">Cependant, pour calculer l'√©clairage, la carte normale nous donne d'autres normales. </font><font style="vertical-align: inherit;">Dans le fragment shader, nous devons remplacer les normales des sommets par les normales situ√©es dans la carte normale.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform sampler2D p3d_Texture0; // ... in vec2 normalCoord; // ... /* Find */ vec4 normalTex = texture(p3d_Texture0, normalCoord); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En utilisant les coordonn√©es de la carte normale transf√©r√©es par le vertex shader, nous extrayons la normale correspondante de la carte. </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 normal; // ... /* Unpack */ normal = normalize ( normalTex.rgb * 2.0 - 1.0 ); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ci-dessus, j'ai montr√© comment les normales sont converties en couleurs pour cr√©er des cartes normales. </font><font style="vertical-align: inherit;">Maintenant, nous devons inverser ce processus afin que les normales d'origine soient int√©gr√©es √† la carte.</font></font><br><br><pre> <code class="cpp hljs">[ r, g, b] = [ r * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>, g * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>, b * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>] = [ x, y, z]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Voici √† quoi ressemble le processus de d√©compression des normales de la carte normale. </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... /* Transform */ normal = normalize ( mat3 ( tangent , binormal , vertexNormal ) * normal ); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les normales obtenues √† partir de la carte normale sont g√©n√©ralement dans l'espace tangent. </font><font style="vertical-align: inherit;">Cependant, ils peuvent √™tre dans un autre espace. </font><font style="vertical-align: inherit;">Par exemple, Blender vous permet de faire cuire des normales dans l'espace tangent, l'espace objet, l'espace monde et l'espace cam√©ra.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/009/cfc/62c/009cfc62c03b455a1e22b68e8636e735.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour transf√©rer la normale de la carte normale de l'espace tangent √† l'espace de visualisation, cr√©ez une matrice 3x3 bas√©e sur le vecteur tangent, les vecteurs binormaux et la normale du sommet. </font><font style="vertical-align: inherit;">Multipliez la normale par cette matrice et normalisez-la. </font><font style="vertical-align: inherit;">C'est l√† que nous nous sommes retrouv√©s avec les normales. </font><font style="vertical-align: inherit;">Tous les autres calculs d'√©clairage sont toujours effectu√©s.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code source </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.frag</font></font></a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr453300/">https://habr.com/ru/post/fr453300/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr453290/index.html">Data Science Digest (mai 2019)</a></li>
<li><a href="../fr453292/index.html">"Un petit livre sur les trous noirs"</a></li>
<li><a href="../fr453294/index.html">R√©agir Chargement paresseux</a></li>
<li><a href="../fr453296/index.html">G√©rer l'asynchronie en PHP: des promesses aux coroutines</a></li>
<li><a href="../fr453298/index.html">√ât√©: temps de mise √† niveau ... vous</a></li>
<li><a href="../fr453302/index.html">La premi√®re heure de vie avec Yandex.Module</a></li>
<li><a href="../fr453304/index.html">Avantages cl√©s de Zextras PowerStore</a></li>
<li><a href="../fr453306/index.html">Kubernetes prendra le contr√¥le du monde. Quand et comment?</a></li>
<li><a href="../fr453310/index.html">√âchangez des donn√©es entre les composants React √† l'aide de la biblioth√®que RxJS</a></li>
<li><a href="../fr453312/index.html">G√©n√©rateur d'e-mails professionnels PDF bas√© sur des donn√©es XML</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>