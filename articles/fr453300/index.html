<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🤝‍👩🏼 ⚓️ 👩🏼‍🍳 Shaders de jeu 3D pour débutants 👨‍⚖️ 👔 👩🏿‍🤝‍👨🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Vous voulez apprendre à ajouter des textures, des éclairages, des ombres, des cartes normales, des objets lumineux, une occlusion ambiante et d'autres...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Shaders de jeu 3D pour débutants</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453300/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ba2/494/983/ba2494983fe869e14d259f717aa8fc19.gif" alt="image"></div><br>  Vous voulez apprendre à ajouter des textures, des éclairages, des ombres, des cartes normales, des objets lumineux, une occlusion ambiante et d'autres effets à votre jeu 3D?  Super!  Cet article présente un ensemble de techniques d'ombrage qui peuvent élever le niveau des graphismes de votre jeu à de nouveaux sommets.  J'explique chaque technique de telle manière que vous pouvez appliquer / porter ces informations sur n'importe quelle pile d'outils, que ce soit Godot, Unity ou autre. <br><br>  Comme «colle» entre les shaders, j'ai décidé d'utiliser le magnifique moteur de jeu Panda3D et OpenGL Shading Language (GLSL).  Si vous utilisez la même pile, vous obtiendrez un avantage supplémentaire - vous apprendrez à utiliser des techniques d'ombrage spécifiquement dans Panda3D et OpenGL. <br><a name="habracut"></a><br><h2>  La préparation </h2><br>  Vous trouverez ci-dessous le système que j'ai utilisé pour développer et tester l'exemple de code. <br><br><h3>  Mercredi </h3><br>  L'exemple de code a été développé et testé dans l'environnement suivant: <br><br><ul><li>  Linux manjaro 4.9.135-1-MANJARO </li><li>  Chaîne de rendu OpenGL: GeForce GTX 970 / PCIe / SSE2 </li><li>  Chaîne de version OpenGL: 4.6.0 NVIDIA 410.73 </li><li>  g ++ (GCC) 8.2.1 20180831 </li><li>  Panda3D 1.10.1-1 </li></ul><br><h3>  Matériaux </h3><br>  Chacun des matériaux <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Blender</a> utilisés pour créer <code>mill-scene.egg</code> a deux textures. <br><br>  La première texture est une carte normale, la seconde est une carte diffuse.  Si un objet utilise les normales de ses sommets, une carte normale «bleu clair» est utilisée.  Du fait que tous les modèles ont les mêmes cartes dans les mêmes positions, les shaders peuvent être généralisés et appliqués au nœud racine du graphe de la scène. <br><br>  Notez que le graphique de scène est une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">fonctionnalité de</a> l' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">implémentation du</a> moteur Panda3D. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/19f/9c0/14f/19f9c014f06aee0e2204aa95f87c6306.png"></div><br>  Voici une carte normale à une couleur contenant uniquement la couleur <code>[red = 128, green = 128, blue = 255]</code> . <br><br>  Cette couleur indique l'unité normale, indiquant dans le sens positif de l'axe z <code>[0, 0, 1]</code> . <br><br><pre> <code class="cpp hljs">[<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>] = [ round((<span class="hljs-number"><span class="hljs-number">0</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * <span class="hljs-number"><span class="hljs-number">255</span></span>) , round((<span class="hljs-number"><span class="hljs-number">0</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * <span class="hljs-number"><span class="hljs-number">255</span></span>) , round((<span class="hljs-number"><span class="hljs-number">1</span></span> * <span class="hljs-number"><span class="hljs-number">0.5</span></span> + <span class="hljs-number"><span class="hljs-number">0.5</span></span>) * <span class="hljs-number"><span class="hljs-number">255</span></span>) ] = [<span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">128</span></span>, <span class="hljs-number"><span class="hljs-number">255</span></span>] = [ round(<span class="hljs-number"><span class="hljs-number">128</span></span> / <span class="hljs-number"><span class="hljs-number">255</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) , round(<span class="hljs-number"><span class="hljs-number">128</span></span> / <span class="hljs-number"><span class="hljs-number">255</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) , round(<span class="hljs-number"><span class="hljs-number">255</span></span> / <span class="hljs-number"><span class="hljs-number">255</span></span> * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>) ] = [<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br>  Ici, nous voyons l'unité normale <code>[0, 0, 1]</code> convertie en bleu clair <code>[128, 128, 255]</code> , et le bleu uni converti en unité normale. <br><br>  Ceci est décrit plus en détail dans la section sur les techniques normales de superposition de carte. <br><br><h3>  Panda3d </h3><br>  Dans cet exemple de code, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Panda3D est</a> utilisé comme «colle» entre les shaders.  Cela n'affecte pas les techniques décrites ci-dessous, c'est-à-dire que vous pouvez utiliser les informations étudiées ici dans n'importe quelle pile ou moteur de jeu sélectionné.  Panda3D offre certaines commodités.  Dans l'article dont j'ai parlé, vous pouvez soit trouver leur homologue dans votre pile, soit les recréer vous-même s'ils ne sont pas sur la pile. <br><br>  Il convient de noter que le <code>gl-coordinate-system default</code> , <code>textures-power-2 down</code> et <code>textures-auto-power-2 1</code> ont été ajoutés à <code>config.prc</code> .  Ils ne sont pas contenus dans la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">configuration Panda3D</a> standard. <br><br>  Par défaut, Panda3D utilise un système de coordonnées droitier avec un axe z vers le haut, tandis qu'OpenGL utilise un système de coordonnées droitier avec un axe y vers le haut. <br><br>  <code>gl-coordinate-system default</code> vous permet de vous débarrasser des transformations entre deux systèmes de coordonnées à l'intérieur des shaders. <br><br>  <code>textures-auto-power-2 1</code> nous permet d'utiliser des tailles de texture qui ne sont pas des puissances de deux, si le système les prend en charge. <br><br>  Cela est pratique lors de l'exécution de SSAO ou de la mise en œuvre d'autres techniques dans un écran / fenêtre, car la taille de l'écran / fenêtre n'est généralement pas une puissance de deux. <br><br>  <code>textures-power-2 down</code> réduit la taille des textures à une puissance de deux si le système ne prend en charge que les textures de tailles égales à deux. <br><br><h2>  Exemple de code de génération </h2><br>  Si vous souhaitez exécuter l'exemple de code, vous devez d'abord le générer. <br><br>  Panda3D fonctionne sur Linux, Mac et Windows. <br><br><h3>  Linux </h3><br>  Commencez par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">installer le</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">SDK Panda3D</a> pour votre distribution. <br><br>  Trouvez où se trouvent les en-têtes et les bibliothèques Panda3D.  Ils se trouvent très probablement dans <code>/usr/include/panda3d/</code> et dans <code>/usr/lib/panda3d/</code> . <br><br>  Ensuite, clonez ce référentiel et accédez à son répertoire. <br><br> <code>git clone https://github.com/lettier/3d-game-shaders-for-beginners.git <br> cd 3d-game-shaders-for-beginners</code> <br> <br>  Compilez maintenant le code source dans un fichier de sortie. <br><br> <code>g++ \ <br> -c main.cxx \ <br> -o 3d-game-shaders-for-beginners.o \ <br> -std=gnu++11 \ <br> -O2 \ <br> -I/usr/include/python2.7/ \ <br> -I/usr/include/panda3d/</code> <br> <br>  Après avoir créé le fichier de sortie, créez un fichier exécutable en associant le fichier de sortie à ses dépendances. <br><br> <code>g++ \ <br> 3d-game-shaders-for-beginners.o \ <br> -o 3d-game-shaders-for-beginners \ <br> -L/usr/lib/panda3d \ <br> -lp3framework \ <br> -lpanda \ <br> -lpandafx \ <br> -lpandaexpress \ <br> -lp3dtoolconfig \ <br> -lp3dtool \ <br> -lp3pystub \ <br> -lp3direct \ <br> -lpthread</code> <br> <br>  Voir le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">manuel Panda3D pour</a> plus d'informations. <br><br><h3>  Mac </h3><br>  Commencez par installer le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">SDK Panda3D</a> pour Mac. <br><br>  Trouvez où se trouvent les en-têtes et les bibliothèques de Panda3D. <br><br>  Ensuite, clonez le référentiel et accédez à son répertoire. <br><br> <code>git clone https://github.com/lettier/3d-game-shaders-for-beginners.git <br> cd 3d-game-shaders-for-beginners</code> <br> <br>  Compilez maintenant le code source dans un fichier de sortie.  Vous devez trouver où se trouvent les répertoires include dans Python 2.7 et Panda3D. <br><br> <code>clang++ \ <br> -c main.cxx \ <br> -o 3d-game-shaders-for-beginners.o \ <br> -std=gnu++11 \ <br> -g \ <br> -O2 \ <br> -I/usr/include/python2.7/ \ <br> -I/Developer/Panda3D/include/</code> <br> <br>  Après avoir créé le fichier de sortie, créez un fichier exécutable en associant le fichier de sortie à ses dépendances. <br><br>  Vous devez trouver où se trouvent les bibliothèques Panda3D. <br><br> <code>clang++ \ <br> 3d-game-shaders-for-beginners.o \ <br> -o 3d-game-shaders-for-beginners \ <br> -L/Developer/Panda3D/lib \ <br> -lp3framework \ <br> -lpanda \ <br> -lpandafx \ <br> -lpandaexpress \ <br> -lp3dtoolconfig \ <br> -lp3dtool \ <br> -lp3pystub \ <br> -lp3direct \ <br> -lpthread</code> <br> <br>  Voir le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">manuel Panda3D pour</a> plus d'informations. <br><br><h3>  Windows </h3><br>  Commencez par <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">installer le</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">SDK Panda3D</a> pour Windows. <br><br>  Trouvez où se trouvent les en-têtes et les bibliothèques Panda3D. <br><br>  Clonez ce référentiel et accédez à son répertoire. <br><br> <code>git clone https://github.com/lettier/3d-game-shaders-for-beginners.git <br> cd 3d-game-shaders-for-beginners</code> <br> <br>  Voir le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">manuel Panda3D pour</a> plus d'informations. <br><br><h2>  Lancer la démo </h2><br>  Après avoir créé l'exemple de code, vous pouvez exécuter le fichier exécutable ou la démo.  C'est ainsi qu'ils fonctionnent sous Linux ou Mac. <br><br> <code>./3d-game-shaders-for-beginners</code> <br> <br>  Et donc ils fonctionnent sous Windows: <br><br> <code>3d-game-shaders-for-beginners.exe</code> <br> <br><h3>  Contrôle clavier </h3><br>  La démo dispose d'un contrôle au clavier qui vous permet de déplacer la caméra et de changer l'état de divers effets. <br><br><h3>  Mouvement </h3><br><ul><li>  <code>w</code> - pénétrer profondément dans la scène. </li><li>  <code>a</code> - faites pivoter la scène dans le sens des aiguilles d'une montre. </li><li>  <code>s</code> - éloignez-vous de la scène. </li><li>  <code>d</code> - faire pivoter la scène dans le sens antihoraire. </li></ul><br><h3>  Effets commutables </h3><br><ul><li>  <code>y</code> - activer SSAO. </li><li>  <code>Shift</code> + <code>y</code> - désactiver SSAO. </li><li>  <code>u</code> - inclusion de circuits. </li><li>  <code>Shift</code> + <code>u</code> - désactiver les contours. </li><li>  <code>i</code> - activer la floraison. </li><li>  <code>Shift</code> + <code>i</code> - désactiver la floraison. </li><li>  <code>o</code> - activer les cartes normales. </li><li>  <code>Shift</code> + <code>o</code> - désactiver les cartes normales. </li><li>  <code>p</code> - inclusion de brouillard. </li><li>  <code>Shift</code> + <code>p</code> - désactiver le brouillard. </li><li>  <code>h</code> - l'inclusion de la profondeur de champ. </li><li>  <code>Shift</code> + <code>h</code> - désactiver la profondeur de champ. </li><li>  <code>j</code> - activer la postérisation. </li><li>  <code>Shift</code> + <code>j</code> - désactiver la postérisation </li><li>  <code>k</code> - activer la pixellisation. </li><li>  <code>Shift</code> + <code>k</code> - désactiver la pixelisation. </li><li>  <code>l</code> - affûtage. </li><li>  <code>Shift</code> + <code>l</code> - désactiver la netteté. </li><li>  <code>n</code> inclusion de grain de film. </li><li>  <code>Shift</code> + <code>n</code> - désactive le grain du film. </li></ul><br><h2>  Système de référence </h2><br>  Avant de commencer à écrire des shaders, vous devez vous familiariser avec les systèmes de référence ou systèmes de coordonnées suivants.  Tous se résument à la provenance des coordonnées actuelles de l'origine de la référence <code>(0, 0, 0)</code> .  Dès que nous le découvrons, nous pouvons les transformer en utilisant une sorte de matrice ou un autre espace vectoriel.  En règle générale, si la sortie d'un shader ne semble pas correcte, la cause est la confusion des systèmes de coordonnées. <br><br><h3>  Modèle </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e06/9ce/863/e069ce863ffc7bd3b94394dc20b25687.gif"></div><br>  Le système de coordonnées du modèle ou de l'objet est relatif à l'origine du modèle.  Dans les programmes de modélisation tridimensionnelle, par exemple, dans Blender, il est généralement placé au centre du modèle. <br><br><h3>  Le monde </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d0a/9de/1f7/d0a9de1f741bb90174efd93d174ef1f9.gif"></div><br>  L'espace mondial est relatif à l'origine de la scène / niveau / univers que vous avez créé. <br><br><h3>  Revue </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/bd2/15b/b6e/bd215bb6ee79a6904eba3f6ad4ff56d3.gif"></div><br>  L'espace de coordonnées de la vue est relatif à la position de la caméra active. <br><br><h3>  Coupure </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d77/505/a34/d77505a349f37a695f77625400857d58.png"></div><br>  Espace de détourage par rapport au centre du cadre de la caméra.  Toutes les coordonnées sont homogènes et sont dans l'intervalle <code>(-1, 1)</code> .  X et y sont parallèles au film de la caméra et la coordonnée z est la profondeur. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/dc7/0be/d7c/dc70bed7ca78c39cc9f538b127d7176e.gif"></div><br>  Tous les sommets qui ne se trouvent pas dans les limites de la pyramide de visibilité ou du volume de visibilité de la caméra sont coupés ou supprimés.  Nous voyons comment cela se produit avec un cube tronqué derrière par le plan éloigné de la caméra, et avec un cube situé sur le côté. <br><br><h3>  Écran </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e5b/47d/336/e5b47d33660b9c1744faa12fec8ef256.png"></div><br>  L'espace d'écran est (généralement) relatif au coin inférieur gauche de l'écran.  X passe de zéro à la largeur de l'écran.  Y passe de zéro à la hauteur de l'écran. <br><br><h2>  GLSL </h2><br>  Au lieu de travailler avec un pipeline de fonctions fixes, nous utiliserons un pipeline de rendu GPU programmable.  Puisqu'il est programmable, nous devons lui-même lui passer le code du programme sous forme de shaders.  Un shader est un programme (généralement petit) créé avec une syntaxe ressemblant au langage C. Un pipeline de rendu GPU programmable se compose de différentes étapes qui peuvent être programmées à l'aide de shaders.  Différents types de shaders comprennent les vertex shaders, les tessellation shaders, les shaders géométriques, fragmentaires et informatiques.  Pour utiliser les techniques décrites dans l'article, il nous suffit d'utiliser vertex et fragment <br>  étapes. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 void main() {}</span></span></code> </pre> <br>  Voici le shader GLSL minimal, composé du numéro de version GLSL et de la fonction principale. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform mat4 p3d_ModelViewProjectionMatrix; in vec4 p3d_Vertex; void main() { gl_Position = p3d_ModelViewProjectionMatrix * p3d_Vertex; }</span></span></code> </pre> <br>  Voici le vertex shader GLSL tronqué, qui transforme le sommet d'entrée en espace de découpage et affiche cette nouvelle position comme une position de sommet uniforme. <br><br>  La procédure <code>main</code> ne renvoie rien, car elle est <code>void</code> , et la variable <code>gl_Position</code> est la sortie en ligne. <br><br>  Deux mots clés méritent d'être mentionnés: <code>uniform</code> et <code>in</code> . <br><br>  Le mot-clé <code>uniform</code> signifie que cette variable globale est la même pour tous les sommets.  Panda3D définit lui-même <code>p3d_ModelViewProjectionMatrix</code> et pour chaque sommet, il s'agit de la même matrice. <br><br>  Le mot clé <code>in</code> signifie que cette variable globale est passée au shader.  Un vertex shader obtient chaque vertex composé de la géométrie, auquel un vertex shader est attaché. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 out vec4 fragColor; void main() { fragColor = vec4(0, 1, 0, 1); }</span></span></code> </pre> <br>  Voici le shader de fragment GLSL découpé, affichant le vert opaque comme couleur du fragment. <br><br>  N'oubliez pas qu'un fragment n'affecte qu'un seul pixel d'écran, mais plusieurs fragments peuvent affecter un pixel. <br><br>  Faites attention au mot clé out. <br><br>  Le mot clé <code>out</code> signifie que cette variable globale est définie par le shader. <br><br>  Le nom <code>fragColor</code> facultatif, vous pouvez donc en choisir un autre. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8b4/276/b2d/8b4276b2d7e735cc05484e80e0c046e8.gif"></div><br>  Voici la sortie des deux shaders illustrés ci-dessus. <br><br><h2>  Rendu de texture </h2><br>  Au lieu de rendre / dessiner directement sur l'écran, l'exemple de code utilise une technique pour <br>  le nom "rendu en texture" (rendu en texture).  Pour effectuer un rendu sur une texture, vous devez configurer le tampon d'image et y lier la texture.  Vous pouvez lier plusieurs textures à un seul tampon d'image. <br><br>  Les textures liées au tampon de trame stockent les vecteurs renvoyés par le fragment shader.  Habituellement, ces vecteurs sont des vecteurs de couleur <code>(r, g, b, a)</code> , mais ils peuvent être des positions ou des vecteurs normaux <code>(x, y, z, w)</code> .  Pour chaque texture liée, un ombrage de fragment peut générer un vecteur distinct.  Par exemple, on peut déduire en un seul passage la position et la normale du sommet. <br><br>  La majeure partie de l'exemple de code qui fonctionne avec Panda3D est liée à la définition <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">des textures de tampon de trame</a> .  Pour simplifier les choses, chaque fragment de shader dans l'exemple de code n'a qu'une seule sortie.  Cependant, pour garantir une fréquence d'images élevée (FPS), nous devons produire autant d'informations que possible à chaque passage de rendu. <br><br>  Voici deux structures de texture pour le tampon de trame de l'exemple de code. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ac9/d2b/d50/ac9d2bd50cd1c0bc991ffe7569bf5432.gif"></div><br>  La première structure transforme une scène de moulin à eau en une texture de tampon de trame à l'aide d'une variété de vertex et de shaders de fragments.  Cette structure passe par chacun des sommets de la scène avec le moulin et le long des fragments correspondants. <br><br>  Dans cette structure, l'exemple de code fonctionne comme suit. <br><br><ul><li>  Enregistre les données de géométrie (par exemple, la position ou le sommet normal) pour une utilisation future. </li><li>  Enregistre les données de matériau (par exemple, couleur diffuse) pour une utilisation future. </li><li>  Crée une liaison UV de différentes textures (diffuses, normales, ombrées, etc.). </li><li>  Calcule l'éclairage ambiant, diffus, réfléchi et émis. </li><li>  Rend le brouillard. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e5/554/0c2/7e55540c20fe190246f3180b3f06a731.png"></div><br>  La deuxième structure est une caméra orthogonale visant un rectangle en forme d'écran. <br>  Cette structure ne traverse que quatre pics et leurs fragments correspondants. <br><br>  Dans la deuxième structure, l'exemple de code effectue les actions suivantes: <br><br><ul><li>  Traite la sortie d'une autre texture de tampon de trame. </li><li>  Combine différentes textures de tampon de trame en une seule. </li></ul><br>  Dans l'exemple de code, nous pouvons voir la sortie d'une texture de tampon d'image, définissant l'image correspondante sur true et false sur toutes les autres. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... bool showPositionBuffer = false; bool showNormalBuffer = false; bool showSsaoBuffer = false; bool showSsaoBlurBuffer = false; bool showMaterialDiffuseBuffer = false; bool showOutlineBuffer = false; bool showBaseBuffer = false; bool showSharpenBuffer = false; bool showBloomBuffer = false; bool showCombineBuffer = false; bool showCombineBlurBuffer = false; bool showDepthOfFieldBuffer = false; bool showPosterizeBuffer = false; bool showPixelizeBuffer = false; bool showFilmGrainBuffer = true; // ...</span></span></code> </pre> <br><h2>  Texturation </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/d1c/0eb/1c6/d1c0eb1c650b9b05e2372b33259ed8a6.gif"></div><br>  La texturation est la liaison d'une couleur ou d'un autre vecteur à un fragment en utilisant les coordonnées UV.  Les valeurs de U et V varient de zéro à un.  Chaque sommet reçoit une coordonnée UV et elle est affichée dans le vertex shader. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/519/487/fee/519487fee2bb16357b225ce32649fb91.png"></div><br>  Le fragment shader obtient la coordonnée UV interpolée.  L'interpolation signifie que la coordonnée UV du fragment se situe quelque part entre les coordonnées UV des sommets qui composent la face du triangle. <br><br><h3>  Vertex shader </h3><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform mat4 p3d_ModelViewProjectionMatrix; in vec2 p3d_MultiTexCoord0; in vec4 p3d_Vertex; out vec2 texCoord; void main() { texCoord = p3d_MultiTexCoord0; gl_Position = p3d_ModelViewProjectionMatrix * p3d_Vertex; }</span></span></code> </pre> <br>  Ici, nous voyons que le vertex shader délivre les coordonnées de la texture au fragment shader.  Notez qu'il s'agit d'un vecteur à deux dimensions: une valeur pour U et une pour V. <br><br><h3>  Shader de fragment </h3><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform sampler2D p3d_Texture0; in vec2 texCoord; out vec2 fragColor; void main() { texColor = texture(p3d_Texture0, texCoord); fragColor = texColor; }</span></span></code> </pre> <br>  Ici, nous voyons que le shader de fragment recherche la couleur dans sa coordonnée UV et l'affiche comme la couleur du fragment. <br><br><h4>  Texture de remplissage d'écran </h4><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 140 uniform sampler2D screenSizedTexture; out vec2 fragColor; void main() { vec2 texSize = textureSize(texture, 0).xy; vec2 texCoord = gl_FragCoord.xy / texSize; texColor = texture(screenSizedTexture, texCoord); fragColor = texColor; }</span></span></code> </pre> <br>  Lors du rendu d'une texture, le maillage est un rectangle plat avec le même rapport hauteur / largeur que l'écran.  Par conséquent, nous pouvons calculer les coordonnées UV, en ne connaissant que <br><br>  A) la largeur et la hauteur de la texture avec la taille de l'écran superposée au rectangle en utilisant les coordonnées UV, et <br>  B) les coordonnées x et y du fragment. <br><br>  Pour lier x à U, vous devez diviser x par la largeur de la texture entrante.  De même, pour lier y à V, vous devez diviser y par la hauteur de la texture entrante.  Vous verrez que cette technique est utilisée dans l'exemple de code. <br><br><h2>  Eclairage </h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/f98/05e/0ca/f9805e0ca9717c961dd9618f49475381.gif"></div><br>  Pour déterminer l'éclairage, il est nécessaire de calculer et de combiner les aspects de l'éclairage ambiant, diffus, réfléchi et émis.  L'exemple de code utilise l'éclairage Phong. <br><br><h3>  Vertex shader </h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform struct p3d_LightSourceParameters { vec4 color ; vec4 ambient ; vec4 diffuse ; vec4 specular ; vec4 position ; vec3 spotDirection ; float spotExponent ; float spotCutoff ; float spotCosCutoff ; float constantAttenuation ; float linearAttenuation ; float quadraticAttenuation ; vec3 attenuation ; sampler2DShadow shadowMap ; mat4 shadowViewMatrix ; } p3d_LightSource[NUMBER_OF_LIGHTS]; // ...</span></span></code> </pre><br>  Pour chaque source de lumière, à l'exception de la lumière ambiante, Panda3D nous fournit une structure pratique qui est disponible pour les vertex et les shaders de fragments.  La chose la plus pratique est une carte d'ombres et une matrice pour visualiser les ombres afin de convertir les sommets en un espace d'ombres ou d'éclairage. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vertexPosition = p3d_ModelViewMatrix * p3d_Vertex; // ... for (int i = 0; i &lt; p3d_LightSource.length(); ++i) { vertexInShadowSpaces[i] = p3d_LightSource[i].shadowViewMatrix * vertexPosition; } // ...</span></span></code> </pre> <br>  En commençant par le vertex shader, nous devons transformer et supprimer le sommet de l'espace de visualisation en ombre ou espace d'éclairage pour chaque source de lumière dans la scène.  Cela sera utile à l'avenir pour que le fragment shader rende les ombres.  Un espace d'ombre ou d'éclairage est un espace dans lequel chaque coordonnée est relative à la position de la source lumineuse (l'origine est la source lumineuse). <br><br><h3>  Shader de fragment </h3><br>  Le fragment shader fait la majeure partie du calcul d'éclairage. <br><br><h4>  Matière </h4><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform struct { vec4 ambient ; vec4 diffuse ; vec4 emission ; vec3 specular ; float shininess ; } p3d_Material; // ...</span></span></code> </pre> <br>  Panda3D nous fournit du matériel (sous la forme d'une structure) pour le maillage ou le modèle que nous rendons actuellement. <br><br><h4>  Sources d'éclairage multiples </h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 diffuseSpecular = vec4(0.0, 0.0, 0.0, 0.0); // ...</span></span></code> </pre> <br>  Avant de faire le tour des sources d'éclairage de la scène, nous allons créer un lecteur qui contiendra à la fois des couleurs diffuses et réfléchies. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... for (int i = 0; i &lt; p3d_LightSource.length(); ++i) { // ... } // ...</span></span></code> </pre> <br>  Nous pouvons maintenant faire le tour des sources lumineuses dans un cycle, en calculant les couleurs diffuses et réfléchies pour chacune. <br><br><h4>  Vecteurs liés à l'éclairage </h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/307/035/ce7/307035ce7bf5a52b8f25c7aeb862b9d4.gif"></div><br>  Voici quatre vecteurs de base nécessaires pour calculer les couleurs diffuses et réfléchies introduites par chaque source de lumière.  Le vecteur de direction d'éclairage est une flèche bleue pointant vers la source de lumière.  Le vecteur normal est une flèche verte pointant verticalement vers le haut.  Le vecteur de réflexion est une flèche bleue qui reflète le vecteur de direction de la lumière.  Le vecteur œil ou vue est la flèche orange pointant vers la caméra. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 lightDirection = p3d_LightSource[i].position.xyz - vertexPosition.xyz * p3d_LightSource[i].position.w; // ...</span></span></code> </pre> <br>  La direction de l'éclairage est le vecteur de la position du sommet à la position de la source lumineuse. <br><br>  S'il s'agit d'un éclairage directionnel, Panda3D met <code>p3d_LightSource[i].position.w</code> zéro <code>p3d_LightSource[i].position.w</code> .  L'éclairage directionnel n'a pas de position, seulement une direction.  Par conséquent, s'il s'agit d'un éclairage directionnel, la direction de l'éclairage sera une direction négative ou opposée à la source, car pour l'éclairage directionnel, Panda3D définit <code>p3d_LightSource[i].position.xyz</code> sur <code>-direction</code> . <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... normal = normalize(vertexNormal); // ...</span></span></code> </pre> <br>  La normale au sommet doit être un vecteur unitaire.  Les vecteurs unitaires ont une valeur égale à un. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 unitLightDirection = normalize(lightDirection); vec3 eyeDirection = normalize(-vertexPosition.xyz); vec3 reflectedDirection = normalize(-reflect(unitLightDirection, normal)); // ...</span></span></code> </pre> <br>  Ensuite, nous avons besoin de trois vecteurs supplémentaires. <br><br>  Nous avons besoin d'un produit scalaire avec la participation de la direction d'éclairage, il est donc préférable de le normaliser.  Cela nous donne une distance ou une magnitude égale à l'unité (vecteur unitaire). <br><br>  La direction de vue est opposée à la position du sommet / fragment, car la position du sommet / fragment est relative à la position de la caméra.  N'oubliez pas que la position du sommet / fragment est dans l'espace de visualisation.  Par conséquent, au lieu de passer de la caméra (œil) au sommet / fragment, nous passons du sommet / fragment à la caméra (œil). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Le vecteur de réflexion</a> est une réflexion de la direction d'éclairage normale à la surface.  Lorsque le "rayon" de lumière touche la surface, il se reflète sous le même angle auquel il est tombé.  L'angle entre le vecteur de direction de l'illumination et la normale est appelé "angle d'incidence".  L'angle entre le vecteur de réflexion et la normale est appelé "angle de réflexion". <br><br>  Vous devez changer le signe du vecteur de lumière réfléchie, car il doit pointer dans la même direction que le vecteur de l'œil.  N'oubliez pas que la direction de l'œil va du haut / fragment à la position de la caméra.  Nous utiliserons le vecteur de réflexion pour calculer la luminosité de la lumière réfléchie. <br><br><h4>  Éclairage diffus </h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float diffuseIntensity = max(dot(normal, unitLightDirection), 0.0); if (diffuseIntensity &gt; 0) { // ... } // ...</span></span></code> </pre> <br>  La luminosité de l'éclairage diffus est le produit scalaire de la normale à la surface et de la direction d'éclairage d'un vecteur unique.  Le produit scalaire peut aller de moins un à un.  Si les deux vecteurs pointent dans la même direction, alors la luminosité est l'unité.  Dans tous les autres cas, ce sera inférieur à l'unité. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/168/5bc/5e7/1685bc5e759e638b5c2bcc4a6c56bbd3.gif"></div><br>  Si le vecteur d'éclairage se rapproche de la même direction que la normale, alors la luminosité de l'éclairage diffus tend à l'unité. <br><br>  Si la luminosité de l'éclairage diffus est inférieure ou égale à zéro, vous devez passer à la source de lumière suivante. <br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 diffuse = vec4 ( clamp ( diffuseTex.rgb * p3d_LightSource[i].diffuse.rgb * diffuseIntensity , 0 , 1 ) , 1 ); diffuse.r = clamp(diffuse.r, 0, diffuseTex.r); diffuse.g = clamp(diffuse.g, 0, diffuseTex.g); diffuse.b = clamp(diffuse.b, 0, diffuseTex.b); // ...</span></span></code> </pre> <br>  Nous pouvons maintenant calculer la couleur diffuse introduite par cette source.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si la luminosité de l'éclairage diffus est égale à l'unité, alors la couleur diffuse sera un mélange de la couleur de la texture diffuse et de la couleur de l'éclairage. </font><font style="vertical-align: inherit;">À toute autre luminosité, la couleur diffuse sera plus sombre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notez que je limite la couleur diffuse afin qu'elle ne soit pas plus lumineuse que la couleur de la texture diffuse. </font><font style="vertical-align: inherit;">Cela évitera une surexposition de la scène.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lumière réfléchie </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Après un éclairage diffus, la réflexion est calculée. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/989/ade/77c/989ade77c01b7137f437f97fe83ccd17.gif"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 specular = clamp ( vec4(p3d_Material.specular, 1) * p3d_LightSource[i].specular * pow ( max(dot(reflectedDirection, eyeDirection), 0) , p3d_Material.shininess ) , 0 , 1 ); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La luminosité de la lumière réfléchie est le produit scalaire entre le vecteur œil et le vecteur réflexion. </font><font style="vertical-align: inherit;">Comme dans le cas de la luminosité d'un éclairage diffus, si deux vecteurs pointent dans la même direction, alors la luminosité de l'éclairage réfléchi est égale à l'unité. </font><font style="vertical-align: inherit;">Toute autre luminosité réduira la quantité de couleur réfléchie introduite par cette source de lumière.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/c2e/046/570/c2e046570e770e1804544d6ae67ae2f8.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le lustre du matériau détermine la quantité de diffusion de la lumière réfléchie. </font><font style="vertical-align: inherit;">Il est généralement défini dans un programme de simulation, par exemple dans Blender. </font><font style="vertical-align: inherit;">Dans Blender, on parle de dureté spéculaire.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Projecteurs </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float unitLightDirectionDelta = dot ( normalize(p3d_LightSource[i].spotDirection) , -unitLightDirection ); if (unitLightDirectionDelta &gt;= p3d_LightSource[i].spotCosCutoff) { // ... } // ... }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ce code ne permet pas à l'éclairage d'affecter les fragments à l'extérieur du cône ou de la pyramide du projecteur. </font><font style="vertical-align: inherit;">Heureusement, Panda3D peut </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">définir</font></font></a> <code>spotDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> et </font></font><code>spotCosCutoff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">travailler avec des </font><font style="vertical-align: inherit;">lumières directionnelles et ponctuelles. </font><font style="vertical-align: inherit;">Les projecteurs ont à la fois une position et une direction. </font><font style="vertical-align: inherit;">Cependant, l'éclairage directionnel n'a qu'une direction et les sources ponctuelles n'ont qu'une position. </font><font style="vertical-align: inherit;">Cependant, ce code fonctionne pour les trois types d'éclairage sans qu'il soit nécessaire de confondre les instructions if.</font></font><br><br><pre> <code class="cpp hljs">spotCosCutoff = cosine(<span class="hljs-number"><span class="hljs-number">0.5</span></span> * spotlightLensFovAngle);</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Si dans le cas d'un éclairage de projection, le produit scalaire du vecteur "fragment-source d'éclairage" et du vecteur de direction du projecteur est inférieur au cosinus de la moitié de l'angle du champ de vision du </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">projecteur, le shader ne prend pas en compte l'influence de cette source. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notez que vous devez changer le signe </font></font><code>unitLightDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>unitLightDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">va du fragment au projecteur, et nous devons passer du projecteur au fragment, car il </font></font><code>spotDirection</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">va directement au centre de la pyramide du projecteur à une certaine distance de la position du projecteur. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dans le cas d'un éclairage directionnel et ponctuel, Panda3D définit la </font></font><code>spotCosCutoff</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">valeur sur -1. Rappelons que le produit scalaire varie dans la plage de -1 à 1. Par conséquent, peu importe ce qu'il sera </font></font><code>unitLightDirectionDelta</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, car il est toujours supérieur ou égal à -1.</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... diffuse *= pow(unitLightDirectionDelta, p3d_LightSource[i].spotExponent); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Comme le code </font></font><code>unitLightDirectionDelta</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ce code fonctionne également pour les trois types de sources lumineuses. </font><font style="vertical-align: inherit;">Dans le cas des projecteurs, il rendra les fragments plus brillants à l'approche du centre de la pyramide des projecteurs. </font><font style="vertical-align: inherit;">Pour les sources de lumière directionnelles et ponctuelles, la valeur </font></font><code>spotExponent</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">est nulle. </font><font style="vertical-align: inherit;">Rappelons que toute valeur à la puissance de zéro est égale à l'unité, de sorte que la couleur diffuse est égale à elle-même, multipliée par un, c'est-à-dire qu'elle ne change pas.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ombres </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float shadow = textureProj ( p3d_LightSource[i].shadowMap , vertexInShadowSpaces[i] ); diffuse.rgb *= shadow; specular.rgb *= shadow; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panda3D simplifie l'utilisation des ombres car il crée une carte des ombres et une matrice de transformation des ombres pour chaque source de lumière dans la scène. Pour créer vous-même une matrice de transformation, vous devez collecter une matrice qui convertit les coordonnées de l'espace de visualisation en espace d'éclairage (les coordonnées sont relatives à la position de la source lumineuse). Pour créer vous-même une carte d'ombre, vous devez rendre la scène du point de vue de la source de lumière dans la texture du tampon d'image. La texture du tampon de trame doit contenir la distance entre la source de lumière et les fragments. C'est ce qu'on appelle une «carte de profondeur». Enfin, vous devez transférer manuellement vers le shader votre carte de profondeur maison en tant que </font></font><code>uniform sampler2DShadow</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, et la matrice de transformation d'ombre en tant que </font></font><code>uniform mat4</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Nous allons donc recréer ce que Panda3D fait automatiquement pour nous.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'extrait de code illustré est utilisé </font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, ce qui est différent de la fonction indiquée ci-dessus </font></font><code>texture</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">divise d'abord </font></font><code>vertexInShadowSpaces[i].xyz</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">par </font></font><code>vertexInShadowSpaces[i].w</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Elle l'utilise ensuite </font></font><code>vertexInShadowSpaces[i].xy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour trouver la profondeur stockée dans la carte d'ombre. Ensuite, elle utilise </font></font><code>vertexInShadowSpaces[i].z</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pour comparer la profondeur du haut avec la profondeur de la carte d'ombre dans </font></font><code>vertexInShadowSpaces[i].xy</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Si la comparaison réussit, elle en </font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">renvoie un. Sinon, il renvoie zéro. Zéro signifie que ce sommet / fragment est dans l'ombre et un signifie que le sommet / fragment n'est pas dans l'ombre. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Notez </font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">qu'il peut également renvoyer une valeur de zéro à un, selon la configuration de la carte fantôme. Dans cet exemple</font></font><code>textureProj</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Effectue plusieurs tests de profondeur basés sur des profondeurs adjacentes et renvoie une moyenne pondérée. </font><font style="vertical-align: inherit;">Cette moyenne pondérée peut donner de la douceur aux ombres.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Atténuation </font></font></h4><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/381/e8d/bfb/381e8dbfb118dac85b139d0c1ec41bad.png"></div><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... float lightDistance = length(lightDirection); float attenuation = 1 / ( p3d_LightSource[i].constantAttenuation + p3d_LightSource[i].linearAttenuation * lightDistance + p3d_LightSource[i].quadraticAttenuation * (lightDistance * lightDistance) ); diffuse.rgb *= attenuation; specular.rgb *= attenuation; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La distance à la source lumineuse est simplement la grandeur ou la longueur du vecteur de direction d'éclairage. </font><font style="vertical-align: inherit;">Notez que nous n'utilisons pas la direction d'éclairement normalisée, car une telle distance serait égale à l'unité. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">La distance à la source lumineuse est nécessaire pour calculer l'atténuation. </font><font style="vertical-align: inherit;">L'atténuation signifie que l'effet de la lumière loin de la source diminue. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Paramètres </font></font><code>constantAttenuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>linearAttenuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>quadraticAttenuation</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vous pouvez définir toutes les valeurs. </font><font style="vertical-align: inherit;">Cela vaut la peine de commencer par </font></font><code>constantAttenuation = 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>linearAttenuation = 0</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">et </font></font><code>quadraticAttenuation = 1</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Avec de tels paramètres, la position de la source lumineuse est égale à l'unité et tend à zéro en s'éloignant d'elle.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Éclairage couleur final </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... diffuseSpecular += (diffuse + specular); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour calculer la couleur finale de l'éclairage, vous devez ajouter la couleur diffuse et réfléchie. </font><font style="vertical-align: inherit;">Il est nécessaire d'ajouter cela au lecteur dans un cycle de contournement des sources lumineuses dans la scène.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ambiant </font></font></h4><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform sampler2D p3d_Texture1; // ... uniform struct { vec4 ambient ; } p3d_LightModel; // ... in vec2 diffuseCoord; // ... vec4 diffuseTex = texture(p3d_Texture1, diffuseCoord); // ... vec4 ambient = p3d_Material.ambient * p3d_LightModel.ambient * diffuseTex; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Le composant d'éclairage ambiant dans le modèle d'éclairage est basé sur la couleur ambiante du matériau, la couleur de l'éclairage ambiant et la couleur de la texture diffuse. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Il ne doit jamais y avoir plus d'une source de lumière ambiante, ce calcul ne doit donc être effectué qu'une seule fois, contrairement aux calculs des couleurs diffuses et réfléchies accumulées pour chaque source de lumière. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Veuillez noter que la couleur de la lumière ambiante est utile lors de l'exécution de SSAO.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tout mettre ensemble </font></font></h4><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec4 outputColor = ambient + diffuseSpecular + p3d_Material.emission; // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> La couleur finale est la somme de la couleur ambiante, de la couleur diffuse, de la couleur réfléchie et de la couleur émise. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code source </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.frag</font></font></a> </li></ul><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Cartes normales </font></font></h2><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/6d1/6bb/9de/6d16bb9deae1520429083896b7492a3f.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">L'utilisation de cartes normales vous permet d'ajouter de nouvelles pièces à la surface sans géométrie supplémentaire. </font><font style="vertical-align: inherit;">En règle générale, lorsque vous travaillez dans un programme de modélisation 3D, des versions haute et basse poly du maillage sont créées. </font><font style="vertical-align: inherit;">Ensuite, les normales des sommets du maillage poly élevé sont prises et intégrées dans la texture. </font><font style="vertical-align: inherit;">Cette texture est une carte normale. </font><font style="vertical-align: inherit;">Ensuite, à l'intérieur du shader de fragment, nous remplaçons les normales des sommets du maillage poly faible par les normales du maillage poly élevé cuites dans la carte normale. </font><font style="vertical-align: inherit;">Pour cette raison, lors de l'éclairage d'un maillage, il semblera qu'il a plus de polygones qu'il ne l'est réellement. </font><font style="vertical-align: inherit;">Cela vous permet de maintenir un FPS élevé, tout en transmettant la plupart des détails de la version haute poly.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/8e1/92b/4ae/8e192b4ae48d96a65b92456ba640c7d0.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ici, nous voyons la transition d'un modèle poly élevé à un modèle poly faible, puis à un modèle poly faible avec une carte normale superposée. </font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/987/20d/ee1/98720dee1f77246721e1905abf2ebea4.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cependant, n'oubliez pas que superposer une carte normale n'est qu'une illusion. </font><font style="vertical-align: inherit;">Sous un certain angle, la surface redevient plate.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vertex shader </font></font></h3><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform mat3 p3d_NormalMatrix; // ... in vec3 p3d_Normal; // ... in vec3 p3d_Binormal; in vec3 p3d_Tangent; // ... vertexNormal = normalize(p3d_NormalMatrix * p3d_Normal); binormal = normalize(p3d_NormalMatrix * p3d_Binormal); tangent = normalize(p3d_NormalMatrix * p3d_Tangent); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En commençant par le vertex shader, nous devons sortir le vecteur normal, le vecteur binormal et le vecteur tangent vers le fragment shader. </font><font style="vertical-align: inherit;">Ces vecteurs sont utilisés dans le fragment shader pour transformer la normale de la carte normale de l'espace tangent à l'espace de visualisation. </font></font><br><br> <code>p3d_NormalMatrix</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">convertit les vecteurs normaux du vecteur sommet, binormal et tangent en espace de visualisation. </font><font style="vertical-align: inherit;">N'oubliez pas que dans l'espace de visualisation, toutes les coordonnées sont relatives à la position de la caméra.</font></font><br><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">[p3d_NormalMatrix] sont les principaux éléments de transposition inverse 3x3 de ModelViewMatrix. </font><font style="vertical-align: inherit;">Cette structure est utilisée pour convertir le vecteur normal en coordonnées de l'espace d'observation.</font></font><br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=" rel="nofollow">Source</a> </blockquote><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... in vec2 p3d_MultiTexCoord0; // ... out vec2 normalCoord; // ... normalCoord = p3d_MultiTexCoord0; // ...</span></span></code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/b40/f21/575/b40f21575482aa633de61643a1c497aa.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Nous devons également sortir les coordonnées UV de la carte normale dans le fragment shader. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Shader de fragment </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rappelons que le sommet normal a été utilisé pour calculer l'éclairage. </font><font style="vertical-align: inherit;">Cependant, pour calculer l'éclairage, la carte normale nous donne d'autres normales. </font><font style="vertical-align: inherit;">Dans le fragment shader, nous devons remplacer les normales des sommets par les normales situées dans la carte normale.</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// ... uniform sampler2D p3d_Texture0; // ... in vec2 normalCoord; // ... /* Find */ vec4 normalTex = texture(p3d_Texture0, normalCoord); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> En utilisant les coordonnées de la carte normale transférées par le vertex shader, nous extrayons la normale correspondante de la carte. </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... vec3 normal; // ... /* Unpack */ normal = normalize ( normalTex.rgb * 2.0 - 1.0 ); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ci-dessus, j'ai montré comment les normales sont converties en couleurs pour créer des cartes normales. </font><font style="vertical-align: inherit;">Maintenant, nous devons inverser ce processus afin que les normales d'origine soient intégrées à la carte.</font></font><br><br><pre> <code class="cpp hljs">[ r, g, b] = [ r * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>, g * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>, b * <span class="hljs-number"><span class="hljs-number">2</span></span> - <span class="hljs-number"><span class="hljs-number">1</span></span>] = [ x, y, z]</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Voici à quoi ressemble le processus de décompression des normales de la carte normale. </font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-comment"><span class="hljs-comment">// ... /* Transform */ normal = normalize ( mat3 ( tangent , binormal , vertexNormal ) * normal ); // ...</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Les normales obtenues à partir de la carte normale sont généralement dans l'espace tangent. </font><font style="vertical-align: inherit;">Cependant, ils peuvent être dans un autre espace. </font><font style="vertical-align: inherit;">Par exemple, Blender vous permet de faire cuire des normales dans l'espace tangent, l'espace objet, l'espace monde et l'espace caméra.</font></font><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/009/cfc/62c/009cfc62c03b455a1e22b68e8636e735.gif"></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pour transférer la normale de la carte normale de l'espace tangent à l'espace de visualisation, créez une matrice 3x3 basée sur le vecteur tangent, les vecteurs binormaux et la normale du sommet. </font><font style="vertical-align: inherit;">Multipliez la normale par cette matrice et normalisez-la. </font><font style="vertical-align: inherit;">C'est là que nous nous sommes retrouvés avec les normales. </font><font style="vertical-align: inherit;">Tous les autres calculs d'éclairage sont toujours effectués.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Code source </font></font></h3><br><ul><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">main.cxx</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.vert</font></font></a> </li><li> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">base.frag</font></font></a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr453300/">https://habr.com/ru/post/fr453300/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr453290/index.html">Data Science Digest (mai 2019)</a></li>
<li><a href="../fr453292/index.html">"Un petit livre sur les trous noirs"</a></li>
<li><a href="../fr453294/index.html">Réagir Chargement paresseux</a></li>
<li><a href="../fr453296/index.html">Gérer l'asynchronie en PHP: des promesses aux coroutines</a></li>
<li><a href="../fr453298/index.html">Été: temps de mise à niveau ... vous</a></li>
<li><a href="../fr453302/index.html">La première heure de vie avec Yandex.Module</a></li>
<li><a href="../fr453304/index.html">Avantages clés de Zextras PowerStore</a></li>
<li><a href="../fr453306/index.html">Kubernetes prendra le contrôle du monde. Quand et comment?</a></li>
<li><a href="../fr453310/index.html">Échangez des données entre les composants React à l'aide de la bibliothèque RxJS</a></li>
<li><a href="../fr453312/index.html">Générateur d'e-mails professionnels PDF basé sur des données XML</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>