<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>💆🏿 🚅 👨🏾‍🏭 Chaos de dépendance Python 💰 🧕🏼 🧑🏼‍🤝‍🧑🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Connaissez-vous l'histoire de l'emballage Python? Naviguez-vous dans des formats de paquets? Savez-vous que vous devrez démêler l'enchevêtrement des d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Chaos de dépendance Python</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/483920/"> Connaissez-vous l'histoire de l'emballage Python?  Naviguez-vous dans des formats de paquets?  Savez-vous que vous devrez démêler l'enchevêtrement des dépendances même s'il semble que ce soit un miracle - zéro dépendance?  Je suis sûr qu'ils ne sont pas aussi familiers avec tout cela que l'auteur de la bibliothèque DepHell. <br><br><img src="https://habrastorage.org/webt/zp/dv/ao/zpdvaohc2qflukqaxxduyl7rxmu.png"><br><br>  J'ai réussi à parler à <b>Nikita Voronov</b> , mieux connu sous le nom de Gram ou <a href="https://habr.com/ru/users/orsinium/" class="user_link">orsinium</a> , et à lui poser des questions sur le sujet du futur rapport, les douleurs des mauvaises décisions de résolution des dépendances, DepHell, pip, le principe du premier match l'emporte, Guido, Pipfile, le développement incrémentiel Python et l'avenir de l'écosystème. <br><a name="habracut"></a><br>  <b>- Chez Moscow Python Conf ++, vous parlerez des dépendances et de tout ce qui est à côté d'eux.</b>  <b>Pourquoi avez-vous choisi un tel sujet pour le rapport?</b> <br><br>  Parce que cette question passe par toute mon expérience avec Python.  Quand j'ai fait mon premier paquet, écrit le premier code, j'ai pensé à comment aider d'autres personnes afin qu'elles puissent l'installer, et j'ai fait setup.py.  Puis il a travaillé dans une entreprise, dans une autre, dans une troisième, la tâche a été compliquée et développée.  Au début, il n'y avait qu'un fichier requirements.txt, puis j'ai réalisé que je devais corriger les dépendances, pip-tools, un fichier de verrouillage est apparu.  Plus tard, nous avons eu Pipenv, puis Poetry. <br><br>  Petit à petit, de plus en plus de problèmes s'ouvraient, je m'enfonçais de plus en plus dans ce chaos.  En conséquence, j'ai commencé à implémenter <a href="https://github.com/dephell/dephell">DepHell</a> , un projet de gestion des dépendances qui peut les résoudre et les lire dans un format différent.  Alors que je travaillais avec toutes sortes de formats, j'en avais vu assez de l'intérieur et maintenant je sais combien est organisé à l'intérieur, mais chaque jour j'apprends quelque chose de nouveau.  Par conséquent, je peux vous dire beaucoup de choses intéressantes sur la douleur et les mauvaises décisions. <br><br>  <b>- La douleur est toujours intéressante.</b>  <b>Selon vous, quels sont les problèmes en ce moment dans cette partie de Python?</b> <br><br>  JS a un répertoire <code>node_modules</code> , et chaque dépendance a ses propres dépendances empilées à l'intérieur.  En Python, ce n'est pas le cas.  Par exemple, un package est installé dans le même environnement et tous les packages qui l'utilisent utilisent la même version de ce package.  Pour ce faire, vous devez résoudre correctement les dépendances - choisissez la version de ce package qui satisfera généralement tous les packages de cet environnement.  La tâche n'est pas anodine: les packages dépendent les uns des autres, tout est entrelacé et la résolution des dépendances est difficile.  Il n'y a pratiquement pas de résolveurs en Python.  Le résolveur intelligent est uniquement en Poésie et DepHell. <br><br>  Tout cela est grandement compliqué par le fait que pypi.org ne fournit souvent pas d'informations sur les dépendances des packages, car ces informations doivent être spécifiées par le client, le serveur PyPI ne peut pas le comprendre par lui-même.  Par conséquent, lorsque PyPI indique que le package n'a pas de dépendances, vous ne pouvez pas lui faire confiance.  Vous devez télécharger l'intégralité de la version, décompresser et analyser les dépendances du package à partir de setup.py.  C'est un long processus, donc le résolveur en Python ne peut pas être rapide. <br><br><blockquote>  Non seulement il y a peu de résolveurs en Python, mais ils sont également lents de par leur conception. </blockquote><br>  Dans mon <a href="https://conf.python.ru/moscow/2020/abstracts/6254">rapport,</a> je veux dire comment fonctionne la résolution DepHell: comment créer un graphique de dépendance, à quoi ressemble ce graphique, pourquoi la plupart des articles scientifiques se trouvent sur la façon de résoudre les dépendances et de travailler avec ce graphique.  Bien sûr, il existe des livres blancs sur la façon dont tout cela devrait fonctionner.  Les gens intelligents ont écrit des articles avec des algorithmes, mais le plus souvent, ils ne fonctionnent pas pour Python.  Par conséquent, je vais décrire comment je travaille avec la résolution des dépendances dans la pratique dans DepHell. <br><br>  <b>- J'entends souvent des programmeurs qu'ils utilisent pip, et tout fonctionne bien pour eux.</b>  <b>Que font-ils mal?</b> <br><br>  Ils ont de la chance, ils ne rencontrent pas de conflit de dépendances.  Bien que le problème puisse survenir lorsque vous placez seulement deux packages dans un environnement propre.  Récemment, il y a eu une version du package de couverture 5.0, et si vous spécifiez simplement les <code>pip install pytest-cov coveralls</code> , pip ira dans l'ordre et pour le premier package sélectionnera la dernière version de la couverture, à savoir 5.0.  Le principe du <b>premier match gagnant</b> fonctionne dans pip, donc même si la version n'est pas compatible avec le deuxième package, elle sera déjà corrigée pour le premier package.  Cette approche fonctionne souvent, mais pas toujours. <br><br>  De plus, il y a une question avec les environnements reproductibles.  Puisque pip met toujours la dernière version, les versions dans l'environnement local et en production peuvent différer.  Pour résoudre ce problème, il est habituel de corriger les dépendances.  Et lorsque les dépendances sont déjà corrigées, les versions spécifiques que pip doit installer sont indiquées, puis pip fonctionne déjà correctement.  Pip n'a pas de résolveur, mais il le fait quand quelqu'un d'autre résout des dépendances pour lui, comme DepHell ou Poetry. <br><br>  <b>- Pourquoi ce sujet gagne-t-il maintenant en pertinence, comme vous le pensez?</b>  <b>Pourquoi n’était-il rien arrivé avant, mais maintenant tout est parti, et même dans des directions différentes?</b> <br><br>  Premièrement, l'écosystème Python se développe.  Il y a plus de packages, ils doivent être installés plus, et beaucoup plus de problèmes apparaissent.  Deuxièmement, les problèmes de formats de fichiers existent depuis longtemps et sont discutés depuis longtemps. <br><br>  Setup.py est généralement impossible à analyser, il ne peut être exécuté.  Si nous voulons, par exemple, écrire un serveur dans Go pour distribuer rapidement des packages pour Python, nous ne pouvons pas simplement saisir et lire setup.py, car il s'agit d'un fichier exécutable.  En conséquence, pour l'exécuter, vous avez besoin de Python et d'un environnement complet, et souvent aussi pour que l'ensemble du projet se trouve à proximité et que certaines dépendances spécifiques soient installées.  Outre toutes ces difficultés, l'exécution de setup.py peut être dangereuse, car un autre code sera exécuté sur votre ordinateur.  En fait, il est même effrayant d'exécuter du code sous l'utilisateur actuel, car si, par exemple, il reçoit ma clé SSH privée et l'envoie quelque part, ce sera une grande tragédie. <br><br>  La deuxième option pour définir les dépendances, qui existe depuis longtemps et que tout le monde travaille avec elle, est requirements.txt.  Il est également presque impossible d'analyser de la même manière.  Pip peut, mais il le fait très, très difficile: les fonctions qui appellent les fonctions, les itérateurs, tout est mélangé.  De plus, pip peut lire certaines de ses clés dans requirements.txt, par exemple, un index à télécharger peut être spécifié.  Mais cela ne fonctionne pas avec toutes les clés. <br><br>  Ainsi, pour analyser requirements.txt, vous devez utiliser pip ou une solution tierce.  Toutes les solutions tierces sont essentiellement des fourchettes et utilisent une sorte d'hypothèses sur le fichier.  Tous les fichiers exigeants que pip peut lire ne pourront pas lire ces fourches. <br><br>  Pip lui-même n'est pas destiné à être utilisé comme bibliothèque.  Il s'agit d'un outil exclusivement CLI qui ne peut être utilisé qu'à partir de la console.  Tout le code source de pip est caché derrière <code>_internal</code> , et les développeurs disent directement: "Ne l'utilisez pas!".  Et chaque version rompt la compatibilité descendante.  Honnêtement, ils ne garantissent pas la compatibilité et peuvent changer quoi que ce soit à tout moment.  Et c'est ce qui se passe - chaque fois qu'une nouvelle version est livrée avec pip, je l'apprends à partir d'un CI cassé dans DepHell. <br><br>  <b>- Et dans d'autres langues?</b>  <b>Est-ce tout aussi mauvais là-bas, ou tous ces problèmes sont-ils résolus quelque part?</b> <br><br>  <b>Guido van Rossum</b> a <b>récemment</b> reçu le prix Dijkstra.  J'ai assisté à ses conférences et je lui ai posé des questions sur les dépendances de Python.  Guido a déclaré que la dépendance dans toutes les langues est le chaos, il essaie de ne pas entrer et fait confiance à la communauté pour résoudre ce problème. <br><br>  Ainsi, en Python, le travail avec les dépendances est progressivement organisé par la communauté.  De nouvelles solutions émergent.  Une fois Distutils construit en Python, les gens ont réalisé qu'il y avait beaucoup de problèmes, Setuptools.  <code>easy_Install</code> a ensuite été développé pour installer des packages, mais il a également rencontré des problèmes.  Pour les résoudre, créé pip.  Maintenant, pip a beaucoup de problèmes.  Ses sources changent constamment, il n'y a pas d'architecture, il n'y a pas du tout d'interface. <br><br>  La communauté essaie de trouver quelque chose.  Par exemple, il y a eu une longue discussion sur le problème appelé exigences 2.0 sur la façon de rendre les exigences compréhensibles à la fois pour les personnes (voici la version, voici les marqueurs) et par programmation à partir d'autres langues. <br><br><blockquote>  Ils ont créé un Pipfile, mais comme pip est très déroutant, ils ne pouvaient pas y ajouter le support Pipfile. </blockquote><br>  Les développeurs veulent bien sûr le faire.  Très probablement, un jour, ils le pourront, mais jusqu'à présent, pip ne peut pas prendre en charge Pipfile.  Par conséquent, nous avons fait pipenv pour fonctionner avec Pipfile et l'environnement virtuel, certains autres wrappers avec l'environnement.  Mais à Pipenv aussi, tout est mélangé et confus. <br><br>  Pour les autres langues, j'aime la façon dont la gestion des dépendances est implémentée dans Go.  Auparavant, il n'y avait pas de version, il y avait <code>go get</code> , dans lequel vous indiquiez à partir de quel référentiel quel package télécharger.  Du point de vue d'un débutant, c'est pratique: il suffit d'écrire <code>go get</code> et le package est déjà dans le système.  Et lorsque vous commencez à travailler avec Python, tout un tas de tout s'effondre: certaines versions, PyPI, pip, requirements.txt, setup.py, maintenant aussi Pipfile, Poetry, <code>__pymodules__</code> , etc. <br><br>  À mesure que Python évolue progressivement et avec l'aide de la communauté, l'héritage s'accumule dans l'écosystème.  Go était juste <code>go get</code> , mais encore une fois, le problème s'est posé que les dépendances devaient être corrigées afin que, en particulier, l'environnement soit reproductible. <br><br>  Un environnement jouable peut être créé à l'aide d'un conteneur Docker avec toutes les dépendances installées.  Mais parfois, vous devez mettre à jour les dépendances individuelles.  Par exemple, nous ne sommes peut-être pas prêts à tout mettre à jour, car le projet n'a pas suffisamment de tests pour prouver qu'après la mise à jour, tout fonctionne toujours.  Mais une certaine dépendance peut devoir être mise à jour, car, disons, une vulnérabilité y a été trouvée.  Pour ce faire, il vaut mieux ne pas avoir d'image docker, mais un fichier qui dit: "Installez une version spécifique d'un package spécifique". <br><br>  Il n'y avait rien de tel dans Go, et la marchandisation est apparue: toutes les dépendances ont été prises et placées dans un seul répertoire.  Il s'agit d'une sale solution, similaire à <code>node_modules</code> , qui dans Go est implémentée depuis un certain temps à l'aide de solutions tierces.  En Python, cette approche est également utilisée, par exemple, pip a un répertoire de <code>vendor</code> .  Lorsque vous installez pip, les dépendances ne sont pas créées, et vous pourriez penser que tout est très cool et qu'il n'y a aucune dépendance, mais en fait, elles sont toutes à l'intérieur du <code>vendor</code> . <br><br>  Il y a environ un an, go.mod (modules Go) est apparu dans Go.  Il s'agit d'un nouvel outil intégré, mais <code>go get</code> également pris en charge.  Le projet contient deux fichiers: <br><br><ul><li>  l'une décrit les dépendances avec lesquelles le projet travaille directement; </li><li>  l'autre est un fichier de verrouillage, qui décrit absolument toutes les dépendances et leurs versions spécifiques. </li></ul><br>  Ceci est une solution centralisée cool. <br><br>  Ce qui est important, ils insistent sur le fait que certaines choses doivent avoir une certaine apparence.  Par exemple, dans Go, la version doit être la version sémantique. <br><br>  Python a également une spécification sur l'apparence de la version.  Pour cela, il y a PEP 440. Mais, tout d'abord, la spécification est très compliquée: il y a non seulement trois composants de version (nombres), mais aussi la pré-version, la post-sortie et l'ère (lorsque la façon de versionner change).  Deuxièmement, le PEP 440 n'a pas été accepté immédiatement, ils y sont également venus progressivement, par conséquent, la version héritée est prise en charge, ce qui signifie que tout peut être utilisé comme version - n'importe quelle ligne comme «Bonjour tout le monde!». <br><br>  <b>- Vous avez dit que la communauté développe la langue progressivement, donc il y a un grand nombre de solutions.</b>  <b>Mais pourquoi ne pas se débarrasser de toutes ces ordures?</b>  <b>Pourquoi ne pas jeter les Distutils, abandonner les anciens et inutiles que personne n'utilise, et plutôt introduire activement de nouvelles pratiques et de nouveaux outils?</b> <br><br>  Maintenir tout cela a du sens, afin que vous puissiez toujours installer les anciens packages.  Il est impossible d'insister sur la nécessité de le faire, et non autrement, car la décision est prise par la communauté.  Aucun des développeurs de Core Python ne vient dire: «Ça y est, nous faisons tout maintenant, et pas de clous.» <br><br>  Go a tout ce dont vous avez besoin pour travailler avec les dépendances tout de suite.  En Python, vous devez tout réinstaller de l'extérieur et vous devez toujours comprendre quoi exactement.  Le plus souvent, pip suffit, mais maintenant d'autres options apparaissent. <br><br>  Sur le site avec les recommandations de package officielles de la Python Packaging Authority, le groupe qui fabrique pip, pipenv, PyPI, il est écrit pour utiliser pipenv.  Avec pipenv, c'est une autre histoire.  Premièrement, sa résolution est médiocre.  Deuxièmement, il n'y a pas eu de sortie depuis très longtemps et la communauté attend déjà que les créateurs admettent honnêtement que ce projet est mort.  Le troisième problème avec pipenv est qu'il ne convient qu'aux projets, mais pas aux packages: vous pouvez spécifier les dépendances du projet dans pipenv, mais vous ne pouvez pas spécifier son nom, sa version et, par conséquent, le placer dans un package à télécharger sur PyPI.  Il s'avère que suivre les recommandations de Python Packaging Authority et utiliser pipenv n'est toujours pas suffisant pour le comprendre. <br><br>  La poésie essaie d'être révolutionnaire.  Il ne génère essentiellement pas le fichier setup.py, ce qui serait utile pour la compatibilité descendante, car Poetry veut être le nouveau et le seul format pour tout.  Il sait comment collecter les packages, et il a un fichier de verrouillage, qui est nécessaire pour les projets.  Néanmoins, la poésie a beaucoup de choses étranges, de nombreuses fonctionnalités familières ne sont pas prises en charge. <br><br>  <b>- Selon vous, quel est l'avenir de l'écosystème en termes de travail avec les dépendances?</b>  <b>Votre prédiction.</b> <br><br>  Tout va plus ou moins mieux.  Par exemple, j'ai vu un poste vacant à pip, et un développeur qui le met en ordre se voit promettre beaucoup d'argent.  Peut-être que pip deviendra une solution plus universelle.  Mais vous avez besoin de quelqu'un pour le prendre au sérieux: venez dire que nous le faisons de cette façon, maintenant nous suivons un PEP plus strict et insisterons dessus (parce que le PEP n'est que des recommandations que personne en fait pas obligé de suivre). <br><br>  Par exemple, nous avions une telle histoire: une certaine version de PyYAML était verrouillée dans le fichier de verrouillage.  Un jour les tests sur CI passent, nous déployons en production, et tout y tombe, car la version PyYAML est introuvable.  Le fait est que la version verrouillée a été supprimée de pypi.org.  Tout le monde était indigné, a mis à jour le fichier de verrouillage, a survécu, mais les sédiments sont restés. <br><br>  Il n'y a pas si longtemps, le PEP 592 est apparu; il a déjà été adopté et est maintenu dans le pip, dans lequel des rejets en yank sont apparus.  Yank signifie que la version n'a pas encore été complètement supprimée de pypi.org - elle est cachée.  En d'autres termes, si vous spécifiez que vous avez besoin, par exemple, d'une version PyYAML supérieure à 3.0, pip ignorera les versions copiées et installera la dernière version disponible.  Mais si une version spécifique est indiquée dans le fichier de verrouillage, et que cette version est yank, pip l'installera quand même.  Ainsi, verrouiller les fichiers et déployer ne se cassera pas, mais, si possible, l'ancienne version ne sera pas utilisée. <br><br>  La deuxième chose intéressante est le PEP pour <code>__pymodules__</code> .  Ce sont des environnements virtuels légers: vous ouvrez le répertoire du projet, écrivez <code>pip install</code> PyYAML, et PyYAML n'est pas installé globalement, mais dans le répertoire <code>__pymodules__</code> .  Lorsque Python démarre dans ce répertoire, il importe PyYAML non pas globalement, mais à partir de ce répertoire. <br><br>  J'appelle cela des environnements virtuels au minimum, car il y a moins d'isolement.  Par exemple, il n'y a pas d'accès aux fichiers binaires.  Lorsqu'un environnement virtuel avec pytest installé est activé, il peut être utilisé à partir de la console: il suffit d'écrire pytest et de faire quelque chose.  Avec <code>__pymodules__</code> seront disponibles pour l'importation, mais pas les binaires, car ils ne seront pas réellement installés. <br><br>  Ce PEP est conçu pour le rendre facile pour les débutants.  Pour qu'ils n'aient pas à gérer toutes les subtilités des environnements virtuels, mais installez simplement tout ce dont vous avez besoin dans <code>__pymodules__</code> via pip install. <br><br>  <b>- Eh bien, l'avenir de vos prévisions est plus brillant que maintenant.</b> <br><br>  Oui, mais comme je l'ai dit, si personne ne vient et dit que nous refaisons et essayons de jeter l'héritage, alors les problèmes resteront.  Maintenant, nous accumulons et accumulons des outils, et il sera impossible de s'en débarrasser complètement dans un avenir proche. <br><br>  <b>- Que pensez-vous, pourquoi aucun des développeurs ne peut mettre à jour les dépendances Presque partout - ni dans les entreprises ni dans l'open source - le processus de travail avec les versions de sécurité, en principe, avec de nouvelles versions mineures ou majeures, a été construit.</b>  <b>Où voyez-vous les problèmes ici?</b> <br><br>  Au minimum, lorsque vous souhaitez mettre à jour des dépendances, il est effrayant de mettre à jour toutes les dépendances, car ce n'est pas un fait que même si les tests réussissent, tout fonctionnera.  Par exemple, cette situation se produit souvent avec le céleri, car le céleri ne peut pas être entièrement testé dans les tests.  Vous pouvez verrouiller quelque chose, simplifier quelque chose, mais le fait que les travailleurs s'exécutent ne peut pas être vérifié. <br><br>  Go work with tests est bien implémenté, même dans les tutoriels Go Modules il est écrit comment mettre à jour les dépendances: vous mettez à jour certaines dépendances et exécutez des tests.  De plus, les tests s'exécutent non seulement sur le vôtre, mais aussi sur cette dépendance. <br><br>  Un aspect intéressant mérite encore d'être mentionné: les tests devraient-ils être dans des packages en Python?  Lorsque vous téléchargez un package sur pypi.org, doit-il y avoir des tests?  En théorie, ils devraient, et même avoir un mécanisme pour les exécuter: dans setup.py, vous pouvez spécifier comment exécuter les tests, quelles dépendances ils ont. <br><br>  Mais, premièrement, de nombreuses personnes ne savent pas comment les exécuter et n'exécutent pas de tests dépendants.  Par conséquent, ils ne sont souvent pas nécessaires.  Deuxièmement, souvent ces tests ont des montages très difficiles, et donc inclure des tests dans un package signifie rendre le package 6 à 10 fois plus grand. <br><br>  Ce serait formidable de pouvoir télécharger un package avec des tests et sans tests.  Mais maintenant, il n'y a pas une telle possibilité, donc les tests ne s'additionnent souvent pas dans les packages.  Il y a le chaos, et je ne sais même pas s'il est possible d'exécuter des tests de ces dépendances lors de la mise à jour des dépendances. <br><br>  Cet aspect semble être largement ignoré.  Mais dans certaines autres langues, en particulier, Go est considéré comme une bonne pratique, en mettant à jour un package dans l'environnement, exécutez immédiatement des tests pour s'assurer que ce package fonctionne correctement dans cet environnement. <br><br>  <b>- Pourquoi, à votre avis, en Python, les outils de versioning sémantique automatique ne sont pas populaires?</b> <br><br>  Je pense que l'un des problèmes est que la version peut être décrite à de nombreux endroits.  Le plus souvent, il en existe trois: le format de description des métadonnées du projet (pypi.org, poety, setup.py, etc.), à l'intérieur du projet lui-même et dans la documentation.  La mise à niveau d'une version à trois endroits n'est pas très difficile, mais facile à oublier. <br><br>  DepHell a une équipe pour les mises à niveau de version.  DepHell      , ,        .    semantic version, compatible version  ..  <a href="https://dephell.readthedocs.io/cmd-project-bump.html"></a> ,    ,    . <br><br>      Flit. Flit —          ,      .    : <code>init</code> , <code>build</code> , <code>publish</code>  <code>install</code> .     ,  ,   PyPI     —   .  Flit      ,        .       docstring  .       ,    . <br><br> DepHell     Flit   .        description,   ,   ,       . <br><br><blockquote>  ,      . </blockquote><br>  DepHell      <code>import</code> ,   ,   , ,        .           ,    ,    . <br><br><blockquote>    ,      <a href="https://conf.python.ru/moscow/2020">Moscow Python Conf++</a> 27 .  DepHell    backend, web,    , AI/ML, , DevOps,  , IoT, infosec      . , <a href="http://conf.ontico.ru/conference/join/mpc2020.html"> </a> ,   Moscow Python Conf++. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr483920/">https://habr.com/ru/post/fr483920/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr483910/index.html">Théorie de l'information visuelle (partie 1)</a></li>
<li><a href="../fr483912/index.html">Quelles sont les nouveautés à attendre de YouTrack en 2020?</a></li>
<li><a href="../fr483914/index.html">Nous vous invitons à DINS JavaScript EVENING: nous parlons de la conception de l'API et résolvons les problèmes à l'aide de types de données algébriques</a></li>
<li><a href="../fr483916/index.html">DJI n'a pas été en mesure de patcher les applications DJI Fly pour Android 10 depuis un mois maintenant</a></li>
<li><a href="../fr483918/index.html">Formation en entreprise: les leaders enseignent aux leaders</a></li>
<li><a href="../fr483922/index.html">Maison intelligente sur roues ... Alice</a></li>
<li><a href="../fr483930/index.html">6 projets de développement Web GitHub qui valent le détour</a></li>
<li><a href="../fr483934/index.html">Autorisations de fichiers Linux</a></li>
<li><a href="../fr483936/index.html">Conférence sur le développement de jeux</a></li>
<li><a href="../fr483938/index.html">Nakamichi: à propos des dieux de l'ère de la cassette et des temps où le soleil levant brillait plus fort</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>