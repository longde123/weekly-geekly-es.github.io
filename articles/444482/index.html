<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚Äçüéì üïü üíí ¬øQu√© infla la memoria en Ruby? üôà üë©üèª‚Äçü§ù‚Äçüë®üèº ü§≥üèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nosotros en Phusion tenemos un simple proxy HTTP multiproceso en Ruby (distribuye paquetes DEB y RPM). Vi en √©l un consumo de memoria de 1.3 GB. Pero ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¬øQu√© infla la memoria en Ruby?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444482/">  Nosotros en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Phusion tenemos</a> un simple proxy HTTP multiproceso en Ruby (distribuye paquetes DEB y RPM).  Vi en √©l un consumo de memoria de 1.3 GB.  Pero esto es una locura para un proceso sin estado ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ba/f7a/d2b/9baf7ad2bd3ecdfb0779482c018473eb.jpg"></div><br>  <i><font color="gray">Pregunta: ¬øQu√© es?</font></i>  <i><font color="gray">Respuesta: ¬°Ruby usa la memoria con el tiempo!</font></i> <br><br>  Resulta que no estoy solo en este problema.  Las aplicaciones de Ruby pueden usar mucha memoria.  Pero por que?  Seg√∫n <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Heroku</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nate Burkopek</a> , la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hinchaz√≥n</a> se debe principalmente a la fragmentaci√≥n de la memoria y la distribuci√≥n excesiva del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">mont√≥n</a> . <br><a name="habracut"></a><br>  Berkopek concluy√≥ que hay dos soluciones: <br><br><ol><li>  Utilice un asignador de memoria completamente diferente al glibc, generalmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">jemalloc</a> , o: </li><li> Establezca la variable de entorno m√°gico <code>MALLOC_ARENA_MAX=2</code> . </li></ol><br>  Me preocupa la descripci√≥n del problema y las soluciones propuestas.  Hay algo mal aqu√≠ ... No estoy seguro de que el problema est√© completamente descrito correctamente o de que estas sean las √∫nicas soluciones disponibles.  Tambi√©n me molesta que muchos se refieran a jemalloc como una piscina m√°gica de plata. <br><br>  <b>La magia es solo una ciencia que a√∫n no entendemos</b> .  As√≠ que hice un viaje de investigaci√≥n para descubrir toda la verdad.  Este art√≠culo cubrir√° los siguientes temas: <br><br><ol><li>  C√≥mo funciona la asignaci√≥n de memoria. <br></li><li>  ¬øQu√© es esta "fragmentaci√≥n" y "distribuci√≥n excesiva" de memoria de la que todos est√°n hablando? <br></li><li>  ¬øQu√© causa un gran consumo de memoria?  ¬øLa situaci√≥n es consistente con lo que dice la gente o hay algo m√°s?  (spoiler: s√≠, hay algo m√°s). <br></li><li>  ¬øHay alguna soluci√≥n alternativa?  (spoiler: encontr√© uno). </li></ol><br>  <i>Nota: este art√≠culo es relevante solo para Linux, y solo para aplicaciones de Ruby multiproceso.</i> <br><br><h1>  Contenido </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Asignaci√≥n de memoria rub√≠: una introducci√≥n</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rub√≠</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Asignador de memoria del sistema</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El n√∫cleo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Definici√≥n de uso de memoria</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬øQu√© es la fragmentaci√≥n?</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fragmentaci√≥n de nivel rub√≠</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fragmentaci√≥n de asignaci√≥n de memoria</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬øLa fragmentaci√≥n de la p√°gina del mont√≥n de Ruby est√° causando una hinchaz√≥n de memoria?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Estudio de fragmentaci√≥n de asignaci√≥n de memoria</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Asignaci√≥n de memoria excesiva y glibc</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Visualizaci√≥n de montones de sistema.</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Truco de magia: circuncisi√≥n</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conclusi√≥n</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥digo fuente del visualizador</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¬øQu√© pasa con el rendimiento?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Necesito m√°s pruebas</a> </li></ul></li></ul><br><a name="1"></a><h1>  Asignaci√≥n de memoria rub√≠: una introducci√≥n </h1><br>  Ruby asigna memoria a tres niveles, de arriba a abajo: <br><br><ol><li>  Int√©rprete de Ruby que gestiona objetos Ruby. <br></li><li>  La biblioteca del asignador de memoria del sistema operativo. <br></li><li>  El n√∫cleo </li></ol><br>  Veamos cada nivel. <br><br><a name="1_1"></a><h3>  Rub√≠ </h3><br>  Por su parte, Ruby organiza objetos en √°reas de memoria llamadas <i>p√°ginas de mont√≥n Ruby</i> .  Tal p√°gina de mont√≥n se divide en ranuras del mismo tama√±o, donde un objeto ocupa una ranura.  Ya sea una cadena, una tabla hash, una matriz, una clase u otra cosa, ocupa una ranura. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d6/155/0be/2d61550be208df42ad3052ca1f821807.png"></div><br><br>  Los espacios en la p√°gina del mont√≥n pueden estar ocupados o libres.  Cuando Ruby selecciona un nuevo objeto, inmediatamente trata de ocupar un espacio libre.  Si no hay espacios libres, se resaltar√° una nueva p√°gina de mont√≥n. <br><br>  La ranura es peque√±a, de unos 40 bytes.  Obviamente, algunos objetos no caben en √©l, por ejemplo, l√≠neas de 1 MB.  Luego, Ruby almacena la informaci√≥n en otro lugar fuera de la p√°gina del mont√≥n y coloca un puntero a esta √°rea de memoria externa en la ranura. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e5/e96/1c6/1e5e961c6c90ed1cd17daa8ab19d8212.png"></div><br>  <i><font color="gray">Los datos que no caben en la ranura se almacenan fuera de la p√°gina del mont√≥n.</font></i>  <i><font color="gray">Ruby coloca un puntero a estos datos externos en la ranura</font></i> <br><br>  Tanto las p√°ginas de almacenamiento din√°mico de Ruby como cualquier √°rea de memoria externa se asignan utilizando el asignador de memoria del sistema. <br><br><a name="1_2"></a><h3>  Asignador de memoria del sistema </h3><br>  El asignador de memoria del sistema operativo es parte de glibc (tiempo de ejecuci√≥n C).  Es utilizado por casi todas las aplicaciones, no solo Ruby.  Tiene una API simple: <br><br><ul><li>  La memoria se asigna llamando a <code>malloc(size)</code> .  Le da el n√∫mero de bytes que desea asignar y devuelve la direcci√≥n de asignaci√≥n o un error. </li><li>  La memoria asignada se libera llamando <code>free(address)</code> . </li></ul><br>  A diferencia de Ruby, donde se asignan ranuras del mismo tama√±o, el asignador de memoria se ocupa de las solicitudes de asignaci√≥n de memoria de cualquier tama√±o.  Como aprender√° m√°s adelante, este hecho conduce a algunas complicaciones. <br><br>  A su vez, el asignador de memoria accede a la API del n√∫cleo.  El n√∫cleo requiere fragmentos de memoria mucho m√°s grandes que los que solicitan sus propios suscriptores, ya que la llamada del n√∫cleo es costosa y la API del n√∫cleo tiene una limitaci√≥n: solo puede asignar memoria en m√∫ltiplos de 4 KB. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/323/dba/21a/323dba21a7b5ad2df8e1f9335d6b7c11.png"></div><br>  <i><font color="gray">El asignador de memoria asigna fragmentos grandes (se denominan montones del sistema) y comparte su contenido para satisfacer las solicitudes de las aplicaciones.</font></i> <br><br>  El √°rea de memoria que el asignador de memoria asigna desde el n√∫cleo se denomina mont√≥n.  Tenga en cuenta que no tiene nada que ver con las p√°ginas del mont√≥n Ruby, por lo que, para mayor claridad, usaremos el t√©rmino <i>mont√≥n del sistema</i> . <br><br>  El asignador de memoria luego asigna partes de los montones del sistema a sus llamantes hasta que haya espacio libre.  En este caso, el asignador de memoria asigna un nuevo mont√≥n de sistema desde el n√∫cleo.  Esto es similar a c√≥mo Ruby selecciona objetos de las p√°ginas de un mont√≥n de Ruby. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/453/f81/c11/453f81c11aaadb818ecdcf798112db99.png"></div><br>  <i><font color="gray">Ruby asigna memoria del asignador de memoria, que a su vez asigna memoria del n√∫cleo</font></i> <br><br><a name="1_3"></a><h3>  El n√∫cleo </h3><br>  El n√∫cleo solo puede asignar memoria en unidades de 4 KB.  Uno de esos bloques 4K se llama p√°gina.  Para evitar confusiones con las p√°ginas del mont√≥n Ruby, para mayor claridad, utilizaremos el t√©rmino <i>p√°gina del sistema</i> ( <i>p√°gina del sistema</i> operativo). <br><br>  La raz√≥n es dif√≠cil de explicar, pero as√≠ es como funcionan todos los n√∫cleos modernos. <br><br>  La asignaci√≥n de memoria a trav√©s del n√∫cleo tiene un impacto significativo en el rendimiento, raz√≥n por la cual los asignadores de memoria intentan minimizar la cantidad de llamadas al n√∫cleo. <br><br><a name="1_4"></a><h3>  Definici√≥n de uso de memoria </h3><br>  Por lo tanto, la memoria se asigna a varios niveles, y cada nivel asigna m√°s memoria de la que realmente necesita.  Las p√°ginas de mont√≥n de Ruby pueden tener espacios libres, as√≠ como montones de sistema.  Por lo tanto, la respuesta a la pregunta "¬øCu√°nta memoria se usa?"  ¬°depende completamente del nivel que pidas! <br><br>  Herramientas como <code>top</code> o <code>ps</code> muestran el uso de memoria desde la perspectiva del <b>kernel</b> .  Esto significa que los niveles superiores deben funcionar en concierto para liberar memoria desde el punto de vista del n√∫cleo.  Como aprender√° m√°s tarde, esto es m√°s dif√≠cil de lo que parece. <br><br><a name="2"></a><h1>  ¬øQu√© es la fragmentaci√≥n? </h1><br>  La fragmentaci√≥n de la memoria significa que las asignaciones de memoria se dispersan aleatoriamente.  Esto puede causar problemas interesantes. <br><br><a name="2_1"></a><h3>  Fragmentaci√≥n de nivel rub√≠ </h3><br>  Considere la recolecci√≥n de basura de Ruby.  La recolecci√≥n de basura para un objeto significa marcar el espacio de la p√°gina del mont√≥n Ruby como libre, lo que permite su reutilizaci√≥n.  Si toda la p√°gina del mont√≥n de Ruby consta solo de ranuras libres, entonces toda su p√°gina se puede volver a liberar al asignador de memoria (y, posiblemente, de vuelta al n√∫cleo). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27b/cde/97d/27bcde97d27e6aeed3dc2020a4eda766.png"></div><br><br>  Pero, ¬øqu√© sucede si no todas las m√°quinas tragamonedas son gratuitas?  ¬øQu√© pasa si tenemos muchas p√°ginas del mont√≥n de Ruby, y el recolector de basura libera objetos en diferentes lugares, de modo que al final hay muchos espacios libres, pero en diferentes p√°ginas?  En esta situaci√≥n, Ruby tiene ranuras libres para colocar objetos, ¬°pero el asignador de memoria y el n√∫cleo continuar√°n asignando memoria! <br><br><a name="2_2"></a><h3>  Fragmentaci√≥n de asignaci√≥n de memoria </h3><br>  El asignador de memoria tiene un problema similar pero completamente diferente.  No necesita borrar inmediatamente los montones de todo el sistema.  Te√≥ricamente, puede liberar cualquier p√°gina del sistema.  Pero dado que el asignador de memoria trata con asignaciones de memoria de tama√±o arbitrario, puede haber varias asignaciones en la p√°gina del sistema.  No puede liberar la p√°gina del sistema hasta que se liberen todas las selecciones. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/76b/723/850/76b72385026fa24bd18b7db324d7353b.png"></div><br><br>  Piense en lo que sucede si tenemos una asignaci√≥n de 3 KB, as√≠ como una asignaci√≥n de 2 KB, dividida en dos p√°ginas del sistema.  Si libera los primeros 3 KB, ambas p√°ginas del sistema permanecer√°n parcialmente ocupadas y no podr√°n liberarse. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc2/cf1/70f/cc2cf170facbc6bca673014e33389606.png"></div><br><br>  Por lo tanto, si las circunstancias fallan, habr√° mucho espacio libre en las p√°ginas del sistema, pero no se liberar√°n por completo. <br><br>  Peor a√∫n: ¬øqu√© pasa si hay muchos lugares libres, pero ninguno de ellos es lo suficientemente grande como para satisfacer una nueva solicitud de asignaci√≥n?  El asignador de memoria tendr√° que asignar un mont√≥n de sistema completamente nuevo. <br><br><a name="3"></a><h1>  ¬øLa fragmentaci√≥n de la p√°gina del mont√≥n de Ruby est√° causando una hinchaz√≥n de memoria? </h1><br>  Es probable que la fragmentaci√≥n est√© causando un uso excesivo de la memoria en Ruby.  Si es as√≠, ¬øcu√°l de las dos fragmentaciones es m√°s da√±ina?  Esto es ... <br><br><ol><li>  ¬øFragmentaci√≥n de la p√°gina del mont√≥n de rub√≠es?  O <br></li><li>  ¬øFragmentaci√≥n del asignador de memoria? </li></ol><br>  La primera opci√≥n es bastante simple de verificar.  Ruby proporciona dos API: <code>ObjectSpace.memsize_of_all</code> y <code>GC.stat</code> .  Gracias a esta informaci√≥n, puede calcular toda la memoria que recibi√≥ Ruby del asignador. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb8/f7e/30e/cb8f7e30e363d2fa57f0fc37b84183fe.png"></div><br><br>  <code>ObjectSpace.memsize_of_all</code> devuelve la memoria ocupada por todos los objetos Ruby activos.  Es decir, todo el espacio en sus ranuras y cualquier dato externo.  En el diagrama anterior, este es el tama√±o de todos los objetos azules y naranjas. <br><br>  <code>GC.stat</code> permite averiguar el tama√±o de todas las ranuras libres, es decir, el √°rea gris completa en la ilustraci√≥n de arriba.  Aqu√≠ est√° el algoritmo: <br><br><pre> <code class="cpp hljs">GC.stat[:heap_free_slots] * GC::INTERNAL_CONSTANTS[:RVALUE_SIZE]</code> </pre> <br>  Para resumirlos, este es todo el recuerdo que conoce Ruby, e implica fragmentar las p√°ginas del mont√≥n de Ruby.  Si, desde el punto de vista del kernel, el uso de memoria es mayor, entonces la memoria restante va a alg√∫n lugar fuera del control de Ruby, por ejemplo, a bibliotecas o fragmentaci√≥n de terceros. <br><br>  Escrib√≠ un programa de prueba simple que crea un mont√≥n de hilos, cada uno de los cuales selecciona l√≠neas en un bucle.  Aqu√≠ est√° el resultado despu√©s de un tiempo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4e/859/2fc/a4e8592fc1d2edf2f11957844d33e55d.png"></div><br><br>  es ... solo ... loco! <br><br>  El resultado muestra que Ruby tiene un efecto tan d√©bil en la cantidad total de memoria utilizada, no importa si las p√°ginas del mont√≥n de Ruby est√°n fragmentadas o no. <br><br>  Hay que buscar al culpable en otra parte.  Al menos ahora sabemos que Ruby no tiene la culpa. <br><br><a name="4"></a><h1>  Estudio de fragmentaci√≥n de asignaci√≥n de memoria </h1><br>  Otro sospechoso probable es un asignador de memoria.  Al final, Nate Berkopek y Heroku notaron que preocuparse por el asignador de memoria (ya sea un reemplazo completo para jemalloc o establecer la variable de entorno m√°gico <code>MALLOC_ARENA_MAX=2</code> ) reduce dr√°sticamente el uso de memoria. <br><br>  Primero veamos qu√© hace <code>MALLOC_ARENA_MAX=2</code> y por qu√© ayuda.  Luego examinamos la fragmentaci√≥n a nivel del distribuidor. <br><br><a name="4_1"></a><h3>  Asignaci√≥n de memoria excesiva y glibc </h3><br>  La raz√≥n por la que <code>MALLOC_ARENA_MAX=2</code> ayuda es <code>MALLOC_ARENA_MAX=2</code> subprocesamiento <code>MALLOC_ARENA_MAX=2</code> .  Cuando varios subprocesos intentan simult√°neamente asignar memoria desde el mismo mont√≥n de sistema, luchan por el acceso.  Solo un subproceso a la vez puede recibir memoria, lo que reduce el rendimiento de la asignaci√≥n de memoria de subprocesos m√∫ltiples. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a40/99c/65b/a4099c65b73541efa05c38008fa0e181.png"></div><br>  <i><font color="gray">Solo un subproceso a la vez puede funcionar con el mont√≥n del sistema.</font></i>  <i><font color="gray">En tareas de subprocesos m√∫ltiples, surge un conflicto y, en consecuencia, el rendimiento disminuye</font></i> <br><br>  En el asignador de memoria para tal caso hay optimizaci√≥n.  Intenta crear varios montones de sistema y asignarlos a diferentes subprocesos.  La mayor√≠a de las veces un subproceso solo funciona con su propio mont√≥n, evitando conflictos con otros subprocesos. <br><br>  De hecho, el n√∫mero m√°ximo de montones de sistemas asignados de esta manera es por defecto igual al n√∫mero de procesadores virtuales multiplicado por 8. Es decir, en un sistema de doble n√∫cleo con dos hiperprocesos, ¬°cada uno produce <code>2 * 2 * 8 = 32</code> montones de sistemas!  Esto es lo que yo llamo <b>distribuci√≥n excesiva</b> . <br><br>  ¬øPor qu√© es tan grande el multiplicador predeterminado?  Porque el desarrollador l√≠der del asignador de memoria es Red Hat.  Sus clientes son grandes empresas con servidores potentes y una tonelada de RAM.  La optimizaci√≥n anterior le permite aumentar el rendimiento promedio de subprocesos m√∫ltiples en un 10% debido a un aumento significativo en el uso de la memoria.  Para los clientes de Red Hat, este es un buen compromiso.  Para la mayor√≠a del resto, apenas. <br><br>  Nate en su blog y en el art√≠culo de Heroku afirman que aumentar la cantidad de montones de sistemas aumenta la fragmentaci√≥n y citan documentaci√≥n oficial.  La variable <code>MALLOC_ARENA_MAX</code> reduce el n√∫mero m√°ximo de montones de sistema asignados para subprocesos m√∫ltiples.  Por esta l√≥gica, reduce la fragmentaci√≥n. <br><br><a name="4_2"></a><h3>  Visualizaci√≥n de montones de sistema. </h3><br>  ¬øEs verdad la afirmaci√≥n de Nate y Heroku de que aumentar la cantidad de montones de sistemas aumenta la fragmentaci√≥n?  De hecho, ¬øhay alg√∫n problema con la fragmentaci√≥n en el nivel del asignador de memoria?  No quer√≠a dar por sentado ninguno de estos supuestos, as√≠ que comenc√© el estudio. <br><br>  Desafortunadamente, no hay herramientas para visualizar los montones de sistemas, por lo <b>que escrib√≠ tal visualizador yo mismo</b> . <br><br>  Primero, debe preservar de alguna manera el esquema de distribuci√≥n de los montones del sistema.  Estudi√© la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fuente del asignador de memoria</a> y mir√© c√≥mo representa internamente la memoria.  Luego escribi√≥ una biblioteca que itera sobre estas estructuras de datos y escribe el esquema en un archivo.  Finalmente, escribi√≥ una herramienta que toma un archivo como entrada y compila la visualizaci√≥n como im√°genes HTML y PNG ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">c√≥digo fuente</a> ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/309/adb/064/309adb06474b3ec49bb2d0d6622bbb48.png"></div><br><br>  Aqu√≠ hay un ejemplo de visualizaci√≥n de un mont√≥n de sistema espec√≠fico (hay muchos m√°s).  Peque√±os bloques en esta visualizaci√≥n representan p√°ginas del sistema. <br><br><ul><li>  Las √°reas rojas se utilizan celdas de memoria. </li><li>  Los grises son √°reas libres que no se devuelven al n√∫cleo. </li><li>  Las √°reas blancas se liberan para el n√∫cleo. </li></ul><br>  Las siguientes conclusiones se pueden extraer de la visualizaci√≥n: <br><br><ol><li>  Hay cierta fragmentaci√≥n.  Las manchas rojas est√°n dispersas de la memoria, y algunas p√°ginas del sistema son solo medio rojas. <br></li><li>  Para mi sorpresa, la <i>mayor√≠a de los</i> montones del sistema contienen una cantidad significativa de p√°ginas del sistema completamente gratis (gris). </li></ol><br>  Y luego me di cuenta: <br><br>  <i><b>Aunque la fragmentaci√≥n sigue siendo un problema, ¬°no es el punto!</b></i> <br><br>  M√°s bien, el problema es muy gris: ¬°este asignador de memoria <i>no env√≠a memoria al n√∫cleo</i> ! <br><br>  Despu√©s de volver a estudiar el c√≥digo fuente del asignador de memoria, result√≥ que, de forma predeterminada, solo env√≠a p√°ginas del sistema al n√∫cleo al final del mont√≥n del sistema, e incluso <i>rara vez lo</i> hace.  Probablemente, dicho algoritmo se implementa por razones de rendimiento. <br><br><a name="5"></a><h1>  Truco de magia: circuncisi√≥n </h1><br>  Afortunadamente, encontr√© un truco.  Hay una interfaz de programaci√≥n que obligar√° al asignador de memoria a liberar el n√∫cleo, no solo la √∫ltima, sino <i>todas las</i> p√°ginas relevantes del sistema.  Se llama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">malloc_trim</a> . <br><br>  Conoc√≠a esta funci√≥n, pero no pens√© que fuera √∫til, porque el manual dice lo siguiente: <br><br><blockquote>  La funci√≥n malloc_trim () intenta liberar memoria libre en la parte superior del mont√≥n. </blockquote><br>  <b>¬°El manual est√° mal!</b>  El an√°lisis del c√≥digo fuente dice que el programa libera todas las p√°ginas relevantes del sistema, no solo la parte superior. <br><br>  ¬øQu√© sucede si se llama a esta funci√≥n durante la recolecci√≥n de basura?  <code>malloc_trim()</code> c√≥digo fuente de Ruby 2.6 para llamar a <code>malloc_trim()</code> en la funci√≥n gc_start desde gc.c, por ejemplo: <br><br><pre> <code class="cpp hljs">gc_prof_timer_start(objspace); { gc_marks(objspace, do_full_mark); <span class="hljs-comment"><span class="hljs-comment">// BEGIN MODIFICATION if (do_full_mark) { malloc_trim(0); } // END MODIFICATION } gc_prof_timer_stop(objspace);</span></span></code> </pre> <br>  Y aqu√≠ est√°n los resultados de la prueba: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f4/cfc/063/1f4cfc063a1c0672a80ed11baec2c323.png"></div><br><br>  <b>¬°Qu√© gran diferencia!</b>  Un simple parche redujo el consumo de memoria a casi <code>MALLOC_ARENA_MAX=2</code> . <br><br>  As√≠ es como se ve en la visualizaci√≥n: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9de/410/594/9de410594884baa131d3b8e52d7c6656.png"></div><br><br>  Vemos muchas √°reas blancas que corresponden a las p√°ginas del sistema liberadas nuevamente al n√∫cleo. <br><br><a name="6"></a><h1>  Conclusi√≥n </h1><br>  Result√≥ que la fragmentaci√≥n, b√°sicamente, no ten√≠a nada que ver con eso.  La desfragmentaci√≥n sigue siendo √∫til, pero el problema principal es que al asignador de memoria no le gusta liberar memoria de vuelta al n√∫cleo. <br><br>  Afortunadamente, la soluci√≥n result√≥ ser muy simple.  Lo principal era encontrar la causa ra√≠z. <br><br><a name="6_1"></a><h3>  C√≥digo fuente del visualizador </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">C√≥digo fuente</a> <br><br><a name="6_2"></a><h3>  ¬øQu√© pasa con el rendimiento? </h3><br>  El rendimiento sigui√≥ siendo una de las principales preocupaciones.  Llamar a <code>malloc_trim()</code> no se puede <code>malloc_trim()</code> de forma gratuita, pero de acuerdo con el c√≥digo, el algoritmo funciona en tiempo lineal.  Entonces recurr√≠ a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Noah Gibbs</a> , quien lanz√≥ el banco de pruebas Rails Ruby Bench.  Para mi sorpresa, el parche caus√≥ un ligero <b>aumento en el</b> rendimiento. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e5/115/88c/7e511588c662a60e0f8a82556b2e1988.jpg"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/474/c8e/f91/474c8ef919bf360ecf45f365e1a87ab0.jpg"></div><br><br>  Me vol√≥ la cabeza.  El efecto es incomprensible, pero la noticia es buena. <br><br><a name="6_3"></a><h3>  Necesito m√°s pruebas </h3><br>  Como parte de este estudio, solo se ha verificado un n√∫mero limitado de casos.  No se sabe cu√°l es el impacto en otras cargas de trabajo.  Si desea ayudar con las pruebas, <a href="">cont√°cteme</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/444482/">https://habr.com/ru/post/444482/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444470/index.html">20 h√°bitos para la higiene de la atenci√≥n: c√≥mo usar la tecnolog√≠a, pero no dejar que se tomen su tiempo y atenci√≥n</a></li>
<li><a href="../444472/index.html">Emulaci√≥n de servicios web de Amazon en un proceso JVM. Evitar Roskomnadzor y acelerar el desarrollo y las pruebas</a></li>
<li><a href="../444474/index.html">Construcci√≥n de la l√≠nea de comunicaci√≥n Sakhalin-Kuril. Segero Tour - Telef√©rico</a></li>
<li><a href="../444476/index.html">Competencia de RUSNANO: tome un curso en l√≠nea sobre microelectr√≥nica moderna, luego un recorrido pr√°ctico con FPGA, obtenga un premio</a></li>
<li><a href="../444480/index.html">C√≥mo reducir el peso del elemento estructural de un avi√≥n en un tercio</a></li>
<li><a href="../444484/index.html">Estimaci√≥n de t√©rminos para el desarrollo de tareas y pruebas (no es necesario)</a></li>
<li><a href="../444488/index.html">Matrix Powerwatch por dentro y por fuera: ¬øqu√© hay de nuevo?</a></li>
<li><a href="../444490/index.html">Escane√© Ucrania</a></li>
<li><a href="../444492/index.html">Aventuras de la nada</a></li>
<li><a href="../444494/index.html">La Moto Volante (Lazareth LMV 496) - motocicleta transformadora voladora</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>