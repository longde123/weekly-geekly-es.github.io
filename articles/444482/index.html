<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🎓 🕟 💒 ¿Qué infla la memoria en Ruby? 🙈 👩🏻‍🤝‍👨🏼 🤳🏾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nosotros en Phusion tenemos un simple proxy HTTP multiproceso en Ruby (distribuye paquetes DEB y RPM). Vi en él un consumo de memoria de 1.3 GB. Pero ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>¿Qué infla la memoria en Ruby?</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/444482/">  Nosotros en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Phusion tenemos</a> un simple proxy HTTP multiproceso en Ruby (distribuye paquetes DEB y RPM).  Vi en él un consumo de memoria de 1.3 GB.  Pero esto es una locura para un proceso sin estado ... <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9ba/f7a/d2b/9baf7ad2bd3ecdfb0779482c018473eb.jpg"></div><br>  <i><font color="gray">Pregunta: ¿Qué es?</font></i>  <i><font color="gray">Respuesta: ¡Ruby usa la memoria con el tiempo!</font></i> <br><br>  Resulta que no estoy solo en este problema.  Las aplicaciones de Ruby pueden usar mucha memoria.  Pero por que?  Según <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Heroku</a> y <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Nate Burkopek</a> , la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">hinchazón</a> se debe principalmente a la fragmentación de la memoria y la distribución excesiva del <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">montón</a> . <br><a name="habracut"></a><br>  Berkopek concluyó que hay dos soluciones: <br><br><ol><li>  Utilice un asignador de memoria completamente diferente al glibc, generalmente <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">jemalloc</a> , o: </li><li> Establezca la variable de entorno mágico <code>MALLOC_ARENA_MAX=2</code> . </li></ol><br>  Me preocupa la descripción del problema y las soluciones propuestas.  Hay algo mal aquí ... No estoy seguro de que el problema esté completamente descrito correctamente o de que estas sean las únicas soluciones disponibles.  También me molesta que muchos se refieran a jemalloc como una piscina mágica de plata. <br><br>  <b>La magia es solo una ciencia que aún no entendemos</b> .  Así que hice un viaje de investigación para descubrir toda la verdad.  Este artículo cubrirá los siguientes temas: <br><br><ol><li>  Cómo funciona la asignación de memoria. <br></li><li>  ¿Qué es esta "fragmentación" y "distribución excesiva" de memoria de la que todos están hablando? <br></li><li>  ¿Qué causa un gran consumo de memoria?  ¿La situación es consistente con lo que dice la gente o hay algo más?  (spoiler: sí, hay algo más). <br></li><li>  ¿Hay alguna solución alternativa?  (spoiler: encontré uno). </li></ol><br>  <i>Nota: este artículo es relevante solo para Linux, y solo para aplicaciones de Ruby multiproceso.</i> <br><br><h1>  Contenido </h1><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Asignación de memoria rubí: una introducción</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Rubí</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Asignador de memoria del sistema</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">El núcleo</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Definición de uso de memoria</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¿Qué es la fragmentación?</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fragmentación de nivel rubí</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Fragmentación de asignación de memoria</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¿La fragmentación de la página del montón de Ruby está causando una hinchazón de memoria?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Estudio de fragmentación de asignación de memoria</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Asignación de memoria excesiva y glibc</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Visualización de montones de sistema.</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Truco de magia: circuncisión</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Conclusión</a> <br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Código fuente del visualizador</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">¿Qué pasa con el rendimiento?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Necesito más pruebas</a> </li></ul></li></ul><br><a name="1"></a><h1>  Asignación de memoria rubí: una introducción </h1><br>  Ruby asigna memoria a tres niveles, de arriba a abajo: <br><br><ol><li>  Intérprete de Ruby que gestiona objetos Ruby. <br></li><li>  La biblioteca del asignador de memoria del sistema operativo. <br></li><li>  El núcleo </li></ol><br>  Veamos cada nivel. <br><br><a name="1_1"></a><h3>  Rubí </h3><br>  Por su parte, Ruby organiza objetos en áreas de memoria llamadas <i>páginas de montón Ruby</i> .  Tal página de montón se divide en ranuras del mismo tamaño, donde un objeto ocupa una ranura.  Ya sea una cadena, una tabla hash, una matriz, una clase u otra cosa, ocupa una ranura. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/2d6/155/0be/2d61550be208df42ad3052ca1f821807.png"></div><br><br>  Los espacios en la página del montón pueden estar ocupados o libres.  Cuando Ruby selecciona un nuevo objeto, inmediatamente trata de ocupar un espacio libre.  Si no hay espacios libres, se resaltará una nueva página de montón. <br><br>  La ranura es pequeña, de unos 40 bytes.  Obviamente, algunos objetos no caben en él, por ejemplo, líneas de 1 MB.  Luego, Ruby almacena la información en otro lugar fuera de la página del montón y coloca un puntero a esta área de memoria externa en la ranura. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1e5/e96/1c6/1e5e961c6c90ed1cd17daa8ab19d8212.png"></div><br>  <i><font color="gray">Los datos que no caben en la ranura se almacenan fuera de la página del montón.</font></i>  <i><font color="gray">Ruby coloca un puntero a estos datos externos en la ranura</font></i> <br><br>  Tanto las páginas de almacenamiento dinámico de Ruby como cualquier área de memoria externa se asignan utilizando el asignador de memoria del sistema. <br><br><a name="1_2"></a><h3>  Asignador de memoria del sistema </h3><br>  El asignador de memoria del sistema operativo es parte de glibc (tiempo de ejecución C).  Es utilizado por casi todas las aplicaciones, no solo Ruby.  Tiene una API simple: <br><br><ul><li>  La memoria se asigna llamando a <code>malloc(size)</code> .  Le da el número de bytes que desea asignar y devuelve la dirección de asignación o un error. </li><li>  La memoria asignada se libera llamando <code>free(address)</code> . </li></ul><br>  A diferencia de Ruby, donde se asignan ranuras del mismo tamaño, el asignador de memoria se ocupa de las solicitudes de asignación de memoria de cualquier tamaño.  Como aprenderá más adelante, este hecho conduce a algunas complicaciones. <br><br>  A su vez, el asignador de memoria accede a la API del núcleo.  El núcleo requiere fragmentos de memoria mucho más grandes que los que solicitan sus propios suscriptores, ya que la llamada del núcleo es costosa y la API del núcleo tiene una limitación: solo puede asignar memoria en múltiplos de 4 KB. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/323/dba/21a/323dba21a7b5ad2df8e1f9335d6b7c11.png"></div><br>  <i><font color="gray">El asignador de memoria asigna fragmentos grandes (se denominan montones del sistema) y comparte su contenido para satisfacer las solicitudes de las aplicaciones.</font></i> <br><br>  El área de memoria que el asignador de memoria asigna desde el núcleo se denomina montón.  Tenga en cuenta que no tiene nada que ver con las páginas del montón Ruby, por lo que, para mayor claridad, usaremos el término <i>montón del sistema</i> . <br><br>  El asignador de memoria luego asigna partes de los montones del sistema a sus llamantes hasta que haya espacio libre.  En este caso, el asignador de memoria asigna un nuevo montón de sistema desde el núcleo.  Esto es similar a cómo Ruby selecciona objetos de las páginas de un montón de Ruby. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/453/f81/c11/453f81c11aaadb818ecdcf798112db99.png"></div><br>  <i><font color="gray">Ruby asigna memoria del asignador de memoria, que a su vez asigna memoria del núcleo</font></i> <br><br><a name="1_3"></a><h3>  El núcleo </h3><br>  El núcleo solo puede asignar memoria en unidades de 4 KB.  Uno de esos bloques 4K se llama página.  Para evitar confusiones con las páginas del montón Ruby, para mayor claridad, utilizaremos el término <i>página del sistema</i> ( <i>página del sistema</i> operativo). <br><br>  La razón es difícil de explicar, pero así es como funcionan todos los núcleos modernos. <br><br>  La asignación de memoria a través del núcleo tiene un impacto significativo en el rendimiento, razón por la cual los asignadores de memoria intentan minimizar la cantidad de llamadas al núcleo. <br><br><a name="1_4"></a><h3>  Definición de uso de memoria </h3><br>  Por lo tanto, la memoria se asigna a varios niveles, y cada nivel asigna más memoria de la que realmente necesita.  Las páginas de montón de Ruby pueden tener espacios libres, así como montones de sistema.  Por lo tanto, la respuesta a la pregunta "¿Cuánta memoria se usa?"  ¡depende completamente del nivel que pidas! <br><br>  Herramientas como <code>top</code> o <code>ps</code> muestran el uso de memoria desde la perspectiva del <b>kernel</b> .  Esto significa que los niveles superiores deben funcionar en concierto para liberar memoria desde el punto de vista del núcleo.  Como aprenderá más tarde, esto es más difícil de lo que parece. <br><br><a name="2"></a><h1>  ¿Qué es la fragmentación? </h1><br>  La fragmentación de la memoria significa que las asignaciones de memoria se dispersan aleatoriamente.  Esto puede causar problemas interesantes. <br><br><a name="2_1"></a><h3>  Fragmentación de nivel rubí </h3><br>  Considere la recolección de basura de Ruby.  La recolección de basura para un objeto significa marcar el espacio de la página del montón Ruby como libre, lo que permite su reutilización.  Si toda la página del montón de Ruby consta solo de ranuras libres, entonces toda su página se puede volver a liberar al asignador de memoria (y, posiblemente, de vuelta al núcleo). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/27b/cde/97d/27bcde97d27e6aeed3dc2020a4eda766.png"></div><br><br>  Pero, ¿qué sucede si no todas las máquinas tragamonedas son gratuitas?  ¿Qué pasa si tenemos muchas páginas del montón de Ruby, y el recolector de basura libera objetos en diferentes lugares, de modo que al final hay muchos espacios libres, pero en diferentes páginas?  En esta situación, Ruby tiene ranuras libres para colocar objetos, ¡pero el asignador de memoria y el núcleo continuarán asignando memoria! <br><br><a name="2_2"></a><h3>  Fragmentación de asignación de memoria </h3><br>  El asignador de memoria tiene un problema similar pero completamente diferente.  No necesita borrar inmediatamente los montones de todo el sistema.  Teóricamente, puede liberar cualquier página del sistema.  Pero dado que el asignador de memoria trata con asignaciones de memoria de tamaño arbitrario, puede haber varias asignaciones en la página del sistema.  No puede liberar la página del sistema hasta que se liberen todas las selecciones. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/76b/723/850/76b72385026fa24bd18b7db324d7353b.png"></div><br><br>  Piense en lo que sucede si tenemos una asignación de 3 KB, así como una asignación de 2 KB, dividida en dos páginas del sistema.  Si libera los primeros 3 KB, ambas páginas del sistema permanecerán parcialmente ocupadas y no podrán liberarse. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cc2/cf1/70f/cc2cf170facbc6bca673014e33389606.png"></div><br><br>  Por lo tanto, si las circunstancias fallan, habrá mucho espacio libre en las páginas del sistema, pero no se liberarán por completo. <br><br>  Peor aún: ¿qué pasa si hay muchos lugares libres, pero ninguno de ellos es lo suficientemente grande como para satisfacer una nueva solicitud de asignación?  El asignador de memoria tendrá que asignar un montón de sistema completamente nuevo. <br><br><a name="3"></a><h1>  ¿La fragmentación de la página del montón de Ruby está causando una hinchazón de memoria? </h1><br>  Es probable que la fragmentación esté causando un uso excesivo de la memoria en Ruby.  Si es así, ¿cuál de las dos fragmentaciones es más dañina?  Esto es ... <br><br><ol><li>  ¿Fragmentación de la página del montón de rubíes?  O <br></li><li>  ¿Fragmentación del asignador de memoria? </li></ol><br>  La primera opción es bastante simple de verificar.  Ruby proporciona dos API: <code>ObjectSpace.memsize_of_all</code> y <code>GC.stat</code> .  Gracias a esta información, puede calcular toda la memoria que recibió Ruby del asignador. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/cb8/f7e/30e/cb8f7e30e363d2fa57f0fc37b84183fe.png"></div><br><br>  <code>ObjectSpace.memsize_of_all</code> devuelve la memoria ocupada por todos los objetos Ruby activos.  Es decir, todo el espacio en sus ranuras y cualquier dato externo.  En el diagrama anterior, este es el tamaño de todos los objetos azules y naranjas. <br><br>  <code>GC.stat</code> permite averiguar el tamaño de todas las ranuras libres, es decir, el área gris completa en la ilustración de arriba.  Aquí está el algoritmo: <br><br><pre> <code class="cpp hljs">GC.stat[:heap_free_slots] * GC::INTERNAL_CONSTANTS[:RVALUE_SIZE]</code> </pre> <br>  Para resumirlos, este es todo el recuerdo que conoce Ruby, e implica fragmentar las páginas del montón de Ruby.  Si, desde el punto de vista del kernel, el uso de memoria es mayor, entonces la memoria restante va a algún lugar fuera del control de Ruby, por ejemplo, a bibliotecas o fragmentación de terceros. <br><br>  Escribí un programa de prueba simple que crea un montón de hilos, cada uno de los cuales selecciona líneas en un bucle.  Aquí está el resultado después de un tiempo: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a4e/859/2fc/a4e8592fc1d2edf2f11957844d33e55d.png"></div><br><br>  es ... solo ... loco! <br><br>  El resultado muestra que Ruby tiene un efecto tan débil en la cantidad total de memoria utilizada, no importa si las páginas del montón de Ruby están fragmentadas o no. <br><br>  Hay que buscar al culpable en otra parte.  Al menos ahora sabemos que Ruby no tiene la culpa. <br><br><a name="4"></a><h1>  Estudio de fragmentación de asignación de memoria </h1><br>  Otro sospechoso probable es un asignador de memoria.  Al final, Nate Berkopek y Heroku notaron que preocuparse por el asignador de memoria (ya sea un reemplazo completo para jemalloc o establecer la variable de entorno mágico <code>MALLOC_ARENA_MAX=2</code> ) reduce drásticamente el uso de memoria. <br><br>  Primero veamos qué hace <code>MALLOC_ARENA_MAX=2</code> y por qué ayuda.  Luego examinamos la fragmentación a nivel del distribuidor. <br><br><a name="4_1"></a><h3>  Asignación de memoria excesiva y glibc </h3><br>  La razón por la que <code>MALLOC_ARENA_MAX=2</code> ayuda es <code>MALLOC_ARENA_MAX=2</code> subprocesamiento <code>MALLOC_ARENA_MAX=2</code> .  Cuando varios subprocesos intentan simultáneamente asignar memoria desde el mismo montón de sistema, luchan por el acceso.  Solo un subproceso a la vez puede recibir memoria, lo que reduce el rendimiento de la asignación de memoria de subprocesos múltiples. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/a40/99c/65b/a4099c65b73541efa05c38008fa0e181.png"></div><br>  <i><font color="gray">Solo un subproceso a la vez puede funcionar con el montón del sistema.</font></i>  <i><font color="gray">En tareas de subprocesos múltiples, surge un conflicto y, en consecuencia, el rendimiento disminuye</font></i> <br><br>  En el asignador de memoria para tal caso hay optimización.  Intenta crear varios montones de sistema y asignarlos a diferentes subprocesos.  La mayoría de las veces un subproceso solo funciona con su propio montón, evitando conflictos con otros subprocesos. <br><br>  De hecho, el número máximo de montones de sistemas asignados de esta manera es por defecto igual al número de procesadores virtuales multiplicado por 8. Es decir, en un sistema de doble núcleo con dos hiperprocesos, ¡cada uno produce <code>2 * 2 * 8 = 32</code> montones de sistemas!  Esto es lo que yo llamo <b>distribución excesiva</b> . <br><br>  ¿Por qué es tan grande el multiplicador predeterminado?  Porque el desarrollador líder del asignador de memoria es Red Hat.  Sus clientes son grandes empresas con servidores potentes y una tonelada de RAM.  La optimización anterior le permite aumentar el rendimiento promedio de subprocesos múltiples en un 10% debido a un aumento significativo en el uso de la memoria.  Para los clientes de Red Hat, este es un buen compromiso.  Para la mayoría del resto, apenas. <br><br>  Nate en su blog y en el artículo de Heroku afirman que aumentar la cantidad de montones de sistemas aumenta la fragmentación y citan documentación oficial.  La variable <code>MALLOC_ARENA_MAX</code> reduce el número máximo de montones de sistema asignados para subprocesos múltiples.  Por esta lógica, reduce la fragmentación. <br><br><a name="4_2"></a><h3>  Visualización de montones de sistema. </h3><br>  ¿Es verdad la afirmación de Nate y Heroku de que aumentar la cantidad de montones de sistemas aumenta la fragmentación?  De hecho, ¿hay algún problema con la fragmentación en el nivel del asignador de memoria?  No quería dar por sentado ninguno de estos supuestos, así que comencé el estudio. <br><br>  Desafortunadamente, no hay herramientas para visualizar los montones de sistemas, por lo <b>que escribí tal visualizador yo mismo</b> . <br><br>  Primero, debe preservar de alguna manera el esquema de distribución de los montones del sistema.  Estudié la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">fuente del asignador de memoria</a> y miré cómo representa internamente la memoria.  Luego escribió una biblioteca que itera sobre estas estructuras de datos y escribe el esquema en un archivo.  Finalmente, escribió una herramienta que toma un archivo como entrada y compila la visualización como imágenes HTML y PNG ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">código fuente</a> ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/309/adb/064/309adb06474b3ec49bb2d0d6622bbb48.png"></div><br><br>  Aquí hay un ejemplo de visualización de un montón de sistema específico (hay muchos más).  Pequeños bloques en esta visualización representan páginas del sistema. <br><br><ul><li>  Las áreas rojas se utilizan celdas de memoria. </li><li>  Los grises son áreas libres que no se devuelven al núcleo. </li><li>  Las áreas blancas se liberan para el núcleo. </li></ul><br>  Las siguientes conclusiones se pueden extraer de la visualización: <br><br><ol><li>  Hay cierta fragmentación.  Las manchas rojas están dispersas de la memoria, y algunas páginas del sistema son solo medio rojas. <br></li><li>  Para mi sorpresa, la <i>mayoría de los</i> montones del sistema contienen una cantidad significativa de páginas del sistema completamente gratis (gris). </li></ol><br>  Y luego me di cuenta: <br><br>  <i><b>Aunque la fragmentación sigue siendo un problema, ¡no es el punto!</b></i> <br><br>  Más bien, el problema es muy gris: ¡este asignador de memoria <i>no envía memoria al núcleo</i> ! <br><br>  Después de volver a estudiar el código fuente del asignador de memoria, resultó que, de forma predeterminada, solo envía páginas del sistema al núcleo al final del montón del sistema, e incluso <i>rara vez lo</i> hace.  Probablemente, dicho algoritmo se implementa por razones de rendimiento. <br><br><a name="5"></a><h1>  Truco de magia: circuncisión </h1><br>  Afortunadamente, encontré un truco.  Hay una interfaz de programación que obligará al asignador de memoria a liberar el núcleo, no solo la última, sino <i>todas las</i> páginas relevantes del sistema.  Se llama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">malloc_trim</a> . <br><br>  Conocía esta función, pero no pensé que fuera útil, porque el manual dice lo siguiente: <br><br><blockquote>  La función malloc_trim () intenta liberar memoria libre en la parte superior del montón. </blockquote><br>  <b>¡El manual está mal!</b>  El análisis del código fuente dice que el programa libera todas las páginas relevantes del sistema, no solo la parte superior. <br><br>  ¿Qué sucede si se llama a esta función durante la recolección de basura?  <code>malloc_trim()</code> código fuente de Ruby 2.6 para llamar a <code>malloc_trim()</code> en la función gc_start desde gc.c, por ejemplo: <br><br><pre> <code class="cpp hljs">gc_prof_timer_start(objspace); { gc_marks(objspace, do_full_mark); <span class="hljs-comment"><span class="hljs-comment">// BEGIN MODIFICATION if (do_full_mark) { malloc_trim(0); } // END MODIFICATION } gc_prof_timer_stop(objspace);</span></span></code> </pre> <br>  Y aquí están los resultados de la prueba: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1f4/cfc/063/1f4cfc063a1c0672a80ed11baec2c323.png"></div><br><br>  <b>¡Qué gran diferencia!</b>  Un simple parche redujo el consumo de memoria a casi <code>MALLOC_ARENA_MAX=2</code> . <br><br>  Así es como se ve en la visualización: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/9de/410/594/9de410594884baa131d3b8e52d7c6656.png"></div><br><br>  Vemos muchas áreas blancas que corresponden a las páginas del sistema liberadas nuevamente al núcleo. <br><br><a name="6"></a><h1>  Conclusión </h1><br>  Resultó que la fragmentación, básicamente, no tenía nada que ver con eso.  La desfragmentación sigue siendo útil, pero el problema principal es que al asignador de memoria no le gusta liberar memoria de vuelta al núcleo. <br><br>  Afortunadamente, la solución resultó ser muy simple.  Lo principal era encontrar la causa raíz. <br><br><a name="6_1"></a><h3>  Código fuente del visualizador </h3><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Código fuente</a> <br><br><a name="6_2"></a><h3>  ¿Qué pasa con el rendimiento? </h3><br>  El rendimiento siguió siendo una de las principales preocupaciones.  Llamar a <code>malloc_trim()</code> no se puede <code>malloc_trim()</code> de forma gratuita, pero de acuerdo con el código, el algoritmo funciona en tiempo lineal.  Entonces recurrí a <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Noah Gibbs</a> , quien lanzó el banco de pruebas Rails Ruby Bench.  Para mi sorpresa, el parche causó un ligero <b>aumento en el</b> rendimiento. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e5/115/88c/7e511588c662a60e0f8a82556b2e1988.jpg"></div><br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/474/c8e/f91/474c8ef919bf360ecf45f365e1a87ab0.jpg"></div><br><br>  Me voló la cabeza.  El efecto es incomprensible, pero la noticia es buena. <br><br><a name="6_3"></a><h3>  Necesito más pruebas </h3><br>  Como parte de este estudio, solo se ha verificado un número limitado de casos.  No se sabe cuál es el impacto en otras cargas de trabajo.  Si desea ayudar con las pruebas, <a href="">contácteme</a> . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/444482/">https://habr.com/ru/post/444482/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../444470/index.html">20 hábitos para la higiene de la atención: cómo usar la tecnología, pero no dejar que se tomen su tiempo y atención</a></li>
<li><a href="../444472/index.html">Emulación de servicios web de Amazon en un proceso JVM. Evitar Roskomnadzor y acelerar el desarrollo y las pruebas</a></li>
<li><a href="../444474/index.html">Construcción de la línea de comunicación Sakhalin-Kuril. Segero Tour - Teleférico</a></li>
<li><a href="../444476/index.html">Competencia de RUSNANO: tome un curso en línea sobre microelectrónica moderna, luego un recorrido práctico con FPGA, obtenga un premio</a></li>
<li><a href="../444480/index.html">Cómo reducir el peso del elemento estructural de un avión en un tercio</a></li>
<li><a href="../444484/index.html">Estimación de términos para el desarrollo de tareas y pruebas (no es necesario)</a></li>
<li><a href="../444488/index.html">Matrix Powerwatch por dentro y por fuera: ¿qué hay de nuevo?</a></li>
<li><a href="../444490/index.html">Escaneé Ucrania</a></li>
<li><a href="../444492/index.html">Aventuras de la nada</a></li>
<li><a href="../444494/index.html">La Moto Volante (Lazareth LMV 496) - motocicleta transformadora voladora</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>