<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩‍💼 🗝️ ⛵️ Introduction à C. Message du siècle dernier 🖼️ 🧗🏾 🍦</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Préface 
 Dans mes commentaires, je me suis référé à plusieurs reprises au livre Operating Systems Design and Implementation d’Andrew Tanenbaum, à sa ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introduction à C. Message du siècle dernier</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464075/"><h3>  Préface </h3><br>  Dans mes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">commentaires, je me suis</a> référé à plusieurs reprises au livre Operating Systems Design and Implementation d’Andrew Tanenbaum, à sa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">première édition,</a> et à la façon dont C y est représenté.  Et ces commentaires ont toujours été intéressants.  J'ai décidé qu'il était temps de publier une traduction de cette introduction en C.  C'est toujours d'actualité.  Bien qu'il y ait certainement ceux qui n'ont pas entendu parler du langage de programmation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PL / 1</a> , et peut-être même du système d'exploitation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Minix</a> . <br><br>  Cette description est également intéressante d'un point de vue historique et pour comprendre jusqu'où le langage C est allé depuis sa naissance et l'industrie informatique dans son ensemble. <br><a name="habracut"></a><br>  Je souhaite immédiatement réserver que ma deuxième langue soit le français: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/961/467/5a3/9614675a3883bf417fa2505dada57690.png" alt="image"><br><br>  Mais cela est compensé par 46 ans d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">expérience en programmation</a> . <br>  Alors, commençons, c'est au tour d'Andrew Tanenbaum. <br><br><h3>  Introduction au langage C (pp. 350 - 362) </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cx/s5/il/cxs5ilctyz8rybmfwoqyjahv5ty.png"></div><br><br>  Le langage de programmation C a été créé par Dennis Ritchie d'AT &amp; T Bell Laboratories en tant que langage de programmation de haut niveau pour le développement du système d'exploitation UNIX.  Actuellement, la langue est largement utilisée dans divers domaines.  C est particulièrement populaire auprès des programmeurs système car il vous permet d'écrire des programmes de manière simple et concise. <br><br>  Le livre principal décrivant le langage C est le livre du langage de programmation C (1978) de Brian Kernigan et Dennis Ritchie.  Des livres sur le langage C ont été écrits par Bolon (1986), Gehani (1984), Hancock et Krieger (1986), Harbison et Steele (1984) et bien d'autres. <br><br>  Dans cette application, nous essaierons de donner une introduction assez complète au C, afin que ceux qui sont familiers avec les langages de haut niveau tels que Pascal, PL / 1 ou Modula 2 puissent comprendre la plupart du code MINIX donné dans ce livre.  Les fonctionnalités C qui ne sont pas utilisées dans MINIX ne sont pas traitées ici.  Nombreux points subtils omis.  L'accent est mis sur la lecture de programmes C plutôt que sur l'écriture de code. <br><br><h3>  A.1.  Bases du langage C </h3><br>  Un programme C se compose d'un ensemble de procédures (souvent appelées fonctions, même si elles ne renvoient pas de valeurs).  Ces procédures contiennent des déclarations, des opérateurs et d'autres éléments qui, ensemble, indiquent à l'ordinateur quoi faire.  La figure A-1 montre une petite procédure dans laquelle trois variables entières sont déclarées et affectées à des valeurs.  Le nom de la procédure est principal.  La procédure n'a pas de paramètres formels, comme l'indique l'absence d'identificateurs entre les crochets derrière le nom de la procédure.  Le corps de la procédure est placé entre accolades ({}).  Cet exemple montre que C a des variables et que ces variables doivent être déclarées avant utilisation.  C a également des opérateurs, dans cet exemple ce sont des opérateurs d'affectation.  Toutes les instructions doivent se terminer par un point-virgule (contrairement à Pascal, qui utilise des deux-points entre les instructions, pas après). <br><br>  Les commentaires commencent par les caractères «/ *» et se terminent par les caractères «* /» et peuvent s'étendre sur plusieurs lignes. <br><br><pre><code class="cpp hljs">main () <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, j, k; <span class="hljs-comment"><span class="hljs-comment">/*  3   */</span></span> i = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  i  10 ( ) */</span></span> j = i + <span class="hljs-number"><span class="hljs-number">015</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  j  i + 015 ( ) */</span></span> k = j * j + <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  k  j * j + 0xFF ( ) */</span></span> } . Al.    .</code> </pre> <br>  La procédure contient trois constantes.  Constante 10 dans la première affectation <br>  c'est une constante décimale ordinaire.  La constante 015 est une constante octale <br>  (égal à 13 en décimal).  Les constantes octales commencent toujours à zéro.  La constante 0xFF est une constante hexadécimale (égale à 255 décimales).  Les constantes hexadécimales commencent toujours par 0x.  Les trois types sont utilisés en C. <br><br><h3>  A.2.  Types de données de base </h3><br>  C a deux principaux types de données (variables): un entier et un caractère, déclarés respectivement int et char.  Il n'y a pas de variable booléenne distincte.  La variable int est utilisée comme variable booléenne.  Si cette variable contient 0, cela signifie faux / faux et toute autre valeur signifie vrai / vrai.  C a également des types à virgule flottante, mais MINIX ne les utilise pas. <br><br>  Vous pouvez appliquer des «adjectifs» courts, longs ou non signés à un type int qui définit une plage de valeurs (dépendant du compilateur).  La plupart des processeurs 8088 utilisent des entiers 16 bits pour int et short int et 32 ​​bits pour int long.  Les entiers non signés (entier non signé) sur le processeur 8088 ont une plage de 0 à 65535, et non de -32768 à +32767, comme c'est le cas avec les entiers ordinaires (int).  Un caractère prend 8 bits. <br><br>  Le spécificateur de registre est également autorisé pour int et char, et indique au compilateur que la variable déclarée doit être placée dans le registre pour que le programme fonctionne plus rapidement. <br><br>  Certaines annonces sont montrées sur la fig.  A - 2. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z1, z2; / *    */ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> flag_poll; <span class="hljs-comment"><span class="hljs-comment">/* 'int'    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> . <span class="hljs-number"><span class="hljs-number">-2.</span></span>  .</code> </pre> <br>  La conversion entre les types est autorisée.  Par exemple, l'opérateur <br><br><pre> <code class="cpp hljs">flag_pole = i;</code> </pre> <br>  autorisé même si i est de type int et que flag_pole est long.  Dans de nombreux cas <br>  il est nécessaire ou utile de forcer les conversions entre les types de données.  Pour une conversion forcée, il suffit de mettre le type cible entre crochets devant l'expression à convertir.  Par exemple: <br><br><pre> <code class="cpp hljs"> ( (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) i);</code> </pre> <br>  indique de convertir l'entier i en long avant de le passer comme paramètre à la procédure p, qui attend le paramètre long. <br><br>  Lors de la conversion entre les types, faites attention au signe. <br>  Lors de la conversion d'un caractère en entier, certains compilateurs traitent les caractères comme signés, c'est-à-dire de - 128 à +127, tandis que d'autres les traitent comme <br>  non signé, c'est-à-dire de 0 à 255. Dans MINIX, des expressions telles que <br><br><pre> <code class="cpp hljs">i = c &amp; <span class="hljs-number"><span class="hljs-number">0377</span></span>;</code> </pre> <br>  qui convertit de (caractère) en entier, puis effectue un ET logique <br>  (esperluette) avec la constante octale 0377. Le résultat est que les 8 bits élevés <br>  sont mis à zéro, forçant en fait c à être considéré comme un nombre non signé de 8 bits, dans la plage de 0 à 255. <br><br><h3>  A.3.  Types de composés et pointeurs </h3><br>  Dans cette section, nous examinerons quatre façons de créer des types de données plus complexes: les tableaux, les structures, les unions et les pointeurs.  Un tableau est une collection / un ensemble d'éléments du même type.  Tous les tableaux en C commencent par l'élément 0. <br><br>  Annonce <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a [<span class="hljs-number"><span class="hljs-number">10</span></span>];</code> </pre> <br>  déclare un tableau a avec 10 entiers à stocker dans les éléments du tableau de [0] à a [9].  Deuxièmement, les tableaux peuvent avoir trois dimensions ou plus, mais ils ne sont pas utilisés dans MINIX. <br>  Une structure est un ensemble de variables, généralement de différents types.  La structure en C est similaire à celle de Pascal.  Opératrice <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c;} s;</code> </pre> <br>  déclare s comme une structure contenant deux membres, l'entier i et le caractère c. <br><br>  Pour affecter le membre i de la structure s à 6, écrivez l'expression suivante: <br><br><pre> <code class="cpp hljs">si = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br>  où l'opérateur point indique que l'élément i appartient à la structure s. <br>  Un syndicat est également un ensemble de membres, semblable à une structure, sauf qu'à tout moment un seul d'entre eux peut être membre d'un syndicat.  Annonce <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">union</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c;} u;</code> </pre> <br>  signifie que vous pouvez avoir un entier ou un caractère, mais pas les deux.  Le compilateur doit allouer suffisamment d'espace pour la combinaison afin qu'il puisse accueillir le plus grand élément de combinaison (du point de vue de la mémoire occupée).  Les unions ne sont utilisées qu'à deux endroits dans MINIX (pour définir un message comme une union de plusieurs structures différentes, et pour définir un bloc de disque comme une union d'un bloc de données, d'un bloc i-node, d'un bloc catalogue, etc.). <br><br>  Les pointeurs sont utilisés pour stocker les adresses des machines en C.  Ils sont utilisés très, très souvent.  Un astérisque (*) est utilisé pour indiquer un pointeur dans les annonces.  Annonce <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, *pi, a [<span class="hljs-number"><span class="hljs-number">10</span></span>], *b[<span class="hljs-number"><span class="hljs-number">10</span></span>], **ppi;</code> </pre> <br>  déclare un entier i, un pointeur sur un entier pi, un tableau a de 10 éléments, un tableau b de 10 pointeurs sur des entiers et un pointeur sur un pointeur ppi sur un entier. <br><br>  Les règles de syntaxe exactes pour les déclarations complexes qui combinent des tableaux, des pointeurs et d'autres types sont quelque peu complexes.  Heureusement, MINIX n'utilise que des déclarations simples. <br><br>  La figure A-3 montre la déclaration d'un tableau z de structures de table struct, chacune ayant <br>  trois membres, entier i, pointeur cp vers caractère et caractère c. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">table</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; / *  */ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *cp, c; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> } z [<span class="hljs-number"><span class="hljs-number">20</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/*    20  */</span></span> .  - <span class="hljs-number"><span class="hljs-number">3.</span></span>  .</code> </pre> <br>  Les tableaux de structures sont courants dans MINIX.  De plus, la table de noms peut être déclarée comme une structure de table struct qui peut être utilisée dans les déclarations suivantes.  Par exemple <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">table</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">;</span></span></code> </pre> <br>  déclare p un pointeur sur une structure de table struct et suggère de l'enregistrer <br>  dans le registre.  Pendant l'exécution du programme, p peut indiquer, par exemple, z [4] ou <br>  à tout autre élément de z, dont les 20 éléments sont des structures de type struct table. <br><br>  Pour faire de p un pointeur sur z [4], il suffit d'écrire <br><br><pre> <code class="cpp hljs">p = &amp;z[<span class="hljs-number"><span class="hljs-number">4</span></span>];</code> </pre> <br>  où l'esperluette en tant qu'opérateur unaire (monadique) signifie "prendre l'adresse de ce qui la suit".  Copiez la valeur du membre i dans la variable entière n <br>  la structure pointée par p peut se faire comme suit: <br><br><pre> <code class="cpp hljs">n = p-&gt;i;</code> </pre> <br>  Notez que la flèche est utilisée pour accéder à un membre de la structure via un pointeur.  Si nous utilisons la variable z, alors nous devons utiliser l'opérateur point: <br><br><pre> <code class="cpp hljs">n = z [<span class="hljs-number"><span class="hljs-number">4</span></span>] .i;</code> </pre> <br>  La différence est que z [4] est une structure, et l'opérateur de point sélectionne les éléments <br>  à partir de types composites (structures, tableaux) directement.  À l'aide de pointeurs, nous ne sélectionnons pas directement un participant.  Le pointeur vous demande de sélectionner d'abord une structure, puis de sélectionner ensuite un membre de cette structure. <br><br>  Parfois, il est pratique de donner un nom à un type composite.  Par exemple: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> unshort;</code> </pre> <br>  définit unshort comme non signé court (entier court non signé).  Maintenant unshort peut être utilisé dans le programme comme type principal.  Par exemple <br><br><pre> <code class="cpp hljs">unshort ul, *u2, u3[<span class="hljs-number"><span class="hljs-number">5</span></span>];</code> </pre> <br>  déclare un entier court non signé, un pointeur sur un entier court non signé et <br>  un tableau d'entiers courts non signés. <br><br><h3>  A.4.  Les opérateurs </h3><br>  Les procédures en C contiennent des déclarations et des déclarations.  Nous avons déjà vu les déclarations, nous allons donc maintenant considérer les opérateurs.  Le but des opérateurs conditionnels et de boucle est essentiellement le même que dans d'autres langues.  La figure A-4 en montre plusieurs exemples.  La seule chose à laquelle il faut faire attention est que les accolades sont utilisées pour grouper les opérateurs, et l'instruction while a deux formes, dont la seconde est similaire à l'instruction répétée de Pascal. <br><br>  C a également une instruction for, mais elle ne ressemble à une instruction for dans aucune autre langue.  L'instruction for a la forme suivante: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (&lt;&gt;; &lt;&gt;; &lt;&gt;) ;</code> </pre> <br>  La même chose peut être exprimée à travers la déclaration while: <br><br><pre> <code class="cpp hljs">&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(&lt;&gt;) { &lt;&gt;; &lt;&gt; }</code> </pre> <br>  À titre d'exemple, considérons l'énoncé suivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;n; i = i+l) a[i]=<span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  Cet opérateur met à zéro les n premiers éléments du tableau a.  L'exécution de l'opérateur commence par mettre i à zéro (cela se fait en dehors de la boucle).  Ensuite, l'opérateur est répété jusqu'à i &lt;n, tout en effectuant l'affectation et l'augmentation de i.  Bien sûr, au lieu de l'opérateur d'assigner une valeur à l'élément actuel d'un tableau zéro, il peut y avoir un opérateur composé (bloc) entre crochets. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) k = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   if */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; y) { <span class="hljs-comment"><span class="hljs-comment">/*   if */</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; k = j + l, } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x + <span class="hljs-number"><span class="hljs-number">2</span></span> &lt;y) { <span class="hljs-comment"><span class="hljs-comment">/*  if-else */</span></span> j = <span class="hljs-number"><span class="hljs-number">2</span></span>; k = j - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { m = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*  while */</span></span> k = k + k; n = n - l; } <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { / *    <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> */ k = k + k; n = n - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>); . A<span class="hljs-number"><span class="hljs-number">-4.</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>  C.</code> </pre> <br>  C a également un opérateur similaire à l'opérateur case en Pascal.  Il s'agit d'une instruction switch.  Un exemple est illustré à la figure A-5.  En fonction de la valeur de l'expression spécifiée dans switch, l'une ou l'autre instruction case est sélectionnée. <br><br>  Si l'expression ne correspond à aucune des instructions case, l'instruction par défaut est sélectionnée. <br><br>  Si l'expression n'est associée à aucune instruction case et que l'instruction par défaut est absente, l'exécution se poursuit à partir de l'instruction suivante après l'instruction switch. <br><br>  Il convient de noter que pour quitter le bloc de cas, utilisez l'instruction break.  S'il n'y a pas d'instruction break, le bloc de cas suivant sera exécuté. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (k) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>: i = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   case 20, ..    switch */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span>: i = <span class="hljs-number"><span class="hljs-number">2</span></span>; k = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; / *   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>* / <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: j = <span class="hljs-number"><span class="hljs-number">5</span></span>; } . A<span class="hljs-number"><span class="hljs-number">-5.</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span></code> </pre> <br>  L'instruction break agit également à l'intérieur des boucles for et while.  Il ne faut pas oublier que si l'instruction break se trouve à l'intérieur d'une série de boucles imbriquées, la sortie n'est que d'un niveau supérieur. <br><br>  Une instruction connexe est l'instruction continue, qui ne quitte pas la boucle, <br>  mais provoque la fin de l'itération en cours et le début de l'itération suivante <br>  immédiatement.  Il s'agit essentiellement d'un retour en haut de la boucle. <br><br>  C a des procédures qui peuvent être appelées avec ou sans paramètres. <br>  Selon Kernigan et Ritchie (p. 121), il n'est pas autorisé de transférer des tableaux, <br>  structures ou procédures en tant que paramètres, bien que passant des pointeurs à tout cela <br>  autorisé.  Existe-t-il un livre ou non (il apparaîtra dans ma mémoire: - "S'il y a de la vie sur Mars, s'il n'y en a pas sur Mars"), de nombreux compilateurs C autorisent les structures comme paramètres. <br>  Le nom du tableau, s'il est écrit sans index, signifie un pointeur vers un tableau, ce qui simplifie le transfert d'un pointeur de tableau.  Ainsi, si a est le nom d'un tableau de n'importe quel type, il peut être passé à g en écrivant <br><br><pre> <code class="cpp hljs">g();</code> </pre> <br>  Cette règle s'applique uniquement aux tableaux; cette règle ne s'applique pas aux structures. <br>  Les procédures peuvent renvoyer des valeurs en exécutant une instruction return.  Cette instruction peut contenir une expression, dont le résultat sera renvoyé comme valeur de la procédure, mais l'appelant peut ignorer la valeur de retour en toute sécurité.  Si la procédure renvoie une valeur, alors la valeur de type est écrite avant le nom de la procédure, comme illustré à la Fig.  A-6.  Comme les paramètres, les procédures ne peuvent pas renvoyer de tableaux, de structures ou de procédures, mais peuvent leur renvoyer des pointeurs.  Cette règle est conçue pour une implémentation plus efficace - tous les paramètres et résultats correspondent toujours à un mot machine (dans lequel l'adresse est stockée).  Les compilateurs qui autorisent l'utilisation de structures en tant que paramètres autorisent généralement leur utilisation en tant que valeurs de retour. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, j)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/*      */</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> i, j </span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (i + j); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> } . <span class="hljs-number"><span class="hljs-number">-6.</span></span>   ,   .</code> </pre> <br>  C n'a pas d'E / S intégrées.  L'entrée / sortie est implémentée en appelant des fonctions de bibliothèque, dont les plus courantes sont illustrées ci-dessous: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> («x=% dy = %oz = %x \n», x, y, z);</code> </pre> <br>  Le premier paramètre est la chaîne de caractères entre guillemets (en fait, il s'agit d'un tableau de caractères). <br><br>  Tout caractère qui n'est pas un pourcentage est simplement imprimé tel quel. <br><br>  Lorsqu'un pourcentage se produit, le paramètre suivant est imprimé sous la forme définie par la lettre suivant le pourcentage: <br><blockquote>  d - imprimer sous forme d'entier décimal <br>  o - imprimer comme un entier octal <br>  u - imprimer comme un entier décimal non signé <br>  x - affiche un entier hexadécimal <br>  s - imprimer comme une chaîne de caractères <br>  c - imprimer en un seul caractère </blockquote>  Les lettres D, 0 et X sont également autorisées pour l'impression décimale, octale et hexadécimale des nombres longs. <br><br><h3>  A.5.  Expressions </h3><br>  Les expressions sont créées en combinant des opérandes et des opérateurs. <br><br>  Opérateurs arithmétiques tels que + et - et opérateurs relationnels tels que &lt; <br>  et&gt; similaires à leurs homologues dans d'autres langues.  % Opérateur <br>  utilisé modulo.  Il convient de noter que l'opérateur d'égalité est ==, et l'opérateur d'inégalité est!  =.  Pour vérifier si a et b sont égaux, vous pouvez écrire comme ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a == b) &lt;&gt;;</code> </pre> <br>  C vous permet également de combiner l'opérateur d'affectation avec d'autres opérateurs, donc <br><br><pre> <code class="cpp hljs">a += <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre> <br>  équivalent à l'enregistrement <br><br><pre> <code class="cpp hljs"> =  + <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre><br>  D'autres opérateurs peuvent également être combinés de cette manière. <br><br>  C a des opérateurs pour manipuler les bits d'un mot.  Les décalages et les opérations logiques au niveau du bit sont autorisés.  Les opérateurs de décalage gauche et droit sont &lt;&lt; <br>  et &gt;&gt; respectivement.  Opérateurs logiques bit à bit &amp;, |  et ^, qui sont des ET logiques (ET), y compris OU (OU) et OU exclusif (XOP), respectivement.  Si i a la valeur 035 (octal), alors l'expression i &amp; 06 a la valeur 04 (octal).  Un autre exemple, si i = 7, alors <br><br><pre> <code class="cpp hljs">j = (i &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) | <span class="hljs-number"><span class="hljs-number">014</span></span>;</code> </pre> <br>  et obtenez 074 pour j. <br>  Un autre groupe important d'opérateurs est les opérateurs unaires, dont chacun n'accepte qu'un seul opérande.  En tant qu'opérateur unaire, esperluette &amp; obtient l'adresse d'une variable. <br><br>  Si p est un pointeur sur un entier et i est un entier, l'opérateur <br><br><pre> <code class="cpp hljs">p = &amp;i;</code> </pre> <br>  calcule l'adresse i et la stocke dans la variable p. <br>  L'opposé de la prise d'une adresse est un opérateur qui prend un pointeur en entrée et calcule la valeur à cette adresse.  Si nous venons d'affecter l'adresse i au pointeur p, alors * p a la même signification que i. <br><br>  En d'autres termes, en tant qu'opérateur unaire, un astérisque est suivi d'un pointeur (ou <br>  expression donnant un pointeur) et renvoie la valeur de l'élément vers lequel il pointe.  Si i a une valeur de 6, alors l'opérateur <br><br><pre> <code class="cpp hljs">j = *;</code> </pre> <br>  attribuera j le numéro 6. <br>  L'opératrice!  (le point d'exclamation est l'opérateur de négation) renvoie 0 si son opérande est différent de zéro et 1 si son opérateur est 0. <br><br>  Il est principalement utilisé dans les instructions if, par exemple <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!x) k=<span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  vérifie la valeur de x.  Si x est zéro (faux), alors k reçoit la valeur 0. En fait, l'opérateur!  annule la condition qui la suit, tout comme l'opérateur not dans Pascal. <br><br>  L'opérateur ~ est un opérateur complémentaire au niveau du bit.  Chaque 0 dans son opérande <br>  devient 1, et chaque 1 devient 0. <br><br>  L'opérateur sizeof indique la taille de son opérande en octets.  Par rapport à <br>  un tableau de 20 entiers a sur un ordinateur avec des entiers de 2 octets, par exemple sizeof a aura une valeur de 40. <br><br>  Le dernier groupe d'opérateurs est celui des opérateurs d'augmentation et de diminution. <br><br>  Opératrice <br><br><pre> <code class="cpp hljs">++;</code> </pre> <br>  signifie une augmentation de p.  La quantité de p augmentera en fonction de son type. <br>  Les nombres entiers ou caractères incrémentent de 1, mais les pointeurs incrémentent de <br>  la taille de l'objet pointé de cette façon, si a est un tableau de structures, et p est un pointeur vers l'une de ces structures, et nous écrivons <br><br><pre> <code class="cpp hljs">p = &amp;a[<span class="hljs-number"><span class="hljs-number">3</span></span>];</code> </pre> <br>  faire pointer p vers l'une des structures du tableau, puis après avoir augmenté p <br>  pointera vers un [4] quelle que soit la taille des structures.  Opératrice <br><br><pre> <code class="cpp hljs">p--;</code> </pre> <br>  similaire à l'opérateur p ++, sauf qu'il diminue plutôt qu'il n'augmente la valeur de l'opérande. <br><br>  En déclaration <br><br><pre> <code class="cpp hljs">n = k++;</code> </pre> <br>  où les deux variables sont des entiers, la valeur d'origine de k est affectée à n et <br>  ce n'est qu'alors que k augmente.  En déclaration <br><br><pre> <code class="cpp hljs">n = ++ k;</code> </pre> <br>  k augmente d'abord, puis sa nouvelle valeur est stockée dans n. <br><br>  Ainsi, un opérateur ++ (ou -) peut être écrit avant ou après son opérande, ce qui donne différentes valeurs. <br><br>  La dernière déclaration est-ce?  (point d'interrogation) qui sélectionne l'une des deux alternatives <br>  séparés par deux points.  Par exemple, un opérateur, <br><br><pre> <code class="cpp hljs">i = (x &lt; y ? <span class="hljs-number"><span class="hljs-number">6</span></span> : k + <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  compare x à y.  Si x est inférieur à y, alors i obtient la valeur 6;  sinon, la variable i obtient la valeur k + 1. Les crochets sont facultatifs. <br><br><h3>  A.6.  Structure du programme </h3><br>  Un programme C consiste en un ou plusieurs fichiers contenant des procédures et des déclarations. <br>  Ces fichiers peuvent être compilés individuellement en fichiers objets, qui sont ensuite liés les uns aux autres (à l'aide de l'éditeur de liens) pour former un programme exécutable. <br>  Contrairement à Pascal, les déclarations de procédure ne peuvent pas être imbriquées, elles sont donc toutes écrites au «niveau supérieur» dans le fichier programme. <br><br>  Il est autorisé de déclarer des variables en dehors des procédures, par exemple au début du fichier avant la première déclaration de la procédure.  Ces variables sont globales et peuvent être utilisées dans n'importe quelle procédure du programme, sauf si le mot clé statique précède la déclaration.  Dans ce cas, ces variables ne peuvent pas être utilisées dans un autre fichier.  Les mêmes règles s'appliquent aux procédures.  Les variables déclarées à l'intérieur d'une procédure sont locales à la procédure. <br>  La procédure peut accéder à la variable entière v déclarée dans un autre fichier (à condition que la variable ne soit pas statique), la déclarant externe: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v;</code> </pre> <br>  Chaque variable globale doit être déclarée une seule fois sans l'attribut extern afin de lui allouer de la mémoire. <br><br>  Les variables peuvent être initialisées lorsqu'elles sont déclarées: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre> <br>  Les tableaux et les structures peuvent également être initialisés.  Les variables globales qui ne sont pas explicitement initialisées reçoivent une valeur par défaut de zéro. <br><br><h3>  A.7.  Préprocesseur C </h3><br>  Avant que le fichier source soit transféré vers le compilateur C, il est automatiquement traité <br>  un programme appelé préprocesseur.  C'est la sortie du préprocesseur, pas <br>  Le programme d'origine est alimenté à l'entrée du compilateur.  Le préprocesseur effectue <br>  Trois conversions de base dans un fichier avant de le passer au compilateur: <br><br>  1. Inclusion de fichiers. <br>  2. Définition et remplacement des macros. <br>  3. Compilation conditionnelle. <br><br>  Toutes les directives du préprocesseur commencent par un signe numérique (#) dans la 1ère colonne. <br>  Lorsqu'une directive view <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"prog.h"</span></span></span></span></code> </pre> <br>  rencontré par le préprocesseur, il inclut le fichier prog.h, ligne par ligne, en <br>  le programme à passer au compilateur.  Lorsque la directive #include est écrite comme <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;prog.h&gt;</span></span></span></span></code> </pre> <br>  puis le fichier inclus est recherché dans le répertoire / usr / include au lieu du répertoire de travail.  Il est courant en C de regrouper les déclarations utilisées par plusieurs fichiers dans un fichier d'en-tête (généralement avec le suffixe .h) et de les inclure si nécessaire. <br>  Le préprocesseur permet également des définitions de macro.  Par exemple <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BLOCK_SIZE 1024</span></span></code> </pre> <br>   BLOCK_SIZE     1024.    <br>     10  «BLOCK_SIZE»    <br>  4-  «1024»  ,      .        .    ,      . <br><br>    —  .  MINIX   <br> ,       8088,           .     : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> i8088 </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;   8088&gt; #endif</span></span></span></span></code> </pre> <br>   i8088 ,       #ifdef i8088  #endif     ;     .     <br><br><pre> <code class="cpp hljs">cc -c -Di8088 prog.c</code> </pre> <br>      <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> i8088</span></span></code> </pre> <br>    i8088,      8088  .    MINIX       68000s   ,    . <br><br>    ,   ,   . A-7 (a).       prog.h,     : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAXAELEMENTS 100</span></span></code> </pre><br> ,      <br><br><pre> <code class="bash hljs">cc -E -Di8088 prog.c</code> </pre> <br>  ,     ,   ,    . A-7 (b). <br><br>   ,    ,     C . <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#include prog.h int x; main () main (); { { int a[MAX_ELEMENTS]; int a [100];  = 4;  = 4; a[x] = 6; [] = 6; #ifdef i8088 printf("8088. a[x]:% d\n", a[x]); printf ("8088. a[x]:% d\n", a[x]); #endif } #ifdef m68000 printf ("68000. x=%d\n", x); #endif } () (b) . -7. (a)   prog.c. (b)  .</span></span></code> </pre> <br>  ,         ,    #.       <br><br><pre> <code class="bash hljs">cc -c -Dm68000 prog.c</code> </pre> <br>      .       : <br><br><pre> <code class="bash hljs">cc -c prog.c</code> </pre> <br>        . (    ,   ,        -Dﬂags.) <br><br><h3> .8.  </h3><br>       ,    C,       .    : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n--) *p++ = *q++;</code> </pre> <br>  p  q    ,  n  .   n-   ,    q,  ,    .      ,      0,     ,           . <br><br>    : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; i++) a[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>    N    0.       : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (p = &amp;a[<span class="hljs-number"><span class="hljs-number">0</span></span>]; p &lt; &amp;a[N]; p++) *p = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>      p  ,      .     ,  p    N-  .    ,   ,     . <br><br>       .  Par exemple <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a = f (x)) &lt;  &gt;;</code> </pre> <br>    f,      a  <br> , ,     ()   ().     ,   .  Opératrice <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a = b) &lt;  &gt;;</code> </pre> <br>     b  a,    a,     .       <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a == b) &lt;  &gt;;</code> </pre> <br>       ,   . <br><br><h3>  Postface </h3><br>   .   ,     ,   .          . ,          . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr464075/">https://habr.com/ru/post/fr464075/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr464053/index.html">Nota: Algorithme de sélection et de rotation des pistes</a></li>
<li><a href="../fr464055/index.html">Nous étudions les données collectées par Xiaomi Mi Band pour l'année</a></li>
<li><a href="../fr464057/index.html">Hilbert, Lebesgue ... et le vide</a></li>
<li><a href="../fr464063/index.html">Couper le câble en 2019</a></li>
<li><a href="../fr464071/index.html">Révolution ou douleur? Rapport Yandex React Hooks</a></li>
<li><a href="../fr464077/index.html">Non, vous n'avez pas besoin de delta ve à 50 km / s. Vous avez besoin de technologies additives (partie 1)</a></li>
<li><a href="../fr464079/index.html">Comment faire un vaisseau spatial de décollage et d'atterrissage horizontal sans technologie miracle</a></li>
<li><a href="../fr464083/index.html">Comment ITSM va aider et qui applique cette méthodologie</a></li>
<li><a href="../fr464089/index.html">Automatiser les requêtes HTTP dans le contexte de Spring</a></li>
<li><a href="../fr464091/index.html">Le condensé de matériaux intéressants pour le développeur mobile # 311 (du 12 au 18 août)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>