<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë©‚Äçüíº üóùÔ∏è ‚õµÔ∏è Introduction √† C. Message du si√®cle dernier üñºÔ∏è üßóüèæ üç¶</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©face 
 Dans mes commentaires, je me suis r√©f√©r√© √† plusieurs reprises au livre Operating Systems Design and Implementation d‚ÄôAndrew Tanenbaum, √† sa ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Introduction √† C. Message du si√®cle dernier</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/464075/"><h3>  Pr√©face </h3><br>  Dans mes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">commentaires, je me suis</a> r√©f√©r√© √† plusieurs reprises au livre Operating Systems Design and Implementation d‚ÄôAndrew Tanenbaum, √† sa <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">premi√®re √©dition,</a> et √† la fa√ßon dont C y est repr√©sent√©.  Et ces commentaires ont toujours √©t√© int√©ressants.  J'ai d√©cid√© qu'il √©tait temps de publier une traduction de cette introduction en C.  C'est toujours d'actualit√©.  Bien qu'il y ait certainement ceux qui n'ont pas entendu parler du langage de programmation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PL / 1</a> , et peut-√™tre m√™me du syst√®me d'exploitation <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Minix</a> . <br><br>  Cette description est √©galement int√©ressante d'un point de vue historique et pour comprendre jusqu'o√π le langage C est all√© depuis sa naissance et l'industrie informatique dans son ensemble. <br><a name="habracut"></a><br>  Je souhaite imm√©diatement r√©server que ma deuxi√®me langue soit le fran√ßais: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/961/467/5a3/9614675a3883bf417fa2505dada57690.png" alt="image"><br><br>  Mais cela est compens√© par 46 ans d' <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">exp√©rience en programmation</a> . <br>  Alors, commen√ßons, c'est au tour d'Andrew Tanenbaum. <br><br><h3>  Introduction au langage C (pp. 350 - 362) </h3><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/cx/s5/il/cxs5ilctyz8rybmfwoqyjahv5ty.png"></div><br><br>  Le langage de programmation C a √©t√© cr√©√© par Dennis Ritchie d'AT &amp; T Bell Laboratories en tant que langage de programmation de haut niveau pour le d√©veloppement du syst√®me d'exploitation UNIX.  Actuellement, la langue est largement utilis√©e dans divers domaines.  C est particuli√®rement populaire aupr√®s des programmeurs syst√®me car il vous permet d'√©crire des programmes de mani√®re simple et concise. <br><br>  Le livre principal d√©crivant le langage C est le livre du langage de programmation C (1978) de Brian Kernigan et Dennis Ritchie.  Des livres sur le langage C ont √©t√© √©crits par Bolon (1986), Gehani (1984), Hancock et Krieger (1986), Harbison et Steele (1984) et bien d'autres. <br><br>  Dans cette application, nous essaierons de donner une introduction assez compl√®te au C, afin que ceux qui sont familiers avec les langages de haut niveau tels que Pascal, PL / 1 ou Modula 2 puissent comprendre la plupart du code MINIX donn√© dans ce livre.  Les fonctionnalit√©s C qui ne sont pas utilis√©es dans MINIX ne sont pas trait√©es ici.  Nombreux points subtils omis.  L'accent est mis sur la lecture de programmes C plut√¥t que sur l'√©criture de code. <br><br><h3>  A.1.  Bases du langage C </h3><br>  Un programme C se compose d'un ensemble de proc√©dures (souvent appel√©es fonctions, m√™me si elles ne renvoient pas de valeurs).  Ces proc√©dures contiennent des d√©clarations, des op√©rateurs et d'autres √©l√©ments qui, ensemble, indiquent √† l'ordinateur quoi faire.  La figure A-1 montre une petite proc√©dure dans laquelle trois variables enti√®res sont d√©clar√©es et affect√©es √† des valeurs.  Le nom de la proc√©dure est principal.  La proc√©dure n'a pas de param√®tres formels, comme l'indique l'absence d'identificateurs entre les crochets derri√®re le nom de la proc√©dure.  Le corps de la proc√©dure est plac√© entre accolades ({}).  Cet exemple montre que C a des variables et que ces variables doivent √™tre d√©clar√©es avant utilisation.  C a √©galement des op√©rateurs, dans cet exemple ce sont des op√©rateurs d'affectation.  Toutes les instructions doivent se terminer par un point-virgule (contrairement √† Pascal, qui utilise des deux-points entre les instructions, pas apr√®s). <br><br>  Les commentaires commencent par les caract√®res ¬´/ *¬ª et se terminent par les caract√®res ¬´* /¬ª et peuvent s'√©tendre sur plusieurs lignes. <br><br><pre><code class="cpp hljs">main () <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, j, k; <span class="hljs-comment"><span class="hljs-comment">/*  3   */</span></span> i = <span class="hljs-number"><span class="hljs-number">10</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  i  10 ( ) */</span></span> j = i + <span class="hljs-number"><span class="hljs-number">015</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  j  i + 015 ( ) */</span></span> k = j * j + <span class="hljs-number"><span class="hljs-number">0xFF</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*  k  j * j + 0xFF ( ) */</span></span> } . Al.    .</code> </pre> <br>  La proc√©dure contient trois constantes.  Constante 10 dans la premi√®re affectation <br>  c'est une constante d√©cimale ordinaire.  La constante 015 est une constante octale <br>  (√©gal √† 13 en d√©cimal).  Les constantes octales commencent toujours √† z√©ro.  La constante 0xFF est une constante hexad√©cimale (√©gale √† 255 d√©cimales).  Les constantes hexad√©cimales commencent toujours par 0x.  Les trois types sont utilis√©s en C. <br><br><h3>  A.2.  Types de donn√©es de base </h3><br>  C a deux principaux types de donn√©es (variables): un entier et un caract√®re, d√©clar√©s respectivement int et char.  Il n'y a pas de variable bool√©enne distincte.  La variable int est utilis√©e comme variable bool√©enne.  Si cette variable contient 0, cela signifie faux / faux et toute autre valeur signifie vrai / vrai.  C a √©galement des types √† virgule flottante, mais MINIX ne les utilise pas. <br><br>  Vous pouvez appliquer des ¬´adjectifs¬ª courts, longs ou non sign√©s √† un type int qui d√©finit une plage de valeurs (d√©pendant du compilateur).  La plupart des processeurs 8088 utilisent des entiers 16 bits pour int et short int et 32 ‚Äã‚Äãbits pour int long.  Les entiers non sign√©s (entier non sign√©) sur le processeur 8088 ont une plage de 0 √† 65535, et non de -32768 √† +32767, comme c'est le cas avec les entiers ordinaires (int).  Un caract√®re prend 8 bits. <br><br>  Le sp√©cificateur de registre est √©galement autoris√© pour int et char, et indique au compilateur que la variable d√©clar√©e doit √™tre plac√©e dans le registre pour que le programme fonctionne plus rapidement. <br><br>  Certaines annonces sont montr√©es sur la fig.  A - 2. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-comment"><span class="hljs-comment">/*    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> z1, z2; / *    */ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> k; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">long</span></span> flag_poll; <span class="hljs-comment"><span class="hljs-comment">/* 'int'    */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> r; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> . <span class="hljs-number"><span class="hljs-number">-2.</span></span>  .</code> </pre> <br>  La conversion entre les types est autoris√©e.  Par exemple, l'op√©rateur <br><br><pre> <code class="cpp hljs">flag_pole = i;</code> </pre> <br>  autoris√© m√™me si i est de type int et que flag_pole est long.  Dans de nombreux cas <br>  il est n√©cessaire ou utile de forcer les conversions entre les types de donn√©es.  Pour une conversion forc√©e, il suffit de mettre le type cible entre crochets devant l'expression √† convertir.  Par exemple: <br><br><pre> <code class="cpp hljs"> ( (<span class="hljs-keyword"><span class="hljs-keyword">long</span></span>) i);</code> </pre> <br>  indique de convertir l'entier i en long avant de le passer comme param√®tre √† la proc√©dure p, qui attend le param√®tre long. <br><br>  Lors de la conversion entre les types, faites attention au signe. <br>  Lors de la conversion d'un caract√®re en entier, certains compilateurs traitent les caract√®res comme sign√©s, c'est-√†-dire de - 128 √† +127, tandis que d'autres les traitent comme <br>  non sign√©, c'est-√†-dire de 0 √† 255. Dans MINIX, des expressions telles que <br><br><pre> <code class="cpp hljs">i = c &amp; <span class="hljs-number"><span class="hljs-number">0377</span></span>;</code> </pre> <br>  qui convertit de (caract√®re) en entier, puis effectue un ET logique <br>  (esperluette) avec la constante octale 0377. Le r√©sultat est que les 8 bits √©lev√©s <br>  sont mis √† z√©ro, for√ßant en fait c √† √™tre consid√©r√© comme un nombre non sign√© de 8 bits, dans la plage de 0 √† 255. <br><br><h3>  A.3.  Types de compos√©s et pointeurs </h3><br>  Dans cette section, nous examinerons quatre fa√ßons de cr√©er des types de donn√©es plus complexes: les tableaux, les structures, les unions et les pointeurs.  Un tableau est une collection / un ensemble d'√©l√©ments du m√™me type.  Tous les tableaux en C commencent par l'√©l√©ment 0. <br><br>  Annonce <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a [<span class="hljs-number"><span class="hljs-number">10</span></span>];</code> </pre> <br>  d√©clare un tableau a avec 10 entiers √† stocker dans les √©l√©ments du tableau de [0] √† a [9].  Deuxi√®mement, les tableaux peuvent avoir trois dimensions ou plus, mais ils ne sont pas utilis√©s dans MINIX. <br>  Une structure est un ensemble de variables, g√©n√©ralement de diff√©rents types.  La structure en C est similaire √† celle de Pascal.  Op√©ratrice <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c;} s;</code> </pre> <br>  d√©clare s comme une structure contenant deux membres, l'entier i et le caract√®re c. <br><br>  Pour affecter le membre i de la structure s √† 6, √©crivez l'expression suivante: <br><br><pre> <code class="cpp hljs">si = <span class="hljs-number"><span class="hljs-number">6</span></span>;</code> </pre> <br>  o√π l'op√©rateur point indique que l'√©l√©ment i appartient √† la structure s. <br>  Un syndicat est √©galement un ensemble de membres, semblable √† une structure, sauf qu'√† tout moment un seul d'entre eux peut √™tre membre d'un syndicat.  Annonce <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">union</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> c;} u;</code> </pre> <br>  signifie que vous pouvez avoir un entier ou un caract√®re, mais pas les deux.  Le compilateur doit allouer suffisamment d'espace pour la combinaison afin qu'il puisse accueillir le plus grand √©l√©ment de combinaison (du point de vue de la m√©moire occup√©e).  Les unions ne sont utilis√©es qu'√† deux endroits dans MINIX (pour d√©finir un message comme une union de plusieurs structures diff√©rentes, et pour d√©finir un bloc de disque comme une union d'un bloc de donn√©es, d'un bloc i-node, d'un bloc catalogue, etc.). <br><br>  Les pointeurs sont utilis√©s pour stocker les adresses des machines en C.  Ils sont utilis√©s tr√®s, tr√®s souvent.  Un ast√©risque (*) est utilis√© pour indiquer un pointeur dans les annonces.  Annonce <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i, *pi, a [<span class="hljs-number"><span class="hljs-number">10</span></span>], *b[<span class="hljs-number"><span class="hljs-number">10</span></span>], **ppi;</code> </pre> <br>  d√©clare un entier i, un pointeur sur un entier pi, un tableau a de 10 √©l√©ments, un tableau b de 10 pointeurs sur des entiers et un pointeur sur un pointeur ppi sur un entier. <br><br>  Les r√®gles de syntaxe exactes pour les d√©clarations complexes qui combinent des tableaux, des pointeurs et d'autres types sont quelque peu complexes.  Heureusement, MINIX n'utilise que des d√©clarations simples. <br><br>  La figure A-3 montre la d√©claration d'un tableau z de structures de table struct, chacune ayant <br>  trois membres, entier i, pointeur cp vers caract√®re et caract√®re c. <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">table</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> i; / *  */ <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *cp, c; <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> } z [<span class="hljs-number"><span class="hljs-number">20</span></span>]; <span class="hljs-comment"><span class="hljs-comment">/*    20  */</span></span> .  - <span class="hljs-number"><span class="hljs-number">3.</span></span>  .</code> </pre> <br>  Les tableaux de structures sont courants dans MINIX.  De plus, la table de noms peut √™tre d√©clar√©e comme une structure de table struct qui peut √™tre utilis√©e dans les d√©clarations suivantes.  Par exemple <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">register</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">table</span></span></span><span class="hljs-class"> *</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">p</span></span></span><span class="hljs-class">;</span></span></code> </pre> <br>  d√©clare p un pointeur sur une structure de table struct et sugg√®re de l'enregistrer <br>  dans le registre.  Pendant l'ex√©cution du programme, p peut indiquer, par exemple, z [4] ou <br>  √† tout autre √©l√©ment de z, dont les 20 √©l√©ments sont des structures de type struct table. <br><br>  Pour faire de p un pointeur sur z [4], il suffit d'√©crire <br><br><pre> <code class="cpp hljs">p = &amp;z[<span class="hljs-number"><span class="hljs-number">4</span></span>];</code> </pre> <br>  o√π l'esperluette en tant qu'op√©rateur unaire (monadique) signifie "prendre l'adresse de ce qui la suit".  Copiez la valeur du membre i dans la variable enti√®re n <br>  la structure point√©e par p peut se faire comme suit: <br><br><pre> <code class="cpp hljs">n = p-&gt;i;</code> </pre> <br>  Notez que la fl√®che est utilis√©e pour acc√©der √† un membre de la structure via un pointeur.  Si nous utilisons la variable z, alors nous devons utiliser l'op√©rateur point: <br><br><pre> <code class="cpp hljs">n = z [<span class="hljs-number"><span class="hljs-number">4</span></span>] .i;</code> </pre> <br>  La diff√©rence est que z [4] est une structure, et l'op√©rateur de point s√©lectionne les √©l√©ments <br>  √† partir de types composites (structures, tableaux) directement.  √Ä l'aide de pointeurs, nous ne s√©lectionnons pas directement un participant.  Le pointeur vous demande de s√©lectionner d'abord une structure, puis de s√©lectionner ensuite un membre de cette structure. <br><br>  Parfois, il est pratique de donner un nom √† un type composite.  Par exemple: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">short</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> unshort;</code> </pre> <br>  d√©finit unshort comme non sign√© court (entier court non sign√©).  Maintenant unshort peut √™tre utilis√© dans le programme comme type principal.  Par exemple <br><br><pre> <code class="cpp hljs">unshort ul, *u2, u3[<span class="hljs-number"><span class="hljs-number">5</span></span>];</code> </pre> <br>  d√©clare un entier court non sign√©, un pointeur sur un entier court non sign√© et <br>  un tableau d'entiers courts non sign√©s. <br><br><h3>  A.4.  Les op√©rateurs </h3><br>  Les proc√©dures en C contiennent des d√©clarations et des d√©clarations.  Nous avons d√©j√† vu les d√©clarations, nous allons donc maintenant consid√©rer les op√©rateurs.  Le but des op√©rateurs conditionnels et de boucle est essentiellement le m√™me que dans d'autres langues.  La figure A-4 en montre plusieurs exemples.  La seule chose √† laquelle il faut faire attention est que les accolades sont utilis√©es pour grouper les op√©rateurs, et l'instruction while a deux formes, dont la seconde est similaire √† l'instruction r√©p√©t√©e de Pascal. <br><br>  C a √©galement une instruction for, mais elle ne ressemble √† une instruction for dans aucune autre langue.  L'instruction for a la forme suivante: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (&lt;&gt;; &lt;&gt;; &lt;&gt;) ;</code> </pre> <br>  La m√™me chose peut √™tre exprim√©e √† travers la d√©claration while: <br><br><pre> <code class="cpp hljs">&lt;&gt; <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(&lt;&gt;) { &lt;&gt;; &lt;&gt; }</code> </pre> <br>  √Ä titre d'exemple, consid√©rons l'√©nonc√© suivant: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i=<span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt;n; i = i+l) a[i]=<span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  Cet op√©rateur met √† z√©ro les n premiers √©l√©ments du tableau a.  L'ex√©cution de l'op√©rateur commence par mettre i √† z√©ro (cela se fait en dehors de la boucle).  Ensuite, l'op√©rateur est r√©p√©t√© jusqu'√† i &lt;n, tout en effectuant l'affectation et l'augmentation de i.  Bien s√ªr, au lieu de l'op√©rateur d'assigner une valeur √† l'√©l√©ment actuel d'un tableau z√©ro, il peut y avoir un op√©rateur compos√© (bloc) entre crochets. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &lt; <span class="hljs-number"><span class="hljs-number">0</span></span>) k = <span class="hljs-number"><span class="hljs-number">3</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   if */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x &gt; y) { <span class="hljs-comment"><span class="hljs-comment">/*   if */</span></span> i = <span class="hljs-number"><span class="hljs-number">2</span></span>; k = j + l, } <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (x + <span class="hljs-number"><span class="hljs-number">2</span></span> &lt;y) { <span class="hljs-comment"><span class="hljs-comment">/*  if-else */</span></span> j = <span class="hljs-number"><span class="hljs-number">2</span></span>; k = j - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { m = <span class="hljs-number"><span class="hljs-number">0</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>) { <span class="hljs-comment"><span class="hljs-comment">/*  while */</span></span> k = k + k; n = n - l; } <span class="hljs-keyword"><span class="hljs-keyword">do</span></span> { / *    <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> */ k = k + k; n = n - <span class="hljs-number"><span class="hljs-number">1</span></span>; } <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n &gt; <span class="hljs-number"><span class="hljs-number">0</span></span>); . A<span class="hljs-number"><span class="hljs-number">-4.</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>  <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>  C.</code> </pre> <br>  C a √©galement un op√©rateur similaire √† l'op√©rateur case en Pascal.  Il s'agit d'une instruction switch.  Un exemple est illustr√© √† la figure A-5.  En fonction de la valeur de l'expression sp√©cifi√©e dans switch, l'une ou l'autre instruction case est s√©lectionn√©e. <br><br>  Si l'expression ne correspond √† aucune des instructions case, l'instruction par d√©faut est s√©lectionn√©e. <br><br>  Si l'expression n'est associ√©e √† aucune instruction case et que l'instruction par d√©faut est absente, l'ex√©cution se poursuit √† partir de l'instruction suivante apr√®s l'instruction switch. <br><br>  Il convient de noter que pour quitter le bloc de cas, utilisez l'instruction break.  S'il n'y a pas d'instruction break, le bloc de cas suivant sera ex√©cut√©. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (k) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">10</span></span>: i = <span class="hljs-number"><span class="hljs-number">6</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   case 20, ..    switch */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">20</span></span>: i = <span class="hljs-number"><span class="hljs-number">2</span></span>; k = <span class="hljs-number"><span class="hljs-number">4</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; / *   <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>* / <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: j = <span class="hljs-number"><span class="hljs-number">5</span></span>; } . A<span class="hljs-number"><span class="hljs-number">-5.</span></span>   <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span></code> </pre> <br>  L'instruction break agit √©galement √† l'int√©rieur des boucles for et while.  Il ne faut pas oublier que si l'instruction break se trouve √† l'int√©rieur d'une s√©rie de boucles imbriqu√©es, la sortie n'est que d'un niveau sup√©rieur. <br><br>  Une instruction connexe est l'instruction continue, qui ne quitte pas la boucle, <br>  mais provoque la fin de l'it√©ration en cours et le d√©but de l'it√©ration suivante <br>  imm√©diatement.  Il s'agit essentiellement d'un retour en haut de la boucle. <br><br>  C a des proc√©dures qui peuvent √™tre appel√©es avec ou sans param√®tres. <br>  Selon Kernigan et Ritchie (p. 121), il n'est pas autoris√© de transf√©rer des tableaux, <br>  structures ou proc√©dures en tant que param√®tres, bien que passant des pointeurs √† tout cela <br>  autoris√©.  Existe-t-il un livre ou non (il appara√Ætra dans ma m√©moire: - "S'il y a de la vie sur Mars, s'il n'y en a pas sur Mars"), de nombreux compilateurs C autorisent les structures comme param√®tres. <br>  Le nom du tableau, s'il est √©crit sans index, signifie un pointeur vers un tableau, ce qui simplifie le transfert d'un pointeur de tableau.  Ainsi, si a est le nom d'un tableau de n'importe quel type, il peut √™tre pass√© √† g en √©crivant <br><br><pre> <code class="cpp hljs">g();</code> </pre> <br>  Cette r√®gle s'applique uniquement aux tableaux; cette r√®gle ne s'applique pas aux structures. <br>  Les proc√©dures peuvent renvoyer des valeurs en ex√©cutant une instruction return.  Cette instruction peut contenir une expression, dont le r√©sultat sera renvoy√© comme valeur de la proc√©dure, mais l'appelant peut ignorer la valeur de retour en toute s√©curit√©.  Si la proc√©dure renvoie une valeur, alors la valeur de type est √©crite avant le nom de la proc√©dure, comme illustr√© √† la Fig.  A-6.  Comme les param√®tres, les proc√©dures ne peuvent pas renvoyer de tableaux, de structures ou de proc√©dures, mais peuvent leur renvoyer des pointeurs.  Cette r√®gle est con√ßue pour une impl√©mentation plus efficace - tous les param√®tres et r√©sultats correspondent toujours √† un mot machine (dans lequel l'adresse est stock√©e).  Les compilateurs qui autorisent l'utilisation de structures en tant que param√®tres autorisent g√©n√©ralement leur utilisation en tant que valeurs de retour. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sum</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, j)</span></span></span><span class="hljs-function"> </span><span class="hljs-comment"><span class="hljs-function"><span class="hljs-comment">/*      */</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> i, j </span></span>; <span class="hljs-comment"><span class="hljs-comment">/*   */</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (i + j); <span class="hljs-comment"><span class="hljs-comment">/*      */</span></span> } . <span class="hljs-number"><span class="hljs-number">-6.</span></span>   ,   .</code> </pre> <br>  C n'a pas d'E / S int√©gr√©es.  L'entr√©e / sortie est impl√©ment√©e en appelant des fonctions de biblioth√®que, dont les plus courantes sont illustr√©es ci-dessous: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">printf</span></span> (¬´x=% dy = %oz = %x \n¬ª, x, y, z);</code> </pre> <br>  Le premier param√®tre est la cha√Æne de caract√®res entre guillemets (en fait, il s'agit d'un tableau de caract√®res). <br><br>  Tout caract√®re qui n'est pas un pourcentage est simplement imprim√© tel quel. <br><br>  Lorsqu'un pourcentage se produit, le param√®tre suivant est imprim√© sous la forme d√©finie par la lettre suivant le pourcentage: <br><blockquote>  d - imprimer sous forme d'entier d√©cimal <br>  o - imprimer comme un entier octal <br>  u - imprimer comme un entier d√©cimal non sign√© <br>  x - affiche un entier hexad√©cimal <br>  s - imprimer comme une cha√Æne de caract√®res <br>  c - imprimer en un seul caract√®re </blockquote>  Les lettres D, 0 et X sont √©galement autoris√©es pour l'impression d√©cimale, octale et hexad√©cimale des nombres longs. <br><br><h3>  A.5.  Expressions </h3><br>  Les expressions sont cr√©√©es en combinant des op√©randes et des op√©rateurs. <br><br>  Op√©rateurs arithm√©tiques tels que + et - et op√©rateurs relationnels tels que &lt; <br>  et&gt; similaires √† leurs homologues dans d'autres langues.  % Op√©rateur <br>  utilis√© modulo.  Il convient de noter que l'op√©rateur d'√©galit√© est ==, et l'op√©rateur d'in√©galit√© est!  =.  Pour v√©rifier si a et b sont √©gaux, vous pouvez √©crire comme ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a == b) &lt;&gt;;</code> </pre> <br>  C vous permet √©galement de combiner l'op√©rateur d'affectation avec d'autres op√©rateurs, donc <br><br><pre> <code class="cpp hljs">a += <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre> <br>  √©quivalent √† l'enregistrement <br><br><pre> <code class="cpp hljs"> =  + <span class="hljs-number"><span class="hljs-number">4</span></span>;</code> </pre><br>  D'autres op√©rateurs peuvent √©galement √™tre combin√©s de cette mani√®re. <br><br>  C a des op√©rateurs pour manipuler les bits d'un mot.  Les d√©calages et les op√©rations logiques au niveau du bit sont autoris√©s.  Les op√©rateurs de d√©calage gauche et droit sont &lt;&lt; <br>  et &gt;&gt; respectivement.  Op√©rateurs logiques bit √† bit &amp;, |  et ^, qui sont des ET logiques (ET), y compris OU (OU) et OU exclusif (XOP), respectivement.  Si i a la valeur 035 (octal), alors l'expression i &amp; 06 a la valeur 04 (octal).  Un autre exemple, si i = 7, alors <br><br><pre> <code class="cpp hljs">j = (i &lt;&lt; <span class="hljs-number"><span class="hljs-number">3</span></span>) | <span class="hljs-number"><span class="hljs-number">014</span></span>;</code> </pre> <br>  et obtenez 074 pour j. <br>  Un autre groupe important d'op√©rateurs est les op√©rateurs unaires, dont chacun n'accepte qu'un seul op√©rande.  En tant qu'op√©rateur unaire, esperluette &amp; obtient l'adresse d'une variable. <br><br>  Si p est un pointeur sur un entier et i est un entier, l'op√©rateur <br><br><pre> <code class="cpp hljs">p = &amp;i;</code> </pre> <br>  calcule l'adresse i et la stocke dans la variable p. <br>  L'oppos√© de la prise d'une adresse est un op√©rateur qui prend un pointeur en entr√©e et calcule la valeur √† cette adresse.  Si nous venons d'affecter l'adresse i au pointeur p, alors * p a la m√™me signification que i. <br><br>  En d'autres termes, en tant qu'op√©rateur unaire, un ast√©risque est suivi d'un pointeur (ou <br>  expression donnant un pointeur) et renvoie la valeur de l'√©l√©ment vers lequel il pointe.  Si i a une valeur de 6, alors l'op√©rateur <br><br><pre> <code class="cpp hljs">j = *;</code> </pre> <br>  attribuera j le num√©ro 6. <br>  L'op√©ratrice!  (le point d'exclamation est l'op√©rateur de n√©gation) renvoie 0 si son op√©rande est diff√©rent de z√©ro et 1 si son op√©rateur est 0. <br><br>  Il est principalement utilis√© dans les instructions if, par exemple <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!x) k=<span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>  v√©rifie la valeur de x.  Si x est z√©ro (faux), alors k re√ßoit la valeur 0. En fait, l'op√©rateur!  annule la condition qui la suit, tout comme l'op√©rateur not dans Pascal. <br><br>  L'op√©rateur ~ est un op√©rateur compl√©mentaire au niveau du bit.  Chaque 0 dans son op√©rande <br>  devient 1, et chaque 1 devient 0. <br><br>  L'op√©rateur sizeof indique la taille de son op√©rande en octets.  Par rapport √† <br>  un tableau de 20 entiers a sur un ordinateur avec des entiers de 2 octets, par exemple sizeof a aura une valeur de 40. <br><br>  Le dernier groupe d'op√©rateurs est celui des op√©rateurs d'augmentation et de diminution. <br><br>  Op√©ratrice <br><br><pre> <code class="cpp hljs">++;</code> </pre> <br>  signifie une augmentation de p.  La quantit√© de p augmentera en fonction de son type. <br>  Les nombres entiers ou caract√®res incr√©mentent de 1, mais les pointeurs incr√©mentent de <br>  la taille de l'objet point√© de cette fa√ßon, si a est un tableau de structures, et p est un pointeur vers l'une de ces structures, et nous √©crivons <br><br><pre> <code class="cpp hljs">p = &amp;a[<span class="hljs-number"><span class="hljs-number">3</span></span>];</code> </pre> <br>  faire pointer p vers l'une des structures du tableau, puis apr√®s avoir augment√© p <br>  pointera vers un [4] quelle que soit la taille des structures.  Op√©ratrice <br><br><pre> <code class="cpp hljs">p--;</code> </pre> <br>  similaire √† l'op√©rateur p ++, sauf qu'il diminue plut√¥t qu'il n'augmente la valeur de l'op√©rande. <br><br>  En d√©claration <br><br><pre> <code class="cpp hljs">n = k++;</code> </pre> <br>  o√π les deux variables sont des entiers, la valeur d'origine de k est affect√©e √† n et <br>  ce n'est qu'alors que k augmente.  En d√©claration <br><br><pre> <code class="cpp hljs">n = ++ k;</code> </pre> <br>  k augmente d'abord, puis sa nouvelle valeur est stock√©e dans n. <br><br>  Ainsi, un op√©rateur ++ (ou -) peut √™tre √©crit avant ou apr√®s son op√©rande, ce qui donne diff√©rentes valeurs. <br><br>  La derni√®re d√©claration est-ce?  (point d'interrogation) qui s√©lectionne l'une des deux alternatives <br>  s√©par√©s par deux points.  Par exemple, un op√©rateur, <br><br><pre> <code class="cpp hljs">i = (x &lt; y ? <span class="hljs-number"><span class="hljs-number">6</span></span> : k + <span class="hljs-number"><span class="hljs-number">1</span></span>);</code> </pre> <br>  compare x √† y.  Si x est inf√©rieur √† y, alors i obtient la valeur 6;  sinon, la variable i obtient la valeur k + 1. Les crochets sont facultatifs. <br><br><h3>  A.6.  Structure du programme </h3><br>  Un programme C consiste en un ou plusieurs fichiers contenant des proc√©dures et des d√©clarations. <br>  Ces fichiers peuvent √™tre compil√©s individuellement en fichiers objets, qui sont ensuite li√©s les uns aux autres (√† l'aide de l'√©diteur de liens) pour former un programme ex√©cutable. <br>  Contrairement √† Pascal, les d√©clarations de proc√©dure ne peuvent pas √™tre imbriqu√©es, elles sont donc toutes √©crites au ¬´niveau sup√©rieur¬ª dans le fichier programme. <br><br>  Il est autoris√© de d√©clarer des variables en dehors des proc√©dures, par exemple au d√©but du fichier avant la premi√®re d√©claration de la proc√©dure.  Ces variables sont globales et peuvent √™tre utilis√©es dans n'importe quelle proc√©dure du programme, sauf si le mot cl√© statique pr√©c√®de la d√©claration.  Dans ce cas, ces variables ne peuvent pas √™tre utilis√©es dans un autre fichier.  Les m√™mes r√®gles s'appliquent aux proc√©dures.  Les variables d√©clar√©es √† l'int√©rieur d'une proc√©dure sont locales √† la proc√©dure. <br>  La proc√©dure peut acc√©der √† la variable enti√®re v d√©clar√©e dans un autre fichier (√† condition que la variable ne soit pas statique), la d√©clarant externe: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">extern</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> v;</code> </pre> <br>  Chaque variable globale doit √™tre d√©clar√©e une seule fois sans l'attribut extern afin de lui allouer de la m√©moire. <br><br>  Les variables peuvent √™tre initialis√©es lorsqu'elles sont d√©clar√©es: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> size = <span class="hljs-number"><span class="hljs-number">100</span></span>;</code> </pre> <br>  Les tableaux et les structures peuvent √©galement √™tre initialis√©s.  Les variables globales qui ne sont pas explicitement initialis√©es re√ßoivent une valeur par d√©faut de z√©ro. <br><br><h3>  A.7.  Pr√©processeur C </h3><br>  Avant que le fichier source soit transf√©r√© vers le compilateur C, il est automatiquement trait√© <br>  un programme appel√© pr√©processeur.  C'est la sortie du pr√©processeur, pas <br>  Le programme d'origine est aliment√© √† l'entr√©e du compilateur.  Le pr√©processeur effectue <br>  Trois conversions de base dans un fichier avant de le passer au compilateur: <br><br>  1. Inclusion de fichiers. <br>  2. D√©finition et remplacement des macros. <br>  3. Compilation conditionnelle. <br><br>  Toutes les directives du pr√©processeur commencent par un signe num√©rique (#) dans la 1√®re colonne. <br>  Lorsqu'une directive view <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"prog.h"</span></span></span></span></code> </pre> <br>  rencontr√© par le pr√©processeur, il inclut le fichier prog.h, ligne par ligne, en <br>  le programme √† passer au compilateur.  Lorsque la directive #include est √©crite comme <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;prog.h&gt;</span></span></span></span></code> </pre> <br>  puis le fichier inclus est recherch√© dans le r√©pertoire / usr / include au lieu du r√©pertoire de travail.  Il est courant en C de regrouper les d√©clarations utilis√©es par plusieurs fichiers dans un fichier d'en-t√™te (g√©n√©ralement avec le suffixe .h) et de les inclure si n√©cessaire. <br>  Le pr√©processeur permet √©galement des d√©finitions de macro.  Par exemple <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> BLOCK_SIZE 1024</span></span></code> </pre> <br>   BLOCK_SIZE     1024.    <br>     10  ¬´BLOCK_SIZE¬ª    <br>  4-  ¬´1024¬ª  ,      .        .    ,      . <br><br>    ‚Äî  .  MINIX   <br> ,       8088,           .     : <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifdef</span></span></span><span class="hljs-meta"> i8088 </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;   8088&gt; #endif</span></span></span></span></code> </pre> <br>   i8088 ,       #ifdef i8088  #endif     ;     .     <br><br><pre> <code class="cpp hljs">cc -c -Di8088 prog.c</code> </pre> <br>      <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> i8088</span></span></code> </pre> <br>    i8088,      8088  .    MINIX       68000s   ,    . <br><br>    ,   ,   . A-7 (a).       prog.h,     : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> x; <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> MAXAELEMENTS 100</span></span></code> </pre><br> ,      <br><br><pre> <code class="bash hljs">cc -E -Di8088 prog.c</code> </pre> <br>  ,     ,   ,    . A-7 (b). <br><br>   ,    ,     C . <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#include prog.h int x; main () main (); { { int a[MAX_ELEMENTS]; int a [100];  = 4;  = 4; a[x] = 6; [] = 6; #ifdef i8088 printf("8088. a[x]:% d\n", a[x]); printf ("8088. a[x]:% d\n", a[x]); #endif } #ifdef m68000 printf ("68000. x=%d\n", x); #endif } () (b) . -7. (a)   prog.c. (b)  .</span></span></code> </pre> <br>  ,         ,    #.       <br><br><pre> <code class="bash hljs">cc -c -Dm68000 prog.c</code> </pre> <br>      .       : <br><br><pre> <code class="bash hljs">cc -c prog.c</code> </pre> <br>        . (    ,   ,        -DÔ¨Çags.) <br><br><h3> .8.  </h3><br>       ,    C,       .    : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">while</span></span> (n--) *p++ = *q++;</code> </pre> <br>  p  q    ,  n  .   n-   ,    q,  ,    .      ,      0,     ,           . <br><br>    : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (i = <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; N; i++) a[i] = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>    N    0.       : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> (p = &amp;a[<span class="hljs-number"><span class="hljs-number">0</span></span>]; p &lt; &amp;a[N]; p++) *p = <span class="hljs-number"><span class="hljs-number">0</span></span>;</code> </pre> <br>      p  ,      .     ,  p    N-  .    ,   ,     . <br><br>       .  Par exemple <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a = f (x)) &lt;  &gt;;</code> </pre> <br>    f,      a  <br> , ,     ()   ().     ,   .  Op√©ratrice <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a = b) &lt;  &gt;;</code> </pre> <br>     b  a,    a,     .       <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (a == b) &lt;  &gt;;</code> </pre> <br>       ,   . <br><br><h3>  Postface </h3><br>   .   ,     ,   .          . ,          . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr464075/">https://habr.com/ru/post/fr464075/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr464053/index.html">Nota: Algorithme de s√©lection et de rotation des pistes</a></li>
<li><a href="../fr464055/index.html">Nous √©tudions les donn√©es collect√©es par Xiaomi Mi Band pour l'ann√©e</a></li>
<li><a href="../fr464057/index.html">Hilbert, Lebesgue ... et le vide</a></li>
<li><a href="../fr464063/index.html">Couper le c√¢ble en 2019</a></li>
<li><a href="../fr464071/index.html">R√©volution ou douleur? Rapport Yandex React Hooks</a></li>
<li><a href="../fr464077/index.html">Non, vous n'avez pas besoin de delta ve √† 50 km / s. Vous avez besoin de technologies additives (partie 1)</a></li>
<li><a href="../fr464079/index.html">Comment faire un vaisseau spatial de d√©collage et d'atterrissage horizontal sans technologie miracle</a></li>
<li><a href="../fr464083/index.html">Comment ITSM va aider et qui applique cette m√©thodologie</a></li>
<li><a href="../fr464089/index.html">Automatiser les requ√™tes HTTP dans le contexte de Spring</a></li>
<li><a href="../fr464091/index.html">Le condens√© de mat√©riaux int√©ressants pour le d√©veloppeur mobile # 311 (du 12 au 18 ao√ªt)</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>