<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤟🏿 🌴 😜 Jaringan saraf dan pembelajaran mendalam, bab 1: menggunakan jaringan saraf untuk mengenali angka tulisan tangan 🔩 🏁 🤙</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Catatan 
 Berikut ini adalah terjemahan buku online gratis Michael Nielsen, Neural Networks dan Deep Learning, yang didistribusikan di bawah Lisensi C...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Jaringan saraf dan pembelajaran mendalam, bab 1: menggunakan jaringan saraf untuk mengenali angka tulisan tangan</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/456738/"><h3>  Catatan </h3><br><img src="https://habrastorage.org/getpro/habr/post_images/d1f/7ac/ee5/d1f7acee5600a381c43f05c7df9c439a.jpg" alt="Michael nielsen" align="left">  Berikut ini adalah terjemahan buku online gratis Michael Nielsen, Neural Networks dan Deep Learning, yang didistribusikan di bawah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lisensi Creative Commons Attribution-NonCommercial 3.0 Unported</a> .  Motivasi untuk penciptaannya adalah pengalaman sukses menerjemahkan buku teks pemrograman, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">JavaScript Ekspresif</a> .  Buku tentang jaringan saraf juga cukup populer, penulis artikel berbahasa Inggris secara aktif mengutipnya.  Saya tidak menemukan terjemahannya, kecuali <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">terjemahan awal bab pertama dengan singkatan</a> . <br><br>  Mereka yang ingin berterima kasih kepada penulis buku dapat melakukan ini di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman resminya</a> , dengan mentransfer melalui PayPal atau Bitcoin.  Untuk mendukung penerjemah di Habré ada formulir "untuk mendukung penulis". <br><br><div class="spoiler">  <b class="spoiler_title">Isi</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 1: menggunakan jaringan saraf untuk mengenali nomor tulisan tangan</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 2: cara kerja algoritma backpropagation</a> </li><li>  Bab 3: <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1: meningkatkan metode pelatihan jaringan saraf</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2: Mengapa regularisasi membantu mengurangi pelatihan ulang?</a> <br></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 3: bagaimana memilih hyperparameters jaringan saraf?</a> <br></li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 4: bukti visual bahwa jaringan saraf mampu menghitung fungsi apa pun</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bab 5: mengapa jaringan saraf yang dalam begitu sulit untuk dilatih?</a> </li><li>  Bab 6: <ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 1: Pembelajaran Mendalam</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Bagian 2: kemajuan terbaru dalam pengenalan gambar</a> </li></ul></li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Kata penutup: apakah ada algoritma sederhana untuk menciptakan kecerdasan?</a> </li></ul></div></div><br><h2>  Pendahuluan </h2><br>  Tutorial ini akan memberi tahu Anda secara rinci tentang konsep-konsep seperti: <br><br><ul><li>  Jaringan saraf - paradigma perangkat lunak yang sangat baik, dibuat di bawah pengaruh biologi, dan memungkinkan komputer untuk belajar berdasarkan pengamatan. </li><li>  Pembelajaran mendalam adalah seperangkat teknik pelatihan jaringan saraf yang kuat. </li></ul><br>  Neural networks (NS) dan deep learning (GO) saat ini memberikan solusi terbaik untuk banyak masalah di bidang pengenalan gambar, suara dan pemrosesan bahasa alami.  Tutorial ini akan mengajarkan Anda banyak konsep kunci yang mendukung NS dan GO. <br><a name="habracut"></a><br><h2>  Tentang apa buku ini </h2><br>  NS adalah salah satu paradigma perangkat lunak terbaik yang pernah ditemukan oleh manusia.  Dengan pendekatan pemrograman standar, kami memberi tahu komputer apa yang harus dilakukan, memecah tugas-tugas besar menjadi banyak tugas kecil, dan secara tepat menentukan tugas yang akan dilakukan dengan mudah oleh komputer.  Dalam kasus Majelis Nasional, sebaliknya, kami tidak memberi tahu komputer bagaimana menyelesaikan masalah.  Dia sendiri belajar ini berdasarkan "pengamatan" data, "menciptakan" solusi sendiri untuk masalah tersebut. <br><br>  Pembelajaran berbasis data otomatis terdengar menjanjikan.  Namun, hingga 2006, kami tidak tahu bagaimana melatih Majelis Nasional sehingga mereka dapat melampaui pendekatan yang lebih tradisional, dengan pengecualian beberapa kasus khusus.  Pada tahun 2006, teknik pelatihan disebut  deep neural networks (GNS).  Sekarang teknik ini dikenal dengan deep learning (GO).  Mereka terus dikembangkan, dan hari ini GNS dan GO telah mencapai hasil luar biasa dalam banyak tugas penting yang terkait dengan visi komputer, pengenalan ucapan, dan pemrosesan bahasa alami.  Dalam skala besar, mereka dikerahkan oleh perusahaan seperti Google, Microsoft dan Facebook. <br><br>  Tujuan buku ini adalah untuk membantu Anda menguasai konsep-konsep kunci jaringan saraf, termasuk teknik GO modern.  Setelah bekerja dengan tutorial, Anda akan menulis kode yang menggunakan NS dan GO untuk memecahkan masalah pengenalan pola yang kompleks.  Anda akan memiliki dasar untuk menggunakan NS dan pertahanan sipil dalam pendekatan untuk menyelesaikan masalah Anda sendiri. <br><br><h3>  Pendekatan Berbasis Prinsip </h3><br>  Salah satu keyakinan yang mendasari buku ini adalah bahwa lebih baik memperoleh pemahaman yang kuat tentang prinsip-prinsip utama Majelis Nasional dan Masyarakat Sipil daripada mengambil pengetahuan dari daftar panjang berbagai ide.  Jika Anda memiliki pemahaman yang baik tentang ide-ide kunci, Anda akan dengan cepat memahami materi baru lainnya.  Dalam bahasa programmer, kita dapat mengatakan bahwa kita akan mempelajari sintaks dasar, pustaka, dan struktur data dari bahasa baru.  Anda mungkin mengenali hanya sebagian kecil dari keseluruhan bahasa - banyak bahasa memiliki pustaka standar yang sangat besar - namun, Anda dapat memahami pustaka dan struktur data baru dengan cepat dan mudah. <br><br>  Jadi, buku ini jelas bukan materi pendidikan tentang cara menggunakan perpustakaan tertentu untuk Majelis Nasional.  Jika Anda hanya ingin belajar cara bekerja dengan perpustakaan - jangan membaca buku!  Temukan perpustakaan yang Anda butuhkan dan kerjakan dengan materi pelatihan dan dokumentasi.  Namun perlu diingat: walaupun pendekatan ini memiliki keuntungan dalam memecahkan masalah secara instan, jika Anda ingin memahami apa yang sebenarnya terjadi di dalam Majelis Nasional, jika Anda ingin menguasai ide-ide yang relevan dalam beberapa tahun, maka tidak akan cukup bagi Anda untuk hanya mempelajari semacam perpustakaan mode.  Anda perlu memahami ide-ide jangka panjang yang andal dan mendasari pekerjaan Majelis Nasional.  Teknologi datang dan pergi, dan gagasan bertahan lama. <br><br><h3>  Pendekatan praktis </h3><br>  Kami akan mempelajari prinsip-prinsip dasar dengan contoh tugas tertentu: mengajar komputer untuk mengenali angka tulisan tangan.  Menggunakan pendekatan pemrograman tradisional, tugas ini sangat sulit untuk diselesaikan.  Namun, kita dapat menyelesaikannya dengan cukup baik dengan NS sederhana dan beberapa lusin baris kode, tanpa perpustakaan khusus.  Selain itu, kami secara bertahap akan meningkatkan program ini, secara konsisten termasuk di dalamnya semakin banyak gagasan utama tentang Majelis Nasional dan Pertahanan Sipil. <br><br>  Pendekatan praktis ini berarti bahwa Anda akan memerlukan beberapa pengalaman pemrograman.  Tetapi Anda tidak harus menjadi programmer profesional.  Saya menulis kode python (versi 2.7) yang harus jelas bahkan jika Anda belum menulis program python.  Dalam proses belajar, kami akan membuat perpustakaan kami sendiri untuk Majelis Nasional, yang dapat Anda gunakan untuk eksperimen dan pelatihan lebih lanjut.  Semua kode dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diunduh di sini</a> .  Setelah menyelesaikan buku, atau dalam proses membaca, Anda dapat memilih salah satu perpustakaan yang lebih lengkap untuk Majelis Nasional, disesuaikan untuk digunakan dalam proyek-proyek ini. <br><br>  Persyaratan matematika untuk memahami materi cukup rata-rata.  Sebagian besar bab memiliki bagian matematika, tetapi biasanya mereka adalah aljabar dasar dan grafik fungsi.  Kadang-kadang saya menggunakan matematika yang lebih maju, tetapi saya menyusun materi sehingga Anda dapat memahaminya, bahkan jika beberapa detail menghindari Anda.  Sebagian besar matematika digunakan dalam bab 2, yang memerlukan sedikit matanalisis dan aljabar linier.  Bagi mereka yang belum mereka kenal, saya memulai Bab 2 dengan pengantar matematika.  Jika Anda merasa kesulitan, lewati saja bab ini sampai pembekalan.  Bagaimanapun, jangan khawatir tentang ini. <br><br>  Buku jarang berorientasi pada pemahaman prinsip-prinsip dan pendekatan praktis.  Tetapi saya percaya bahwa lebih baik belajar berdasarkan ide-ide dasar Majelis Nasional.  Kami akan menulis kode kerja, dan tidak hanya mempelajari teori abstrak, dan Anda dapat menjelajahi dan memperluas kode ini.  Dengan cara ini, Anda akan memahami dasar-dasarnya, baik teori maupun praktik, dan akan dapat belajar lebih lanjut. <br><br><h3>  Latihan dan Tugas </h3><br>  Penulis buku teknis sering memperingatkan pembaca bahwa ia hanya perlu menyelesaikan semua latihan dan menyelesaikan semua masalah.  Ketika membaca peringatan seperti itu kepada saya, mereka selalu tampak sedikit aneh.  Akankah sesuatu yang buruk terjadi pada saya jika saya tidak melakukan latihan dan menyelesaikan masalah?  Tidak, tentu saja  Saya hanya akan menghemat waktu dengan pemahaman yang kurang mendalam.  Terkadang itu sepadan.  Terkadang tidak. <br><br>  Apa yang pantas dilakukan dengan buku ini?  Saya menyarankan Anda untuk mencoba menyelesaikan sebagian besar latihan, tetapi jangan mencoba untuk menyelesaikan sebagian besar tugas. <br><br>  Sebagian besar latihan perlu diselesaikan karena ini adalah pemeriksaan dasar untuk pemahaman materi yang tepat.  Jika Anda tidak dapat melakukan latihan dengan relatif mudah, Anda harus melewatkan sesuatu yang mendasar.  Tentu saja, jika Anda benar-benar terjebak dalam suatu jenis latihan - jatuhkan, mungkin ini adalah semacam kesalahpahaman kecil, atau mungkin saya memiliki sesuatu yang buruk dirumuskan.  Tetapi jika sebagian besar latihan menyebabkan Anda kesulitan, maka kemungkinan besar Anda perlu membaca ulang materi sebelumnya. <br><br>  Tugas adalah masalah lain.  Mereka lebih sulit daripada latihan, dan dengan beberapa Anda akan mengalami kesulitan.  Ini menjengkelkan, tetapi tentu saja kesabaran dalam menghadapi kekecewaan seperti itu adalah satu-satunya cara untuk benar-benar memahami dan menyerap subjek. <br><br>  Jadi saya tidak menyarankan menyelesaikan semua masalah.  Lebih baik lagi - ambil proyek Anda sendiri.  Anda mungkin ingin menggunakan NS untuk mengklasifikasikan koleksi musik Anda.  Atau untuk memprediksi nilai saham.  Atau yang lainnya.  Tetapi temukan proyek yang menarik untuk Anda.  Dan kemudian Anda dapat mengabaikan tugas-tugas dari buku, atau menggunakannya murni sebagai inspirasi untuk mengerjakan proyek Anda.  Masalah dengan proyek Anda sendiri akan mengajarkan Anda lebih dari bekerja dengan sejumlah tugas.  Keterlibatan emosional adalah faktor kunci dalam penguasaan prestasi. <br><br>  Tentu saja, sementara Anda mungkin tidak memiliki proyek seperti itu.  Ini normal.  Selesaikan tugas yang membuat Anda merasakan motivasi intrinsik.  Gunakan bahan dari buku untuk membantu Anda menemukan ide untuk proyek kreatif pribadi. <br><br><h2>  Bab 1 </h2><br>  Sistem visual manusia adalah salah satu keajaiban dunia.  Pertimbangkan urutan nomor tulisan tangan berikut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/839/d0b/543/839d0b54370af70f06b3f097897de457.png"><br><br>  Kebanyakan orang akan membacanya dengan mudah, seperti 504192. Tetapi kesederhanaan ini menipu.  Di setiap belahan otak, seseorang memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">korteks visual primer</a> , juga dikenal sebagai V1, yang berisi 140 juta neuron dan puluhan miliar koneksi di antara mereka.  Pada saat yang sama, tidak hanya V1 yang terlibat dalam penglihatan manusia, tetapi seluruh rangkaian wilayah otak - V2, V3, V4 dan V5 - yang terlibat dalam pemrosesan gambar yang semakin kompleks.  Kami membawa di kepala kami sebuah superkomputer yang ditala oleh evolusi selama ratusan juta tahun, dan diadaptasi dengan sempurna untuk memahami dunia yang terlihat.  Mengenali nomor tulisan tangan tidaklah mudah.  Hanya saja kita, orang-orang, luar biasa, sangat baik, mengenali apa yang mata kita tunjukkan kepada kita.  Tetapi hampir semua pekerjaan ini dilakukan secara tidak sadar.  Dan biasanya kami tidak menganggap penting tugas yang sulit diselesaikan oleh sistem visual kami. <br><br>  Kesulitan mengenali pola visual menjadi jelas ketika Anda mencoba menulis program komputer untuk mengenali angka-angka seperti yang di atas.  Apa yang tampaknya mudah dalam eksekusi kami tiba-tiba ternyata sangat kompleks.  Konsep sederhana tentang bagaimana kita mengenali bentuk - "kesembilan memiliki lingkaran di atas dan bar vertikal di kanan bawah" - sama sekali tidak begitu sederhana untuk ekspresi algoritmik.  Dengan mencoba mengartikulasikan aturan-aturan ini dengan jelas, Anda dengan cepat terjebak dalam rawa pengecualian, perangkap, dan acara-acara khusus.  Tugas itu tampaknya tidak ada harapan. <br><br>  Pendekatan NS untuk memecahkan masalah dengan cara yang berbeda.  Idenya adalah untuk mengambil banyak angka tulisan tangan yang dikenal sebagai contoh pengajaran, <br><br><img src="https://habrastorage.org/getpro/habr/post_images/a67/2ff/15c/a672ff15c58d9672b9f5d2b427a20eb6.png"><br><br>  dan kembangkan sistem yang dapat belajar dari contoh-contoh ini.  Dengan kata lain, Majelis Nasional menggunakan contoh untuk secara otomatis membuat aturan pengakuan angka tulisan tangan.  Selain itu, dengan menambah jumlah contoh pelatihan, jaringan dapat mempelajari lebih lanjut tentang angka tulisan tangan dan meningkatkan akurasinya.  Jadi, walaupun saya telah mengutip di atas hanya 100 studi kasus, mungkin kita dapat membuat sistem pengenalan tulisan tangan yang lebih baik menggunakan ribuan atau bahkan jutaan dan milyaran studi kasus. <br><br>  Dalam bab ini kita akan menulis sebuah program komputer yang mengimplementasikan pembelajaran NS untuk mengenali angka tulisan tangan.  Program ini akan hanya sepanjang 74 baris, dan tidak akan menggunakan perpustakaan khusus untuk Majelis Nasional.  Namun, program singkat ini akan dapat mengenali angka tulisan tangan dengan akurasi lebih dari 96%, tanpa memerlukan campur tangan manusia.  Selain itu, dalam bab-bab selanjutnya kami akan mengembangkan gagasan yang dapat meningkatkan akurasi hingga 99% atau lebih.  Bahkan, NS komersial terbaik melakukan pekerjaan dengan baik sehingga digunakan oleh bank untuk memproses cek, dan layanan pos untuk mengenali alamat. <br><br>  Kami berkonsentrasi pada pengenalan tulisan tangan, karena ini merupakan prototipe tugas untuk mempelajari NS.  Prototipe seperti itu sangat ideal bagi kami: ini adalah tugas yang sulit (mengenali nomor tulisan tangan bukanlah tugas yang mudah), tetapi tidak begitu rumit sehingga membutuhkan solusi yang sangat kompleks atau daya komputasi yang sangat besar.  Selain itu, ini adalah cara yang bagus untuk mengembangkan teknik yang lebih kompleks, seperti GO.  Karena itu, dalam buku ini kita akan terus kembali ke tugas pengenalan tulisan tangan.  Nanti kita akan membahas bagaimana ide-ide ini dapat diterapkan pada tugas-tugas lain dari visi komputer, pengenalan suara, pemrosesan bahasa alami dan bidang lainnya. <br><br>  Tentu saja, jika tujuan bab ini hanya untuk menulis program untuk mengenali angka tulisan tangan, maka bab itu akan jauh lebih pendek!  Namun, dalam prosesnya, kami akan mengembangkan banyak ide kunci yang terkait dengan NS, termasuk dua jenis neuron buatan ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">perceptron</a> dan sigmoid neuron), dan algoritma pembelajaran NS standar, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">keturunan gradien stokastik</a> .  Dalam teks, saya berkonsentrasi menjelaskan mengapa semuanya dilakukan dengan cara ini, dan pada pembentukan pemahaman Anda tentang Majelis Nasional.  Ini membutuhkan percakapan yang lebih lama daripada jika saya baru saja mempresentasikan mekanika dasar tentang apa yang terjadi, tetapi membutuhkan pemahaman yang lebih dalam yang akan Anda miliki.  Di antara kelebihan lainnya - di akhir bab ini Anda akan memahami apa pertahanan sipil dan mengapa pertahanan itu begitu penting. <br><br><h3>  Perceptrons </h3><br>  Apa itu jaringan saraf?  Untuk memulai, saya akan berbicara tentang satu jenis neuron buatan yang disebut perceptron.  Perceptrons diciptakan oleh ilmuwan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Frank Rosenblatt</a> pada 1950-an dan 60-an, terinspirasi oleh karya awal <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Warren McCallock</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Walter Pitts</a> .  Saat ini, model lain dari neuron buatan lebih sering digunakan - dalam buku ini, dan sebagian besar karya modern di NS terutama menggunakan model sigmoid dari neuron.  Kami akan segera bertemu dengannya.  Tetapi untuk memahami mengapa neuron sigmoid didefinisikan dengan cara ini, perlu menghabiskan waktu menganalisis perceptron. <br><br>  Jadi bagaimana cara kerja perceptrons?  Perceptron menerima beberapa angka biner x <sub>1</sub> , x <sub>2</sub> , ... dan memberikan satu angka biner: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/293/1f3/f5c/2931f3f5c6125d14262954583868f959.png"><br><br>  Dalam contoh ini, perceptron memiliki tiga angka input, x <sub>1</sub> , x <sub>2</sub> , x <sub>3</sub> .  Secara umum, mungkin ada lebih atau kurang dari mereka.  Rosenblatt mengusulkan aturan sederhana untuk menghitung hasilnya.  Dia memperkenalkan bobot, w <sub>1</sub> , w <sub>2</sub> , bilangan real, yang menyatakan pentingnya bilangan input yang sesuai untuk hasil.  Output dari neuron, 0 atau 1, ditentukan oleh apakah jumlah tertimbang kurang atau lebih dari ambang tertentu [ambang batas] <math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-1"><span class="MJXp-mtext" id="MJXp-Span-2">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-3"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-4"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u </font></font></span><span class="MJXp-msubsup" id="MJXp-Span-5"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-6" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m </font></font></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-7" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j </font></font></span></span><span class="MJXp-msubsup" id="MJXp-Span-8"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-9" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w </font></font></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-10" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j </font></font></span></span><span class="MJXp-msubsup" id="MJXp-Span-11"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-12" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x </font></font></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-13" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></span></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="10.764ex" height="2.057ex" viewBox="0 -520.7 4634.5 885.9" role="img" focusable="false" style="vertical-align: -0.848ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-73" x="250" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-75" x="719" y="0"></use><g transform="translate(1292,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-6A" x="1242" y="-213"></use></g><g transform="translate(2562,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-77" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-6A" x="1013" y="-213"></use></g><g transform="translate(3670,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-78" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-6A" x="809" y="-213"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-1"> \ sum_j w_jx_j </script>  .  Seperti bobot, ambang adalah bilangan real, parameter dari neuron.  Dalam istilah matematika: <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-14"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-15"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-16"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-17"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-18"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-19"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-20"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-21" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><font style="vertical-align: inherit;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23"><font style="vertical-align: inherit;">b </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-24"><font style="vertical-align: inherit;">e </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-25"><font style="vertical-align: inherit;">g </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-26"><font style="vertical-align: inherit;">saya </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-27"><font style="vertical-align: inherit;">n </font></span><span class="MJXp-mrow" id="MJXp-Span-28"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-29"><font style="vertical-align: inherit;">c </font></span></span><span class="MJXp-mrow" id="MJXp-Span-28"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-30"><font style="vertical-align: inherit;">a </font></span></span><span class="MJXp-mrow" id="MJXp-Span-28"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-31"><font style="vertical-align: inherit;">s </font></span></span><span class="MJXp-mrow" id="MJXp-Span-28"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-32"><font style="vertical-align: inherit;">e </font></span></span><span class="MJXp-mrow" id="MJXp-Span-28"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-33"><font style="vertical-align: inherit;">s</font></span></span><span class="MJXp-mn" id="MJXp-Span-34"><font style="vertical-align: inherit;"> 0 </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-36"><font style="vertical-align: inherit;">i </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-37"><font style="vertical-align: inherit;">f </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-40"><font style="vertical-align: inherit;">s </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-41"><font style="vertical-align: inherit;">u </font></span><span class="MJXp-msubsup" id="MJXp-Span-42"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-43" style="margin-right: 0.05em;"><font style="vertical-align: inherit;">m </font></span></span><span class="MJXp-msubsup" id="MJXp-Span-42"><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-44" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;">j </font></span></span><span class="MJXp-msubsup" id="MJXp-Span-45"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-46" style="margin-right: 0.05em;"><font style="vertical-align: inherit;">w </font></span></span><span class="MJXp-msubsup" id="MJXp-Span-45"><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-47" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;">j </font></span></span><span class="MJXp-msubsup" id="MJXp-Span-48"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-49" style="margin-right: 0.05em;"><font style="vertical-align: inherit;">x </font></span></span><span class="MJXp-msubsup" id="MJXp-Span-48"><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-50" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;">j</font></span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-52"><font style="vertical-align: inherit;"> l </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-53"><font style="vertical-align: inherit;">e </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-54"><font style="vertical-align: inherit;">q </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-55"><font style="vertical-align: inherit;">t </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-56"><font style="vertical-align: inherit;">h </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-57"><font style="vertical-align: inherit;">r </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-58"><font style="vertical-align: inherit;">e </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-59"><font style="vertical-align: inherit;">s </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-60"><font style="vertical-align: inherit;">h </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-61"><font style="vertical-align: inherit;">o </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-62"><font style="vertical-align: inherit;">l </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-63"><font style="vertical-align: inherit;">d</font></span></font><span class="MJXp-mtext" id="MJXp-Span-22">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-23"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-24"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-25"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-26"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-27"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mrow" id="MJXp-Span-28"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-29"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-30"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-31"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-32"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-33"><font style="vertical-align: inherit;"></font></span></span><span class="MJXp-mn" id="MJXp-Span-34"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mtext" id="MJXp-Span-35">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-36"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-37"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mtext" id="MJXp-Span-38">&nbsp;</span><span class="MJXp-mtext" id="MJXp-Span-39">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-40"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-41"><font style="vertical-align: inherit;"></font></span><span class="MJXp-msubsup" id="MJXp-Span-42"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-43" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-44" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"></font></span></span><span class="MJXp-msubsup" id="MJXp-Span-45"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-46" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-47" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"></font></span></span><span class="MJXp-msubsup" id="MJXp-Span-48"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-49" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-50" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"></font></span></span><span class="MJXp-mtext" id="MJXp-Span-51">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-52"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-53"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-54"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-55"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-56"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-57"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-58"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-59"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-60"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-61"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-62"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-63"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mspace" id="MJXp-Span-64" style="width: 0em; height: 0em;"></span><span class="MJXp-mn" id="MJXp-Span-65">1</span><span class="MJXp-mtext" id="MJXp-Span-66">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-67">j</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-68">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-69">k</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-70">a</span><span class="MJXp-mtext" id="MJXp-Span-71">&nbsp;</span><span class="MJXp-mtext" id="MJXp-Span-72">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-73">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-74">u</span><span class="MJXp-msubsup" id="MJXp-Span-75"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-76" style="margin-right: 0.05em;">m</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-77" style="vertical-align: -0.4em;">j</span></span><span class="MJXp-msubsup" id="MJXp-Span-78"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-79" style="margin-right: 0.05em;">w</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-80" style="vertical-align: -0.4em;">j</span></span><span class="MJXp-msubsup" id="MJXp-Span-81"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-82" style="margin-right: 0.05em;">x</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-83" style="vertical-align: -0.4em;">j</span></span><span class="MJXp-mo" id="MJXp-Span-84" style="margin-left: 0.333em; margin-right: 0.333em;">&gt;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-85">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-86">h</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-87">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-88">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-89">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-90">h</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-91">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-92">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-93">d</span><span class="MJXp-mtext" id="MJXp-Span-94">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-95">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-96">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-97">d</span><span class="MJXp-mrow" id="MJXp-Span-98"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-99">c</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-100">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-101">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-102">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-103">s</span></span><span class="MJXp-mtext" id="MJXp-Span-104">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-105">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-106">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-107">g</span><span class="MJXp-mrow" id="MJXp-Span-108"><span class="MJXp-mn" id="MJXp-Span-109">1</span></span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processed"><span class="MathJax_SVG" id="MathJax-Element-2-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="76.867ex" height="6.033ex" viewBox="0 -780.1 33095.6 2597.7" role="img" focusable="false" style="vertical-align: -4.222ex; max-width: 638px;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g transform="translate(5873,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-6F" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-75" x="485" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-74" x="1058" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-70" x="1419" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-75" x="1923" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-74" x="2495" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMAIN-3D" x="3134" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-62" x="4441" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-65" x="4870" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-67" x="5337" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-69" x="5817" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-6E" x="6163" y="0"></use><g transform="translate(6763,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-63" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-61" x="433" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-73" x="963" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-65" x="1432" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-73" x="1899" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMAIN-30" x="9132" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-69" x="9882" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-66" x="10228" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-73" x="11278" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-75" x="11748" y="0"></use><g transform="translate(12320,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-6A" x="1242" y="-213"></use></g><g transform="translate(13590,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-77" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-6A" x="1013" y="-213"></use></g><g transform="translate(14698,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-78" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-6A" x="809" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-6C" x="15913" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-65" x="16211" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-71" x="16678" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-74" x="17138" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-68" x="17500" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-72" x="18076" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-65" x="18528" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-73" x="18994" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-68" x="19464" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-6F" x="20040" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-6C" x="20526" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-64" x="20824" y="0"></use></g><g transform="translate(6888,-1422)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMAIN-31" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-6A" x="750" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-69" x="1163" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-6B" x="1508" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-61" x="2030" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-73" x="3059" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-75" x="3529" y="0"></use><g transform="translate(4101,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-6D" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-6A" x="1242" y="-213"></use></g><g transform="translate(5371,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-77" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-6A" x="1013" y="-213"></use></g><g transform="translate(6479,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-78" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-6A" x="809" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMAIN-3E" x="7721" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-74" x="8778" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-68" x="9139" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-72" x="9716" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-65" x="10167" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-73" x="10634" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-68" x="11103" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-6F" x="11680" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-6C" x="12165" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-64" x="12464" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-65" x="13237" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-6E" x="13704" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-64" x="14304" y="0"></use><g transform="translate(14828,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-63" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-61" x="433" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-73" x="963" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-65" x="1432" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-73" x="1899" y="0"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-74" x="17446" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-61" x="17808" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-67" x="18337" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMAIN-31" x="18818" y="0"></use></g></g></svg></span></div><script type="math/tex;mode=display" id="MathJax-Element-2"> output = \ begin {cases} 0 ~ if ~ \ sum_j w_jx_j \ leq threshold \\ 1 ~ jika ~ \ sum_j w_jx_j> threshold \ end {cases} \ tag {1} </script></p><br><br>  Itulah keseluruhan deskripsi perceptron! <br><br>  Ini adalah model matematika dasar.  Sebuah perceptron dapat dianggap sebagai pengambil keputusan dengan menimbang bukti.  Biarkan saya memberi Anda contoh yang tidak terlalu realistis, tetapi sederhana.  Katakanlah akhir pekan akan datang, dan Anda mendengar bahwa festival keju akan diadakan di kota Anda.  Anda suka keju, dan mencoba memutuskan apakah akan pergi ke festival atau tidak.  Anda dapat mengambil keputusan dengan menimbang tiga faktor: <br><br><ol><li>  Apakah cuacanya bagus? </li><li>  Apakah pasangan Anda ingin pergi dengan Anda? </li><li>  Apakah festival jauh dari transportasi umum?  (Anda tidak punya mobil). </li></ol><br>  Ketiga faktor ini dapat direpresentasikan sebagai variabel biner x <sub>1</sub> , x <sub>2</sub> , x <sub>3</sub> .  Misalnya, x <sub>1</sub> = 1 jika cuacanya bagus, dan 0 jika cuacanya buruk.  x <sub>2</sub> = 1 jika pasangan Anda ingin pergi, dan 0 jika tidak.  Sama untuk x <sub>3</sub> . <br><br>  Sekarang, katakanlah Anda penggemar berat keju sehingga Anda siap untuk pergi ke festival, bahkan jika pasangan Anda tidak tertarik padanya dan sulit untuk mendapatkannya.  Tapi mungkin Anda hanya membenci cuaca buruk, dan jika cuaca buruk, Anda tidak akan pergi ke festival.  Anda dapat menggunakan perceptrons untuk memodelkan proses pengambilan keputusan seperti itu.  Salah satu caranya adalah dengan memilih bobot w <sub>1</sub> = 6 untuk cuaca, dan w <sub>2</sub> = 2, w <sub>3</sub> = 2 untuk kondisi lainnya.  Nilai lebih besar dari w1 berarti bahwa cuaca lebih penting bagi Anda daripada apakah pasangan Anda akan bergabung dengan Anda atau kedekatan festival untuk berhenti.  Akhirnya, misalkan Anda memilih ambang batas 5 untuk perceptron. Dengan opsi ini, perceptron mengimplementasikan model keputusan yang diinginkan, memberikan 1 ketika cuaca bagus dan 0 saat buruk.  Keinginan pasangan dan kedekatan berhenti tidak mempengaruhi nilai output. <br><br>  Dengan mengubah bobot dan ambang, kita bisa mendapatkan model pengambilan keputusan yang berbeda.  Sebagai contoh, katakanlah kita mengambil ambang batas 3. Kemudian perceptron memutuskan bahwa Anda perlu pergi ke festival, baik ketika cuaca bagus, atau ketika festival berada di dekat halte bus dan pasangan Anda setuju untuk pergi bersama Anda.  Dengan kata lain, modelnya berbeda.  Menurunkan ambang berarti Anda ingin lebih ke festival. <br><br>  Jelas, perceptron bukanlah model pengambilan keputusan manusia yang lengkap!  Tetapi contoh ini menunjukkan bagaimana perceptron dapat menimbang berbagai jenis bukti untuk membuat keputusan.  Tampaknya mungkin bahwa jaringan perceptron yang kompleks dapat membuat keputusan yang sangat kompleks: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/5f1/853/0d8/5f18530d8e17d640b3146924f7666032.png"><br><br>  Dalam jaringan ini, kolom pertama dari perceptrons - yang kita sebut lapisan pertama perceptrons - membuat tiga keputusan yang sangat sederhana, menimbang bukti input.  Bagaimana dengan perceptrons dari lapisan kedua?  Masing-masing dari mereka membuat keputusan, menimbang hasil dari lapisan pengambilan keputusan pertama.  Dengan cara ini, perceptron dari lapisan kedua dapat membuat keputusan pada tingkat yang lebih kompleks dan abstrak dibandingkan dengan perceptron dari lapisan pertama.  Dan bahkan keputusan yang lebih kompleks dapat dibuat oleh perceptrons di lapisan ketiga.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan cara ini, jaringan perceptron yang lebih berlapis dapat menangani keputusan yang rumit. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Omong-omong, ketika saya menentukan perceptron, saya mengatakan bahwa ia hanya memiliki satu nilai output. Tetapi dalam jaringan di atas, perceptrons terlihat seperti mereka memiliki beberapa nilai output. Padahal, mereka hanya punya satu jalan keluar. Banyak panah keluaran hanya cara mudah untuk menunjukkan bahwa keluaran perceptron digunakan sebagai input dari beberapa perceptron lainnya. Ini kurang rumit daripada menggambar keluar bercabang tunggal. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mari sederhanakan deskripsi perceptrons. Ketentuan</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-110"><span class="MJXp-msubsup" id="MJXp-Span-111"><span class="MJXp-mo" id="MJXp-Span-112" style="margin-left: 0.111em; margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Σ </font></font></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-113" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j </font></font></span></span><span class="MJXp-msubsup" id="MJXp-Span-114"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-115" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dari w </font></font></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-116" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j </font></font></span></span><span class="MJXp-msubsup" id="MJXp-Span-117"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-118" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x </font></font></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-119" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></span></span><span class="MJXp-mo" id="MJXp-Span-120" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> &gt; </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-121"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-122"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-123"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-124"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-125"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">h </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-126"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-127"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-128"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> canggung, dan kita bisa menyepakati dua perubahan untuk rekaman kesederhanaannya. </font><font style="vertical-align: inherit;">Yang pertama adalah merekam</font></font><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-3-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="20.1ex" height="3.142ex" viewBox="0 -832 8654.3 1352.7" role="img" focusable="false" style="vertical-align: -1.209ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJSZ1-2211" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-6A" x="1494" y="-405"></use><g transform="translate(1614,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-77" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-6A" x="1013" y="-213"></use></g><g transform="translate(2723,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-78" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-6A" x="809" y="-213"></use></g><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMAIN-3E" x="3964" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-74" x="5021" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-72" x="5382" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-65" x="5834" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-73" x="6300" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-68" x="6770" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-6F" x="7346" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-6C" x="7832" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-64" x="8130" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-3">\sum_j w_jx_j > treshold</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-129"><span class="MJXp-msubsup" id="MJXp-Span-130"><span class="MJXp-mo" id="MJXp-Span-131" style="margin-left: 0.111em; margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">∑ </font></font></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-132" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j </font></font></span></span><span class="MJXp-msubsup" id="MJXp-Span-133"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-134" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w </font></font></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-135" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j </font></font></span></span><span class="MJXp-msubsup" id="MJXp-Span-136"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-137" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x </font></font></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-138" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></span></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sebagai produk skalar,</font></font><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-4-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="8.564ex" height="3.142ex" viewBox="0 -832 3687.2 1352.7" role="img" focusable="false" style="vertical-align: -1.209ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJSZ1-2211" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-6A" x="1494" y="-405"></use><g transform="translate(1614,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-77" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-6A" x="1013" y="-213"></use></g><g transform="translate(2723,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-78" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-6A" x="809" y="-213"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-4">\sum_j w_jx_j</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-139"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-140"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w </font></font></span><span class="MJXp-mo" id="MJXp-Span-141" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">⋅ </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-142"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x </font></font></span><span class="MJXp-mo" id="MJXp-Span-143" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-msubsup" id="MJXp-Span-144"><span class="MJXp-mo" id="MJXp-Span-145" style="margin-left: 0.111em; margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">∑ </font></font></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-146" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j </font></font></span></span><span class="MJXp-msubsup" id="MJXp-Span-147"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-148" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">w </font></font></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-149" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j </font></font></span></span><span class="MJXp-msubsup" id="MJXp-Span-150"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-151" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x </font></font></span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-152" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></span></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , di mana w dan x adalah vektor yang komponennya masing-masing adalah bobot dan data input. </font><font style="vertical-align: inherit;">Yang kedua adalah untuk mentransfer ambang batas ke bagian lain dari ketidaksetaraan, dan menggantinya dengan nilai yang dikenal sebagai perceptron displacement [bias],</font></font><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-5-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="16.335ex" height="3.142ex" viewBox="0 -832 7033.2 1352.7" role="img" focusable="false" style="vertical-align: -1.209ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-77" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMAIN-22C5" x="938" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-78" x="1439" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMAIN-3D" x="2289" y="0"></use><g transform="translate(3346,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJSZ1-2211" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-6A" x="1494" y="-405"></use></g><g transform="translate(4960,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-77" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-6A" x="1013" y="-213"></use></g><g transform="translate(6069,0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-78" x="0" y="0"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-6A" x="809" y="-213"></use></g></g></svg></span><script type="math/tex" id="MathJax-Element-5">w \cdot x = \sum_j w_jx_j</script><font style="vertical-align: inherit;"></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-153"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-154"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">b </font></font></span><span class="MJXp-mo" id="MJXp-Span-155" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">≡ </font></font></span><span class="MJXp-mo" id="MJXp-Span-156" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">- </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-157"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-158"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">h </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-159"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-160"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">e </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-161"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-162"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">h </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-163"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-164"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-165"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">d</font></font></span></span></span><span class="MathJax_SVG MathJax_SVG_Processed" id="MathJax-Element-6-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="15.681ex" height="2.178ex" viewBox="0 -780.1 6751.6 937.7" role="img" focusable="false" style="vertical-align: -0.366ex;"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-62" x="0" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMAIN-2261" x="707" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMAIN-2212" x="1763" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-74" x="2542" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-68" x="2903" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-72" x="3480" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-65" x="3931" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-73" x="4398" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-68" x="4867" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-6F" x="5444" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-6C" x="5929" y="0"></use><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/post/456738/&amp;usg=ALkJrhjHvWVAD1y1iYJV0Uqx6jlb-C9OuQ#MJMATHI-64" x="6228" y="0"></use></g></svg></span><script type="math/tex" id="MathJax-Element-6">b \equiv −threshold</script>  .<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Menggunakan perpindahan alih-alih ambang batas, kita dapat menulis ulang aturan perceptron: </font></font><br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-166"><span class="MJXp-mtable" id="MJXp-Span-167"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-168" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-169" style="text-align: center;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-170"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">o </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-171"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-172"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-173"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-174"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-175"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mo" id="MJXp-Span-176" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">= </font></font></span><span class="MJXp-mrow" id="MJXp-Span-177"><span class="MJXp-mo" id="MJXp-Span-178" style="margin-left: 0em; margin-right: 0em; vertical-align: -0.472em;"><span class="MJXp-right MJXp-scale5" style="font-size: 2.889em; margin-left: -0.22em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">{ </font></font></span></span><span class="MJXp-mtable" id="MJXp-Span-179"><span><span class="MJXp-mtr" id="MJXp-Span-180" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-181" style="text-align: left;"><span class="MJXp-mn" id="MJXp-Span-182"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">0 </font></font></span><font style="vertical-align: inherit;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-184"><font style="vertical-align: inherit;">i </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-185"><font style="vertical-align: inherit;">f </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-187"><font style="vertical-align: inherit;">w </font></span><span class="MJXp-mo" id="MJXp-Span-188" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;">⋅ </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-189"><font style="vertical-align: inherit;">x </font></span><span class="MJXp-mo" id="MJXp-Span-190" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;">+ </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-191"><font style="vertical-align: inherit;">b </font></span><span class="MJXp-mo" id="MJXp-Span-192" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;">≤ </font></span><span class="MJXp-mn" id="MJXp-Span-193"><font style="vertical-align: inherit;">0 </font></span></font><span class="MJXp-mtext" id="MJXp-Span-183">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-184"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-185"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mtext" id="MJXp-Span-186">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-187"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mo" id="MJXp-Span-188" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-189"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mo" id="MJXp-Span-190" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-191"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mo" id="MJXp-Span-192" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mn" id="MJXp-Span-193"><font style="vertical-align: inherit;"></font></span></span></span><span class="MJXp-mtr" id="MJXp-Span-194" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-195" style="padding-top: 0.2em; text-align: left;"><span class="MJXp-mn" id="MJXp-Span-196"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1 </font></font></span><font style="vertical-align: inherit;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-198"><font style="vertical-align: inherit;">i </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-199"><font style="vertical-align: inherit;">f </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-201"><font style="vertical-align: inherit;">w </font></span><span class="MJXp-mo" id="MJXp-Span-202" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;">⋅ </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-203"><font style="vertical-align: inherit;">x </font></span><span class="MJXp-mo" id="MJXp-Span-204" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;">+ </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-205"><font style="vertical-align: inherit;">b </font></span><span class="MJXp-mo" id="MJXp-Span-206" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;">&gt; </font></span><span class="MJXp-mn" id="MJXp-Span-207"><font style="vertical-align: inherit;">0</font></span></font><span class="MJXp-mtext" id="MJXp-Span-197">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-198"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-199"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mtext" id="MJXp-Span-200">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-201"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mo" id="MJXp-Span-202" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-203"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mo" id="MJXp-Span-204" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-205"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mo" id="MJXp-Span-206" style="margin-left: 0.333em; margin-right: 0.333em;"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mn" id="MJXp-Span-207"><font style="vertical-align: inherit;"></font></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-208" style="margin-left: 0em; margin-right: 0em;"></span></span></span></span></span></span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-7-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-7"> output = \begin{cases} 0 ~ if ~ w \cdot x + b \leq 0 \\ 1 ~ if ~ w \cdot x + b > 0 \end{cases} \tag{2} </script></p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Offset dapat direpresentasikan sebagai ukuran betapa mudahnya untuk mendapatkan nilai 1 pada output dari perceptron. Atau, dalam istilah biologis, perpindahan adalah ukuran seberapa mudahnya untuk mengaktifkan perceptron. Sebuah perceptron dengan bias yang sangat besar sangat mudah untuk diberikan 1. Tetapi dengan bias negatif yang sangat besar, ini sulit dilakukan. Jelas, pengenalan bias adalah perubahan kecil dalam deskripsi perceptrons, tetapi kemudian kita akan melihat bahwa itu mengarah pada penyederhanaan lebih lanjut dari rekaman. Oleh karena itu, lebih lanjut kami tidak akan menggunakan ambang, tetapi akan selalu menggunakan offset.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya menggambarkan perceptrons dalam hal metode menimbang bukti untuk pengambilan keputusan. Metode lain penggunaannya adalah perhitungan fungsi logis elementer, yang biasanya kita anggap sebagai perhitungan utama, seperti AND, OR dan NAND. Misalkan, misalnya, kita memiliki perceptron dengan dua input, bobot masing-masing adalah -2, dan offsetnya adalah 3. Ini dia: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/530/d45/9a9/530d459a9262c475caf057106a500ddc.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Input 00 memberikan output 1, karena (−2) ∗ 0 + (- 2 ) ∗ 0 + 3 = 3 lebih besar dari nol. Perhitungan yang sama mengatakan bahwa input 01 dan 10 memberikan 1. Tetapi 11 pada input memberikan 0 pada output, karena (−2) ∗ 1 + (- 2) ∗ 1 + 3 = −1, kurang dari nol. Karena itu, perceptron kami mengimplementasikan fungsi NAND!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh ini menunjukkan bahwa perceptrons dapat digunakan untuk menghitung fungsi logika dasar. Bahkan, kita dapat menggunakan jaringan perceptron untuk menghitung fungsi logis apa saja secara umum. Faktanya adalah bahwa </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">gerbang logika</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> NAND </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">bersifat</font></a><font style="vertical-align: inherit;"> universal untuk perhitungan - dimungkinkan untuk membangun perhitungan apa pun pada dasarnya. Misalnya, Anda dapat menggunakan gerbang NAND untuk membuat sirkuit yang menambahkan dua bit, x </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan x </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Untuk melakukan ini, hitung jumlah bitwise</font></font><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math" id="MJXp-Span-209"><span class="MJXp-msubsup" id="MJXp-Span-210"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-211" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x </font></font></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-212" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></span></span><span class="MJXp-mo" id="MJXp-Span-213" style="margin-left: 0.267em; margin-right: 0.267em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ⊕ </font></font></span><span class="MJXp-msubsup" id="MJXp-Span-214"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-215" style="margin-right: 0.05em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">x </font></font></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-216" style="vertical-align: -0.4em;"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></span></span></span></span><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , serta</font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">flag carry</font></a><font style="vertical-align: inherit;">, yaitu 1 ketika x</font><sub><font style="vertical-align: inherit;">1</font></sub><font style="vertical-align: inherit;">dan x</font><sub><font style="vertical-align: inherit;">2</font></sub><font style="vertical-align: inherit;">adalah 1 - yaitu, flag carry hanyalah hasil penggandaan bitwise x</font><sub><font style="vertical-align: inherit;">1</font></sub><font style="vertical-align: inherit;">x</font><sub><font style="vertical-align: inherit;">2</font></sub><font style="vertical-align: inherit;">:</font><font style="vertical-align: inherit;">Untuk mendapatkan jaringan yang setara dari perceptrons, kami mengganti semua Gerbang NAND adalah perceptrons dengan dua input, berat masing-masing adalah -2, dan dengan offset 3. Berikut ini adalah jaringan yang dihasilkan. Perhatikan bahwa saya memindahkan perceptron yang sesuai dengan katup kanan bawah, hanya untuk membuatnya lebih mudah untuk menggambar panah:</font></font><span class="MathJax_SVG MathJax_SVG_Processing" id="MathJax-Element-8-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span><script type="math/tex" id="MathJax-Element-8"> x_1 \oplus x_2 </script><font style="vertical-align: inherit;"></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"></font></a><font style="vertical-align: inherit;"></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"></font><sub><font style="vertical-align: inherit;"></font></sub><font style="vertical-align: inherit;"></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d25/af6/afe/d25af6afec499649a0b338f2ccc67f63.png"><br><br><font style="vertical-align: inherit;"></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/222/5b4/71b/2225b471b11b7357777ebc024bd287c2.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Satu aspek penting dari jaringan perceptron ini adalah bahwa output dari jaringan yang paling kiri digunakan dua kali sebagai input ke bagian bawah. Mendefinisikan model perceptron, saya tidak menyebutkan diterimanya skema keluar ganda di tempat yang sama. Padahal, itu tidak terlalu penting. Jika kita tidak ingin mengizinkan ini, kita cukup menggabungkan dua garis dengan bobot -2 menjadi satu dengan bobot -4. (Jika ini tidak terlihat jelas bagi Anda, berhentilah dan buktikan sendiri). Setelah perubahan ini, jaringan terlihat sebagai berikut, dengan semua bobot yang tidak terisi sama dengan -2, semua offset sama dengan 3, dan satu bobot -4 ditandai: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/151/d84/dbd/151d84dbdf944cc9016ed656ba70e424.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Catatan perceptron yang memiliki output tetapi tidak ada input:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/41c/8e3/e46/41c8e3e46587bf536bab96b8427e9bcd.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hanyalah sebuah singkatan. Ini tidak berarti bahwa dia tidak memiliki input. Untuk memahami ini, anggaplah kita memiliki perceptron tanpa input. Kemudian tertimbang jumlah Σ </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> x </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> akan selalu menjadi nol, sehingga Perceptron akan menghasilkan 1 untuk b&gt; 0 dan 0 untuk b ≤ 0. Artinya, Perceptron hanya akan memberi nilai tetap, tetapi tidak perlu bagi kita (x </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Contoh di atas). Lebih baik untuk mempertimbangkan input perceptrons bukan sebagai perceptrons, tetapi sebagai unit khusus yang hanya didefinisikan sehingga menghasilkan nilai yang diinginkan x </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , x </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ...</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Contoh penambah menunjukkan bagaimana jaringan perceptron dapat digunakan untuk mensimulasikan rangkaian yang berisi banyak gerbang NAND. Dan karena gerbang ini bersifat universal untuk perhitungan, maka perceptron bersifat universal untuk perhitungan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fleksibilitas komputasi dari perceptrons cukup menggembirakan dan mengecewakan. Ini menggembirakan, memastikan bahwa jaringan perceptron dapat sekuat perangkat komputasi lainnya. Mengecewakan, memberi kesan bahwa perceptrons hanyalah tipe baru dari gerbang logika NAND. Penemuan begitu-begitu!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, situasinya sebenarnya lebih baik. </font><font style="vertical-align: inherit;">Ternyata kita dapat mengembangkan algoritma pelatihan yang dapat secara otomatis menyesuaikan bobot dan perpindahan jaringan dari neuron buatan. </font><font style="vertical-align: inherit;">Penyesuaian ini terjadi sebagai respons terhadap rangsangan eksternal, tanpa intervensi langsung dari seorang programmer. </font><font style="vertical-align: inherit;">Algoritma pembelajaran ini memungkinkan kita untuk menggunakan neuron buatan dengan cara yang sangat berbeda dari gerbang logika biasa. </font><font style="vertical-align: inherit;">Alih-alih secara eksplisit mendaftarkan sirkuit dari gerbang NAND dan lainnya, jaringan saraf kita dapat dengan mudah belajar bagaimana menyelesaikan masalah, kadang-kadang yang sangat sulit untuk secara langsung merancang sirkuit reguler.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Neuron Sigmoid </font></font></h3><br>  Algoritma pembelajaran sangat bagus.  Namun, bagaimana cara mengembangkan algoritma seperti itu untuk jaringan saraf?  Misalkan kita memiliki jaringan perceptron yang ingin kita gunakan untuk melatih kita dalam memecahkan suatu masalah.  Misalkan input ke jaringan mungkin piksel dari gambar yang dipindai dari digit tulisan tangan.  Dan kami ingin jaringan mengetahui bobot dan offset yang dibutuhkan untuk mengklasifikasikan angka-angka dengan benar.  Untuk memahami bagaimana pelatihan semacam itu dapat bekerja, mari kita bayangkan bahwa kita sedikit mengubah bobot (atau bias) tertentu dalam jaringan.  Kami ingin perubahan kecil ini mengarah ke perubahan kecil dalam output jaringan.  Seperti yang akan segera kita lihat, properti ini memungkinkan pembelajaran.  Secara skematis, kami ingin yang berikut ini (jelas, jaringan seperti itu terlalu sederhana untuk mengenali tulisan tangan!): <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2cf/d97/76f/2cfd9776fdb27a7106bdf2a94d76eb46.png"><br><br>  Jika perubahan kecil dalam berat (atau bias) akan menyebabkan perubahan kecil dalam hasil output, kita bisa mengubah bobot dan bias sehingga jaringan kita berperilaku sedikit lebih dekat dengan apa yang kita inginkan.  Misalnya, katakanlah jaringan secara tidak benar menetapkan gambar ke "8", meskipun seharusnya "9".  Kita bisa mencari cara bagaimana membuat perubahan kecil dalam berat dan perpindahan sehingga jaringan menjadi sedikit lebih dekat dengan mengklasifikasikan gambar sebagai "9".  Dan kemudian kita akan mengulangi ini, mengubah bobot dan bergeser lagi dan lagi untuk mendapatkan hasil terbaik dan terbaik.  Jaringan akan belajar. <br><br>  Masalahnya adalah bahwa jika ada perceptrons di jaringan, ini tidak terjadi.  Perubahan kecil dalam bobot atau perpindahan perceptron apa pun kadang-kadang dapat menyebabkan perubahan dalam outputnya menjadi sebaliknya, katakanlah, dari 0 menjadi 1. Balik seperti itu dapat mengubah perilaku sisa jaringan dengan cara yang sangat rumit.  Dan bahkan jika sekarang "9" kita dikenali dengan benar, perilaku jaringan dengan semua gambar lain mungkin telah sepenuhnya berubah dengan cara yang sulit dikendalikan.  Karena itu, sulit untuk membayangkan bagaimana kita dapat secara bertahap menyesuaikan bobot dan offset sehingga jaringan secara bertahap mendekati perilaku yang diinginkan.  Mungkin ada beberapa cara pintar untuk mengatasi masalah ini.  Tetapi tidak ada solusi sederhana untuk masalah mempelajari jaringan perceptrons. <br><br>  Masalah ini dapat diatasi dengan memperkenalkan jenis baru neuron buatan yang disebut neuron sigmoid.  Mereka mirip dengan perceptrons, tetapi dimodifikasi sehingga perubahan kecil dalam bobot dan offset hanya menghasilkan perubahan kecil pada output.  Ini adalah fakta dasar yang akan memungkinkan jaringan neuron sigmoid untuk belajar. <br><br>  Biarkan saya menggambarkan neuron sigmoid.  Kami akan menggambar mereka dengan cara yang sama seperti perceptrons: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/2cd/0b3/ccf/2cd0b3ccf36d0dabf96fd15649c29f90.png"><br><br>  Ini memiliki input yang sama x <sub>1</sub> , x <sub>2</sub> , ... Tetapi alih-alih sama dengan 0 atau 1, input ini dapat memiliki nilai apa pun dalam kisaran dari 0 hingga 1. Misalnya, nilai 0,638 akan menjadi input yang valid untuk neuron sigmoid (CH).  Sama seperti perceptron, SN memiliki bobot untuk setiap input, w <sub>1</sub> , w <sub>2</sub> , ... dan total bias b.  Tetapi nilai outputnya tidak akan 0 atau 1. Ini akan menjadi σ (w⋅x + b), di mana σ adalah sigmoid. <br><br>  By the way, σ kadang-kadang disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">fungsi logistik</a> , dan kelas neuron ini disebut neuron logistik.  Sangat berguna untuk mengingat terminologi ini, karena istilah ini digunakan oleh banyak orang yang bekerja dengan jaringan saraf.  Namun, kami akan mematuhi terminologi sigmoid. <br><br>  Fungsi didefinisikan sebagai berikut: <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-217"><span class="MJXp-mtext" id="MJXp-Span-218">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-219">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-220">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-221">g</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-222">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-223">a</span><span class="MJXp-mo" id="MJXp-Span-224" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-225">z</span><span class="MJXp-mo" id="MJXp-Span-226" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mtext" id="MJXp-Span-227">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-228">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-229">q</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-230">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-231">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-232">v</span><span class="MJXp-mtext" id="MJXp-Span-233">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-234">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-235">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-236">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-237">c</span><span class="MJXp-mrow" id="MJXp-Span-238"><span class="MJXp-mn" id="MJXp-Span-239">1</span></span><span class="MJXp-mrow" id="MJXp-Span-240"><span class="MJXp-mn" id="MJXp-Span-241">1</span><span class="MJXp-mo" id="MJXp-Span-242" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-msubsup" id="MJXp-Span-243"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-244" style="margin-right: 0.05em;">e</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-245" style="vertical-align: 0.5em;"><span class="MJXp-mo" id="MJXp-Span-246">−</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-247">z</span></span></span></span><span class="MJXp-mtext" id="MJXp-Span-248">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-249">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-250">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-251">g</span><span class="MJXp-mrow" id="MJXp-Span-252"><span class="MJXp-mn" id="MJXp-Span-253">3</span></span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-9-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-9"> \ sigma (z) \ equiv \ frac {1} {1 + e ^ {- z}} \ tag {3} </script></p><br><br>  Dalam kasus kami, nilai output dari neuron sigmoid dengan data input x <sub>1</sub> , x <sub>2</sub> , ... dengan bobot w <sub>1</sub> , w <sub>2</sub> , ... dan offset b akan dianggap sebagai: <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-254"><span class="MJXp-mtext" id="MJXp-Span-255">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-256">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-257">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-258">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-259">c</span><span class="MJXp-mrow" id="MJXp-Span-260"><span class="MJXp-mn" id="MJXp-Span-261">1</span></span><span class="MJXp-mrow" id="MJXp-Span-262"><span class="MJXp-mn" id="MJXp-Span-263">1</span><span class="MJXp-mo" id="MJXp-Span-264" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-265">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-266">x</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-267">p</span><span class="MJXp-mo" id="MJXp-Span-268" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mo" id="MJXp-Span-269" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mtext" id="MJXp-Span-270">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-271">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-272">u</span><span class="MJXp-msubsup" id="MJXp-Span-273"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-274" style="margin-right: 0.05em;">m</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-275" style="vertical-align: -0.4em;">j</span></span><span class="MJXp-msubsup" id="MJXp-Span-276"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-277" style="margin-right: 0.05em;">w</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-278" style="vertical-align: -0.4em;">j</span></span><span class="MJXp-msubsup" id="MJXp-Span-279"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-280" style="margin-right: 0.05em;">x</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-281" style="vertical-align: -0.4em;">j</span></span><span class="MJXp-mo" id="MJXp-Span-282" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-283">b</span><span class="MJXp-mo" id="MJXp-Span-284" style="margin-left: 0em; margin-right: 0em;">)</span></span><span class="MJXp-mtext" id="MJXp-Span-285">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-286">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-287">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-288">g</span><span class="MJXp-mrow" id="MJXp-Span-289"><span class="MJXp-mn" id="MJXp-Span-290">4</span></span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-10-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-10"> \ frac {1} {1 + exp (- \ sum_j w_jx_j - b)} \ tag {4} </script></p><br><br>  Pada pandangan pertama, CH tampak sama sekali tidak seperti neuron.  Tampilan aljabar dari sigmoid mungkin tampak membingungkan dan tidak jelas jika Anda tidak terbiasa dengannya.  Sebenarnya, ada banyak kesamaan antara perceptrons dan SN, dan bentuk aljabar dari sigmoid ternyata lebih merupakan detail teknis daripada hambatan serius untuk memahami. <br><br>  Untuk memahami kesamaan dengan model perceptron, anggaplah bahwa z ≡ w ⋅ x + b adalah angka positif yang besar.  Maka e - z ≈ 0, oleh karena itu, σ (z) ≈ 1. Dengan kata lain, ketika z = w ⋅ x + b adalah besar dan positif, hasil SN adalah sekitar 1, seperti dalam perceptron.  Misalkan z = w ⋅ x + b besar dengan tanda minus.  Kemudian e - z → ∞, dan σ (z) ≈ 0. Jadi untuk z besar dengan tanda minus, perilaku SN juga mendekati perceptron.  Dan hanya ketika w ⋅ x + b memiliki ukuran rata-rata, penyimpangan serius dari model perceptron diamati. <br><br>  Bagaimana dengan bentuk aljabar σ?  Bagaimana kita memahaminya?  Sebenarnya, bentuk persis σ tidak begitu penting - bentuk fungsi pada grafik itu penting.  Ini dia: <br><br><img src="https://habrastorage.org/webt/sm/u4/jv/smu4jvbwuriryrfojrpt-ukdr6w.png"><br><br>  Ini adalah versi lancar dari fungsi langkah: <br><br><img src="https://habrastorage.org/webt/2i/p0/a-/2ip0a-3cmpstyiwrglx_michl3m.png"><br><br>  Jika σ adalah stepwise, maka SN akan menjadi perceptron, karena itu akan memiliki 0 atau 1 output tergantung pada tanda w ⋅ x + b (well, pada kenyataannya, pada z = 0, perceptron memberikan 0, dan fungsi langkah - 1 , jadi pada titik itu, fungsinya harus diubah). <br><br>  Menggunakan fungsi nyata σ, kita mendapatkan perceptron yang dihaluskan.  Dan hal utama di sini adalah kelancaran fungsi, bukan bentuk pastinya.  Kelancaran berarti bahwa perubahan kecil dengan bobot dan offset willb akan memberikan perubahan kecil put keluaran output.  Aljabar memberi tahu kita bahwa putoutput diperkirakan dengan baik sebagai berikut: <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-291"><span class="MJXp-mtext" id="MJXp-Span-292">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-293">D</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-294">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-295">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-296">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-297">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-298">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-299">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-300">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-301">p</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-302">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-303">t</span><span class="MJXp-mtext" id="MJXp-Span-304">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-305">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-306">p</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-307">p</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-308">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-309">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-310">x</span><span class="MJXp-mtext" id="MJXp-Span-311">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-312">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-313">u</span><span class="MJXp-msubsup" id="MJXp-Span-314"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-315" style="margin-right: 0.05em;">m</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-316" style="vertical-align: -0.4em;">j</span></span><span class="MJXp-mtext" id="MJXp-Span-317">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-318">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-319">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-320">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-321">c</span><span class="MJXp-mrow" id="MJXp-Span-322"><span class="MJXp-mtext" id="MJXp-Span-323">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-324">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-325">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-326">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-327">p</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-328">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-329">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-330">p</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-331">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-332">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-333">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-334">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-335">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-336">l</span></span><span class="MJXp-mrow" id="MJXp-Span-337"><span class="MJXp-mtext" id="MJXp-Span-338">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-339">p</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-340">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-341">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-342">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-343">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-344">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-345">l</span><span class="MJXp-msubsup" id="MJXp-Span-346"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-347" style="margin-right: 0.05em;">w</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-348" style="vertical-align: -0.4em;">j</span></span></span><span class="MJXp-mtext" id="MJXp-Span-349">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-350">D</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-351">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-352">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-353">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-354">a</span><span class="MJXp-msubsup" id="MJXp-Span-355"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-356" style="margin-right: 0.05em;">w</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-357" style="vertical-align: -0.4em;">j</span></span><span class="MJXp-mo" id="MJXp-Span-358" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mtext" id="MJXp-Span-359">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-360">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-361">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-362">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-363">c</span><span class="MJXp-mrow" id="MJXp-Span-364"><span class="MJXp-mtext" id="MJXp-Span-365">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-366">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-367">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-368"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-369"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-370"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">u </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-371"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">t </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-372"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">p </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-373"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-374"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">r </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-375"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">s </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-376"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">i </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-377"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">a </font></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-378"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l </font></font></span></span><font style="vertical-align: inherit;"><span class="MJXp-mrow" id="MJXp-Span-379"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-381"><font style="vertical-align: inherit;">p </font></span></span><span class="MJXp-mrow" id="MJXp-Span-379"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-382"><font style="vertical-align: inherit;">a </font></span></span><span class="MJXp-mrow" id="MJXp-Span-379"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-383"><font style="vertical-align: inherit;">r </font></span></span><span class="MJXp-mrow" id="MJXp-Span-379"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-384"><font style="vertical-align: inherit;">t </font></span></span><span class="MJXp-mrow" id="MJXp-Span-379"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-385"><font style="vertical-align: inherit;">i </font></span></span><span class="MJXp-mrow" id="MJXp-Span-379"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-386"><font style="vertical-align: inherit;">a </font></span></span><span class="MJXp-mrow" id="MJXp-Span-379"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-387"><font style="vertical-align: inherit;">l </font></span></span><span class="MJXp-mrow" id="MJXp-Span-379"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-388"><font style="vertical-align: inherit;">b</font></span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-390"><font style="vertical-align: inherit;"> D </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-391"><font style="vertical-align: inherit;">e </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-392"><font style="vertical-align: inherit;">l </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-393"><font style="vertical-align: inherit;">t </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-394"><font style="vertical-align: inherit;">a </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-395"><font style="vertical-align: inherit;">b </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-397"><font style="vertical-align: inherit;">t </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-398"><font style="vertical-align: inherit;">a </font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-399"><font style="vertical-align: inherit;">g </font></span><span class="MJXp-mrow" id="MJXp-Span-400"><span class="MJXp-mn" id="MJXp-Span-401"><font style="vertical-align: inherit;">5</font></span></span></font><span class="MJXp-mrow" id="MJXp-Span-379"><span class="MJXp-mtext" id="MJXp-Span-380">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-381"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-382"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-383"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-384"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-385"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-386"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-387"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-388"><font style="vertical-align: inherit;"></font></span></span><span class="MJXp-mtext" id="MJXp-Span-389">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-390"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-391"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-392"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-393"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-394"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-395"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mtext" id="MJXp-Span-396">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-397"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-398"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-399"><font style="vertical-align: inherit;"></font></span><span class="MJXp-mrow" id="MJXp-Span-400"><span class="MJXp-mn" id="MJXp-Span-401"><font style="vertical-align: inherit;"></font></span></span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-11-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-11"> \ Delta output \ approx \ sum_j \ frac {\ output parsial} {\ partial w_j} \ Delta w_j + \ frac {\ output parsial} {\ partial b} \ Delta b \ tag {5} </script></p><br><br>  Jika penjumlahannya melebihi semua bobot <sub>wj</sub> , dan ∂output / ∂w <sub>j</sub> dan ∂output / ∂b masing-masing menunjukkan turunan parsial dari output sehubungan dengan <sub>j</sub> dan b, masing-masing.  Jangan panik jika Anda merasa tidak aman di perusahaan turunan pribadi!  Meskipun rumusnya terlihat rumit, dengan semua turunan parsial ini, ia sebenarnya mengatakan sesuatu yang sangat sederhana (dan bermanfaat): putoutput adalah fungsi linier tergantung pada bobot dan bias Δw <sub>j</sub> dan Δb.  Lineritasnya membuatnya mudah untuk memilih perubahan kecil dalam bobot dan offset untuk mencapai bias output kecil yang diinginkan.  Jadi, meskipun SN mirip dengan persepsi dalam perilaku kualitatif, mereka membuatnya lebih mudah untuk memahami bagaimana output dapat diubah dengan mengubah bobot dan perpindahan. <br><br>  Jika bentuk umum σ penting bagi kita, dan bukan bentuk tepatnya, lalu mengapa kita menggunakan rumus seperti itu (3)?  Bahkan, nanti kita kadang-kadang akan mempertimbangkan neuron yang outputnya adalah f (w ⋅ x + b), di mana f () adalah beberapa fungsi aktivasi lainnya.  Hal utama yang berubah ketika fungsi berubah adalah nilai turunan parsial dalam persamaan (5).  Ternyata ketika kita menghitung turunan parsial ini, penggunaan σ sangat menyederhanakan aljabar, karena eksponen memiliki sifat yang sangat bagus ketika membedakan.  Bagaimanapun, σ sering digunakan dalam bekerja dengan jaringan saraf, dan paling sering dalam buku ini kita akan menggunakan fungsi aktivasi seperti itu. <br><br>  Bagaimana menafsirkan hasil kerja CH?  Jelas, perbedaan utama antara perceptrons dan CH adalah bahwa CH tidak hanya memberikan 0 atau 1. Outputnya dapat berupa bilangan real dari 0 hingga 1, sehingga nilai seperti 0,173 atau 0,689 valid.  Ini dapat bermanfaat, misalnya, jika Anda ingin nilai output menunjukkan, misalnya, kecerahan rata-rata piksel gambar yang diterima pada input NS.  Tapi kadang-kadang bisa merepotkan.  Misalkan kita ingin keluaran jaringan mengatakan bahwa "gambar 9 adalah input" atau "input gambar bukan 9".  Jelas, akan lebih mudah jika nilai output 0 atau 1, seperti perceptron.  Namun dalam praktiknya, kita dapat sepakat bahwa nilai output minimal 0,5 akan berarti "9" pada input, dan nilai apa pun yang kurang dari 0,5 akan berarti bahwa itu "bukan 9".  Saya akan selalu secara eksplisit menunjukkan keberadaan perjanjian tersebut. <br><br>  Latihan <br><br><ul><li>  CH mensimulasikan perceptrons, bagian 1 </li></ul><br>  Misalkan kita mengambil semua bobot dan offset dari jaringan perceptrons, dan mengalikannya dengan konstanta positif c&gt; 0.  Tunjukkan bahwa perilaku jaringan tidak berubah. <br><br><ul><li>  CH mensimulasikan perceptrons, bagian 2 </li></ul><br>  Misalkan kita memiliki situasi yang sama seperti pada masalah sebelumnya - jaringan perceptrons.  Juga anggaplah bahwa input data untuk jaringan dipilih.  Kami tidak membutuhkan nilai tertentu, yang utama adalah tetap.  Misalkan bobot dan perpindahan sedemikian rupa sehingga w⋅x + b ≠ 0, di mana x adalah nilai input dari setiap perceptron jaringan.  Sekarang kita mengganti semua perceptrons dalam jaringan dengan SN, dan gandakan bobot dan perpindahan dengan konstanta positif c&gt; 0.  Tunjukkan bahwa dalam batas c → ∞ perilaku jaringan dari SN akan persis sama dengan jaringan perceptrons.  Bagaimana pernyataan ini dilanggar jika untuk salah satu dari perceptrons w⋅x + b = 0? <br><br><h3>  Arsitektur jaringan saraf </h3><br>  Pada bagian selanjutnya, saya akan memperkenalkan jaringan saraf yang mampu mengklasifikasikan angka tulisan tangan dengan baik.  Sebelum itu, ada baiknya menjelaskan terminologi yang memungkinkan kita untuk menunjuk ke bagian jaringan yang berbeda.  Katakanlah kita memiliki jaringan berikut: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/472/521/00b/47252100b91b8e1a527796217a6ed0fa.png"><br><br>  Seperti yang saya sebutkan, lapisan paling kiri dalam jaringan disebut lapisan input, dan neuronnya disebut neuron input.  Lapisan paling kanan, atau keluaran, berisi neuron keluaran, atau, seperti dalam kasus kami, satu neuron keluaran.  Lapisan tengah disebut tersembunyi, karena neuronnya bukan input maupun output.  Istilah "tersembunyi" mungkin terdengar sedikit misterius - ketika saya pertama kali mendengarnya, saya memutuskan bahwa itu harus memiliki kepentingan filosofis atau matematika yang mendalam - namun, itu hanya berarti "tidak masuk atau keluar."  Jaringan di atas hanya memiliki satu lapisan tersembunyi, tetapi beberapa jaringan memiliki beberapa lapisan tersembunyi.  Misalnya, dalam jaringan empat lapis berikut ini ada dua lapisan tersembunyi: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/26e/be9/c5f/26ebe9c5f4c7f61413cfa43e67151734.png"><br><br>  Ini mungkin membingungkan, tetapi karena alasan historis, jaringan multi-layer seperti itu kadang-kadang disebut multilayer perceptrons, MLPs, meskipun mereka terdiri dari neuron sigmoid daripada perceptron.  Saya tidak akan menggunakan terminologi seperti itu karena membingungkan, tetapi saya harus memperingatkan tentang keberadaannya. <br><br>  Mendesain layer input dan output terkadang merupakan tugas yang sederhana.  Sebagai contoh, katakanlah kita mencoba menentukan apakah angka tulisan tangan berarti "9" atau tidak.  Sirkuit jaringan alami akan menyandikan kecerahan piksel gambar dalam neuron input.  Jika gambar hitam dan putih dengan ukuran 64x64 piksel, maka kita akan memiliki 64x64 = 4096 neuron input, dengan kecerahan dalam kisaran dari 0 hingga 1. Lapisan output hanya akan berisi satu neuron, yang nilainya kurang dari 0,5 akan berarti bahwa "pada input bukan 9 ", tetapi nilai lebih akan berarti bahwa" input adalah 9 ". <br><br>  Dan sementara mendesain layer input dan output seringkali merupakan tugas yang sederhana, mendesain layer tersembunyi bisa menjadi seni yang sulit.  Secara khusus, tidak mungkin untuk menggambarkan proses pengembangan lapisan tersembunyi dengan beberapa aturan praktis sederhana.  Para peneliti Majelis Nasional telah mengembangkan banyak aturan heuristik untuk desain lapisan tersembunyi yang membantu untuk mendapatkan perilaku jaringan saraf yang diinginkan.  Misalnya, heuristik semacam itu dapat digunakan untuk memahami bagaimana mencapai kompromi antara jumlah lapisan tersembunyi dan waktu yang tersedia untuk melatih jaringan.  Nanti kita akan menemui beberapa aturan ini. <br><br>  Sejauh ini, kita telah membahas NS di mana output dari satu layer digunakan sebagai input untuk layer berikutnya.  Jaringan semacam itu disebut jaringan saraf distribusi langsung.  Ini berarti bahwa tidak ada loop dalam jaringan - informasi selalu maju, dan tidak pernah memberi umpan balik.  Jika kita memiliki loop, kita akan menghadapi situasi di mana input sigmoid akan bergantung pada output.  Akan sulit untuk dipahami, dan kami tidak mengizinkan loop seperti itu. <br><br>  Namun, ada model lain dari NS buatan di mana dimungkinkan untuk menggunakan loop umpan balik.  Model-model ini disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">jaringan saraf berulang</a> (RNS).  Gagasan dari jaringan-jaringan ini adalah bahwa neuron-neuron mereka diaktifkan untuk periode waktu yang terbatas.  Aktivasi ini dapat merangsang neutron lain, yang dapat diaktifkan sedikit kemudian, juga untuk waktu yang terbatas.  Ini mengarah pada aktivasi neuron-neuron berikut, dan seiring berjalannya waktu kita mendapatkan kaskade neuron teraktivasi.  Loop dalam model seperti itu tidak menimbulkan masalah, karena output neuron mempengaruhi pemasukannya di lain waktu, dan tidak langsung. <br><br>  RNS tidak berpengaruh seperti NS distribusi langsung, khususnya karena algoritma pelatihan untuk RNS sejauh ini memiliki potensi lebih kecil.  Namun, RNS tetap sangat menarik.  Dalam semangat kerja, mereka lebih dekat ke otak daripada NS distribusi langsung.  Ada kemungkinan bahwa RNS akan dapat memecahkan masalah penting yang dapat diselesaikan dengan kesulitan besar dengan bantuan distribusi langsung NS.  Namun, untuk membatasi ruang lingkup penelitian kami, kami akan berkonsentrasi pada NS distribusi langsung yang lebih banyak digunakan. <br><br><h3>  Jaringan klasifikasi tinta sederhana </h3><br>  Setelah mendefinisikan jaringan saraf, kami akan kembali ke pengenalan tulisan tangan.  Tugas mengenali nomor tulisan tangan dapat dibagi menjadi dua subtugas.  Pertama, kami ingin menemukan cara untuk membagi gambar yang mengandung banyak digit ke dalam urutan masing-masing gambar, yang masing-masing berisi satu digit.  Sebagai contoh, kami ingin membagi gambar <br><br><img src="https://habrastorage.org/getpro/habr/post_images/839/d0b/543/839d0b54370af70f06b3f097897de457.png"><br><br>  menjadi enam yang terpisah <br><br><img src="https://habrastorage.org/getpro/habr/post_images/b36/135/6ae/b361356aec440b1dbf77c8dedbc6f9b6.png"><br><br>  Kita manusia dapat dengan mudah menyelesaikan masalah segmentasi ini, tetapi sulit bagi program komputer untuk membagi gambar dengan benar.  Setelah segmentasi, program perlu mengklasifikasikan setiap digit individu.  Jadi, misalnya, kami ingin program kami mengenali angka pertama <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e5a/c2a/808/e5ac2a808e18ac02ba0f09b2052fff4f.png"><br><br>  ini 5. <br><br>  Kami akan berkonsentrasi pada pembuatan program untuk memecahkan masalah kedua, klasifikasi angka individu.  Ternyata masalah segmentasi tidak begitu sulit untuk dipecahkan segera setelah kami menemukan cara yang baik untuk mengklasifikasikan digit individu.  Ada banyak pendekatan untuk memecahkan masalah segmentasi.  Salah satunya adalah mencoba berbagai cara segmentasi gambar menggunakan penggolong dari masing-masing digit, mengevaluasi setiap upaya.  Segmentasi uji coba sangat dihargai jika penggolong digit individu yakin dalam klasifikasi semua segmen, dan rendah jika memiliki masalah dalam satu segmen atau lebih.  Idenya adalah bahwa jika penggolong memiliki masalah di suatu tempat, ini kemungkinan besar berarti bahwa segmentasi tidak benar.  Gagasan ini dan opsi lainnya dapat digunakan untuk solusi yang baik untuk masalah segmentasi.  Jadi, alih-alih mengkhawatirkan segmentasi, kami akan berkonsentrasi pada pengembangan NS yang mampu menyelesaikan tugas yang lebih menarik dan kompleks, yaitu, mengenali angka tulisan tangan individu. <br><br>  Untuk mengenali masing-masing digit, kami akan menggunakan NS dari tiga lapisan: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/e6b/350/3dc/e6b3503dcc1e2848980d17ad8c193018.png"><br><br>  Lapisan jaringan input berisi neuron yang mengkodekan berbagai nilai piksel input.  Seperti yang akan ditunjukkan pada bagian selanjutnya, data pelatihan kami akan terdiri dari banyak gambar digit tulisan tangan yang dipindai berukuran 28x28 piksel, sehingga lapisan input berisi 28x28 = 784 neuron.  Untuk kesederhanaan, saya tidak menunjukkan sebagian besar 784 neuron dalam diagram.  Pixel yang masuk berwarna hitam dan putih, dengan nilai 0,0 mengindikasikan putih, 1,0 mengindikasikan hitam, dan nilai tengah menunjukkan semakin banyak nuansa abu-abu yang semakin gelap. <br><br>  Lapisan kedua jaringan disembunyikan.  Kami menunjukkan jumlah neuron di lapisan ini n, dan kami akan bereksperimen dengan nilai n yang berbeda.  Contoh di atas menunjukkan lapisan kecil yang tersembunyi yang hanya mengandung n = 15 neuron. <br><br>  Ada 10 neuron di lapisan output jaringan.  Jika neuron pertama diaktifkan, yaitu, nilai outputnya adalah ≈ 1, ini menunjukkan bahwa jaringan percaya bahwa inputnya adalah 0. Jika neuron kedua diaktifkan, jaringan percaya bahwa inputnya adalah 1. Dan seterusnya.  Sebenarnya, kami menomori neuron output dari 0 hingga 9, dan melihat mana di antara mereka yang memiliki nilai aktivasi maksimum.  Jika ini, katakanlah, neuron No. 6, maka jaringan kami percaya bahwa inputnya adalah nomor 6. Dan seterusnya. <br><br>  Anda mungkin bertanya-tanya mengapa kita perlu menggunakan sepuluh neuron.  Lagi pula, kami ingin tahu digit mana dari 0 hingga 9 yang sesuai dengan gambar input.  Wajar jika hanya menggunakan 4 neuron output, yang masing-masing akan mengambil nilai biner, tergantung pada apakah nilai outputnya lebih dekat ke 0 atau 1. Empat neuron akan cukup, karena 2 <sup>4</sup> = 16, lebih dari 10 nilai yang mungkin.  Mengapa jaringan kami menggunakan 10 neuron?  Apakah ini tidak efektif?  Dasar untuk ini adalah empiris;  kita dapat mencoba kedua varian jaringan, dan ternyata untuk tugas ini, jaringan dengan 10 neuron output lebih terlatih untuk mengenali angka daripada jaringan dengan 4.  Namun, pertanyaannya tetap, mengapa 10 neuron keluaran lebih baik.  Apakah ada heuristik yang akan memberitahu kita sebelumnya bahwa 10 neuron output harus digunakan, bukan 4? <br><br>  Untuk memahami alasannya, penting untuk memikirkan apa yang dilakukan jaringan saraf.  Pertama, pertimbangkan opsi dengan 10 neuron output.  Kami fokus pada neuron keluaran pertama, yang mencoba memutuskan apakah gambar yang masuk adalah nol.  Dia melakukan ini dengan menimbang bukti yang diperoleh dari lapisan tersembunyi.  Apa yang dilakukan neuron tersembunyi?  Misalkan neuron pertama dalam lapisan tersembunyi menentukan apakah ada sesuatu seperti ini pada gambar: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/650/c35/402/650c3540204f98b406e25078ddc8742a.png"><br><br>  Ia dapat melakukan ini dengan menetapkan bobot besar ke piksel yang cocok dengan gambar ini, dan bobot kecil untuk sisanya.  Dengan cara yang sama, anggaplah bahwa neuron kedua, ketiga dan keempat dalam lapisan tersembunyi mencari apakah ada fragmen yang serupa dalam gambar: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/d94/4c3/cea/d944c3cea54d91106d2ee2198d04c801.png"><br><br>  Seperti yang mungkin sudah Anda duga, keempat fragmen ini memberikan gambar 0, yang kita lihat sebelumnya: <br><br><img src="https://habrastorage.org/getpro/habr/post_images/f99/a20/1e5/f99a201e557bacdbe39190a6f913b49e.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, jika empat neuron tersembunyi diaktifkan, kita dapat menyimpulkan bahwa angkanya adalah 0. Tentu saja, ini bukan satu-satunya bukti bahwa 0 ditampilkan di sana - kita bisa mendapatkan 0 dengan banyak cara lain (dengan sedikit menggeser gambar-gambar ini atau sedikit mengubah mereka). </font><font style="vertical-align: inherit;">Namun, kita dapat mengatakan dengan pasti bahwa, setidaknya dalam kasus ini, kita dapat menyimpulkan bahwa ada 0 pada input.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika kita mengasumsikan bahwa jaringan bekerja seperti ini, kita dapat memberikan penjelasan yang masuk akal mengapa lebih baik menggunakan 10 neuron output daripada 4. Jika kita memiliki 4 neuron output, maka neuron pertama akan mencoba untuk memutuskan apa yang paling signifikan dari digit yang masuk. Dan tidak ada cara mudah untuk mengasosiasikan bit paling signifikan dengan bentuk sederhana yang diberikan di atas. Sulit membayangkan alasan historis mengapa bagian-bagian dari bentuk digit entah bagaimana terkait dengan bit paling signifikan dari output.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Namun, semua hal di atas hanya didukung oleh heuristik. </font><font style="vertical-align: inherit;">Tidak ada yang mendukung fakta bahwa jaringan tiga lapis harus bekerja seperti yang saya katakan, dan neuron tersembunyi harus menemukan komponen bentuk yang sederhana. </font><font style="vertical-align: inherit;">Mungkin algoritma pembelajaran yang rumit akan menemukan beberapa bobot yang akan memungkinkan kita untuk menggunakan hanya 4 neuron keluaran. </font><font style="vertical-align: inherit;">Namun, sebagai heuristik, metode saya berfungsi dengan baik, dan dapat menghemat waktu Anda dalam mengembangkan arsitektur NS yang baik.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Latihan </font></font></h3><br><ul><li>      ,      .          ,     .         . ,   3   ,       (  )     0,99,       0,01. </li></ul><br><img src="https://habrastorage.org/getpro/habr/post_images/f5b/4af/2e9/f5b4af2e9acf846ab8cc5c60dac20c03.png"><br><br><h3>     </h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jadi, kami memiliki skema NA - cara belajar mengenali angka? Hal pertama yang kita butuhkan adalah data pelatihan, yang disebut set data pelatihan. Kami akan menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kit MNIST yang</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> berisi puluhan ribu gambar pindaian angka tulisan tangan, dan klasifikasi yang benar. Nama MNIST diterima karena fakta bahwa itu adalah himpunan bagian dari dua set data yang dikumpulkan oleh </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">NIST</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , Institut Standar dan Teknologi Nasional AS. Berikut adalah beberapa gambar dari MNIST: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/b36/135/6ae/b361356aec440b1dbf77c8dedbc6f9b6.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini adalah angka yang sama yang diberikan pada awal bab sebagai tugas pengenalan. Tentu saja, ketika memeriksa NS, kami akan memintanya untuk mengenali gambar yang salah yang sudah ada di set pelatihan!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Data MNIST terdiri dari dua bagian. Yang pertama berisi 60.000 gambar yang dimaksudkan untuk pelatihan. Ini adalah naskah yang dipindai dari 250 orang, setengah di antaranya adalah karyawan Biro Sensus AS, dan setengah lainnya adalah siswa sekolah menengah. Gambar berwarna hitam dan putih, berukuran 28x28 piksel. Bagian kedua dari dataset MNIST adalah 10.000 gambar untuk menguji jaringan. Ini juga merupakan gambar hitam dan putih 28x28 piksel. Kami akan menggunakan data ini untuk mengevaluasi seberapa baik jaringan telah belajar mengenali angka. Untuk meningkatkan kualitas penilaian, angka-angka ini diambil dari 250 orang lain yang tidak berpartisipasi dalam rekaman set pelatihan (meskipun ini juga karyawan Biro dan siswa sekolah menengah). Ini membantu kami memastikan bahwa sistem kami dapat mengenali tulisan tangan orang-orang yang tidak bertemu selama pelatihan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Input pelatihan akan dilambangkan dengan x. Akan lebih mudah untuk memperlakukan setiap input gambar x sebagai vektor dengan 28x28 = 784 pengukuran. Setiap nilai di dalam vektor menunjukkan kecerahan satu piksel dalam gambar. Kami akan menunjukkan nilai output sebagai y = y (x), di mana y adalah vektor sepuluh dimensi. Misalnya, jika gambar pelatihan x tertentu berisi 6, maka y (x) = (0,0,0,0,0,0,1,0,0,0,0) </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> akan menjadi vektor yang kita butuhkan. T adalah operasi transpos yang mengubah vektor baris menjadi vektor kolom. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami ingin menemukan algoritma yang memungkinkan kami mencari bobot dan offset sedemikian rupa sehingga output jaringan mendekati y (x) untuk semua input pelatihan x. Untuk menghitung perkiraan tujuan ini, kami mendefinisikan fungsi biaya (kadang-kadang disebut </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">fungsi kerugian)</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">; dalam buku ini kita akan menggunakan fungsi biaya, tetapi perlu diingat nama lain):</font></font><br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-402"><span class="MJXp-mtable" id="MJXp-Span-403"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-404" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-405" style="text-align: center;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-406">C</span><span class="MJXp-mo" id="MJXp-Span-407" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-408">w</span><span class="MJXp-mo" id="MJXp-Span-409" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-410">b</span><span class="MJXp-mo" id="MJXp-Span-411" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-412" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mfrac" id="MJXp-Span-413" style="vertical-align: 0.25em;"><span class="MJXp-box"><span class="MJXp-mn" id="MJXp-Span-414">1</span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box"><span class="MJXp-mn" id="MJXp-Span-415">2</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-416">n</span></span></span></span></span></span><span class="MJXp-munderover" id="MJXp-Span-417"><span class=""><span class="MJXp-mo" id="MJXp-Span-418" style="margin-left: 0.111em; margin-right: 0.167em;"><span class="MJXp-largeop">∑</span></span></span><span class=" MJXp-script"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-419" style="margin-left: 0px;">x</span></span></span><span class="MJXp-mrow" id="MJXp-Span-420"><span class="MJXp-mo" id="MJXp-Span-421" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span><span class="MJXp-mrow" id="MJXp-Span-422"><span class="MJXp-mo" id="MJXp-Span-423" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-424">y</span><span class="MJXp-mo" id="MJXp-Span-425" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-426">x</span><span class="MJXp-mo" id="MJXp-Span-427" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mo" id="MJXp-Span-428" style="margin-left: 0em; margin-right: 0.222em;">–</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-429">a</span><span class="MJXp-mrow" id="MJXp-Span-430"><span class="MJXp-mo" id="MJXp-Span-431" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span><span class="MJXp-msubsup" id="MJXp-Span-432"><span class="MJXp-mrow" id="MJXp-Span-433" style="margin-right: 0.05em;"><span class="MJXp-mo" id="MJXp-Span-434" style="margin-left: 0.167em; margin-right: 0.167em;">|</span></span><span class="MJXp-mn MJXp-script" id="MJXp-Span-435" style="vertical-align: 0.5em;">2</span></span></span></span></span></span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-12-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-12"> C(w, b) = \frac{1}{2n} \sum_x || y(x) – a ||^2 \tag{6} </script></p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Di sini w menunjukkan seperangkat bobot jaringan, b adalah seperangkat offset, n adalah jumlah data input pelatihan, a adalah vektor data output ketika x adalah input data, dan jumlah melewati semua input pelatihan x. Outputnya, tentu saja, tergantung pada x, w dan b, tetapi untuk kesederhanaan saya tidak menunjuk ketergantungan ini. Notasi || v || berarti panjang vektor v. Kami akan menyebut C fungsi biaya kuadratik; kadang-kadang juga disebut kesalahan standar, atau MSE. Jika Anda mengamati C dengan seksama, Anda dapat melihat bahwa itu tidak negatif, karena semua anggota penjumlahan itu tidak negatif. Selain itu, biaya C (w, b) menjadi kecil, yaitu, C (w, b) ≈ 0, tepatnya ketika y (x) kira-kira sama dengan vektor output a untuk semua data input pelatihan x. Jadi algoritma kami bekerja dengan baik jika kami berhasil menemukan bobot dan offset sehingga C (w, b) ≈ 0. Dan sebaliknya, itu bekerja dengan buruk ketika C (w,b) besar - ini berarti bahwa y (x) tidak cocok dengan output untuk sejumlah besar input. Ternyata tujuan dari algoritma pelatihan adalah untuk meminimalkan biaya C (b, b) sebagai fungsi dari bobot dan offset. Dengan kata lain, kita perlu menemukan satu set bobot dan offset yang meminimalkan nilai biaya. Kami akan melakukan ini menggunakan algoritma yang disebut gradient descent.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mengapa kita membutuhkan nilai kuadratik? Bukankah kita terutama tertarik pada jumlah gambar yang dikenali dengan benar oleh jaringan? Apakah mungkin untuk memaksimalkan angka ini secara langsung, dan tidak meminimalkan nilai tengah dari nilai kuadratik? Masalahnya adalah bahwa jumlah gambar yang dikenali dengan benar bukanlah fungsi yang mulus dari bobot dan offset jaringan. Sebagian besar, perubahan kecil pada bobot dan offset tidak akan mengubah jumlah gambar yang dikenali dengan benar. Karena itu, sulit untuk memahami bagaimana mengubah bobot dan bias untuk meningkatkan efisiensi. Jika kita menggunakan fungsi biaya yang lancar, akan mudah bagi kita untuk memahami bagaimana membuat perubahan kecil dalam bobot dan offset untuk meningkatkan biaya. Oleh karena itu, pertama-tama kita akan fokus pada nilai kuadrat, dan kemudian kita akan mempelajari keakuratan klasifikasi.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bahkan mengingat bahwa kami ingin menggunakan fungsi biaya yang lancar, Anda mungkin masih tertarik mengapa kami memilih fungsi kuadrat untuk persamaan (6)? Apakah tidak mungkin untuk memilihnya secara sewenang-wenang? Mungkin jika kita memilih fungsi yang berbeda, kita akan mendapatkan satu set yang sama sekali berbeda untuk meminimalkan bobot dan offset? Sebuah pertanyaan yang masuk akal, dan nanti kita akan kembali memeriksa fungsi biaya dan membuat beberapa perbaikan untuk itu. Namun, fungsi biaya kuadrat berfungsi baik untuk memahami hal-hal dasar dalam mempelajari NS, jadi untuk sekarang kita akan tetap berpegang pada itu.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk meringkas: tujuan kami dalam pelatihan NS adalah untuk menemukan bobot dan offset yang meminimalkan fungsi biaya kuadratik C (b, b). Tugasnya cukup baik, tetapi sejauh ini ia memiliki banyak struktur yang mengganggu - penafsiran w dan b sebagai bobot dan penyeimbang, fungsi σ tersembunyi di latar belakang, pilihan arsitektur jaringan, MNIST, dan sebagainya. Ternyata kita bisa mengerti banyak, mengabaikan sebagian besar struktur ini, dan hanya berkonsentrasi pada aspek minimisasi. Jadi untuk sekarang, kita akan melupakan bentuk khusus fungsi biaya, komunikasi dengan Majelis Nasional, dan sebagainya. Sebaliknya, kita akan membayangkan bahwa kita hanya memiliki fungsi dengan banyak variabel, dan kami ingin menguranginya. Kami akan mengembangkan teknologi yang disebut gradient descent, yang dapat digunakan untuk menyelesaikan masalah tersebut. Dan kemudian kita kembali ke fungsi tertentu,yang kami ingin meminimalkan untuk Majelis Nasional.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Baiklah, katakanlah kita mencoba untuk meminimalkan beberapa fungsi C (v). Ini bisa berupa fungsi apa pun dengan nilai nyata dari banyak variabel v = v </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , v </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ... Perhatikan bahwa saya mengganti notasi w dan b dengan v untuk menunjukkan bahwa itu bisa berupa fungsi apa pun - kita tidak lagi terobsesi dengan HC. Sangat berguna untuk membayangkan bahwa fungsi C hanya memiliki dua variabel - v </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan v </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> : </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/fff/752/1ad/fff7521ad0e339cb68eceace0f200697.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami ingin menemukan di mana C mencapai minimum global. Tentu saja, dengan fungsi yang digambarkan di atas, kita dapat mempelajari grafik dan menemukan minimum. Dalam hal ini, saya mungkin telah memberi Anda fungsi yang terlalu sederhana! Dalam kasus umum, C dapat menjadi fungsi kompleks dari banyak variabel, dan biasanya tidak mungkin untuk hanya melihat grafik dan menemukan minimum.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Salah satu cara untuk memecahkan masalah adalah dengan menggunakan aljabar untuk menemukan minimum secara analitis. Kita dapat menghitung turunan dan mencoba menggunakannya untuk menemukan ekstrem. Jika kita beruntung, ini akan berfungsi ketika C adalah fungsi dari satu atau dua variabel. Tetapi dengan sejumlah besar variabel, ini berubah menjadi mimpi buruk. Dan untuk NS kita sering membutuhkan lebih banyak variabel - untuk NS terbesar, fungsi biaya dengan cara yang kompleks tergantung pada miliaran bobot dan perpindahan. Menggunakan aljabar untuk meminimalkan fungsi-fungsi ini akan gagal!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(Setelah menyatakan bahwa akan lebih nyaman bagi kita untuk menganggap C sebagai fungsi dari dua variabel, saya mengatakan dua kali dalam dua paragraf “ya, tetapi bagaimana jika itu adalah fungsi dari variabel yang jauh lebih besar?” Saya minta maaf. dua variabel, hanya saja kadang-kadang gambar ini berantakan, itulah sebabnya dua paragraf sebelumnya diperlukan. ZYA.)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oke, itu artinya aljabar tidak akan bekerja. Untungnya, ada analogi yang bagus yang menawarkan algoritma yang berfungsi dengan baik. Kami membayangkan fungsi kami seperti lembah. Dengan jadwal terbaru, tidak akan terlalu sulit untuk dilakukan. Dan kita membayangkan sebuah bola menggelinding di sepanjang lereng lembah. Pengalaman kami memberi tahu kami bahwa bola pada akhirnya akan meluncur ke bagian paling bawah. Mungkin kita bisa menggunakan ide ini untuk menemukan fungsi minimum? Kami secara acak memilih titik awal untuk bola imajiner, dan kemudian mensimulasikan pergerakan bola, seolah-olah itu bergulir ke dasar lembah. Kita dapat menggunakan simulasi ini hanya dengan menghitung turunan (dan, mungkin, turunan kedua) dari C - mereka akan memberi tahu kita segala sesuatu tentang bentuk lokal lembah, dan karenanya tentang bagaimana bola kita akan bergulir.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berdasarkan apa yang Anda tulis, Anda mungkin berpikir bahwa kami akan menuliskan persamaan gerak Newton untuk bola, mempertimbangkan efek gesekan dan gravitasi, dan sebagainya. Faktanya, kita tidak akan begitu dekat dengan analogi ini dengan bola - kita sedang mengembangkan algoritma untuk meminimalkan C, dan bukan simulasi yang tepat dari hukum fisika! Analogi ini harus merangsang imajinasi kita, dan tidak membatasi pemikiran kita. Jadi alih-alih menyelam ke detail fisika yang kompleks, mari kita ajukan pertanyaan: jika kita ditunjuk sebagai dewa untuk satu hari, dan kita akan membuat hukum fisika kita sendiri, memberi tahu bola cara menggulung hukum mana atau hukum gerak yang akan kita pilih, sehingga bola selalu bergulir ke atas bawah lembah? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mengklarifikasi masalah ini, kami akan memikirkan tentang apa yang terjadi jika kami memindahkan bola sedikit 1v </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke arah v </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, dan jarak kecil Δv </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ke arah v </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Aljabar memberi tahu kita bahwa C berubah sebagai berikut:</font></font><br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-436"><span class="MJXp-mtable" id="MJXp-Span-437"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-438" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-439" style="text-align: center;"><span class="MJXp-mi" id="MJXp-Span-440">Δ</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-441">C</span><span class="MJXp-mo" id="MJXp-Span-442" style="margin-left: 0.333em; margin-right: 0.333em;">≈</span><span class="MJXp-mfrac" id="MJXp-Span-443" style="vertical-align: 0.25em;"><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-444">∂</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-445">C</span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-446">∂</span><span class="MJXp-msubsup" id="MJXp-Span-447"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-448" style="margin-right: 0.05em;">v</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-449" style="vertical-align: -0.4em;">1</span></span></span></span></span></span></span><span class="MJXp-mi" id="MJXp-Span-450">Δ</span><span class="MJXp-msubsup" id="MJXp-Span-451"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-452" style="margin-right: 0.05em;">v</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-453" style="vertical-align: -0.4em;">1</span></span><span class="MJXp-mo" id="MJXp-Span-454" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mfrac" id="MJXp-Span-455" style="vertical-align: 0.25em;"><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-456">∂</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-457">C</span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-458">∂</span><span class="MJXp-msubsup" id="MJXp-Span-459"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-460" style="margin-right: 0.05em;">v</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-461" style="vertical-align: -0.4em;">2</span></span></span></span></span></span></span><span class="MJXp-mi" id="MJXp-Span-462">Δ</span><span class="MJXp-msubsup" id="MJXp-Span-463"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-464" style="margin-right: 0.05em;">v</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-465" style="vertical-align: -0.4em;">2</span></span></span></span></span></span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-13-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-13"> \Delta C \approx \frac{\partial C}{\partial v_1} \Delta v_1 + \frac{\partial C}{\partial v_2} \Delta v_2 \tag{7} </script></p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami akan menemukan cara untuk memilih Δv </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan Δv </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> sehingga ΔC kurang dari nol; </font><font style="vertical-align: inherit;">yaitu, kami akan memilih mereka sehingga bola bergulir ke bawah. </font><font style="vertical-align: inherit;">Untuk memahami bagaimana melakukan ini, penting untuk mendefinisikan asv sebagai vektor perubahan, yaitu, Δv ≡ (Δv </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , 2v </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , di mana T adalah operasi transpos yang mengubah vektor baris menjadi vektor kolom. </font><font style="vertical-align: inherit;">Kami juga mendefinisikan vektor gradien C sebagai derivatif parsial (∂S / ∂v </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ∂S / ∂v </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Kami menunjukkan vektor gradien oleh ∇:</font></font><br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-466"><span class="MJXp-mtable" id="MJXp-Span-467"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-468" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-469" style="text-align: center;"><span class="MJXp-mi" id="MJXp-Span-470">∇</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-471">C</span><span class="MJXp-mo" id="MJXp-Span-472" style="margin-left: 0.333em; margin-right: 0.333em;">≡</span><span class="MJXp-mo" id="MJXp-Span-473" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mfrac" id="MJXp-Span-474" style="vertical-align: 0.25em;"><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-475">∂</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-476">C</span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-477">∂</span><span class="MJXp-msubsup" id="MJXp-Span-478"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-479" style="margin-right: 0.05em;">v</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-480" style="vertical-align: -0.4em;">1</span></span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-481" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mfrac" id="MJXp-Span-482" style="vertical-align: 0.25em;"><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-483">∂</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-484">C</span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-485">∂</span><span class="MJXp-msubsup" id="MJXp-Span-486"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-487" style="margin-right: 0.05em;">v</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-488" style="vertical-align: -0.4em;">2</span></span></span></span></span></span></span><span class="MJXp-msubsup" id="MJXp-Span-489"><span class="MJXp-mo" id="MJXp-Span-490" style="margin-left: 0em; margin-right: 0.05em;">)</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-491" style="vertical-align: 0.5em;">T</span></span></span></span></span></span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-14-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-14"> \nabla C \equiv (\frac{\partial C}{\partial v_1}, \frac{\partial C}{\partial v_2})^T \tag{8} </script></p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Segera kami akan menulis ulang perubahan ΔC hingga Δv dan gradien ∇C. Sementara itu, saya ingin mengklarifikasi sesuatu, karena itu orang sering bergantung pada gradien. Ketika mereka pertama kali bertemu dengan ∇C, orang kadang-kadang tidak mengerti bagaimana mereka harus memahami simbol ∇. Apa artinya secara khusus? Bahkan, Anda dapat dengan aman mempertimbangkan ∇C sebagai objek matematika tunggal - vektor yang telah ditentukan sebelumnya - yang hanya ditulis menggunakan dua karakter. Dari sudut pandang ini, ∇ seperti mengibarkan bendera yang menginformasikan bahwa "∇C adalah vektor gradien." Ada beberapa sudut pandang yang lebih maju dari mana ∇ dapat dianggap sebagai entitas matematika independen (misalnya, sebagai operator diferensiasi), tetapi kami tidak membutuhkannya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan definisi seperti itu, ekspresi (7) dapat ditulis ulang sebagai:</font></font><br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-492"><span class="MJXp-mtable" id="MJXp-Span-493"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-494" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-495" style="text-align: center;"><span class="MJXp-mi" id="MJXp-Span-496">Δ</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-497">C</span><span class="MJXp-mo" id="MJXp-Span-498" style="margin-left: 0.333em; margin-right: 0.333em;">≈</span><span class="MJXp-mi" id="MJXp-Span-499">∇</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-500">C</span><span class="MJXp-mo" id="MJXp-Span-501" style="margin-left: 0.267em; margin-right: 0.267em;">⋅</span><span class="MJXp-mi" id="MJXp-Span-502">Δ</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-503">v</span></span></span></span></span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-15-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-15"> \Delta C \approx \nabla C \cdot \Delta v \tag{9} </script></p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Persamaan ini membantu menjelaskan mengapa ∇C disebut vektor gradien: ia menghubungkan perubahan v dengan perubahan C, sama seperti yang diharapkan dari entitas yang disebut gradien. [eng. gradient - deviasi / kira-kira. terjemahan.] Namun, lebih menarik bahwa persamaan ini memungkinkan kita untuk melihat bagaimana memilih Δv sehingga ΔC negatif. Katakanlah kita memilih</font></font><br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-504"><span class="MJXp-mtable" id="MJXp-Span-505"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-506" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-507" style="text-align: center;"><span class="MJXp-mi" id="MJXp-Span-508">Δ</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-509">v</span><span class="MJXp-mo" id="MJXp-Span-510" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mo" id="MJXp-Span-511" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-512">η</span><span class="MJXp-mi" id="MJXp-Span-513">∇</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-514">C</span></span></span></span></span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-16-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-16"> \Delta v = - \eta \nabla C \tag{10} </script></p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di mana η adalah parameter positif kecil (kecepatan belajar). Kemudian persamaan (9) memberi tahu kita bahwa ΔC ≈ - η ∇C ⋅ ∇C = - η || ∇C || </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Sejak || ∇C || </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ≥ 0, ini memastikan bahwa ΔC ≤ 0, yaitu, C akan berkurang sepanjang waktu jika kita mengubah v, sebagaimana ditentukan dalam (10) (tentu saja, sebagai bagian dari perkiraan dari persamaan (9)). Dan inilah yang kita butuhkan! Oleh karena itu, kita mengambil persamaan (10) untuk menentukan "hukum gerak" bola dalam algoritma gradient descent kami. Artinya, kita akan menggunakan persamaan (10) untuk menghitung nilai Δv, dan kemudian kita akan memindahkan bola ke nilai ini:</font></font><br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-515"><span class="MJXp-mtable" id="MJXp-Span-516"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-517" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-518" style="text-align: center;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-519">v</span><span class="MJXp-mo" id="MJXp-Span-520" style="margin-left: 0.333em; margin-right: 0.333em;">→</span><span class="MJXp-msup" id="MJXp-Span-521"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-522" style="margin-right: 0.05em;">v</span><span class="MJXp-mo MJXp-script" id="MJXp-Span-523" style="vertical-align: 0.5em;">′</span></span><span class="MJXp-mo" id="MJXp-Span-524" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-525">v</span><span class="MJXp-mo" id="MJXp-Span-526" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-527">η</span><span class="MJXp-mi" id="MJXp-Span-528">∇</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-529">C</span></span></span></span></span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-17-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-17"> v \rightarrow v' = v - \eta \nabla C \tag{11} </script></p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kemudian kami kembali menerapkan aturan ini untuk langkah selanjutnya. Melanjutkan pengulangan, kami akan menurunkan C hingga, semoga, kami mencapai minimum global. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesimpulannya, gradient descent bekerja melalui perhitungan sekuensial dari gradien ∇ C, dan perpindahan selanjutnya dalam arah yang berlawanan, yang mengarah pada “jatuh” di sepanjang lereng lembah. Ini dapat divisualisasikan sebagai berikut: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/5f7/495/966/5f749596634bc20923f5f8a3e49a3b9f.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Perhatikan bahwa dengan aturan ini, gradient descent tidak mereproduksi gerak fisik nyata. Dalam kehidupan nyata, bola memiliki dorongan yang memungkinkan bola bergulir melewati lereng, atau bahkan menggulung selama beberapa waktu. Hanya setelah pekerjaan gaya gesekan, bola dijamin akan bergulir ke bawah lembah. Aturan seleksi kami Δv hanya mengatakan "turun". Aturan yang cukup bagus untuk menemukan minimum!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Agar gradient descent berfungsi dengan benar, kita perlu memilih nilai kecepatan pembelajaran yang cukup kecil η sehingga persamaan (9) adalah perkiraan yang baik. Kalau tidak, mungkin akan menghasilkan ΔC&gt; 0 - tidak ada yang baik! Pada saat yang sama, η tidak perlu terlalu kecil, karena perubahan Δv akan menjadi kecil, dan algoritme akan bekerja terlalu lambat. Dalam prakteknya, η berubah sehingga persamaan (9) memberikan perkiraan yang baik, dan algoritma tidak bekerja terlalu lambat. Nanti kita akan lihat cara kerjanya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya menjelaskan gradient descent ketika fungsi C hanya bergantung pada dua variabel. Tetapi semuanya bekerja dengan cara yang sama jika C adalah fungsi dari banyak variabel. Misalkan dia memiliki variabel m, v </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ..., v </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Maka perubahan ΔC yang disebabkan oleh perubahan kecil dalam Δv = (Δv </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">1</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , ..., Δv </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">m</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ) </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">T</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> akan menjadi</font></font><br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-530"><span class="MJXp-mtable" id="MJXp-Span-531"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-532" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-533" style="text-align: center;"><span class="MJXp-mi" id="MJXp-Span-534">Δ</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-535">C</span><span class="MJXp-mo" id="MJXp-Span-536" style="margin-left: 0.333em; margin-right: 0.333em;">≈</span><span class="MJXp-mi" id="MJXp-Span-537">∇</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-538">C</span><span class="MJXp-mo" id="MJXp-Span-539" style="margin-left: 0.267em; margin-right: 0.267em;">⋅</span><span class="MJXp-mi" id="MJXp-Span-540">Δ</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-541">v</span></span></span></span></span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-18-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-18"> \Delta C \approx \nabla C \cdot \Delta v \tag{12} </script></p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di mana gradien ∇C adalah vektor </font></font><br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-542"><span class="MJXp-mtable" id="MJXp-Span-543"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-544" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-545" style="text-align: center;"><span class="MJXp-mi" id="MJXp-Span-546">∇</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-547">C</span><span class="MJXp-mo" id="MJXp-Span-548" style="margin-left: 0.333em; margin-right: 0.333em;">≡</span><span class="MJXp-mo" id="MJXp-Span-549" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mfrac" id="MJXp-Span-550" style="vertical-align: 0.25em;"><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-551">∂</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-552">C</span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-553">∂</span><span class="MJXp-msubsup" id="MJXp-Span-554"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-555" style="margin-right: 0.05em;">v</span><span class="MJXp-mn MJXp-script" id="MJXp-Span-556" style="vertical-align: -0.4em;">1</span></span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-557" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mo" id="MJXp-Span-558" style="margin-left: 0em; margin-right: 0em;">…</span><span class="MJXp-mo" id="MJXp-Span-559" style="margin-left: 0em; margin-right: 0.222em;">,</span><span class="MJXp-mfrac" id="MJXp-Span-560" style="vertical-align: 0.25em;"><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-561">∂</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-562">C</span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-563">∂</span><span class="MJXp-msubsup" id="MJXp-Span-564"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-565" style="margin-right: 0.05em;">v</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-566" style="vertical-align: -0.4em;">m</span></span></span></span></span></span></span><span class="MJXp-msubsup" id="MJXp-Span-567"><span class="MJXp-mo" id="MJXp-Span-568" style="margin-left: 0em; margin-right: 0.05em;">)</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-569" style="vertical-align: 0.5em;">T</span></span></span></span></span></span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-19-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-19"> \nabla C \equiv (\frac{\partial C}{\partial v_1},…, \frac{\partial C}{\partial v_m})^T \tag{13} </script></p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Seperti halnya dua variabel, kita dapat memilih </font></font><br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-570"><span class="MJXp-mtable" id="MJXp-Span-571"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-572" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-573" style="text-align: center;"><span class="MJXp-mi" id="MJXp-Span-574">Δ</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-575">v</span><span class="MJXp-mo" id="MJXp-Span-576" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mo" id="MJXp-Span-577" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-578">η</span><span class="MJXp-mi" id="MJXp-Span-579">∇</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-580">C</span></span></span></span></span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-20-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-20"> \Delta v = - \eta \nabla C \tag{14} </script></p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">dan memastikan bahwa perkiraan kami (12) untuk ΔC negatif. </font><font style="vertical-align: inherit;">Ini memberi kita cara untuk menjalankan gradien ke minimum, bahkan ketika C adalah fungsi dari banyak variabel, menerapkan aturan pembaruan berulang-ulang.</font></font><br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-581"><span class="MJXp-mtable" id="MJXp-Span-582"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-583" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-584" style="text-align: center;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-585">v</span><span class="MJXp-mo" id="MJXp-Span-586" style="margin-left: 0.333em; margin-right: 0.333em;">→</span><span class="MJXp-msup" id="MJXp-Span-587"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-588" style="margin-right: 0.05em;">v</span><span class="MJXp-mo MJXp-script" id="MJXp-Span-589" style="vertical-align: 0.5em;">′</span></span><span class="MJXp-mo" id="MJXp-Span-590" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-591">v</span><span class="MJXp-mo" id="MJXp-Span-592" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-593">η</span><span class="MJXp-mi" id="MJXp-Span-594">∇</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-595">C</span></span></span></span></span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-21-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-21"> v \rightarrow v' = v - \eta \nabla C \tag{15} </script></p><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aturan pembaruan ini dapat dianggap sebagai algoritma penurunan gradien pendefinisian. Ini memberi kita metode berulang kali mengubah posisi v dalam mencari minimum fungsi C. Aturan ini tidak selalu berfungsi - beberapa hal bisa salah, mencegah gradien keturunan menemukan minimum global C - kita akan kembali ke titik ini dalam bab-bab berikut. Namun dalam praktiknya, gradient descent sering bekerja dengan sangat baik, dan kita akan melihat bahwa di Majelis Nasional ini adalah cara yang efektif untuk meminimalkan fungsi biaya, dan karenanya, melatih jaringan.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam arti tertentu, gradient descent dapat dianggap sebagai strategi pencarian minimum yang optimal. </font><font style="vertical-align: inherit;">Misalkan kita sedang mencoba memindahkan tov ke posisi untuk meminimalkan C. Ini sama dengan meminimalkan ΔC ≈ ∇C ⋅ Δv. </font><font style="vertical-align: inherit;">Kami akan membatasi ukuran langkah sehingga || Δv || </font><font style="vertical-align: inherit;">= ε untuk beberapa konstanta kecil ε&gt; 0. Dengan kata lain, kami ingin memindahkan jarak kecil dari ukuran tetap, dan mencoba menemukan arah gerakan yang mengurangi C sebanyak mungkin. </font><font style="vertical-align: inherit;">Dapat dibuktikan bahwa pilihan minimv meminimalkan ∇C ⋅ Δv adalah Δv = -η∇C, di mana η = ε / || ∇C || ditentukan oleh batasan || Δv || </font><font style="vertical-align: inherit;">= ε. </font><font style="vertical-align: inherit;">Jadi gradient descent dapat dianggap sebagai cara untuk mengambil langkah-langkah kecil ke arah yang paling banyak menurunkan C.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Latihan </font></font></h3><br><ul><li>     . :      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">  — </a> , ,  ,      . </li><li>     ,      ,       .  ,       ?            ? </li></ul><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Orang-orang telah mempelajari banyak pilihan untuk gradient descent, termasuk yang lebih akurat mereproduksi bola fisik nyata. Opsi semacam itu memiliki kelebihan, tetapi juga kelemahan besar: kebutuhan untuk menghitung turunan parsial kedua C, yang dapat menghabiskan banyak sumber daya. Untuk memahami hal ini, anggaplah kita perlu menghitung semua turunan parsial kedua ∂ </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C / ∂v </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ∂v </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Jika variabel </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vj adalah</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> juta, maka kita perlu menghitung sekitar satu triliun (satu juta kuadrat) dari turunan parsial kedua (sebenarnya, setengah triliun, karena ∂ </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C / ∂v </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ∂v </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> = ∂ </font></font><sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">2</font></font></sup><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> C / ∂v </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ∂v </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">j</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Tetapi Anda menangkap esensinya). Ini akan membutuhkan banyak sumber daya komputasi. Ada trik untuk menghindari ini, dan mencari alternatif untuk gradient descent adalah bidang penelitian aktif. Namun, dalam buku ini kita akan menggunakan gradient descent dan variannya sebagai pendekatan utama untuk mempelajari NS. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana kita menerapkan gradient descent pada pembelajaran NA? Kita perlu menggunakannya untuk mencari bobot w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan offset b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> yang meminimalkan persamaan biaya (6). Mari kita menulis ulang aturan pembaruan gradient descent dengan mengganti variabel </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">vj</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dengan </font><font style="vertical-align: inherit;">bobot dan offset. Dengan kata lain, sekarang kami "posisi" adalah komponen dari w </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , sedangkan vektor gradient ∇C telah komponen ∂C / ∂w sesuai</font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">k</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dan ∂C / ∂b </font></font><sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">l</font></font></sub><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Setelah menulis aturan pembaruan kami dengan komponen baru, kami mendapatkan:</font></font><br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-596"><span class="MJXp-mtable" id="MJXp-Span-597"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-598" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-599" style="text-align: center;"><span class="MJXp-msubsup" id="MJXp-Span-600"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-601" style="margin-right: 0.05em;">w</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-602" style="vertical-align: -0.4em;">k</span></span><span class="MJXp-mo" id="MJXp-Span-603" style="margin-left: 0.333em; margin-right: 0.333em;">→</span><span class="MJXp-msubsup" id="MJXp-Span-604"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-605" style="margin-right: 0.05em;">w</span><span class="MJXp-script-box" style="height: 1.86em; vertical-align: -0.64em;"><span class=" MJXp-script"><span><span style="margin-bottom: -0.25em;"><span class="MJXp-mo" id="MJXp-Span-607">′</span></span></span></span><span class=" MJXp-script"><span><span style="margin-top: -0.85em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-606">k</span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-608" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-msubsup" id="MJXp-Span-609"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-610" style="margin-right: 0.05em;">w</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-611" style="vertical-align: -0.4em;">k</span></span><span class="MJXp-mo" id="MJXp-Span-612" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-613">η</span><span class="MJXp-mfrac" id="MJXp-Span-614" style="vertical-align: 0.25em;"><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-615">∂</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-616">C</span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-617">∂</span><span class="MJXp-msubsup" id="MJXp-Span-618"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-619" style="margin-right: 0.05em;">w</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-620" style="vertical-align: -0.4em;">k</span></span></span></span></span></span></span></span></span></span></span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-22-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-22"> w_k \rightarrow w'_k = w_k - \eta \frac{\partial C}{\partial w_k} \tag{16} </script></p><br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-621"><span class="MJXp-mtable" id="MJXp-Span-622"><span><span class="MJXp-mlabeledtr" id="MJXp-Span-623" style="vertical-align: baseline;"><span class="MJXp-mtd" id="MJXp-Span-624" style="text-align: center;"><span class="MJXp-msubsup" id="MJXp-Span-625"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-626" style="margin-right: 0.05em;">b</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-627" style="vertical-align: -0.4em;">l</span></span><span class="MJXp-mo" id="MJXp-Span-628" style="margin-left: 0.333em; margin-right: 0.333em;">→</span><span class="MJXp-msubsup" id="MJXp-Span-629"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-630" style="margin-right: 0.05em;">b</span><span class="MJXp-script-box" style="height: 1.86em; vertical-align: -0.64em;"><span class=" MJXp-script"><span><span style="margin-bottom: -0.25em;"><span class="MJXp-mo" id="MJXp-Span-632">′</span></span></span></span><span class=" MJXp-script"><span><span style="margin-top: -0.85em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-631">l</span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-633" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-msubsup" id="MJXp-Span-634"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-635" style="margin-right: 0.05em;">b</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-636" style="vertical-align: -0.4em;">l</span></span><span class="MJXp-mo" id="MJXp-Span-637" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-638">η</span><span class="MJXp-mfrac" id="MJXp-Span-639" style="vertical-align: 0.25em;"><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-640">∂</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-641">C</span></span><span class="MJXp-box" style="margin-top: -0.9em;"><span class="MJXp-denom"><span><span class="MJXp-rule" style="height: 1em; border-top: none; border-bottom: 1px solid; margin: 0.1em 0px;"></span></span><span><span class="MJXp-box"><span class="MJXp-mi" id="MJXp-Span-642">∂</span><span class="MJXp-msubsup" id="MJXp-Span-643"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-644" style="margin-right: 0.05em;">b</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-645" style="vertical-align: -0.4em;">l</span></span></span></span></span></span></span></span></span></span></span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-23-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-23"> b_l \rightarrow b'_l = b_l - \eta \frac{\partial C}{\partial b_l} \tag{17} </script></p><br><br>  Dengan menerapkan kembali aturan pembaruan ini, kita dapat "meluncur turun" dan, dengan sedikit keberuntungan, menemukan fungsi biaya minimum.  Dengan kata lain, aturan ini dapat digunakan untuk melatih Majelis Nasional. <br><br>  Ada beberapa kendala untuk menerapkan aturan gradient descent.  Kami akan mempelajarinya secara lebih rinci dalam bab-bab berikut.  Tetapi untuk sekarang, saya hanya ingin menyebutkan satu masalah.  Untuk memahaminya, mari kita kembali ke nilai kuadrat dalam persamaan (6).  Perhatikan bahwa fungsi biaya ini terlihat seperti C = 1 / n <sub>x</sub> C <sub>x</sub> , yaitu biaya rata-rata C <sub>x</sub> ≡ (|| y (x) −a || <sup>2</sup> ) / 2 untuk contoh pelatihan individual.  Dalam praktiknya, untuk menghitung gradien ∇C, kita perlu menghitung gradien ∇C <sub>x</sub> secara terpisah untuk setiap input pelatihan x, dan kemudian rata-rata, ∇C = 1 / n <sub>x x</sub> ∇C <sub>x</sub> .  Sayangnya, ketika jumlah input akan sangat besar, itu akan memakan waktu yang sangat lama, dan pelatihan seperti itu akan lambat. <br><br>  Untuk mempercepat pembelajaran, Anda dapat menggunakan keturunan gradien stokastik.  Idenya adalah untuk kira-kira menghitung gradien ∇C dengan menghitung ∇C <sub>x</sub> untuk sampel acak kecil dari input pelatihan.  Dengan menghitung rata-rata, kita dapat dengan cepat mendapatkan estimasi yang baik dari gradien sebenarnya ∇C, dan ini membantu mempercepat gradient descent, dan karenanya melatih. <br><br>  Merumuskan lebih tepat, penurunan gradien stokastik bekerja melalui pengambilan sampel acak dari sejumlah kecil data input pelatihan.  Kami akan memanggil data acak ini X <sub>1</sub> , X <sub>2</sub> , .., X <sub>m</sub> , dan menyebutnya paket mini.  Jika ukuran sampel m cukup besar, nilai rata-rata ∇C <sub>X <sub>j</sub></sub> akan cukup dekat dengan rata-rata semua ∇Cx, yaitu. <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-646"><span class="MJXp-mtext" id="MJXp-Span-647">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-648">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-649">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-650">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-651">c</span><span class="MJXp-mrow" id="MJXp-Span-652"><span class="MJXp-mtext" id="MJXp-Span-653">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-654">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-655">u</span><span class="MJXp-msubsup" id="MJXp-Span-656"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-657" style="margin-right: 0.05em;">m</span><span class="MJXp-script-box" style="height: 1.86em; vertical-align: -0.64em;"><span class=" MJXp-script"><span><span style="margin-bottom: -0.25em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-662">m</span></span></span></span><span class=" MJXp-script"><span><span style="margin-top: -0.85em;"><span class="MJXp-mrow" id="MJXp-Span-658"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-659">j</span><span class="MJXp-mo" id="MJXp-Span-660">=</span><span class="MJXp-mn" id="MJXp-Span-661">1</span></span></span></span></span></span></span><span class="MJXp-mtext" id="MJXp-Span-663">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-664">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-665">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-666">b</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-667">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-668">a</span><span class="MJXp-msubsup" id="MJXp-Span-669"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-670" style="margin-right: 0.05em;">C</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-671" style="vertical-align: -0.4em;"><span class="MJXp-msubsup" id="MJXp-Span-672"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-673" style="margin-right: 0.05em;">X</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-674" style="vertical-align: -0.4em;">j</span></span></span></span></span><span class="MJXp-mrow" id="MJXp-Span-675"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-676">m</span></span><span class="MJXp-mtext" id="MJXp-Span-677">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-678">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-679">p</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-680">p</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-681">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-682">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-683">x</span><span class="MJXp-mtext" id="MJXp-Span-684">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-685">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-686">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-687">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-688">c</span><span class="MJXp-mrow" id="MJXp-Span-689"><span class="MJXp-mtext" id="MJXp-Span-690">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-691">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-692">u</span><span class="MJXp-msubsup" id="MJXp-Span-693"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-694" style="margin-right: 0.05em;">m</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-695" style="vertical-align: -0.4em;">x</span></span><span class="MJXp-mtext" id="MJXp-Span-696">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-697">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-698">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-699">b</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-700">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-701">a</span><span class="MJXp-msubsup" id="MJXp-Span-702"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-703" style="margin-right: 0.05em;">C</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-704" style="vertical-align: -0.4em;">x</span></span></span><span class="MJXp-mrow" id="MJXp-Span-705"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-706">n</span></span><span class="MJXp-mo" id="MJXp-Span-707" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mtext" id="MJXp-Span-708">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-709">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-710">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-711">b</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-712">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-713">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-714">C</span><span class="MJXp-mtext" id="MJXp-Span-715">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-716">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-717">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-718">g</span><span class="MJXp-mrow" id="MJXp-Span-719"><span class="MJXp-mn" id="MJXp-Span-720">18</span></span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-24-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-24"> \ frac {\ sum ^ m_ {j = 1} \ nabla C_ {X_j}} {m} \ approx \ frac {\ sum_x \ nabla C_x} {n} = \ nabla C \ tag {18} </script></p><br><br>  di mana jumlah kedua melewati seluruh set data pelatihan.  Dengan menukar bagian, kita dapatkan <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-721"><span class="MJXp-mtext" id="MJXp-Span-722">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-723">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-724">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-725">b</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-726">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-727">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-728">C</span><span class="MJXp-mtext" id="MJXp-Span-729">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-730">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-731">p</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-732">p</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-733">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-734">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-735">x</span><span class="MJXp-mtext" id="MJXp-Span-736">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-737">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-738">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-739">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-740">c</span><span class="MJXp-mrow" id="MJXp-Span-741"><span class="MJXp-mn" id="MJXp-Span-742">1</span></span><span class="MJXp-mrow" id="MJXp-Span-743"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-744">m</span></span><span class="MJXp-mtext" id="MJXp-Span-745">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-746">j</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-747">u</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-748">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-749">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-750">a</span><span class="MJXp-msubsup" id="MJXp-Span-751"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-752" style="margin-right: 0.05em;">h</span><span class="MJXp-script-box" style="height: 1.86em; vertical-align: -0.64em;"><span class=" MJXp-script"><span><span style="margin-bottom: -0.25em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-757">m</span></span></span></span><span class=" MJXp-script"><span><span style="margin-top: -0.85em;"><span class="MJXp-mrow" id="MJXp-Span-753"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-754">j</span><span class="MJXp-mo" id="MJXp-Span-755">=</span><span class="MJXp-mn" id="MJXp-Span-756">1</span></span></span></span></span></span></span><span class="MJXp-mtext" id="MJXp-Span-758">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-759">n</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-760">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-761">b</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-762">l</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-763">a</span><span class="MJXp-msubsup" id="MJXp-Span-764"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-765" style="margin-right: 0.05em;">C</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-766" style="vertical-align: -0.4em;"><span class="MJXp-msubsup" id="MJXp-Span-767"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-768" style="margin-right: 0.05em;">X</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-769" style="vertical-align: -0.4em;">j</span></span></span></span><span class="MJXp-mtext" id="MJXp-Span-770">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-771">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-772">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-773">g</span><span class="MJXp-mrow" id="MJXp-Span-774"><span class="MJXp-mn" id="MJXp-Span-775">19</span></span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-25-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-25"> \ nabla C \ approx \ frac {1} {m} \ jumlah ^ m_ {j = 1} \ nabla C_ {X_j} \ tag {19} </script></p><br><br>  yang mengonfirmasi bahwa kita dapat memperkirakan gradien keseluruhan dengan menghitung gradien untuk minipack yang dipilih secara acak. <br><br>  Untuk mengaitkan ini langsung dengan pelatihan NS, mari kita asumsikan bahwa <sub>wk</sub> dan b <sub>l</sub> menunjukkan bobot dan perpindahan NS kita.  Kemudian keturunan gradien stokastik memilih paket mini acak dari data input, dan belajar dari mereka <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-776"><span class="MJXp-msubsup" id="MJXp-Span-777"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-778" style="margin-right: 0.05em;">w</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-779" style="vertical-align: -0.4em;">k</span></span><span class="MJXp-mtext" id="MJXp-Span-780">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-781">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-782">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-783">g</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-784">h</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-785">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-786">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-787">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-788">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-789">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-790">w</span><span class="MJXp-msubsup" id="MJXp-Span-791"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-792" style="margin-right: 0.05em;">w</span><span class="MJXp-script-box" style="height: 1.86em; vertical-align: -0.64em;"><span class=" MJXp-script"><span><span style="margin-bottom: -0.25em;"><span class="MJXp-mo" id="MJXp-Span-794">′</span></span></span></span><span class=" MJXp-script"><span><span style="margin-top: -0.85em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-793">k</span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-795" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-msubsup" id="MJXp-Span-796"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-797" style="margin-right: 0.05em;">w</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-798" style="vertical-align: -0.4em;">k</span></span><span class="MJXp-mo" id="MJXp-Span-799" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mtext" id="MJXp-Span-800">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-801">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-802">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-803">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-804">c</span><span class="MJXp-mrow" id="MJXp-Span-805"><span class="MJXp-mtext" id="MJXp-Span-806">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-807">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-808">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-809">a</span></span><span class="MJXp-mrow" id="MJXp-Span-810"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-811">m</span></span><span class="MJXp-mtext" id="MJXp-Span-812">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-813">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-814">u</span><span class="MJXp-msubsup" id="MJXp-Span-815"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-816" style="margin-right: 0.05em;">m</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-817" style="vertical-align: -0.4em;">j</span></span><span class="MJXp-mtext" id="MJXp-Span-818">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-819">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-820">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-821">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-822">c</span><span class="MJXp-mrow" id="MJXp-Span-823"><span class="MJXp-mtext" id="MJXp-Span-824">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-825">p</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-826">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-827">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-828">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-829">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-830">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-831">l</span><span class="MJXp-msubsup" id="MJXp-Span-832"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-833" style="margin-right: 0.05em;">C</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-834" style="vertical-align: -0.4em;"><span class="MJXp-msubsup" id="MJXp-Span-835"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-836" style="margin-right: 0.05em;">X</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-837" style="vertical-align: -0.4em;">j</span></span></span></span></span><span class="MJXp-mrow" id="MJXp-Span-838"><span class="MJXp-mtext" id="MJXp-Span-839">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-840">p</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-841">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-842">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-843">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-844">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-845">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-846">l</span><span class="MJXp-msubsup" id="MJXp-Span-847"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-848" style="margin-right: 0.05em;">w</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-849" style="vertical-align: -0.4em;">k</span></span></span><span class="MJXp-mtext" id="MJXp-Span-850">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-851">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-852">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-853">g</span><span class="MJXp-mrow" id="MJXp-Span-854"><span class="MJXp-mn" id="MJXp-Span-855">20</span></span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-26-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-26"> w_k \ rightarrow w'_k = w_k - \ frac {\ eta} {m} \ sum_j \ frac {\ partial C_ {X_j}} {\ partial w_k} \ tag {20} </script></p><br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-856"><span class="MJXp-msubsup" id="MJXp-Span-857"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-858" style="margin-right: 0.05em;">b</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-859" style="vertical-align: -0.4em;">l</span></span><span class="MJXp-mtext" id="MJXp-Span-860">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-861">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-862">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-863">g</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-864">h</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-865">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-866">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-867">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-868">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-869">o</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-870">w</span><span class="MJXp-msubsup" id="MJXp-Span-871"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-872" style="margin-right: 0.05em;">b</span><span class="MJXp-script-box" style="height: 1.86em; vertical-align: -0.64em;"><span class=" MJXp-script"><span><span style="margin-bottom: -0.25em;"><span class="MJXp-mo" id="MJXp-Span-874">′</span></span></span></span><span class=" MJXp-script"><span><span style="margin-top: -0.85em;"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-873">l</span></span></span></span></span></span><span class="MJXp-mo" id="MJXp-Span-875" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-msubsup" id="MJXp-Span-876"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-877" style="margin-right: 0.05em;">b</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-878" style="vertical-align: -0.4em;">l</span></span><span class="MJXp-mo" id="MJXp-Span-879" style="margin-left: 0.267em; margin-right: 0.267em;">−</span><span class="MJXp-mtext" id="MJXp-Span-880">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-881">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-882">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-883">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-884">c</span><span class="MJXp-mrow" id="MJXp-Span-885"><span class="MJXp-mtext" id="MJXp-Span-886">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-887">e</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-888">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-889">a</span></span><span class="MJXp-mrow" id="MJXp-Span-890"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-891">m</span></span><span class="MJXp-mtext" id="MJXp-Span-892">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-893">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-894">u</span><span class="MJXp-msubsup" id="MJXp-Span-895"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-896" style="margin-right: 0.05em;">m</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-897" style="vertical-align: -0.4em;">j</span></span><span class="MJXp-mtext" id="MJXp-Span-898">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-899">f</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-900">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-901">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-902">c</span><span class="MJXp-mrow" id="MJXp-Span-903"><span class="MJXp-mtext" id="MJXp-Span-904">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-905">p</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-906">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-907">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-908">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-909">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-910">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-911">l</span><span class="MJXp-msubsup" id="MJXp-Span-912"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-913" style="margin-right: 0.05em;">C</span><span class="MJXp-mrow MJXp-script" id="MJXp-Span-914" style="vertical-align: -0.4em;"><span class="MJXp-msubsup" id="MJXp-Span-915"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-916" style="margin-right: 0.05em;">X</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-917" style="vertical-align: -0.4em;">j</span></span></span></span></span><span class="MJXp-mrow" id="MJXp-Span-918"><span class="MJXp-mtext" id="MJXp-Span-919">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-920">p</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-921">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-922">r</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-923">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-924">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-925">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-926">l</span><span class="MJXp-msubsup" id="MJXp-Span-927"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-928" style="margin-right: 0.05em;">b</span><span class="MJXp-mi MJXp-italic MJXp-script" id="MJXp-Span-929" style="vertical-align: -0.4em;">l</span></span></span><span class="MJXp-mtext" id="MJXp-Span-930">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-931">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-932">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-933">g</span><span class="MJXp-mrow" id="MJXp-Span-934"><span class="MJXp-mn" id="MJXp-Span-935">21</span></span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-27-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-27"> b_l \ rightarrow b'_l = b_l - \ frac {\ eta} {m} \ sum_j \ frac {\ partial C_ {X_j}} {\ partial b_l} \ tag {21} </script></p><br><br>  di mana penjumlahan atas semua contoh pelatihan X <sub>j</sub> dalam paket mini saat ini.  Kemudian kami memilih satu paket mini acak dan mempelajarinya.  Dan seterusnya, sampai kita menghabiskan semua data pelatihan, yang disebut akhir dari era pelatihan.  Pada saat ini, kita memulai era baru pembelajaran. <br><br>  Ngomong-ngomong, perlu dicatat bahwa perjanjian mengenai penskalaan fungsi biaya dan memperbarui bobot dan offset berbeda dalam paket mini.  Dalam persamaan (6), kami meningkatkan fungsi biaya 1 / n kali.  Kadang-kadang orang menghilangkan 1 / n dengan menambahkan biaya contoh pelatihan individu, bukannya menghitung rata-rata.  Ini berguna ketika jumlah total contoh pelatihan tidak diketahui sebelumnya.  Ini bisa terjadi, misalnya, ketika data tambahan muncul secara real time.  Dengan cara yang sama, aturan pembaruan paket mini (20) dan (21) kadang-kadang menghilangkan anggota 1 / m di depan jumlah.  Secara konseptual, ini tidak mempengaruhi apa pun, karena ini setara dengan perubahan dalam kecepatan belajar η.  Namun, perlu diperhatikan ketika membandingkan berbagai karya. <br><br>  Keturunan gradien stokastik dapat dianggap sebagai pemungutan suara politik: jauh lebih mudah untuk mengambil sampel dalam bentuk paket-mini daripada menerapkan gradient descent ke sampel penuh - sama seperti jajak pendapat di pintu keluar dari situs lebih mudah untuk dilakukan daripada pemilihan penuh.  Misalnya, jika set pelatihan kami memiliki ukuran n = 60.000, seperti MNIST, dan kami membuat sampel paket mini ukuran m = 10, maka kami akan mempercepat estimasi gradien sebanyak 6000 kali!  Tentu saja, estimasi tidak akan ideal - akan ada fluktuasi statistik di dalamnya - tetapi itu tidak perlu ideal: kita hanya perlu bergerak ke arah yang mengurangi C, yang berarti bahwa kita tidak perlu menghitung gradien secara akurat.  Dalam praktiknya, penurunan gradien stokastik adalah teknik pengajaran yang umum dan kuat untuk Majelis Nasional, dan basis dari sebagian besar teknologi pengajaran yang akan kami kembangkan sebagai bagian dari buku ini. <br><br><h3>  Latihan </h3><br><ul><li>  Versi ekstrim dari gradient descent menggunakan ukuran paket-mini sama dengan 1. Yaitu, dengan input x kami memperbarui bobot dan offset kami sesuai dengan aturan wk → w ′ <sub>k</sub> = w <sub>k</sub> - η xC <sub>x</sub> / ∂w <sub>k</sub> dan b <sub>l</sub> → b ′ <sub>L</sub> = b <sub>l</sub> - η ∂C <sub>x</sub> / ∂b <sub>l</sub> .  Kemudian kami memilih contoh input pelatihan lainnya dan memperbarui bobot dan offset.  Dan sebagainya.  Prosedur ini dikenal sebagai pembelajaran online, atau tambahan.  Dalam pembelajaran online, studi NS berdasarkan pada satu salinan pelatihan dari data input pada suatu waktu (seperti orang).  Apa kelebihan dan kekurangan dari pembelajaran online dibandingkan dengan stochastic gradient descent dengan ukuran paket mini 20? </li></ul><br>  Biarkan saya mengakhiri bagian ini dengan diskusi tentang suatu topik yang kadang-kadang mengganggu orang yang pertama kali mengalami penurunan gradien.  Di NS, nilai C adalah fungsi dari banyak variabel - semua bobot dan offset - dan dalam arti tertentu, menentukan permukaan dalam ruang yang sangat multidimensi.  Orang-orang mulai berpikir: "Saya harus memvisualisasikan semua dimensi tambahan ini."  Dan mereka mulai khawatir: "Saya tidak bisa menavigasi dalam empat dimensi, belum lagi lima (atau lima juta)."  Apakah mereka memiliki kualitas istimewa yang dimiliki oleh supermathemik “asli”?  Tentu saja tidak.  Bahkan matematikawan profesional tidak dapat memvisualisasikan ruang empat dimensi dengan cukup baik - jika sama sekali.  Mereka melakukan trik, mengembangkan cara lain untuk mewakili apa yang terjadi.  Kami melakukan hal itu: kami menggunakan representasi aljabar (bukan visual) dari ΔC untuk memahami cara bergerak sehingga C berkurang.  Orang-orang yang berprestasi baik dengan sejumlah besar dimensi memiliki perpustakaan besar teknik yang sama di benak mereka;  trik aljabar kita hanyalah satu contoh.  Teknik-teknik ini mungkin tidak sesederhana yang biasa kita lakukan ketika memvisualisasikan tiga dimensi, tetapi ketika Anda membuat perpustakaan teknik yang serupa, Anda mulai berpikir dengan baik dalam dimensi yang lebih tinggi.  Saya tidak akan membahas secara terperinci, tetapi jika Anda tertarik, Anda mungkin menyukai <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">diskusi tentang beberapa teknik ini oleh</a> ahli matematika profesional yang terbiasa berpikir dalam dimensi yang lebih tinggi.  Meskipun beberapa teknik yang dibahas cukup kompleks, sebagian besar jawaban terbaik bersifat intuitif dan dapat diakses oleh semua orang. <br><br><h3>  Menerapkan jaringan untuk mengklasifikasikan angka </h3><br>  Ok, sekarang mari kita menulis sebuah program yang belajar mengenali angka tulisan tangan menggunakan stochastic gradient descent dan data pelatihan dari MNIST.  Kami akan melakukan ini dengan program pendek dalam python 2.7 yang hanya terdiri dari 74 baris!  Hal pertama yang kita butuhkan adalah mengunduh data MNIST.  Jika Anda menggunakan git, maka Anda bisa mendapatkannya dengan mengkloning repositori buku ini: <br><br> <code>git clone https://github.com/mnielsen/neural-networks-and-deep-learning.git</code> <br> <br>  Jika tidak, unduh kode <a href="">dari tautan</a> . <br><br>  Omong-omong, ketika saya menyebutkan data MNIST sebelumnya, saya mengatakan bahwa mereka dibagi menjadi 60.000 gambar pelatihan dan 10.000 gambar uji.  Ini adalah deskripsi resmi dari MNIST.  Kami akan memecah data sedikit berbeda.  Kami akan membiarkan gambar verifikasi tidak berubah, tetapi kami akan membagi set pelatihan menjadi dua bagian: 50.000 gambar, yang akan kami gunakan untuk melatih Majelis Nasional, dan masing-masing 10.000 gambar untuk konfirmasi tambahan.  Meskipun kami tidak akan menggunakannya, tetapi nanti mereka akan berguna bagi kami ketika kami akan memahami konfigurasi beberapa parameter hiper NS - kecepatan belajar, dll. - yang tidak dipilih langsung oleh algoritma kami.  Meskipun data yang menguatkan bukan bagian dari spesifikasi MNIST asli, banyak yang menggunakan MNIST dengan cara ini, dan di bidang HC penggunaan data yang menguatkan adalah umum.  Sekarang, berbicara tentang "data pelatihan MNIST," maksud saya adalah 50.000 karitnoks kami, bukan 60.000 yang asli. <br><br>  Selain data MNIST, kita juga membutuhkan pustaka python bernama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Numpy</a> untuk perhitungan aljabar linier cepat.  Jika Anda tidak memilikinya, Anda dapat mengambilnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dari tautan</a> . <br><br>  Sebelum memberi Anda seluruh program, izinkan saya menjelaskan fitur utama kode untuk NS.  Tempat sentral ditempati oleh kelas Jaringan, yang kami gunakan untuk mewakili Majelis Nasional.  Berikut adalah kode inisialisasi untuk objek Jaringan: <br><br><pre> <code class="python hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Network</span></span></span><span class="hljs-params"><span class="hljs-class"><span class="hljs-params">(object)</span></span></span><span class="hljs-class">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">__init__</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, sizes)</span></span></span><span class="hljs-function">:</span></span> self.num_layers = len(sizes) self.sizes = sizes self.biases = [np.random.randn(y, <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> sizes[<span class="hljs-number"><span class="hljs-number">1</span></span>:]] self.weights = [np.random.randn(y, x) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x, y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> zip(sizes[:<span class="hljs-number"><span class="hljs-number">-1</span></span>], sizes[<span class="hljs-number"><span class="hljs-number">1</span></span>:])]</code> </pre> <br>  Array ukuran berisi jumlah neuron di lapisan yang sesuai.  Jadi, jika kita ingin membuat objek Jaringan dengan dua neuron di lapisan pertama, tiga neuron di lapisan kedua, dan satu neuron di lapisan ketiga, maka kita akan menulis seperti ini: <br><br><pre> <code class="python hljs">net = Network([<span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>])</code> </pre> <br>  Offset dan bobot dalam objek Jaringan diinisialisasi secara acak menggunakan fungsi numpy np.random.randn, yang menghasilkan distribusi Gaussian dengan ekspektasi matematis dari 0 dan standar deviasi 1. Inisialisasi acak ini memberikan algoritma penurunan gradien stochastic kami sebagai titik awal.  Dalam bab-bab berikut, kami akan menemukan cara terbaik untuk menginisialisasi bobot dan offset, tetapi untuk saat ini cukup.  Perhatikan bahwa kode inisialisasi jaringan mengasumsikan bahwa lapisan pertama neuron akan menjadi input, dan tidak memberikan mereka bias, karena mereka hanya digunakan untuk menghitung output. <br><br>  Perhatikan juga bahwa offset dan bobot disimpan sebagai array matriks Numpy.  Sebagai contoh, net.weights [1] adalah matriks Numpy yang menyimpan bobot yang menghubungkan lapisan neuron kedua dan ketiga (ini bukan lapisan pertama dan kedua, karena dalam python penomoran elemen-elemen array berasal dari awal).  Karena akan memakan waktu terlalu lama untuk menulis net.weights [1], kami menyatakan matriks ini sebagai w.  Ini adalah suatu matriks yang <sub>wjk</sub> adalah bobot hubungan antara neuron k di lapisan kedua dan neuron ke-j di lapisan ketiga.  Urutan indeks j dan k seperti itu mungkin tampak aneh - bukankah lebih logis untuk menukar mereka?  Tetapi keuntungan besar dari rekaman tersebut adalah bahwa vektor aktivasi dari lapisan ketiga neuron diperoleh: <br><br><p></p><p><math></math><span class="MathJax_Preview" style="color: inherit;"><span class="MJXp-math MJXp-display" id="MJXp-Span-936"><span class="MJXp-msup" id="MJXp-Span-937"><span class="MJXp-mi MJXp-italic" id="MJXp-Span-938" style="margin-right: 0.05em;">a</span><span class="MJXp-mo MJXp-script" id="MJXp-Span-939" style="vertical-align: 0.5em;">′</span></span><span class="MJXp-mo" id="MJXp-Span-940" style="margin-left: 0.333em; margin-right: 0.333em;">=</span><span class="MJXp-mtext" id="MJXp-Span-941">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-942">s</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-943">i</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-944">g</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-945">m</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-946">a</span><span class="MJXp-mo" id="MJXp-Span-947" style="margin-left: 0em; margin-right: 0em;">(</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-948">w</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-949">a</span><span class="MJXp-mo" id="MJXp-Span-950" style="margin-left: 0.267em; margin-right: 0.267em;">+</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-951">b</span><span class="MJXp-mo" id="MJXp-Span-952" style="margin-left: 0em; margin-right: 0em;">)</span><span class="MJXp-mtext" id="MJXp-Span-953">&nbsp;</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-954">t</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-955">a</span><span class="MJXp-mi MJXp-italic" id="MJXp-Span-956">g</span><span class="MJXp-mrow" id="MJXp-Span-957"><span class="MJXp-mn" id="MJXp-Span-958">22</span></span></span></span><div class="MathJax_SVG_Display MathJax_SVG_Processing"><span class="MathJax_SVG" id="MathJax-Element-28-Frame" tabindex="0" style="font-size: 100%; display: inline-block;"></span></div><script type="math/tex;mode=display" id="MathJax-Element-28"> a '= \ sigma (wa + b) \ tag {22} </script></p><br><br>  Mari kita lihat persamaan yang cukup kaya ini.  a adalah vektor aktivasi lapisan kedua neuron.  Untuk mendapatkan ', kita mengalikan a dengan matriks bobot w, dan menambahkan vektor perpindahan b.  Kemudian kita menerapkan elemen σ sigmoid demi elemen ke setiap elemen vektor wa + b (ini disebut vektorisasi fungsi σ).  Mudah untuk memverifikasi bahwa persamaan (22) memberikan hasil yang sama dengan aturan (4) untuk menghitung neuron sigmoid. <br><br><h3>  Latihan </h3><br><ul><li>  Tulis persamaan (22) dalam bentuk komponen, dan pastikan itu memberikan hasil yang sama dengan aturan (4) untuk menghitung neuron sigmoid. </li></ul><br>  Dengan semua ini dalam pikiran, mudah untuk menulis kode yang menghitung output dari objek Network.  Kita mulai dengan mendefinisikan sigmoid: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sigmoid</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(z)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-number"><span class="hljs-number">1.0</span></span>/(<span class="hljs-number"><span class="hljs-number">1.0</span></span>+np.exp(-z))</code> </pre> <br>  Perhatikan bahwa ketika parameter z adalah vektor atau array Numpy, Numpy akan secara otomatis menerapkan elemen sigmoid, yaitu dalam bentuk vektor. <br><br>  Tambahkan metode propagasi langsung ke kelas Jaringan, yang mengambil dari jaringan sebagai input dan mengembalikan output yang sesuai.  Diasumsikan bahwa parameter a adalah (n, 1) Numpy ndarray, bukan vektor (n,).  Di sini n adalah jumlah neuron input.  Jika Anda mencoba menggunakan vektor (n,), Anda akan mendapatkan hasil yang aneh. <br><br>  Metode ini hanya menerapkan persamaan (22) untuk setiap lapisan: <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">feedforward</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, a)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""       "a"""</span></span><span class="hljs-string"><span class="hljs-string">" for b, w in zip(self.biases, self.weights): a = sigmoid(np.dot(w, a)+b) return a</span></span></code> </pre> <br>  Tentu saja, pada dasarnya kita dari objek Network membutuhkannya untuk dipelajari.  Untuk melakukan ini, kami akan memberi mereka metode SGD, yang mengimplementasikan penurunan gradien stokastik.  Ini kodenya.  Di beberapa tempat itu agak misterius, tetapi di bawah ini kami akan menganalisisnya lebih detail. <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">SGD</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, training_data, epochs, mini_batch_size, eta, test_data=None)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""    -    . training_data –   "(x, y)",       .       .  test_data ,          ,     .     ,    . """</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> test_data: n_test = len(test_data) n = len(training_data) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> j <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(epochs): random.shuffle(training_data) mini_batches = [ training_data[k:k+mini_batch_size] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> k <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> xrange(<span class="hljs-number"><span class="hljs-number">0</span></span>, n, mini_batch_size)] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> mini_batch <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> mini_batches: self.update_mini_batch(mini_batch, eta) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> test_data: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"Epoch {0}: {1} / {2}"</span></span>.format( j, self.evaluate(test_data), n_test) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">print</span></span> <span class="hljs-string"><span class="hljs-string">"Epoch {0} complete"</span></span>.format(j)</code> </pre> <br>  training_data adalah daftar tupel "(x, y)" yang mewakili input pelatihan dan output yang diinginkan.  Variabel epochs dan mini_batch_size adalah jumlah zaman untuk dipelajari dan ukuran paket mini yang digunakan.  eta - kecepatan belajar, η.  Jika test_data disetel, maka jaringan akan dievaluasi terhadap data verifikasi setelah setiap era, dan kemajuan saat ini akan ditampilkan.  Ini berguna untuk melacak kemajuan, tetapi secara signifikan memperlambat pekerjaan. <br><br>  Kode kerjanya seperti ini.  Di setiap era, ia mulai dengan secara tidak sengaja mencampurkan data pelatihan, dan kemudian memecahnya menjadi paket mini dengan ukuran yang tepat.  Ini adalah cara mudah untuk membuat sampel data pelatihan.  Kemudian untuk setiap mini_batch kami menerapkan satu langkah gradient descent.  Ini dilakukan oleh kode self.update_mini_batch (mini_batch, eta), yang memperbarui bobot dan offset jaringan menurut satu iterasi dari penurunan gradien menggunakan hanya data pelatihan di mini_batch.  Berikut adalah kode untuk metode update_mini_batch: <br><br><pre> <code class="python hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">update_mini_batch</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, mini_batch, eta)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-string"><span class="hljs-string">"""    ,          -. mini_batch –    (x, y),  eta –  ."""</span></span> nabla_b = [np.zeros(b.shape) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> b <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.biases] nabla_w = [np.zeros(w.shape) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> self.weights] <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> x, y <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> mini_batch: delta_nabla_b, delta_nabla_w = self.backprop(x, y) nabla_b = [nb+dnb <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> nb, dnb <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> zip(nabla_b, delta_nabla_b)] nabla_w = [nw+dnw <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> nw, dnw <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> zip(nabla_w, delta_nabla_w)] self.weights = [w-(eta/len(mini_batch))*nw <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> w, nw <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> zip(self.weights, nabla_w)] self.biases = [b-(eta/len(mini_batch))*nb <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> b, nb <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> zip(self.biases, nabla_b)]</code> </pre> <br>  Sebagian besar pekerjaan dilakukan oleh garis. <br><br><pre> <code class="python hljs"> delta_nabla_b, delta_nabla_w = self.backprop(x, y)</code> </pre> <br>  Ini memanggil algoritma backpropagation - cara cepat untuk menghitung gradien dari fungsi biaya.  Jadi, update_mini_batch cukup menghitung gradien ini untuk setiap contoh pelatihan dari mini_batch, dan kemudian memperbarui self.weights dan self.biases. <br><br>  Sejauh ini, saya tidak akan menunjukkan kode untuk self.backprop.  Kita akan belajar tentang backpropagation di bab selanjutnya, dan akan ada kode self.backprop.  Untuk saat ini, anggaplah berperilaku seperti yang dinyatakan, mengembalikan gradien yang sesuai untuk biaya yang terkait dengan contoh pelatihan x. <br><br>  Mari kita lihat keseluruhan program, termasuk komentar penjelasan.  Dengan pengecualian fungsi self.backprop, program berbicara sendiri - pekerjaan utama dilakukan oleh self.SGD dan self.update_mini_batch.  Metode self.backprop menggunakan beberapa fungsi tambahan untuk menghitung gradien, yaitu sigmoid_prime, yang menghitung turunan dari sigmoid, dan self.cost_derivative, yang tidak akan saya jelaskan di sini.  Anda bisa mendapatkan ide tentang mereka dengan melihat kode dan komentar.  Dalam bab selanjutnya kita akan membahasnya secara lebih rinci.  Ingatlah bahwa meskipun programnya tampak panjang, sebagian besar kode adalah komentar yang membuatnya lebih mudah untuk dipahami.  Bahkan, program itu sendiri hanya terdiri dari 74 kode non-baris - tidak kosong dan tidak komentar.  Semua <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kode tersedia di GitHub</a> . <br><br><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">""" network.py ~~~~~~~~~~           .      .     ,    .   ,       . """</span></span> <span class="hljs-comment"><span class="hljs-comment">####  #   import random #   import numpy as np class Network(object): def __init__(self, sizes): """  sizes      .  ,      Network      ,     ,     ,    ,  [2, 3, 1].               0    1. ,      ,       ,        . """ self.num_layers = len(sizes) self.sizes = sizes self.biases = [np.random.randn(y, 1) for y in sizes[1:]] self.weights = [np.random.randn(y, x) for x, y in zip(sizes[:-1], sizes[1:])] def feedforward(self, a): """   ,  ``a`` -  .""" for b, w in zip(self.biases, self.weights): a = sigmoid(np.dot(w, a)+b) return a def SGD(self, training_data, epochs, mini_batch_size, eta, test_data=None): """    -    . training_data –   "(x, y)",       .       .  test_data ,          ,     .     ,    . """ if test_data: n_test = len(test_data) n = len(training_data) for j in xrange(epochs): random.shuffle(training_data) mini_batches = [ training_data[k:k+mini_batch_size] for k in xrange(0, n, mini_batch_size)] for mini_batch in mini_batches: self.update_mini_batch(mini_batch, eta) if test_data: print "Epoch {0}: {1} / {2}".format( j, self.evaluate(test_data), n_test) else: print "Epoch {0} complete".format(j) def update_mini_batch(self, mini_batch, eta): """    ,          -. mini_batch –    (x, y),  eta –  .""" nabla_b = [np.zeros(b.shape) for b in self.biases] nabla_w = [np.zeros(w.shape) for w in self.weights] for x, y in mini_batch: delta_nabla_b, delta_nabla_w = self.backprop(x, y) nabla_b = [nb+dnb for nb, dnb in zip(nabla_b, delta_nabla_b)] nabla_w = [nw+dnw for nw, dnw in zip(nabla_w, delta_nabla_w)] self.weights = [w-(eta/len(mini_batch))*nw for w, nw in zip(self.weights, nabla_w)] self.biases = [b-(eta/len(mini_batch))*nb for b, nb in zip(self.biases, nabla_b)] def backprop(self, x, y): """  ``(nabla_b, nabla_w)``,      C_x. ``nabla_b``  ``nabla_w`` -    numpy,   ``self.biases`` and ``self.weights``.""" nabla_b = [np.zeros(b.shape) for b in self.biases] nabla_w = [np.zeros(w.shape) for w in self.weights] #   activation = x activations = [x] #      zs = [] #     z- for b, w in zip(self.biases, self.weights): z = np.dot(w, activation)+b zs.append(z) activation = sigmoid(z) activations.append(activation) #   delta = self.cost_derivative(activations[-1], y) * \ sigmoid_prime(zs[-1]) nabla_b[-1] = delta nabla_w[-1] = np.dot(delta, activations[-2].transpose()) """ l      ,      . l = 1    , l = 2 – ,   .    ,   python      .""" for l in xrange(2, self.num_layers): z = zs[-l] sp = sigmoid_prime(z) delta = np.dot(self.weights[-l+1].transpose(), delta) * sp nabla_b[-l] = delta nabla_w[-l] = np.dot(delta, activations[-l-1].transpose()) return (nabla_b, nabla_w) def evaluate(self, test_data): """    ,      .    –          .""" test_results = [(np.argmax(self.feedforward(x)), y) for (x, y) in test_data] return sum(int(x == y) for (x, y) in test_results) def cost_derivative(self, output_activations, y): """    ( C_x /  a)   .""" return (output_activations-y) ####   def sigmoid(z): """.""" return 1.0/(1.0+np.exp(-z)) def sigmoid_prime(z): """ .""" return sigmoid(z)*(1-sigmoid(z))</span></span></code> </pre> <br>  Seberapa baik program mengenali angka tulisan tangan?  Mari kita mulai dengan memuat data MNIST.  Kami akan melakukan ini menggunakan program pembantu kecil mnist_loader.py, yang akan saya jelaskan di bawah ini.  Jalankan perintah berikut di shell python: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> mnist_loader &gt;&gt;&gt; training_data, validation_data, test_data = \ ... mnist_loader.load_data_wrapper()</code> </pre> <br>  Ini, tentu saja, dapat dilakukan dalam program terpisah, tetapi jika Anda bekerja secara paralel dengan sebuah buku, itu akan lebih mudah. <br><br>  Setelah mengunduh data MNIST, atur jaringan 30 neuron tersembunyi.  Kami akan melakukan ini setelah mengimpor program yang dijelaskan di atas, yang disebut jaringan: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> network &gt;&gt;&gt; net = network.Network([<span class="hljs-number"><span class="hljs-number">784</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>])</code> </pre> <br>  Akhirnya, kami menggunakan keturunan gradien stokastik untuk pelatihan data pelatihan selama 30 era, dengan ukuran paket mini 10, dan kecepatan belajar η = 3.0: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>net.SGD(training_data, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span>, test_data=test_data)</code> </pre> <br>  Jika Anda mengeksekusi kode secara paralel dengan membaca buku, perlu diketahui bahwa akan membutuhkan beberapa menit untuk mengeksekusi.  Saya sarankan Anda memulai semuanya, terus membaca, dan secara berkala memeriksa apa yang dihasilkan oleh program.  Jika Anda terburu-buru, Anda dapat mengurangi jumlah era dengan mengurangi jumlah neuron tersembunyi, atau hanya menggunakan sebagian data pelatihan.  Kode kerja terakhir akan bekerja lebih cepat: skrip python ini dirancang untuk membuat Anda memahami cara kerja jaringan, dan tidak berkinerja tinggi!  Dan, tentu saja, setelah pelatihan, jaringan dapat bekerja dengan sangat cepat di hampir semua platform komputasi.  Misalnya, ketika kami mengajarkan jaringan pilihan bobot dan offset yang baik, jaringan dapat dengan mudah dipindahkan untuk berfungsi pada JavaScript di peramban web, atau sebagai aplikasi asli pada perangkat seluler.  Dalam kasus apa pun, kesimpulan yang kira-kira sama dibuat oleh program yang melatih jaringan saraf.  Dia menulis jumlah gambar uji yang diakui dengan benar setelah setiap era pelatihan.  Seperti yang Anda lihat, bahkan setelah satu era, ia mencapai akurasi 9.129 dari 10.000, dan jumlah ini terus bertambah: <br><br> <code>Epoch 0: 9129 / 10000 <br> Epoch 1: 9295 / 10000 <br> Epoch 2: 9348 / 10000 <br> ... <br> Epoch 27: 9528 / 10000 <br> Epoch 28: 9542 / 10000 <br> Epoch 29: 9534 / 10000</code> <br> <br>  Ternyata jaringan terlatih memberikan persentase klasifikasi yang benar sekitar 95 - 95,42% maksimal!  Upaya pertama yang cukup menjanjikan.  Saya memperingatkan Anda bahwa kode Anda tidak harus menghasilkan hasil yang persis sama, karena kami menginisialisasi jaringan dengan bobot dan offset acak.  Untuk bab ini, saya telah memilih yang terbaik dari tiga upaya. <br><br>  Mari kita mulai kembali percobaan dengan mengubah jumlah neuron tersembunyi menjadi 100. Seperti sebelumnya, jika Anda menjalankan kode pada saat yang sama dengan membaca, perlu diketahui bahwa itu membutuhkan banyak waktu (pada mesin saya, setiap era membutuhkan beberapa puluh detik), jadi lebih baik membaca secara paralel dengan eksekusi kode. <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>net = network.Network([<span class="hljs-number"><span class="hljs-number">784</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>]) &gt;&gt;&gt; net.SGD(training_data, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span>, test_data=test_data)</code> </pre> <br>  Secara alami, ini meningkatkan hasilnya menjadi 96,59%.  Setidaknya dalam kasus ini, menggunakan lebih banyak neuron tersembunyi membantu mendapatkan hasil yang lebih baik. <br><br>  Umpan balik dari pembaca menunjukkan bahwa hasil percobaan ini sangat bervariasi, dan beberapa hasil pembelajaran jauh lebih buruk.  Menggunakan teknik dari Bab 3 untuk secara serius mengurangi keragaman efisiensi kerja dari satu proses ke yang lain. <br><br>  Tentu saja, untuk mencapai akurasi seperti itu, saya harus memilih sejumlah era untuk belajar, ukuran paket mini dan kecepatan belajar η.  Seperti yang saya sebutkan di atas, mereka disebut hyperparameters dari Majelis Nasional kami - untuk membedakan mereka dari parameter sederhana (bobot dan offset) yang disesuaikan oleh algoritma selama pelatihan.  Jika kita memilih hyperparameters dengan buruk, kita akan mendapatkan hasil yang buruk.  Misalkan, misalnya, bahwa kami telah memilih tingkat pembelajaran η = 0,001: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>net = network.Network([<span class="hljs-number"><span class="hljs-number">784</span></span>, <span class="hljs-number"><span class="hljs-number">100</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>]) &gt;&gt;&gt; net.SGD(training_data, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">0.001</span></span>, test_data=test_data)</code> </pre> <br>  Hasilnya jauh lebih mengesankan: <br><br> <code>Epoch 0: 1139 / 10000 <br> Epoch 1: 1136 / 10000 <br> Epoch 2: 1135 / 10000 <br> ... <br> Epoch 27: 2101 / 10000 <br> Epoch 28: 2123 / 10000 <br> Epoch 29: 2142 / 10000</code> <br> <br>  Namun, Anda dapat melihat bahwa efisiensi jaringan perlahan-lahan tumbuh seiring waktu.  Ini menunjukkan bahwa Anda dapat mencoba meningkatkan kecepatan belajar, misalnya, menjadi 0,01.  Dalam hal ini, hasilnya akan lebih baik, yang menunjukkan kebutuhan untuk lebih meningkatkan kecepatan (jika perubahan memperbaiki situasi, ubah lebih lanjut!).  Jika Anda melakukan ini beberapa kali, kami akhirnya akan tiba di η = 1.0 (dan kadang-kadang bahkan 3.0), yang dekat dengan eksperimen kami sebelumnya.  Jadi, meskipun pada awalnya kami memilih hiperparameter yang buruk, setidaknya kami mengumpulkan informasi yang cukup untuk dapat meningkatkan pilihan parameter kami. <br><br>  Secara umum, debugging NA adalah masalah yang rumit.  Ini khususnya terjadi ketika pilihan hiperparameter awal menghasilkan hasil yang tidak melebihi noise acak.  Misalkan kita mencoba menggunakan arsitektur 30 neuron yang berhasil, tetapi ubah kecepatan belajar menjadi 100.0: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">&gt;&gt;&gt; </span></span>net = network.Network([<span class="hljs-number"><span class="hljs-number">784</span></span>, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>]) &gt;&gt;&gt; net.SGD(training_data, <span class="hljs-number"><span class="hljs-number">30</span></span>, <span class="hljs-number"><span class="hljs-number">10</span></span>, <span class="hljs-number"><span class="hljs-number">100.0</span></span>, test_data=test_data)</code> </pre> <br>  Pada akhirnya, ternyata kami terlalu jauh dan terlalu cepat: <br><br> <code>Epoch 0: 1009 / 10000 <br> Epoch 1: 1009 / 10000 <br> Epoch 2: 1009 / 10000 <br> Epoch 3: 1009 / 10000 <br> ... <br> Epoch 27: 982 / 10000 <br> Epoch 28: 982 / 10000 <br> Epoch 29: 982 / 10000</code> <br> <br>  Sekarang bayangkan kita sedang mendekati tugas ini untuk pertama kalinya.  Tentu saja, kita tahu dari percobaan awal bahwa itu benar untuk mengurangi kecepatan belajar.  Tetapi jika kita mendekati tugas ini untuk pertama kalinya, kita tidak akan memiliki output yang dapat membawa kita ke solusi yang tepat.  Bisakah kita mulai berpikir bahwa mungkin kita telah memilih parameter awal yang salah untuk bobot dan offset, dan sulit bagi jaringan untuk belajar?  Atau mungkin kita tidak memiliki data pelatihan yang cukup untuk mendapatkan hasil yang bermakna?  Mungkin kita tidak menunggu era yang cukup?  Mungkin jaringan saraf dengan arsitektur seperti itu tidak bisa belajar mengenali angka tulisan tangan?  Mungkin kecepatan belajarnya terlalu lambat?  Saat Anda pertama kali mendekati tugas, Anda tidak pernah memiliki kepercayaan diri. <br><br>  Dari sini perlu dipelajari pelajaran bahwa men-debug NS bukan tugas yang sepele, dan ini, seperti pemrograman biasa, adalah bagian dari seni.  Anda harus mempelajari seni debug ini untuk mendapatkan hasil yang baik dari NS.  Secara umum, kita perlu mengembangkan heuristik untuk memilih hyperparameter dan arsitektur yang bagus.  Kami akan membahas ini secara rinci dalam buku ini, termasuk bagaimana saya memilih hyperparameters di atas. <br><br><h3>  Latihan </h3><br><ul><li>  Cobalah untuk membuat jaringan hanya dua lapisan - input dan output, tanpa tersembunyi - masing-masing dengan 784 dan 10 neuron.  Melatih jaringan dengan penurunan gradien stokastik.  Apa akurasi klasifikasi yang Anda dapatkan? </li></ul><br>  Saya sebelumnya melewatkan detail memuat data MNIST.  Itu terjadi cukup sederhana.  Ini adalah kode untuk melengkapi gambar.  Struktur data dijelaskan dalam komentar - semuanya sederhana, tupel dan larik objek Numpy ndarray (jika Anda tidak terbiasa dengan objek tersebut, anggap sebagai vektor). <br><br><pre> <code class="python hljs"><span class="hljs-string"><span class="hljs-string">""" mnist_loader ~~~~~~~~~~~~      MNIST.       ``load_data``  ``load_data_wrapper``.  , ``load_data_wrapper`` -  ,     . """</span></span> <span class="hljs-comment"><span class="hljs-comment">####  #  import cPickle import gzip #  import numpy as np def load_data(): """  MNIST   ,  ,    . ``training_data``      .    .  numpy ndarray  50 000 .   –     numpy ndarray  784 ,  28 * 28 = 784    MNIST.  –  numpy ndarray  50 000 .   –   0  9   ,    . ``validation_data``  ``test_data`` ,    10 000 .    ,           ``training_data``.    - ``load_data_wrapper()``. """ f = gzip.open('../data/mnist.pkl.gz', 'rb') training_data, validation_data, test_data = cPickle.load(f) f.close() return (training_data, validation_data, test_data) def load_data_wrapper(): """ ,  ``(training_data, validation_data, test_data)``.   ``load_data``,         .  , ``training_data`` -    50 000    , ``(x, y)``. ``x`` -  784- numpy.ndarray,   . ``y`` -  10- numpy.ndarray,   ,     ``x``. ``validation_data``  ``test_data`` -  ,   10 000    , ``(x, y)``. ``x`` -  784- numpy.ndarray,   ,  ``y`` -   ,  ,   ( ),  ``x``. ,  ,           .         .""" tr_d, va_d, te_d = load_data() training_inputs = [np.reshape(x, (784, 1)) for x in tr_d[0]] training_results = [vectorized_result(y) for y in tr_d[1]] training_data = zip(training_inputs, training_results) validation_inputs = [np.reshape(x, (784, 1)) for x in va_d[0]] validation_data = zip(validation_inputs, va_d[1]) test_inputs = [np.reshape(x, (784, 1)) for x in te_d[0]] test_data = zip(test_inputs, te_d[1]) return (training_data, validation_data, test_data) def vectorized_result(j): """ 10-    1.0   j     .      (0..9)     .""" e = np.zeros((10, 1)) e[j] = 1.0 return e</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya mengatakan bahwa program kami mencapai hasil yang cukup baik. </font><font style="vertical-align: inherit;">Apa artinya ini? </font><font style="vertical-align: inherit;">Bagus dibandingkan dengan apa? </font><font style="vertical-align: inherit;">Adalah bermanfaat untuk mendapatkan hasil dari beberapa tes dasar yang sederhana yang dengannya Anda dapat membuat perbandingan untuk memahami apa arti "hasil yang baik". </font><font style="vertical-align: inherit;">Level dasar yang paling sederhana, tentu saja, adalah tebakan acak. </font><font style="vertical-align: inherit;">Ini dapat dilakukan pada sekitar 10% kasus. </font><font style="vertical-align: inherit;">Dan kami menunjukkan hasil yang jauh lebih baik! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bagaimana dengan tingkat dasar yang kurang sepele? </font><font style="vertical-align: inherit;">Mari kita lihat seberapa gelap gambarnya. </font><font style="vertical-align: inherit;">Misalnya, gambar 2 biasanya akan lebih gelap daripada gambar 1, hanya karena memiliki lebih banyak piksel gelap, seperti terlihat pada contoh di bawah ini:</font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/f59/0de/5b7/f590de5b7bc6581b9854b2013e5013de.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Oleh karena itu kita dapat menghitung kegelapan rata-rata untuk setiap digit dari 0 hingga 9. Ketika kita mendapatkan gambar baru, kita menghitung kegelapannya, dan kami menduga itu menunjukkan angka dengan kegelapan rata-rata terdekat. Ini adalah prosedur sederhana yang mudah diprogram, jadi saya tidak akan menulis kode - jika tertarik, itu ada </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">di GitHub</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . Tapi ini adalah peningkatan yang serius dibandingkan dengan tebakan acak - kode dengan benar mengenali 2.225 dari 10.000 gambar, yaitu memberikan akurasi 22,25%.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tidak sulit untuk menemukan ide-ide lain yang mencapai akurasi dalam kisaran 20 hingga 50%. Setelah bekerja sedikit lagi, Anda dapat melebihi 50%. Tetapi untuk mencapai akurasi yang jauh lebih besar, lebih baik menggunakan algoritma MO otoritatif. Mari kita coba salah satu algoritma paling terkenal, metode vektor dukungan atau SVM. Jika Anda tidak terbiasa dengan SVM, jangan khawatir, kami tidak perlu memahami detail ini. Kami hanya menggunakan pustaka python bernama scikit-learn, yang menyediakan antarmuka sederhana ke pustaka C cepat untuk SVM, yang dikenal sebagai </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">LIBSVM</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika kita menjalankan classifier SVM scikit-belajar pada pengaturan default, maka kita mendapatkan klasifikasi yang benar dari 9.435 dari 10.000 (kode </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">tersedia di tautan</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">) Ini sudah merupakan peningkatan besar atas pendekatan naif mengklasifikasikan gambar berdasarkan kegelapan. Ini berarti SVM bekerja sebaik NS kami, hanya sedikit lebih buruk. Dalam bab-bab berikut kita akan berkenalan dengan teknik-teknik baru yang akan memungkinkan kita untuk meningkatkan NS kita sehingga mereka jauh mengungguli SVM.</font></font><br><br>  Tapi itu belum semuanya.<font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasil 9 435 dari 10.000 dari scikit-learn ditentukan untuk pengaturan default. SVM memiliki banyak parameter yang dapat disetel, dan Anda dapat mencari parameter yang meningkatkan hasil ini. Saya tidak akan merinci, mereka dapat dibaca dalam </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">artikel oleh</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Andreas Muller. Dia menunjukkan bahwa dengan melakukan pekerjaan untuk mengoptimalkan parameter, dimungkinkan untuk mencapai akurasi minimal 98,5%. Dengan kata lain, SVM yang disetel dengan baik hanya membuat satu digit dari 70 kesalahan. Hasil yang bagus! Bisakah NA mencapai lebih banyak? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ternyata mereka bisa. Saat ini, NS yang telah disesuaikan dengan baik menyalip teknologi lain yang dikenal dalam solusi MNIST, termasuk SVM. </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rekam untuk 2013</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">diklasifikasikan dengan benar 9,979 dari 10.000 gambar. Dan kita akan melihat sebagian besar teknologi yang digunakan untuk ini dalam buku ini. Tingkat akurasi ini dekat dengan manusia, dan mungkin bahkan melebihi itu, karena beberapa gambar dari MNIST sulit diuraikan bahkan untuk manusia, misalnya: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/def/4b3/b37/def4b3b37d8d510615d60a372a06ad47.png"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya pikir Anda akan setuju bahwa sulit untuk mengklasifikasikannya! Dengan gambar-gambar seperti itu dalam dataset MNIST, mengejutkan bahwa NS dapat dengan benar mengenali semua gambar dari 10.000, kecuali 21. Biasanya, programmer menganggap bahwa algoritma yang kompleks diperlukan untuk menyelesaikan tugas yang sedemikian rumit. Tetapi bahkan NS sedang </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">bekerja</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">pemegang catatan menggunakan algoritma yang cukup sederhana, yang merupakan variasi kecil dari yang kami periksa dalam bab ini. </font><font style="vertical-align: inherit;">Semua kompleksitas muncul secara otomatis selama pelatihan berdasarkan data pelatihan. </font><font style="vertical-align: inherit;">Dalam arti tertentu, moral hasil kami dan yang terkandung dalam karya yang lebih kompleks adalah untuk beberapa tugas</font></font><br><blockquote><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> algoritme kompleks ≤ algoritma pelatihan sederhana + data pelatihan yang baik </font></font></blockquote><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk pembelajaran yang mendalam </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Meskipun jaringan kami menunjukkan kinerja yang mengesankan, itu dicapai dengan cara yang misterius. </font><font style="vertical-align: inherit;">Bobot dan jaringan pencampuran terdeteksi secara otomatis. </font><font style="vertical-align: inherit;">Jadi, kami tidak memiliki penjelasan siap pakai tentang bagaimana jaringan melakukan apa yang dilakukannya. </font><font style="vertical-align: inherit;">Apakah ada cara untuk memahami prinsip dasar klasifikasi dengan jaringan angka tulisan tangan? </font><font style="vertical-align: inherit;">Dan apakah mungkin, mengingat mereka, untuk meningkatkan hasilnya?</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kami merumuskan kembali pertanyaan-pertanyaan ini dengan lebih ketat: mari kita asumsikan bahwa dalam beberapa dekade NS akan berubah menjadi kecerdasan buatan (AI). Akankah kita mengerti bagaimana AI ini bekerja? Mungkin jaringan akan tetap tidak dapat dipahami oleh kami, dengan bobot dan offset mereka, karena mereka ditugaskan secara otomatis. Pada tahun-tahun awal penelitian AI, orang berharap bahwa mencoba membuat AI juga akan membantu kita memahami prinsip-prinsip yang mendasari kecerdasan, dan mungkin bahkan karya otak manusia. Namun, pada akhirnya mungkin kita tidak akan memahami otak atau cara kerja AI! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk mengatasi masalah ini, mari kita ingat interpretasi neuron buatan yang saya berikan di awal bab ini - bahwa ini adalah cara untuk menimbang bukti. Misalkan kita ingin menentukan apakah wajah seseorang ada pada gambar:</font></font><br><br><img src="https://habrastorage.org/webt/up/2e/af/up2eafnwrrpph5xdai4oapmgw8m.jpeg"><br><br><img src="https://habrastorage.org/webt/tu/8i/an/tu8ianduufnfebbjnqaibtzskyy.jpeg"><br><br><img src="https://habrastorage.org/webt/wf/tj/4j/wftj4j86hzytgwyypbw_eqk0jte.jpeg"><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah ini dapat didekati dengan cara yang sama seperti pengenalan tulisan tangan: menggunakan piksel gambar sebagai input untuk NS, dan output dari NS akan menjadi satu neuron yang akan mengatakan, "Ya, ini wajah", atau "Tidak, ini bukan wajah ". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Misalkan kita melakukan ini, tetapi tanpa menggunakan algoritma pembelajaran. Kami akan mencoba membuat jaringan secara manual, memilih bobot dan offset yang sesuai. Bagaimana kita bisa mendekati ini? Untuk sesaat, lupa tentang Majelis Nasional, kita dapat membagi tugas menjadi subtugas: apakah gambar mata ada di sudut kiri atas? Apakah ada mata di sudut kanan atas? Apakah ada hidung tengah? Apakah ada mulut di tengah? Apakah ada rambut di bagian atas?</font></font> Dan sebagainya. <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika jawaban atas beberapa pertanyaan ini positif, atau bahkan "mungkin ya," maka kami menyimpulkan bahwa gambar tersebut mungkin memiliki wajah. Sebaliknya, jika jawabannya tidak, maka mungkin tidak ada orang.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ini, tentu saja, adalah perkiraan heuristik, dan memiliki banyak kekurangan. Mungkin ini adalah pria botak, dan dia tidak memiliki rambut. Mungkin kita hanya bisa melihat sebagian wajah, atau wajah miring, sehingga beberapa bagian wajah tertutup. Namun demikian, heuristik menunjukkan bahwa jika kita dapat menyelesaikan submasalah dengan bantuan jaringan saraf, maka mungkin kita dapat membuat NS untuk pengenalan wajah dengan menggabungkan jaringan untuk subtugas. Berikut ini adalah arsitektur yang memungkinkan dari jaringan di mana subnet ditunjukkan oleh persegi panjang. Ini bukan pendekatan yang sepenuhnya realistis untuk memecahkan masalah pengenalan wajah: diperlukan untuk membantu kita secara intuitif memahami kerja jaringan saraf. </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/61b/dd0/ef6/61bdd0ef651ebc30afff87ed56204bd0.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dalam persegi panjang ada subtugas: apakah gambar mata ada di sudut kiri atas? Apakah ada mata di sudut kanan atas? Apakah ada hidung tengah? Apakah ada mulut di tengah? Apakah ada rambut di bagian atas? Dan sebagainya.</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada kemungkinan bahwa subnet juga dapat dibongkar menjadi komponen. Ambil pertanyaan tentang memiliki mata di sudut kiri atas. Ini dapat dibedakan menjadi pertanyaan seperti: "Apakah ada alis?", "Apakah ada bulu mata?", "Apakah ada murid?" dan sebagainya. Tentu saja, pertanyaan harus berisi informasi tentang lokasi - "Apakah alis terletak di kiri atas, di atas murid?", Dan seterusnya - tetapi mari kita sederhanakan untuk sekarang. Oleh karena itu, jaringan yang menjawab pertanyaan tentang keberadaan mata dapat dibongkar menjadi komponen: </font></font><br><br><img src="https://habrastorage.org/getpro/habr/post_images/d87/871/6ff/d878716ff0ecad83cfa5b0e9c54a866e.png"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">"Apakah ada alis?", "Apakah ada bulu mata?", "Apakah ada murid?"</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pertanyaan-pertanyaan ini selanjutnya dapat dipecah menjadi pertanyaan-pertanyaan kecil, dalam langkah-langkah melalui banyak lapisan. Sebagai hasilnya, kami akan bekerja dengan subnet yang menjawab pertanyaan sederhana sedemikian rupa sehingga mudah dibongkar pada tingkat piksel. Pertanyaan-pertanyaan ini mungkin menyangkut, misalnya, ada tidaknya bentuk-bentuk sederhana di tempat-tempat gambar tertentu. Neuron individu yang terkait dengan piksel akan dapat meresponsnya.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hasilnya adalah jaringan yang memecah pertanyaan yang sangat kompleks - apakah seseorang ada dalam gambar - menjadi pertanyaan yang sangat sederhana yang dapat dijawab pada tingkat piksel individu. Dia akan melakukan ini melalui serangkaian banyak lapisan, di mana lapisan pertama menjawab pertanyaan yang sangat sederhana dan spesifik tentang gambar, dan yang terakhir menciptakan hierarki konsep yang lebih kompleks dan abstrak. Jaringan dengan struktur multilayer - dua atau lebih lapisan tersembunyi - disebut deep neural networks (GNS).</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tentu saja, saya tidak berbicara tentang cara melakukan subnetting rekursif ini. Pasti tidak praktis untuk memilih bobot dan offset secara manual. Kami ingin menggunakan algoritma pelatihan sehingga jaringan secara otomatis mempelajari bobot dan offset - dan melaluinya hierarki konsep - berdasarkan data pelatihan. Para peneliti pada 1980-an dan 1990-an mencoba menggunakan keturunan gradien stokastik dan backpropagation untuk melatih GNS. Sayangnya, dengan pengecualian beberapa arsitektur khusus, mereka tidak berhasil. Jaringan dilatih, tetapi sangat lambat, dan dalam praktiknya terlalu lambat untuk digunakan entah bagaimana.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sejak 2006, beberapa teknologi telah dikembangkan untuk melatih STS. Mereka didasarkan pada keturunan gradien stokastik dan propagasi kembali, tetapi mereka juga mengandung ide-ide baru. Mereka diizinkan untuk melatih jaringan yang lebih dalam - saat ini orang diam-diam melatih jaringan dengan 5-10 lapisan. Dan ternyata mereka memecahkan banyak masalah jauh lebih baik daripada NS dangkal, yaitu jaringan dengan satu lapisan tersembunyi. Alasannya, tentu saja, adalah bahwa STS dapat menciptakan hierarki konsep yang kompleks. Ini mirip dengan bagaimana bahasa pemrograman menggunakan skema modular dan ide-ide abstraksi sehingga mereka dapat membuat program komputer yang kompleks. Untuk membandingkan NS yang mendalam dengan NS yang dangkal adalah kira-kira bagaimana membandingkan bahasa pemrograman yang dapat membuat panggilan fungsi dengan bahasa yang tidak. Abstraksi di NS tidak terlihat seperti dalam bahasa pemrograman,tetapi memiliki kepentingan yang sama.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id456738/">https://habr.com/ru/post/id456738/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id456722/index.html">Resep PostgreSQL: Penjadwal Tugas Asinkron</a></li>
<li><a href="../id456724/index.html">5 cara yang sangat sederhana untuk mempercepat aplikasi VueJS Anda secara signifikan</a></li>
<li><a href="../id456730/index.html">Pesan "{Anda Tidak Tahu JS} Jenis dan Konstruksi Grammar"</a></li>
<li><a href="../id456732/index.html">Untuk menjadi seorang mentor</a></li>
<li><a href="../id456736/index.html">Resep PostgreSQL: cURL: dapatkan, kirim dan ... email</a></li>
<li><a href="../id456740/index.html">Perendaman dalam jaringan saraf convolutional. Bagian 5/1 - 9</a></li>
<li><a href="../id456744/index.html">10 masalah yang saya pecahkan dengan pengingat pada ponsel cerdas saya</a></li>
<li><a href="../id456746/index.html">Data besar - tanggung jawab besar, stres besar dan uang besar</a></li>
<li><a href="../id456748/index.html">Thermal printer 2003 dari pasar loak: apa yang bisa dilakukan di 2019?</a></li>
<li><a href="../id456754/index.html">GitOps: membandingkan metode Tarik dan Dorong</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>