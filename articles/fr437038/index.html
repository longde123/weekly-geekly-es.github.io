<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§µüèª ‚ôäÔ∏è ‚õµÔ∏è Traduction du guide de l'API Benjamin Winterberg Stream üòô „ÄΩÔ∏è üöÄ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour, Habr! Je vous pr√©sente la traduction de l'article " Java 8 Stream Tutorial ". 

 Ce tutoriel, bas√© sur des exemples de code, fournit une vue ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Traduction du guide de l'API Benjamin Winterberg Stream</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/437038/">  Bonjour, Habr!  Je vous pr√©sente la traduction de l'article " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Java 8 Stream Tutorial</a> ". <br><br>  Ce tutoriel, bas√© sur des exemples de code, fournit une vue d'ensemble compl√®te des flux en Java 8. Lorsque j'ai introduit l'API Stream pour la premi√®re fois, mon nom m'a intrigu√© car il est tr√®s en accord avec InputStream et OutputStream du package java.io;  Cependant, les threads en Java 8 sont quelque chose de compl√®tement diff√©rent. <a name="habracut"></a>  Les threads sont des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">monades</a> qui jouent un r√¥le important dans le d√©veloppement de la programmation fonctionnelle en Java. <br><blockquote>  En programmation fonctionnelle, une monade est une structure qui repr√©sente un calcul sous la forme d'une cha√Æne d'√©tapes successives.  Le type et la structure de la monade d√©terminent la cha√Æne d'op√©rations, dans notre cas, une s√©quence de m√©thodes avec des fonctions int√©gr√©es d'un type donn√©. </blockquote>  Ce didacticiel vous apprendra √† travailler avec des flux et vous montrera comment g√©rer les diff√©rentes m√©thodes disponibles dans l'API Stream.  Nous analyserons l'ordre des op√©rations et verrons comment la s√©quence de m√©thodes dans la cha√Æne affecte les performances.  Apprenez √† <code>flatMap</code> m√©thodes puissantes de l'API Stream telles que <code>reduce</code> , <code>collect</code> et <code>flatMap</code> .  √Ä la fin du manuel, nous ferons attention au travail parall√®le avec les flux. <br><br>  Si vous ne vous sentez pas libre de travailler avec des expressions lambda, des interfaces fonctionnelles et des m√©thodes de r√©f√©rence, il vous sera utile de vous familiariser avec <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mon guide des innovations en Java 8</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">traduction</a> en Habr√©), puis de revenir √† l'√©tude des flux. <br><br><h3>  Fonctionnement des threads </h3><br>  Un flux repr√©sente une s√©quence d'√©l√©ments et fournit diverses m√©thodes pour effectuer des calculs sur ces √©l√©ments: <br><br><pre> <code class="java hljs">List&lt;String&gt; myList = Arrays.asList(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"c2"</span></span>, <span class="hljs-string"><span class="hljs-string">"c1"</span></span>); myList .stream() .filter(s -&gt; s.startsWith(<span class="hljs-string"><span class="hljs-string">"c"</span></span>)) .map(String::toUpperCase) .sorted() .forEach(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// C1 // C2</span></span></code> </pre> <br>  Les modes de flux sont <i>interm√©diaires</i> (interm√©diaires) et <i>terminaux</i> (terminaux).  Les m√©thodes interm√©diaires renvoient un flux, ce qui permet √† plusieurs de ces m√©thodes d'√™tre appel√©es s√©quentiellement.  Les m√©thodes de terminal ne renvoient pas de valeur (void) ou renvoient un r√©sultat d'un type autre qu'un flux.  Dans l'exemple ci-dessus, le <code>filter</code> , la <code>map</code> et les <code>sorted</code> sont interm√©diaires et <code>forEach</code> sont terminaux.  Pour une liste compl√®te des m√©thodes de flux disponibles, consultez la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> .  Une telle cha√Æne d'op√©rations de flux est √©galement connue sous le nom de pipeline d'op√©rations. <br><br>  La plupart des m√©thodes de l'API Stream acceptent comme param√®tres les expressions lambda, une interface fonctionnelle qui d√©crit le comportement sp√©cifique de la m√©thode.  La plupart d'entre eux doivent √† la fois ne pas interf√©rer et √™tre apatrides.  Qu'est-ce que cela signifie? <br><br>  Une m√©thode n'interf√®re pas si elle ne modifie pas les donn√©es sous-jacentes sous-jacentes au flux.  Par exemple, dans l'exemple ci-dessus, aucune expression lambda ne modifie le tableau de listes myList. <br><br>  Une m√©thode est sans √©tat si l'ordre dans lequel l'op√©ration est effectu√©e est sp√©cifi√©.  Par exemple, aucune expression lambda de l'exemple ne d√©pend de variables mutables ou d'√©tats d'espace externes qui pourraient changer au moment de l'ex√©cution. <br><br><h3>  Diff√©rents types de fils </h3><br>  Les flux peuvent √™tre cr√©√©s √† partir de diverses donn√©es sources, principalement √† partir de collections.  Les listes et les ensembles prennent en charge les nouvelles m√©thodes <code>stream()</code> et <code>parllelStream()</code> pour cr√©er des flux s√©quentiels et parall√®les.  Les threads parall√®les peuvent fonctionner en mode multi-thread (sur plusieurs threads) et seront discut√©s √† la fin du manuel.  En attendant, consid√©rez les threads s√©quentiels: <br><br><pre> <code class="java hljs">Arrays.asList(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a3"</span></span>) .stream() .findFirst() .ifPresent(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// a1</span></span></code> </pre><br>  Ici, l'appel de la m√©thode <code>stream()</code> sur une liste renvoie un objet stream normal. <br>  Cependant, pour travailler avec un flux, il n'est pas du tout n√©cessaire de cr√©er une collection: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a3"</span></span>) .findFirst() .ifPresent(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// a1</span></span></code> </pre><br>  Utilisez simplement <code>Stream.of()</code> pour cr√©er un flux √† partir de plusieurs r√©f√©rences d'objet. <br><br>  En plus des flux d'objets r√©guliers, Java 8 dispose de types sp√©ciaux de flux pour travailler avec des types primitifs: int, long, double.  Comme vous pouvez le deviner, il s'agit d' <code>IntStream</code> , <code>LongStream</code> , <code>DoubleStream</code> . <br><br>  Les flux IntStream peuvent remplacer les <code>IntStream.range()</code> r√©guli√®res pour (;;) en utilisant <code>IntStream.range()</code> : <br><br><pre> <code class="java hljs">IntStream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) .forEach(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// 1 // 2 // 3</span></span></code> </pre><br>  Tous ces flux pour travailler avec des types primitifs fonctionnent exactement comme les flux r√©guliers d'objets, √† l'exception des suivants: <br><br><ul><li>  Les flux primitifs utilisent des expressions lambda sp√©ciales.  Par exemple, IntFunction au lieu de Function, ou IntPredicate au lieu de Predicate. </li><li>  Les flux primitifs prennent en charge des m√©thodes terminales suppl√©mentaires: <code>sum()</code> et <code>average()</code> <br><br><pre> <code class="java hljs">Arrays.stream(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>[] {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>}) .map(n -&gt; <span class="hljs-number"><span class="hljs-number">2</span></span> * n + <span class="hljs-number"><span class="hljs-number">1</span></span>) .average() .ifPresent(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// 5.0</span></span></code> </pre><br></li></ul><br>  Il est parfois utile de transformer un flux d'objets en un flux de primitives ou vice versa.  √Ä cet effet, les flux d'objets prennent en charge des m√©thodes sp√©ciales: <code>mapToInt()</code> , <code>mapToLong()</code> , <code>mapToDouble()</code> : <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a3"</span></span>) .map(s -&gt; s.substring(<span class="hljs-number"><span class="hljs-number">1</span></span>)) .mapToInt(Integer::parseInt) .max() .ifPresent(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// 3</span></span></code> </pre><br>  Les flux de primitives peuvent √™tre convertis en flux d'objets en appelant <code>mapToObj()</code> : <br><br><pre> <code class="java hljs">IntStream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) .mapToObj(i -&gt; <span class="hljs-string"><span class="hljs-string">"a"</span></span> + i) .forEach(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// a1 // a2 // a3</span></span></code> </pre><br>  Dans l'exemple suivant, un flux de nombres √† virgule flottante est mapp√© √† un flux d'entiers, puis mapp√© √† un flux d'objets: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-number"><span class="hljs-number">1.0</span></span>, <span class="hljs-number"><span class="hljs-number">2.0</span></span>, <span class="hljs-number"><span class="hljs-number">3.0</span></span>) .mapToInt(Double::intValue) .mapToObj(i -&gt; <span class="hljs-string"><span class="hljs-string">"a"</span></span> + i) .forEach(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// a1 // a2 // a3</span></span></code> </pre><br><h3>  Ordre d'ex√©cution </h3><br>  Maintenant que nous avons appris √† cr√©er diff√©rents flux et √† travailler avec eux, nous allons approfondir et examiner l'aspect des op√©rations de streaming sous le capot. <br><br>  Une caract√©ristique importante des m√©thodes interm√©diaires est leur <i>paresse</i> .  Il n'y a pas de m√©thode de terminal dans cet exemple: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; });</code> </pre><br>  Lorsque ce morceau de code est ex√©cut√©, rien ne sera sorti sur la console.  Et tout cela parce que les m√©thodes interm√©diaires ne sont ex√©cut√©es que s'il existe une m√©thode terminale.  D√©veloppons l'exemple en ajoutant la m√©thode du terminal <code>forEach</code> : <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }) .forEach(s -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"forEach: "</span></span> + s));</code> </pre><br>  L'ex√©cution de ce fragment de code conduit √† la sortie sur la console du r√©sultat suivant: <br><br><pre> <code class="java hljs">filter: d2 forEach: d2 filter: a2 forEach: a2 filter: b1 forEach: b1 filter: b3 forEach: b3 filter: c forEach: c</code> </pre><br>  L'ordre dans lequel les r√©sultats sont organis√©s peut surprendre.  On peut na√Øvement s'attendre √† ce que les m√©thodes soient ex√©cut√©es ¬´horizontalement¬ª: l'une apr√®s l'autre pour tous les √©l√©ments du flux.  Cependant, au lieu de cela, l'√©l√©ment se d√©place le long de la cha√Æne ¬´verticalement¬ª.  Premi√®rement, la premi√®re ligne de ¬´d2¬ª passe par la m√©thode de <code>filter</code> , puis par <code>forEach</code> et seulement ensuite, apr√®s avoir pass√© le premier √©l√©ment √† travers la cha√Æne de m√©thodes enti√®re, l'√©l√©ment suivant commence √† √™tre trait√©. <br><br>  Compte tenu de ce comportement, vous pouvez r√©duire le nombre r√©el d'op√©rations: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .map(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"map: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .anyMatch(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"anyMatch: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.startsWith(<span class="hljs-string"><span class="hljs-string">"A"</span></span>); }); <span class="hljs-comment"><span class="hljs-comment">// map: d2 // anyMatch: D2 // map: a2 // anyMatch: A2</span></span></code> </pre><br>  La m√©thode <code>anyMatch</code> renvoie <i>true</i> d√®s que le pr√©dicat est appliqu√© √† l'√©l√©ment entrant.  Dans ce cas, il s'agit du deuxi√®me √©l√©ment de la s√©quence - ¬´A2¬ª.  Par cons√©quent, en raison de l'ex√©cution ¬´verticale¬ª de la cha√Æne de threads, la <code>map</code> ne sera appel√©e que deux fois.  Ainsi, au lieu d'afficher tous les √©l√©ments du flux, la <code>map</code> sera appel√©e le moins de fois possible. <br><br><h3>  Pourquoi la s√©quence est importante </h3><br>  L'exemple suivant consiste en deux m√©thodes interm√©diaires de <code>map</code> et de <code>filter</code> et d'une m√©thode terminale <code>forEach</code> .  Consid√©rez comment ces m√©thodes sont ex√©cut√©es: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .map(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"map: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.startsWith(<span class="hljs-string"><span class="hljs-string">"A"</span></span>); }) .forEach(s -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"forEach: "</span></span> + s)); <span class="hljs-comment"><span class="hljs-comment">// map: d2 // filter: D2 // map: a2 // filter: A2 // forEach: A2 // map: b1 // filter: B1 // map: b3 // filter: B3 // map: c // filter: C</span></span></code> </pre> <br>  Il est facile de deviner que les m√©thodes <code>map</code> et <code>filter</code> sont appel√©es 5 fois au moment de l'ex√©cution - une fois pour chaque √©l√©ment de la collection source, tandis que <code>forEach</code> n'est appel√© qu'une seule fois - pour l'√©l√©ment qui a pass√© le filtre. <br><br>  Vous pouvez r√©duire consid√©rablement le nombre d'op√©rations en modifiant l'ordre des appels de m√©thode en pla√ßant le <code>filter</code> en premier lieu: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.startsWith(<span class="hljs-string"><span class="hljs-string">"a"</span></span>); }) .map(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"map: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .forEach(s -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"forEach: "</span></span> + s)); <span class="hljs-comment"><span class="hljs-comment">// filter: d2 // filter: a2 // map: a2 // forEach: A2 // filter: b1 // filter: b3 // filter: c</span></span></code> </pre><br>  Maintenant, la carte n'est appel√©e qu'une seule fois.  Avec un grand nombre d'√©l√©ments d'entr√©e, nous observerons une augmentation notable de la productivit√©.  Gardez cela √† l'esprit lorsque vous composez des cha√Ænes de m√©thodes complexes. <br><br>  Nous d√©veloppons l'exemple ci-dessus en ajoutant une op√©ration de tri suppl√©mentaire - la m√©thode tri√©e: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .sorted((s1, s2) -&gt; { System.out.printf(<span class="hljs-string"><span class="hljs-string">"sort: %s; %s\n"</span></span>, s1, s2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s1.compareTo(s2); }) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.startsWith(<span class="hljs-string"><span class="hljs-string">"a"</span></span>); }) .map(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"map: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .forEach(s -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"forEach: "</span></span> + s));</code> </pre><br>  Le tri est un type sp√©cial d'op√©ration interm√©diaire.  Il s'agit de l'op√©ration dite avec √©tat, car pour trier une collection, son √©tat doit √™tre pris en compte tout au long de l'op√©ration. <br><br>  √Ä la suite de l'ex√©cution de ce code, nous obtenons la sortie suivante sur la console: <br><br><pre> <code class="java hljs">sort: a2; d2 sort: b1; a2 sort: b1; d2 sort: b1; a2 sort: b3; b1 sort: b3; d2 sort: c; b3 sort: c; d2 filter: a2 map: a2 forEach: A2 filter: b1 filter: b3 filter: c filter: d2</code> </pre><br>  Tout d'abord, la collection enti√®re est tri√©e.  En d'autres termes, la m√©thode <code>sorted</code> s'ex√©cute horizontalement.  Dans ce cas, <code>sorted</code> est appel√© 8 fois pour plusieurs combinaisons des √©l√©ments de la collection entrante. <br><br>  Encore une fois, nous optimisons l'ex√©cution de ce code en modifiant l'ordre des appels de m√©thode dans la cha√Æne: <br><br><pre> <code class="java hljs">Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"filter: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.startsWith(<span class="hljs-string"><span class="hljs-string">"a"</span></span>); }) .sorted((s1, s2) -&gt; { System.out.printf(<span class="hljs-string"><span class="hljs-string">"sort: %s; %s\n"</span></span>, s1, s2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s1.compareTo(s2); }) .map(s -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"map: "</span></span> + s); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .forEach(s -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"forEach: "</span></span> + s)); <span class="hljs-comment"><span class="hljs-comment">// filter: d2 // filter: a2 // filter: b1 // filter: b3 // filter: c // map: a2 // forEach: A2</span></span></code> </pre><br>  Dans cet exemple, <code>sorted</code> n'est pas appel√© du tout.  <code>filter</code> r√©duit la collection d'entr√©e √† un √©l√©ment.  Dans le cas de donn√©es d'entr√©e volumineuses, les performances en b√©n√©ficieront consid√©rablement. <br><br><h3>  R√©utiliser les flux </h3><br>  Dans Java 8, les threads ne peuvent pas √™tre r√©utilis√©s.  Apr√®s avoir appel√© une m√©thode de terminal, le thread se termine: <br><br><pre> <code class="java hljs">Stream&lt;String&gt; stream = Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; s.startsWith(<span class="hljs-string"><span class="hljs-string">"a"</span></span>)); stream.anyMatch(s -&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ok stream.noneMatch(s -&gt; true); // exception</span></span></code> </pre><br>  L'appel de <code>noneMatch</code> apr√®s <code>anyMatch</code> dans un thread entra√Æne l'exception suivante: <br><br><pre> <code class="java hljs">java.lang.IllegalStateException: stream has already been operated upon or closed at java.util.stream.AbstractPipeline.evaluate(AbstractPipeline.java:<span class="hljs-number"><span class="hljs-number">229</span></span>) at java.util.stream.ReferencePipeline.noneMatch(ReferencePipeline.java:<span class="hljs-number"><span class="hljs-number">459</span></span>) at com.winterbe.java8.Streams5.test7(Streams5.java:<span class="hljs-number"><span class="hljs-number">38</span></span>) at com.winterbe.java8.Streams5.main(Streams5.java:<span class="hljs-number"><span class="hljs-number">28</span></span>)</code> </pre><br>  Pour surmonter cette limitation, un nouveau thread doit √™tre cr√©√© pour chaque m√©thode de terminal. <br><br>  Par exemple, vous pouvez cr√©er un <i>fournisseur</i> pour un nouveau constructeur de threads dans lequel toutes les m√©thodes interm√©diaires seront install√©es: <br><br><pre> <code class="java hljs">Supplier&lt;Stream&lt;String&gt;&gt; streamSupplier = () -&gt; Stream.of(<span class="hljs-string"><span class="hljs-string">"d2"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"b3"</span></span>, <span class="hljs-string"><span class="hljs-string">"c"</span></span>) .filter(s -&gt; s.startsWith(<span class="hljs-string"><span class="hljs-string">"a"</span></span>)); streamSupplier.get().anyMatch(s -&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>); <span class="hljs-comment"><span class="hljs-comment">// ok streamSupplier.get().noneMatch(s -&gt; true); // ok</span></span></code> </pre><br>  Chaque appel √† la m√©thode <code>get</code> cr√©e un nouveau thread dans lequel vous pouvez appeler en toute s√©curit√© la m√©thode de terminal souhait√©e. <br><br><h3>  M√©thodes avanc√©es </h3><br>  Les threads prennent en charge un grand nombre de m√©thodes diff√©rentes.  Nous nous sommes d√©j√† familiaris√©s avec les m√©thodes les plus importantes.  Pour vous familiariser avec le reste, reportez-vous √† la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">documentation</a> .  Et maintenant, plongez encore plus dans des m√©thodes plus complexes: <code>collect</code> , <code>flatMap</code> et <code>reduce</code> . <br><br>  La plupart des exemples de code de cette section font r√©f√©rence √† l'extrait de code suivant pour illustrer le fonctionnement: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Person</span></span></span><span class="hljs-class"> </span></span>{ String name; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age; Person(String name, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> age) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.age = age; } <span class="hljs-meta"><span class="hljs-meta">@Override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> name; } } List&lt;Person&gt; persons = Arrays.asList( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Max"</span></span>, <span class="hljs-number"><span class="hljs-number">18</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Peter"</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Pamela"</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"David"</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>));</code> </pre><br><h4>  Recueillir </h4><br>  <code>Collect</code> m√©thode de terminal tr√®s utile, qui est utilis√©e pour convertir des √©l√©ments de flux en un r√©sultat d'un type diff√©rent, par exemple, List, Set ou Map. <br><br>  <code>Collect</code> accepte un <code>Collector</code> qui contient quatre m√©thodes diff√©rentes: un fournisseur.  accumulateur, combineur, finisseur.  √Ä premi√®re vue, cela semble tr√®s compliqu√©, mais Java 8 prend en charge divers collecteurs int√©gr√©s via la classe <code>Collectors</code> , o√π les m√©thodes les plus utilis√©es sont impl√©ment√©es. <br><br>  Cas populaire: <br><br><pre> <code class="java hljs">List&lt;Person&gt; filtered = persons .stream() .filter(p -&gt; p.name.startsWith(<span class="hljs-string"><span class="hljs-string">"P"</span></span>)) .collect(Collectors.toList()); System.out.println(filtered); <span class="hljs-comment"><span class="hljs-comment">// [Peter, Pamela]</span></span></code> </pre> <br>  Comme vous pouvez le voir, la cr√©ation d'une liste √† partir d'√©l√©ments de flux est tr√®s simple.  Pas besoin d'une liste mais beaucoup?  Utilisez <code>Collectors.toSet()</code> . <br><br>  Dans l'exemple suivant, les personnes sont regroup√©es par √¢ge: <br><br><pre> <code class="java hljs">Map&lt;Integer, List&lt;Person&gt;&gt; personsByAge = persons .stream() .collect(Collectors.groupingBy(p -&gt; p.age)); personsByAge .forEach((age, p) -&gt; System.out.format(<span class="hljs-string"><span class="hljs-string">"age %s: %s\n"</span></span>, age, p)); <span class="hljs-comment"><span class="hljs-comment">// age 18: [Max] // age 23: [Peter, Pamela] // age 12: [David]</span></span></code> </pre><br>  Les collectionneurs sont incroyablement diversifi√©s.  Vous pouvez √©galement agr√©ger les √©l√©ments de la collection, par exemple, d√©terminer l'√¢ge moyen: <br><br><pre> <code class="java hljs">Double averageAge = persons .stream() .collect(Collectors.averagingInt(p -&gt; p.age)); System.out.println(averageAge); <span class="hljs-comment"><span class="hljs-comment">// 19.0</span></span></code> </pre><br>  Pour obtenir des statistiques plus compl√®tes, nous utilisons un collecteur r√©capitulatif qui renvoie un objet sp√©cial avec des informations: valeurs minimale, maximale et moyenne, la somme des valeurs et le nombre d'√©l√©ments: <br><br><pre> <code class="java hljs">IntSummaryStatistics ageSummary = persons .stream() .collect(Collectors.summarizingInt(p -&gt; p.age)); System.out.println(ageSummary); <span class="hljs-comment"><span class="hljs-comment">// IntSummaryStatistics{count=4, sum=76, min=12, average=19.000000, max=23}</span></span></code> </pre><br>  L'exemple suivant combine tous les noms sur une seule ligne: <br><br><pre> <code class="java hljs">String phrase = persons .stream() .filter(p -&gt; p.age &gt;= <span class="hljs-number"><span class="hljs-number">18</span></span>) .map(p -&gt; p.name) .collect(Collectors.joining(<span class="hljs-string"><span class="hljs-string">" and "</span></span>, <span class="hljs-string"><span class="hljs-string">"In Germany "</span></span>, <span class="hljs-string"><span class="hljs-string">" are of legal age."</span></span>)); System.out.println(phrase); <span class="hljs-comment"><span class="hljs-comment">// In Germany Max and Peter and Pamela are of legal age.</span></span></code> </pre><br>  Le collecteur de connexion accepte un s√©parateur, ainsi qu'un pr√©fixe et un suffixe facultatifs. <br><br>  Pour convertir les √©l√©ments d'un flux en affichage, vous devez d√©terminer comment les cl√©s et les valeurs doivent √™tre affich√©es.  N'oubliez pas que les cl√©s du mappage doivent √™tre uniques.  Sinon, nous obtenons une <code>IllegalStateException</code> .  Vous pouvez √©ventuellement ajouter une fonction de fusion pour contourner l'exception: <br><br><pre> <code class="java hljs">Map&lt;Integer, String&gt; map = persons .stream() .collect(Collectors.toMap( p -&gt; p.age, p -&gt; p.name, (name1, name2) -&gt; name1 + <span class="hljs-string"><span class="hljs-string">";"</span></span> + name2)); System.out.println(map); <span class="hljs-comment"><span class="hljs-comment">// {18=Max, 23=Peter;Pamela, 12=David}</span></span></code> </pre><br>  Nous avons donc fait la connaissance de certains des collecteurs int√©gr√©s les plus puissants.  Essayons de construire le v√¥tre.  Nous voulons convertir tous les √©l√©ments du flux en une seule ligne, qui se compose de noms en majuscules s√©par√©s par une barre verticale |.  Pour ce faire, cr√©ez un nouveau collecteur √† l'aide de <code>Collector.of()</code> .  Nous avons besoin des quatre composants de notre collecteur: fournisseur, batterie, connecteur, finisseur. <br><br><pre> <code class="java hljs">Collector&lt;Person, StringJoiner, String&gt; personNameCollector = Collector.of( () -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StringJoiner(<span class="hljs-string"><span class="hljs-string">" | "</span></span>), <span class="hljs-comment"><span class="hljs-comment">// supplier (j, p) -&gt; j.add(p.name.toUpperCase()), // accumulator (j1, j2) -&gt; j1.merge(j2), // combiner StringJoiner::toString); // finisher String names = persons .stream() .collect(personNameCollector); System.out.println(names); // MAX | PETER | PAMELA | DAVID</span></span></code> </pre> <br>  √âtant donn√© que les cha√Ænes en Java sont immuables, nous avons besoin d'une classe d'assistance comme <code>StringJoiner</code> qui permet au collecteur de cr√©er une cha√Æne pour nous.  Dans la premi√®re √©tape, le fournisseur construit un <code>StringJoiner</code> avec un d√©limiteur affect√©.  La batterie est utilis√©e pour ajouter chaque nom √† <code>StringJoiner</code> . <br><br>  Le connecteur sait comment connecter deux <code>StringJoiner</code> en un seul.  Et √† la fin, le finisseur construit la cha√Æne souhait√©e √† partir de <code>StringJoiner</code> s. <br><br><h4>  Flatmap </h4><br>  Nous avons donc appris √† transformer des objets de flux en d'autres types d'objets √† l'aide de la m√©thode <code>map</code> .  <code>Map</code> est une sorte de m√©thode limit√©e, car chaque objet ne peut √™tre mapp√© qu'√† un seul autre objet.  Mais que se passe-t-il si vous souhaitez mapper un objet √† plusieurs autres, ou ne pas l'afficher du tout?  C'est l√† que la m√©thode <code>flatMap</code> aide.  <code>FlatMap</code> transforme chaque objet de flux en un flux d'autres objets.  Le contenu de ces threads est ensuite conditionn√© dans le flux renvoy√© de la m√©thode <code>flatMap</code> . <br><br>  Afin de regarder <code>flatMap</code> en action, construisons une hi√©rarchie de types appropri√©e pour un exemple: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Foo</span></span></span><span class="hljs-class"> </span></span>{ String name; List&lt;Bar&gt; bars = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); Foo(String name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Bar</span></span></span><span class="hljs-class"> </span></span>{ String name; Bar(String name) { <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.name = name; } }</code> </pre><br>  Cr√©ons quelques objets: <br><br><pre> <code class="java hljs">List&lt;Foo&gt; foos = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ArrayList&lt;&gt;(); <span class="hljs-comment"><span class="hljs-comment">// create foos IntStream .range(1, 4) .forEach(i -&gt; foos.add(new Foo("Foo" + i))); // create bars foos.forEach(f -&gt; IntStream .range(1, 4) .forEach(i -&gt; f.bars.add(new Bar("Bar" + i + " &lt;- " + f.name))));</span></span></code> </pre><br>  Nous avons maintenant une liste de trois <i>foo</i> , chacune contenant trois <i>barres</i> . <br><br>  <code>FlatMap</code> accepte une fonction qui devrait renvoyer un flux d'objets.  Ainsi, pour acc√©der aux objets <i>bar</i> de chaque <i>foo</i> , il suffit de trouver la fonction appropri√©e: <br><br><pre> <code class="java hljs">foos.stream() .flatMap(f -&gt; f.bars.stream()) .forEach(b -&gt; System.out.println(b.name)); <span class="hljs-comment"><span class="hljs-comment">// Bar1 &lt;- Foo1 // Bar2 &lt;- Foo1 // Bar3 &lt;- Foo1 // Bar1 &lt;- Foo2 // Bar2 &lt;- Foo2 // Bar3 &lt;- Foo2 // Bar1 &lt;- Foo3 // Bar2 &lt;- Foo3 // Bar3 &lt;- Foo3</span></span></code> </pre><br>  Nous avons donc r√©ussi √† transformer un flux de trois objets <i>foo</i> en un flux de 9 objets <i>bar</i> . <br><br>  Enfin, tout le code ci-dessus peut √™tre r√©duit √† un simple pipeline d'op√©rations: <br><br><pre> <code class="java hljs">IntStream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) .mapToObj(i -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Foo(<span class="hljs-string"><span class="hljs-string">"Foo"</span></span> + i)) .peek(f -&gt; IntStream.range(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">4</span></span>) .mapToObj(i -&gt; <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Bar(<span class="hljs-string"><span class="hljs-string">"Bar"</span></span> + i + <span class="hljs-string"><span class="hljs-string">" &lt;- "</span></span> f.name)) .forEach(f.bars::add)) .flatMap(f -&gt; f.bars.stream()) .forEach(b -&gt; System.out.println(b.name));</code> </pre><br>  <code>FlatMap</code> √©galement disponible dans la classe <code>Optional</code> introduite dans Java 8. <code>FlatMap</code> de la classe <code>Optional</code> renvoie un objet facultatif d'une autre classe.  Cela peut √™tre utilis√© pour √©viter un tas de contr√¥les <code>null</code> . <br><br>  Imaginez une structure hi√©rarchique comme celle-ci: <br><br><pre> <code class="java hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Outer</span></span></span><span class="hljs-class"> </span></span>{ Nested nested; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Nested</span></span></span><span class="hljs-class"> </span></span>{ Inner inner; } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Inner</span></span></span><span class="hljs-class"> </span></span>{ String foo; }</code> </pre><br>  Pour obtenir la cha√Æne imbriqu√©e <i>foo</i> d'un objet externe, vous devez ajouter plusieurs v√©rifications <code>null</code> pour √©viter une <code>NullPointException</code> : <br><br><pre> <code class="java hljs">Outer outer = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Outer(); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (outer != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; outer.nested != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> &amp;&amp; outer.nested.inner != <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>) { System.out.println(outer.nested.inner.foo); }</code> </pre><br>  La m√™me chose peut √™tre obtenue en utilisant le flatMap de la classe facultative: <br><br><pre> <code class="java hljs">Optional.of(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Outer()) .flatMap(o -&gt; Optional.ofNullable(o.nested)) .flatMap(n -&gt; Optional.ofNullable(n.inner)) .flatMap(i -&gt; Optional.ofNullable(i.foo)) .ifPresent(System.out::println);</code> </pre><br>  Chaque appel √† <code>flatMap</code> renvoie un wrapper <code>Optional</code> pour l'objet souhait√©, s'il est pr√©sent, ou pour <code>null</code> si l'objet est manquant. <br><br><h4>  R√©duire </h4><br>  L'op√©ration de simplification combine tous les √©l√©ments d'un flux en un seul r√©sultat.  Java 8 prend en charge trois types diff√©rents de m√©thodes de r√©duction. <br><br>  Le premier r√©duit le flux d'√©l√©ments √† un seul √©l√©ment de flux.  Nous utilisons cette m√©thode pour d√©terminer l'√©l√©ment ayant le plus grand √¢ge: <br><br><pre> <code class="java hljs">persons .stream() .reduce((p1, p2) -&gt; p1.age &gt; p2.age ? p1 : p2) .ifPresent(System.out::println); <span class="hljs-comment"><span class="hljs-comment">// Pamela</span></span></code> </pre> <br>  La m√©thode de <code>reduce</code> prend une fonction d'accumulation avec un <i>op√©rateur binaire</i> (BinaryOperator).  Ici, <code>reduce</code> est une <i>bi-fonction</i> (BiFunction), o√π les deux arguments appartiennent au m√™me type.  Dans notre cas, au type <i>Personne</i> .  Une bi-fonction est presque la m√™me chose qu'une <code></code> , mais elle prend 2 arguments.  Dans notre exemple, la fonction compare l'√¢ge de deux personnes et renvoie un √©l√©ment avec un √¢ge sup√©rieur. <br><br>  La forme suivante de la m√©thode de <code>reduce</code> prend √† la fois une valeur initiale et une batterie avec un op√©rateur binaire.  Cette m√©thode peut √™tre utilis√©e pour cr√©er un nouvel √©l√©ment.  Nous avons - <i>Personne</i> avec un nom et un √¢ge, comprenant l'addition de tous les noms et la somme des ann√©es v√©cues: <br><br><pre> <code class="java hljs">Person result = persons .stream() .reduce(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">""</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>), (p1, p2) -&gt; { p1.age += p2.age; p1.name += p2.name; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p1; }); System.out.format(<span class="hljs-string"><span class="hljs-string">"name=%s; age=%s"</span></span>, result.name, result.age); <span class="hljs-comment"><span class="hljs-comment">// name=MaxPeterPamelaDavid; age=76</span></span></code> </pre><br>  La troisi√®me m√©thode de <code>reduce</code> prend trois param√®tres: la valeur initiale, l'accumulateur avec une bi-fonction et une fonction de combinaison telle qu'un op√©rateur binaire.  √âtant donn√© que la valeur initiale du type n'est pas limit√©e au type Personne, vous pouvez utiliser la r√©duction pour d√©terminer le nombre total d'ann√©es v√©cues de chaque personne: <br><br><pre> <code class="java hljs">Integer ageSum = persons .stream() .reduce(<span class="hljs-number"><span class="hljs-number">0</span></span>, (sum, p) -&gt; sum += p.age, (sum1, sum2) -&gt; sum1 + sum2); System.out.println(ageSum); <span class="hljs-comment"><span class="hljs-comment">// 76</span></span></code> </pre><br>  Comme vous pouvez le voir, nous avons obtenu le r√©sultat 76, mais que se passe-t-il vraiment sous le capot? <br><br>  Nous d√©veloppons le fragment de code ci-dessus avec la sortie du texte pour le d√©bogage: <br><br><pre> <code class="java hljs">Integer ageSum = persons .stream() .reduce(<span class="hljs-number"><span class="hljs-number">0</span></span>, (sum, p) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"accumulator: sum=%s; person=%s\n"</span></span>, sum, p); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum += p.age; }, (sum1, sum2) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"combiner: sum1=%s; sum2=%s\n"</span></span>, sum1, sum2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum1 + sum2; }); <span class="hljs-comment"><span class="hljs-comment">// accumulator: sum=0; person=Max // accumulator: sum=18; person=Peter // accumulator: sum=41; person=Pamela // accumulator: sum=64; person=David</span></span></code> </pre><br>  Comme vous pouvez le voir, la fonction d'accumulation effectue tout le travail.  Il est d'abord appel√© avec une valeur initiale de 0 et la premi√®re personne Max.  Au cours des trois prochaines √©tapes, la somme augmente constamment selon l'√¢ge de la personne depuis la derni√®re √©tape jusqu'√† ce qu'elle atteigne un √¢ge total de 76 ans. <br><br>  Et maintenant?  Le combineur n'est-il jamais appel√©?  Consid√©rez l'ex√©cution parall√®le de ce fil: <br><br><pre> <code class="java hljs">Integer ageSum = persons .parallelStream() .reduce(<span class="hljs-number"><span class="hljs-number">0</span></span>, (sum, p) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"accumulator: sum=%s; person=%s\n"</span></span>, sum, p); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum += p.age; }, (sum1, sum2) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"combiner: sum1=%s; sum2=%s\n"</span></span>, sum1, sum2); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum1 + sum2; }); <span class="hljs-comment"><span class="hljs-comment">// accumulator: sum=0; person=Pamela // accumulator: sum=0; person=David // accumulator: sum=0; person=Max // accumulator: sum=0; person=Peter // combiner: sum1=18; sum2=23 // combiner: sum1=23; sum2=12 // combiner: sum1=41; sum2=35</span></span></code> </pre><br>  Avec une ex√©cution parall√®le, nous obtenons une sortie de console compl√®tement diff√©rente.  Maintenant, le combineur est vraiment appel√©.    ,     ,  -. <br><br>         . <br><br><h3>   </h3><br>              .     <code>ForkJoinPool</code>      <code>ForkJoinPool.commonPool()</code> .       5   ‚Äî         . <br><br><pre> <code class="java hljs">ForkJoinPool commonPool = ForkJoinPool.commonPool(); System.out.println(commonPool.getParallelism()); <span class="hljs-comment"><span class="hljs-comment">// 3</span></span></code> </pre><br>             3 .           JVM: <br><br><pre> <code class="bash hljs">-Djava.util.concurrent.ForkJoinPool.common.parallelism=5</code> </pre> <br>    <code>parallelStream()</code>     .      <code>parallel()</code>      . <br><br>       ,         (thread)  <code>System.out</code> : <br><br><pre> <code class="java hljs">Arrays.asList(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"c2"</span></span>, <span class="hljs-string"><span class="hljs-string">"c1"</span></span>) .parallelStream() .filter(s -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"filter: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }) .map(s -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"map: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .forEach(s -&gt; System.out.format(<span class="hljs-string"><span class="hljs-string">"forEach: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()));</code> </pre><br>         ,   (thread)       (stream): <br><br><pre> <code class="java hljs">filter: b1 [main] filter: a2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] map: a2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] filter: c2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] map: c2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] filter: c1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] map: c1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] forEach: C2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] forEach: A2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] map: b1 [main] forEach: B1 [main] filter: a1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] map: a1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] forEach: A1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] forEach: C1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>]</code> </pre><br>  ,          (threads)  <code>ForkJoinPool</code> .    ,          (thread). <br><br>      <code>sort</code> : <br><br><pre> <code class="java hljs">Arrays.asList(<span class="hljs-string"><span class="hljs-string">"a1"</span></span>, <span class="hljs-string"><span class="hljs-string">"a2"</span></span>, <span class="hljs-string"><span class="hljs-string">"b1"</span></span>, <span class="hljs-string"><span class="hljs-string">"c2"</span></span>, <span class="hljs-string"><span class="hljs-string">"c1"</span></span>) .parallelStream() .filter(s -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"filter: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; }) .map(s -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"map: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s.toUpperCase(); }) .sorted((s1, s2) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"sort: %s &lt;&gt; %s [%s]\n"</span></span>, s1, s2, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> s1.compareTo(s2); }) .forEach(s -&gt; System.out.format(<span class="hljs-string"><span class="hljs-string">"forEach: %s [%s]\n"</span></span>, s, Thread.currentThread().getName()));</code> </pre><br>       : <br><br><pre> <code class="java hljs">filter: c2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] filter: c1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] map: c1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] filter: a2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] map: a2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] filter: b1 [main] map: b1 [main] filter: a1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] map: a1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] map: c2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] sort: A2 &lt;&gt; A1 [main] sort: B1 &lt;&gt; A2 [main] sort: C2 &lt;&gt; B1 [main] sort: C1 &lt;&gt; C2 [main] sort: C1 &lt;&gt; B1 [main] sort: C1 &lt;&gt; C2 [main] forEach: A1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] forEach: C2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] forEach: B1 [main] forEach: A2 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] forEach: C1 [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>]</code> </pre> <br> ,  <code>sort</code>       <i>main</i> .           <code>sort</code>  Stream API     <code>Arrays</code> ,   Java 8, ‚Äî <code>Arrays.parallelSort()</code> .    ,        ,   ‚Äî      : <br><blockquote>       ‚Äú‚Äù,      Arrays.sort. </blockquote>      <code>reduce</code>   .   ,          . ,   : <br><br><pre> <code class="java hljs">List&lt;Person&gt; persons = Arrays.asList( <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Max"</span></span>, <span class="hljs-number"><span class="hljs-number">18</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Peter"</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"Pamela"</span></span>, <span class="hljs-number"><span class="hljs-number">23</span></span>), <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Person(<span class="hljs-string"><span class="hljs-string">"David"</span></span>, <span class="hljs-number"><span class="hljs-number">12</span></span>)); persons .parallelStream() .reduce(<span class="hljs-number"><span class="hljs-number">0</span></span>, (sum, p) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"accumulator: sum=%s; person=%s [%s]\n"</span></span>, sum, p, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum += p.age; }, (sum1, sum2) -&gt; { System.out.format(<span class="hljs-string"><span class="hljs-string">"combiner: sum1=%s; sum2=%s [%s]\n"</span></span>, sum1, sum2, Thread.currentThread().getName()); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> sum1 + sum2; });</code> </pre><br>   ,   :   ,  ,    : <br><br><pre> <code class="java hljs">accumulator: sum=<span class="hljs-number"><span class="hljs-number">0</span></span>; person=Pamela; [main] accumulator: sum=<span class="hljs-number"><span class="hljs-number">0</span></span>; person=Max; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">3</span></span>] accumulator: sum=<span class="hljs-number"><span class="hljs-number">0</span></span>; person=David; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] accumulator: sum=<span class="hljs-number"><span class="hljs-number">0</span></span>; person=Peter; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] combiner: sum1=<span class="hljs-number"><span class="hljs-number">18</span></span>; sum2=<span class="hljs-number"><span class="hljs-number">23</span></span>; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">1</span></span>] combiner: sum1=<span class="hljs-number"><span class="hljs-number">23</span></span>; sum2=<span class="hljs-number"><span class="hljs-number">12</span></span>; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>] combiner: sum1=<span class="hljs-number"><span class="hljs-number">41</span></span>; sum2=<span class="hljs-number"><span class="hljs-number">35</span></span>; [ForkJoinPool.commonPool-worker-<span class="hljs-number"><span class="hljs-number">2</span></span>]</code> </pre><br>  ,               .   ,          ( ),      . <br><br>  ,         <code>ForkJoinPool</code> ,     JVM.              ,     (threads),      . <br><br><h3>    </h3><br>       Java 8 .           <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="></a> .         ,     ,         (Martin Fowler) <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Collection Pipelines</a> . <br><br>      JavaScript,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Stream.js</a> ‚Äî JavaScript  Java 8 Streams API. ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Java 8 Tutorial</a> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a>  )  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Java 8 Nashorn Tutorial</a> . <br><br> ,        ,      .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">  GitHub</a> .   ,    . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr437038/">https://habr.com/ru/post/fr437038/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr437026/index.html">Google en France inflige une amende de 50 millions d'euros au RGPD pour abus de donn√©es √† caract√®re personnel</a></li>
<li><a href="../fr437030/index.html">Automatisation de l'infrastructure d'un bureau de luxe: √† quoi elle ressemble</a></li>
<li><a href="../fr437032/index.html">Instructions d'installation de NGINX ModSecurity</a></li>
<li><a href="../fr437034/index.html">Universal Whistles: Snom A230 et A210 USB Dongle Review</a></li>
<li><a href="../fr437036/index.html">SAPUI5 for dummies part 2: Un exercice complet √©tape par √©tape</a></li>
<li><a href="../fr437040/index.html">En Russie, a commenc√© √† tester l'interface neuronale domestique "Neurochat"</a></li>
<li><a href="../fr437044/index.html">Comment vaincre le dragon: r√©√©crivez votre programme sur Golang</a></li>
<li><a href="../fr437050/index.html">Le livre "Python. Cours express. 3e √©d.</a></li>
<li><a href="../fr437052/index.html">Ne manquez pas d'apprendre: un sp√©cialiste universitaire en informatique a-t-il besoin</a></li>
<li><a href="../fr437054/index.html">Nouveaux processeurs Intel de 9e g√©n√©ration: Core moins GPU</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>