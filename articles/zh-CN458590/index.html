<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🏨 🎲 👉🏼 iOS应用程序中的架构方法 🦗 🚺 👊🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="今天，我们将讨论iOS开发中的架构方法，某些事物的实现方面的细微差别和开发。 我将告诉您我们遵循的方法，并进一步详细介绍。 


 立即显示所有卡片。 我们使用MVVM-R（MVVM +路由器）。 


 实际上，这是常规的MVVM，其中屏幕之间的导航位于服务中的单独层（路由器和接收数据的逻辑）中。...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>iOS应用程序中的架构方法</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/agima/blog/458590/"><p> 今天，我们将讨论iOS开发中的架构方法，某些事物的实现方面的细微差别和开发。 我将告诉您我们遵循的方法，并进一步详细介绍。 </p><a name="habracut"></a><br><p> 立即显示所有卡片。 我们使用MVVM-R（MVVM +路由器）。 </p><br><p> 实际上，这是常规的MVVM，其中屏幕之间的导航位于服务中的单独层（路由器和接收数据的逻辑）中。 接下来，我们将考虑在每个层的实现中所取得的成就。 </p><br><h2 id="pochemu-mvvm-a-ne-viper-ili-mvc"> 为什么选择MVVM，而不是VIPER或MVC？ </h2><br><p> 与MVC不同，MVVM在各层之间负有相当大的责任。 尽管屏幕的ViewModel也由协议关闭，但它没有VIPER中的“服务”代码那么多。 这种体系结构有点类似于VIPER，ViewModel中仅合并了Presenter和Interactor，并且通过使用反应式编程和活页夹（我们使用ReactiveSwift）简化了层之间的连接。 </p><br><h2 id="entity"> 实体 </h2><br><p> 我们使用两层数据模型：第一层与数据库绑定（以下称为<strong>托管对象</strong> ），第二层是所谓的<strong>普通对象</strong> ，它们与数据库无关。 </p><br><p>每个简单实体都实现可翻译协议，该协议可从托管对象初始化并从中创建托管对象。 我们使用Realm作为数据库，在本例中<code>RealmSwift.Object</code>是<code>RealmSwift.Object</code> 。 映射通过<code>Codable</code> ：将它们映射为纯对象并保存为托管对象。 进一步的服务和ViewModel仅适用于纯对象。 </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Translatable</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">associatedtype</span></span> <span class="hljs-type"><span class="hljs-type">ManagedObject</span></span>: <span class="hljs-type"><span class="hljs-type">Object</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(object: <span class="hljs-type"><span class="hljs-type">ManagedObject</span></span>) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toManagedObject</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">ManagedObject</span></span> }</code> </pre> <br><p> 为了从数据库中保存，检索和删除对象，使用了一个单独的实体-存储。 由于协议已关闭存储，因此我们不依赖于特定数据库的实现，并且在必要时可以用CoreData替换Realm。 </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">StorageProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">cachedObjects</span></span></span><span class="hljs-function">&lt;T: Translatable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; [<span class="hljs-type"><span class="hljs-type">T</span></span>] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">object</span></span></span><span class="hljs-function">&lt;T: Translatable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(byPrimaryKey key: AnyHashable)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">T?</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-function">&lt;T: Translatable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(objects: [T])</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">save</span></span></span><span class="hljs-function">&lt;T: Translatable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object: T)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-function">&lt;T: Translatable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(objects: [T])</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">delete</span></span></span><span class="hljs-function">&lt;T: Translatable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(object: T)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">deleteAll</span></span></span><span class="hljs-function">&lt;T: Translatable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(ofType type: T.</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">Type</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">throws</span></span> }</code> </pre> <br><h3 id="kakie-plyusy-i-minusy-u-takogo-podhoda"> 这种方法的优缺点是什么？ </h3><br><p> 每个数据库都有其自己的特征。 例如，已经存储在数据库中的Realm对象只能在创建它的流的框架内使用。 这很不方便。 </p><br><p> 同样，当对象位于RAM中时，可以从数据库中删除该对象，并且访问该对象将崩溃。 核心数据具有相同的功能。 因此，我们从数据库中获取对象，将它们转换为普通对象，然后使用它们。 </p><br><p> 使用这种方法，代码变得更大，需要得到支持。 无论数据库的功能如何，我们都会失去使用出色芯片的能力。 对于CoreData，这是一个FetchedResultsController，我们可以在其中控制实体数组中的所有插入，删除和更改。 与Realm中的机制相同。 </p><br><h2 id="core-components"> 核心组成 </h2><br><p> 核心组件是执行其任务之一的实体。 例如，映射，与数据库的交互，发送和处理网络请求。 上一段中的存储只是核心组件之一。 </p><br><h3 id="protocols"> 通讯协定 </h3><br><p> 我们积极使用协议。 协议封闭了所有核心组件，并且可以对单元测试进行模拟或测试实现。 这样，我们获得了一定的实现灵活性。 所有依赖项都传递给init。 初始化每个对象时，我们了解它们之间存在什么样的依赖关系，以及它在内部使用的依赖关系。 </p><br><h3 id="http-client">  HTTP客户端 </h3><br><p> 网络请求由<code>NetworkRequestParams</code>协议描述。 </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NetworkRequestParams</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> path: <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> method: <span class="hljs-type"><span class="hljs-type">HTTPMethod</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parameters: <span class="hljs-type"><span class="hljs-type">Parameters</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> encoding: <span class="hljs-type"><span class="hljs-type">ParameterEncoding</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> headers: [<span class="hljs-type"><span class="hljs-type">String</span></span>: <span class="hljs-type"><span class="hljs-type">String</span></span>]? { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> defaultHeaders: [<span class="hljs-type"><span class="hljs-type">String</span></span>: <span class="hljs-type"><span class="hljs-type">String</span></span>]? { <span class="hljs-keyword"><span class="hljs-keyword">get</span></span> } }</code> </pre> <br><p> 我们使用<code>enum</code>来描述网络请求。 看起来像这样： </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">enum</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserNetworkRouter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">URLRequestConvertible</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> info <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> update(userJson:[<span class="hljs-type"><span class="hljs-type">String</span></span> : <span class="hljs-type"><span class="hljs-type">Any</span></span>]) } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">UserNetworkRouter</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">NetworkRequestParams</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> path: <span class="hljs-type"><span class="hljs-type">String</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .info: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"/users/profile"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .update: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"/users/update_profile"</span></span> } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> method: <span class="hljs-type"><span class="hljs-type">HTTPMethod</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .info: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">get</span></span> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .update: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> .post } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> encoding: <span class="hljs-type"><span class="hljs-type">ParameterEncoding</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .info: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">URLEncoding</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .update: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-type"><span class="hljs-type">JSONEncoding</span></span>() } } <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> parameters: <span class="hljs-type"><span class="hljs-type">Parameters</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .info: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> [:] <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> .update(<span class="hljs-keyword"><span class="hljs-keyword">let</span></span> userJson): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> userJson } } }</code> </pre> <br><p> 每个<code>NetworkRouter</code>实现<code>URLRequestConvertible</code>协议。 我们将其提供给网络客户端，网络客户端将其转换为<code>URLRequest</code>并将其用于预期目的。 </p><br><p> 网络客户端如下： </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">HTTPClientProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">load</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(request: NetworkRequestParams &amp; URLRequestConvertible)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SignalProducer</span></span>&lt;<span class="hljs-type"><span class="hljs-type">Data</span></span>, <span class="hljs-type"><span class="hljs-type">Error</span></span>&gt; }</code> </pre> <br><h3 id="mapper"> 映射器 </h3><br><p> 我们使用<code>Codable</code>进行数据映射。 </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MapperProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">map</span></span></span><span class="hljs-function">&lt;MappingResult: Codable&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data: Data, dateDecodingStrategy: JSONDecoder.DateDecodingStrategy)</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SignalProducer</span></span>&lt;<span class="hljs-type"><span class="hljs-type">MappingResult</span></span>, <span class="hljs-type"><span class="hljs-type">Error</span></span>&gt; }</code> </pre> <br><h3 id="push---uvedomleniya"> 推送通知 </h3><br><p> 每个推送通知都有一个类型，每种类型都有自己的处理程序。 处理程序从通知中接收带有信息的字典。 聚合实体持有处理程序；由她来接收推送并将其定向到所需的处理程序。 这是一种相当可扩展的方法，如果您需要以不同方式处理几种类型的推送通知，则使用起来很方便。 </p><br><h2 id="servisy"> 服务项目 </h2><br><p> 粗略地说，一项服务负责一个实体。 考虑一个社交网络应用程序的示例。 有一个用户的服务器接收用户-他本人，并且如果我们对其进行了编辑，则给出更改的实体。 有一个邮政服务，可以接收邮件列表，详细的邮件，付款服务等。 等 </p><br><p> 所有服务都包含核心组件。 当我们在服务上调用方法时，它开始处理核心组件的各种方法，并最终给出结果。 </p><br><p> 通常，服务确实适用于特定的屏幕，或者适用于屏幕视图模型（有关更多信息，请参见下文）。 如果在离开屏幕时该服务没有被破坏，但继续满足了已经不必要的网络请求，并且将减慢其他请求的速度。 这可以手动控制，但是维护这样的系统将更加困难。 但是，这种方法有一个缺点：如果即使在我们退出屏幕后仍需要服务结果，则您将不得不寻找其他解决方案，也许会使某些服务成为单例。 </p><br><p> 服务是无状态的。 由于服务不是单调的，因此我们可以具有同一服务的多个实例，其中状态可以彼此不同。 这可能会导致错误的行为。 </p><br><p> 一种服务的方法示例： </p><br><pre> <code class="swift hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">currentUser</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> -&gt; <span class="hljs-type"><span class="hljs-type">SignalProducer</span></span>&lt;<span class="hljs-type"><span class="hljs-type">User</span></span>, <span class="hljs-type"><span class="hljs-type">Error</span></span>&gt; { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> request = <span class="hljs-type"><span class="hljs-type">UserNetworkRouter</span></span>.info <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> httpClient.load(request: request) .flatMap(.latest, mapUser) .flatMap(.latest, save) }</code> </pre> <br><h2 id="viewmodel"> 视图模型 </h2><br><p> 我们将ViewModel分为2种类型： </p><br><ul><li> 屏幕的ViewModel（ViewController） </li><li>  UIView的ViewModel（包括表单元格或UICollectionView） </li></ul><br><p>  ViewController的ViewModel负责屏幕的逻辑。 通常，这是发送网络请求，准备数据，响应UI事件。 </p><br><p>  ViewModel为来自服务的视图准备所有数据。 如果到达实体列表，则ViewModel会将其转换为ViewModel列表，并将其绑定到视图。 如果存在状态（有一个选中标记/没有选中标记），则也将对其进行管理并将其传递给ViewModel。 </p><br><p>  ViewModel还控制导航逻辑。 有一个单独的Router层用于导航，但是ViewModel提供了命令。 </p><br><p> 视图模型的典型功能：吸引用户，联系用户服务，根据接收到的值创建ViewModel。 加载完所有内容后，View将使用ViewModel并绘制视图单元格。 </p><br><p> 由于与服务相同的原因，协议关闭了屏幕的ViewModel。 但是，还有另一种有趣的情况：例如，一个银行应用程序，其中每个操作（转移资金，开设帐户，冻结帐户）都由SMS确认。 在确认屏幕上，有一个代码输入字段和一个“再次发送”按钮。 </p><br><p>  ViewModel通过以下协议关闭： </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CodeInputViewModelProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">///    func send(code: String) -&gt; SignalProducer&lt;Void, Error&gt; ///    func resendCode() -&gt; SignalProducer&lt;Void, Error&gt; }</span></span></code> </pre> <br><p> 在ViewController中，它以以下形式存储： </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> viewModel: <span class="hljs-type"><span class="hljs-type">CodeInputViewModelProtocol?</span></span></code> </pre> <br><p> 根据我们试图通过SMS进行确认的方式，可以通过完全不同的请求来表示发送代码和发送SMS的过程，并且在确认之后，需要转换到不同的屏幕等。 由于ViewController并不关心ViewModel实际具有的时间，我们可以针对不同情况使用几种ViewModel实现，并且UI会很常见。 </p><br><p> 用于View和单元格的ViewModel通常处理数据格式和用户输入处理。 例如，存储选定/未选定状态。 </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeedCellViewModel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> url: <span class="hljs-type"><span class="hljs-type">URL?</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> title: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> subtitle: <span class="hljs-type"><span class="hljs-type">String</span></span> <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(feed: <span class="hljs-type"><span class="hljs-type">FeedItem</span></span>) { url = <span class="hljs-type"><span class="hljs-type">URL</span></span>(string: feed.imageUrl) title = feed.title subtitle = <span class="hljs-type"><span class="hljs-type">DateFormatter</span></span>.feed.string(from feed.publishDate) } }</code> </pre> <br><h2 id="navigaciya"> 导览 </h2><br><p> 屏幕之间的转换由路由器执行。 </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseRouter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">init</span></span>(sourceViewController: <span class="hljs-type"><span class="hljs-type">UIViewController</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.sourceViewController = sourceViewController } <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> sourceViewController: <span class="hljs-type"><span class="hljs-type">UIViewController?</span></span> }</code> </pre> <br><p> 每个屏幕都有自己的路由器，该路由器是从基础继承的。 它具有特定屏幕的转换方法。 </p><br><pre> <code class="swift hljs"><span class="hljs-keyword"><span class="hljs-keyword">final</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeedRouter</span></span></span><span class="hljs-class"> : </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseRouter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showDetail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(viewModel: FeedDetailViewModelProtocol)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vc = <span class="hljs-type"><span class="hljs-type">FeedDetailViewController</span></span>() vc.viewModel = viewModel sourceViewController?.navigationController?.pushViewController(vc, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) } }</code> </pre> <br><p> 从上面的示例中可以看到，“模块”的组装在路由器中进行。 这在形式上与SOLID中的字母S相矛盾，但实际上它非常方便且不会引起问题。 </p><br><p> 有时在不同的路由器中需要使用相同的方法。 为了避免多次编写，我们创建了一个协议，其中包含一些通用方法，并且将对其进行<code>extension</code> 。 现在，足以为该协议签名所需的路由器，并且它将具有必要的方法。 </p><br><pre> <code class="swift hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">protocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeedRouterProtocol</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showDetail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(viewModel: FeedDetailViewModelProtocol)</span></span></span></span> } <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extension</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">FeedRouterProtocol</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">where</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Self</span></span></span><span class="hljs-class">: </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">BaseRouter</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">showDetail</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(viewModel: FeedDetailViewModelProtocol)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> vc = <span class="hljs-type"><span class="hljs-type">FeedDetailViewController</span></span>() vc.viewModel = viewModel sourceViewController?.navigationController?.pushViewController(vc, animated: <span class="hljs-literal"><span class="hljs-literal">true</span></span>) } }</code> </pre> <br><h2 id="view"> 检视 </h2><br><p> 传统上，视图负责向用户显示信息并处理用户操作。 在MVVM中，我们认为ViewController是一个View。 重要的是，ViewModel中不应该包含任何复杂的逻辑。 无论如何，即使在MVC中，也很难重载ViewController，尽管这样做很难。 </p><br><p> 查看命令ViewModel。 如果加载了ViewController，则提供ViewModel命令：从网络或从缓存加载数据。  View还接受来自ViewModel的信号。 如果ViewModel说发生了某些变化（例如，数据已经加载），则View会对它做出反应并重新绘制。 </p><br><p> 我们不使用情节提要。 导航与ViewController紧密相关，很难融入到架构中。 情节提要中经常会发生冲突，这是一个单独的“乐趣”，需要编辑。 </p><br><h2 id="chto-delat-dalshe"> 接下来要做什么？ </h2><br><p> 您可以为模型使用代码生成（可翻译），因为现在已手动注册了从数据库对象到计划对象的所有初始化过程，反之亦然。 </p><br><p> 您还可以使用更通用的查询方案，因为许多服务方法如下所示：转到网络，应用映射，保存到数据库。 也可以将其通用化以设置通用骨架。 </p><br><p> 我们已经考虑了架构方法，但不要忘记，高质量的应用程序不仅是架构，而且是平滑，响应迅速，方便的界面。 爱您的用户并编写优质的应用程序。 </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN458590/">https://habr.com/ru/post/zh-CN458590/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN458572/index.html">Anatoly Slyusar：“欧盟计算机时代允许我们训练系统和应用程序员”</a></li>
<li><a href="../zh-CN458574/index.html">如何从开发人员成长为团队负责人并与之进一步共处</a></li>
<li><a href="../zh-CN458576/index.html">Web应用程序中的文本管理和本地化</a></li>
<li><a href="../zh-CN458582/index.html">亚马逊工程师创造了一种AI阻止设备，将猫拒之门外</a></li>
<li><a href="../zh-CN458584/index.html">7月11日，Group-IB网络研讨会“针对初学者的恶意软件分析：基本方法”</a></li>
<li><a href="../zh-CN458592/index.html">从高Ceph延迟到使用eBPF / BCC的内核补丁</a></li>
<li><a href="../zh-CN458594/index.html">不要忘记使用L7平衡中的重复请求来增加对客户端做出响应的机会</a></li>
<li><a href="../zh-CN458596/index.html">小巧的小乐趣＃6：OpenAI Gym-玩游戏和控制机器人</a></li>
<li><a href="../zh-CN458598/index.html">在环境地图上识别光源</a></li>
<li><a href="../zh-CN458600/index.html">什么是电动自行车（在两个制造商的五个型号的两个部分中进行的小组审查），第1部分</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>