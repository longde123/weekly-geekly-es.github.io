<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🤝‍👨🏻 👩🏻‍🍳 🎩 如何以及为什么在git中偷树 🕕 🈲 🍺</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在本文中，我将讨论使用git的一个有用但鲜为人知的技巧-如何使用另一个提交中的树轻松创建一个提交。 简而言之，如何在分支上获取项目的期望状态（如果该状态之前已经存在于存储库中的某个位置）。 将给出几个示例，说明如何优雅地解决一些实际问题。 特别是，我将讨论我发现的方法，该方法可以大大简化在重新设置基...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>如何以及为什么在git中偷树</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/433748/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/gu/kk/lu/gukklu2hqqy4qrjdnixfkmligiq.jpeg" alt="树木"></a> </p><br><p> 在本文中，我将讨论使用git的一个有用但鲜为人知的技巧-如何使用另一个提交中的树轻松创建一个提交。 简而言之，如何在分支上获取项目的期望状态（如果该状态之前已经存在于存储库中的某个位置）。 将给出几个示例，说明如何优雅地解决一些实际问题。 特别是，我将讨论我发现的方法，该方法可以大大简化在重新设置基准期间纠正多个冲突的方法。 另外，本文是在实践中理解git提交内容的好方法。 </p><a name="habracut"></a><br><h3 id="soderzhanie">  <strong>目录内容</strong> </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">理论部分。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">关于提交和树</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">git提交树</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">实践部分</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">1.与另一个分支同步</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">2.两个分支的比较</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">3.分支反向</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">4.部分反转</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">5.人工合并</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">6a。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">通过合并重新设置方法-描述</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">6b。</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">通过合并重新设置方法-脚本</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">7.别名</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">结论</a> </p><br><a name="theory"></a><br><h3 id="teoreticheskaya-chast-pro-kommity-i-derevya">  <strong>理论部分。</strong>  <strong>关于提交和树</strong> </h3><br><p> 提交可能是git中最基本的概念，让我们看看它的组成。 每个提交都有其自己的唯一标识符，该标识符以哈希形式表示，例如<strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">5e45ecb</a></strong> 。 并使用以下命令，了解了哈希，就可以看到其内容。 </p><br><pre><code class="bash hljs">git cat-file -p 5e45ecb</code> </pre> <br><pre> <code class="plaintext hljs">tree 8640790949c12690fc71f9abadd7b57ec0539376 parent 930741d1f5fd2a78258aa1999bb4be897ba3d015 author Mark Tareshawty &lt;tareby...@github.com&gt; 1542718283 -0500 committer Mark Tareshawty &lt;tareby...@github.com&gt; 1542718283 -0500 gpgsig -----BEGIN PGP SIGNATURE----- ... -----END PGP SIGNATURE----- Fix scoping so that we don't break the naming convention</code> </pre> <br><p> 以下几行是提交的全部内容： </p><br><ul><li> 树-指向特定项目状态的链接 </li><li>  parent-链接到父提交 </li><li> 作者-最初提交的作者+日期 </li><li>  committer-此提交的创建者+日期 </li><li>  gpgsig-数字签名（如果有） </li><li> 消息-提交文本 </li></ul><br><p> 让我提醒您，git中的提交（与其他VCS不同）没有描述所做的更改。 恰恰相反：每次提交都描述了整个项目的特定状态，而我们所做的更改实际上是与先前状态相比的动态计算差异。 还值得注意的是，所有提交都是不可变的（例如，不可变的），例如，使用rebase / cherry-pick / amend可以创建绝对的新提交。 </p><br><p> 树（树）-实际上，它只是一个具有特定不变内容的文件夹。 树类型的对象包含具有特定内容（斑点）和子文件夹（树）的文件列表。 每个提交所指向的树是项目的根文件夹，或者是其特定状态。 </p><br><div class="spoiler">  <b class="spoiler_title">查看树内容</b> <div class="spoiler_text"><p> 对于其他任何对象（提交/树/ blob），都可以采用完全相同的方式进行操作，并且足以采用前几个唯一的哈希字符：8640790949c12690fc71f9abadd7b57ec0539376-&gt; 8640790。 </p><br><pre> <code class="bash hljs">git cat-file -p 8640790</code> </pre> <br><pre> <code class="bash hljs">100644 blob 7ab08294a46f158c51460be3e7df6a190e15023b .env.example 100644 blob 0a1a4d1ad9ff3f35b67678ca893811e91b423af5 .gemset 040000 tree 033aa38ce0eab11fe229067c14ccce95e2b8b601 .github 100644 blob ca49bb7ffa6273b0be4ce7ba1accba456032fb11 .gitignore 100644 blob c99d2e7396e14ac072c63ec8419d9b8fede28d86 .rspec 100644 blob 65e77a2f59f635a8f24eb4714e8e43745c5c0eb9 .rubocop.yml 100644 blob 8e8299dcc068356889b365e23c948b92c6dfcd78 .ruby-version 100644 blob 19028f9885948aca2ba61f9d062e9dc21c21ad03 .stylelintrc.json 100644 blob 2f7a032fbc3f4f7195bfd91cb33889a684b572b9 .travis.yml 100644 blob 121615722a6c206a9fe24b9a1c9b647662a460d2 ARCHITECTURE.md 100644 blob 898195daeea0bbf8c5930deeaf1020ba8abab34a Gemfile 100644 blob de7ca707f9fe9172db941b65cdacaba7e024fc06 Gemfile.lock 100644 blob e6ff62fefd071b1a8ca279bae94ddbc4dd17b7a3 Gruntfile.js 100644 blob 0cac5b30fb32d36cce2aeb7d936be7b6207d68c7 MIT-LICENSE.txt 100644 blob c2c566e8cc3d440d3ee8041b79cded416db28136 Procfile 100644 blob d1fb2f575380e1e093a4d82e3f19e51f0b99a0a1 Procfile.dev 100644 blob 3a88e138f10fa65bd2cfe1a1d3292348205508b5 README.md 100644 blob 5366e6e073cc426518894cc379d3a07cf3c9cfb3 Rakefile 100644 blob e6d3d2d3e9d5122c5f75bbeee8ed0917ad38c131 app.json 040000 tree 94f83cf03bd6f1cf14672034877b14604744b7a2 app 040000 tree d4d859e82564250b4c4f2047de21e089e7555475 bin 100644 blob 1f71007621f17334fd6f2dd71c87b7a16867119c config.ru 040000 tree 9e8e4bf5ec44541aefff544672b94ca8a9d07bbf config 040000 tree 31b8d0e1fa2bb789dbd6319e04fc9f115952cf2a db 040000 tree 38e7a13e0e772c2a13e46d2007e239f679045bee doc 040000 tree a6e35ded8b35837660cf786e637912377f845515 lib 040000 tree d564d0bc3dd917926892c55e3706cc116d5b165e <span class="hljs-built_in"><span class="hljs-built_in">log</span></span> 100644 blob 843523565ddee5e00f580d9c4e37fc2478fdaecc package-lock.json 100644 blob 791ee833ad316d75b1d2c83a64a3053fc952d254 package.json 040000 tree 4645317c52675d9889f89b26f4dd4d2ae1d8cbad public 040000 tree 31d3f8ae4a4ffe62787134642743ed32a35dbae2 resources 040000 tree 807ffa29868ef9c25ddb4b4126a4bb7f1b041bf0 script 040000 tree 4c3bf9a7f3679ba059b0f1c214a500d197546462 spec 040000 tree 136c8174412345531a9542cafef25ce558d2664f <span class="hljs-built_in"><span class="hljs-built_in">test</span></span> 040000 tree e6524eafe066819e4181bc56c503320548d8009b vendor</code> </pre> </div></div><br><p> 这实际上是git如何工作的最重要特征，提交标识符实际上是其内容的哈希。 就像嵌入其中的对象（树，斑点）的哈希一样。 </p><br><p> 现在让我们看看当我们这样做时会发生什么 </p><br><pre> <code class="bash hljs">git commit -m <span class="hljs-string"><span class="hljs-string">"Fixed bug"</span></span></code> </pre> <br><p> 此命令创建一个新提交，捕获以下内容： </p><br><ul><li> 暂存项目的状态（另存为新的树对象并采用其哈希值） </li><li> 链接到当前（父）提交 </li><li> 作者+提交者+两个日期 </li><li> 提交文字 </li></ul><br><p> 全部保存，散列，并获得新的提交对象。 然后，团队会自动将当前分支指针引发到该分支。 </p><br><div class="spoiler">  <b class="spoiler_title">关于术语的一点点</b> <div class="spoiler_text"><p> 众所周知，tree是一个对象，它包含过去某个时刻的项目状态-使用此树创建提交时。 </p><br><p> 工作文件夹称为工作树/工作副本/工作目录，这很合逻辑。 </p><br><p> 我们还具有-暂存区域/索引-准备好的更改区域。  <strong>但从逻辑上讲，这也是一棵树</strong> ，或者更确切地说，是提交为树时保存的状态。 因此，在我看来，调用分级树会更合乎逻辑。 </p></div></div><br><a name="commit-tree"></a><br><h3 id="git-commit-tree">  <strong>git提交树</strong> </h3><br><p> 最后，我们可以继续描述所需的<strong>git commit-tree</strong>命令。 形式上，这是低级命令之一，因此很少提及和使用。 我们不会考虑与其关联的其他低级命令（例如git write-tree，git-update-index，它们也称为管道命令）。 我们只对一个特定的结果感兴趣：使用此命令，我们可以轻松地从任何其他提交中复制（重用）项目状态树。 </p><br><p> 看她的挑战 </p><br><pre> <code class="bash hljs">git commit-tree 4c835c2 -m <span class="hljs-string"><span class="hljs-string">"Fixed bug"</span></span> -p a8fc5e3</code> </pre> <br><pre> <code class="plaintext hljs">d9aded78bf57ca906322e26883644f5f36cfdca5</code> </pre> <br><p>  git commit-tree命令也可以进行提交，但是以低级方式进行。 在这里，您必须显式指定已经存在的树（树）4c835c2以及到父提交a8fc5e3的链接。 并且它返回新提交d9aded7的哈希，并且分支的位置没有更改（因此，此提交似乎已冻结）。 </p><br><a name="practice"></a><br><h3 id="prakticheskaya-chast">  <strong>实践部分</strong> </h3><br><p> 以下简单的存储库中演示了使用此命令的示例。 </p><br><img src="https://habrastorage.org/webt/ft/ot/to/ftottogtrm5xmyiqmbz1_loijuy.png"><br><p> 它包含三个分支： </p><br><p> 主-主分支 <br>  alpha-我们工作所在的分支 <br>  beta-先前停在master中的分支 </p><br><p> 所有操作都易于在本地重复，因此只需克隆存储库，进入alpha分支，然后执行示例中的命令就足够了。 此初始状态是所有示例共有的。 </p><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/capslocky/git-commit-tree-example.git <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ./git-commit-tree-example/ git checkout alpha</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">在窗户下</b> <div class="spoiler_text"><p> 所有命令（包括脚本）也在Windows下运行。 您只需要在项目文件夹中打开bash终端，例如这样 </p><br><pre> <code class="plaintext hljs">"C:\Program Files\Git\git-bash.exe" --cd="D:\path\project"</code> </pre> </div></div><br><a name="z1"></a><br><h3 id="1-sinhronizaciya-s-drugoy-vetkoy">  <strong>1.与另一个分支同步</strong> </h3><br><p> 挑战： <br> 将<strong>alpha</strong>分支上的项目状态与<strong>beta</strong>分支同步。 也就是说，您需要在<strong>alpha</strong>分支上创建这样的新提交，以便项目状态变得与<strong>beta</strong>分支上的完全相同。 </p><br><p> 具体而言，这种任务不太可能出现，但这是最合适的方法来演示该方法。 </p><br><p> 最简单的解决方案是获取beta分支指向的现有树，然后从alpha分支的新提交中仅指向它。 由于这是第一个示例，因此将充分详细地考虑其所有逻辑。 </p><br><p> 首先，找到beta分支指向的提交哈希： </p><br><pre> <code class="bash hljs">git rev-parse origin/beta</code> </pre> <br><pre> <code class="bash hljs">280c30ff81a574f8dd41721726cf60b22fb2eced</code> </pre> <br><p>  <strong>280c30f-</strong>仅需输入前几个字符 </p><br><p> 现在通过通过git cat-file显示提交的内容来找到其树的哈希： </p><br><pre> <code class="bash hljs">git cat-file -p 280c30f</code> </pre> <br><pre> <code class="plaintext hljs">tree 3c1afe75f54518dbd82ea7a4e3c4ff50389a573a &lt;--- parent 560b449675513bc8f8f4d6cda56a922d4e36917a author Baur &lt;atanov...@gmail.com&gt; 1540619512 +0600 committer Baur &lt;atanov...@gmail.com&gt; 1540619512 +0600 Added info about windows</code> </pre> <br><p>  <strong>3c1afe7-</strong>这是我们需要的树 </p><br><p> 现在，我们将创建一个指向该树的提交，并使用父提交来指示当前提交： </p><br><pre> <code class="bash hljs">git commit-tree 3c1afe7 -m <span class="hljs-string"><span class="hljs-string">"Synced with branch 'beta'"</span></span> -p HEAD</code> </pre> <br><pre> <code class="bash hljs">eb804d403d4ec0dbeee36aa09da706052a7cc687</code> </pre> <br><p> 就是这样，提交已创建，团队获得了哈希值。 而且，此值将始终是唯一的，因为它不仅是根据树计算的，而且还根据作者和时间来计算的。 只要提交不进入任何分支，提交本身就会被冻结。 对于我们来说，只需输入前几个字符就足够了： <strong>eb804d4</strong> ，这个<strong>值</strong>对于每种情况都是唯一的，我将其指定为<strong>xxxxxxx</strong> 。 让我们看一下它的内容： </p><br><pre> <code class="bash hljs">git cat-file -p xxxxxxx</code> </pre> <br><pre> <code class="plaintext hljs">tree 3c1afe75f54518dbd82ea7a4e3c4ff50389a573a &lt;--- parent 64fafc79e8f6d22f5226490daa5023062299fd6c author Peter &lt;peter...@gmail.com&gt; 1545230299 +0600 committer Peter &lt;peter...@gmail.com&gt; 1545230299 +0600 Synced with branch 'beta'</code> </pre> <br><p> 太好了，它具有与origin / beta分支上的提交相同的树。 并且由于此提交是当前分支的直接后代，因此要将其包括在分支中，只需进行快进合并 </p><br><pre> <code class="bash hljs">git merge --ff xxxxxxx</code> </pre> <br><pre> <code class="plaintext hljs">Updating 64fafc7..xxxxxxx Fast-forward Azure.txt | 3 --- Bill.txt | 6 +----- Linus.txt | 15 +++++++++++++++ 3 files changed, 16 insertions(+), 8 deletions(-)</code> </pre> <br><p> 做完了 现在，alpha分支上的项目状态与beta分支上的状态完全相同。  <strong>[更新]</strong>如果您查看此提交毕竟发生了什么变化，我们将看到：它颠倒了alpha分支的所有自身提交（更改），并添加了beta分支相对于其共同祖先提交的所有唯一提交（更改）。 </p><br><img src="https://habrastorage.org/webt/6r/cp/9j/6rcp9jjsridsnn297yjyhaa3e-e.png"><br><a name="z2"></a><br><h3 id="2-sravnenie-dvuh-vetok">  <strong>2.两个分支的比较</strong> </h3><br><p> 挑战： <br> 比较<strong>alpha</strong>分支和<strong>beta</strong>分支。 </p><br><p> 第一个示例显示创建的提交显示所有更改，这是两个分支之间的实际差异。 通过此属性，可以轻松地将一个分支与另一个分支进行比较。 创建第三个临时分支并在其中进行类似的提交就足够了。 </p><br><p> 因此，首先，将Alpha分支返回其原始状态 </p><br><pre> <code class="bash hljs">git reset --hard origin/alpha</code> </pre> <br><p> 让我们在当前分支上创建一个临时分支并将其站立 </p><br><pre> <code class="bash hljs">git checkout -b temp</code> </pre> <br><p> 剩下的工作与前面的示例相同。 但是这次我们将碰面。 为此，我们使用特殊语法来访问提交树<strong>origin / beta ^ {tree}</strong>或相同的<strong>280c30f ^ {tree}</strong> 。 </p><br><pre> <code class="bash hljs">git merge --ff $(git commit-tree origin/beta^{tree} -m <span class="hljs-string"><span class="hljs-string">"Diff with branch 'beta'"</span></span> -p HEAD)</code> </pre> <br><p> 完成，本质上我们实现为两个分支之间的提交差异 </p><br><pre> <code class="bash hljs">git show</code> </pre> <br><pre> <code class="bash hljs">git diff alpha origin/beta</code> </pre> <br><p> 当然，我们可以为存储库中的任何两个提交（状态）创建这样的“比较”提交。 </p><br><img src="https://habrastorage.org/webt/bd/eq/nt/bdeqntgdkpows5ly0zc7ahzjgf8.png"><br><a name="z3"></a><br><h3 id="3-revert-vetki">  <strong>3.分支反向</strong> </h3><br><p> 挑战： <br> 回滚最近的几次提交。 </p><br><p> 让我们回到alpha分支并删除temp分支 </p><br><pre> <code class="bash hljs">git checkout alpha git branch -D temp</code> </pre> <br><p> 假设我们需要回滚alpha分支上的最后两次提交。 有两种经典的方法可以做到这一点： </p><br><ol><li> 运行git revert两次-每次提交 </li><li>  git reset，即重置分支位置 </li></ol><br><p> 但是您可以通过第三种方式来做到这一点： </p><br><pre> <code class="bash hljs">git merge --ff $(git commit-tree 7a714bf^{tree} -m <span class="hljs-string"><span class="hljs-string">"Reverted to commit 7a714bf"</span></span> -p HEAD)</code> </pre> <br><p> 这将添加一个新提交，该新提交将回滚前两个提交的更改。 与第一种方法不同，即使您需要回滚最后十次提交，也只会创建一个提交。  git reset方法的区别在于我们不从分支本身抛出这些提交。 </p><br><p> 此外，如果您需要返回分支的原始状态，则可以用相同的方式完成 </p><br><pre> <code class="bash hljs">git merge --ff $(git commit-tree 64fafc7^{tree} -m <span class="hljs-string"><span class="hljs-string">"Reverted back to commit 64fafc7"</span></span> -p HEAD)</code> </pre> <br><p> 同时，这两个提交将保留在分支的历史记录中，根据该历史记录，可以看到该分支已回滚并返回。 </p><br><img src="https://habrastorage.org/webt/2a/w_/g_/2aw_g_0m9m2vf8zs9sqh_c4ozw8.png"><br><a name="z4"></a><br><h3 id="4-chastichnyy-revert">  <strong>4.部分反转</strong> </h3><br><p> 挑战： <br> 在最近的几次提交中将更改回滚到某些文件。 </p><br><p> 再次，将Alpha分支返回其原始状态 </p><br><pre> <code class="bash hljs">git reset --hard origin/alpha</code> </pre> <br><p>  alpha分支包含3个提交，每个提交都对Bill.txt文件进行了更改，在最后一次提交中，还添加了Azure.txt文件。 假设我们需要将对最后2次提交的更改回滚到Bill.txt文件，而不涉及任何其他文件。 </p><br><p> 首先，回滚所有文件2提交 </p><br><pre> <code class="bash hljs">git merge --ff $(git commit-tree 7a714bf^{tree} -m <span class="hljs-string"><span class="hljs-string">"any text"</span></span> -p HEAD)</code> </pre> <br><p> 接下来，将分支返回到上一个提交，但不影响磁盘上项目的状态 </p><br><pre> <code class="bash hljs">git reset HEAD~1</code> </pre> <br><p> 现在，只需足够必要的文件并提交，就可以丢弃其他更改。 </p><br><pre> <code class="bash hljs">git add Bill.txt git commit -m <span class="hljs-string"><span class="hljs-string">"Reverted file Bill.txt to 7a714bf"</span></span> git reset --hard HEAD</code> </pre> <br><img src="https://habrastorage.org/webt/0p/8g/yy/0p8gyybuacise2ffx4qka3relhw.png"><br><a name="z5"></a><br><h3 id="5-iskustvennyy-merge">  <strong>5.人工合并</strong> </h3><br><p> 挑战： <br> 将一个分支增加到另一个分支，以获得预定结果。 </p><br><p> 想象一下这种情况。 在生产中已检测到一个严重的错误，并且与往常一样，需要紧急修复。 但是，尚不清楚需要花费多少时间来研究它并做出正确的修补程序，因此迅速制作了一个临时修补程序，该修补程序隔离了与问题模块的交互。 因此，在master分支中，将出现带有此临时补丁的提交，并且一段时间后，而不是在master中提交，您需要处理一个已经成熟的修补程序。 </p><br><p> 因此，我们需要合并master中的alpha分支，但是当从alpha分支的所有唯一更改都从上方添加到master中并且存在冲突时，这不应该是传统的合并，并且我们必须用alpha分支完全覆盖master。 </p><br><p> 首先，让我们回想一下合并提交的全部含义-实际上是相同的普通提交，但是它只有两个父提交，如果您查看其内容（其树的形成方式是一个单独的问题），就可以清楚地看到。 。 由谁决定谁是简单的-第一次父提交被认为是主要提交。 </p><br><pre> <code class="plaintext hljs">git cat-file -p 7229df8</code> </pre> <br><pre> <code class="bash hljs">tree 3c1afe75f54518dbd82ea7a4e3c4ff50389a573a parent fd54ab7dde87593b9892b6d1ffbf1afd39ba6f9e parent 280c30ff81a574f8dd41721726cf60b22fb2eced author Baur &lt;atanov...@gmail.com&gt; 1540619579 +0600 committer Baur &lt;atanov...@gmail.com&gt; 1540619592 +0600 Merge branch <span class="hljs-string"><span class="hljs-string">'beta'</span></span> into <span class="hljs-string"><span class="hljs-string">'master'</span></span></code> </pre> <br><p> 重置当前的Alpha分支并切换到母版 </p><br><pre> <code class="bash hljs">git reset --hard origin/alpha git checkout master</code> </pre> <br><p> 现在是同一个团队，但是有<strong>两个</strong>父提交 </p><br><pre> <code class="bash hljs">git merge --ff $(git commit-tree alpha^{tree} -m <span class="hljs-string"><span class="hljs-string">"Merge 'alpha' into 'master', but take 'alpha' tree"</span></span> -p HEAD -p alpha)</code> </pre> <br><p> 完成后，我们在master中暂存了alpha分支，并且不必删除临时代码并解决冲突，因为在这种情况下，我们只需要重写最新的更改即可。 </p><br><img src="https://habrastorage.org/webt/y3/qa/p_/y3qap_rct5emnkmqfirrhtmhmlg.png"><br><p> 实际上，与从另一次提交复制的树创建合并并不奇怪。 之所以会出现这种情况，是因为git是一种非常灵活的工具，它使您可以实现用于处理分支和存储库的多种方法。 但是，最常见的示例还是从一开始就在我们的存储库中-尝试自己解析它或打开破坏器以阅读说明。 </p><br><div class="spoiler">  <b class="spoiler_title">扰流板</b> <div class="spoiler_text"><p> 让我们注意一下beta分支是如何被扼杀回master的。 在其中出现两次提交期间，master分支本身中没有新的提交。 这意味着在主版中使用合并beta时，由于同时发生更改，因此排除了任何冲突。 </p><br><img src="https://habrastorage.org/webt/ld/b2/9c/ldb29c4suiipfkkwc4qmozqxc9i.png"><br><img src="https://habrastorage.org/webt/mb/c8/za/mbc8za3pa9q9hmlcuvblb1holzk.png"><br><p> 如果我们进行了git merge beta，则将发生快进合并（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">默认</a>行为），也就是说，master分支将与beta分支处于同一提交，并且不会进行合并提交。 就像这样： </p><br><img src="https://habrastorage.org/webt/sb/xb/ir/sbxbirjlbr69iwl0e6qfymenwb0.png"><br><p> 但是这里没有使用git merge beta --no-ff命令进行快速合并。 也就是说，尽管没有必要，我们还是强制创建了合并提交。 而且由于知道了将来合并所需的项目最终状态-这是一个beta树，git只需将指向该树的链接复制到新提交中： </p><br><pre> <code class="bash hljs">git cat-file -p origin/beta</code> </pre> <br><pre> <code class="bash hljs">tree 3c1afe75f54518dbd82ea7a4e3c4ff50389a573a &lt;--- parent 560b449675513bc8f8f4d6cda56a922d4e36917a author Baur &lt;atanov...@gmail.com&gt; 1540619512 +0600 committer Baur &lt;atanov...@gmail.com&gt; 1540619512 +0600 Added info about windows</code> </pre> <br><pre> <code class="bash hljs">git cat-file -p 7229df8</code> </pre> <br><pre> <code class="bash hljs">tree 3c1afe75f54518dbd82ea7a4e3c4ff50389a573a &lt;--- parent fd54ab7dde87593b9892b6d1ffbf1afd39ba6f9e parent 280c30ff81a574f8dd41721726cf60b22fb2eced author Baur &lt;atanov...@gmail.com&gt; 1540619579 +0600 committer Baur &lt;atanov...@gmail.com&gt; 1540619592 +0600 Merge branch <span class="hljs-string"><span class="hljs-string">'beta'</span></span> into <span class="hljs-string"><span class="hljs-string">'master'</span></span></code> </pre> </div></div><br><a name="z6a"></a><br><h3 id="6a-metod-rebase-cherez-merge---opisanie">  <strong>6a。</strong>  <strong>通过合并重新设置方法-描述</strong> </h3><br><p> 挑战： <br> 有必要建立一个“大量”的rebase分支（在不同的提交上有很多冲突）。 </p><br><p>  git中有一个经典的holivar主题-rebase vs merge。 但是我不会胡扯。 相反，我将谈谈如何在此任务范围内结识他们。 </p><br><p> 通常，git是经过专门设计的，因此我们可以有效地进行合并。 当我来到工作流基于rebase的项目时，我第一次感到不舒服和不寻常，直到我开发出可以简化git日常工作的技术。 其中之一是我进行大量基准调整的原始方法。 </p><br><p> 因此，我们需要在开发时重新设置alpha分支，以便以后将其与beta分支一样精美地进行染色。 如果我们像往常一样开始变基，则第一次提交和最后一次提交将在两个不同的地方产生两个不同的冲突。 但是，如果不进行基础调整而只是进行合并，则一次合并提交中的一个位置只会有一个冲突。 </p><br><p> 如果您想确保这一点，我会在扰流板下方提供现成的团队。 </p><br><div class="spoiler">  <b class="spoiler_title">隐藏文字</b> <div class="spoiler_text"><p> 使分支恢复到原始状态 </p><br><pre> <code class="bash hljs">git checkout master git reset --hard origin/master git checkout alpha git reset --hard origin/alpha</code> </pre> <br><p> 创建并站在alpha-rebase-conflicts分支上，并以master为基础 </p><br><pre> <code class="bash hljs">git checkout -b alpha-rebase-conflicts git rebase master</code> </pre> <br><p> 各种提交都会有冲突，包括幻影冲突。 </p><br><p> 现在，让我们尝试合并，回到alpha分支并删除该分支以进行变基。 </p><br><pre> <code class="bash hljs">git checkout alpha git branch -D alpha-rebase-conflicts</code> </pre> <br><p> 切换到母版并进行合并 </p><br><pre> <code class="bash hljs">git checkout master git merge alpha</code> </pre> <br><p> 只有一个简单的冲突，我们将其纠正并执行 </p><br><pre> <code class="bash hljs">git add Bill.txt git commit -m <span class="hljs-string"><span class="hljs-string">"Merge branch 'alpha' into 'master'"</span></span></code> </pre> <br><p>  Marge成功完成。 </p></div></div><br><p>  Git冲突是我们生活中很自然的一部分，这个简单的例子表明，就此而言，合并绝对比重新设置更为方便。 在实际项目中，这种差异是通过花费大量时间和精力来衡量的。 因此，例如，存在一个模糊的建议，即在合并之前将功能分支的所有提交压缩为一个提交。 </p><br><p> 这种方法的想法是进行一个临时的隐藏合并，在该合并中我们将立即解决所有冲突。 记住结果（树）。 接下来，运行常规的变基，但是选择“自动解决冲突，选择我们的更改”。 最后，向分支添加一个额外的提交，这将还原正确的树。 </p><br><p> 让我们开始吧。 同样，将两个分支都恢复到其原始状态。 </p><br><pre> <code class="bash hljs">git checkout master git reset --hard origin/master git checkout alpha git reset --hard origin/alpha</code> </pre> <br><p> 让我们创建一个临时分支临时文件，在其中进行合并。 </p><br><pre> <code class="bash hljs">git checkout -b temp git merge origin/master</code> </pre> <br><p> 冲突。 </p><br><p> 让我们照常解决Bill.txt文件中的一个简单冲突（在任何编辑器中）。 <br> 请注意，与rebase一样，只有一个冲突，而不是两个冲突。 </p><br><pre> <code class="bash hljs">git add Bill.txt git commit -m <span class="hljs-string"><span class="hljs-string">"Merge branch 'origin/master' into 'temp'"</span></span></code> </pre> <br><p> 我们返回到alpha分支，为自动解决所有冲突做好基础，并将temp分支带入状态，并删除temp分支本身。 </p><br><pre> <code class="bash hljs">git checkout alpha git rebase origin/master -X theirs git merge --ff $(git commit-tree temp^{tree} -m <span class="hljs-string"><span class="hljs-string">"Fix after rebase"</span></span> -p HEAD) git branch -D temp</code> </pre> <br><img src="https://habrastorage.org/webt/0c/dh/ou/0cdhoulztbrr4eskxlrotkxgjg0.png"><br><p> 最后，大师中精美的mergim alpha。 </p><br><pre> <code class="bash hljs">git checkout master git merge alpha --no-ff --no-edit</code> </pre> <br><img src="https://habrastorage.org/webt/jj/aw/om/jjawom3amg15ki9ob7_osbahzdo.png"><br><p> 请注意，尽管master，alpha和remote temp分支都是三个不同的提交，但它们都指向同一棵树。 </p><br><p> 这种方法的缺点： </p><br><ul><li> 没有每个冲突提交的手动更正-冲突会自动解决。 这样的中间提交可能无法编译。 </li><li> 在每个基础上添加（但不总是）额外提交 </li></ul><br><p> 优点： </p><br><ul><li> 我们只解决实际冲突（没有幻影冲突） </li><li> 所有冲突仅修复一次。 </li><li> 前两点节省时间 </li><li> 保存了提交和所有更改的完整历史记录（例如，您可以进行选择） </li><li> 该方法以脚本的形式实现，并且在必要时始终可以用于变基（它不需要任何有关树的知识，等等）。 </li></ul><br><a name="z6b"></a><br><h3 id="6b-metod-rebase-cherez-merge---skript">  <strong>6b。</strong>  <strong>通过合并重新设置方法-脚本</strong> </h3><br><p> 该脚本发布在这里： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https</a> : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">//github.com/capslocky/git-rebase-via-merge</a> </p><br><p> 让我们在示例中检查其工作。 同样，将两个分支都恢复到原始状态 </p><br><pre> <code class="bash hljs">git checkout master git reset --hard origin/master git checkout alpha git reset --hard origin/alpha</code> </pre> <br><p> 下载脚本并使其可执行 </p><br><pre> <code class="bash hljs">curl -L https://git.io/rebase-via-merge -o ~/git-rebase-via-merge.sh chmod +x ~/git-rebase-via-merge.sh</code> </pre> <br><div class="spoiler">  <b class="spoiler_title">窗户</b> <div class="spoiler_text"><p> 该文件将显示在这里：C：\ Users \用户名\ git-rebase-via-merge.sh </p></div></div><br><p> 更改您需要为其重新设置基础的默认分支，在本例中，我们需要origin / master </p><br><pre> <code class="bash hljs">nano ~/git-rebase-via-merge.sh</code> </pre> <br><pre> <code class="bash hljs">default_base_branch=<span class="hljs-string"><span class="hljs-string">'origin/master'</span></span></code> </pre> <br><p> 我们还创建并站在一个临时分支上，以免碰到alpha分支本身 </p><br><pre> <code class="bash hljs">git checkout -b alpha-rebase-test</code> </pre> <br><p> 现在，您可以运行脚本（而不是传统的git rebase起源/主服务器） </p><br><pre> <code class="bash hljs">~/git-rebase-via-merge.sh</code> </pre> <br><img src="https://habrastorage.org/webt/hi/nx/fw/hinxfwidwz65f9et23qqn9daxdi.png"><br><div class="spoiler">  <b class="spoiler_title">脚本结果</b> <div class="spoiler_text"><pre> <code class="bash hljs">$ ~/git-rebase-via-merge.sh This script will perform rebase via merge. Current branch: alpha-rebase-test (64fafc7) Base branch: origin/master (9c6b60a) Continue (c) / Abort (a) c Auto-merging Bill.txt CONFLICT (content): Merge conflict <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> Bill.txt Automatic merge failed; fix conflicts and <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> commit the result. You have at least one merge conflict. Fix all conflicts <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> the following files, stage them up and <span class="hljs-built_in"><span class="hljs-built_in">type</span></span> <span class="hljs-string"><span class="hljs-string">'c'</span></span>: Bill.txt Continue (c) / Abort (a) c [detached HEAD 785d49e] Hidden temp commit to save result of merging <span class="hljs-string"><span class="hljs-string">'origin/master'</span></span> into <span class="hljs-string"><span class="hljs-string">'alpha-rebase-test'</span></span> as detached head. Merge succeeded on hidden commit: 785d49e Starting rebase automatically resolving any conflicts <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> favor of current branch. First, rewinding head to replay your work on top of it... Auto-merging Bill.txt [detached HEAD a680316] Added <span class="hljs-built_in"><span class="hljs-built_in">history</span></span> of windows Author: Baur &lt;atanov...@gmail.com&gt; Date: Sat Oct 27 11:45:50 2018 +0600 1 file changed, 6 insertions(+), 3 deletions(-) Committed: 0001 Added <span class="hljs-built_in"><span class="hljs-built_in">history</span></span> of windows Auto-merging Bill.txt [detached HEAD dcd34a8] Replaced <span class="hljs-built_in"><span class="hljs-built_in">history</span></span> of windows Author: Baur &lt;atanov...@gmail.com&gt; Date: Sat Oct 27 11:55:42 2018 +0600 1 file changed, 4 insertions(+), 5 deletions(-) Committed: 0002 Replaced <span class="hljs-built_in"><span class="hljs-built_in">history</span></span> of windows Auto-merging Bill.txt [detached HEAD 8d6d82c] Added file about Azure and info about Windows 10 Author: Baur &lt;atanov...@gmail.com&gt; Date: Sat Oct 27 12:06:27 2018 +0600 2 files changed, 5 insertions(+), 3 deletions(-) create mode 100644 Azure.txt Committed: 0003 Added file about Azure and info about Windows 10 All <span class="hljs-keyword"><span class="hljs-keyword">done</span></span>. Restoring project state from hidden merge with single additional commit. Updating 8d6d82c..268b320 Fast-forward Bill.txt | 4 ++++ 1 file changed, 4 insertions(+) Done.</code> </pre> </div></div><br><p>       </p><br><pre> <code class="bash hljs">~/git-rebase-via-merge.sh origin/develop</code> </pre> <br><p>   ,  ours / theirs     : </p><br><p> ours —       (HEAD) <br> theirs —      (, origin/develop) </p><br><p>      rebase —    . </p><br><a name="z7"></a><br><h3 id="7-alias"> <strong>7. </strong> </h3><br><p>    git       . </p><br><p>      . </p><br><pre> <code class="bash hljs">git config alias.copy <span class="hljs-string"><span class="hljs-string">'!git merge --ff $(git commit-tree ${1}^{tree} -p HEAD -m "Tree copy from ${1}")'</span></span></code> </pre> <br><p>     git copy xxx,  xxx —    . </p><br><pre> <code class="bash hljs">git copy xxx</code> </pre> <br><p>        </p><br><pre> <code class="bash hljs">git merge --ff $(git commit-tree xxx^{tree} -p HEAD -m <span class="hljs-string"><span class="hljs-string">"Tree copy from xxx"</span></span>)</code> </pre> <br><p>  </p><br><pre> <code class="bash hljs">git copy a8fc5e3</code> </pre> <br><pre> <code class="bash hljs">git copy origin/beta</code> </pre> <br><pre> <code class="bash hljs">git copy HEAD~3</code> </pre> <br><p>           git amend. </p><br><pre> <code class="bash hljs">git commit --amend -m <span class="hljs-string"><span class="hljs-string">"Just for test"</span></span></code> </pre> <br><p>   : </p><br><pre> <code class="bash hljs">git commit --amend</code> </pre> <br><a name="end"></a><br><h3 id="zaklyuchenie"> <strong></strong> </h3><br><p>   ,           ,      .    ,   .  —  .    , ,   .           .   "  "  "   "   .         ( ,   devops), ,   . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN433748/">https://habr.com/ru/post/zh-CN433748/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN433734/index.html">唐纳德·克努斯（Donald Knuth）：“年长的同志们打网球，我们是球。 他们打我们，很伤人。” （11,12 / 97）</a></li>
<li><a href="../zh-CN433738/index.html">上古：我们未选择的MS-DOS下的游戏</a></li>
<li><a href="../zh-CN433740/index.html">国家杜马取消三读国家漫游</a></li>
<li><a href="../zh-CN433742/index.html">涡轮喷气</a></li>
<li><a href="../zh-CN433746/index.html">读模因的马尔瓦尔</a></li>
<li><a href="../zh-CN433750/index.html">我们如何在克拉斯诺亚尔斯克度过冬季学校“数字嵌入式系统”</a></li>
<li><a href="../zh-CN433752/index.html">疯狂的卡桑德（Crazy Cassander）谈俄罗斯游戏设计教育的细微差别</a></li>
<li><a href="../zh-CN433754/index.html">Slack禁止从克里米亚开户</a></li>
<li><a href="../zh-CN433756/index.html">魅力Android。 有关移动自动化的信息报告</a></li>
<li><a href="../zh-CN433758/index.html">仿生假体：通过设计自我表达</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>