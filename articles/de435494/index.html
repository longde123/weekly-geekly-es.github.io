<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕺🏽 🐅 💑 Nahtloser Client-Server 🤲🏻 🚒 🎨</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Jedes Client-Server-Projekt impliziert eine klare Trennung der Codebasis in zwei Teile (manchmal mehr) - Client und Server. Oft wird jeder dieser Teil...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Nahtloser Client-Server</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435494/"><img src="https://habrastorage.org/webt/rq/-9/mh/rq-9mhais2g6p5dd5tsfv8rllak.jpeg" align="left">  Jedes Client-Server-Projekt impliziert eine klare Trennung der Codebasis in zwei Teile (manchmal mehr) - Client und Server.  Oft wird jeder dieser Teile in Form eines separaten unabhängigen Projekts ausgeführt, das von einem eigenen Entwicklerteam unterstützt wird. <br><br>  In diesem Artikel schlage ich einen kritischen Blick auf die standardmäßige harte Unterteilung von Code in ein Backend und ein Frontend vor.  Und überlegen Sie sich eine Alternative, bei der der Code keine klare Linie zwischen Client und Server aufweist. <br><br><a name="habracut"></a><br><br><h3>  Nachteile des Standardansatzes </h3><br>  Der Hauptnachteil der Standardaufteilung des Projekts in zwei Teile ist die Erosion der Geschäftslogik zwischen Client und Server.  Wir bearbeiten die Daten im Formular im Browser, überprüfen sie im Kundencode und senden sie an das Dorf des Großvaters (an den Server).  Der Server ist bereits ein anderes Projekt.  Dort müssen Sie auch die Richtigkeit der empfangenen Daten überprüfen (d. H. Die Funktionalität des Clients duplizieren), einige zusätzliche Manipulationen vornehmen (in der Datenbank speichern, E-Mail senden usw.). <br><br>  Um den gesamten Informationspfad vom Formular im Browser zur Datenbank auf dem Server zu verfolgen, müssen wir uns daher mit zwei verschiedenen Systemen befassen.  Wenn die Rollen in einem Team aufgeteilt sind und verschiedene Spezialisten für das Backend und das Frontend verantwortlich sind, treten zusätzliche organisatorische Probleme im Zusammenhang mit ihrer Synchronisation auf. <br><br><h3>  Lass uns träumen </h3><br>  Angenommen, wir können den gesamten Datenpfad vom Formular auf dem Client zur Datenbank auf dem Server in einem Modell beschreiben.  Im Code sieht es möglicherweise so aus (der Code funktioniert nicht): <br><br><pre><code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyDataModel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">//         verifyData(data) { //   .... return true; } //       client saveData(data) { if(this.verifyData(data)) this.writeDataToDb(data) else consol.log('error') } //  .     server writeDataToDb(data) { if(this.verifyData(data)) this.db.insert(data) else consol.log('error') } }</span></span></code> </pre> <br>  Somit liegt die gesamte Geschäftslogik des Modells vor unseren Augen.  Die Pflege eines solchen Codes ist einfacher.  Die Kombination von Client-Server-Methoden in einem Modell bietet folgende Vorteile: <br><br><ol><li>  Die Geschäftslogik ist an einem Ort konzentriert. Sie muss nicht zwischen Client und Server geteilt werden. </li><li>  Während der Entwicklung des Projekts können Sie Funktionen problemlos von Server zu Client oder von Client zu Server übertragen. </li><li>  Es ist nicht erforderlich, dieselben Methoden für das Backend und das Frontend zu duplizieren. </li><li>  Ein einziger Testsatz für die gesamte Geschäftslogik des Projekts. </li><li>  Ersetzen horizontaler Linien der Verantwortungsabgrenzung im Projekt durch vertikale. </li></ol><br>  Ich werde den letzten Punkt genauer erläutern.  Stellen Sie sich eine reguläre Client-Server-Anwendung in Form eines solchen Schemas vor: <br><br><img src="https://habrastorage.org/webt/8x/c9/de/8xc9degimzw-w-ln5w2ihiybi6w.jpeg" width="400"><br><br>  Vasya ist verantwortlich für das Frontend, Fedya - für das Backend.  Die Linie der Verantwortungsabgrenzung verläuft horizontal.  Dieses Schema hat die Nachteile jeder vertikalen Struktur - es ist schwierig zu skalieren und weist eine geringe Fehlertoleranz auf.  Wenn das Projekt erweitert wird, müssen Sie eine ziemlich schwierige Entscheidung treffen: Wen sollen Sie Vasya oder Fedya stärken?  Oder wenn Fedya krank wurde oder aufhörte, kann Vasya ihn nicht ersetzen. <br><br>  Mit dem hier vorgeschlagenen Ansatz können Sie die Aufteilung der Verantwortung um 90 Grad erweitern und die vertikale Architektur in eine horizontale umwandeln. <br><br><img src="https://habrastorage.org/webt/v6/4m/9f/v64m9fuv5sonujosvh4yc4v8vbw.jpeg" width="400"><br><br>  Eine solche Architektur ist viel einfacher zu skalieren und fehlertoleranter.  Vasya und Fedya werden austauschbar. <br><br>  Theoretisch sieht es gut aus. Versuchen wir, all dies in die Praxis umzusetzen, ohne dabei alles zu verlieren, was uns auf diesem Weg die getrennte Existenz von Client und Server ermöglicht. <br><br><h3>  Erklärung des Problems </h3><br>  Wir müssen absolut keinen integrierten Client-Server im Produkt haben.  Im Gegenteil, eine solche Entscheidung wäre unter allen Gesichtspunkten äußerst schädlich.  Die Aufgabe besteht darin, dass wir im Entwicklungsprozess eine einzige Codebasis für Datenmodelle für das Backend und das Frontend haben würden, die Ausgabe jedoch ein unabhängiger Client und Server wäre.  In diesem Fall erhalten wir alle Vorteile des Standardansatzes und erhalten die oben aufgeführten Annehmlichkeiten für die Entwicklung und Unterstützung des Projekts. <br><br><h3>  Lösung </h3><br>  Ich experimentiere seit einiger Zeit mit der Integration von Client und Server in eine Datei.  Bis vor kurzem bestand das Hauptproblem darin, dass in Standard-JS die Verbindung von Modulen von Drittanbietern auf dem Client und dem Server zu unterschiedlich war: erfordern (...) in node.js alle AJAX-Magie auf dem Client.  Mit dem Aufkommen der ES-Module hat sich alles geändert.  In modernen Browsern wird „Importieren“ seit langem unterstützt.  Node.js liegt in dieser Hinsicht leicht zurück und ES-Module werden nur mit aktiviertem Flag "--experimental-modules" unterstützt.  Es ist zu hoffen, dass in absehbarer Zeit Module in node.js sofort funktionieren.  Darüber hinaus ist es unwahrscheinlich, dass sich etwas stark ändert, weil  In Browsern funktioniert diese Funktionalität seit langer Zeit standardmäßig.  Ich denke, dass Sie jetzt ES-Module nicht nur auf dem Client, sondern auch auf der Serverseite verwenden können (wenn Sie Gegenargumente zu diesem Thema haben, schreiben Sie in die Kommentare). <br><br>  Das Lösungsschema sieht folgendermaßen aus: <br><br><img src="https://habrastorage.org/webt/xo/_a/vi/xo_avikvz1udp9-dwhxfe6ypt-q.png" width="600"><br><br>  Das Projekt enthält drei Hauptkataloge: <br><br>  <b>geschützt</b> - Backend; <br>  <b>öffentliches</b> Frontend; <br>  <b>Shared</b> - Shared Client-Server-Modelle. <br><br>  Ein separater Beobachterprozess überwacht Dateien im freigegebenen Verzeichnis und erstellt bei Änderungen Versionen der geänderten Datei separat für den Client und separat für den Server (in den Verzeichnissen protected / shared und public / shared). <br><br><h3>  Implementierung </h3><br>  Betrachten Sie das Beispiel eines einfachen Echtzeit-Messenger.  Wir benötigen frische node.js (ich habe Version 11.0.0) und Redis (deren Installation wird hier nicht behandelt). <br><br>  Klonen Sie ein Beispiel: <br><br><pre> <code class="bash hljs">git <span class="hljs-built_in"><span class="hljs-built_in">clone</span></span> https://github.com/Kolbaskin/both-example <span class="hljs-built_in"><span class="hljs-built_in">cd</span></span> ./both-example npm i</code> </pre><br>  Installieren Sie den Beobachterprozess und führen Sie ihn aus (Beobachter im Diagramm): <br><br><pre> <code class="bash hljs">npm i both-js -g both ./index.mjs</code> </pre><br>  Wenn alles in Ordnung ist, startet der Beobachter den Webserver und beginnt, Änderungen an den Dateien in den freigegebenen und geschützten Verzeichnissen zu überwachen.  Wenn Änderungen an der Freigabe vorgenommen werden, werden entsprechende Versionen der Datenmodelle für den Client und den Server erstellt.  Bei Änderungen an protected startet der Watcher den Webserver automatisch neu. <br><br>  Sie können die Leistung des Messenger im Browser sehen, indem Sie auf den Link klicken <br><br> <code>http://localhost:3000/index.html?token=123&amp;user=Vasya</code> <br> <br>  (Token und Benutzer sind beliebig).  Um mehrere Benutzer zu emulieren, öffnen Sie dieselbe Seite in einem anderen Browser, indem Sie ein anderes Token und einen anderen Benutzer angeben. <br><br>  Nun ein kleiner Code. <br><br><h4>  Webserver </h4><br>  protected / server.mjs <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> express <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'express'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> bodyParser <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'body-parser'</span></span>; <span class="hljs-comment"><span class="hljs-comment">// -     //  -  import wsServer from './lib/wsServer.mjs'; const app = express(); //   - wsServer(app); //  mime  mjs express.static.mime.define({'application/javascript': ['js','mjs']}); app.use( bodyParser.json() ); app.use(bodyParser.urlencoded({ extended: true })); //      public app.use(express.static('public')); const server = app.listen(3000, () =&gt; { console.log('server is running at %s', server.address().port); });</span></span></code> </pre><br>  Dies ist ein regulärer Express-Server, hier gibt es nichts Interessantes.  Die Erweiterung mjs wird für ES-Module in node.js benötigt.  Aus Gründen der Konsistenz verwenden wir diese Erweiterung für den Client. <br><br><h4>  Kunde </h4><br>  public / index.html <br><br><pre> <code class="xml hljs"><span class="hljs-meta"><span class="hljs-meta">&lt;!DOCTYPE html&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">lang</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"en"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">src</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"/main.mjs"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"module"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="undefined"></span><span class="hljs-tag"><span class="undefined"></span><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">script</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">head</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> ... <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"users"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-for</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"user in users"</span></span></span><span class="hljs-tag">&gt;</span></span> {{ user.name }} ({{user.id}}) <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">id</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"messages"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">input</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">type</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-model</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"msg"</span></span></span><span class="hljs-tag"> /&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-on:click</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"sendMessage()"</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">button</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">v-for</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"message in messages"</span></span></span><span class="hljs-tag">&gt;</span></span>[{{ message.date }}] <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">strong</span></span></span><span class="hljs-tag">&gt;</span></span>{{ message.text }}<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">strong</span></span></span><span class="hljs-tag">&gt;</span></span><span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">li</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">ul</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">div</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">body</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">html</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br>  Zum Beispiel verwende ich Vue auf dem Client, aber das ändert nichts an der Essenz.  Anstelle von Vue kann es alles geben, wo Sie das Datenmodell in eine separate Klasse (Knockout, Angular) unterteilen können. <br><br>  public / main.mjs <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//      - import ws from "/lib/Ws.mjs"; //       import Messages from "./shared/messages/model/dataModel.mjs"; //    import Users from "./shared/users/model/dataModel.mjs"; //  - (     ) window.WS = new ws({ token: new URLSearchParams(document.location.search).get("token"), user: new URLSearchParams(document.location.search).get("user") }); //       new Messages({ el: '#messages' }) //       new Users({ el: '#users' })</span></span></code> </pre><br>  main.mjs ist ein Skript, das Datenmodelle mit entsprechenden Ansichten verknüpft.  Um den Code zu vereinfachen, werden Beispieldarstellungen für die Liste der aktiven Benutzer und Nachrichtenfeeds direkt in index.html integriert <br><br><h4>  Datenmodell </h4><br>  shared / messages / model / dataModel.mjs <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    //          , //    import Base from '@root/lib/Base.mjs'; export default class dataModel extends Base { //!#client constructor(attr) { attr.data = { msg: '', messages: [] } super(attr); //     this.on('newmessage', (data) =&gt; { this.messages.push(data) }) } //!#client async sendMessage(e) { //    await this.$sendMessage(this.msg); this.msg = ''; } //!#server async $sendMessage(text) { //   newmessage     this.fireEvent('newmessage', 'all', { date: new Date(), text }) return true; } }</span></span></code> </pre><br>  Diese verschiedenen Methoden implementieren alle Funktionen zum Senden und Empfangen von Nachrichten in Echtzeit.  Die Anweisungen! #Client und! #Server teilen dem Beobachterprozess mit, welche Methode für welchen Teil (Client oder Server) vorgesehen ist.  Wenn diese Anweisungen vor dem Definieren einer Methode nicht vorhanden sind, ist eine solche Methode sowohl auf dem Client als auch auf dem Server verfügbar.  Schrägstriche vor der Direktive sind optional und nur vorhanden, um zu verhindern, dass die Standard-IDE auf Syntaxfehler schwört. <br><br>  In der ersten Zeile des Pfads wird die &amp; root-Suche verwendet.  Beim Generieren der Client- und Serverversionen wird &amp; root durch den relativen Pfad zu den öffentlichen bzw. geschützten Verzeichnissen ersetzt. <br><br>  Ein weiterer wichtiger Punkt: Von der Client-Methode aus können Sie nur die Server-Methode aufrufen, deren Name mit "$" beginnt: <br><br><pre> <code class="javascript hljs">... <span class="hljs-comment"><span class="hljs-comment">//    async sendMessage(e) { await this.$sendMessage(this.msg); &lt;-    this.msg = ''; } ...</span></span></code> </pre><br>  Dies geschieht aus Sicherheitsgründen: Von außen können Sie hierfür nur auf speziell entwickelte Methoden zurückgreifen. <br><br>  Schauen wir uns die Versionen der Datenmodelle an, die der Beobachter für den Client und den Server generiert hat. <br><br>  <b>Client</b> (public / shared / messages / model / dataModel.mjs) <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Base <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'/lib/Base.mjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dataModel</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ __getFilePath__() {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"messages/model/dataModel.mjs"</span></span>} <span class="hljs-comment"><span class="hljs-comment">// constructor(attr) { attr.data = { msg: '', messages: [] } super(attr); //     this.on('newmessage', (data) =&gt; { this.messages.push(data) }) } // async sendMessage(e) { //    await this.$sendMessage(this.msg); this.msg = ''; } // ... async $sendMessage() {return await this.__runSharedFunction("$sendMessage",arguments)} }</span></span></code> </pre><br>  Auf der Clientseite ist das Modell ein Nachkomme der Vue-Klasse (über Base.mjs).  Somit können Sie damit wie mit einem normalen Vue-Datenmodell arbeiten.  Der Beobachter fügte der Client-Version des Modells die Methode __getFilePath__ hinzu, die den Pfad zur Klassendatei zurückgibt, und ersetzte den Server-Methodencode $ sendMessage durch ein Konstrukt, das im Wesentlichen die auf dem Server benötigte Methode über den RPC-Mechanismus aufruft (__runSharedFunction ist in der übergeordneten Klasse definiert). <br><br>  <b>Server</b> (protected / shared / messages / model / dataModel.mjs) <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Base <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../../lib/Base.mjs'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">dataModel</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Base</span></span></span><span class="hljs-class"> </span></span>{ __getFilePath__() {<span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"messages/model/dataModel.mjs"</span></span>} ...       ... <span class="hljs-comment"><span class="hljs-comment">// async $sendMessage(text) { //   newmessage     this.fireEvent('newmessage', 'all', { date: new Date(), text }) return true; } }</span></span></code> </pre><br>  In der Serverversion wurde auch die Methode __getFilePath__ hinzugefügt und die mit der Direktive gekennzeichneten Client-Methoden wurden entfernt! #Client <br><br>  In beiden generierten Versionen des Modells werden alle gelöschten Zeilen durch leere ersetzt.  Dies geschieht, damit die Fehlermeldung im Debugger die problematische Zeile im Quellcode des Modells leicht finden kann. <br><br><h4>  Client-Server-Interaktion </h4><br>  Wenn wir eine Servermethode auf dem Client aufrufen müssen, tun wir es einfach. <br>  Wenn sich der Anruf innerhalb desselben Modells befindet, ist alles einfach: <br><br><pre> <code class="javascript hljs">... !#client <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> sendMessage(e) { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.$sendMessage(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.msg); <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.msg = <span class="hljs-string"><span class="hljs-string">''</span></span>; } !#server <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> $sendMessage(msg) { <span class="hljs-comment"><span class="hljs-comment">// -    } ...</span></span></code> </pre><br>  Sie können ein anderes Modell „ziehen“: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> dataModel <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">"/shared/messages/model/dataModel.mjs"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> msg = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> dataModel(); msg.$sendMessage(<span class="hljs-string"><span class="hljs-string">'blah-blah-blah'</span></span>);</code> </pre><br>  In der entgegengesetzten Richtung, d.h.  Das Aufrufen einer Clientmethode auf dem Server funktioniert nicht.  Technisch ist dies machbar, aber aus praktischer Sicht macht es keinen Sinn, weil  Der Server ist einer, aber es gibt viele Clients.  Wenn wir einige Aktionen auf dem Server auf dem Client initiieren müssen, verwenden wir den Ereignismechanismus: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//    ... //!#client constructor(attr) { .... //       "newmessage" this.on('newmessage', (data) =&gt; { this.messages.push(data) }) } //!#server async $sendMessage(text) { //     newmessage     this.fireEvent('newmessage', 'all', { date: new Date(), text }) return true; } ...</span></span></code> </pre><br>  Die fireEvent-Methode verwendet drei Parameter: den Namen des Ereignisses, an das es gerichtet ist, und Daten.  Sie können den Empfänger auf verschiedene Arten festlegen: Schlüsselwort "all" - Das Ereignis wird an alle Benutzer oder im Array gesendet, um die Sitzungstoken der Clients aufzulisten, an die das Ereignis gerichtet ist. <br><br>  Das Ereignis ist nicht an eine bestimmte Instanz der Datenmodellklasse gebunden, und Handler werden in allen Instanzen der Klasse ausgelöst, in der fireEvent aufgerufen wurde. <br><br><h4>  Horizontale Backend-Skalierung </h4><br>  Die Monolithizität von Client-Server-Modellen in der vorgeschlagenen Implementierung sollte auf den ersten Blick die Möglichkeit einer horizontalen Skalierung des Serverteils erheblich einschränken.  Dies ist jedoch nicht der Fall: Technisch gesehen ist der Server nicht vom Client abhängig.  Sie können das "öffentliche" Verzeichnis überall kopieren und seinen Inhalt über einen anderen Webserver (Nginx, Apache usw.) bereitstellen. <br><br>  Die Serverseite kann einfach durch Starten neuer Backend-Instanzen erweitert werden.  Redis und das Kue-Warteschlangensystem werden verwendet, um mit einzelnen Instanzen zu interagieren. <br><br><h4>  API und verschiedene Clients zu einem Backend </h4><br>  In realen Projekten können verschiedene Server-Clients eine Server-API verwenden - Websites, mobile Anwendungen und Dienste von Drittanbietern.  In der vorgeschlagenen Lösung ist all dies ohne zusätzliche Tänze verfügbar.  Unter der Haube des Aufrufs von Servermethoden befindet sich der gute alte RPC.  Der Webserver selbst ist eine klassische Expressanwendung.  Es reicht aus, dort einen Wrapper für Routen hinzuzufügen, bei dem die erforderlichen Methoden derselben Datenmodelle aufgerufen werden. <br><br><h4>  Post scriptum </h4><br>  Der in diesem Artikel vorgeschlagene Ansatz gibt keine revolutionären Änderungen in Client-Server-Anwendungen vor.  Es bietet dem Entwicklungsprozess nur ein wenig Komfort, sodass Sie sich auf die an einem Ort zusammengestellte Geschäftslogik konzentrieren können. <br><br>  Dieses Projekt ist experimentell. Schreiben Sie in die Kommentare, ob es sich Ihrer Meinung nach lohnt, dieses Experiment fortzusetzen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435494/">https://habr.com/ru/post/de435494/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435480/index.html">Microsoft und Kroger werden Amazon einen Kampf auf dem Gebiet geben ... den Handel mit Lebensmitteln</a></li>
<li><a href="../de435482/index.html">Zirkon-Highlight: vDSO (virtuelles dynamisches gemeinsames Objekt)</a></li>
<li><a href="../de435484/index.html">Fuzzing Style 1989</a></li>
<li><a href="../de435488/index.html">Verspottet, stummelt und spioniert im Spock Framework</a></li>
<li><a href="../de435490/index.html">Google Steueränderungen im Jahr 2019</a></li>
<li><a href="../de435496/index.html">Tesla klagte wegen eines Unfalls, bei dem Fahrer und Beifahrer des Modells S starben</a></li>
<li><a href="../de435498/index.html">vCloud Director Extender: Migration</a></li>
<li><a href="../de435500/index.html">Biometrische Handschuhe im Motorsport</a></li>
<li><a href="../de435502/index.html">Die Studie enthüllte die Vor- und Nachteile des Perfektionismus</a></li>
<li><a href="../de435504/index.html">Handmonster im Kampf um Sauberkeit: Xiaomi manuelle Staubsaugerauswahl</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>