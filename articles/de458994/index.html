<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üíÉüèº üçø üé∏ Raspberry Pi + CentOS = WLAN-Hotspot (oder Himbeer-Router in einem roten Hut) ‚ô¶Ô∏è üêì üå°Ô∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Im Internet gibt es eine F√ºlle von Informationen zum Erstellen von Wi-Fi-Zugangspunkten auf der Basis eines Single-Board-Raspberry-PCs. In der Regel b...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Raspberry Pi + CentOS = WLAN-Hotspot (oder Himbeer-Router in einem roten Hut)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/458994/"> Im Internet gibt es eine F√ºlle von Informationen zum Erstellen von Wi-Fi-Zugangspunkten auf der Basis eines Single-Board-Raspberry-PCs.  In der Regel bedeutet dies die Verwendung des nativen Betriebssystems f√ºr Raspberry - Raspbian. <br><br>  Als Anh√§nger von RPM-basierten Systemen konnte ich dieses kleine Wunder nicht √ºberwinden und mein Lieblings-CentOS nicht ausprobieren. <br><br>  Der Artikel enth√§lt Anweisungen zum Herstellen eines 5-GHz / AC-WLAN-Routers aus dem Raspberry Pi 3 Model B + basierend auf dem CentOS-Betriebssystem.  Es wird mehrere Standardtricks geben, die jedoch wenig bekannt sind, und als Bonus eine Zeichnung f√ºr die Verbindung mit der zus√§tzlichen Wi-Fi-Ausr√ºstung "Himbeere", die es erm√∂glicht, gleichzeitig in mehreren Modi (2,4 + 5 GHz) zu arbeiten. <br><br><img src="https://habrastorage.org/webt/mp/yb/fz/mpybfz6gzojqkaftnuljhpzx5da.png" alt="Bild"><br>  <sub><i>(Mischung von Bildern aus freiem Zugang)</i></sub> <br><a name="habracut"></a><br>  Wir stellen sofort fest, dass einige kosmische Geschwindigkeiten nicht funktionieren.  Ich dr√ºcke maximal 100 Mbit aus meiner ‚ÄûHimbeere‚Äú √ºber Funk, und dies deckt die Geschwindigkeit meines Internetproviders ab.  Warum brauchen wir eine so tr√§ge Klimaanlage, wenn Sie theoretisch sogar auf N ein halbes Gigabyte bekommen k√∂nnen?  Wenn Sie diese Frage gestellt haben, suchen Sie im Gesch√§ft nach einem echten Router mit acht externen Antennen. <br><br><h1>  0. Was wird ben√∂tigt </h1><br><ul><li>  Eigentlich das "Himbeerprodukt" des Kalibers selbst: Pi 3 Modell B + (um die begehrten 5GHz Geschwindigkeiten und Kan√§le zu erreichen); <br></li><li>  Feste microSD&gt; = 4 GB; <br></li><li>  Linux-Workstation mit microSD-Reader / Writer; <br></li><li>  Das Vorhandensein ausreichender Kenntnisse in Linux, der Artikel ist f√ºr den vorbereiteten Geek; <br></li><li>  Ethed-Konnektivit√§t (Wired Network) zwischen Raspberry und Linux, einem funktionierenden DHCP-Server im lokalen Netzwerk, und Internetzugang von beiden Ger√§ten. <br></li></ul><br>  Ein kurzer Kommentar zum letzten Punkt.  "Was war zuerst da, ein Ei oder ..." Wie kann man einen WLAN-Router ohne Internet-Zugangsausr√ºstung herstellen?  Lassen wir diese unterhaltsame √úbung au√üerhalb des Geltungsbereichs des Artikels und nehmen einfach an, dass Raspberry per Kabel mit dem lokalen Netzwerk verbunden ist und √ºber einen Internetzugang verf√ºgt.  In diesem Fall ben√∂tigen wir keinen zus√§tzlichen Fernseher und keinen Manipulator zum Einrichten der Himbeere. <br><br><h1>  1. Installieren Sie CentOS </h1><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Projekthomepage</a> <br><br>  Zum Zeitpunkt dieses Schreibens ist die Arbeitsversion von CentOS auf dem Ger√§t 32-Bit.  Irgendwo in der Weite des World Wide Web stie√ü ich auf Meinungen √ºber die Leistungsverschlechterung solcher Betriebssysteme in der 64-Bit-ARM-Architektur von bis zu 20%.  Ich werde diesen Punkt kommentarlos belassen. <br><br>  Laden Sie unter Linux das Minimal-Image mit dem Kernel " <b>-RaspberryPI-</b> " herunter und schreiben Sie es in microSD: <br><br><pre><code class="plaintext hljs"># xzcat CentOS-Userland-7-armv7hl-RaspberryPI-Minimal-1810-sda.raw.xz | \ dd of=/dev/mmcblk0 bs=4M # sync</code> </pre> <br>  Bevor Sie das Image verwenden, l√∂schen Sie den SWAP-Abschnitt daraus, erweitern Sie den Stamm auf das gesamte verf√ºgbare Volume und entfernen Sie SELinux.  Der Algorithmus ist einfach: Wir erstellen unter Linux eine Kopie des Stammverzeichnisses, l√∂schen alle Partitionen von der microSD mit Ausnahme der ersten (/ boot), erstellen ein neues Stammverzeichnis und geben dessen Inhalt von der Kopie zur√ºck. <br><br><div class="spoiler">  <b class="spoiler_title">Beispiel f√ºr notwendige Aktionen (harte Konsolenausgabe)</b> <div class="spoiler_text"><pre> <code class="plaintext hljs"># mount /dev/mmcblk0p3 /mnt # cd /mnt # tar cfz ~/pi.tgz . --no-selinux # cd # umount /mnt</code> </pre><br><pre> <code class="plaintext hljs"># parted /dev/mmcblk0 (parted) unit s (parted) print free Model: SD SC16G (sd/mmc) Disk /dev/mmcblk0: 31116288s Sector size (logical/physical): 512B/512B Partition Table: msdos Disk Flags: Number Start End Size Type File system Flags 63s 2047s 1985s Free Space 1 2048s 1370111s 1368064s primary fat32 boot, lba 2 1370112s 2369535s 999424s primary linux-swap(v1) 3 2369536s 5298175s 2928640s primary ext4 5298176s 31116287s 25818112s Free Space (parted) rm 3 (parted) rm 2 (parted) print free Model: SD SC16G (sd/mmc) Disk /dev/mmcblk0: 31116288s Sector size (logical/physical): 512B/512B Partition Table: msdos Disk Flags: Number Start End Size Type File system Flags 63s 2047s 1985s Free Space 1 2048s 1370111s 1368064s primary fat32 boot, lba 1370112s 31116287s 29746176s Free Space (parted) mkpart Partition type? primary/extended? primary File system type? [ext2]? ext4 Start? 1370112s End? 31116287s (parted) set Partition number? 2 Flag to Invert? lba New state? on/[off]? off (parted) print free Model: SD SC16G (sd/mmc) Disk /dev/mmcblk0: 31116288s Sector size (logical/physical): 512B/512B Partition Table: msdos Disk Flags: Number Start End Size Type File system Flags 63s 2047s 1985s Free Space 1 2048s 1370111s 1368064s primary fat32 boot, lba 2 1370112s 31116287s 29746176s primary ext4 (parted) quit</code> </pre><br><pre> <code class="plaintext hljs"># mkfs.ext4 /dev/mmcblk0p2 mke2fs 1.44.6 (5-Mar-2019) /dev/mmcblk0p2 contains a swap file system labelled '_swap' Proceed anyway? (y,N) y Discarding device blocks: done Creating filesystem with 3718272 4k blocks and 930240 inodes Filesystem UUID: 6a1a0694-8196-4724-a58d-edde1f189b31 Superblock backups stored on blocks: 32768, 98304, 163840, 229376, 294912, 819200, 884736, 1605632, 2654208 Allocating group tables: done Writing inode tables: done Creating journal (16384 blocks): done Writing superblocks and filesystem accounting information: done # mount /dev/mmcblk0p2 /mnt # tar xfz ~/pi.tgz -C /mnt --no-selinux</code> </pre><br>  Nachdem Sie den Inhalt der Root-Partition entpackt haben, m√ºssen Sie einige √Ñnderungen daran vornehmen. <br><br>  Deaktivieren Sie SELinux in <b>/ mnt / etc / selinux / config</b> : <br><br><pre> <code class="plaintext hljs">SELINUX=disabled</code> </pre><br>  Wir bearbeiten <b>/ mnt / etc / fstab</b> und lassen nur zwei Partitionseintr√§ge darin: boot (/ boot, unver√§ndert) und root (√§ndern Sie den UUID-Wert, der durch Untersuchen der Ausgabe des Befehls blkid unter Linux ermittelt werden kann): <br><br><pre> <code class="plaintext hljs">UUID=6a1a0694-8196-4724-a58d-edde1f189b31 / ext4 defaults,noatime 0 0 UUID=6938-F4F2 /boot vfat defaults,noatime 0 0</code> </pre><br>  Schlie√ülich √§ndern wir die Kernel-Boot-Parameter: Geben Sie den neuen Speicherort der Root-Partition an, deaktivieren Sie die Ausgabe von Debugging-Informationen und verhindern Sie (optional), dass der Kernel IPv6-Adressen auf Netzwerkschnittstellen zuweist: <br><br><pre> <code class="plaintext hljs"># cd # umount /mnt # mount /dev/mmcblk0p1 /mnt</code> </pre><br>  Wir <b>bringen den</b> Inhalt von <b>/mnt/cmdline.txt</b> in das folgende Formular (eine Zeile ohne Silbentrennung): <br><br><pre> <code class="plaintext hljs">root=/dev/mmcblk0p2 rootfstype=ext4 elevator=deadline rootwait quiet ipv6.disable_ipv6=1</code> </pre><br>  Fertig: <br><br><pre> <code class="plaintext hljs"># cd # umount /mnt # sync</code> </pre><br></div></div><br>  Wir ordnen die microSD in der "Malinka" neu an, f√ºhren sie aus und erhalten √ºber ssh (root / centos) Netzwerkzugriff darauf. <br><br><h1>  2. CentOS konfigurieren </h1><br>  Die ersten drei unersch√ºtterlichen Bewegungen: <b>passwd</b> , <b>yum -y update</b> , <b>neustart</b> . <br><br>  Wir geben <b>networkd</b> Netzwerkmanagement: <br><br><pre> <code class="plaintext hljs"># yum install systemd-networkd # systemctl enable systemd-networkd # systemctl disable NetworkManager # chkconfig network off</code> </pre><br>  Erstellen Sie die Datei (zusammen mit den Verzeichnissen) <b>/etc/systemd/network/eth0.network</b> : <br><br><pre> <code class="plaintext hljs">[Match] Name=eth0 [Network] DHCP=ipv4</code> </pre><br>  Wir starten die "Himbeere" neu und erhalten erneut Netzwerkzugriff √ºber ssh (die IP-Adresse kann sich √§ndern).  Beachten Sie, dass <b>/etc/resolv.conf</b> , das zuvor von Network Manager erstellt wurde, verwendet wird.  Bearbeiten Sie daher bei Problemen mit der L√∂sung den Inhalt.  Wir werden nicht <b>systemd-Resolution verwenden</b> . <br><br>  Wir entfernen das "√úberfl√ºssige", reparieren und beschleunigen das Laden des Betriebssystems: <br><br><pre> <code class="plaintext hljs"># systemctl set-default multi-user.target # yum remove GeoIP Network* aic* alsa* cloud-utils-growpart \ cronie* dhc* firewal* initscripts iwl* kexec* logrotate \ postfix rsyslog selinux-pol* teamd wpa_supplicant</code> </pre><br>  Wer <b>cron</b> braucht und wer die eingebauten <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">systemd-Timer</a> nicht <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">verdaut</a> , kann die fehlenden installieren.  <b>/ var / log -</b> und durch <b>journalctl</b> schauen.  Wenn Sie einen Protokollverlauf ben√∂tigen (standardm√§√üig werden Informationen erst ab dem Start des Systems gespeichert): <br><br><pre> <code class="plaintext hljs"># mkdir /var/log/journal # systemd-tmpfiles --create --prefix /var/log/journal # systemctl restart systemd-journald # vi /etc/systemd/journald.conf</code> </pre><br><div class="spoiler">  <b class="spoiler_title">Deaktivieren Sie die IPv6-Nutzung durch Kerndienste (falls erforderlich).</b> <div class="spoiler_text">  <b>/ etc / ssh / sshd_config</b> : <br><br><pre> <code class="plaintext hljs">AddressFamily inet</code> </pre><br>  <b>/ etc / sysconfig / chronyd</b> : <br><pre> <code class="plaintext hljs">OPTIONS="-4"</code> </pre><br></div></div><br>  Die Relevanz der Zeit f√ºr die "Himbeere" ist eine wichtige Sache.  Da "out of the box" nicht in der Lage ist, den aktuellen Status der Uhr beim Neustart zu speichern, m√ºssen Sie synchronisieren.  Ein sehr guter und schneller Daemon daf√ºr - <b>chrony</b> - ist bereits installiert und startet automatisch.  Sie k√∂nnen die NTP-Server auf die n√§chsten √§ndern. <br><br>  <b>/etc/chrony.conf</b> : <br><br><pre> <code class="plaintext hljs">server 0.ru.pool.ntp.org iburst server 1.ru.pool.ntp.org iburst server 2.ru.pool.ntp.org iburst server 3.ru.pool.ntp.org iburst</code> </pre><br>  Wir werden den <b>Trick verwenden</b> , um die Zeitzone einzustellen.  Da unser Ziel darin besteht, einen WLAN-Router mit 5-GHz-Frequenzen zu entwickeln, werden wir uns im Voraus auf die √úberraschungen des <b>Regulators</b> vorbereiten: <br><blockquote>  # yum info crda <br>  Zusammenfassung: Daemon zur Einhaltung gesetzlicher Bestimmungen f√ºr drahtlose 802.11-Netzwerke <br></blockquote><br>  Dieses boshafte Design, das sich unter anderem auf die Zeitzone konzentriert, ‚Äûverbietet‚Äú die Verwendung (in Russland) von 5-GHz-Frequenzen und -Kan√§len mit ‚Äûgro√üen‚Äú Zahlen.  Der Trick besteht darin, die Zeitzone festzulegen, ohne die Namen des Festlandes / der Stadt zu verwenden, dh anstelle von: <br><br><pre> <code class="plaintext hljs"># timedatectl set-timezone Europe/Moscow</code> </pre><br>  Dr√ºcken Sie: <br><br><pre> <code class="plaintext hljs"># timedatectl set-timezone Etc/GMT-3</code> </pre><br>  Und der letzte Schliff in der Frisur des Systems: <br><br><pre> <code class="plaintext hljs"># hostnamectl set-hostname router</code> </pre><br>  <b>/root/.bash_profile</b> : <br><br><pre> <code class="plaintext hljs">. . . # User specific environment and startup programs export PROMPT_COMMAND="echo -n $(($(&lt;/sys/class/thermal/thermal_zone0/temp) / 1000))\'C\ " export LANG=en_US.UTF-8 export PATH=$PATH:$HOME/bin</code> </pre><br><h1>  3. CentOS-Add-Ons </h1><br>  Alles, was oben gesagt wurde, kann als vollst√§ndige Anleitung zur Installation des "Vanilla" CentOS auf dem Raspberry Pi angesehen werden.  Sie sollten einen PC haben, der in weniger als 10 Sekunden (neu) startet, weniger als 15 Megabyte RAM und 1,5 Gigabyte microSD verwendet (tats√§chlich weniger als 1 Gigabyte aufgrund von Unvollst√§ndigkeit / Booten, aber wir werden bis zum Ende ehrlich sein): <br><img src="https://habrastorage.org/webt/mu/0g/cf/mu0gcfyiokq0x_2dysrb1ieh0ke.jpeg"><br><br><img src="https://habrastorage.org/webt/xx/l3/_g/xxl3_gukovfw0zawwvvy8ua0dtw.jpeg"><br><br><img src="https://habrastorage.org/webt/wt/yc/-9/wtyc-9erdcdx-rvqnnjite7c9ru.jpeg"><br><br>  Um die Wi-Fi Access Point-Software auf diesem System zu installieren, m√ºssen Sie die Funktionen der Standard-CentOS-Distribution geringf√ºgig erweitern.  Pumpen Sie zun√§chst den Treiber (Firmware) des eingebauten Wi-Fi-Adapters.  Die Projekthomepage sagt: <br><blockquote>  Wifi auf der Himbeere 3B und 3B + <br><br>  Die Raspberry PI 3B / 3B + -Firmware-Dateien d√ºrfen vom CentOS-Projekt nicht verteilt werden.  Sie k√∂nnen die folgenden Artikel verwenden, um das Problem zu verstehen, die Firmware abzurufen und das WLAN einzurichten. <br></blockquote><br>  Was das CentOS-Projekt nicht kann, ist uns f√ºr den pers√∂nlichen Gebrauch nicht verboten.  Wir ersetzen die Distributions-Wi-Fi-Firmware in CentOS durch die entsprechende von den Broadcom-Entwicklern (dieselben verhassten bin√§ren Blobs ...).  Dies erm√∂glicht insbesondere die Verwendung von Wechselstrom im Zugangspunktmodus. <br><br><div class="spoiler">  <b class="spoiler_title">WLAN-Firmware-Upgrade</b> <div class="spoiler_text">  Wir finden das Modell des Ger√§ts und die aktuelle Firmware-Version heraus: <br><br><pre> <code class="plaintext hljs"># journalctl | grep $(basename $(readlink /sys/class/net/wlan0/device/driver)) Jan 01 04:00:03 router kernel: brcmfmac: F1 signature read @0x18000000=0x15264345 Jan 01 04:00:03 router kernel: brcmfmac: brcmf_fw_map_chip_to_name: using brcm/brcmfmac43455-sdio.bin for chip 0x004345(17221) rev 0x000006 Jan 01 04:00:03 router kernel: usbcore: registered new interface driver brcmfmac Jan 01 04:00:03 router kernel: brcmfmac: brcmf_c_preinit_dcmds: Firmware version = wl0: Mar 1 2015 07:29:38 version 7.45.18 (r538002) FWID 01-6a2c8ad4 Jan 01 04:00:03 router kernel: brcmfmac: brcmf_c_preinit_dcmds: CLM version = API: 12.2 Data: 7.14.8 Compiler: 1.24.9 ClmImport: 1.24.9 Creation: 2014-09-02 03:05:33 Inc Data: 7.17.1 Inc Compiler: 1.26.11 Inc ClmImport: 1.26.11 Creation: 2015-03-01 07:22:34</code> </pre><br>  Wir sehen, dass die Firmware-Version 7.45.18 vom 01.03.2015 ist, und wir erinnern uns an die folgenden Zahlen: <b>43455</b> (brcmfmac43455-sdio.bin). <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Laden Sie das aktuelle Bild von Raspbian herunter</a> .  Faule Leute k√∂nnen das Bild auf microSD schreiben und von dort die Dateien mit der Firmware abholen.  Und Sie k√∂nnen die Root-Partition des Images unter Linux mounten und die ben√∂tigte von dort kopieren: <br><br><pre> <code class="plaintext hljs"># wget https://downloads.raspberrypi.org/raspbian_lite_latest # unzip -p raspbian_lite_latest &gt; raspbian.img # fdisk -l raspbian.img Disk raspbian.img: 2 GiB, 2197815296 bytes, 4292608 sectors Units: sectors of 1 * 512 = 512 bytes Sector size (logical/physical): 512 bytes / 512 bytes I/O size (minimum/optimal): 512 bytes / 512 bytes Disklabel type: dos Disk identifier: 0x17869b7d Device Boot Start End Sectors Size Id Type raspbian.img1 8192 532480 524289 256M c W95 FAT32 (LBA) raspbian.img2 540672 4292607 3751936 1.8G 83 Linux # mount -t ext4 -o loop,offset=$((540672 * 512)) raspbian.img /mnt # cp -fv /mnt/lib/firmware/brcm/*43455* ... '/mnt/lib/firmware/brcm/brcmfmac43455-sdio.bin' -&gt; ... '/mnt/lib/firmware/brcm/brcmfmac43455-sdio.clm_blob' -&gt; ... '/mnt/lib/firmware/brcm/brcmfmac43455-sdio.txt' -&gt; ... # umount /mnt</code> </pre><br>  Die resultierenden Firmware-Dateien f√ºr den Wi-Fi-Adapter m√ºssen mit dem Ersatz der "Himbeere" im Verzeichnis <b>/ usr / lib / firmware / brcm / kopiert werden.</b> <br><br>  Wir starten den zuk√ºnftigen Router neu und l√§cheln eher: <br><br><pre> <code class="plaintext hljs"># journalctl | grep $(basename $(readlink /sys/class/net/wlan0/device/driver)) Jan 01 04:00:03 router kernel: brcmfmac: F1 signature read @0x18000000=0x15264345 Jan 01 04:00:03 router kernel: brcmfmac: brcmf_fw_map_chip_to_name: using brcm/brcmfmac43455-sdio.bin for chip 0x004345(17221) rev 0x000006 Jan 01 04:00:03 router kernel: usbcore: registered new interface driver brcmfmac Jan 01 04:00:03 router kernel: brcmfmac: brcmf_c_preinit_dcmds: Firmware version = wl0: Feb 27 2018 03:15:32 version 7.45.154 (r684107 CY) FWID 01-4fbe0b04 Jan 01 04:00:03 router kernel: brcmfmac: brcmf_c_preinit_dcmds: CLM version = API: 12.2 Data: 9.10.105 Compiler: 1.29.4 ClmImport: 1.36.3 Creation: 2018-03-09 18:56:28</code> </pre><br>  Version: 7.45.154 vom 27.02.2018. <br></div></div><br>  Und nat√ºrlich EPEL: <br><br><pre> <code class="plaintext hljs"># cat &gt; /etc/yum.repos.d/epel.repo &lt;&lt; EOF [epel] name=Epel rebuild for armhfp baseurl=https://armv7.dev.centos.org/repodir/epel-pass-1/ enabled=1 gpgcheck=0 EOF # yum clean all # rm -rfv /var/cache/yum # yum update</code> </pre><br><h1>  4. Netzwerkkonfiguration und bevorstehende Herausforderungen </h1><br>  Wie oben vereinbart, ist die "Malinka" √ºber eine "Leitung" mit dem lokalen Netzwerk verbunden.  Angenommen, ein Anbieter bietet den Internetzugang genauso an: Eine Adresse in einem √∂ffentlichen Netzwerk wird dynamisch von einem DHCP-Server ausgegeben (sie kann mit einem MAC verbunden werden).  In diesem Fall reicht es nach der endg√ºltigen Einrichtung der "Himbeere" aus, das Providerkabel daran anzuschlie√üen, und alles ist fertig.  Die Autorisierung mit <b>systemd-networkd</b> ist das Thema eines separaten Artikels und wird hier nicht ber√ºcksichtigt. <br><br>  Die Wi-Fi-Schnittstelle (n) von Raspberry ist ein lokales Netzwerk, und der integrierte Ethernet-Adapter (eth0) ist extern.  Wir nummerieren das lokale Netzwerk statisch, zum Beispiel: 192.168.0.0/24.  Malinkas Adresse: 192.168.0.1.  In einem externen Netzwerk (Internet) funktioniert ein DHCP-Server. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Das Problem der einheitlichen Benennung</a> und der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ber√ºhmte guatemaltekische Programmierer</a> sind zwei Probleme, die auf alle warten, die an der Konfiguration von Netzwerkschnittstellen und -diensten in Systemd-Distributionen beteiligt sind. <br><br><div class="spoiler">  <b class="spoiler_title">Paralleles Chaos (lyrischer Exkurs)</b> <div class="spoiler_text">  Lennart Pottering hat sein Systemprogramm sehr gut gemacht.  Dieses <b>System</b> startet andere Programme so schnell, dass sie, nachdem sie sich nicht vom Pfeifen des Schiedsrichters erholt haben, beim Start stolpern und fallen, ohne ihren Hindernislauf zu beginnen. <br><br>  Aber im Ernst, die aggressive Parallelisierung der gestarteten Prozesse zu Beginn des systemd-OS ist eine Art ‚ÄûEselbr√ºcke‚Äú f√ºr erfahrene serielle LSB-Treiber.  Gl√ºcklicherweise stellt sich heraus, dass es einfach ist, dieses ‚Äûparallele Chaos‚Äú aufzur√§umen, obwohl die Wahrheit nicht immer offensichtlich ist. <br></div></div><br>  Wir erstellen zwei virtuelle Bridge-Schnittstellen mit konstanten Namen: <b>lan</b> und <b>wan</b> .  Wir werden die Wi-Fi-Adapter mit dem ersten und eth0 der Himbeere mit dem zweiten "verbinden". <br><br>  <b>/etc/systemd/network/lan.netdev</b> : <br><br><pre> <code class="plaintext hljs">[NetDev] Name=lan Kind=bridge</code> </pre><br>  <b>/etc/systemd/network/lan.network</b> : <br><br><pre> <code class="plaintext hljs">[Match] Name=lan [Network] Address=192.168.0.1/24 IPForward=yes</code> </pre><br>  <b>/etc/systemd/network/wan.netdev</b> : <br><br><pre> <code class="plaintext hljs">[NetDev] Name=wan Kind=bridge #MACAddress=xx:xx:xx:xx:xx:xx</code> </pre><br>  <b>/etc/systemd/network/wan.network</b> : <br><br><pre> <code class="plaintext hljs">[Match] Name=wan [Network] DHCP=ipv4 IPForward=yes</code> </pre><br>  <b>IPForward = yes macht es √ºberfl√ºssig,</b> √ºber sysctl auf den Kernel hinzuweisen, um das Routing zu aktivieren. <br>  <b>MACAddress = auskommentieren</b> und ggf. √§ndern. <br><br>  Zuerst verbinden wir eth0.  Denken Sie an das ‚ÄûEinheitlichkeitsproblem‚Äú und verwenden Sie nur die MAC-Adresse dieser Schnittstelle, die Sie beispielsweise wie folgt herausfinden k√∂nnen: <br><br><pre> <code class="plaintext hljs"># cat /sys/class/net/eth0/address</code> </pre><br>  Erstellen Sie <b>/etc/systemd/network/eth.network</b> : <br><br><pre> <code class="plaintext hljs">[Match] MACAddress=b8:27:eb:xx:xx:xx [Network] Bridge=wan</code> </pre><br>  L√∂schen Sie die vorherige eth0-Konfigurationsdatei, starten Sie die "Himbeere" neu und erhalten Sie Netzwerkzugriff darauf (die IP-Adresse wird sich h√∂chstwahrscheinlich √§ndern): <br><br><pre> <code class="plaintext hljs"># rm -fv /etc/systemd/network/eth0.network # reboot</code> </pre><br><h1>  5. DNSMASQ </h1><br>  F√ºr die Herstellung von Wi-Fi-Zugangspunkten wurde noch nichts Besseres als ein s√º√ües Paar von <b>dnsmasq</b> + <b>hostapd</b> erfunden.  Meiner Meinung nach. <br><br><div class="spoiler">  <b class="spoiler_title">Wenn jemand vergessen hat, dann ...</b> <div class="spoiler_text">  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hostapd</a> verwaltet Wi-Fi-Adapter (insbesondere wird es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">schwierig</a> sein, sie mit dem virtuellen LAN der Himbeere zu verbinden). Es autorisiert und registriert drahtlose Clients. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">dnsmasq</a> - Konfiguriert den Netzwerkstapel von Clients: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Stellt</a> IP-Adressen, DNS-Server, ein Standard-Gateway und dergleichen bereit. <br></div></div><br>  Wir beginnen mit dnsmasq: <br><br><pre> <code class="plaintext hljs"># yum install dnsmasq</code> </pre><br>  Vorlage <b>/etc/resolv.conf</b> : <br><br><pre> <code class="plaintext hljs">nameserver 1.1.1.1 nameserver 1.0.0.1 nameserver 8.8.8.8 nameserver 8.8.4.4 nameserver 77.88.8.8 nameserver 77.88.8.1 domain router.local search router.local</code> </pre><br>  Bearbeiten Sie es nach Ihren W√ºnschen. <br><br>  Minimalistisch <b>/etc/dnsmasq.conf</b> : <br><br><pre> <code class="plaintext hljs">domain-needed bogus-priv interface=lan bind-dynamic expand-hosts domain=# dhcp-range=192.168.0.100,192.168.0.199,255.255.255.0,24h conf-dir=/etc/dnsmasq.d</code> </pre><br>  Die ‚ÄûMagie‚Äú hier ist der bindendynamische Parameter, der den dnsmasq-D√§mon anweist, auf das Erscheinen von <b>interface = lan</b> im System zu warten und nach dem Start nicht vor einem Angriff stolzer Einsamkeit in Ohnmacht zu fallen. <br><br><pre> <code class="plaintext hljs"># systemctl enable dnsmasq # systemctl start dnsmasq; journalctl -f</code> </pre><br><h1>  6. HOSTAPD </h1><br>  Schlie√ülich die magischen Hostapd-Konfigurationen.  Ich habe keinen Zweifel, dass jemand diesen Artikel auf der Suche nach genau diesen gesch√§tzten Zeilen liest. <br><br>  Vor der Installation von hostapd m√ºssen Sie sich mit dem ‚ÄûEinheitlichkeitsproblem‚Äú befassen.  Der integrierte WLAN-Adapter wlan0 kann seinen Namen leicht in wlan1 √§ndern, wenn zus√§tzliche USB-WLAN-Ger√§te angeschlossen werden.  Daher werden wir die Namen der Schnittstellen folgenderma√üen festlegen: Wir werden eindeutige Namen f√ºr (drahtlose) Adapter erstellen und diese an die MAC-Adressen binden. <br><br>  F√ºr den eingebauten Wi-Fi-Adapter, der immer noch wlan0 ist: <br><br><pre> <code class="plaintext hljs"># cat /sys/class/net/wlan0/address b8:27:eb:xx:xx:xx</code> </pre><br>  Erstellen Sie <b>/etc/systemd/network/wl0.link</b> : <br><br><pre> <code class="plaintext hljs">[Match] MACAddress=b8:27:eb:xx:xx:xx [Link] Name=wl0</code> </pre><br>  Jetzt werden wir sicher sein, dass <b>wl0</b> das eingebaute Wi-Fi ist.  Wir starten die "Himbeere" neu, um dies zu sehen. <br><br>  Installieren: <br><br><pre> <code class="plaintext hljs"># yum install hostapd wireless-tools</code> </pre><br>  Konfigurationsdatei <b>/etc/hostapd/hostapd.conf</b> : <br><br><pre> <code class="plaintext hljs">ssid=rpi wpa_passphrase=1234567890 channel=36 country_code=US interface=wl0 bridge=lan driver=nl80211 auth_algs=1 wpa=2 wpa_key_mgmt=WPA-PSK rsn_pairwise=CCMP macaddr_acl=0 hw_mode=a wmm_enabled=1 # N ieee80211n=1 require_ht=1 ht_capab=[MAX-AMSDU-3839][HT40+][SHORT-GI-20][SHORT-GI-40][DSSS_CCK-40] # AC ieee80211ac=1 require_vht=1 ieee80211d=0 ieee80211h=0 vht_capab=[MAX-AMSDU-3839][SHORT-GI-80] vht_oper_chwidth=1 vht_oper_centr_freq_seg0_idx=42</code> </pre><br>  Ohne das <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GKChP</a> f√ºr eine Minute zu vergessen, √§ndern wir die ben√∂tigten Parameter und √ºberpr√ºfen manuell die Leistung: <br><br><pre> <code class="plaintext hljs"># hostapd /etc/hostapd/hostapd.conf</code> </pre><br>  hostapd startet interaktiv und √ºbersetzt seinen Status in die Konsole.  Wenn keine Fehler vorliegen, k√∂nnen Clients, die den AC-Modus unterst√ºtzen, bereits mit dem Access Point verbunden werden.  So stoppen Sie hostapd - Strg-C. <br><br>  Hostapd muss weiterhin in den Systemstart einbezogen werden.  Wenn Sie standardm√§√üig handeln (systemctl enable hostapd), k√∂nnen Sie nach dem n√§chsten Neustart einen "Daemon im Blut" eines D√§mons mit der Diagnose " <b>wl0-Schnittstelle nicht gefunden</b> " erhalten.  Infolge des "parallelen Chaos" landete hostapd schneller als der Kernel einen drahtlosen Adapter gefunden hatte. <br><br>  Das Internet ist voll von Medikamenten: vom erzwungenen Timeout vor dem Start des D√§mons (f√ºr einige Minuten) bis zu einem anderen D√§mon, der das Erscheinungsbild der Benutzeroberfl√§che √ºberwacht und das Hostpad (neu) startet.  Die L√∂sungen funktionieren ziemlich gut, sind aber furchtbar h√§sslich.  Wir bitten das gro√üe <b>System</b> um Hilfe bei seinen "Zielen" und " <s>Aufgaben</s> ", "Abh√§ngigkeiten". <br><br>  Kopieren Sie die Distributionsdienstdatei nach <b>/etc/systemd/system/hostapd.service</b> : <br><br><pre> <code class="plaintext hljs"># cp -fv /usr/lib/systemd/system/hostapd.service /etc/systemd/system</code> </pre><br>  und bringen Sie seinen Inhalt in die folgende Form: <br><br><pre> <code class="plaintext hljs">[Unit] Description=Hostapd IEEE 802.11 AP, IEEE 802.1X/WPA/WPA2/EAP/RADIUS Authenticator After=sys-subsystem-net-devices-wl0.device BindsTo=sys-subsystem-net-devices-wl0.device [Service] Type=forking PIDFile=/run/hostapd.pid ExecStart=/usr/sbin/hostapd /etc/hostapd/hostapd.conf -P /run/hostapd.pid -B [Install] WantedBy=sys-subsystem-net-devices-wl0.device</code> </pre><br>  Die Magie der aktualisierten Servicedatei besteht darin, hostapd dynamisch an ein neues Ziel zu binden - die wl0-Schnittstelle.  Wenn die Schnittstelle angezeigt wird, wird der D√§mon gestartet und beim Verschwinden gestoppt.  Und alles online - ohne das System neu zu starten.  Diese Technik ist besonders n√ºtzlich, wenn Sie eine Verbindung zum USB-WLAN-Adapter "Himbeere" herstellen. <br><br>  Jetzt k√∂nnen Sie: <br><br><pre> <code class="plaintext hljs"># systemctl enable hostapd # reboot</code> </pre><br><h1>  7. IPTABLES </h1><br>  "Shta ???"  ¬© Ja, ja!  Kein <b>systemd</b> .  Keine neuen M√§hdrescher (in Form von <b>Firewalld</b> ), die letztendlich das Gleiche tun. <br><br>  Wir verwenden die guten alten <b>iptables</b> , deren Dienste nach ihrem Start Netzwerkregeln in den Kernel hochladen und leise herunterfahren, ohne resident zu bleiben und ohne Ressourcen zu verbrauchen.  Systemd hat eine elegante <b>IPMasquerade =</b> , aber wir werden iptables weiterhin mit Adress√ºbersetzung (NAT) und Firewall betrauen. <br><br>  Installieren: <br><br><pre> <code class="plaintext hljs"># yum install iptables-services # systemctl enable iptables ip6tables</code> </pre><br>  Ich bevorzuge es, die iptables-Konfiguration als Skript zu speichern (Beispiel): <br><br><pre> <code class="bash hljs"><span class="hljs-comment"><span class="hljs-comment">#!/bin/bash # # Disable IPv6 # ip6tables --flush ip6tables --delete-chain ip6tables --policy INPUT DROP ip6tables --policy FORWARD DROP ip6tables --policy OUTPUT DROP ip6tables-save &gt; /etc/sysconfig/ip6tables systemctl restart ip6tables # # Cleaning # iptables -F iptables -X iptables -t nat -F iptables -t nat -X iptables -t mangle -F iptables -t mangle -X iptables -P INPUT DROP iptables -P OUTPUT ACCEPT iptables -P FORWARD ACCEPT # # Loopback, lan # iptables -A INPUT -i lo -j ACCEPT iptables -A INPUT -i lan -j ACCEPT # # Ping, Established # iptables -A INPUT -p icmp --icmp-type echo-request -j ACCEPT iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT # # NAT # iptables -t nat -A POSTROUTING -o wan -j MASQUERADE # # Saving # iptables-save &gt; /etc/sysconfig/iptables systemctl restart iptables</span></span></code> </pre><br>  Wir f√ºhren das obige Skript aus und verlieren die F√§higkeit, neue verkabelte SSH-Verbindungen mit dem "Malinka" herzustellen.  Richtig, wir haben einen WLAN-Router entwickelt, auf den "√ºber das Internet" standardm√§√üig der Zugriff verboten ist - jetzt nur noch "√ºber die Luft".  Wir verbinden das Kabel des Anbieters mit Ethernet und beginnen zu surfen! <br><br><h1>  8. Bonus: + 2,4 GHz </h1><br>  Als ich den ersten Himbeer-Router gem√§√ü der oben beschriebenen Zeichnung zusammenbaute, fand ich in meinem Haushalt eine Reihe von Ger√§ten, bei denen Wi-Fi aufgrund ihrer Designbeschr√§nkungen die "Himbeere" √ºberhaupt nicht sehen konnte.  Die Neukonfiguration des Routers f√ºr 802.11b / g / n war unsportlich, da die maximale Geschwindigkeit "√ºber Funk" in diesem Fall 40 Mbit / s nicht √ºberschritt und mein bevorzugter Internetprovider mir 100 (√ºber Kabel) anbietet. <br><br>  Tats√§chlich wurde bereits eine L√∂sung f√ºr das Problem erfunden: eine zweite Wi-Fi-Schnittstelle mit 2,4 GHz und ein zweiter Zugangspunkt.  Am n√§chsten Stand kaufte ich nicht die erste, sondern die zweite USB-WLAN-Pfeife, die mir einfiel.  Der Verk√§ufer wurde von Fragen zum Chipsatz, zur Kompatibilit√§t mit Linux-ARM-Kernen und zur M√∂glichkeit, im AP-Modus zu arbeiten, gequ√§lt (er startete zuerst). <br><br>  Wir konfigurieren die "Pfeife" analog zum eingebauten Wi-Fi-Adapter. <br><br>  <b>Benennen Sie</b> es zun√§chst in <b>wl1 um</b> : <br><br><pre> <code class="plaintext hljs"># cat /sys/class/net/wlan0/address b0:6e:bf:xx:xx:xx</code> </pre><br>  <b>/etc/systemd/network/wl1.link</b> : <br><br><pre> <code class="plaintext hljs">[Match] MACAddress=b0:6e:bf:xx:xx:xx [Link] Name=wl1</code> </pre><br>  Wir werden die Verwaltung der neuen Wi-Fi-Schnittstelle einem separaten Hostapd-Daemon anvertrauen, der abh√§ngig vom Vorhandensein einer streng definierten ‚ÄûPfeife‚Äú im System gestartet und gestoppt wird: wl1. <br><br>  Konfigurationsdatei <b>/etc/hostapd/hostapd2.conf</b> : <br><br><pre> <code class="plaintext hljs">ssid=rpi2 wpa_passphrase=1234567890 #channel=1 #channel=6 channel=11 interface=wl1 bridge=lan driver=nl80211 auth_algs=1 wpa=2 wpa_key_mgmt=WPA-PSK rsn_pairwise=CCMP macaddr_acl=0 hw_mode=g wmm_enabled=1 # N ieee80211n=1 require_ht=1 ht_capab=[HT40][SHORT-GI-20][SHORT-GI-40][DSSS_CCK-40]</code> </pre><br>  Der Inhalt dieser Datei h√§ngt direkt vom Modell des USB-WLAN-Adapters ab, sodass Sie beim einfachen Kopieren / Einf√ºgen im Stich gelassen werden k√∂nnen. <br><br>  Kopieren Sie die Distributionsdienstdatei nach <b>/etc/systemd/system/hostapd2.service</b> : <br><br><pre> <code class="plaintext hljs"># cp -fv /usr/lib/systemd/system/hostapd.service /etc/systemd/system/hostapd2.service</code> </pre><br>  und bringen Sie seinen Inhalt in die folgende Form: <br><br><pre> <code class="plaintext hljs">[Unit] Description=Hostapd IEEE 802.11 AP, IEEE 802.1X/WPA/WPA2/EAP/RADIUS Authenticator After=sys-subsystem-net-devices-wl1.device BindsTo=sys-subsystem-net-devices-wl1.device [Service] Type=forking PIDFile=/run/hostapd2.pid ExecStart=/usr/sbin/hostapd /etc/hostapd/hostapd2.conf -P /run/hostapd2.pid -B [Install] WantedBy=sys-subsystem-net-devices-wl1.device</code> </pre><br>  Es bleibt eine neue Instanz von hostapd einzuschlie√üen: <br><br><pre> <code class="plaintext hljs"># systemctl enable hostapd2</code> </pre><br>  Das ist alles!  Ziehen Sie die Pfeife und die Himbeere selbst und sehen Sie sich die drahtlosen Netzwerke an. <br><br>  Und schlie√ülich m√∂chte ich vor der Qualit√§t des USB-WLAN-Adapters und des Raspberry-Netzteils warnen.  Verbunden mit "einer hei√üen Pfeife", kann es manchmal zu einem "Himbeer-Hang" aufgrund kurzfristiger elektrischer Probleme kommen. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de458994/">https://habr.com/ru/post/de458994/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de458984/index.html">So erstellen Sie die erste Anwendung f√ºr den Handel an der B√∂rse: 3 erste Schritte</a></li>
<li><a href="../de458986/index.html">PostgreSQL-Rezepte: Konvertieren von HTML und URLs in PDF und PS</a></li>
<li><a href="../de458988/index.html">Texturierung oder was Sie wissen m√ºssen, um ein Oberfl√§chenk√ºnstler zu werden. Teil 4. Modelle, Normalen und Sweep</a></li>
<li><a href="../de458990/index.html">H√∂r auf eifrig mit Kommentaren im Code</a></li>
<li><a href="../de458992/index.html">Achtung f√ºr Dummies und Implementierung in Keras</a></li>
<li><a href="../de458996/index.html">User Inyerface - wie man den Benutzer nicht qu√§lt</a></li>
<li><a href="../de459000/index.html">Wie ich versucht habe, Halo 2 zu verbessern, es aber fast ruiniert habe</a></li>
<li><a href="../de459002/index.html">So konfigurieren Sie HTTPS - SSL Configuration Generator hilft</a></li>
<li><a href="../de459004/index.html">Grasshopper kryptografischer Algorithmus: fast der Komplex</a></li>
<li><a href="../de459012/index.html">Erstellen einer Anwendung f√ºr Bitrix24 von Grund auf neu</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>