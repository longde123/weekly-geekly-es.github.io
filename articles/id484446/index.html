<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîå üí´ üëéüèΩ Python 3.5 Menerapkan Concurrency Menggunakan asyncio ü•Ñ üëãüèæ üòù</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Terjemahan Bab 13 Concurrency 
 dari buku 'Pemrograman Python Ahli', 
 Edisi kedua 
 Micha≈Ç Jaworski & Tarek Ziad√©, 2016 
 
 Pemrograman asinkron 
 Da...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Python 3.5 Menerapkan Concurrency Menggunakan asyncio</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/484446/">  <i>Terjemahan Bab 13 Concurrency</i> <i><br></i>  <i>dari buku 'Pemrograman Python Ahli',</i> <i><br></i>  <i>Edisi kedua</i> <i><br></i>  <i>Micha≈Ç Jaworski &amp; Tarek Ziad√©, 2016</i> <i><br></i> <br><h4>  Pemrograman asinkron </h4><br>  Dalam beberapa tahun terakhir, pemrograman asinkron telah mendapatkan popularitas besar.  Python 3.5 akhirnya mendapatkan beberapa fungsi sintaksis yang memperkuat konsep solusi asinkron.  Tetapi ini tidak berarti bahwa pemrograman asinkron telah menjadi mungkin hanya sejak Python 3.5.  Banyak pustaka dan kerangka kerja yang disediakan jauh lebih awal, dan sebagian besar berasal dari versi Python yang lebih lama 2. Bahkan ada implementasi alternatif seluruh Python yang disebut Stackless (lihat Bab 1, ‚ÄúStatus Saat Ini dari Python‚Äù), yang berfokus pada pendekatan pemrograman tunggal ini.  Untuk beberapa solusi, seperti <b>Twisted, Tornado,</b> atau <b>Eventlet</b> , komunitas aktif masih ada dan benar-benar layak untuk diketahui.  Bagaimanapun, dimulai dengan Python 3.5, pemrograman asinkron telah menjadi lebih mudah daripada sebelumnya.  Dengan demikian, diharapkan bahwa fungsi asinkron bawaannya akan menggantikan sebagian besar alat lama, atau proyek eksternal akan secara bertahap berubah menjadi semacam kerangka kerja tingkat tinggi berdasarkan pada Python bawaan. <br><a name="habracut"></a><br>  Ketika mencoba menjelaskan apa pemrograman asinkron, paling mudah untuk menganggap pendekatan ini sebagai sesuatu yang mirip dengan utas, tetapi tanpa penjadwal sistem.  Ini berarti bahwa program asinkron dapat memproses tugas secara bersamaan, tetapi konteksnya diaktifkan secara internal dan bukan oleh penjadwal sistem. <br><br>  Tapi, tentu saja, kami tidak menggunakan utas untuk pemrosesan paralel tugas dalam program asinkron.  Sebagian besar solusi menggunakan konsep yang berbeda dan, tergantung pada implementasinya, dipanggil secara berbeda.  Beberapa contoh nama yang digunakan untuk menggambarkan objek program paralel tersebut adalah: <br><br><ul><li>  <b>Green threads</b> - Green threads (proyek greenlet, gevent atau eventlet) </li><li>  <b>Coroutines</b> - coroutines (pemrograman asynchronous murni dalam Python 3.5) </li><li>  <b>Tasklets (Stackless Python)</b> Ini pada dasarnya adalah konsep yang sama, tetapi sering diimplementasikan dalam cara yang sedikit berbeda. </li></ul><br>  Untuk alasan yang jelas, di bagian ini kita akan fokus hanya pada coroutine yang awalnya didukung oleh Python, dimulai dengan versi 3.5. <br><br><h4>  Multitasking kolaboratif dan I / O yang tidak sinkron </h4><br>  Multitasking kolaboratif adalah inti dari pemrograman asinkron.  Dalam hal ini, multitasking dalam sistem operasi tidak diperlukan untuk memulai pengalihan konteks (ke proses atau utas lainnya), tetapi sebaliknya, setiap proses secara sukarela melepaskan kontrol ketika berada dalam mode siaga untuk memastikan eksekusi beberapa program secara simultan.  Itulah mengapa disebut kolaboratif.  Semua proses harus bekerja bersama untuk memastikan multitasking berhasil. <br><br>  Model multitasking kadang-kadang digunakan dalam sistem operasi, tetapi sekarang hampir tidak dapat ditemukan sebagai solusi tingkat sistem.  Ini karena ada risiko bahwa satu layanan yang dirancang dengan buruk dapat dengan mudah mengganggu stabilitas seluruh sistem.  Menjadwalkan utas dan proses menggunakan sakelar konteks yang dikendalikan langsung oleh sistem operasi saat ini merupakan pendekatan dominan untuk konkurensi di tingkat sistem.  Tetapi multitasking kolaboratif masih merupakan alat konkurensi yang hebat di level aplikasi. <br><br>  Berbicara tentang multitasking bersama di tingkat aplikasi, kami tidak berurusan dengan utas atau proses yang perlu melepaskan kontrol, karena semua eksekusi terkandung dalam satu proses dan utas.  Sebagai gantinya, kami memiliki beberapa tugas (coroutine, tasklets, dan thread hijau) yang mentransfer kontrol ke fungsi tunggal yang mengontrol koordinasi tugas.  Fungsi ini biasanya semacam loop acara. <br><br>  Untuk menghindari kebingungan (karena terminologi Python), sekarang kita akan memanggil tugas paralel seperti coroutine.  Masalah paling penting dalam multitasking kolaboratif adalah kapan harus mentransfer kontrol.  Pada sebagian besar aplikasi asinkron, kontrol dilewatkan ke penjadwal atau loop peristiwa selama operasi I / O.  Terlepas dari apakah program membaca data dari sistem file atau berkomunikasi melalui soket, operasi I / O seperti itu selalu dikaitkan dengan beberapa waktu tunggu ketika proses menjadi tidak aktif.  Latensi tergantung pada sumber daya eksternal, jadi ini adalah kesempatan yang baik untuk membebaskan kontrol sehingga coroutine lain dapat melakukan pekerjaan mereka sampai mereka juga harus menunggu pendekatan ini agak mirip dalam perilaku dengan bagaimana multithreading diimplementasikan dalam Python.  Kita tahu bahwa GIL membuat serial utas-utas Python, tetapi juga dibebaskan dengan setiap operasi I / O.  Perbedaan utama adalah bahwa utas dalam Python diimplementasikan sebagai utas tingkat sistem, sehingga sistem operasi dapat membongkar utas yang saat ini berjalan kapan saja dan mentransfer kendali ke yang lain. <br><br>  Dalam pemrograman asinkron, tugas tidak pernah terganggu oleh loop acara utama.  Itu sebabnya gaya multitasking ini juga disebut multitasking non-prioritas. <br><br>  Tentu saja, setiap aplikasi Python berjalan pada sistem operasi di mana ada proses lain yang bersaing untuk sumber daya.  Ini berarti bahwa sistem operasi selalu memiliki hak untuk membongkar seluruh proses dan mentransfer kontrol ke yang lain.  Tetapi ketika aplikasi asinkron kami mulai kembali, itu berlanjut dari tempat yang sama di mana ia ditangguhkan ketika penjadwal sistem mengintervensi.  Itulah sebabnya coroutine dalam konteks ini dianggap tidak berdesakan. <br><br><h4>  Python async dan tunggu kata kunci </h4><br>  Kata kunci <i>async</i> dan <i>menunggu</i> adalah blok bangunan utama dalam pemrograman Python asinkron. <br><br>  Kata <i>kunci async yang</i> digunakan sebelum pernyataan <i>def</i> mendefinisikan coroutine baru.  Fungsi coroutine dapat ditangguhkan dan dilanjutkan dalam kondisi yang ditentukan secara ketat.  Sintaks dan perilakunya sangat mirip dengan generator (lihat Bab 2, ‚ÄúRekomendasi Sintaks,‚Äù di bawah level kelas).  Bahkan, generator harus digunakan dalam versi Python yang lebih lama untuk mengimplementasikan coroutine.  Berikut adalah contoh pernyataan fungsi yang menggunakan <i>kata kunci async</i> : <br><br><pre><code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">async_hello</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> print(<span class="hljs-string"><span class="hljs-string">"hello, world!"</span></span>)</code> </pre> <br>  Fungsi yang didefinisikan menggunakan <i>kata kunci async</i> adalah spesial.  Saat dipanggil, mereka tidak mengeksekusi kode di dalam, tetapi mengembalikan objek coroutine: <br><br><pre> <b><code class="plaintext hljs">&gt;&gt;&gt;&gt; async def async_hello(): ... print("hello, world!") ... &gt;&gt;&gt; async_hello() &lt;coroutine object async_hello at 0x1014129e8&gt;</code></b> </pre><br>  Objek coroutine tidak melakukan apa-apa sampai eksekusinya dijadwalkan di loop acara.  Modul asyncio tersedia untuk menyediakan implementasi dasar dari loop acara, serta banyak utilitas asinkron lainnya: <br><br><pre> <b><code class="plaintext hljs">&gt;&gt;&gt; import asyncio &gt;&gt;&gt; async def async_hello(): ... print("hello, world!") ... &gt;&gt;&gt; loop = asyncio.get_event_loop() &gt;&gt;&gt; loop.run_until_complete(async_hello()) hello, world! &gt;&gt;&gt; loop.close()</code></b> </pre><br>  Secara alami, hanya membuat satu coroutine sederhana, dalam program kami, kami tidak menerapkan paralelisme.  Untuk melihat sesuatu yang benar-benar paralel, kita perlu membuat lebih banyak tugas yang akan dilakukan oleh loop peristiwa. <br><br>  Tugas baru dapat ditambahkan ke loop dengan memanggil metode <i>loop.create_task ()</i> atau dengan menyediakan objek lain untuk menunggu penggunaan fungsi <i>asyncio.wait ()</i> .  Kami akan menggunakan pendekatan yang terakhir dan mencoba untuk mencetak secara asinkron urutan angka yang dihasilkan menggunakan fungsi <i>range ()</i> : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">print_number</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(number)</span></span></span><span class="hljs-function">:</span></span> print(number) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: loop = asyncio.get_event_loop() loop.run_until_complete( asyncio.wait([ print_number(number) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> number <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">10</span></span>) ]) ) loop.close()</code> </pre><br>  Fungsi <i>asyncio.wait ()</i> menerima daftar objek coroutine dan segera kembali.  Hasilnya adalah generator yang menghasilkan objek yang mewakili hasil masa depan (futures).  Seperti namanya, itu digunakan untuk menunggu semua coroutine yang disediakan untuk menyelesaikan.  Alasan mengembalikan generator alih-alih objek coroutine adalah karena itu kompatibel dengan versi Python sebelumnya, yang akan dijelaskan nanti.  Hasil menjalankan skrip ini mungkin sebagai berikut: <br><br><pre> <b><code class="plaintext hljs">$ python asyncprint.py 0 7 8 3 9 4 1 5 2 6</code></b> </pre><br>  Seperti yang bisa kita lihat, angka tidak dicetak sesuai urutan kita membuat coroutine kita.  Tapi inilah yang ingin kami capai. <br><br>  Kata kunci penting kedua yang ditambahkan dalam Python 3.5 sedang <i>menunggu</i> .  Ini digunakan untuk menunggu hasil dari coroutine atau acara mendatang (dijelaskan nanti) dan melepaskan kontrol atas eksekusi di loop acara.  Untuk lebih memahami bagaimana ini bekerja, kita perlu mempertimbangkan contoh kode yang lebih kompleks. <br><br>  Misalkan kita ingin membuat dua coroutine yang akan melakukan beberapa tugas sederhana dalam satu lingkaran: <br><br><ul><li>  Tunggu beberapa detik secara acak </li><li>  Cetak beberapa teks yang disediakan sebagai argumen, dan jumlah waktu yang dihabiskan untuk menunggu.  Mari kita mulai dengan implementasi sederhana yang memiliki beberapa masalah konkurensi yang akan kami coba tingkatkan nanti dengan tambahan penggunaan menunggu: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> time <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> random <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waiter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">4</span></span>): time_to_sleep = random.randint(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) / <span class="hljs-number"><span class="hljs-number">4</span></span> time.sleep(time_to_sleep) print( <span class="hljs-string"><span class="hljs-string">"{} waited {} seconds"</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>.format(name, time_to_sleep) ) <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.wait([waiter(<span class="hljs-string"><span class="hljs-string">"foo"</span></span>), waiter(<span class="hljs-string"><span class="hljs-string">"bar"</span></span>)]) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> __name__ == <span class="hljs-string"><span class="hljs-string">"__main__"</span></span>: loop = asyncio.get_event_loop() loop.run_until_complete(main()) loop.close()</code> </pre></li></ul><br>  Ketika dieksekusi di terminal (menggunakan perintah waktu untuk mengukur waktu), Anda dapat melihat: <br><br><pre> <b><code class="plaintext hljs">$ time python corowait.py bar waited 0.25 seconds bar waited 0.25 seconds bar waited 0.5 seconds bar waited 0.5 seconds foo waited 0.75 seconds foo waited 0.75 seconds foo waited 0.25 seconds foo waited 0.25 seconds real 0m3.734s user 0m0.153s sys 0m0.028s</code></b> </pre><br><br>  Seperti yang bisa kita lihat, kedua coroutine menyelesaikan eksekusi mereka, tetapi tidak secara sinkron.  Alasannya adalah bahwa mereka berdua menggunakan fungsi <i>time.sleep ()</i> , yang mengunci tetapi tidak melepaskan kontrol di loop acara.  Ini akan berfungsi lebih baik di pemasangan multi-utas, tetapi kami tidak ingin menggunakan streaming sekarang.  Jadi bagaimana kita memperbaikinya? <br><br>  Jawabannya adalah menggunakan <i>asyncio.sleep ()</i> , yang merupakan versi time.sleep () yang asinkron, dan mengharapkan hasilnya menggunakan kata kunci <i>tunggu</i> .  Kami sudah menggunakan pernyataan ini di versi <i>utama ()</i> , tetapi ini hanya untuk meningkatkan kejelasan kode.  Ini jelas tidak membuat implementasi kami lebih paralel.  Mari kita lihat versi perbaikan dari waitout () coroutine yang menggunakan wait asyncio.sleep (): <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">waiter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _ <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(<span class="hljs-number"><span class="hljs-number">4</span></span>): time_to_sleep = random.randint(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) / <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(time_to_sleep) print( <span class="hljs-string"><span class="hljs-string">"{} waited {} seconds"</span></span> <span class="hljs-string"><span class="hljs-string">""</span></span>.format(name, time_to_sleep) )</code> </pre><br><br>  Menjalankan skrip yang diperbarui, kita akan melihat bagaimana output dari dua fungsi saling bergantian: <br><br><pre> <b><code class="plaintext hljs">$ time python corowait_improved.py bar waited 0.25 seconds foo waited 0.25 seconds bar waited 0.25 seconds foo waited 0.5 seconds foo waited 0.25 seconds bar waited 0.75 seconds foo waited 0.25 seconds bar waited 0.5 seconds real 0m1.953s user 0m0.149s sys 0m0.026s</code></b> </pre><br><br>  Manfaat tambahan dari peningkatan sederhana ini adalah bahwa kode berjalan lebih cepat.  Total waktu eksekusi kurang dari jumlah semua waktu tidur, karena coroutine mengambil kendali satu per satu. <br><br><h4>  Asyncio di versi Python sebelumnya </h4><br>  Modul asyncio muncul dalam Python 3.4.  Jadi ini adalah satu-satunya versi Python yang memiliki dukungan serius untuk pemrograman asinkron sebelum Python 3.5.  Sayangnya, tampaknya kedua versi berikut ini sudah cukup untuk menyajikan masalah kompatibilitas. <br><br>  Bagaimanapun, inti pemrograman asinkron dalam Python diperkenalkan lebih awal dari elemen sintaks yang mendukung templat ini.  Lebih baik terlambat daripada tidak sama sekali, tetapi ini menciptakan situasi di mana ada dua sintaks untuk bekerja dengan coroutine. <br><br>  Dimulai dengan Python 3.5, Anda dapat menggunakan <i>async</i> dan <i>menunggu</i> : <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> asyncio.sleep(<span class="hljs-number"><span class="hljs-number">0</span></span>)</code> </pre><br><br>  Namun, dalam Python 3.4, Anda harus menerapkan dekorator asyncio.coroutine dan menghasilkan teks coroutine sebagai tambahan: <br><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta">@asyncio.couroutine def main(): yield from asyncio.sleep(0)</span></span></code> </pre><br><br>  Fakta lain yang bermanfaat adalah bahwa <i>hasil dari pernyataan</i> diperkenalkan dalam Python 3.3, dan PyPI memiliki backport asinkron.  Ini berarti bahwa Anda juga dapat menggunakan implementasi multitasking kolaboratif ini dengan Python 3.3. <br><br><h4>  Contoh praktis pemrograman asinkron </h4><br>  Seperti yang disebutkan berulang kali dalam bab ini, pemrograman asinkron adalah alat yang hebat untuk menangani I / O.  Sudah waktunya untuk membuat sesuatu yang lebih praktis dari sekedar mencetak urutan atau menunggu tanpa sinkronisasi. <br><br>  Untuk memastikan konsistensi, kami akan mencoba memecahkan masalah yang sama yang kami pecahkan dengan bantuan multithreading dan multiprocessing.  Oleh karena itu, kami akan mencoba mengekstrak beberapa data dari sumber daya eksternal secara tidak sinkron melalui koneksi jaringan.  Akan lebih bagus jika kita bisa menggunakan paket <i>python-gmaps</i> yang sama seperti pada bagian sebelumnya.  Sayangnya, kami tidak bisa. <br><br>  Pencipta <i>python-gmaps</i> agak malas dan hanya mengambil nama.  Untuk menyederhanakan pengembangan, ia memilih paket permintaan sebagai pustaka klien HTTP-nya.  Sayangnya, permintaan tidak mendukung I / O <i>asinkron</i> dengan <i>async</i> dan <i>menunggu</i> .  Ada beberapa proyek lain yang bertujuan untuk memberikan beberapa paralelisme untuk proyek permintaan, tetapi mereka juga mengandalkan <i>Gevent</i> ( <i>grequests</i> , lihat <i>https://github.com/ kennethreitz / grequests</i> ) atau menjalankan thread / proses pool (query-futures) lihat <i><a href="https://github.com/ross/requests-futures" rel="nofollow">github.com/ross/requests-futures</a></i> ).  Tak satu pun dari mereka memecahkan masalah kita. <br><br><blockquote>  <i>Sebelum mencela diri sendiri karena telah memarahi pengembang open source yang tidak bersalah, tenanglah.</i>  <i>Orang di belakang paket <i>python-gmaps</i> adalah saya.</i>  <i>Pilihan dependensi yang buruk adalah salah satu masalah proyek ini.</i>  <i>Saya hanya suka mengkritik diri sendiri di depan umum dari waktu ke waktu.</i>  <i>Ini akan menjadi pelajaran pahit bagi saya, karena <i>python-gmaps</i> dalam versi terbarunya (0.3.1 pada saat menulis buku ini) tidak dapat dengan mudah diintegrasikan dengan Python I / O yang tidak sinkron.</i>  <i>Bagaimanapun, ini mungkin berubah di masa depan, jadi tidak ada yang hilang.</i> <br></blockquote>  Mengetahui keterbatasan perpustakaan, yang sangat mudah digunakan dalam contoh sebelumnya, kita perlu membuat sesuatu yang mengisi celah ini.  Google MapsAPI sangat mudah digunakan, jadi kami akan menyiapkan utilitas asinkron hanya untuk ilustrasi.  Pustaka standar Python 3.5 masih kekurangan pustaka yang dapat mengeksekusi permintaan HTTP asinkron semudah memanggil <i>urllib.urlopen ()</i> .  Kami jelas tidak ingin membuat dukungan protokol penuh dari awal, jadi kami akan menggunakan sedikit bantuan dari paket <i>aiohttp</i> yang tersedia di PyPI.  Ini adalah perpustakaan yang sangat menjanjikan yang menambahkan implementasi klien dan server untuk HTTP asinkron.  Berikut adalah modul kecil yang dibangun di atas <i>aiohttp</i> yang membuat satu fungsi pembantu <i>geocode ()</i> yang mengeksekusi permintaan geocoding ke layanan Google Maps API: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> aiohttp session = aiohttp.ClientSession() <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">geocode</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(place)</span></span></span><span class="hljs-function">:</span></span> params = { <span class="hljs-string"><span class="hljs-string">'sensor'</span></span>: <span class="hljs-string"><span class="hljs-string">'false'</span></span>, <span class="hljs-string"><span class="hljs-string">'address'</span></span>: place } <span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> session.get( <span class="hljs-string"><span class="hljs-string">'https://maps.googleapis.com/maps/api/geocode/json'</span></span>, params=params ) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> response: result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> response.json() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result[<span class="hljs-string"><span class="hljs-string">'results'</span></span>]</code> </pre><br><br>  Mari kita asumsikan bahwa kode ini disimpan dalam modul bernama <i>asyncgmaps</i> , yang akan kita gunakan nanti.  Sekarang kita siap untuk menulis ulang contoh yang digunakan dalam diskusi multithreading dan multiprocessing.  Sebelumnya, kami biasa memisahkan seluruh operasi menjadi dua tahap terpisah: <br><br><ol><li>  Memenuhi semua permintaan ke layanan eksternal secara paralel menggunakan fungsi <i>fetch_place ()</i> . </li><li>  Tampilkan semua hasil dalam satu lingkaran menggunakan fungsi <i>present_result ()</i> . </li></ol><br>  Tetapi karena multitasking kolaboratif sama sekali berbeda dari menggunakan beberapa proses atau utas, kami dapat sedikit mengubah pendekatan kami.  Sebagian besar masalah yang diangkat dalam Menggunakan satu utas per item tidak lagi menjadi perhatian kami. <br>  Coroutine bukan preemptive, jadi kami dapat dengan mudah menampilkan hasilnya segera setelah menerima tanggapan HTTP.  Ini akan menyederhanakan kode kami dan membuatnya lebih dimengerti: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> asyncio <span class="hljs-comment"><span class="hljs-comment"># note: local module introduced earlier from asyncgmaps import geocode, session PLACES = ( 'Reykjavik', 'Vien', 'Zadar', 'Venice', 'Wroc≈Çaw', 'Bolognia', 'Berlin', 'S≈Çubice', 'New York', 'Dehli', ) async def fetch_place(place): return (await geocode(place))[0] async def present_result(result): geocoded = await result print("{:&gt;25s}, {:6.2f}, {:6.2f}".format( geocoded['formatted_address'], geocoded['geometry']['location']['lat'], geocoded['geometry']['location']['lng'], )) async def main(): await asyncio.wait([ present_result(fetch_place(place)) for place in PLACES ]) if __name__ == "__main__": loop = asyncio.get_event_loop() loop.run_until_complete(main()) # aiohttp will raise issue about unclosed # ClientSession so we perform cleanup manually loop.run_until_complete(session.close()) loop.close()</span></span></code> </pre><br><br>  Pemrograman asinkron sangat bagus untuk pengembang backend yang tertarik dalam membangun aplikasi yang dapat diskalakan.  Dalam praktiknya, ini adalah salah satu alat paling penting untuk membuat server yang sangat kompetitif. <br><br>  Tetapi kenyataannya menyedihkan.  Banyak paket populer yang menangani masalah I / O tidak dimaksudkan untuk digunakan dengan kode asinkron.  Alasan utama untuk ini adalah: <br><br><ul><li>  Implementasi Python 3 masih rendah dan beberapa fitur canggihnya </li><li>  Pemahaman yang rendah tentang berbagai konsep konkurensi di kalangan pemula untuk belajar Python </li></ul><br>  Ini berarti bahwa sangat sering migrasi aplikasi dan paket multi-threaded sinkron yang ada tidak mungkin (karena batasan arsitektur) atau terlalu mahal.  Banyak proyek dapat sangat diuntungkan dari penerapan gaya multitasking asinkron, tetapi hanya sedikit yang pada akhirnya akan melakukannya.  Ini berarti bahwa saat ini Anda akan mengalami banyak kesulitan dalam mencoba membuat aplikasi asinkron sejak awal.  Dalam kebanyakan kasus, ini akan mirip dengan masalah yang disebutkan di bagian "Contoh Praktis Pemrograman Asinkron" - antarmuka yang tidak kompatibel dan pemblokiran non-sinkron operasi I / O.  Tentu saja, kadang-kadang Anda bisa menyerah menunggu ketika Anda mengalami ketidakcocokan tersebut dan hanya mendapatkan sumber daya yang diperlukan secara serempak.  Tapi ini akan memblokir masing-masing coroutine lain dari mengeksekusi kodenya sementara Anda menunggu hasilnya.  Secara teknis, ini berfungsi, tetapi juga menghancurkan semua manfaat pemrograman asinkron.  Jadi, pada akhirnya, menggabungkan I / O asinkron dengan I / O sinkron bukanlah suatu pilihan.  Ini semua atau tidak sama sekali game. <br><br>  Masalah lain adalah operasi yang terikat prosesor yang panjang.  Ketika Anda melakukan operasi I / O, tidak ada masalah melepaskan kontrol dari coroutine.  Saat menulis / membaca dari sistem file atau soket, Anda akhirnya akan menunggu, jadi panggilan menggunakan menunggu adalah yang terbaik yang dapat Anda lakukan.  Tetapi bagaimana jika Anda perlu menghitung sesuatu, dan Anda tahu itu akan memakan waktu?  Tentu saja, Anda dapat membagi masalah menjadi beberapa bagian dan membatalkan kontrol setiap kali Anda sedikit memajukan pekerjaan.  Tetapi segera Anda akan menemukan bahwa ini bukan model yang sangat baik.  Hal seperti itu dapat membuat kode berantakan, dan juga tidak menjamin hasil yang baik. <br><br>  Pengikatan temporal harus menjadi tanggung jawab penerjemah atau sistem operasi. <br><br><h4>  Menggabungkan Kode Asynchronous dengan Asynchronous Futures </h4><br>  Jadi apa yang harus dilakukan jika Anda memiliki kode yang melakukan I / O sinkron panjang sehingga Anda tidak dapat atau tidak ingin menulis ulang.  Atau apa yang harus dilakukan ketika Anda harus melakukan beberapa operasi prosesor berat dalam aplikasi yang dirancang terutama untuk I / O asinkron?  Nah ... Anda perlu mencari solusinya.  Dan maksud saya multithreading atau multiprocessing. <br><br>  Ini mungkin kedengarannya tidak terlalu bagus, tetapi kadang-kadang solusi terbaik mungkin adalah apa yang kami coba hindari.  Pemrosesan paralel tugas intensif sumber daya dengan Python selalu dilakukan dengan lebih baik karena multi-pemrosesan.  Dan multithreading dapat menangani operasi I / O dengan sama baiknya (dengan cepat dan tanpa banyak sumber daya), tidak sinkron dan menunggu jika dikonfigurasi dengan benar dan ditangani dengan hati-hati. <br><br>  Jadi kadang-kadang, ketika Anda tidak tahu apa yang harus dilakukan ketika sesuatu tidak sesuai dengan aplikasi asinkron Anda, gunakan sepotong kode yang meletakkannya di utas atau proses terpisah.  Anda bisa berpura-pura itu coroutine, melepaskan kontrol untuk loop acara, dan akhirnya memproses hasilnya ketika sudah siap. <br><br>  Untungnya bagi kami, pustaka standar Python menyediakan modul <i>concurrent.futures</i> , yang juga terintegrasi dengan modul <i>asyncio</i> .  Bersama-sama, kedua modul ini memungkinkan Anda untuk merencanakan fungsi pemblokiran yang dieksekusi di utas atau proses tambahan, seolah-olah mereka adalah coroutine non-blocking asinkron. <br><br><h4>  Pelaksana dan masa depan </h4><br>  Sebelum kita melihat bagaimana menanamkan utas atau proses dalam loop peristiwa asinkron, kita melihat lebih dekat pada modul <i>concurrent.futures</i> , yang nantinya akan menjadi komponen utama dari apa yang disebut solusi kami. <br><br>  Kelas yang paling penting dalam modul <i>concurrent.futures</i> adalah <i>Pelaksana</i> dan <i>Masa Depan</i> . <br><br>  <i>Pelaksana</i> adalah kumpulan sumber daya yang dapat memproses item kerja secara paralel.  Ini mungkin terlihat sangat mirip dengan tujuan dari kelas-kelas dari modul multiprosesor - <i>Pool</i> dan <i>dummy.Pool</i> - tetapi memiliki antarmuka dan semantik yang sama sekali berbeda.  Ini adalah kelas dasar yang tidak dimaksudkan untuk implementasi dan memiliki dua implementasi spesifik: <br><br><ul><li>  <i>ThreadPoolExecutor</i> : yang mewakili kumpulan utas </li><li>  <i>ProcessPoolExecutor</i> : yang mewakili kumpulan proses </li></ul><br>  Setiap <i>pelaksana</i> menyajikan tiga metode: <br><br><ul><li>  <i>submit (fn, * args, ** kwargs)</i> : menjadwalkan fungsi fn untuk dieksekusi di pool sumber daya dan mengembalikan objek Future yang mewakili eksekusi objek yang dipanggil </li><li>  <i>map (func, * iterables, timeout = Tidak ada, chunksize = 1)</i> : fungsi <i>func</i> dieksekusi pada iterasi yang mirip dengan multiprocessing.  <i>Metode Pool.map ()</i> </li><li>  <i>shutdown (wait = True)</i> : ini mematikan <i>Executor</i> dan membebaskan semua sumber dayanya. </li></ul><br>  Metode yang paling menarik adalah <i>submit ()</i> karena objek Future yang dikembalikannya.  Ini mewakili eksekusi asynchronous dari yang dipanggil dan hanya secara tidak langsung mewakili hasilnya.  Untuk mendapatkan nilai balik aktual dari objek yang dipanggil yang dikirim, Anda harus memanggil metode <i>Future.result ()</i> .  Dan jika objek yang dipanggil sudah selesai, metode <i>result ()</i> tidak akan memblokirnya dan hanya akan mengembalikan output dari fungsi.  Jika tidak, ia akan memblokirnya sampai hasilnya siap.  Anggap saja sebagai janji hasil (itu sebenarnya konsep yang sama dengan janji dalam JavaScript).  Anda tidak perlu membongkar segera setelah menerimanya (menggunakan metode <i>result ()</i> ), tetapi jika Anda mencoba melakukan ini, dijamin pada akhirnya akan mengembalikan sesuatu: <br><br><pre> <b><code class="plaintext hljs">&gt;&gt;&gt; def loudy_return(): ... print("processing") ... return 42 ... &gt;&gt;&gt; from concurrent.futures import ThreadPoolExecutor &gt;&gt;&gt; with ThreadPoolExecutor(1) as executor: ... future = executor.submit(loudy_return) ... processing &gt;&gt;&gt; future &lt;Future at 0x33cbf98 state=finished returned int&gt; &gt;&gt;&gt; future.result() 42</code></b> </pre><br><br>  Jika Anda ingin menggunakan metode <i>Executor.map ()</i> , itu tidak berbeda dalam penggunaan dari metode <i>Pool.map ()</i> dari kelas <i>Pool</i> dari modul multiprosesor: <br><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">with</span></span> ThreadPoolExecutor(POOL_SIZE) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> pool: results = pool.map(fetch_place, PLACES) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> result <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> results: present_result(result)</code> </pre><br><br><h4>  Menggunakan <i>Pelaksana</i> dalam <i>Lingkaran</i> Peristiwa </h4><br>  Contoh-contoh dari kelas Future yang dikembalikan oleh metode <i>Executor.submit ()</i> secara konseptual sangat dekat dengan coroutine yang digunakan dalam pemrograman asinkron.  Karena itulah kita dapat menggunakan artis untuk membuat hibrid antara multitasking kolaboratif dan multiprosesing atau multithreading. <br><br>  Inti dari pemecahan masalah ini adalah metode <i>BaseEventLoop.run_in_executor (executor, func, * args)</i> dari kelas loop <i>acara</i> .  Ini memungkinkan Anda untuk merencanakan eksekusi fungsi func dalam proses atau kumpulan utas yang diwakili oleh argumen pelaksana.  Yang paling penting tentang metode ini adalah ia mengembalikan objek baru yang diharapkan (objek yang dapat diharapkan menggunakan operator menunggu).  Dengan demikian, berkat ini, Anda dapat melakukan fungsi pemblokiran yang bukan coroutine persis seperti coroutine, dan itu tidak akan memblokir, tidak peduli berapa lama untuk menyelesaikannya.  Ini akan berhenti hanya fungsi yang mengharapkan hasil dari panggilan seperti itu, tetapi seluruh siklus acara akan berlanjut. <br><br>  Dan fakta yang berguna adalah bahwa Anda bahkan tidak perlu membuat instance dari eksekutor Anda sendiri.  Jika Anda melewatkan <i>Tidak Ada</i> sebagai argumen kepada <i>pelaksana</i> , kelas <i>ThreadPoolExecutor</i> akan digunakan dengan jumlah utas default (untuk Python 3.5, ini adalah jumlah prosesor yang dikalikan 5). <br><br>  Jadi, mari kita asumsikan bahwa kita tidak ingin menulis ulang bagian bermasalah dari paket python-gmaps yang menyebabkan sakit kepala kita.  Kita dapat dengan mudah menunda panggilan pemblokiran ke utas terpisah dengan memanggil <i>loop.run_in_executor ()</i> , sambil meninggalkan fungsi fetch_place () sebagai coroutine yang diharapkan: <br><br><pre> <code class="python hljs"><span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">fetch_place</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(place)</span></span></span><span class="hljs-function">:</span></span> coro = loop.run_in_executor(<span class="hljs-keyword"><span class="hljs-keyword">None</span></span>, api.geocode, place) result = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> coro <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> result[<span class="hljs-number"><span class="hljs-number">0</span></span>]</code> </pre><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Solusi semacam itu lebih buruk daripada memiliki perpustakaan yang sepenuhnya tidak sinkron untuk melakukan pekerjaan itu, tetapi Anda tahu bahwa setidaknya ada sesuatu yang lebih baik daripada tidak sama sekali. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah menjelaskan apa sebenarnya konkurensi, kami mengambil tindakan dan menganalisis salah satu masalah paralel yang khas dengan menggunakan multithreading. Setelah mengidentifikasi kekurangan utama dari kode kami dan memperbaikinya, kami beralih ke multi-pemrosesan untuk melihat bagaimana cara kerjanya dalam kasus kami. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah itu, kami menemukan bahwa dengan modul multiprosesor, menggunakan beberapa proses jauh lebih mudah daripada utas dasar dengan multithreading. Tetapi hanya setelah itu kami menyadari bahwa kami dapat menggunakan API yang sama dengan utas, berkat </font></font><i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">multiprocessing.dummy</font></font></i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Dengan demikian, pilihan antara multiprosesing dan multithreading sekarang hanya bergantung pada solusi mana yang lebih cocok dengan masalah, dan bukan solusi mana yang memiliki antarmuka terbaik. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berbicara tentang menyesuaikan masalah, kami akhirnya mencoba pemrograman asinkron, yang seharusnya menjadi solusi terbaik untuk aplikasi terkait I / O, hanya untuk memahami bahwa kami tidak dapat sepenuhnya melupakan thread dan proses. Jadi kami membuat lingkaran, kembali ke tempat kami mulai!</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dan ini membawa kita pada kesimpulan akhir bab ini. </font><font style="vertical-align: inherit;">Tidak ada solusi yang cocok untuk semua orang. </font><font style="vertical-align: inherit;">Ada beberapa pendekatan yang Anda sukai atau sukai. </font><font style="vertical-align: inherit;">Ada beberapa pendekatan yang lebih cocok untuk serangkaian masalah ini, tetapi Anda perlu tahu semuanya untuk menjadi sukses. </font><font style="vertical-align: inherit;">Dalam skenario realistis, Anda dapat menggunakan seluruh gudang alat dan gaya paralelisme dalam satu aplikasi, dan ini tidak jarang. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesimpulan sebelumnya adalah pengantar yang sangat baik untuk topik bab berikutnya, Bab 14 "Pola Desain Berguna". </font><font style="vertical-align: inherit;">Karena tidak ada templat tunggal yang akan menyelesaikan semua masalah Anda. </font><font style="vertical-align: inherit;">Anda harus tahu sebanyak mungkin, karena pada akhirnya Anda akan menggunakannya setiap hari.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id484446/">https://habr.com/ru/post/id484446/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id484436/index.html">Opensource tidak berterima: pengembang server web tercepat telah menghapus repositori - Pembaruan penting</a></li>
<li><a href="../id484438/index.html">Persamaan fluida terkenal bocor</a></li>
<li><a href="../id484440/index.html">Cadangan Penuh dengan alat Windows standar</a></li>
<li><a href="../id484442/index.html">Contoh SNMPv3</a></li>
<li><a href="../id484444/index.html">Bagaimana kondisi operasi mempengaruhi baterai, atau kisah kebangkitan yang ajaib</a></li>
<li><a href="../id484448/index.html">Konferensi DEFCON 27. Peretasan polisi. Bagian 1</a></li>
<li><a href="../id484454/index.html">Detektif Habra: fotomu hilang</a></li>
<li><a href="../id484456/index.html">ReactJS, rendering Sisi Server dan beberapa seluk-beluk pemrosesan tag meta halaman</a></li>
<li><a href="../id484458/index.html">Pekerja lepas ini rusak - beri saya yang berikutnya</a></li>
<li><a href="../id484462/index.html">Scraping Github: Mencari "Rahasia" untuk Dikembangkan</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>