<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üòö ü§ΩüèΩ üëµüèø C√≥mo ayudaron los gr√°ficos de redes neuronales üñºÔ∏è üòì üéí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="En 1943, los neuropsic√≥logos estadounidenses McCallock y Pitts desarrollaron un modelo inform√°tico de una red neuronal, y en 1958 la primera red de un...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C√≥mo ayudaron los gr√°ficos de redes neuronales</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/441260/">  En 1943, los neuropsic√≥logos estadounidenses McCallock y Pitts desarrollaron un modelo inform√°tico de una red neuronal, y en 1958 la <strong>primera</strong> red de una sola capa en funcionamiento reconoci√≥ algunas letras.  Ahora, las redes neuronales simplemente no se usan para qu√©: predecir el tipo de cambio, diagnosticar enfermedades, pilotos autom√°ticos y crear gr√°ficos en juegos de computadora.  Solo sobre el √∫ltimo y hablamos. <br><br>  <strong>Evgeni Tumanov</strong> trabaja como ingeniero de aprendizaje profundo en <strong>NVIDIA</strong> .  Con base en los resultados de su discurso en la conferencia HighLoad ++, preparamos una historia sobre el uso de Machine Learning y Deep Learning en gr√°ficos.  El aprendizaje autom√°tico no termina con PNL, visi√≥n artificial, sistemas de recomendaci√≥n y tareas de b√∫squeda.  Incluso si no est√° muy familiarizado con esta √°rea, puede aplicar las mejores pr√°cticas del art√≠culo en su campo o industria. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/eeCYmJQAyKA" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  La historia constar√° de tres partes.  Revisaremos las tareas en el gr√°fico que se resuelven con la ayuda del aprendizaje autom√°tico, derivaremos la idea principal y describiremos el caso de aplicar esta idea en una tarea espec√≠fica y espec√≠ficamente en la <b>representaci√≥n de nubes</b> . <a name="habracut"></a><br><br><h2>  DL / ML supervisado en gr√°ficos, o capacitaci√≥n de maestros en gr√°ficos </h2><br>  Analicemos dos grupos de tareas.  Para empezar, den√≥talos brevemente. <br><br>  <strong>Motor del mundo real o render</strong> : <br><br><ul><li>  Creaci√≥n de animaciones cre√≠bles: locomoci√≥n, animaci√≥n facial. </li><li>  Post-procesamiento de im√°genes renderizadas: supermuestreo, anti-aliasing. </li><li>  Slowmotion: interpolaci√≥n de trama. </li><li>  Generaci√≥n de materiales. </li></ul><br>  El segundo grupo de tareas ahora se llama convencionalmente " <strong>Algoritmo pesado</strong> ".  Incluimos tareas como renderizar objetos complejos, como nubes, y <strong>simulaciones f√≠sicas</strong> : agua, humo. <br><br>  Nuestro objetivo es comprender la diferencia fundamental entre los dos grupos.  Consideremos las tareas con m√°s detalle. <br><br><h3>  Creaci√≥n de animaciones cre√≠bles: locomoci√≥n, animaci√≥n facial. <br></h3><br>  En los √∫ltimos a√±os, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">han aparecido</a> muchos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">art√≠culos</a> , donde los investigadores ofrecen nuevas formas de generar hermosas animaciones.  Usar el trabajo de artistas es costoso, y reemplazarlos con un algoritmo ser√≠a muy beneficioso para todos.  Hace un a√±o, en NVIDIA, est√°bamos trabajando en un proyecto en el que nos dedicamos a la animaci√≥n facial de los personajes en los juegos: sincronizar la cara del h√©roe con la pista de audio del discurso.  Intentamos "revivir" la cara para que cada punto se moviera, y sobre todo los labios, porque este es el momento m√°s dif√≠cil de la animaci√≥n.  Manualmente un artista para hacer esto caro y durante mucho tiempo.  ¬øCu√°les son las opciones para resolver este problema y crear un <strong>conjunto</strong> de <strong>datos</strong> ? <br><br>  La primera opci√≥n es <strong>identificar las vocales: la boca se abre en las vocales, la boca se cierra en las consonantes</strong> .  Este es un algoritmo simple, pero demasiado simple.  En los juegos, queremos m√°s calidad.  La segunda opci√≥n es hacer <strong>que las personas lean diferentes textos y escriban sus caras, y luego comparen las letras que pronuncian con expresiones faciales.</strong>  Esta es una buena idea, y lo hicimos en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">proyecto</a> conjunto con Remedy Entertainment.  La √∫nica diferencia es que en el juego no mostramos un video, sino un modelo 3D de puntos.  Para ensamblar un conjunto de datos, debe comprender c√≥mo se mueven puntos espec√≠ficos de la cara.  Tomamos actores, pedimos leer textos con diferentes entonaciones, filmamos en muy buenas c√°maras desde diferentes √°ngulos, despu√©s de lo cual restauramos el modelo 3D de caras en cada cuadro y predijimos la posici√≥n de los puntos en la cara por sonido. <br><br><h3>  Procesamiento de imagen de procesamiento posterior: supermuestreo, anti-aliasing <br></h3><br>  Considere un caso de un juego espec√≠fico: tenemos un motor que genera im√°genes en diferentes resoluciones.  Queremos renderizar la imagen en una resoluci√≥n de 1000 √ó 500 p√≠xeles, y mostrarle al jugador 2000 √ó 1000, esto ser√° m√°s bonito.  ¬øC√≥mo ensamblar un conjunto de datos para esta tarea? <br><br>  Primero renderice la imagen en alta resoluci√≥n, luego baje la calidad y luego intente entrenar el sistema para convertir la imagen de baja resoluci√≥n a alta resoluci√≥n. <br><br><h3>  C√°mara lenta: interpolaci√≥n de trama <br></h3><br>  Tenemos un video y queremos que la red agregue fotogramas en el medio, para interpolar fotogramas.  La idea es obvia: grabar un video real con una gran cantidad de cuadros, eliminar los intermedios e intentar predecir lo que la red elimin√≥. <br><br><h3>  Generaci√≥n de material <br></h3><br>  No nos detendremos mucho en la generaci√≥n de materiales.  Su esencia es que tomamos, por ejemplo, una pieza de madera en varios √°ngulos de iluminaci√≥n e interpolamos la vista desde otros √°ngulos. <br><br>  Examinamos el primer grupo de problemas.  El segundo es fundamentalmente diferente.  Hablaremos sobre la representaci√≥n de objetos complejos, como nubes, m√°s adelante, pero ahora trataremos con simulaciones f√≠sicas. <br><br><h3>  Simulaciones f√≠sicas de agua y humo. <br></h3><br>  Imagine una piscina en la que se encuentran objetos s√≥lidos en movimiento.  Queremos predecir el movimiento de part√≠culas fluidas.  Hay part√≠culas en el grupo en el momento <strong>t</strong> , y en el momento <strong>t + Œît</strong> queremos obtener su posici√≥n.  Para cada part√≠cula, llamamos a una red neuronal y obtenemos una respuesta donde estar√° en el siguiente cuadro. <br><br>  Para resolver el problema, utilizamos <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">la</a> <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">ecuaci√≥n de Navier-Stokes</a></strong> , que describe el movimiento de un fluido.  Para una simulaci√≥n de agua plausible y f√≠sicamente correcta, tendremos que resolver la ecuaci√≥n o aproximaci√≥n a ella.  Esto se puede hacer de manera computacional, muchos de los cuales se han inventado en los √∫ltimos 50 a√±os: el algoritmo SPH, FLIP o el fluido basado en posici√≥n. <br><br><h3>  La diferencia entre el primer grupo de tareas del segundo <br></h3><br>  En el primer grupo, el maestro para el algoritmo es algo anterior: una grabaci√≥n de la vida real, como en el caso de individuos, o algo del motor, por ejemplo, renderizar im√°genes.  En el segundo grupo de problemas, utilizamos el m√©todo de las matem√°ticas computacionales.  A partir de esta divisi√≥n tem√°tica, surge una idea. <br><br><h2>  Idea principal <br></h2><br>  Tenemos una tarea computacionalmente compleja que es larga, dif√≠cil y dif√≠cil de resolver con el m√©todo cl√°sico de la universidad de computaci√≥n.  Para resolverlo y acelerar, tal vez incluso perdiendo un poco de calidad, necesitamos: <br><br><blockquote><ul><li>  encuentre el lugar que consume m√°s tiempo en la tarea donde el c√≥digo dura m√°s; </li><li>  mira lo que produce esta l√≠nea; </li><li>  intente predecir el resultado de una l√≠nea utilizando una red neuronal o cualquier otro algoritmo de aprendizaje autom√°tico. </li></ul></blockquote><br>  Esta es una metodolog√≠a general y la idea principal es una receta sobre c√≥mo encontrar aplicaciones para el aprendizaje autom√°tico.  ¬øQu√© debe hacer para que esta idea sea √∫til?  No hay una respuesta exacta: usa la creatividad, mira tu trabajo y encu√©ntralo.  Hago gr√°ficos y no estoy tan familiarizado con otros campos, pero puedo imaginar que en el entorno acad√©mico, en f√≠sica, qu√≠mica, rob√≥tica, definitivamente puedes encontrar una aplicaci√≥n.  Si resuelve una ecuaci√≥n f√≠sica compleja en su lugar de trabajo, tambi√©n puede encontrar aplicaci√≥n para esta idea.  Para mayor claridad, considere un caso espec√≠fico. <br><br><h2>  Tarea de renderizado en la nube <br></h2><br>  Estuvimos involucrados en este proyecto en NVIDIA hace seis meses: la tarea es dibujar una nube f√≠sicamente correcta, que se representa como la densidad de las gotas de l√≠quido en el espacio. <br><br><blockquote>  Una nube es un objeto f√≠sicamente complejo, una suspensi√≥n de gotas de l√≠quido que no se puede modelar como un objeto s√≥lido. </blockquote><br>  No ser√° posible imponer una textura y renderizar en la nube, porque las gotas de agua son geom√©tricamente dif√≠ciles de ubicar en el espacio 3D y son complejas en s√≠ mismas: pr√°cticamente no absorben el color, sino que lo reflejan, anisotr√≥picamente, en todas las direcciones de diferentes maneras. <br><br>  Si observa una gota de agua, sobre la que brilla el sol, y los vectores del ojo y del sol en una gota son paralelos, se observar√° un gran pico de intensidad de luz.  Esto explica el fen√≥meno f√≠sico que todos han visto: en un clima soleado, uno de los bordes de la nube es muy brillante, casi blanco.  Estamos mirando el borde de la nube, y la l√≠nea de visi√≥n y el vector desde este borde hasta el sol son casi paralelos. <br><img src="https://habrastorage.org/webt/yt/hz/ij/ythzijgn-xfjhl3xri9mefn4vrg.png"><br><br>  La nube es un objeto f√≠sicamente complejo y su representaci√≥n mediante el algoritmo cl√°sico requiere mucho tiempo.  Hablaremos sobre el algoritmo cl√°sico un poco m√°s tarde.  Dependiendo de los par√°metros, el proceso puede llevar horas o incluso d√≠as.  Imagina que eres un artista y dibujas una pel√≠cula con efectos especiales.  Tienes una escena complicada con una iluminaci√≥n diferente con la que quieres jugar.  Dibujamos una topolog√≠a en la nube: no me gusta y desea volver a dibujarla y obtener una respuesta all√≠ mismo.  Es importante obtener una respuesta de un cambio de par√°metro lo m√°s r√°pido posible.  Esto es un problema  Por lo tanto, intentemos acelerar este proceso. <br><br><h3>  Soluci√≥n cl√°sica <br></h3><br>  Para resolver el problema, debes resolver esta complicada ecuaci√≥n. <br><img src="https://habrastorage.org/webt/vs/fg/hq/vsfghqwn4s0rkmnsnescb1h62ma.png"><br><br>  La ecuaci√≥n es dura, pero comprendamos su significado f√≠sico.  Considere un rayo atravesado por una nube que atraviesa una nube.  ¬øC√≥mo entra la luz en la c√°mara en esta direcci√≥n?  En primer lugar, la luz puede alcanzar el punto de salida del rayo desde la nube y luego propagarse a lo largo de este rayo dentro de la nube. <br><br>  Para el segundo m√©todo de "propagaci√≥n de luz a lo largo de la direcci√≥n" es el t√©rmino integral de la ecuaci√≥n.  Su significado f√≠sico es el siguiente. <br><br>  Considere el segmento dentro de la nube en el rayo, desde el punto de entrada hasta el punto de salida.  La integraci√≥n se lleva a cabo precisamente sobre este segmento, y para cada punto en √©l consideramos la llamada <strong>energ√≠a de luz indirecta L (x, œâ)</strong> - el significado de la integral I <sub>1</sub> - iluminaci√≥n indirecta en el punto.  Parece debido al hecho de que las gotas de diferentes maneras reflejan la luz solar.  En consecuencia, una gran cantidad de rayos mediados por las gotas circundantes llega al punto.  I <sub>1</sub> es la integral sobre la esfera que rodea un punto en el rayo.  En el algoritmo cl√°sico, se cuenta utilizando el m√©todo de <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Monte Carlo</a></strong> . <br><br>  El algoritmo cl√°sico. <br><br><ul><li>  Renderice una imagen a partir de p√≠xeles y produzca un rayo que vaya desde el centro de la c√°mara a un p√≠xel y luego m√°s. </li><li>  Cruzamos la viga con la nube, encontramos los puntos de entrada y salida. </li><li>  Consideramos el √∫ltimo t√©rmino de la ecuaci√≥n: cruzar, conectar con el sol. </li><li>  Primeros pasos <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">muestreo de importancia</a></strong> </li></ul><br>  C√≥mo considerar la estimaci√≥n de Montecarlo I <sub>1</sub> que no analizaremos, porque es dif√≠cil y no tan importante.  Baste decir que esta es la parte m√°s larga y dif√≠cil de todo el algoritmo. <br><br><h3>  Conectamos redes neuronales <br></h3><br>  A partir de la idea principal y la descripci√≥n del algoritmo cl√°sico, se sigue una receta sobre c√≥mo aplicar redes neuronales a esta tarea.  Lo m√°s dif√≠cil es calcular el puntaje de Monte Carlo.  Da un n√∫mero que significa iluminaci√≥n indirecta en un punto, y esto es exactamente lo que queremos predecir. <br><img src="https://habrastorage.org/webt/nz/on/st/nzonstvyqkk3uaiylmqjbs6fny0.png"><br><br>  Hemos decidido la salida, ahora entenderemos la entrada, a partir de la cual quedar√° claro cu√°l es la magnitud de la luz indirecta en el punto.  Esta es la luz que se refleja de las muchas gotas de agua que rodean el punto.  La topolog√≠a de la luz est√° fuertemente influenciada por la topolog√≠a de densidad alrededor del punto, la direcci√≥n hacia la fuente y la direcci√≥n hacia la c√°mara. <br><img src="https://habrastorage.org/webt/ks/x6/hc/ksx6hc2boi4sgdp3_j7det6firo.png"><br><br>  Para construir la entrada a la red neuronal, describimos la densidad local.  Hay muchas maneras de hacer esto, pero nos centramos en el art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Dispersi√≥n profunda: renderizaci√≥n de nubes atmosf√©ricas con redes neuronales que predicen la radiaci√≥n, Kallwcit et al.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">2017</a> y muchas ideas vinieron de all√≠. <br><br>  Brevemente, el m√©todo de representaci√≥n local de la densidad alrededor de un punto se ve as√≠. <br><br><ul><li>  <strong>Arregla una constante bastante peque√±a</strong> .  Que sea el camino libre medio en la nube. <br></li><li>  <strong>Dibuje alrededor de un punto en nuestro segmento una cuadr√≠cula rectangular volum√©trica de un tama√±o fijo</strong> , digamos 5 * 5 * 9.  En el centro de este cubo estar√° nuestro punto.  El espaciado de la cuadr√≠cula es una peque√±a constante fija.  En los nodos de la cuadr√≠cula mediremos la densidad de la nube. </li><li>  <strong>Aumentemos la constante 2 veces</strong> , dibujemos una cuadr√≠cula m√°s grande y hagamos lo mismo: mida la densidad en los nodos de la cuadr√≠cula. </li><li>  <strong>Repita el paso anterior varias veces</strong> .  Hicimos esto 10 veces, y despu√©s del procedimiento obtuvimos 10 cuadr√≠culas: 10 tensores, cada uno de los cuales almacena la densidad de la nube, y cada uno de los tensores cubre un vecindario cada vez m√°s grande alrededor del punto. </li></ul><br>  Este enfoque nos brinda la descripci√≥n m√°s detallada de un √°rea peque√±a: cuanto m√°s cerca del punto, m√°s detallada es la descripci√≥n.  Decidido sobre la salida y la entrada de la red, queda por entender c√≥mo entrenarla. <br><br><h3>  Entrenamiento <br></h3><br>  Generaremos 100 nubes diferentes con diferentes topolog√≠as.  Simplemente los representaremos utilizando el algoritmo cl√°sico, anotaremos lo que el algoritmo recibe en la l√≠nea donde realiza la integraci√≥n de Monte Carlo y anotaremos las propiedades que corresponden al punto.  Entonces obtenemos un conjunto de datos sobre el cual aprender. <br><img src="https://habrastorage.org/webt/yc/im/rh/ycimrhfbcbhfhx_rjwsqoc-xt1q.png"><br><br><h3>  Qu√© ense√±ar o arquitectura de red <br></h3><br>  La arquitectura de red para esta tarea no es el momento m√°s crucial, y si no comprende nada, no se preocupe, esto no es lo m√°s importante que quer√≠a transmitir.  Utilizamos la siguiente arquitectura: para cada punto hay 10 tensores, cada uno de los cuales se calcula en una cuadr√≠cula cada vez m√°s grande.  Cada uno de estos tensores cae en el bloque correspondiente. <br><br><ul><li>  Primero en la primera <strong>capa</strong> regular <strong>completamente conectada</strong> . </li><li>  Despu√©s de salir de la primera capa totalmente conectada, en la segunda capa completamente conectada, que no tiene activaci√≥n. </li></ul><br>  Una capa completamente conectada sin activaci√≥n es solo la multiplicaci√≥n por una matriz.  Al resultado de multiplicar por la matriz, agregamos la salida del <strong>bloque residual</strong> anterior, y solo entonces aplicamos la activaci√≥n. <br><img src="https://habrastorage.org/webt/he/fb/pn/hefbpncqogvya11gpsmzjwxtawi.png"><br><br>  Tomamos un punto, contamos los valores en cada una de las cuadr√≠culas, colocamos los tensores obtenidos en el bloque residual correspondiente, y puede realizar la <strong>inferencia de la red neuronal</strong> , el modo de producci√≥n de la red.  Hicimos esto y nos aseguramos de obtener im√°genes de nubes. <br><br><h3>  Resultados <br></h3><br>  La primera observaci√≥n: obtuvimos lo que quer√≠amos: una llamada de red neuronal, en comparaci√≥n con la estimaci√≥n de Monte Carlo, funciona m√°s r√°pido, lo cual ya es bueno. <br><br>  Pero hay otra observaci√≥n sobre los resultados del entrenamiento: es la convergencia en el n√∫mero de muestras.  De que estas hablando <br><img src="https://habrastorage.org/webt/mb/wd/eg/mbwdegnr_cpk6irbcsvrmyhe3n4.png"><br><br>  Al renderizar una imagen, c√≥rtela en peque√±os mosaicos: cuadrados de p√≠xeles, digamos 16 * 16.  Considere un mosaico de imagen sin p√©rdida de generalidad.  Cuando renderizamos este mosaico, para cada p√≠xel de la c√°mara, liberamos muchos rayos correspondientes a un p√≠xel y agregamos un poco de ruido a los rayos para que sean ligeramente diferentes.  Estos rayos se llaman <strong>anti-aliasing</strong> y se inventan para reducir el ruido en la imagen final. <br><br><ul><li>  Lanzamos varios rayos anti-alias para cada p√≠xel. </li><li>  En el interior del haz de la c√°mara, en la nube, en un segmento, calculamos <em>n</em> muestras de puntos en los que queremos realizar una evaluaci√≥n de Monte Carlo, o llamar a una red para ellos. </li></ul><br>  Todav√≠a hay muestras que corresponden a la conexi√≥n con las fuentes de luz.  Aparecen cuando conectamos un punto con una fuente de luz, por ejemplo, con el sol.  Esto es f√°cil de hacer, porque el sol son los rayos que caen sobre la tierra paralelos entre s√≠.  Por ejemplo, el cielo, como fuente de luz, es mucho m√°s complicado, porque aparece como una esfera infinitamente distante, que tiene una funci√≥n de color en la direcci√≥n.  Si el vector se ve verticalmente hacia el cielo, entonces el color es azul.  Cuanto m√°s bajo, m√°s brillante.  En la parte inferior de la esfera suele haber un color neutro que imita a la tierra: verde, marr√≥n. <br><br>  Cuando conectamos un punto con el cielo para comprender cu√°nta luz entra, siempre liberamos algunos rayos para obtener una respuesta que converja con la verdad.  Lanzamos m√°s de un rayo para obtener una mejor calificaci√≥n.  Por lo tanto, todo el <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">procesamiento de la tuber√≠a</a></strong> necesita tantas muestras. <br><br>  Cuando entrenamos la red neuronal, notamos que aprende una soluci√≥n mucho m√°s promedio.  Si fijamos el n√∫mero de muestras, vemos que el algoritmo cl√°sico converge a la fila izquierda de la columna de la imagen, y la red aprende a la derecha.  Esto no significa que el m√©todo original sea malo, solo convergemos m√°s r√°pido.  Cuando aumentamos el n√∫mero de muestras, el m√©todo original estar√° cada vez m√°s cerca de lo que obtenemos. <br><br>  Nuestro principal resultado que quer√≠amos obtener es un aumento en la velocidad de renderizado.  Para una nube espec√≠fica en una resoluci√≥n espec√≠fica con par√°metros de muestra, vemos que las im√°genes obtenidas por la red y el m√©todo cl√°sico son casi id√©nticas, pero obtenemos la imagen correcta 800 veces m√°s r√°pido. <br><img src="https://habrastorage.org/webt/qp/ly/xn/qplyxntotijyhtzhgeqzsygahmc.png"><br><br><h2>  Implementaci√≥n <br></h2><br>  Hay un programa de c√≥digo abierto para modelado 3D: <strong><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Blender</a></strong> , que implementa el algoritmo cl√°sico.  Nosotros mismos no escribimos un algoritmo, pero usamos este programa: nos capacitamos en Blender, escribiendo todo lo que necesit√°bamos para el algoritmo.  La producci√≥n tambi√©n se realiz√≥ en el programa: capacitamos a la red en <strong>TensorFlow</strong> , la transferimos a C ++ usando TensorRT, y ya integramos la red TensorRT en Blender, porque su c√≥digo est√° abierto. <br><br>  Como hicimos todo por Blender, nuestra soluci√≥n tiene todas las caracter√≠sticas del programa: podemos renderizar cualquier tipo de escena y muchas nubes.  Las nubes en nuestra soluci√≥n se establecen creando un cubo, dentro del cual determinamos la funci√≥n de densidad de una manera espec√≠fica para programas 3D.  Optimizamos este proceso: densidad de cach√©.  Si un usuario quiere dibujar la misma nube en una pila de diferentes configuraciones de una escena: bajo diferentes condiciones de iluminaci√≥n, con diferentes objetos en el escenario, entonces no necesita recalcular constantemente la densidad de la nube.  Lo que pas√≥, puedes ver el <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">video</a> . <br><br>  En conclusi√≥n, repito una vez m√°s la idea principal que quer√≠a transmitir: <em>si en su trabajo durante mucho tiempo y duro considera algo como un algoritmo computacional espec√≠fico, y esto no le conviene: encuentre el lugar m√°s dif√≠cil en el c√≥digo, reempl√°celo con una red neuronal, y Quiz√°s esto te ayude.</em> <br><br><blockquote>  Las redes neuronales y la inteligencia artificial son uno de los nuevos temas que discutiremos en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Saint HighLoad ++ 2019</a> en abril.  Ya hemos recibido varias <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">solicitudes</a> sobre este tema, y ‚Äã‚Äãsi tiene una buena experiencia, no necesariamente en redes neuronales, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">env√≠e una solicitud para un informe</a> antes <strong>del 1 de marzo</strong> .  Estaremos encantados de verte entre nuestros oradores. <br><br>  Para mantenerse al tanto de c√≥mo se forma el programa y qu√© informes se aceptan, suscr√≠base al <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">bolet√≠n</a> .  En √©l, solo publicamos colecciones tem√°ticas de informes, res√∫menes de art√≠culos y nuevos videos. <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/441260/">https://habr.com/ru/post/441260/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../441248/index.html">Rusia ocup√≥ el noveno lugar en la clasificaci√≥n global de SSL, por delante de China, Dinamarca y Suiza</a></li>
<li><a href="../441250/index.html">Inicio r√°pido: Ir + Apache Kafka + Redis</a></li>
<li><a href="../441252/index.html">"Art√≠culo de mamada": los cient√≠ficos procesaron 109 horas de sexo oral para desarrollar una IA que apesta a un miembro</a></li>
<li><a href="../441254/index.html">Seminario "Por qu√© nos pusimos en contacto con Kubernetes y lo que obtenemos de √©l", 28 de febrero, Mosc√∫</a></li>
<li><a href="../441258/index.html">Seguimiento din√°mico con todas las funciones en Linux utilizando eBPF y bpftrace</a></li>
<li><a href="../441262/index.html">Las tareas simples y largas eliminan a los candidatos mejor que los cortos y complejos</a></li>
<li><a href="../441264/index.html">Gu√≠a del usuario de Kibana. Visualizaci√≥n. Parte 2</a></li>
<li><a href="../441266/index.html">C√≥mo funciona el marco tiOPF para delphi / lazarus. Plantilla de visitante</a></li>
<li><a href="../441268/index.html">Ceedling + Eclipse o pruebas unitarias para microcontroladores</a></li>
<li><a href="../441270/index.html">Primer vistazo a la FoundationDB de Apple</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>