<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üÖøÔ∏è üî• ü§úüèæ Doom of SceneKit. Yandex Erfahrung mit 3D-Grafik in iOS üî• üé∏ üìß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="- Ich bin zu jung, um zu sterben. 


 SceneKit ist ein 3D-Grafikframework auf hoher Ebene in iOS, mit dem animierte Szenen und Effekte erstellt werden...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Doom of SceneKit. Yandex Erfahrung mit 3D-Grafik in iOS</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/431880/"><p>  <i>- Ich bin zu jung, um zu sterben.</i> </p><br><p>  SceneKit ist ein 3D-Grafikframework auf hoher Ebene in iOS, mit dem animierte Szenen und Effekte erstellt werden k√∂nnen.  Es enth√§lt eine physische Engine, einen Partikelgenerator und eine Reihe einfacher Aktionen f√ºr 3D-Objekte, mit denen Sie die Szene inhaltlich beschreiben k√∂nnen - Geometrie, Materialien, Beleuchtung, Kameras - und sie durch eine Beschreibung der √Ñnderungen f√ºr diese Objekte animieren k√∂nnen. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/de8/eb3/a60/de8eb3a6080bb48be4f407c07d1b122a.gif"></p><br><p> Heute werden wir SceneKit mit einem aufmerksamen, etwas strengen Blick betrachten, aber zuerst gehen wir die Grundlagen durch und sehen, wie die 3D-Szene aussieht und was getan werden muss, um sie zu erstellen. <a name="habracut"></a></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1fa/7d7/138/1fa7d71381bc0f217fe6ddff8a08e77f.png" alt="Die einfachste Szene aus drei Knoten mit Geometrie."><br>  <em>Die einfachste Szene aus drei Knoten mit Geometrie</em> </p><br><p>  Zuerst m√ºssen Sie die Grundstruktur der Szene erstellen, die aus <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Knoten</a> oder Knoten der Szene besteht.  Jeder Knoten kann sowohl Geometrie als auch andere Knoten enthalten.  Die Geometrie kann entweder einfach wie eine Kugel, ein W√ºrfel oder eine Pyramide oder komplexer sein und in externen Editoren erstellt werden. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/a9c/dd6/3ae/a9cdd63aeb3c662009d721feff5a2fa2.png" alt="√úberlagerungsmaterialien"><br>  <em>√úberlagerungsmaterialien</em> </p><br><p>  F√ºr diese Geometrie m√ºssen Sie dann die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Materialien</a> angeben, die die grundlegende Darstellung der Objekte bestimmen.  Jedes Material selbst legt sein eigenes Beleuchtungsmodell fest und verwendet je nach Material unterschiedliche <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Eigenschaften</a> .  Jede dieser Eigenschaften ist normalerweise eine Farbe oder Textur, aber zus√§tzlich zu diesen h√§ufig verwendeten Optionen gibt es auch die Option, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CALayer</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AVPlayer</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SKScene zu verwenden</a> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/0c1/ca5/831/0c1ca58318327b07263caf4f9d67ea63.png" alt="F√ºgen Sie Lichtquellen hinzu"><br>  <em>F√ºgen Sie Lichtquellen hinzu</em> </p><br><p>  Danach m√ºssen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Lichtquellen</a> hinzugef√ºgt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">werden</a> , die bestimmen, wie gut Objekte in dem einen oder anderen Teil der Szene sichtbar sind.  Sie m√ºssen analog zur Geometrie innerhalb eines Knotens liegen.  SceneKit unterst√ºtzt viele verschiedene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Beleuchtungsarten</a> sowie verschiedene <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Arten von Schatten</a> . </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/c16/a8e/f8e/c16a8ef8ebcfb7242eef1d8142b70dea.png" alt="Out-of-the-Box-Boke-Effekte"><br>  <em>Out-of-the-Box-Boke-Effekt</em> </p><br><p>  Dann m√ºssen Sie eine <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kamera</a> erstellen (und in einem separaten Knoten ablegen) und die grundlegenden Parameter daf√ºr festlegen.  Es gibt viele davon, aber mit ihrer Hilfe k√∂nnen Sie coole Effekte erstellen.  Standardm√§√üig werden Bokeh (oder Unsch√§rfe), HDR mit Anpassung, Gl√ºhen, SSAO und Farbton- / S√§ttigungsmodifikationen unterst√ºtzt. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/76f/62c/908/76f62c908bda6280380c922e3a1e8ca3.gif" alt="Einfache Animationen in SceneKits"><br>  <em>Einfache Animationen in SceneKit</em> </p><br><p>  Schlie√ülich enth√§lt SceneKit eine einfache Reihe von Aktionen f√ºr 3D-Objekte, mit denen Sie Szenen√§nderungen im Laufe der Zeit festlegen k√∂nnen.  SceneKit unterst√ºtzt auch <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">in JavaScript beschriebene Aktionen</a> , dies ist jedoch ein Thema f√ºr einen separaten Artikel. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/08c/0dc/2e4/08c0dc2e44e627e369af7dea6f18d27d.gif" alt="Die Wechselwirkung eines Partikelgenerators mit einem eigenen Motor kann zu Tornados f√ºhren!"><br>  <em>Die Wechselwirkung eines Partikelgenerators mit einem physischen Motor kann zu einem Tornado f√ºhren!</em> </p><br><p>  Neben den Grafiken sind die Hauptmerkmale von SceneKit der Partikelgenerator und eine fortschrittliche physikalische Engine, mit der Sie reale physikalische Eigenschaften sowohl f√ºr normale Objekte als auch f√ºr Partikel aus dem Generator festlegen k√∂nnen. </p><br><p>  √úber all diese Chips wurde eine gro√üe Anzahl detaillierter Tutorials geschrieben.  Aber im Entwicklungsprozess haben wir diese M√∂glichkeiten praktisch nicht genutzt ... </p><br><h2 id="hey-not-too-rough">  <strong>Hey, nicht zu rau</strong> </h2><br><blockquote>  <em>Einmal habe ich ein Beleuchtungsmodell f√ºr 3D-Spiele geschrieben, das besser als echtes Sonnenlicht ist und auf dem Nvidia 8800 akzeptable FPS liefert, aber ich habe beschlossen, die Engine nicht freizugeben, weil Gott nett zu mir ist und ich seine Inkompetenz in dieser Angelegenheit nicht zeigen m√∂chte.</em> <br>  <em>- John Carmack</em> </blockquote><p>  Wir werden eine detaillierte Studie mit einer ziemlich einfachen Aufgabe beginnen, die sich f√ºr fast alle ergibt, die sehr ernsthaft mit SceneKit arbeiten: Wie lade ich ein Modell mit komplexer Geometrie und verbundenen Materialien, Beleuchtung und sogar Animationen? </p><br><p>  Es gibt verschiedene M√∂glichkeiten, und alle haben ihre Vor- und Nachteile: </p><br><ol><li><p>  SCNScene (benannt :) - erh√§lt eine Szene aus einem Bundle, </p><br></li><li><p>  SCNScene (url: options :) - l√§dt die Szene per URL, </p><br></li><li><p>  SCNScene (mdlAsset :) - konvertiert eine Szene aus verschiedenen Formaten, </p><br></li><li><p>  SCNReferenceNode (url :) - l√§dt die Szene tr√§ge. </p><br></li></ol><br><h3 id="poluchaem-scenu-iz-bandla">  Holen Sie sich die Szene aus dem Bundle </h3><br><p>  Sie k√∂nnen die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Standardmethode verwenden</a> : F√ºgen Sie unser Modell im dae- oder scn-Format in das scnassets-Bundle ein und laden Sie es von dort in Analogie zu UIImage (benannt :). </p><br><p>  Was aber, wenn Sie das Update von Modellen selbst steuern m√∂chten, ohne jedes Mal ein Update im App Store zu ver√∂ffentlichen, wenn Sie einige Texturen √§ndern m√ºssen?  Oder nehmen Sie an, Sie m√ºssen vom Benutzer erstellte Karten und Modelle unterst√ºtzen.  Oder - dass Sie die Anwendung einfach nicht vergr√∂√üern m√∂chten, da 3D-Grafiken nicht die Hauptfunktionalit√§t sind. </p><br><h3 id="zagruzhaem-scenu-po-url">  Laden der Szene per URL </h3><br><p>  Sie k√∂nnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">den Szenenkonstruktor √ºber die URL der</a> SCN-Datei verwenden.  Diese Methode unterst√ºtzt das Herunterladen nicht nur aus dem Dateisystem, sondern auch aus dem Netzwerk. Im letzteren Fall k√∂nnen Sie die Komprimierung vergessen.  Au√üerdem m√ºssen Sie das Modell im Voraus in das SCN-Format konvertieren.  Sie k√∂nnen nat√ºrlich dae verwenden, aber damit sind eine Reihe von Einschr√§nkungen verbunden.  Zum Beispiel das Fehlen eines physisch basierten Renderings. </p><br><p>  Der Hauptvorteil dieser Methode besteht darin, dass Sie die Importeinstellungen flexibel konfigurieren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">k√∂nnen</a> .  Sie k√∂nnen beispielsweise den Lebenszyklus von Animationen √§ndern und sie endlos wiederholen lassen.  Sie k√∂nnen die Quelle zum Laden externer Ressourcen wie Texturen explizit angeben, die Ausrichtung und den Ma√üstab der Szene konvertieren, fehlende Normalen f√ºr die Geometrie erstellen, die gesamte Geometrie der Szene zu einem gro√üen Knoten zusammenf√ºhren oder alle Szenenelemente verwerfen, die nicht dem Formatstandard entsprechen. </p><br><h3 id="konvertiruem-scenu-iz-raznyh-formatov">  Konvertieren Sie eine Szene aus verschiedenen Formaten </h3><br><p>  Die dritte Option besteht darin, den <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Konstruktor mit MDLAsset zu verwenden</a> .  Das hei√üt, wir erstellen zuerst ein <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">MDLAsset</a> , das im ModelIO-Framework verf√ºgbar ist, und √ºbergeben es dann an den Konstruktor f√ºr die Szene. </p><br><p>  Diese Option ist insofern gut, als Sie viele verschiedene Formate herunterladen k√∂nnen.  Offiziell kann MDLAsset die Formate obj, ply, stl und usd laden, aber nachdem mir eine Liste aller m√∂glichen Formate ausgegangen ist, zumindest in Bezug auf Computergrafiken, habe ich vier weitere gefunden: abc, bsp, vox und md3, aber sie werden m√∂glicherweise nicht vollst√§ndig unterst√ºtzt oder nicht in allen Systemen, und f√ºr sie m√ºssen Sie die Richtigkeit des Imports √ºberpr√ºfen. </p><br><p>  Es ist auch zu ber√ºcksichtigen, dass diese Methode einen Overhead f√ºr die Konvertierung hat, und sie sehr vorsichtig zu verwenden. </p><br><p>  Diese Methoden haben eine gemeinsame Gefahr: Sie geben SCNScene zur√ºck, nicht SCNNode.  Die einzige M√∂glichkeit, einer vorhandenen Szene Inhalte hinzuzuf√ºgen, besteht darin, alle untergeordneten Knoten zu kopieren und - Sie k√∂nnen diesen Schritt leicht √ºberspringen - Animationen vom Stammknoten (z. B. k√∂nnen sie dort angezeigt werden, wenn Sie mit dae arbeiten).  Dar√ºber hinaus m√ºssen Sie ber√ºcksichtigen, dass es in der Szene nur eine Texturumgebung geben kann (wenn Sie keine benutzerdefinierten Shader f√ºr Reflexionen verwenden). </p><br><h3 id="lenivo-zagruzhaem-scenu">  Faul die Szene laden </h3><br><p>  Die vierte Option ist die Verwendung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SCNReferenceNode</a> .  Es wird keine Szene zur√ºckgegeben, sondern ein Knoten, der selbst tr√§ge (oder auf Anfrage) die gesamte Hierarchie der Szene in sich laden kann.  Somit √§hnelt diese Methode der ersten, verbirgt jedoch alle Probleme beim Kopieren in sich. </p><br><p>  Er hat aber eines: Die globalen Parameter der Szene gehen verloren. </p><br><p>  Es stellt sich heraus, dass dies der einfachste und schnellste Weg ist, Ihr Modell herunterzuladen. Wenn Sie jedoch eine Dateioptimierung ben√∂tigen, ist die erste Methode besser. </p><br><p>  Infolgedessen haben wir uns f√ºr die erste Option entschieden, da es f√ºr uns am bequemsten war, im scn-Format zu arbeiten, und f√ºr Designer, vom dae-Format in dieses zu konvertieren.  Au√üerdem brauchten wir beim Booten Animationen zur Dateioptimierung. </p><br><h3 id="vovse-ne-prezhdevremennye-optimizacii">  √úberhaupt keine vorzeitigen Optimierungen </h3><br><p>  Nachdem ich lange an diesem Prozess herumgebastelt habe, kann ich Ihnen einige Ratschl√§ge geben. </p><br><p>  Der wichtigste Tipp ist, Dateien im Voraus in scn zu konvertieren.  Anschlie√üend k√∂nnen Sie durch √ñffnen der Datei im integrierten Szeneneditor in Xcode sehen, wie Ihr Objekt in SceneKit aussehen wird. </p><br><p>  Dar√ºber hinaus ist die scn-Datei nur eine bin√§re Darstellung der Szene, sodass das Laden aus der Szene am wenigsten Zeit in Anspruch nimmt.  Aus demselben Grund m√ºssen Sie zuerst die XML-Datei analysieren und dann alle Netze, Animationen und Materialien konvertieren.  Dar√ºber hinaus ist die Konvertierung von Animationen und Materialien eine potenzielle Problemquelle.  Wir erinnern uns an den Mangel an PBR-Unterst√ºtzung in dae: Es stellt sich heraus, dass Sie, wenn Sie es verwenden m√∂chten, die Art aller Materialien nach der Konvertierung √§ndern und die entsprechenden Texturen manuell ablegen m√ºssen. </p><br><p>  Mit dieser Operation k√∂nnen Sie einen sehr n√ºtzlichen Nebeneffekt erzielen: eine signifikante Texturkomprimierung.  Es reicht aus, sie in der "Ansicht" zu √∂ffnen und zu exportieren und das Format in heic zu √§ndern.  Durch diese einfache Operation konnten durchschnittlich 5 Megabyte pro Modell eingespart werden. </p><br><p>  Wenn Sie eine Szene aus dem Internet herunterladen, kann ich Ihnen auch empfehlen, sie im Archiv herunterzuladen, zu entpacken und die URL der entpackten scn-Datei zu √ºbertragen.  Dies spart Ihnen und dem Benutzer zus√§tzliche Megabyte - was wiederum den Download beschleunigt und auch die Anzahl der Fehlerstellen verringert.  Einverstanden: Eine separate Anfrage f√ºr jede externe Ressource und sogar im mobilen Internet ist nicht der beste Weg, um die Zuverl√§ssigkeit zu erh√∂hen. </p><br><h2 id="hurt-me-plenty">  <strong>Tut mir sehr weh</strong> </h2><br><blockquote>  <em>Wenn ich ein Auto fahre, h√∂re ich oft die Festplatte des Universums knistern und die n√§chste Stra√üe beladen.</em> <br>  <em>- John Carmack</em> </blockquote><p>  Wenn also das Laden und Importieren von Modellen in Betrieb genommen wird, entsteht eine neue Aufgabe: Hinzuf√ºgen verschiedener Effekte und Funktionen zur Szene.  Und glauben Sie mir, es gibt etwas zu erz√§hlen.  Wir beginnen mit den verschiedenen Konstanten in SceneKit. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1e3/c0e/ffd/1e3c0effdc9c72b19d6e3d0a19a13796.png" alt="Werden in SceneKit werden unmittelbar nach der Physik verwaltet.  Und bevor Sie den Rahmen rendern"><br>  <em>Einschr√§nkungen in SceneKit werden unmittelbar nach der Physik ber√ºcksichtigt.</em>  <em>Und bevor Sie den Rahmen rendern</em> </p><br><p>  Einschr√§nkungen, sagst du?  Was sind die Konstanten?  Nur wenige Leute wissen es und sprechen noch mehr dar√ºber, aber SceneKit hat seine eigenen Konstanten.  Und obwohl sie nicht so flexibel sind wie die Konstanten in UIkit, k√∂nnen Sie mit ihnen dennoch viele interessante Dinge tun. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/006/c01/3a3/006c013a36d0bc0f615ca4f4378e4767.gif" alt="SCNReplicatorConstraint"><br>  <em>SCNReplicatorConstraint</em> </p><br><p>  Beginnen wir mit einer einfachen Konstante - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SCNReplicatorConstraint</a> .  Er dupliziert lediglich die Position, Drehung und Gr√∂√üe eines anderen Objekts mit zus√§tzlichen Offsets.  Wie bei allen anderen Konstanten kann er die St√§rke √§ndern und das Flag der Inkrementalit√§t setzen.  Beide Parameter k√∂nnen am besten mit dieser Konstante angezeigt werden. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/dd7/98d/a46/dd798da468df11e71ab53c7a41e187c5.gif" alt="10-mal starke St√§rke"><br>  <em>10-mal reduzierte St√§rke</em> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die St√§rke</a> beeinflusst, wie viel Transformation auf das Objekt angewendet wird.  Und da sich die Position des Zielobjekts in jedem Frame √§ndert, n√§hert sich das Schattenobjekt einem Zehntel der Entfernungsdifferenz.  Aus diesem Grund tritt ein Verz√∂gerungseffekt auf. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/535/ec5/0bc/535ec50bce2b4e57f30c71226bc783da.gif" alt="St√§rkenhtes Inkrement und St√§rken St√§rke um das 10-fache"><br>  <em>Erh√∂htes Inkrement und reduzierte St√§rke um das 10-fache</em> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die Inkrementalit√§t</a> beeinflusst wiederum, ob die Konstante nach dem Rendern gel√∂scht wird.  Angenommen, wir haben es ausgeschaltet.  Dann sehen wir, dass auf jedem Frame die Konstante vor dem Rendern angewendet wird und nach dem Rendern abgebrochen wird, sodass jeder Frame wiederholt wird.  Wenn Sie diese beiden Parameter kombinieren, erhalten Sie einen ziemlich interessanten Effekt der Uhrzeiger. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/74d/5c5/cfd/74d5c5cfd7bde6252adf7855705ec5ad.gif" alt="Das Flugzeug ist immer der Kamera zugewandt."><br>  <em>Das Flugzeug ist immer der Kamera zugewandt.</em> </p><br><p>  Kommen wir zu einer interessanteren Konstante: der sogenannten Plakatwand. </p><br><p>  Angenommen, es ist notwendig, dass ein Objekt uns immer ‚Äûgegen√ºbersteht‚Äú.  Verwenden <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie dazu</a> einfach <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SCNBillboardConstraint</a> und geben <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie an</a> , um welche Achsen sich das Objekt drehen kann.  Vor der Berechnung jedes Frames (nach einem Schritt mit der Physik) werden die Positionen und Ausrichtungen aller Objekte aktualisiert, um alle Konstanten zu erf√ºllen. </p><br><p>  Hier k√∂nnen Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Look At Constraint</a> erw√§hnen: Es √§hnelt einer Werbetafel, nur das Objekt kann anstelle der aktuellen Kamera auf ein anderes Objekt in der Szene gerichtet werden. </p><br><p>  Was kann mit ihrer Hilfe getan werden?  Nat√ºrlich werden diese Konstanten meistens verwendet, um B√§ume oder kleine Objekte zu zeichnen.  Sie erzeugen auch Spezialeffekte wie Feuer oder Explosion.  Dar√ºber hinaus k√∂nnen Sie mit ihrer Hilfe die Kamera dazu bringen, dem Objekt auf der B√ºhne zu folgen. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/077/6ed/96d/0776ed96d0d6116c12ababd108bfe180.gif" alt="H√§lt Abstand zwischen Einstellungen"><br>  <em>H√§lt Abstand zwischen Objekten</em> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mit SCNDistanceConstraint</a> k√∂nnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie</a> den minimalen und / oder maximalen Abstand zur Position eines anderen Objekts <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">festlegen</a> .  Und ja, du kannst damit eine Schlange machen.  :) Diese Einschr√§nkung kann auch verwendet werden, um die Kamera an den Charakter zu binden, obwohl die Position der Kamera normalerweise komplizierter ist und es keine leichte Aufgabe ist, sie nur mit Konstraten zu beschreiben.  Der gleiche Effekt kann durch Hinzuf√ºgen einer Feder im physischen Motor erzielt werden. Diese Feder kann jedoch durch eine Belastung erg√§nzt werden, falls Sie Probleme mit √ºberm√§√üigem Dehnen oder Zusammendr√ºcken der Feder vermeiden m√ºssen. </p><br><p>  Viele haben in Hitman, Fallout oder Skyrim gesehen: Sie ziehen einen K√∂rper mit sich, er ber√ºhrt ein Hindernis - und beginnt sich so zu verhalten, als h√§tte ein D√§mon ihn betreten.  Diese Konstante w√ºrde helfen, solche Fehler zu vermeiden. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/f8f/578/aca/f8f578aca5e9d78034dcef18062349b8.gif" alt="SCNSliderConstraint"><br>  <em>SCNSliderConstraint</em> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mit SCNSliderConstraint</a> k√∂nnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Sie</a> den Mindestabstand zwischen einem bestimmten Objekt und physischen K√∂rpern mit einer geeigneten Kollisionsmaske festlegen.  Ziemlich lustige Konstante, aber auch hier versuchen sie, sie durch physische Interaktion zu simulieren.  Die Hauptidee besteht darin, den Radius der Totzone mit physischen K√∂rpern f√ºr ein Objekt festzulegen, das keinen physischen K√∂rper hat. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/357/930/7df/3579307dfcf69c026734b0c35d7c6f04.gif" alt="Inverse Kinematik bei der Arbeit"><br>  <em>Inverse Kinematik bei der Arbeit</em> </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SCNIKConstraint</a> ist die interessanteste, aber auch die komplexeste Konstante, die die sogenannte inverse Kinematik verwendet.  Mithilfe einer Kette √ºbergeordneter Knoten versucht die inverse Kinematik iterativ, die Knotenposition, auf die Sie diese Konstante anwenden, auf den erforderlichen Punkt zu bringen.  Tats√§chlich k√∂nnen Sie nicht √ºberlegen, in welcher Position sich Schulter und Unterarm befinden sollen, sondern lediglich die Position der Hand und m√∂gliche Drehwinkel der Verbindungsknoten festlegen.  Der Rest wird f√ºr Sie gez√§hlt.  Der Hauptnachteil dieser Einschr√§nkung besteht darin, dass Sie nur die Position der Hand einstellen k√∂nnen, nicht jedoch ihre Ausrichtung, und Winkelbeschr√§nkungen k√∂nnen global festgelegt werden, ohne die Achsen zu besch√§digen. </p><br><p>  Also haben wir uns im Detail mit den Konstanten getroffen und mit dem, was sie zu tun wissen.  Lassen Sie uns weiterhin interessante Effekte untersuchen.  Wir werden uns mit der Wirkung von Schatten befassen. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/5d9/d62/4a4/5d9d624a480d96c5654a8df80be14115.gif" alt="Es gibt ein Flugzeug, aber es ist nicht"><br>  <em>Es gibt ein Flugzeug, aber es ist nicht</em> </p><br><p>  Es scheint, dass es in einer Engine, die Schatten unterst√ºtzt, einfacher sein k√∂nnte, als Schatten zu erzeugen?  Aber manchmal m√ºssen die Schatten auf eine v√∂llig transparente Ebene geworfen werden.  Dies ist in ARKit sehr n√ºtzlich, da das Kamerabild hinter der Ebene angezeigt wird und der Schatten irgendwo geworfen werden sollte.  Der Trick stellt sich als recht einfach heraus: Zuerst m√ºssen Sie verz√∂gerte Schatten aktivieren und die Aufzeichnung in allen Komponenten der Ebene auf der Registerkarte Material deaktivieren, und der Schatten √ºberlappt sie weiterhin.  Das einzige Problem ist, dass diese Ebene die dahinter liegenden Objekte √ºberlappt. </p><br><p>  Schatten sind jedoch nicht der einzige schlecht untersuchte Effekt in SceneKit.  Besch√§ftigen wir uns jetzt mit Spiegeln. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/32d/75b/1ba/32d75b1ba50036e814d21bacb0104523.png" alt="SCNFloor Spiegel - war wahrheitsgem√§√ü sein"><br>  <em>SCNFloor Spiegel - was k√∂nnte einfacher sein</em> </p><br><p>  Jeder, der mit SceneKit gespielt hat, kennt wahrscheinlich scnfloor, das dem Boden Spiegelreflexionen verleiht.  Aber aus irgendeinem Grund verwenden nur sehr wenige es f√ºr ehrliche Spiegelreflexionen, weil Sie Ihr Modell auf die Bodengeometrie setzen, es ein wenig kippen und es ... in einen gew√∂hnlichen Spiegel verwandeln k√∂nnen. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1c4/bdf/289/1c4bdf289fd13dd45489765512bc2d2a.png"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/fdd/950/d98/fdd950d9889d35a4d8e66b871c0c2767.png" alt="Auf Glas und einen gebogenen Spiegel tropfen"><br>  <em>Auf Glas und einen gebogenen Spiegel tropfen</em> </p><br><p>  Was jedoch noch weniger bekannt ist, kann eine normale Karte f√ºr dieses Geschlecht festgelegt werden.  Auf diese Weise k√∂nnen Sie wiederum viele verschiedene interessante Effekte erzielen, z. B. den Effekt von Streifen oder einen gekr√ºmmten Spiegel. </p><br><h2 id="ultra-violence">  <strong>Ultraviolett</strong> </h2><br><blockquote>  <em>Einmal k√ºsste ich ein M√§dchen mit offenen Augen.</em>  <em>Das M√§dchen schnitt ihr Gesicht mit der nahen Ebene des Ausschnitts.</em>  <em>Seitdem k√ºsse ich nur mit geschlossenen Augen.</em> <br>  <em>- John Carmack</em> </blockquote><p>  Schatten, Spiegel - interessante Effekte.  Es gibt jedoch einen Effekt, der sich bei geschickter Verwendung als noch interessanter herausstellen kann - Videotexturen. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/998/047/b54/998047b5496741e28e66d6faeb04f4a1.gif"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/8b7/91c/a6b/8b791ca6b8f464f5bd7401bdc07225ac.gif" alt="Gew√∂hnliche und H√∂henkartenvideos"><br>  <em>Gew√∂hnliche und H√∂henkartenvideos</em> </p><br><p>  M√∂glicherweise ben√∂tigen Sie sie nur, um das Video im Spiel zu zeigen.  Viel interessanter ist jedoch, dass Sie mithilfe von Videotexturen die Geometrie √§ndern k√∂nnen.  Dazu m√ºssen Sie die Videotextur mit einer H√∂henkarte in die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Verschiebungseigenschaft</a> Ihres Materials einf√ºgen und das Material in einer Ebene mit einer ausreichend gro√üen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Anzahl von Segmenten verwenden</a> .  Es bleibt zu verstehen, wie man es dort platziert. </p><br><p>  In der Beschreibung des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Szenenerstellungsprozesses habe</a> ich erw√§hnt, dass Sie <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SKScene</a> als Materialeigenschaft verwenden k√∂nnen, und dies ist eine SpriteKit-Szene.  SpriteKit ist wie SceneKit, jedoch f√ºr 2D-Grafiken.  Es unterst√ºtzt die Anzeige von Videos mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">SKVideoNode</a> .  Sie m√ºssen nur SKVideoNode in SKScene und SKScene in SCNMaterialProperty einf√ºgen, und fertig. </p><br><p>  Nachdem Sie die resultierende 3D-Szene exportiert und an einer anderen Stelle ge√∂ffnet haben, wird ein schwarzes Quadrat angezeigt.  Ich kramte in der scn-Datei und fand den Grund.  Es stellt sich heraus, dass beim Speichern eines Videocodes die Video-URL nicht gespeichert wird.  Es scheint, dass Sie nehmen und regieren.  Aber nicht alles ist so einfach: Die scn-Datei ist eine sogenannte Bin√§rliste, die das Ergebnis von NSKeyedArchiver enth√§lt.  Und das Material, das die SpriteKit-Szene darstellt, ist dieselbe Bin√§rliste, die, wie sich herausstellt, bereits in einer anderen Bin√§rliste liegt!  Es ist gut, dass es nur zwei Verschachtelungsebenen gibt. </p><br><p>  Nun gehen wir sogar zum Effekt √ºber, aber zu einem Werkzeug, mit dem Sie jede Art von Effekten erstellen k√∂nnen.  Dies sind Shader-Modifikatoren. </p><br><p>  Bevor Sie etwas √§ndern, m√ºssen Sie verstehen, was wir √§ndern.  Ein Shader ist per Definition ein Programm f√ºr die GPU, das f√ºr jeden Scheitelpunkt und f√ºr jedes Pixel ausgef√ºhrt wird.  Ein Shader ist also ein Programm, das bestimmt, wie ein Objekt auf dem Bildschirm aussieht. </p><br><p>  Mit Shader-Modifikatoren k√∂nnen Sie die Ergebnisse von Standard-Shadern in GLSL oder Metal Shading Language √§ndern.  Sie sind auch in einem visuellen Editor verf√ºgbar, mit dem Sie √Ñnderungen im Modifikator in Echtzeit sehen k√∂nnen. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/663/9d1/9a7/6639d19a72901a50caea2b969816a1ae.png"></p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/1d1/94a/660/1d194a660488fe33aa392c0573834ca4.png" alt="Pelz- und Parallaxenkartierung"><br>  <em>Pelz- und Parallaxenkartierung</em> </p><br><p>  Mit Hilfe von Shader-Modifikatoren k√∂nnen Sie komplexe visuelle Effekte erstellen.  Zum Beispiel einige der bekanntesten Effekte: Fur and <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Parallax Mapping</a> . </p><br><pre><code class="objectivec hljs"><span class="hljs-meta"><span class="hljs-meta">#pragma arguments texture2d bg; texture2d height; float depth; float layers; #pragma transparent #pragma body constexpr sampler sm = sampler(filter::linear, s_address::repeat, t_address::repeat); float3 bitangent = cross(_surface.tangent, _surface.normal); float2 direction = float2(-dot(_surface.view.rgb, _surface.tangent), dot(_surface.view.rgb, _surface.bitangent)); _output.color.rgba = float4(0); for(int i = 0; i </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; int(floor(layers)); i++) { float coeff = float(i) / floor(layers); float2 defaultCoords = _surface.diffuseTexcoord + direction * (1 - coeff) * depth; float2 adjustment = float2(scn_frame.sinTime + defaultCoords.x, scn_frame.cosTime) * depth * coeff * 0.1; float2 coords = defaultCoords + adjustment; _output.color.rgb += bg.sample(sm, coords).rgb * coeff * (height.sample(sm, coords).r + 0.1) * (1.0 - coeff); _output.color.a += (height.sample(sm, coords).r + 0.1) * (1.0 - coeff); } return _output;</span></span></span></span></code> </pre> <br><p><img src="https://habrastorage.org/getpro/habr/post_images/7aa/b5f/b0e/7aab5fb0e907d2a7290f0f31e415e4be.gif" alt="Ray Casting mit Echtzeit-√Ñtzmitteln."><br>  <em>Ray Casting mit Echtzeit-Caustics</em> </p><br><p>  Interessanter ist, dass sich niemand die M√ºhe macht, die Ergebnisse ihrer Arbeit vollst√§ndig wegzuwerfen und einen eigenen Renderer zu schreiben.  Sie k√∂nnen beispielsweise versuchen, Ray Casting in Shadern zu implementieren.  Und das alles schnell genug, um selbst bei solch komplexen Berechnungen 30 FPS zu liefern.  Dies ist jedoch ein Thema f√ºr einen separaten Bericht.  Komm schon <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Mobius</a> ! </p><br><h2 id="nightmare">  <strong>Albtraum!</strong> </h2><br><blockquote>  <em>Ich blinke nicht gern, weil geschlossene Augenlider die GPU f√ºr BDPT wegen mangelnder Beleuchtung stark belasten.</em> <br>  <em>- John Carmack</em> </blockquote><p>  Wir haben also eine Reihe von Objekten mit coolen Effekten.  Jetzt bleibt zu lernen, wie man sie aufzeichnet.  Lassen Sie uns dazu zu einem komplexeren Thema √ºbergehen: Wie wir gelernt haben, Videos direkt aus SceneKit ohne externe Benutzeroberfl√§che aufzunehmen, und wie wir diese Aufnahme zehnmal optimiert haben. </p><br><p>  Wenden wir uns zun√§chst der einfachsten L√∂sung zu: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">ReplayKit</a> .  Finden Sie heraus, warum es nicht passt.  Im Allgemeinen k√∂nnen Sie mit dieser L√∂sung einen Bildschirmeintrag in mehreren Codezeilen erstellen und √ºber die Systemvorschau speichern.  Aber.  Es hat ein gro√ües Minus - es zeichnet alles auf, die gesamte Benutzeroberfl√§che, einschlie√ülich aller Schaltfl√§chen auf dem Bildschirm.  Dies war unsere erste Entscheidung, aber aus offensichtlichen Gr√ºnden war es unm√∂glich, sie in die Produktion zu lassen: Benutzer mussten das Video freigeben und nicht aus der Systemvorschau. </p><br><p>  Wir befanden uns in einer Situation, in der die L√∂sung von Grund auf neu geschrieben werden musste.  Absolut von Grund auf neu.  Lassen Sie uns sehen, wie Sie in iOS Ihr eigenes Video erstellen und Ihre Bilder dort aufnehmen k√∂nnen.  Alles ist ganz einfach: </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/bd5/ce3/0f8/bd5ce30f8b449cba0a5fbe8d68d2a420.png" alt="Aufnahmevorgang"><br>  <em>Aufnahmevorgang</em> </p><br><p>  Wir m√ºssen eine Entit√§t erstellen, die Dateien aufzeichnet - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AVAssetWriter</a> , einen Videostream - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AVAssetWriterInput</a> hinzuf√ºgen und einen Adapter f√ºr diesen Stream erstellen, der unseren <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pixelpuffer</a> in das vom Stream ben√∂tigte Format konvertiert - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">AVAssetWriterPixelBufferAdaptor</a> . </p><br><p>  Nur f√ºr den Fall, ich erinnere Sie daran, dass der <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Pixelpuffer</a> eine Entit√§t ist, die ein St√ºck Speicher ist, in dem die Daten f√ºr Pixel irgendwie geschrieben sind.  Dies ist im Wesentlichen eine Darstellung des Bildes auf niedriger Ebene. </p><br><p>  Aber wie bekommt man diesen Pixelpuffer?  Die L√∂sung ist einfach.  SCNView hat eine wunderbare <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.snapshot () -</a> Funktion, die ein UIImage zur√ºckgibt.  Wir m√ºssen nur einen Pixelpuffer aus diesem UIImage erstellen. </p><br><pre> <code class="objectivec hljs">var unsafePixelBuffer: CVPixelBuffer? CVPixelBufferPoolCreatePixelBuffer(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.pixelBufferPool, &amp;unsafePixelBuffer) guard let pixelBuffer = maybePixelBuffer <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } CVPixelBufferLockBaseAddress(pixelBuffer, <span class="hljs-number"><span class="hljs-number">0</span></span>) let data = CVPixelBufferGetBaseAddress(pixelBuffer) let rgbColorSpace = <span class="hljs-built_in"><span class="hljs-built_in">CGColorSpaceCreateDeviceRGB</span></span>() let bitmapInfo = <span class="hljs-built_in"><span class="hljs-built_in">CGBitmapInfo</span></span>(rawValue: <span class="hljs-built_in"><span class="hljs-built_in">CGBitmapInfo</span></span>.byteOrder32Little.rawValue | <span class="hljs-built_in"><span class="hljs-built_in">CGImageAlphaInfo</span></span>.premultipliedFirst.rawValue) let rowBytes = <span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>(CVPixelBufferGetBytesPerRow(pixelBuffer)) let context = <span class="hljs-built_in"><span class="hljs-built_in">CGContext</span></span>( data: data, width: image.width, height: image.height, bitsPerComponent: <span class="hljs-number"><span class="hljs-number">8</span></span>, bytesPerRow: CVPixelBufferGetBytesPerRow(pixelBuffer), space: rgbColorSpace, bitmapInfo: bitmapInfo.rawValue ) context?.draw(image, <span class="hljs-keyword"><span class="hljs-keyword">in</span></span>: <span class="hljs-built_in"><span class="hljs-built_in">CGRect</span></span>(x: <span class="hljs-number"><span class="hljs-number">0</span></span>, y: <span class="hljs-number"><span class="hljs-number">0</span></span>, width: image.width, height: image.height)) CVPixelBufferUnlockBaseAddress(pixelBuffer, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.appendPixelBuffer(pixelBuffer, withPresentationTime: presentationTime)</code> </pre> <br><p>  Wir weisen einfach einen Platz im Speicher zu, beschreiben, welches Format diese Pixel haben, blockieren den Puffer zum √Ñndern, rufen die Speicheradresse ab, erstellen einen Kontext an der empfangenen Adresse, wo wir beschreiben, wie die Pixel gepackt sind, wie viele Zeilen im Bild sind und welchen Farbraum wir verwenden.  Dann kopieren wir die Pixel von UIImage dort, kennen das endg√ºltige Format und entsperren die √Ñnderung. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ba0/e25/5a0/ba0e255a03515ee7e299bfa3d2757526.png"></p><br><p>  Jetzt m√ºssen Sie dies in jedem Frame tun.  Zu diesem Zweck erstellen wir einen Anzeigelink, der f√ºr jeden Frame einen R√ºckruf aufruft, wobei wir wiederum die Snapshot-Methode aufrufen und aus dem Bild einen Pixelpuffer erstellen.  Alles ist einfach! </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ab9/6fa/841/ab96fa8410458c0854d2c6b74bfb488c.gif"></p><br><p>  Aber nein.  Eine solche L√∂sung verursacht selbst bei leistungsstarken Telefonen schreckliche Verz√∂gerungen und FPS-Verluste.  Lassen Sie uns die Optimierung durchf√ºhren. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/b13/562/6e6/b135626e6d19559cb931b0d62e20e0d3.png"></p><br><p>  Nehmen wir an, wir brauchen keine 60 FPS.  Wir werden uns sogar √ºber den 25. freuen.  Aber was ist der einfachste Weg, um dieses Ergebnis zu erzielen?  Nat√ºrlich m√ºssen Sie dies alles nur in einen Hintergrund-Thread einf√ºgen.  Dar√ºber hinaus ist diese Funktion laut Entwicklern threadsicher. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/701/d7c/a26/701d7ca267899b726966bcefacd2921e.gif"></p><br><p>  Hmm, die Verz√∂gerung ist geringer geworden, aber das Video hat die Aufnahme gestoppt ... </p><br><p>  Alles ist einfach.  Wie sie sagen, wenn Sie ein Problem haben und es mit Hilfe mehrerer Threads l√∂sen, werden Sie 2 Probleme haben. </p><br><p>  Wenn Sie versuchen, einen Pixelpuffer mit einem Zeitstempel aufzuzeichnen, der niedriger als der zuletzt aufgezeichnete ist, ist das gesamte Video ung√ºltig. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/643/ed3/f61/643ed3f61dd84093f38c4447952d2a8b.png"></p><br><p>  Schreiben wir dann keinen neuen Puffer, bis der vorherige Schreibvorgang beendet ist. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/335/c9f/544/335c9f544b1bfd080a34cfe03847235a.gif"></p><br><p>  Hmm, es wurde viel besser.  Aber warum sind die Verz√∂gerungen anfangs aufgetreten? </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/ef1/b9d/838/ef1b9d8381334a5b0d6c9c4952eea020.png"></p><br><p>  Es stellt sich heraus, dass die Funktion <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.snapshot ()</a> , mit der wir ein Bild vom Bildschirm erhalten, f√ºr jeden Aufruf einen neuen Renderer erstellt, einen Frame von Grund auf neu zeichnet und zur√ºckgibt, nicht das Bild, das auf dem Bildschirm angezeigt wird.  Dies f√ºhrt zu lustigen Effekten.  Beispielsweise ist die physikalische Simulation doppelt so schnell. </p><br><p>  Aber warten Sie - warum versuchen wir jedes Mal, einen neuen Frame zu rendern?  Sicherlich finden Sie irgendwo den Puffer, der auf dem Bildschirm angezeigt wird.  Es gibt zwar Zugriff auf einen solchen Puffer, dieser ist jedoch nicht trivial.  Wir m√ºssen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CAMetalDrawable</a> von Metal bekommen. </p><br><p>  Leider ist es aus einem ziemlich verst√§ndlichen Grund nicht so einfach, direkt von SCNView zu Metal zu gelangen. In SceneKit k√∂nnen Sie den API-Typ selbst ausw√§hlen. Wenn Sie jedoch unter die Haube schauen und die <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Ebene betrachten</a> , k√∂nnen Sie feststellen, dass sie im Fall von Metal, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">CAMetalLayer</a> , so <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">funktioniert</a> . </p><br><p>  Aber auch hier erwartet uns ein Fehler: In CAMetalLayer ist die einzige M√∂glichkeit, mit der Ansicht zu interagieren, die nextDrawable-Funktion, die eine nicht belegte CAMetalDrawable zur√ºckgibt.  Es versteht sich, dass Sie Daten in das Programm schreiben und die aktuelle Funktion darauf aufrufen, die es auf dem Bildschirm anzeigt. </p><br><p>  Die L√∂sung existiert tats√§chlich.  Tatsache ist, dass der Puffer nach dem Verschwinden vom Bildschirm nicht freigegeben, sondern nur wieder in den Pool gestellt wird.  Warum sollte jedes Mal Speicher zugewiesen werden, wenn zwei oder drei Puffer ausreichen? Einer wird auf dem Bildschirm angezeigt, der zweite zum Rendern und der dritte beispielsweise zum Nachbearbeiten, falls Sie einen haben. </p><br><p>  Es stellt sich heraus, dass nach dem Anzeigen des Puffers die Daten aus dem Puffer nirgendwo verschwinden und Sie sicher darauf zugreifen k√∂nnen. </p><br><p>  Und wenn wir im Nachfolger als Antwort auf jeden Aufruf von nextDrawable () beginnen, um ihn zu speichern, erhalten wir fast das, was wir brauchen.  Das Problem ist, dass das gespeicherte CAMetalDrawable dasjenige ist, in dem das Bild gerade gezeichnet wird. </p><br><p>  Der Sprung zur eigentlichen L√∂sung ist sehr einfach - wir speichern sowohl das aktuelle Drawable als auch das vorherige. </p><br><p>  Und hier ist es fertig - direkter Zugriff auf den Speicher √ºber CAMetalDrawable. </p><br><pre> <code class="objectivec hljs">var unsafePixelBuffer: CVPixelBuffer? CVPixelBufferPoolCreatePixelBuffer(<span class="hljs-literal"><span class="hljs-literal">NULL</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.pixelBufferPool, &amp;unsafePixelBuffer) guard let pixelBuffer = maybePixelBuffer <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } CVPixelBufferLockBaseAddress(pixelBuffer, <span class="hljs-number"><span class="hljs-number">0</span></span>) let data = CVPixelBufferGetBaseAddress(pixelBuffer) let width: <span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span> = lastDrawable.texture.width let height: <span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span> = lastDrawable.texture.height let rowBytes: <span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span> = <span class="hljs-built_in"><span class="hljs-built_in">NSUInteger</span></span>(CVPixelBufferGetBytesPerRow(pixelBuffer) lastDrawable.texture.getBytes( data, bytesPerRow: rowBytes, fromRegion: <span class="hljs-built_in"><span class="hljs-built_in">MTLRegionMake2D</span></span>(<span class="hljs-number"><span class="hljs-number">0</span></span>, <span class="hljs-number"><span class="hljs-number">0</span></span>, width, height), mipmapLevel: <span class="hljs-number"><span class="hljs-number">0</span></span> ) CVPixelBufferUnlockBaseAddress(pixelBuffer, <span class="hljs-number"><span class="hljs-number">0</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.appendPixelBuffer(pixelBuffer, withPresentationTime: presentationTime)</code> </pre> <br><p>  Jetzt erstellen wir keinen Kontext und zeichnen kein UIImage darin, sondern kopieren ein St√ºck Speicher in ein anderes.  Es stellt sich die Frage: Was ist mit dem Pixelformat? </p><br><p>  Es stimmt nicht mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">deviceColorSpace √ºberein</a> ... Und es stimmt nicht mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">h√§ufig verwendeten</a> Farbr√§umen √ºberein ... </p><br><p>  Dies ist genau der Punkt, an dem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">der</a> Autor eines der √∂ffentlichen Herde, der die gleiche Aufgabe ausf√ºhrt, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">zusammenbrach</a> .  Alle anderen sind nicht einmal hierher gekommen. </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/198/181/bc7/198181bc7d908bca2ec56df495010106.gif"></p><br><p>  Nun, all diese Tricks - um eines gruseligen Filters willen? </p><br><p>  Nun, nein!  In dem Artikel √ºber ARKit finden Sie eine Erw√§hnung, dass das Bild von der Kamera nicht den Standardfarbraum verwendet, sondern erweitert wird.  Und sogar eine Matrix der Farbraumtransformation wird vorgestellt.  Aber warum sich auf eine Transformation einlassen, wenn Sie versuchen k√∂nnen, direkt in diesem Format aufzunehmen?  Es bleibt abzuwarten, welches Format von 60 verf√ºgbar ist ... </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/75d/802/781/75d8027810eb481eaa1775bd122cb79a.gif"></p><br><p>  Und dann fing ich an zu platzen.  Ich habe drei Videos in verschiedenen Streams mit unterschiedlichen Formaten aufgenommen und sie bei jeder Aufnahme ersetzt. </p><br><p>  Infolgedessen erhalten wir im etwa vierzigsten Format seinen Namen.  Es stellt sich heraus, dass es kein anderer als <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">kCVPixelFormatType_30RGBLEPackedWideGamut ist</a> .  Wie habe ich nicht geraten? </p><br><p><img src="https://habrastorage.org/getpro/habr/post_images/d6e/2e6/31e/d6e2e631e3dfdc690c85222a51561446.gif"></p><br><p>  Aber meine Freude hielt bis zum ersten Tester an.  Ich hatte keine Worte.  Wie?  Ich habe gerade viel Zeit damit verbracht, nach dem richtigen Format zu suchen.  Es ist gut, dass sich das Problem schnell lokalisiert hat - der Fehler wurde stabil und nur auf 6s und 6s Plus reproduziert.  Fast unmittelbar danach fiel mir ein, dass Displays mit breitem Farbumfang erst auf siebten iPhones installiert wurden. </p><br><p>  Wenn ich den weiten Bereich auf den guten alten 32RGBA umstelle, bekomme ich eine Arbeitsaufzeichnung!  Es bleibt zu verstehen, wie festgestellt werden kann, dass das Ger√§t einen weiten Bereich unterst√ºtzt.  Es gibt iPads mit verschiedenen Anzeigetypen, und ich dachte, dass Sie mit Sicherheit den ENUM-Anzeigetyp vom System erhalten k√∂nnen.  Beim Durchst√∂bern der Dokumentation habe ich sie gefunden - dies ist <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">displayGamut</a> in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">UITraitCollection</a> . </p><br><p>  Nachdem ich den Testern die Montage gegeben hatte, erhielt ich angenehme Neuigkeiten von ihnen - alles funktionierte ohne Verz√∂gerungen, auch auf alten Ger√§ten! </p><br><p>  Abschlie√üend m√∂chte ich Ihnen sagen - machen Sie 3D-Grafiken!  In unserer Anwendung, f√ºr die Augmented Reality nicht der Hauptanwendungsfall ist, haben Menschen am Wochenende mehr als 2.000 Kilometer zur√ºckgelegt, mehr als 3.000 Objekte angesehen und mehr als 1.000 Videos mit ihnen aufgenommen!  Stellen Sie sich vor, was Sie tun k√∂nnen, wenn Sie es selbst tun. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de431880/">https://habr.com/ru/post/de431880/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de431870/index.html">Entwickler interaktiver B√ºcher mit LEDs beschweren sich √ºber den Diebstahl von Ideen durch Google-Mitarbeiter</a></li>
<li><a href="../de431872/index.html">JavaScript-Handbuch Teil 9: √úbersicht √ºber die ES7-, ES8- und ES9-Standards</a></li>
<li><a href="../de431874/index.html">Imba: JavaScript-kompatible Sprache f√ºr die schnelle Arbeit mit DOM</a></li>
<li><a href="../de431876/index.html">Optimierung von Winkelanwendungen</a></li>
<li><a href="../de431878/index.html">Wenig bekannte JavaScript-Funktionen</a></li>
<li><a href="../de431884/index.html">Microsoft hat Apple bei der Marktkapitalisierung √ºbertroffen: Wie ist das passiert?</a></li>
<li><a href="../de431886/index.html">Al Lowy hat seine Quellcode-Sammlung f√ºr Sierra-Produkte bei eBay hochgeladen</a></li>
<li><a href="../de431888/index.html">‚ÄûIch denke, Teamideen sind bei der Entwicklung eines Produkts am wichtigsten.‚Äú</a></li>
<li><a href="../de431890/index.html">So geben Sie eine Bestellung an der freiberuflichen B√∂rse auf</a></li>
<li><a href="../de431892/index.html">Wir verwenden Veeam Backup & Replication, um neue Systeme und Anwendungen vor dem Upgrade zu testen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>