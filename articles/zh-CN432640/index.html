<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🍫 🎱 🔄 Rust 1.31和Rust 2018版本 🎡 🏁 👨🏿‍🍳</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Rust开发团队很高兴地宣布发布Rust的新版本1.31.0以及“ Rust 2018”。 Rust是一种编程语言，使每个人都可以创建可靠且高效的软件。 


如果您使用rustup安装了先前版本的Rust，那么要将Rust升级到版本1.31.0，您只需执行以下操作： 


 $ rustup up...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rust 1.31和Rust 2018版本</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/432640/"><p>  Rust开发团队很高兴地宣布发布Rust的新版本1.31.0以及“ Rust 2018”。  Rust是一种编程语言，使每个人都可以创建可靠且高效的软件。 </p><br><p>如果您使用<code>rustup</code>安装了先前版本的Rust，那么要将Rust升级到版本1.31.0，您只需执行以下操作： </p><br><pre> <code class="bash hljs">$ rustup update stable</code> </pre> <br><p> 如果尚未安装<code>rustup</code> ，则可以从我们网站的相应页面进行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">安装</a> 。 可以在GitHub上找到<a href="">Rust 1.31.0的详细发行说明</a> 。 </p><br><h2 id="chto-voshlo-v-stabilnuyu-versiyu-1310"> 稳定版1.31.0中包含什么 </h2><br><p>  Rust 1.31可以说是自Rust 1.0以来最重要的版本！ 此版本中包含“ Rust 2018”的第一次迭代，但这并不是唯一的创新！ 改进的审查很长，因此这里是目录： </p><br><ul><li>  <strong>锈2018</strong> <br><ul><li>  <strong>非词汇时代</strong> </li><li>  <strong>模块系统变更</strong> </li></ul></li><li>  <strong>显示寿命的其他规则</strong> </li><li> <strong><code>const fn</code></strong> </li> <li>  <strong>新工具</strong> </li><li>  <strong>工具代码质量检查</strong> </li><li>  <strong>该文件</strong> </li><li>  <strong>主题工作组</strong> </li><li>  <strong>新网站</strong> </li><li>  <strong>稳定标准库</strong> </li><li>  <strong>货运增强</strong> </li><li>  <strong>发布开发人员</strong> </li></ul><a name="habracut"></a><br><h3 id="rust-2018"> 锈2018 </h3><br><p> 我们<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在3月</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">7月</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一次</a>写了Rust 2018。 有关<em>为什么</em>需要Rust 2018的详细信息，请参阅这些出版物。 在这篇评论中，有太多要告诉我们的内容，因此我们仅关注Rust 2018的全部内容，您也可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在Mozilla Hacks的帖子中</a>阅读（ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">翻译</a> ）。 </p><br><p> 简而言之，Rust 2018是将我们过去三年中所做的所有工作整合为一个连贯整体的机会。  Rust 2018不仅仅是对语言的改进。 除它们之外，它还包括： </p><br><ul><li> 工具包（IDE， <code>rustfmt</code>和Clippy中的支持） </li><li> 该文件 </li><li> 主题工作组 </li><li> 新网站 </li></ul><br><p> 此外，我们将更详细地讨论所有这些以及其他创新。 </p><br><p> 让我们使用Cargo创建一个新项目： </p><br><pre> <code class="plaintext hljs">$ cargo new foo</code> </pre> <br><p> 这是<code>Cargo.toml</code>的内容： </p><br><pre> <code class="plaintext hljs">[package] name = "foo" version = "0.1.0" authors = ["Your Name &lt;you@example.com&gt;"] edition = "2018" [dependencies]</code> </pre> <br><p> 新的密钥已添加到<code>[package]</code>部分： <code>edition</code> 。 请注意，它<code>2018</code>安装。 您也可以在<code>2015</code>年安装它-如果缺少密钥，则默认情况下会设置此值。 </p><br><p> 使用Rust 2018将解锁Rust 2015中不允许的一些新功能。 </p><br><p> 重要的是要注意，每个软件包都可以处于2015或2018模式，并且它们可以一起工作。 您的2018版本项目可以使用2015版本依赖关系，而2015版本项目可以使用2018版本依赖关系。 这样可以确保生态系统的完整性，并且所有新功能都是可选的，同时保持与现有代码的兼容性。 此外，当您决定将Rust 2015代码移植到Rust 2018时，可以通过<code>cargo fix</code>自动进行更改。 </p><br><p> 您可能会问：新功能本身如何？ 首先，如果它们与该版本的功能兼容，它们也会在Rust 2015中添加。 因此，大多数语言到处都是相同的。 您可以查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">编辑手册，</a>以了解每个新功能及其其他要求的最低<code>rustc</code>版本。 但是，有几项重大创新需要分别提及：非词法生存期和模块系统中的某些更改。 </p><br><h4 id="neleksicheskie-vremena-zhizni"> 非词汇时代 </h4><br><p> 如果您在过去的几年中一直关注Rust，那么您可能偶尔会遇到“ NLL”或“非词汇寿命”一词。 这是行话，简单来说，意思是：借款人变得更聪明，现在接受一些正确的代码，而以前它拒绝了。 考虑一个例子： </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = &amp;x; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> z = &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x; }</code> </pre> <br><p>  Rust经常引发编译错误： </p><br><pre> <code class="plaintext hljs">error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable --&gt; src/main.rs:5:18 | 4 | let y = &amp;x; | - immutable borrow occurs here 5 | 6 | let z = &amp;mut x; | ^ mutable borrow occurs here 7 | } | - immutable borrow ends here</code> </pre> <br><p> 这是因为链接的生存区域是“按词法”定义的； 也就是说，即使我们不再在范围内再次使用<code>y</code> ，借用<code>y</code>才被视为活动状态，直到<code>y</code>在<code>main</code>的末尾超出范围为止。 上面的代码一切都很好，但是依赖分析器无法理解这一点。 </p><br><p> 现在，此代码可以正常编译。 </p><br><p> 但是，如果我们使用<code>y</code>怎么办？ 例如，像这样： </p><br><pre> <code class="rust hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> <span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x = <span class="hljs-number"><span class="hljs-number">5</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> y = &amp;x; <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> z = &amp;<span class="hljs-keyword"><span class="hljs-keyword">mut</span></span> x; <span class="hljs-built_in"><span class="hljs-built_in">println!</span></span>(<span class="hljs-string"><span class="hljs-string">"y: {}"</span></span>, y); }</code> </pre> <br><p>  Rust曾经给你这个错误： </p><br><pre> <code class="plaintext hljs">error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable --&gt; src/main.rs:5:18 | 4 | let y = &amp;x; | - immutable borrow occurs here 5 | let z = &amp;mut x; | ^ mutable borrow occurs here ... 8 | } | - immutable borrow ends here</code> </pre> <br><p> 在Rust 2018中，此错误消息得到了改进： </p><br><pre> <code class="plaintext hljs">error[E0502]: cannot borrow `x` as mutable because it is also borrowed as immutable --&gt; src/main.rs:5:13 | 4 | let y = &amp;x; | -- immutable borrow occurs here 5 | let z = &amp;mut x; | ^^^^^^ mutable borrow occurs here 6 | 7 | println!("y: {}", y); | - borrow later used here</code> </pre> <br><p> 它没有显示<code>y</code>超出范围的地方，而是显示发生冲突的借用的地方。 这大大简化了此类调试错误。 </p><br><p> 在Rust 1.31中，这是对Rust 2018的专门改进。我们计划稍后将其添加到Rust 2015中。 </p><br><h4 id="izmeneniya-sistemy-moduley"> 模块系统变更 </h4><br><p> 对于初次学习Rust的人来说，模块系统可能会很困难。 当然，总有一些东西需要花费时间来掌握。 但是，模块之所以让许多人感到尴尬的主要原因是，尽管定义了模块系统的规则简单而一致，但使用它们的后果却似乎是矛盾的，神秘的和不自然的。 </p><br><p> 因此，2018版对路径的工作方式进行了一些更改，从而简化了模块系统并使之更易于理解。 </p><br><p> 这是一个简短的摘要： </p><br><ul><li> 几乎其他任何地方都不再需要<code>extern crate</code> 。 </li><li> 您可以使用<code>use</code>导入宏，而不要使用<code>#[macro_use]</code>属性。 </li><li> 绝对路径以容器名称开头，其中<code>crate</code>关键字引用当前容器。 </li><li>  <code>foo.rs</code>和<code>foo/</code>子目录可以共存； 将子模块放在子目录中时，不再需要<code>mod.rs</code> </li></ul><br><p> 它看起来像一组任意规则，但是总体上，现在已经大大简化了心理模型。 </p><br><p> 还有<em>很多</em>细节，所有细节请参考<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">编辑手册</a> 。 </p><br><h3 id="dopolnitelnye-pravila-vyvoda-vremen-zhizni"> 显示寿命的其他规则 </h3><br><p> 让我们谈谈两个版本中可用的改进：我们为<code>impl</code>块和函数定义添加了一些其他推理规则。 像这样的代码： </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span>&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; Reader <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> BufReader&lt;<span class="hljs-symbol"><span class="hljs-symbol">'a</span></span>&gt; { <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre> <br><p> 现在可以这样写： </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">impl</span></span> Reader <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> BufReader&lt;<span class="hljs-symbol"><span class="hljs-symbol">'_</span></span>&gt; { <span class="hljs-comment"><span class="hljs-comment">//   }</span></span></code> </pre> <br><p> 生命周期<code>'_</code>仍然显示<code>BufReader</code>将其作为参数，但是我们不再需要为其命名。 </p><br><p> 寿命仍然需要在结构中定义。 但是，我们不再需要像以前那样编写更多的样板代码： </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">// Rust 2015 struct Ref&lt;'a, T: 'a&gt; { field: &amp;'a T } // Rust 2018 struct Ref&lt;'a, T&gt; { field: &amp;'a T }</span></span></code> </pre> <br><p> 相关性<code>: 'a</code>将被输出。 您仍然可以根据需要明确指定它。 我们正在考虑将来在这些地方撤出其他机会，但到目前为止，我们还没有具体计划。 </p><br><h3 id="const-fn"> <code>const fn</code> </h3> <br><p>  Rust有几种方法来声明函数： <code>fn</code>用于普通函数， <code>unsafe fn</code>用于不安全函数， <code>extern fn</code>用于外部函数。 此版本增加了一种声明函数的新方法： <code>const fn</code> 。 它的用法如下： </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fn</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">foo</span></span></span></span>(x: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span>) -&gt; <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> { x + <span class="hljs-number"><span class="hljs-number">1</span></span> }</code> </pre> <br><p> 常量函数可以称为普通函数，但除此之外，它可以在任何常量上下文中使用。 但是，它将在编译时执行，而不是在程序执行期间执行。 例如： </p><br><pre> <code class="rust hljs"><span class="hljs-keyword"><span class="hljs-keyword">const</span></span> SIX: <span class="hljs-built_in"><span class="hljs-built_in">i32</span></span> = foo(<span class="hljs-number"><span class="hljs-number">5</span></span>);</code> </pre> <br><p>  <code>foo</code>函数将在编译时执行，并且<code>SIX</code>将设置为<code>6</code> 。 </p><br><p> 常量函数无法完成普通函数可以做的所有事情：它们必须具有确定性的结果。 出于可靠性考虑，这一点很重要。 以当前形式，常量函数可以执行最少的操作子集。 以下是您可以在其中执行的操作的一些示例： </p><br><ul><li> 使用整数算术和比较运算 </li><li> 使用<code>&amp;&amp;</code>和<code>||</code>以外的任何逻辑运算 </li><li> 设计数组，结构，枚举和元组 </li><li> 调用其他常量函数 </li><li> 通过索引访问数组和切片 </li><li> 访问结构和元组的字段 </li><li> 使用常量（但不要使用静态值，甚至不要引用它们） </li><li> 使用<code>&amp;</code>和<code>*</code>链接 </li><li> 强制类型转换，除了将原始指针转换为整数值 </li></ul><br><p> 我们将扩展常量函数的功能，但是上面的设置已经足够在实践中使用<code>const fn</code>了。 </p><br><p> 有关详细信息，请参见<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">手册</a> 。 </p><br><h3 id="novye-instrumenty"> 新工具 </h3><br><p>  2018年版本标志着Rust工具生态系统达到新的成熟水平的开始。 自1.0版以来，Cargo，Rustdoc和Rustup一直是主要工具。 随着2018年版本的出现，新一代工具已经面世，每个人现在都可以使用：Clippy，Rustfmt和IDE支持。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>clippy</code></a>静态代码分析器现在可以在稳定的Rust中使用。 您可以通过<code>rustup component add clippy</code>进行安装，并使用<code>cargo clippy</code>运行它。  Clippy现在已经收到1.0版，并且具有与rustc相同的静态检查稳定性保证。 可以添加新支票，或者可以扩展旧支票的功能，但是不能删除旧支票（只能将其标记为过时的）。 这意味着使用clippy编译的代码将继续使用clippy编译（假定未设置检查以生成 <br> 错误（通过<code>deny</code> ），但可能会生成新的警告。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Rustfmt</a>是用于在Rust中格式化代码的工具。 自动代码格式化将节省您的时间，此外，它将使您的代码更接近于<a href="">Rust</a>的<a href="">正式样式</a> 。 您可以通过<code>rustup component add rustfmt</code>进行安装，并使用<code>cargo fmt</code>命令。 </p><br><p> 当前版本包括Rustfmt 1.0。 从现在开始，我们保证Rustfmt的向后兼容性：如果您今天格式化代码，那么以后的格式将不会更改（仅适用于默认设置）。 向后兼容意味着现在可以在CI上运行Rustfmt（使用<code>cargo fmt --check</code> ）。 在编辑器中将其与“保存时格式化”一起尝试，这将彻底改变您的工作流程。 </p><br><p>  IDE支持是Rust最需要的功能之一。 现在有几种高质量的解决方案： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Visual Studio代码</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">IntelliJ</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">原子</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">崇高文字3</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">日蚀</a> </li></ul><br><p>  IDE中的支持工作尚未完成。 尤其是，基于RLS的编辑器中的代码完成不符合标准。 但是，如果您主要希望支持类型，文档和“到定义的转换”，那么您会感到满意的。 </p><br><h3 id="instrumentalnye-proverki-kachestva-koda-tool-lints"> 仪器代码质量检查（工具棉绒） </h3><br><p> 在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Rust 1.30中，</a>我们稳定了“工具属性”，例如<code>#[rustfmt::skip]</code> 。 在Rust 1.31中，我们稳定了以下内容： <code>#[allow(clippy::bool_comparison)]</code>类的“ tool lints”。 这使您可以为检查指定名称空间，以更清楚地了解它们来自什么工具。 </p><br><p> 如果您以前使用过Clippy检查，则可以按以下方式迁移： </p><br><pre> <code class="rust hljs"><span class="hljs-comment"><span class="hljs-comment">//  #![cfg_attr(feature = "cargo-clippy", allow(bool_comparison))] //  #![allow(clippy::bool_comparison)]</span></span></code> </pre> <br><p> 您不再需要<code>cfg_attr</code> ！ 您现在还将收到警告，可以帮助您切换到使用新样式。 </p><br><h3 id="dokumentaciya"> 该文件 </h3><br><p> 今年，Rustdoc进行了一些改进，并完全重写了《 Rust编程语言》一书。 您可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">从No Starch Press</a>购买<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">纸质副本</a> ！ </p><br><p> 它以前被称为这本书的“第二版”，但是由于它成为第一版印刷，因此引起了混乱。 毕竟，印刷版计划要定期更新。 最后，在与No Starch进行了多次讨论之后，决定在每个发行版的网站上进行更新，No Starch会定期提取并打印更改。 这本书卖得很好，并为《 <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">黑人女孩守则》</a>筹集了资金。 </p><br><p> 您可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>找到该书的新版本。 </p><br><h3 id="predmetnye-rabochie-gruppy"> 主题工作组 </h3><br><p> 今年，我们宣布成立四个工作组： </p><br><ul><li> 网络服务 </li><li> 命令行应用 </li><li> 网络组装 </li><li> 嵌入式设备 </li></ul><br><p> 这些小组非常努力地使Rust在这些领域中都变得更好。 以下是一些成就： </p><br><ul><li> 网络服务重新设计了期货的接口，此外还异步/等待。 这些改进尚未发布，但我们已经接近了！ </li><li>  CLI团队研究库和文档，以使命令行应用程序更好。 </li><li>  WebAssembly发布了许多世界一流的工具，可将Rust与wasm一起使用。 </li><li> 对于嵌入式设备，可以在稳定的Rust上开发ARM！ </li></ul><br><p> 您可以在我们的新网站上了解更多关于这一切的信息！ </p><br><h3 id="novyy-veb-sayt"> 新网站 </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">上周，</a>我们宣布了我们网站的新版本。 现在它已经成为rust-lang.org的正式版本！ </p><br><p> 要创建它需要许多人花费一年的时间。 尽管在完成之前还有很多工作要做，但是我们为完成的工作感到自豪。 </p><br><h3 id="stabilizaciya-standartnoy-biblioteki"> 稳定标准库 </h3><br><p> 添加了新的<code>From</code>实现： </p><br><ul><li>  <code>u8</code>现在实现<code>From&lt;NonZeroU8&gt;</code> ，对于其他数字类型及其等效的<code>NonZero</code> </li><li>  <code>Option&lt;&amp;T&gt;</code> <code>From&lt;&amp;Option&lt;T&gt;&gt;</code> <code>&amp;mut</code>类似，实现了<code>From&lt;&amp;Option&lt;T&gt;&gt;</code> </li></ul><br><p> 以下功能也已稳定： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>slice::align_to</code></a>及其可变的副本 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>slice::chunks_exact</code></a> ，以及所有组合中的可变和<code>r</code>对应项（例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>slice::rchunks_exact_mut</code></a> ） </li></ul><br><p> 有关<a href="">更多</a>详细信息，请参见<a href="">发行说明</a> 。 </p><br><h3 id="uluchsheniya-v-cargo"> 货运增强 </h3><br><p> 现在，货运将使用HTTP / 2并行加载包裹。 </p><br><p> 另外，由于<code>extern crate</code>现在<code>extern crate</code>可选的，因此将<code>extern crate foo as bar;</code>编写<code>extern crate foo as bar;</code>会令人沮丧<code>extern crate foo as bar;</code> 重命名依赖关系。 因此，您可以<code>Cargo.toml</code>以下方式在<code>Cargo.toml</code> ： </p><br><pre> <code class="plaintext hljs">[dependencies] baz = { version = "0.1", package = "foo" }</code> </pre> <br><p> 或等效地： </p><br><pre> <code class="plaintext hljs">[dependencies.baz] version = "0.1" package = "foo"</code> </pre> <br><p>  <code>foo</code>软件包现在可以<code>baz</code>在您的代码中使用。 </p><br><p> 有关<a href="">更多</a>详细信息，请参见<a href="">发行说明</a> 。 </p><br><h2 id="razrabotchiki-1310"> 开发人员1.31.0 </h2><br><p> 通常，在审阅结束时，我们感谢<a href="">为发布做出贡献</a>的<a href="">人们</a> 。 但是这次，与过去不同，此列表并未完全涵盖所有提供帮助的人员以及已完成的所有工作。 每个定期发布都是六个星期的工作结果，但此发布是三年努力的结晶，这反映在大量人员创建的大量存储库中。 我们很高兴与大家一起工作，我们期待Rust在未来三年中继续发展。 </p><br><p>  <em>译者：我要特别感谢Rustycrate社区的成员，并亲自<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">感谢@dashadee</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">ozkriff</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">humbug</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" class="user_link">mvlabat</a>的翻译和校对工作。</em> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN432640/">https://habr.com/ru/post/zh-CN432640/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN432630/index.html">您想了解的有关查询处理的所有信息，但不好意思问</a></li>
<li><a href="../zh-CN432632/index.html">互联网巨魔最喜欢的垃圾电话巨魔莱尼的故事</a></li>
<li><a href="../zh-CN432634/index.html">五个HTTP Web开发库概述</a></li>
<li><a href="../zh-CN432636/index.html">React教程第1部分：课程概述，React，ReactDOM和JSX受欢迎的原因</a></li>
<li><a href="../zh-CN432638/index.html">Upsource 2018.2的新增功能</a></li>
<li><a href="../zh-CN432642/index.html">使用DeviceLock DLP和Citrix Xen控制移动设备上的电子邮件</a></li>
<li><a href="../zh-CN432644/index.html">Intamsys FUNMAT HT高温3D打印机概览</a></li>
<li><a href="../zh-CN432646/index.html">自上而下和自下而上的平衡兼并</a></li>
<li><a href="../zh-CN432648/index.html">我们如何进入云提供商的市场并爱上B2B。 案例MCS</a></li>
<li><a href="../zh-CN432650/index.html">收集软件项目的需求-无需削减</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>