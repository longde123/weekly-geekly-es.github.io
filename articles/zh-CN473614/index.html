<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤠 ⌚️ ♐️ 该书“头先。 科特林» 🏴 👩🏻‍🏭 🔷</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="嗨，habrozhiteli！ 我们有一本书出版，使用Head First技术研究Kotlin，它超出了解决特定问题的语法和说明。 本书将为您提供所需的一切-从语言的基础到高级方法。 您可以练习面向对象和函数式编程。 

 剪辑下方显示摘录“数据类”。 

 处理数据 
 没有人愿意浪费时间并重做已...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>该书“头先。 科特林»</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/piter/blog/473614/"> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><img src="https://habrastorage.org/webt/ev/fj/ao/evfjaohk2b8qeka0nzciygs_q70.jpeg" align="left" alt="图片"></a> 嗨，habrozhiteli！ 我们有一本书出版，使用Head First技术研究Kotlin，它超出了解决特定问题的语法和说明。 本书将为您提供所需的一切-从语言的基础到高级方法。 您可以练习面向对象和函数式编程。 <br><br> 剪辑下方显示摘录“数据类”。 <br><a name="habracut"></a><br><h3> 处理数据 </h3><br> 没有人愿意浪费时间并重做已经完成的事情。 大多数应用程序使用类来存储数据。 为了简化工作，Kotlin的创建者提出了数据类的概念。 在本章中，您将学习数据类如何帮助您编写更优雅，更简洁的代码，而这是您以前梦dream以求的。 我们将研究数据类的辅助函数，并学习如何将数据对象分解为组件。 同时，我们将描述默认参数值如何使代码更灵活，并向您介绍所有超类的祖先Any。 <br><br><h3>  ==运算符调用一个等于函数 </h3><br> 如您所知，==运算符可用于验证相等性。 每次执行==语句时，都会调用一个称为equals的函数。 每个对象都包含一个equals函数，此函数的实现确定==运算符的行为。 <br><br> 默认情况下，用于检查相等性的equals函数检查两个变量引用是否指向同一对象。 <br><br> 要了解其工作原理，请想象两个名为w1和w2的Wolf变量。 如果w1和w2包含对一个Wolf对象的引用，则将它们与==运算符进行比较时，结果为true： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/21/xu/jv/21xujvaljehbr6dvg7klxpu7qi8.png" alt="图片"></div><br> 但是，如果w1和w2包含对不同Wolf对象的引用，则将它们与==运算符进行比较，即使对象包含相同的属性值，其结果也为false。 <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/de/xo/fb/dexofbmvz5qakq1ls-hhvp7h8r8.png" alt="图片"></div><br> 如前所述，equals函数自动包含在您创建的每个对象中。 但是此功能从何而来？ <br><br><h3> 等于从超类Any继承 </h3><br> 每个对象都包含一个称为equals的函数，因为其类从名为Any的类继承了一个函数。  Any类是所有类的祖先：一切的结果超类。 您定义的每个类都是Any的子类，您无需在程序中指出这一点。 因此，如果编写一个名为myClass的类代码，则如下所示： <br><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyClass</span></span></span><span class="hljs-class"> </span></span>{ ... }</code> </pre> <br> 编译器将自动将其转换为以下格式： <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tv/04/lg/tv04lgenrnekhx2uqa2bsfr4meu.png" alt="图片"></div><br><blockquote> 每个类都是Any的子类，并继承其行为。 每个类都是Any的子类，您不必在程序中报告此情况。 </blockquote><br><h3> 任何继承的重要性 </h3><br> 包含Any作为生成的超类具有两个重要的优点： <br><br><ul><li>  <b>它确保每个类都继承通用行为。</b>  Any类定义系统操作所依赖的重要行为。 而且由于每个类都是Any的子类，所以此行为将由您创建的所有对象继承。 因此，Any类定义了一个称为equals的函数，因此，该函数自动被所有对象继承。 </li><li>  <b>这意味着多态可以与任何对象一起使用。</b> 每个类都是Any的子类，因此您创建的任何对象都将Any类作为其最终超类型。 这意味着您可以使用任何参数或任何返回类型创建一个可与任何类型的对象一起使用的函数。 这也意味着您可以使用以下形式的代码创建多态数组以存储任何类型的对象： </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> myArray = arrayOf(Car(), Guitar(), Giraffe())</code> </pre><br> 编译器注意到数组中的每个对象都有一个通用的Any原型，因此创建了一个Array类型的数组。 <br><br>  Any类继承的一般行为值得仔细研究。 <br><br><h3> 从Any继承的常见行为 </h3><br>  Any类定义了每个类继承的几个函数。 以下是基本功能及其行为的示例： <br><br><ul><li>  <b>等于（任意：任意）：布尔值</b> <br> 检查两个对象是否被视为“相等”。 默认情况下，如果函数用于检查一个对象，则该函数返回true；否则，该函数返回false-用于不同的对象。 在幕后，每次在程序中使用==运算符时，都会调用equals函数。 </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> w1 = Wolf() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> w1 = Wolf() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> w2 = Wolf() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> w2 = w1 println(w1.equals(w2)) println(w1.equals(w2)) <span class="hljs-literal"><span class="hljs-literal">false</span></span> (equals  <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span> (equals  <span class="hljs-literal"><span class="hljs-literal">true</span></span>,   w1  w2   w1  w2        .)      —   ,   w1 == w2.</code> </pre> <br><ul><li>  <b>hashCode（）：整数</b> <br> 返回对象的哈希码。 某些数据结构经常使用哈希码来有效地存储和检索值。 </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> w = Wolf() println(w.hashCode())</code> </pre> <br>  <b>523429237</b> （哈希码w的值） <br><br><ul><li>  <b>toString（）：字符串</b> <br> 返回表示对象的String消息。 默认情况下，该消息包含类名和数字，我们通常不关心它们。 </li></ul><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> w = Wolf() println(w.toString())</code> </pre> <br>  <b>狼@ 1f32e575</b> <br><br><blockquote> 默认情况下，equals函数检查两个对象是否是相同的实际对象。 <br><br>  equals函数确定==运算符的行为。 </blockquote><br>  Any类为列出的所有功能提供默认实现，并且所有类都继承了这些实现。 但是，您可以覆盖这些实现以更改所有列出的功能的默认行为。 <br><br><h3> 两个对象的简单等效检查 </h3><br> 在某些情况下，您需要更改equals函数的实现以更改==运算符的行为。 <br><br> 假设您有一个Recipe类，该类可让您创建用于存储配方的对象。 在这种情况下，如果两个Recipe对象包含相同配方的描述，则可能会认为它们相等（或等效）。 假设Recipe类定义了两个属性-title和isVegetarian： <br><br><pre> <code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Recipe</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isVegetarian: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) { }</code> </pre> <br> 如果==运算符用于比较两个具有相同属性title和isVegetarian的Recipe对象，则它将返回true： <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r1 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r2 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/x6/xf/mf/x6xfmfs4maim5uck7papwh2pqdg.png" alt="图片"></div><br> 尽管您可以通过编写其他代码来覆盖equals函数来更改==运算符的行为，但Kotlin开发人员提供了更为方便的解决方案：他们创建了数据类的概念。 让我们看看这些类是什么以及如何创建它们。 <br><br><h3> 数据类允许您创建数据对象。 </h3><br> 数据类是用于创建用于存储数据的对象的类。 它包括一些对数据有用的工具，例如equals函数的新实现，该函数检查两个数据对象是否包含相同的属性值。 如果两个对象包含相同的数据，则可以认为它们相等。 <br><br> 要定义数据类，请在常规数据定义之前添加data关键字。 以下代码将先前创建的Recipe类转换为数据类： <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Recipe</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isVegetarian: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) { }</code> </pre> <br> 数据前缀将常规类转换为数据类。 <br><br><h3> 如何基于数据类创建对象 </h3><br> 数据类对象的创建方式与常规类对象相同：通过调用此类的构造函数。 例如，以下代码创建一个新的Recipe数据对象，并将其分配给名为r1的新变量： <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r1 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre> <br> 数据类自动覆盖它们的equals函数，以更改==运算符的行为，以便根据每个对象的属性值检查对象的相等性。 例如，如果您创建两个具有相同属性值的Recipe对象，则将两个对象与==运算符进行比较将得出结果为true，因为相同的数据存储在其中： <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r1 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r2 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-comment"><span class="hljs-comment">//r1 == r2  true</span></span></code> </pre><br>  r1和r2被视为“相等”，因为两个Recipe对象包含相同的数据。 <br><br> 除了继承自超类Any，数据类的equals函数的新实现之外 <br> 还重写hashCode和toString函数。 让我们看看如何实现这些功能。 <br><br><h3> 类对象重新定义其继承的行为 </h3><br> 为了处理数据，数据类需要对象，因此它自动为从Any超类继承的equals，hashCode和toString函数提供以下实现： <br><br><h3>  equals函数比较属性值 </h3><br> 定义数据类时，如果链接指向同一对象，则其equals函数（因此==运算符）仍返回true。 但是，如果对象具有在构造函数中定义的相同属性值，则它也会返回true： <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r1 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r2 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) println(r1.equals(r2)) <span class="hljs-literal"><span class="hljs-literal">true</span></span></code> </pre> <br><blockquote> 如果数据对象的属性包含相同的值，则认为它们相等。 </blockquote><br><h3> 对于相等的对象，返回相同的hashCode值 </h3><br> 如果两个数据对象被认为相等（换句话说，它们具有相同的属性值），则hashCode函数为这些对象返回相同的值： <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r1 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r2 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) println(r1.hashCode()) println(r2.hashCode())</code> </pre> <br>  <b>241131113</b> <b><br></b>  <b>241131113</b> <br><br><h3>  toString返回所有属性的值 </h3><br> 最后，toString函数不再返回类名，后跟数字，而是返回一个有用的字符串，其中包含在数据类的构造函数中定义的所有属性的值： <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r1 = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) println(r1.toString()) Recipe(title=Chicken Bhuna, isVegetarian=<span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre> <br> 除了覆盖从Any超类继承的函数之外，数据类还提供其他工具，这些工具可提供对数据的更有效处理，例如，复制数据对象的能力。 让我们看看这些工具如何工作。 <br><br><h3> 使用复制功能复制数据对象 </h3><br> 如果需要通过更改数据对象的某些属性来创建数据对象的副本，但将其他属性保留为原始状态，请使用复制功能。 为此，将为要复制的对象调用该函数，并将具有新值的所有可变属性的名称传递给该函数。 <br><br> 假设您有一个名为r1的Recipe对象，它在如下代码中定义： <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r1 = Recipe(<span class="hljs-string"><span class="hljs-string">"Thai Curry"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre> <br><div style="text-align:center;"><img src="https://habrastorage.org/webt/tu/hk/oi/tuhkoizk5srtgdpish28kozd5o4.png" alt="图片"></div><br> 如果要创建Recipe对象的副本，将isVegetarian属性的值替换为true，可以这样进行： <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/p1/_9/xb/p1_9xbbjnwqi2p-lwlsh7jzjvcw.png" alt="图片"></div><br> 本质上，这意味着“创建r1对象的副本，将其isVegetarian属性的值更改为true，然后将新对象分配给名为r2的变量。” 这将创建该对象的新副本，并且原始对象保持不变。 <br><br> 除了复制功能外，数据类还提供了一组用于将数据对象拆分为一组属性值的功能-此过程称为解构。 让我们看看这是如何完成的。 <br><br><h3> 数据类定义componentN ...函数 </h3><br> 定义数据类时，编译器会自动向该类添加一组函数，这些函数可用作访问对象属性值的替代机制。 这些函数在componentN函数的通用名称下是已知的，其中N是要提取的属性数（按声明顺序）。 <br><br> 若要查看componentN函数如何工作，假设您具有以下Recipe对象： <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r = Recipe(<span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>)</code> </pre> <br> 如果要获取对象的第一个属性的值（标题属性），可以为此调用对象的component1（）函数： <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title = r.component1()</code> </pre> <br>  component1（）返回包含在数据类的构造函数中定义的第一个属性中的引用。 <br><br> 该函数与以下代码相同： <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title = r.title</code> </pre> <br> 具有该功能的代码更加通用。 为什么ComponentN函数在数据类中如此有用？ <br><br><h3>  ...旨在重组数据对象 </h3><br> 通用componentN函数之所以有用，主要是因为它们提供了一种简单方便的方法来将数据对象拆分为属性值或对其进行破坏。 <br><br> 假设您要获取Recipe对象的属性值，并将其每个属性的值分配给一个单独的变量。 代替代码 <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title = r.title <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> vegetarian = r.isVegetarian</code> </pre> <br> 通过顺序处理每个属性，可以使用以下代码： <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> (title, vegetarian) = r</code> </pre> <br> 为第一个属性r分配标题，为第二个属性分配素食。 <br><br> 该代码的意思是“创建两个变量title和Vegetarian，并分配每个变量r属性之一的值。” 他和下一个片段一样 <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title = r.component1() <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> vegetarian = r.component2()</code> </pre> <br> 但事实证明它更紧凑。 <br><br>  <b>===运算符始终检查两个变量是否引用同一对象。</b> <br><br> 如果要检查两个变量是否引用同一个对象，而不管它们的类型如何，请使用===运算符而不是==。 当（且仅当）两个变量包含对一个实际对象的引用时，===运算符将结果设为true。 如果您有两个变量x和y，以及以下表达式： <br><br><pre> <code class="kotlin hljs">x === y</code> </pre> <br> 如果结果为true，则您知道变量x和y必须引用同一对象。 <br><br> 与==运算符不同，===运算符的行为独立于equals函数。 不管类的类型如何，===运算符的行为始终相同。 <br><br> 现在，您已经学习了如何创建和使用数据类，为食谱代码创建一个项目。 <br><br><h3> 创建食谱项目 </h3><br> 为JVM创建一个新的Kotlin项目，并将其命名为“ Recipes”。 然后创建一个新的 <br>  Kotlin文件，名为Recipes.kt：选择src文件夹，打开“文件”菜单，然后选择命令 <br> 新建→Kotlin文件/类。 输入文件名“ Recipes”，然后在“种类”组中选择“文件”选项。 <br><br> 我们将一个名为Recipe的新数据类添加到项目中，并创建Recipe数据对象。 下面是代码。 更新您的Recipes.kt版本，并将其与我们的版本保持一致： <br><br><pre> <code class="kotlin hljs"><span class="hljs-keyword"><span class="hljs-keyword">data</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Recipe</span></span></span></span>(<span class="hljs-keyword"><span class="hljs-keyword">val</span></span> title: String, <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> isVegetarian: <span class="hljs-built_in"><span class="hljs-built_in">Boolean</span></span>) (  {} ,        .) <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(args: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Array</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;</span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">&gt;)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r1 = Recipe(<span class="hljs-string"><span class="hljs-string">"Thai Curry"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r2 = Recipe(<span class="hljs-string"><span class="hljs-string">"Thai Curry"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> r3 = r1.copy(title = <span class="hljs-string"><span class="hljs-string">"Chicken Bhuna"</span></span>) (  r1    title) println(<span class="hljs-string"><span class="hljs-string">"r1 hash code: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${r1.hashCode()}</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">"r2 hash code: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${r2.hashCode()}</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">"r3 hash code: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${r3.hashCode()}</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">"r1 toString: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${r1.toString()}</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">"r1 == r2? </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${r1 == r2}</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">"r1 === r2? </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${r1 === r2}</span></span></span><span class="hljs-string">"</span></span>) println(<span class="hljs-string"><span class="hljs-string">"r1 == r3? </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${r1 == r3}</span></span></span><span class="hljs-string">"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> (title, vegetarian) = r1 ( r1) println(<span class="hljs-string"><span class="hljs-string">"title is </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$title</span></span></span><span class="hljs-string"> and vegetarian is </span><span class="hljs-variable"><span class="hljs-string"><span class="hljs-variable">$vegetarian</span></span></span><span class="hljs-string">"</span></span>) }</code> </pre> <br> 运行代码时，以下文本将显示在IDE的输出窗口中： <br><br><pre> <code class="kotlin hljs">r1 hash code: -<span class="hljs-number"><span class="hljs-number">135497891</span></span> r2 hash code: -<span class="hljs-number"><span class="hljs-number">135497891</span></span> r3 hash code: <span class="hljs-number"><span class="hljs-number">241131113</span></span> r1 toString: Recipe(title=Thai Curry, isVegetarian=<span class="hljs-literal"><span class="hljs-literal">false</span></span>) r1 == r2? <span class="hljs-literal"><span class="hljs-literal">true</span></span> r1 === r2? <span class="hljs-literal"><span class="hljs-literal">false</span></span> r1 == r3? <span class="hljs-literal"><span class="hljs-literal">false</span></span> title <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> Thai Curry and vegetarian <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">false</span></span></code> </pre><br><br>  »这本书的更多信息可以<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在出版商的网站上找到</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">目录</a> <br>  » <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">摘录</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><br></a> <br>  Khabrozhitel- <b>Kotlin的</b>优惠券可享受25％的折扣 <br><br> 支付纸质版本的书后，就会通过电子邮件发送电子书。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN473614/">https://habr.com/ru/post/zh-CN473614/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN473600/index.html">谁需要Chromebook？</a></li>
<li><a href="../zh-CN473602/index.html">异步工作</a></li>
<li><a href="../zh-CN473608/index.html">理解现代Web App开发概念的指南</a></li>
<li><a href="../zh-CN473610/index.html">解析新的Plesk Obsidian Web控制台</a></li>
<li><a href="../zh-CN473612/index.html">别针上的论文。 为微控制器在C ++中配置和使用引脚的想法（以CortexM为例）</a></li>
<li><a href="../zh-CN473626/index.html">“开发商想在三年内购买飞机。 我的任务是帮助他”-丹尼斯·普希金谈Skyeng的动机</a></li>
<li><a href="../zh-CN473628/index.html">正畸服务中的C ++：Align Technology CAD开发人员Mikhail Matrosov访谈</a></li>
<li><a href="../zh-CN473630/index.html">开发iOS应用程序的最佳做法和工具</a></li>
<li><a href="../zh-CN473632/index.html">我们看了一篇关于哈伯的文章</a></li>
<li><a href="../zh-CN473634/index.html">Comcast大堂禁止DNS加密</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>