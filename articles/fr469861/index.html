<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🙇🏿 🧓 ⚔️ Structures de données pour les programmeurs de jeux: données en masse 🧑🏼‍🤝‍🧑🏼 👨🏻‍🏭 🚣🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tout programmeur bénéficiera d'une compréhension des différentes structures de données et de la manière d'analyser leurs performances. Mais dans la pr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Structures de données pour les programmeurs de jeux: données en masse</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469861/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e7/1d7/bb3/7e71d7bb314eaffe2d54f349cc854a5f.png" alt="image"></div><br>  Tout programmeur bénéficiera d'une compréhension des différentes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">structures de données</a> et de la manière d'analyser leurs performances.  Mais dans la pratique, je n'ai jamais été utile pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les arbres AVL, les arbres</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rouge-noir, les arbres</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">préfixes</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les listes à sauter</a> , etc.  J'utilise certaines structures de données pour un seul algorithme spécifique et rien de plus (par exemple, des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tas</a> pour implémenter une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">file d'attente prioritaire</a> dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'algorithme de recherche de chemin A *</a> ). <br><br>  Dans le travail quotidien, je fais habituellement avec étonnamment peu de structures de données.  Le plus souvent, ils me sont utiles: <br><br><ul><li>  Matrices de données partagées (données en masse) - un moyen de stocker efficacement un grand nombre d'objets. </li><li>  Références (ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">poignées</a> ) faibles - un moyen d'accéder aux objets dans les données en masse sans que le programme se bloque si l'objet est supprimé. </li><li>  Les index sont un moyen d'accéder rapidement à des sous-ensembles individuels dans des données en masse. </li><li>  Les tableaux de tableaux sont un moyen de stocker des objets de données en vrac avec des tailles dynamiques. </li></ul><br>  Je vais consacrer plusieurs articles à la façon dont j'implémente habituellement toutes ces structures.  Commençons par les données en vrac les plus simples et les plus utiles. <a name="habracut"></a><br><br><h2>  Données en masse </h2><br>  Il n'y a pas de terme commun pour ce concept (ou je ne le connais pas).  J'appelle une « <em>masse de données</em> » toute grande collection d'objets similaires.  Par exemple, cela pourrait être: <br><br><ul><li>  Toutes les balles du jeu. </li><li>  Tous les arbres du jeu. </li><li>  Toutes les pièces du jeu. </li></ul><br>  Ou, si vous écrivez du code à un niveau d'abstraction plus élevé, cela pourrait être: <br><br><ul><li>  Toutes les entités du jeu. </li><li>  Toutes les mailles du jeu. </li><li>  Tous les sons du jeu. </li></ul><br>  En règle générale, chaque système (rendu, son, animation, physique, etc.) d'un jeu a deux types d'objets différents qu'il doit suivre.  Par exemple, pour un système audio, cela pourrait être: <br><br><ul><li>  Toutes les ressources sonores qui <em>peuvent être</em> jouées. </li><li>  Tous les sons en <em>cours de</em> lecture. </li><li>  Tous les effets (atténuation, changements de tonalité, etc.) appliqués aux sons. </li></ul><br>  Dans le cas de données en masse, je supposerai ce qui suit: <br><br><ul><li>  L'ordre de stockage des objets n'est pas important.  C'est-à-dire  nous percevons le tableau comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">autant d'</a> objets. </li><li> Chaque objet est représenté comme une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">structure de données simple (POD-struct) d'une</a> taille fixe qui peut être déplacée ou dupliquée à l'aide de <code>memcpy()</code> . </li></ul><br>  Bien sûr, vous pouvez trouver des situations dans lesquelles l'ordre est <em>important</em> .  Par exemple, si les objets désignent des éléments pour le rendu, avant le rendu, nous devrons peut-être les trier d'avant en arrière pour réduire la quantité de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">redessin</a> . <br><br>  Cependant, je pense que dans la plupart des cas, il est préférable de trier les données <em>telles qu’elles sont utilisées</em> , plutôt que de les stocker dans un conteneur trié, comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des arbres rouge-noir</a> ou des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">arbres</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">B.</a>  Par exemple, nous pouvons trier les objets rendus d'avant en arrière avant de les transmettre au moteur de rendu, ou trier les fichiers par ordre alphabétique avant de les afficher à l'écran sous forme de liste.  Le tri des données dans chaque trame peut sembler coûteux, mais dans de nombreux cas, cela se fait en <em>O (n) en</em> utilisant le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tri radix</a> . <br><br>  Comme j'utilise uniquement des structures de données simples, je préfère les objets C ++ aux objets C ++, car il est plus facile de comprendre ce qui se passe en mémoire et d'évaluer leurs performances.  Cependant, il existe des situations où vous devez stocker dans des données en vrac quelque chose qui n'a pas de taille fixe.  par exemple, le nom ou la liste des objets enfants.  Je parlerai de ces cas dans un article séparé, où nous examinerons les «tableaux de tableaux».  Pour l'instant, supposons que tous les objets sont de simples structures de données de taille fixe. <br><br>  Par exemple, voici à quoi ressembleront les structures de données en vrac pour notre système de son hypothétique: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">resource_t</span></span> *resource; <span class="hljs-comment"><span class="hljs-comment">// Resource manager data uint64_t bytes; // Size of data uint64_t format; // Data format identifier } sound_resource_t; typedef struct { sound_resource_t *resource; // Resource that's playing uint64_t samples_played; // Number of samples played float volume; // Volume of playing sound } playing_sound_t; typedef struct { playing_sound_t *sound; // Faded sound float fade_from; // Volume to fade from float fade_to; // Volume to fade to double fade_from_ts; // Time to start fade double fade_to_ts; // Time to end fade } playing_fade_t;</span></span></code> </pre> <br>  Lorsque nous envisageons des moyens de stocker des données en masse, nous devons considérer deux objectifs: <br><br><ul><li>  L'ajout et la suppression d'objets doivent être rapides. </li><li>  Les données doivent être placées sous une forme <strong>pratique pour la mise en cache</strong> , afin que vous puissiez rapidement les parcourir pour mettre à jour le système. </li><li>  Il doit prendre en charge <strong>le mécanisme de liaison</strong> - il doit exister un moyen de transmettre des informations <em>sur</em> des objets spécifiques dans des données en masse.  Dans l'exemple ci-dessus, le fondu devrait pouvoir spécifier le son atténué.  Dans l'exemple, j'ai écrit les liens sous forme de pointeurs, mais leur implémentation dépend de la façon dont les données en masse sont organisées. </li><li>  Les données doivent être <strong>conviviales pour les allocateurs</strong> - elles doivent utiliser plusieurs allocations de mémoire importantes et ne pas allouer d’objets individuels sur le tas. </li></ul><br>  Les deux façons les plus simples de représenter des données en masse sont un tableau statique ou un vecteur C ++: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Static array #define MAX_PLAYING_SOUNDS 1024 uint32_t num_playing_sounds; playing_sound_t playing_sounds[MAX_PLAYING_SOUNDS]; // C++ vector std::vector&lt;playing_sound_t&gt; playing_sounds;</span></span></code> </pre> <br>  Travailler avec un tableau est extrêmement simple, et cela peut très bien fonctionner pour vous si vous savez exactement combien d'objets sont nécessaires dans l'application.  Si vous ne le <em>savez pas</em> , alors gaspillez votre mémoire ou vous manquerez d'objets. <br><br>  Le vecteur <code>std::vector</code> est également une solution très digne et simple, mais ici, vous devez considérer certains aspects: <br><br><ul><li>  L'implémentation standard de <code>std::vector</code> de Visual Studio est lente en mode débogage en raison du débogage des itérateurs.  Ils doivent être définis sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">_ITERATOR_DEBUG_LEVEL = 0</a> . </li><li>  Pour créer et détruire des objets, <code>std::vector</code> utilise des constructeurs et des destructeurs, et dans certains cas, ils peuvent être beaucoup plus lents que <code>memcpy()</code> . </li><li>  <code>std::vector</code> beaucoup plus difficile à analyser que l'implémentation d'un simple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"tampon extensible"</a> . </li></ul><br>  De plus, sans mesures supplémentaires, ni les tableaux réguliers ni les vecteurs ne prennent en charge les références aux objets individuels.  Examinons ce sujet, ainsi que d'autres décisions de conception importantes impliquées dans la création du système de données en masse. <br><br><h2>  Stratégie de suppression </h2><br>  La première décision importante: que faire lors de la suppression de l'objet <code>a[i]</code> .  Voici trois options principales: <br><br><ul><li>  Vous pouvez déplacer tous les éléments suivants <code>a[i+1]</code> → <code>a[i]</code> , <code>a[i+2]</code> → <code>a[i+1]</code> , etc., pour fermer un emplacement vide. </li><li>  Vous pouvez déplacer le dernier élément du tableau vers un emplacement vide: <code>a[i] = a[n-1]</code> . </li><li>  Ou vous pouvez laisser l'emplacement vide en créant un trou dans le tableau.  Ce trou peut ensuite être utilisé pour placer un nouvel objet. </li></ul><br>  La première option est terrible - <em>O (n)</em> est dépensé pour le mouvement de tous ces éléments.  Le seul avantage de la première méthode est que si le tableau est trié, son ordre est préservé.  Mais comme mentionné ci-dessus, la commande ne nous dérange pas.  Notez que si vous utilisez <code>a.erase()</code> pour supprimer l'élément <code>std::vector</code> , c'est exactement ce qui se passera! <br><br>  La deuxième option est souvent appelée «swap-and-pop».  Pourquoi?  Parce que si vous utilisez un vecteur C ++, cette option est généralement implémentée en remplaçant (permutant) l'élément que vous souhaitez supprimer par le dernier, puis en supprimant ou en éclatant le dernier élément: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap(a[i], a[a.size() - <span class="hljs-number"><span class="hljs-number">1</span></span>]); a.pop_back();</code> </pre> <br>  Pourquoi tout cela est-il nécessaire?  En C ++, si nous <em>affectons</em> <code>a[i] = a[n-1]</code> , nous devons d'abord supprimer <code>a[i]</code> en appelant son destructeur, puis appeler le constructeur de copie pour créer une copie d' <code>a[n-1]</code> à la position <code>i</code> et enfin, nous appelons le destructeur <code>a[n-1]</code> lors du décalage du vecteur.  Si le constructeur de copie alloue de la mémoire et copie des données, cela peut être assez mauvais.  Si nous utilisons <code>std::swap</code> au lieu d'affectation, alors nous ne pouvons faire qu'avec le déplacement des constructeurs et ne devons pas allouer de mémoire. <br><br>  Encore une fois, c'est pourquoi C ++ je préfère les structures de données simples et les opérations C. C ++ a de nombreux pièges de performances dans lesquels vous pouvez tomber si vous ne savez pas ce qui se passe à l'intérieur.  En C, l'opération de swap-effacement sera très simple: <br><br><pre> <code class="cpp hljs">a.data[i] = a.data[--an];</code> </pre> <br>  Lors de l'utilisation de swap-and-pop, les objets restent bien emballés.  Pour placer un nouvel objet, attachez-le simplement à la fin du tableau. <br><br>  Si nous utilisons l'option «avec trous» I, lors du placement d'un nouvel objet, nous devons d'abord vérifier s'il existe des «trous» libres qui peuvent être utilisés.  Cela vaut la peine d'augmenter la taille du tableau uniquement lorsqu'il n'y a pas de «trous» libres.  Sinon, dans le processus de suppression et de création d'objets, il se développera indéfiniment. <br><br>  Vous pouvez utiliser un <code>std::vector&lt;uint32_t&gt;</code> pour suivre les positions des trous, mais il existe une meilleure solution qui ne nécessite pas de mémoire supplémentaire. <br><br>  Étant donné que les données de l'objet dans le «trou» ne sont utilisées pour rien, vous pouvez l'utiliser pour stocker un pointeur sur le trou libre suivant.  Ainsi, tous les trous du tableau forment une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">liste simplement connectée</a> , et si nécessaire, nous pouvons en ajouter et en supprimer des éléments. <br><br>  Ce type de structure de données, dans lequel la mémoire inutilisée est utilisée pour lier des éléments libres, est généralement appelé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une liste libre</a> . <br><br>  Dans une liste chaînée traditionnelle, un <em>élément d'en-tête de</em> liste spécial pointe vers le premier nœud de la liste et le dernier élément de la liste pointe vers NULL, ce qui signifie la fin de la liste.  Au lieu de cela, je préfère utiliser une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">liste liée circulaire</a> , dans laquelle l'en-tête n'est qu'un élément de liste spécial, et le dernier élément de liste pointe vers un élément de titre: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffe/fe0/a6b/ffefe0a6b6bd621b9362e84486db65e1.jpg" width="100%"></div><br>  <i>Listes traditionnelles et chaînées.</i> <br><br>  L'avantage de cette approche est que le code devient beaucoup plus simple en réduisant le nombre de cas spéciaux au début et à la fin de la liste. <br><br>  Notez que si vous utilisez <code>std::vector</code> pour stocker des objets, les pointeurs vers les objets changeront à chaque redistribution du vecteur.  Cela signifie que nous ne pouvons pas utiliser de pointeurs réguliers vers une liste liée, car les pointeurs changent constamment.  Pour contourner ce problème, vous pouvez utiliser des index comme «pointeurs» vers la liste liée, car l'index pointe constamment vers un emplacement spécifique même lors de la redistribution du tableau.  Nous parlerons davantage de réaffectation dans la section suivante. <br><br>  Vous pouvez allouer de l'espace pour un élément spécial du titre de la liste en le stockant toujours dans l'emplacement de tableau 0. <br><br>  Le code ressemblera à ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// The objects that we want to store: typedef struct {...} object_t; // An item in the free list points to the next one. typedef struct { uint32_t next_free; } freelist_item_t; // Each item holds either the object data or the free list pointer. typedef union { object_t; freelist_item_t; } item_t; typedef struct { std::vector&lt;item_t&gt; items; } bulk_data_t; void delete_item(bulk_data_t *bd, uint32_t i) { // Add to the freelist, which is stored in slot 0. bd-&gt;items[i].next = bd-&gt;items[0].next; bd-&gt;items[0].next = i; } uint32_t allocate_slot(bulk_data_t *bd) { const uint32_t slot = bd-&gt;items[0].next; bd-&gt;items[0].next = bd-&gt;items[slot].next; // If the freelist is empty, slot will be 0, because the header // item will point to itself. if (slot) return slot; bd-&gt;items.resize(bd-&gt;items.size() + 1); return bd-&gt;items.size() - 1; }</span></span></code> </pre> <br>  Quelle est la meilleure stratégie de suppression?  Déplacer le dernier élément dans un emplacement vide, assurer un emballage serré du tableau ou garder tous les éléments à leur place avec la création de «trous» dans le tableau à la place de l'élément supprimé? <br><br>  Lors de la prise de décision, deux aspects doivent être pris en compte: <br><br><ul><li>  L'itération sur une matrice dense est plus rapide car nous contournons moins de mémoire et nous n'avons pas à passer trop de temps à ignorer les emplacements vides. </li><li>  Si nous utilisons un tableau compact, les éléments se déplaceront.  Cela signifie que nous ne pouvons pas utiliser l'index d'un élément comme identificateur constant pour les références externes aux éléments.  Nous devrons attribuer un identifiant différent à chaque élément et utiliser la table de recherche pour faire correspondre ces ID constants avec les indices d'objet actuels.  Cette table de recherche peut être une table de hachage ou un <code>std::vector</code> avec des trous, comme décrit ci-dessus (la deuxième option est plus rapide).  Quoi qu'il en soit, nous aurons besoin de mémoire supplémentaire pour cette table et d'une étape indirecte supplémentaire pour les identifiants. </li></ul><br>  Le choix de la meilleure option dépend de votre projet. <br><br>  Vous pouvez dire que le stockage d'un tableau dense est préférable, car les itérations sur tous les éléments (pour mettre à jour le système) se produisent plus souvent que la correspondance de liens externes.  D'un autre côté, nous pouvons dire que les performances d'une «matrice avec trous» ne sont pires que dans le cas d'un grand nombre de trous, et dans le développement de jeux, nous nous soucions généralement des performances dans les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pires cas</a> (nous voulons avoir une fréquence d'images de 60 Hz, même lorsque les opérations maximales sont effectuées dans le jeu) .  Dans le pire des cas, nous avons le nombre maximum d'objets réels, et dans ce cas, <em>il n'y aura pas de trous</em> dans le tableau.  Les trous se produisent uniquement lorsque le nombre d'objets diminue, lorsque nous supprimons certains de ces objets. <br><br>  Il existe également des stratégies qui peuvent être utilisées pour accélérer le traitement des tableaux avec de nombreux trous.  Par exemple, nous pouvons suivre les longueurs de séquences continues de trous pour ignorer des séquences entières de trous à la fois, plutôt qu'élément par élément.  Étant donné que ces données ne sont nécessaires que pour les "trous", et non pour les éléments ordinaires, vous pouvez les stocker avec le pointeur de la liste des versions dans la mémoire non allouée des objets et ne pas gaspiller de mémoire supplémentaire. <br><br>  À mon avis, si vous n'avez pas besoin d'optimiser le code pour des itérations rapides, il est probablement préférable d'utiliser l'option «tableau avec trous».  C'est plus simple, ne nécessite pas de structures de recherche supplémentaires et vous pouvez utiliser l'index de l'objet comme ID, ce qui est très pratique.  De plus, le manque d'objets en mouvement élimine les éventuels bugs. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/781/6e3/91f/7816e391f0b8c68dede02d95dffa304f.jpg" width="100%"></div><br>  <i>Stratégies de suppression de données en masse.</i> <br><br><h2>  Pointeurs faibles </h2><br>  À titre de remarque, je dirai qu'il est facile d'implémenter la prise en charge des «pointeurs faibles» ou des «descripteurs» pour les objets de données en masse. <br><br>  <em>Un pointeur faible</em> est une référence à un objet qui peut en quelque sorte déterminer que l'objet auquel il se réfère a été supprimé.  Pratique dans les pointeurs faibles, ils vous permettent de supprimer des objets sans vous soucier de qui peut les référencer.  Sans pointeurs faibles pour supprimer un objet, nous aurions besoin de rechercher chaque lien individuel et de le déclarer invalide.  Cela peut être particulièrement difficile si les liens sont stockés dans du code de script, sur d'autres ordinateurs du réseau, etc. <br><br>  N'oubliez pas que nous avons déjà un identifiant qui identifie de manière unique <em>les</em> objets <em>existants</em> .  Dans l'option "avec trous", cet ID est simplement l'index de l'élément (car les éléments ne bougent jamais).  Dans le cas de tableaux densément compressés, cet index d'objet est un enregistrement dans le <em>tableau de recherche</em> . <br><br>  L'ID lui-même ne peut pas être utilisé comme pointeur faible, car les ID peuvent être réutilisés.  Si un élément est supprimé et qu'un nouvel élément est créé dans le même emplacement, nous ne serons pas en mesure de le déterminer par l'ID seul.  Pour obtenir un pointeur faible, vous devez combiner l'ID avec le champ de <code>generation</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> generation; } <span class="hljs-keyword"><span class="hljs-keyword">weak_pointer_t</span></span>;</code> </pre> <br>  Le champ de <code>generation</code> est un champ dans la structure de l'objet qui suit le nombre de fois où le slot du tableau de données en vrac a été réutilisé.  (Dans le cas d'un emballage serré, il garde une trace du nombre de fois où l'emplacement a été réutilisé dans le tableau de <em>recherche</em> .) <br><br>  Lorsque vous supprimez un élément, nous augmentons le nombre de génération dans son emplacement.  Pour vérifier si le pointeur faible est toujours valide, nous vérifions si la <code>generation</code> dans la structure du pointeur faible correspond à la génération du slot indiqué par son <code>id</code> .  S'ils correspondent, alors l'objet source que nous référençons existe toujours.  Sinon, cela signifie qu'il est supprimé et que l'emplacement est soit sur la liste des versions, soit a été réutilisé. <br><br>  Gardez à l'esprit que puisque le champ de <code>generation</code> est nécessaire pour les trous et les objets existants, vous devez le stocker en dehors de l'union: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> generation; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">object_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">freelist_item_t</span></span>; }; } <span class="hljs-keyword"><span class="hljs-keyword">item_t</span></span>;</code> </pre> <br><h2>  Stratégie de distribution </h2><br>  Si vous utilisez <code>std::vector</code> pour stocker les données des éléments, alors lorsque le tableau est plein et doit être augmenté, l'ensemble du tableau des éléments sera redistribué.  Les éléments existants sont copiés dans le nouveau tableau. <br><br>  <code>std::vector</code> croît <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>géométriquement</em></a> .  Cela signifie que chaque fois qu'un vecteur doit augmenter, le nombre d'éléments distribués est multiplié par un certain facteur (généralement par × 2).  La croissance géométrique (exponentielle) est importante car elle maintient les coûts d'augmentation de la matrice constants. <br><br>  Lors de la redistribution du tableau, nous devons déplacer tous les éléments, ce qui nécessite <em>O (n)</em> .  Cependant, à mesure que le tableau grandit, nous ajoutons de l'espace pour <em>n</em> autres éléments, car nous doublons la taille.  Cela signifie que nous n'aurons plus besoin d'augmenter le tableau jusqu'à ce que nous y ajoutions <em>n</em> éléments supplémentaires.  Autrement dit, les coûts d'augmentation sont égaux à <em>O (n)</em> , mais nous ne les exécutons que * O (n) * pour la nième fois d'écriture dans le tableau, c'est-à-dire qu'en moyenne, le coût d'écriture d'un élément est <em>O (n) / O (n) = O (1)</em> . <br><br>  Le coût d'enregistrement d'un élément est appelé la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>constante amortie</em></a> , car si vous calculez la moyenne de tous les enregistrements en cours d'exécution, les coûts seront fixes.  Cependant, il ne faut pas oublier qu'avant de faire la moyenne, les coûts s'avèrent très spasmodiques.  Après chaque enregistrement <em>O (n)</em> , nous obtenons un pic de hauteur <em>O (n)</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d0/331/5be/1d03315be5a0c1ad8096ac05f11c7893.jpg" width="100%"></div><br>  <i>Le coût d'écriture dans <code>std::vector</code> .</i> <br><br>  Voyons également ce qui se passe si nous n'utilisons pas de croissance géométrique.  Supposons qu'au lieu de doubler la mémoire pendant la croissance, nous allons simplement ajouter 128 autres emplacements.  Le déplacement des anciennes données nous coûte toujours <em>O (n)</em> , mais maintenant nous devons le faire tous les 128 éléments que nous ajoutons, c'est-à-dire que les coûts moyens seront désormais <em>O (n) / O (128) = O (n)</em> .  Le coût d'écriture d'un élément dans un tableau est proportionnel à la taille du tableau, donc lorsque le tableau devient grand, il commence à fonctionner à la vitesse d'une tortue.  Oups! <br><br>  La stratégie de distribution <code>std::vector</code> est une bonne option standard, fonctionnant bien dans la plupart des cas, mais elle a quelques problèmes: <br><br><ul><li>  Amortized Constant n'est pas bien adapté aux logiciels en temps réel.  Si vous disposez d'un très grand tableau, disons, des centaines de millions d'éléments, l'augmentation de ce tableau et le déplacement de tous les éléments peuvent entraîner un ralentissement notable de la fréquence d'images.  Ceci est problématique pour la même raison que la récupération de place est problématique dans les jeux.  Peu importe à quel point les coûts moyens sont faibles, si dans certains cadres, les coûts peuvent augmenter, provoquant des problèmes de jeu. </li><li>  De même, cette stratégie d'allocation dans le cas de grands tableaux peut gaspiller beaucoup de mémoire.  Disons que nous avons un tableau de 16 millions d'éléments et que nous devons en écrire un autre.  Cela fera passer la gamme à 32 millions.  Nous avons maintenant 16 millions d'éléments dans le tableau que nous n'utilisons pas.  Pour une plateforme à faible mémoire, c'est beaucoup. </li><li>  Enfin, la réallocation déplace les objets en mémoire, invalidant tous les pointeurs vers les objets.  Cela peut être une source de bugs difficiles à suivre. </li></ul><br>  Le code ci-dessous est un exemple de bogues pouvant survenir lors du déplacement d'objets: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Create two items and return the sum of their costs. float f(bulk_data_t *bd) { const uint32_t slot_1 = allocate_slot(bd); item_t *item_1 = &amp;bd-&gt;items[slot_1]; const uint32_t slot_2 = allocate_slot(bd); item_t *item_2 = &amp;bd-&gt;items[slot_2]; return item_1-&gt;cost + item_2-&gt;cost; }</span></span></code> </pre> <br>  Le problème ici est que la fonction <code>item_2</code> <code>allocate_slot()</code> peut avoir besoin de redistribuer le tableau pour créer de l'espace pour <code>item_2</code> .  Dans ce cas, l' <code>item_1</code> sera déplacé en mémoire et le pointeur vers l' <code>item_1</code> cessera d'être valide.  Dans ce cas particulier, nous pouvons éliminer l'erreur en déplaçant l' <code>item_1</code> affectation_1, mais des bogues similaires peuvent apparaître plus imperceptiblement.  Personnellement, ils m'ont mordu plusieurs fois. <br><br>  Une telle situation est perfide par le fait que le bogue ne sortira que lorsque le tableau sera redistribué exactement au moment où <code>slot_2</code> .  Le programme peut fonctionner correctement pendant longtemps jusqu'à ce que quelque chose change le modèle de distribution, après quoi le bogue fonctionnera. <br><br>  Tous ces problèmes peuvent être résolus en utilisant une stratégie de distribution différente.  Voici quelques options: <br><br><ul><li>       : 16, 32, 64, …,  <em></em>     . ,  16     ,  32   ,  .…     ,         <code>std::vector</code> . </li><li>           ,     .       ,       .               . ,           <em>O(n)</em>  <code>push()</code> ,        . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">       </a> ,      ,   ,     ,   . </li></ul><br> ,       .   ,   -       ,      ,       .      ,      ,          . <br><br>         ,      —       ?    ,       . ,     16  ,      16 ,       .   ,            ,           50 %.        . <br><br>   ,         <em> </em> ,           ,       .          *16 K * n*,  <em>n</em> —    bulk data  ,    ,        (      ). <br><br>        . -,         ,    <code>blocks\[i / elements_per_block\][i % elements_per_block]</code> . -,        ,      (heap allocator),   . <br><br>    ,         « »,  -       <code>std::vector</code> ,     ,    .         ,       ,          . <br><br> ,         ,     ID          .    ,        ,    .   ,   64  ,      32  (4   —  ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98e/f31/c3d/98ef31c3d3388db45f0897c9a390ce5d.jpg" width="100%"></div><br> <i> </i> <br><br><h2>      </h2><br>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> (Array of Structures, AoS)  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> (Structure of Arrays, SoA).     . ,      ,      , ,   : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> pos; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> vel; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> col; } <span class="hljs-keyword"><span class="hljs-keyword">particle_t</span></span>;</code> </pre> <br>           struct  .      « ».  : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> num_particles; <span class="hljs-keyword"><span class="hljs-keyword">particle_t</span></span> *particles;</code> </pre> <br> ,          . <br><br>     (SoA)        struct: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> num_particles; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *t; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> *pos; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> *vel; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> *col; } particles;</code> </pre> <br>   ,     ,  <code>vec3_t</code>     struct: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> num_particles; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *t; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *pos_x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *pos_y; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *pos_z; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *vel_x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *vel_y; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *vel_z; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *col_r; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *col_g; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *col_b; } particles;</code> </pre> <br>     ,     AoS,      ?       : <br><br><ul><li>       . ,  <code>tick()</code>    <code>t</code> .  <code>simulate_physics()</code>    <code>pos</code>  <code>vel</code> .   SoA       struct.   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> (     ),      . ,  <code>tick()</code>    1/10  ,  ,    10 . </li><li>  SoA        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SIMD</a>  .     ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FPU</a> .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AVX</a>       float  ,     8 . </li></ul><br>   ,     <code>tick()</code>   80 ?  Non.      10 ,      ,      , SIMD      . <br><br>   SoA: <br><br><ul><li>   . </li><li>    ,           . </li><li>           <code>particle_t *</code> ,         .      . </li><li>           ,            </li><li>             ( ),  <em></em>   .     <em>  </em> ,     . </li></ul><br>    ,      ,    struct   ,        VM (       ). -    10  struct       .   8- -,   ,          . ! <br><br>       —      SIMD.     : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> num_particles; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> position_x[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> position_y[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> position_z[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> velocity_x[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> velocity_y[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> velocity_z[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> color_r[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> color_g[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> color_b[<span class="hljs-number"><span class="hljs-number">8</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">eight_particles_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">eight_particles_t</span></span> *particles;</code> </pre> <br>     -    SIMD-     ,                  -,   .      ,            . <br><br>     <code>tick()</code>  32 ,  288 ,  32   ..  ,      10- ,       <code>t</code> . -, -    64 ,      ,     ,   5 .    ,    ,       -,   100%     . <br><br>    ,     . ,      <code>[16]</code> ,    float  - . ,       ,        ,   : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df8/7a2/558/df87a25586d4afb93a536585a84defef.png" width="100%"></div><br> <i>AoS  SoA.</i> <br><br>    ,  SoA —      « »,      SIMD     ,         (       «»). <br><br>   SIMD-  «»  ,    ,   ,    «» . ,   ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">     </a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> ,  .        <code>next</code>     ,   SIMD-  .      struct. <br><br>       ,      ,        ,    struct  .       ,  ,     . <br><br>  AoS  SoA,  ,              .      «»     AoS    SoA   ,   SIMD-, ,    .              . <br><br>       —    AoS     SoA   - . ,        AoS       SoA,   ,       AoS ( ).        ,     ,       . <br><br> ,        « ».    16-   ,    SoA,      .       scratch buffer  16  . <br><br><h2>  Conclusion </h2><br>        ,  « »    bulk data     : <br><br><blockquote>    «»   ,         VM (  ),       ( 16    ,     ). </blockquote><br>  ,        : <br><br><blockquote>     ,   8   SIMD         VM      . </blockquote><br>         . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr469861/">https://habr.com/ru/post/fr469861/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr469837/index.html">Première rencontre Flutter à Saint-Pétersbourg: reportages vidéo</a></li>
<li><a href="../fr469839/index.html">Vulnérabilité de spam dans Pikabu</a></li>
<li><a href="../fr469843/index.html">"Où sont ces jeunes punks qui nous essuieront de la surface de la terre?"</a></li>
<li><a href="../fr469855/index.html">Gradle + LLVM</a></li>
<li><a href="../fr469859/index.html">Pointeur et valeur sémantique pour déterminer le récepteur d'une méthode</a></li>
<li><a href="../fr469865/index.html">700 employés et plusieurs continents: comment Alconost a construit un modèle commercial sans officier</a></li>
<li><a href="../fr469869/index.html">Pourquoi vous devriez overclocker la RAM (c'est facile!)</a></li>
<li><a href="../fr469871/index.html">Quand les claviers étaient des tables</a></li>
<li><a href="../fr469875/index.html">Comment protéger vos mots de passe en 2019</a></li>
<li><a href="../fr469877/index.html">Oh cette méthode de Newton</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>