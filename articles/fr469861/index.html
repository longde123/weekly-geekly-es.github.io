<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ™‡ğŸ¿ ğŸ§“ âš”ï¸ Structures de donnÃ©es pour les programmeurs de jeux: donnÃ©es en masse ğŸ§‘ğŸ¼â€ğŸ¤â€ğŸ§‘ğŸ¼ ğŸ‘¨ğŸ»â€ğŸ­ ğŸš£ğŸ¿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tout programmeur bÃ©nÃ©ficiera d'une comprÃ©hension des diffÃ©rentes structures de donnÃ©es et de la maniÃ¨re d'analyser leurs performances. Mais dans la pr...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Structures de donnÃ©es pour les programmeurs de jeux: donnÃ©es en masse</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/469861/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/7e7/1d7/bb3/7e71d7bb314eaffe2d54f349cc854a5f.png" alt="image"></div><br>  Tout programmeur bÃ©nÃ©ficiera d'une comprÃ©hension des diffÃ©rentes <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">structures de donnÃ©es</a> et de la maniÃ¨re d'analyser leurs performances.  Mais dans la pratique, je n'ai jamais Ã©tÃ© utile pour <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les arbres AVL, les arbres</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">rouge-noir, les arbres</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">prÃ©fixes</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les listes Ã  sauter</a> , etc.  J'utilise certaines structures de donnÃ©es pour un seul algorithme spÃ©cifique et rien de plus (par exemple, des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tas</a> pour implÃ©menter une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">file d'attente prioritaire</a> dans <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">l'algorithme de recherche de chemin A *</a> ). <br><br>  Dans le travail quotidien, je fais habituellement avec Ã©tonnamment peu de structures de donnÃ©es.  Le plus souvent, ils me sont utiles: <br><br><ul><li>  Matrices de donnÃ©es partagÃ©es (donnÃ©es en masse) - un moyen de stocker efficacement un grand nombre d'objets. </li><li>  RÃ©fÃ©rences (ou <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">poignÃ©es</a> ) faibles - un moyen d'accÃ©der aux objets dans les donnÃ©es en masse sans que le programme se bloque si l'objet est supprimÃ©. </li><li>  Les index sont un moyen d'accÃ©der rapidement Ã  des sous-ensembles individuels dans des donnÃ©es en masse. </li><li>  Les tableaux de tableaux sont un moyen de stocker des objets de donnÃ©es en vrac avec des tailles dynamiques. </li></ul><br>  Je vais consacrer plusieurs articles Ã  la faÃ§on dont j'implÃ©mente habituellement toutes ces structures.  CommenÃ§ons par les donnÃ©es en vrac les plus simples et les plus utiles. <a name="habracut"></a><br><br><h2>  DonnÃ©es en masse </h2><br>  Il n'y a pas de terme commun pour ce concept (ou je ne le connais pas).  J'appelle une Â« <em>masse de donnÃ©es</em> Â» toute grande collection d'objets similaires.  Par exemple, cela pourrait Ãªtre: <br><br><ul><li>  Toutes les balles du jeu. </li><li>  Tous les arbres du jeu. </li><li>  Toutes les piÃ¨ces du jeu. </li></ul><br>  Ou, si vous Ã©crivez du code Ã  un niveau d'abstraction plus Ã©levÃ©, cela pourrait Ãªtre: <br><br><ul><li>  Toutes les entitÃ©s du jeu. </li><li>  Toutes les mailles du jeu. </li><li>  Tous les sons du jeu. </li></ul><br>  En rÃ¨gle gÃ©nÃ©rale, chaque systÃ¨me (rendu, son, animation, physique, etc.) d'un jeu a deux types d'objets diffÃ©rents qu'il doit suivre.  Par exemple, pour un systÃ¨me audio, cela pourrait Ãªtre: <br><br><ul><li>  Toutes les ressources sonores qui <em>peuvent Ãªtre</em> jouÃ©es. </li><li>  Tous les sons en <em>cours de</em> lecture. </li><li>  Tous les effets (attÃ©nuation, changements de tonalitÃ©, etc.) appliquÃ©s aux sons. </li></ul><br>  Dans le cas de donnÃ©es en masse, je supposerai ce qui suit: <br><br><ul><li>  L'ordre de stockage des objets n'est pas important.  C'est-Ã -dire  nous percevons le tableau comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">autant d'</a> objets. </li><li> Chaque objet est reprÃ©sentÃ© comme une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">structure de donnÃ©es simple (POD-struct) d'une</a> taille fixe qui peut Ãªtre dÃ©placÃ©e ou dupliquÃ©e Ã  l'aide de <code>memcpy()</code> . </li></ul><br>  Bien sÃ»r, vous pouvez trouver des situations dans lesquelles l'ordre est <em>important</em> .  Par exemple, si les objets dÃ©signent des Ã©lÃ©ments pour le rendu, avant le rendu, nous devrons peut-Ãªtre les trier d'avant en arriÃ¨re pour rÃ©duire la quantitÃ© de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">redessin</a> . <br><br>  Cependant, je pense que dans la plupart des cas, il est prÃ©fÃ©rable de trier les donnÃ©es <em>telles quâ€™elles sont utilisÃ©es</em> , plutÃ´t que de les stocker dans un conteneur triÃ©, comme <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">des arbres rouge-noir</a> ou des <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">arbres</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">B.</a>  Par exemple, nous pouvons trier les objets rendus d'avant en arriÃ¨re avant de les transmettre au moteur de rendu, ou trier les fichiers par ordre alphabÃ©tique avant de les afficher Ã  l'Ã©cran sous forme de liste.  Le tri des donnÃ©es dans chaque trame peut sembler coÃ»teux, mais dans de nombreux cas, cela se fait en <em>O (n) en</em> utilisant le <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tri radix</a> . <br><br>  Comme j'utilise uniquement des structures de donnÃ©es simples, je prÃ©fÃ¨re les objets C ++ aux objets C ++, car il est plus facile de comprendre ce qui se passe en mÃ©moire et d'Ã©valuer leurs performances.  Cependant, il existe des situations oÃ¹ vous devez stocker dans des donnÃ©es en vrac quelque chose qui n'a pas de taille fixe.  par exemple, le nom ou la liste des objets enfants.  Je parlerai de ces cas dans un article sÃ©parÃ©, oÃ¹ nous examinerons les Â«tableaux de tableauxÂ».  Pour l'instant, supposons que tous les objets sont de simples structures de donnÃ©es de taille fixe. <br><br>  Par exemple, voici Ã  quoi ressembleront les structures de donnÃ©es en vrac pour notre systÃ¨me de son hypothÃ©tique: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">resource_t</span></span> *resource; <span class="hljs-comment"><span class="hljs-comment">// Resource manager data uint64_t bytes; // Size of data uint64_t format; // Data format identifier } sound_resource_t; typedef struct { sound_resource_t *resource; // Resource that's playing uint64_t samples_played; // Number of samples played float volume; // Volume of playing sound } playing_sound_t; typedef struct { playing_sound_t *sound; // Faded sound float fade_from; // Volume to fade from float fade_to; // Volume to fade to double fade_from_ts; // Time to start fade double fade_to_ts; // Time to end fade } playing_fade_t;</span></span></code> </pre> <br>  Lorsque nous envisageons des moyens de stocker des donnÃ©es en masse, nous devons considÃ©rer deux objectifs: <br><br><ul><li>  L'ajout et la suppression d'objets doivent Ãªtre rapides. </li><li>  Les donnÃ©es doivent Ãªtre placÃ©es sous une forme <strong>pratique pour la mise en cache</strong> , afin que vous puissiez rapidement les parcourir pour mettre Ã  jour le systÃ¨me. </li><li>  Il doit prendre en charge <strong>le mÃ©canisme de liaison</strong> - il doit exister un moyen de transmettre des informations <em>sur</em> des objets spÃ©cifiques dans des donnÃ©es en masse.  Dans l'exemple ci-dessus, le fondu devrait pouvoir spÃ©cifier le son attÃ©nuÃ©.  Dans l'exemple, j'ai Ã©crit les liens sous forme de pointeurs, mais leur implÃ©mentation dÃ©pend de la faÃ§on dont les donnÃ©es en masse sont organisÃ©es. </li><li>  Les donnÃ©es doivent Ãªtre <strong>conviviales pour les allocateurs</strong> - elles doivent utiliser plusieurs allocations de mÃ©moire importantes et ne pas allouer dâ€™objets individuels sur le tas. </li></ul><br>  Les deux faÃ§ons les plus simples de reprÃ©senter des donnÃ©es en masse sont un tableau statique ou un vecteur C ++: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Static array #define MAX_PLAYING_SOUNDS 1024 uint32_t num_playing_sounds; playing_sound_t playing_sounds[MAX_PLAYING_SOUNDS]; // C++ vector std::vector&lt;playing_sound_t&gt; playing_sounds;</span></span></code> </pre> <br>  Travailler avec un tableau est extrÃªmement simple, et cela peut trÃ¨s bien fonctionner pour vous si vous savez exactement combien d'objets sont nÃ©cessaires dans l'application.  Si vous ne le <em>savez pas</em> , alors gaspillez votre mÃ©moire ou vous manquerez d'objets. <br><br>  Le vecteur <code>std::vector</code> est Ã©galement une solution trÃ¨s digne et simple, mais ici, vous devez considÃ©rer certains aspects: <br><br><ul><li>  L'implÃ©mentation standard de <code>std::vector</code> de Visual Studio est lente en mode dÃ©bogage en raison du dÃ©bogage des itÃ©rateurs.  Ils doivent Ãªtre dÃ©finis sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">_ITERATOR_DEBUG_LEVEL = 0</a> . </li><li>  Pour crÃ©er et dÃ©truire des objets, <code>std::vector</code> utilise des constructeurs et des destructeurs, et dans certains cas, ils peuvent Ãªtre beaucoup plus lents que <code>memcpy()</code> . </li><li>  <code>std::vector</code> beaucoup plus difficile Ã  analyser que l'implÃ©mentation d'un simple <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"tampon extensible"</a> . </li></ul><br>  De plus, sans mesures supplÃ©mentaires, ni les tableaux rÃ©guliers ni les vecteurs ne prennent en charge les rÃ©fÃ©rences aux objets individuels.  Examinons ce sujet, ainsi que d'autres dÃ©cisions de conception importantes impliquÃ©es dans la crÃ©ation du systÃ¨me de donnÃ©es en masse. <br><br><h2>  StratÃ©gie de suppression </h2><br>  La premiÃ¨re dÃ©cision importante: que faire lors de la suppression de l'objet <code>a[i]</code> .  Voici trois options principales: <br><br><ul><li>  Vous pouvez dÃ©placer tous les Ã©lÃ©ments suivants <code>a[i+1]</code> â†’ <code>a[i]</code> , <code>a[i+2]</code> â†’ <code>a[i+1]</code> , etc., pour fermer un emplacement vide. </li><li>  Vous pouvez dÃ©placer le dernier Ã©lÃ©ment du tableau vers un emplacement vide: <code>a[i] = a[n-1]</code> . </li><li>  Ou vous pouvez laisser l'emplacement vide en crÃ©ant un trou dans le tableau.  Ce trou peut ensuite Ãªtre utilisÃ© pour placer un nouvel objet. </li></ul><br>  La premiÃ¨re option est terrible - <em>O (n)</em> est dÃ©pensÃ© pour le mouvement de tous ces Ã©lÃ©ments.  Le seul avantage de la premiÃ¨re mÃ©thode est que si le tableau est triÃ©, son ordre est prÃ©servÃ©.  Mais comme mentionnÃ© ci-dessus, la commande ne nous dÃ©range pas.  Notez que si vous utilisez <code>a.erase()</code> pour supprimer l'Ã©lÃ©ment <code>std::vector</code> , c'est exactement ce qui se passera! <br><br>  La deuxiÃ¨me option est souvent appelÃ©e Â«swap-and-popÂ».  Pourquoi?  Parce que si vous utilisez un vecteur C ++, cette option est gÃ©nÃ©ralement implÃ©mentÃ©e en remplaÃ§ant (permutant) l'Ã©lÃ©ment que vous souhaitez supprimer par le dernier, puis en supprimant ou en Ã©clatant le dernier Ã©lÃ©ment: <br><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap(a[i], a[a.size() - <span class="hljs-number"><span class="hljs-number">1</span></span>]); a.pop_back();</code> </pre> <br>  Pourquoi tout cela est-il nÃ©cessaire?  En C ++, si nous <em>affectons</em> <code>a[i] = a[n-1]</code> , nous devons d'abord supprimer <code>a[i]</code> en appelant son destructeur, puis appeler le constructeur de copie pour crÃ©er une copie d' <code>a[n-1]</code> Ã  la position <code>i</code> et enfin, nous appelons le destructeur <code>a[n-1]</code> lors du dÃ©calage du vecteur.  Si le constructeur de copie alloue de la mÃ©moire et copie des donnÃ©es, cela peut Ãªtre assez mauvais.  Si nous utilisons <code>std::swap</code> au lieu d'affectation, alors nous ne pouvons faire qu'avec le dÃ©placement des constructeurs et ne devons pas allouer de mÃ©moire. <br><br>  Encore une fois, c'est pourquoi C ++ je prÃ©fÃ¨re les structures de donnÃ©es simples et les opÃ©rations C. C ++ a de nombreux piÃ¨ges de performances dans lesquels vous pouvez tomber si vous ne savez pas ce qui se passe Ã  l'intÃ©rieur.  En C, l'opÃ©ration de swap-effacement sera trÃ¨s simple: <br><br><pre> <code class="cpp hljs">a.data[i] = a.data[--an];</code> </pre> <br>  Lors de l'utilisation de swap-and-pop, les objets restent bien emballÃ©s.  Pour placer un nouvel objet, attachez-le simplement Ã  la fin du tableau. <br><br>  Si nous utilisons l'option Â«avec trousÂ» I, lors du placement d'un nouvel objet, nous devons d'abord vÃ©rifier s'il existe des Â«trousÂ» libres qui peuvent Ãªtre utilisÃ©s.  Cela vaut la peine d'augmenter la taille du tableau uniquement lorsqu'il n'y a pas de Â«trousÂ» libres.  Sinon, dans le processus de suppression et de crÃ©ation d'objets, il se dÃ©veloppera indÃ©finiment. <br><br>  Vous pouvez utiliser un <code>std::vector&lt;uint32_t&gt;</code> pour suivre les positions des trous, mais il existe une meilleure solution qui ne nÃ©cessite pas de mÃ©moire supplÃ©mentaire. <br><br>  Ã‰tant donnÃ© que les donnÃ©es de l'objet dans le Â«trouÂ» ne sont utilisÃ©es pour rien, vous pouvez l'utiliser pour stocker un pointeur sur le trou libre suivant.  Ainsi, tous les trous du tableau forment une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">liste simplement connectÃ©e</a> , et si nÃ©cessaire, nous pouvons en ajouter et en supprimer des Ã©lÃ©ments. <br><br>  Ce type de structure de donnÃ©es, dans lequel la mÃ©moire inutilisÃ©e est utilisÃ©e pour lier des Ã©lÃ©ments libres, est gÃ©nÃ©ralement appelÃ© <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">une liste libre</a> . <br><br>  Dans une liste chaÃ®nÃ©e traditionnelle, un <em>Ã©lÃ©ment d'en-tÃªte de</em> liste spÃ©cial pointe vers le premier nÅ“ud de la liste et le dernier Ã©lÃ©ment de la liste pointe vers NULL, ce qui signifie la fin de la liste.  Au lieu de cela, je prÃ©fÃ¨re utiliser une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">liste liÃ©e circulaire</a> , dans laquelle l'en-tÃªte n'est qu'un Ã©lÃ©ment de liste spÃ©cial, et le dernier Ã©lÃ©ment de liste pointe vers un Ã©lÃ©ment de titre: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/ffe/fe0/a6b/ffefe0a6b6bd621b9362e84486db65e1.jpg" width="100%"></div><br>  <i>Listes traditionnelles et chaÃ®nÃ©es.</i> <br><br>  L'avantage de cette approche est que le code devient beaucoup plus simple en rÃ©duisant le nombre de cas spÃ©ciaux au dÃ©but et Ã  la fin de la liste. <br><br>  Notez que si vous utilisez <code>std::vector</code> pour stocker des objets, les pointeurs vers les objets changeront Ã  chaque redistribution du vecteur.  Cela signifie que nous ne pouvons pas utiliser de pointeurs rÃ©guliers vers une liste liÃ©e, car les pointeurs changent constamment.  Pour contourner ce problÃ¨me, vous pouvez utiliser des index comme Â«pointeursÂ» vers la liste liÃ©e, car l'index pointe constamment vers un emplacement spÃ©cifique mÃªme lors de la redistribution du tableau.  Nous parlerons davantage de rÃ©affectation dans la section suivante. <br><br>  Vous pouvez allouer de l'espace pour un Ã©lÃ©ment spÃ©cial du titre de la liste en le stockant toujours dans l'emplacement de tableau 0. <br><br>  Le code ressemblera Ã  ceci: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// The objects that we want to store: typedef struct {...} object_t; // An item in the free list points to the next one. typedef struct { uint32_t next_free; } freelist_item_t; // Each item holds either the object data or the free list pointer. typedef union { object_t; freelist_item_t; } item_t; typedef struct { std::vector&lt;item_t&gt; items; } bulk_data_t; void delete_item(bulk_data_t *bd, uint32_t i) { // Add to the freelist, which is stored in slot 0. bd-&gt;items[i].next = bd-&gt;items[0].next; bd-&gt;items[0].next = i; } uint32_t allocate_slot(bulk_data_t *bd) { const uint32_t slot = bd-&gt;items[0].next; bd-&gt;items[0].next = bd-&gt;items[slot].next; // If the freelist is empty, slot will be 0, because the header // item will point to itself. if (slot) return slot; bd-&gt;items.resize(bd-&gt;items.size() + 1); return bd-&gt;items.size() - 1; }</span></span></code> </pre> <br>  Quelle est la meilleure stratÃ©gie de suppression?  DÃ©placer le dernier Ã©lÃ©ment dans un emplacement vide, assurer un emballage serrÃ© du tableau ou garder tous les Ã©lÃ©ments Ã  leur place avec la crÃ©ation de Â«trousÂ» dans le tableau Ã  la place de l'Ã©lÃ©ment supprimÃ©? <br><br>  Lors de la prise de dÃ©cision, deux aspects doivent Ãªtre pris en compte: <br><br><ul><li>  L'itÃ©ration sur une matrice dense est plus rapide car nous contournons moins de mÃ©moire et nous n'avons pas Ã  passer trop de temps Ã  ignorer les emplacements vides. </li><li>  Si nous utilisons un tableau compact, les Ã©lÃ©ments se dÃ©placeront.  Cela signifie que nous ne pouvons pas utiliser l'index d'un Ã©lÃ©ment comme identificateur constant pour les rÃ©fÃ©rences externes aux Ã©lÃ©ments.  Nous devrons attribuer un identifiant diffÃ©rent Ã  chaque Ã©lÃ©ment et utiliser la table de recherche pour faire correspondre ces ID constants avec les indices d'objet actuels.  Cette table de recherche peut Ãªtre une table de hachage ou un <code>std::vector</code> avec des trous, comme dÃ©crit ci-dessus (la deuxiÃ¨me option est plus rapide).  Quoi qu'il en soit, nous aurons besoin de mÃ©moire supplÃ©mentaire pour cette table et d'une Ã©tape indirecte supplÃ©mentaire pour les identifiants. </li></ul><br>  Le choix de la meilleure option dÃ©pend de votre projet. <br><br>  Vous pouvez dire que le stockage d'un tableau dense est prÃ©fÃ©rable, car les itÃ©rations sur tous les Ã©lÃ©ments (pour mettre Ã  jour le systÃ¨me) se produisent plus souvent que la correspondance de liens externes.  D'un autre cÃ´tÃ©, nous pouvons dire que les performances d'une Â«matrice avec trousÂ» ne sont pires que dans le cas d'un grand nombre de trous, et dans le dÃ©veloppement de jeux, nous nous soucions gÃ©nÃ©ralement des performances dans les <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">pires cas</a> (nous voulons avoir une frÃ©quence d'images de 60 Hz, mÃªme lorsque les opÃ©rations maximales sont effectuÃ©es dans le jeu) .  Dans le pire des cas, nous avons le nombre maximum d'objets rÃ©els, et dans ce cas, <em>il n'y aura pas de trous</em> dans le tableau.  Les trous se produisent uniquement lorsque le nombre d'objets diminue, lorsque nous supprimons certains de ces objets. <br><br>  Il existe Ã©galement des stratÃ©gies qui peuvent Ãªtre utilisÃ©es pour accÃ©lÃ©rer le traitement des tableaux avec de nombreux trous.  Par exemple, nous pouvons suivre les longueurs de sÃ©quences continues de trous pour ignorer des sÃ©quences entiÃ¨res de trous Ã  la fois, plutÃ´t qu'Ã©lÃ©ment par Ã©lÃ©ment.  Ã‰tant donnÃ© que ces donnÃ©es ne sont nÃ©cessaires que pour les "trous", et non pour les Ã©lÃ©ments ordinaires, vous pouvez les stocker avec le pointeur de la liste des versions dans la mÃ©moire non allouÃ©e des objets et ne pas gaspiller de mÃ©moire supplÃ©mentaire. <br><br>  Ã€ mon avis, si vous n'avez pas besoin d'optimiser le code pour des itÃ©rations rapides, il est probablement prÃ©fÃ©rable d'utiliser l'option Â«tableau avec trousÂ».  C'est plus simple, ne nÃ©cessite pas de structures de recherche supplÃ©mentaires et vous pouvez utiliser l'index de l'objet comme ID, ce qui est trÃ¨s pratique.  De plus, le manque d'objets en mouvement Ã©limine les Ã©ventuels bugs. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/781/6e3/91f/7816e391f0b8c68dede02d95dffa304f.jpg" width="100%"></div><br>  <i>StratÃ©gies de suppression de donnÃ©es en masse.</i> <br><br><h2>  Pointeurs faibles </h2><br>  Ã€ titre de remarque, je dirai qu'il est facile d'implÃ©menter la prise en charge des Â«pointeurs faiblesÂ» ou des Â«descripteursÂ» pour les objets de donnÃ©es en masse. <br><br>  <em>Un pointeur faible</em> est une rÃ©fÃ©rence Ã  un objet qui peut en quelque sorte dÃ©terminer que l'objet auquel il se rÃ©fÃ¨re a Ã©tÃ© supprimÃ©.  Pratique dans les pointeurs faibles, ils vous permettent de supprimer des objets sans vous soucier de qui peut les rÃ©fÃ©rencer.  Sans pointeurs faibles pour supprimer un objet, nous aurions besoin de rechercher chaque lien individuel et de le dÃ©clarer invalide.  Cela peut Ãªtre particuliÃ¨rement difficile si les liens sont stockÃ©s dans du code de script, sur d'autres ordinateurs du rÃ©seau, etc. <br><br>  N'oubliez pas que nous avons dÃ©jÃ  un identifiant qui identifie de maniÃ¨re unique <em>les</em> objets <em>existants</em> .  Dans l'option "avec trous", cet ID est simplement l'index de l'Ã©lÃ©ment (car les Ã©lÃ©ments ne bougent jamais).  Dans le cas de tableaux densÃ©ment compressÃ©s, cet index d'objet est un enregistrement dans le <em>tableau de recherche</em> . <br><br>  L'ID lui-mÃªme ne peut pas Ãªtre utilisÃ© comme pointeur faible, car les ID peuvent Ãªtre rÃ©utilisÃ©s.  Si un Ã©lÃ©ment est supprimÃ© et qu'un nouvel Ã©lÃ©ment est crÃ©Ã© dans le mÃªme emplacement, nous ne serons pas en mesure de le dÃ©terminer par l'ID seul.  Pour obtenir un pointeur faible, vous devez combiner l'ID avec le champ de <code>generation</code> : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> id; <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> generation; } <span class="hljs-keyword"><span class="hljs-keyword">weak_pointer_t</span></span>;</code> </pre> <br>  Le champ de <code>generation</code> est un champ dans la structure de l'objet qui suit le nombre de fois oÃ¹ le slot du tableau de donnÃ©es en vrac a Ã©tÃ© rÃ©utilisÃ©.  (Dans le cas d'un emballage serrÃ©, il garde une trace du nombre de fois oÃ¹ l'emplacement a Ã©tÃ© rÃ©utilisÃ© dans le tableau de <em>recherche</em> .) <br><br>  Lorsque vous supprimez un Ã©lÃ©ment, nous augmentons le nombre de gÃ©nÃ©ration dans son emplacement.  Pour vÃ©rifier si le pointeur faible est toujours valide, nous vÃ©rifions si la <code>generation</code> dans la structure du pointeur faible correspond Ã  la gÃ©nÃ©ration du slot indiquÃ© par son <code>id</code> .  S'ils correspondent, alors l'objet source que nous rÃ©fÃ©renÃ§ons existe toujours.  Sinon, cela signifie qu'il est supprimÃ© et que l'emplacement est soit sur la liste des versions, soit a Ã©tÃ© rÃ©utilisÃ©. <br><br>  Gardez Ã  l'esprit que puisque le champ de <code>generation</code> est nÃ©cessaire pour les trous et les objets existants, vous devez le stocker en dehors de l'union: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> generation; <span class="hljs-keyword"><span class="hljs-keyword">union</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">object_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">freelist_item_t</span></span>; }; } <span class="hljs-keyword"><span class="hljs-keyword">item_t</span></span>;</code> </pre> <br><h2>  StratÃ©gie de distribution </h2><br>  Si vous utilisez <code>std::vector</code> pour stocker les donnÃ©es des Ã©lÃ©ments, alors lorsque le tableau est plein et doit Ãªtre augmentÃ©, l'ensemble du tableau des Ã©lÃ©ments sera redistribuÃ©.  Les Ã©lÃ©ments existants sont copiÃ©s dans le nouveau tableau. <br><br>  <code>std::vector</code> croÃ®t <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>gÃ©omÃ©triquement</em></a> .  Cela signifie que chaque fois qu'un vecteur doit augmenter, le nombre d'Ã©lÃ©ments distribuÃ©s est multipliÃ© par un certain facteur (gÃ©nÃ©ralement par Ã— 2).  La croissance gÃ©omÃ©trique (exponentielle) est importante car elle maintient les coÃ»ts d'augmentation de la matrice constants. <br><br>  Lors de la redistribution du tableau, nous devons dÃ©placer tous les Ã©lÃ©ments, ce qui nÃ©cessite <em>O (n)</em> .  Cependant, Ã  mesure que le tableau grandit, nous ajoutons de l'espace pour <em>n</em> autres Ã©lÃ©ments, car nous doublons la taille.  Cela signifie que nous n'aurons plus besoin d'augmenter le tableau jusqu'Ã  ce que nous y ajoutions <em>n</em> Ã©lÃ©ments supplÃ©mentaires.  Autrement dit, les coÃ»ts d'augmentation sont Ã©gaux Ã  <em>O (n)</em> , mais nous ne les exÃ©cutons que * O (n) * pour la niÃ¨me fois d'Ã©criture dans le tableau, c'est-Ã -dire qu'en moyenne, le coÃ»t d'Ã©criture d'un Ã©lÃ©ment est <em>O (n) / O (n) = O (1)</em> . <br><br>  Le coÃ»t d'enregistrement d'un Ã©lÃ©ment est appelÃ© la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="><em>constante amortie</em></a> , car si vous calculez la moyenne de tous les enregistrements en cours d'exÃ©cution, les coÃ»ts seront fixes.  Cependant, il ne faut pas oublier qu'avant de faire la moyenne, les coÃ»ts s'avÃ¨rent trÃ¨s spasmodiques.  AprÃ¨s chaque enregistrement <em>O (n)</em> , nous obtenons un pic de hauteur <em>O (n)</em> : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d0/331/5be/1d03315be5a0c1ad8096ac05f11c7893.jpg" width="100%"></div><br>  <i>Le coÃ»t d'Ã©criture dans <code>std::vector</code> .</i> <br><br>  Voyons Ã©galement ce qui se passe si nous n'utilisons pas de croissance gÃ©omÃ©trique.  Supposons qu'au lieu de doubler la mÃ©moire pendant la croissance, nous allons simplement ajouter 128 autres emplacements.  Le dÃ©placement des anciennes donnÃ©es nous coÃ»te toujours <em>O (n)</em> , mais maintenant nous devons le faire tous les 128 Ã©lÃ©ments que nous ajoutons, c'est-Ã -dire que les coÃ»ts moyens seront dÃ©sormais <em>O (n) / O (128) = O (n)</em> .  Le coÃ»t d'Ã©criture d'un Ã©lÃ©ment dans un tableau est proportionnel Ã  la taille du tableau, donc lorsque le tableau devient grand, il commence Ã  fonctionner Ã  la vitesse d'une tortue.  Oups! <br><br>  La stratÃ©gie de distribution <code>std::vector</code> est une bonne option standard, fonctionnant bien dans la plupart des cas, mais elle a quelques problÃ¨mes: <br><br><ul><li>  Amortized Constant n'est pas bien adaptÃ© aux logiciels en temps rÃ©el.  Si vous disposez d'un trÃ¨s grand tableau, disons, des centaines de millions d'Ã©lÃ©ments, l'augmentation de ce tableau et le dÃ©placement de tous les Ã©lÃ©ments peuvent entraÃ®ner un ralentissement notable de la frÃ©quence d'images.  Ceci est problÃ©matique pour la mÃªme raison que la rÃ©cupÃ©ration de place est problÃ©matique dans les jeux.  Peu importe Ã  quel point les coÃ»ts moyens sont faibles, si dans certains cadres, les coÃ»ts peuvent augmenter, provoquant des problÃ¨mes de jeu. </li><li>  De mÃªme, cette stratÃ©gie d'allocation dans le cas de grands tableaux peut gaspiller beaucoup de mÃ©moire.  Disons que nous avons un tableau de 16 millions d'Ã©lÃ©ments et que nous devons en Ã©crire un autre.  Cela fera passer la gamme Ã  32 millions.  Nous avons maintenant 16 millions d'Ã©lÃ©ments dans le tableau que nous n'utilisons pas.  Pour une plateforme Ã  faible mÃ©moire, c'est beaucoup. </li><li>  Enfin, la rÃ©allocation dÃ©place les objets en mÃ©moire, invalidant tous les pointeurs vers les objets.  Cela peut Ãªtre une source de bugs difficiles Ã  suivre. </li></ul><br>  Le code ci-dessous est un exemple de bogues pouvant survenir lors du dÃ©placement d'objets: <br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Create two items and return the sum of their costs. float f(bulk_data_t *bd) { const uint32_t slot_1 = allocate_slot(bd); item_t *item_1 = &amp;bd-&gt;items[slot_1]; const uint32_t slot_2 = allocate_slot(bd); item_t *item_2 = &amp;bd-&gt;items[slot_2]; return item_1-&gt;cost + item_2-&gt;cost; }</span></span></code> </pre> <br>  Le problÃ¨me ici est que la fonction <code>item_2</code> <code>allocate_slot()</code> peut avoir besoin de redistribuer le tableau pour crÃ©er de l'espace pour <code>item_2</code> .  Dans ce cas, l' <code>item_1</code> sera dÃ©placÃ© en mÃ©moire et le pointeur vers l' <code>item_1</code> cessera d'Ãªtre valide.  Dans ce cas particulier, nous pouvons Ã©liminer l'erreur en dÃ©plaÃ§ant l' <code>item_1</code> affectation_1, mais des bogues similaires peuvent apparaÃ®tre plus imperceptiblement.  Personnellement, ils m'ont mordu plusieurs fois. <br><br>  Une telle situation est perfide par le fait que le bogue ne sortira que lorsque le tableau sera redistribuÃ© exactement au moment oÃ¹ <code>slot_2</code> .  Le programme peut fonctionner correctement pendant longtemps jusqu'Ã  ce que quelque chose change le modÃ¨le de distribution, aprÃ¨s quoi le bogue fonctionnera. <br><br>  Tous ces problÃ¨mes peuvent Ãªtre rÃ©solus en utilisant une stratÃ©gie de distribution diffÃ©rente.  Voici quelques options: <br><br><ul><li>       : 16, 32, 64, â€¦,  <em></em>     . ,  16     ,  32   ,  .â€¦     ,         <code>std::vector</code> . </li><li>           ,     .       ,       .               . ,           <em>O(n)</em>  <code>push()</code> ,        . </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">       </a> ,      ,   ,     ,   . </li></ul><br> ,       .   ,   -       ,      ,       .      ,      ,          . <br><br>         ,      â€”       ?    ,       . ,     16  ,      16 ,       .   ,            ,           50 %.        . <br><br>   ,         <em> </em> ,           ,       .          *16 K * n*,  <em>n</em> â€”    bulk data  ,    ,        (      ). <br><br>        . -,         ,    <code>blocks\[i / elements_per_block\][i % elements_per_block]</code> . -,        ,      (heap allocator),   . <br><br>    ,         Â« Â»,  -       <code>std::vector</code> ,     ,    .         ,       ,          . <br><br> ,         ,     ID          .    ,        ,    .   ,   64  ,      32  (4   â€”  ). <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/98e/f31/c3d/98ef31c3d3388db45f0897c9a390ce5d.jpg" width="100%"></div><br> <i> </i> <br><br><h2>      </h2><br>         <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> (Array of Structures, AoS)  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> (Structure of Arrays, SoA).     . ,      ,      , ,   : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> pos; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> vel; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> col; } <span class="hljs-keyword"><span class="hljs-keyword">particle_t</span></span>;</code> </pre> <br>           struct  .      Â« Â».  : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> num_particles; <span class="hljs-keyword"><span class="hljs-keyword">particle_t</span></span> *particles;</code> </pre> <br> ,          . <br><br>     (SoA)        struct: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> num_particles; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *t; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> *pos; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> *vel; <span class="hljs-keyword"><span class="hljs-keyword">vec3_t</span></span> *col; } particles;</code> </pre> <br>   ,     ,  <code>vec3_t</code>     struct: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> num_particles; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *t; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *pos_x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *pos_y; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *pos_z; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *vel_x; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *vel_y; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *vel_z; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *col_r; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *col_g; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> *col_b; } particles;</code> </pre> <br>     ,     AoS,      ?       : <br><br><ul><li>       . ,  <code>tick()</code>    <code>t</code> .  <code>simulate_physics()</code>    <code>pos</code>  <code>vel</code> .   SoA       struct.   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> (     ),      . ,  <code>tick()</code>    1/10  ,  ,    10 . </li><li>  SoA        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SIMD</a>  .     ,    <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">FPU</a> .   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">AVX</a>       float  ,     8 . </li></ul><br>   ,     <code>tick()</code>   80 ?  Non.      10 ,      ,      , SIMD      . <br><br>   SoA: <br><br><ul><li>   . </li><li>    ,           . </li><li>           <code>particle_t *</code> ,         .      . </li><li>           ,            </li><li>             ( ),  <em></em>   .     <em>  </em> ,     . </li></ul><br>    ,      ,    struct   ,        VM (       ). -    10  struct       .   8- -,   ,          . ! <br><br>       â€”      SIMD.     : <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">uint32_t</span></span> num_particles; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> t[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> position_x[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> position_y[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> position_z[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> velocity_x[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> velocity_y[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> velocity_z[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> color_r[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> color_g[<span class="hljs-number"><span class="hljs-number">8</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> color_b[<span class="hljs-number"><span class="hljs-number">8</span></span>]; } <span class="hljs-keyword"><span class="hljs-keyword">eight_particles_t</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">eight_particles_t</span></span> *particles;</code> </pre> <br>     -    SIMD-     ,                  -,   .      ,            . <br><br>     <code>tick()</code>  32 ,  288 ,  32   ..  ,      10- ,       <code>t</code> . -, -    64 ,      ,     ,   5 .    ,    ,       -,   100%     . <br><br>    ,     . ,      <code>[16]</code> ,    float  - . ,       ,        ,   : <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/df8/7a2/558/df87a25586d4afb93a536585a84defef.png" width="100%"></div><br> <i>AoS  SoA.</i> <br><br>    ,  SoA â€”      Â« Â»,      SIMD     ,         (       Â«Â»). <br><br>   SIMD-  Â«Â»  ,    ,   ,    Â«Â» . ,   ,       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">     </a>   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u="> </a> ,  .        <code>next</code>     ,   SIMD-  .      struct. <br><br>       ,      ,        ,    struct  .       ,  ,     . <br><br>  AoS  SoA,  ,              .      Â«Â»     AoS    SoA   ,   SIMD-, ,    .              . <br><br>       â€”    AoS     SoA   - . ,        AoS       SoA,   ,       AoS ( ).        ,     ,       . <br><br> ,        Â« Â».    16-   ,    SoA,      .       scratch buffer  16  . <br><br><h2>  Conclusion </h2><br>        ,  Â« Â»    bulk data     : <br><br><blockquote>    Â«Â»   ,         VM (  ),       ( 16    ,     ). </blockquote><br>  ,        : <br><br><blockquote>     ,   8   SIMD         VM      . </blockquote><br>         . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr469861/">https://habr.com/ru/post/fr469861/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr469837/index.html">PremiÃ¨re rencontre Flutter Ã  Saint-PÃ©tersbourg: reportages vidÃ©o</a></li>
<li><a href="../fr469839/index.html">VulnÃ©rabilitÃ© de spam dans Pikabu</a></li>
<li><a href="../fr469843/index.html">"OÃ¹ sont ces jeunes punks qui nous essuieront de la surface de la terre?"</a></li>
<li><a href="../fr469855/index.html">Gradle + LLVM</a></li>
<li><a href="../fr469859/index.html">Pointeur et valeur sÃ©mantique pour dÃ©terminer le rÃ©cepteur d'une mÃ©thode</a></li>
<li><a href="../fr469865/index.html">700 employÃ©s et plusieurs continents: comment Alconost a construit un modÃ¨le commercial sans officier</a></li>
<li><a href="../fr469869/index.html">Pourquoi vous devriez overclocker la RAM (c'est facile!)</a></li>
<li><a href="../fr469871/index.html">Quand les claviers Ã©taient des tables</a></li>
<li><a href="../fr469875/index.html">Comment protÃ©ger vos mots de passe en 2019</a></li>
<li><a href="../fr469877/index.html">Oh cette mÃ©thode de Newton</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>