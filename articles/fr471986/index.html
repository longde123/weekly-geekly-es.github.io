<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üì• ‚úçüèª üßëüèæ‚Äçü§ù‚Äçüßëüèª Grammaire r√©cursive gauche du PEG ‚ôêÔ∏è üëÖ üë®üèΩ‚Äçüöí</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="J'ai mentionn√© la r√©currence gauche comme une pierre d'achoppement √† plusieurs reprises, et il est temps de le comprendre. Le probl√®me principal est q...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Grammaire r√©cursive gauche du PEG</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/471986/"><p>  J'ai mentionn√© la r√©currence gauche comme une pierre d'achoppement √† plusieurs reprises, et il est temps de le comprendre.  Le probl√®me principal est qu'un analyseur avec une descente r√©cursive gauche se bloque instantan√©ment en raison d'un d√©bordement de pile. </p><br><div class="spoiler">  <b class="spoiler_title">Contenu de la s√©rie Python PEG Parser</b> <div class="spoiler_text"><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Analyseurs de cheville</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Impl√©mentation de l'analyseur PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">G√©n√©ration de l'analyseur PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Visualisation de l'analyseur PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Grammaire r√©cursive gauche du PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Ajout d'actions √† la grammaire PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">M√©ta grammaire pour l'analyseur PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Impl√©mentation des fonctionnalit√©s restantes de PEG</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">PEG sur Core Developer Sprint</a> </li></ul></div></div><br><p>  Consid√©rez cette r√®gle de grammaire hypoth√©tique: </p><br><pre><code class="plaintext hljs">expr: expr '+' term | term</code> </pre> <a name="habracut"></a><br><p>  Si nous impl√©mentions ce morceau de grammaire dans la m√©thode de l'analyseur r√©cursif gauche, nous obtiendrions quelque chose comme ceci: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> expr() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> expect(<span class="hljs-string"><span class="hljs-string">'+'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p>  Ainsi, <code>expr()</code> commence par un appel √† <code>expr()</code> , qui commence par un appel √† <code>expr()</code> , qui commence par un appel ... Cela ne peut se terminer qu'avec un d√©bordement de pile, exprim√© comme une exception <code>RecursionError</code> . </p><br><p>  La solution traditionnelle consiste √† r√©√©crire la grammaire.  Dans les parties pr√©c√©dentes, c'est exactement ce que j'ai fait.  En fait, la r√®gle de grammaire ci-dessus peut √™tre r√©√©crite comme suit: </p><br><pre> <code class="plaintext hljs">expr: term '+' expr | term</code> </pre> <br><p>  Cependant, √† l'√©tape de la construction de l'arbre d'analyse, sa forme serait diff√©rente.  Cela pourrait ruiner la situation si nous ajoutions l'op√©rateur <code>'-'</code> √† la grammaire (puisque <code>a - (b - c)</code> pas identique √† <code>(a - b) - c</code> ).  Cela est g√©n√©ralement r√©solu avec des fonctions PEG plus puissantes, telles que le regroupement et l'it√©ration, et nous pourrions r√©√©crire la r√®gle ci-dessus comme suit: </p><br><pre> <code class="plaintext hljs">expr: term ('+' term)*</code> </pre> <br><p>  En fait, c'est exactement comme cela que la grammaire Python actuelle est √©crite pour l'analyseur pgen (qui a les m√™mes probl√®mes avec les r√®gles r√©cursives gauches). </p><br><p>  Cependant, il y a un petit probl√®me: puisque les op√©rateurs comme <code>'+'</code> et <code>'-'</code> (en Python) sont principalement binaires, lorsque nous analysons quelque chose comme <code>a + b + c</code> , nous devons passer par le r√©sultat de l'analyse (qui essentiellement une liste de <code>['a', '+', 'b', '+', 'c']</code> ) pour cr√©er un arbre d'analyse r√©cursive √† gauche (qui ressemblerait √† quelque chose comme ceci <code>[['a', '+', 'b'] , '+', 'c']</code> ). </p><br><p>  La grammaire r√©cursive gauche d'origine fait d√©j√† allusion √† l'associativit√© souhait√©e, il serait donc bien de g√©n√©rer un analyseur directement √† partir de ce formulaire.  Et nous le pouvons!  Un lecteur a soulign√© une bonne astuce avec une preuve math√©matique facile √† mettre en ≈ìuvre.  Maintenant, je vais essayer d'expliquer. </p><br><p>  Regardons un exemple d'entr√©e <code>foo + bar + baz</code> .  L'arbre d'analyse que nous aimerions obtenir correspond √† <code>(foo + bar) + baz</code> .  Cela n√©cessite trois appels r√©cursifs √† gauche √† la fonction <code>expr()</code> : l'un correspond √† l'op√©rateur de niveau sup√©rieur <code>'+'</code> (c'est-√†-dire le second);  un de plus - √† l'op√©rateur interne <code>'+'</code> (c'est-√†-dire le premier);  et la troisi√®me est le choix de la deuxi√®me alternative (c'est- <code>term</code> dire le <code>term</code> ). </p><br><p>  Comme je ne suis pas bon pour dessiner de vrais diagrammes √† l'aide d'outils sp√©ciaux, je vais le montrer ici en utilisant l'art ASCII: </p><br><pre> <code class="plaintext hljs">expr------------+------+ | \ \ expr--+------+ '+' term | \ \ | expr '+' term | | | | term | | | | | 'foo' 'bar' 'baz'</code> </pre> <br><p>  L'id√©e est que dans la fonction <code>expr()</code> , nous avons besoin d'un ¬´oracle¬ª qui nous indique s'il faut choisir la premi√®re alternative (c'est-√†-dire l'appel r√©cursif √† <code>expr()</code> ) ou la seconde (c'est-√†-dire l'appel <code>term()</code> ).  Au premier appel √† <code>expr()</code> oracle devrait nous dire de suivre la premi√®re alternative ( <code>expr()</code> );  dans le deuxi√®me appel (r√©cursif) - de m√™me, mais dans le troisi√®me, il devrait nous inciter √† appeler <code>term()</code> .  Dans le code, cela ressemblera √† ceci: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> oracle() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> expr() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> expect(<span class="hljs-string"><span class="hljs-string">'+'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p>  Comment √©crire un tel oracle?  Voyons voir ... Nous pourrions essayer de suivre le nombre d'appels <code>expr()</code> r√©cursive √† gauche <code>expr()</code> dans la pile d'appels et de le comparer avec le nombre d'op√©rateurs <code>'+'</code> dans l'expression suivante.  Si la pile d'appels est plus profonde que le nombre d'instructions, l'oracle doit retourner false (nous obliger √† s√©lectionner <code>term()</code> ).  J'ai h√¢te de l'impl√©menter avec <code>sys._getframe()</code> , mais il y a une meilleure fa√ßon: retournons la pile des appels! </p><br><p>  L'id√©e est que nous commen√ßons par un appel o√π l'oracle retourne faux, et enregistrons le r√©sultat.  Cela nous donne la s√©quence <code>expr() -&gt; term() -&gt; 'foo'</code> .  (Il devrait retourner un arbre d'analyse pour le <code>term</code> initial, c'est-√†-dire <code>'foo'</code> . Le code ci-dessus renvoie juste <code>True</code> , mais dans la deuxi√®me partie de la s√©rie d'articles, j'ai d√©j√† montr√© comment retourner l'arbre d'analyse √† la place.) Un tel oracle est facile √† impl√©menter, car il devrait renvoyez simplement <code>False</code> lors du premier appel - aucune v√©rification de pile ou scrutation dans le futur n'est requise. </p><br><p>  Ensuite, nous appelons √† nouveau <code>expr()</code> , et cette fois l'oracle retourne <code>True</code> , mais au lieu de l'appel r√©cursif gauche √† <code>expr()</code> nous substituons le r√©sultat enregistr√© de l'appel pr√©c√©dent.  Et puisque l'op√©rateur attendu <code>'+'</code> et le prochain jeton appropri√© sont √©galement pr√©sents, cela nous donnera un arbre d'analyse pour <code>foo + bar</code> . </p><br><p>  Encore une fois, nous r√©p√©tons l'algorithme, et tout se passe √† nouveau: cette fois, nous obtenons un arbre d'analyse pour l'expression compl√®te, et il est vraiment r√©cursif √† gauche ( <code>(foo + bar) + baz</code> ). </p><br><p>  Ensuite, nous r√©p√©tons l'algorithme √† nouveau.  Mais cette fois, bien que Oracle renvoie <code>True</code> et que le r√©sultat enregistr√© de l'appel pr√©c√©dent soit √©galement disponible, il n'y a plus <code>'+'</code> op√©rateur <code>'+'</code> et la premi√®re alternative √©choue.  Ainsi, nous essayons la deuxi√®me option, qui r√©ussit, et ne trouve que le terme initial ( <code>'foo'</code> ).  Ce r√©sultat est pire que celui obtenu √† partir de la premi√®re alternative, donc √† ce stade, nous arr√™tons et enregistrons l'analyse la plus longue (c'est-√†-dire <code>(foo + bar) + baz</code> ). </p><br><p>  Pour transformer cela en code de travail, j'ai d'abord modifi√© un peu l'algorithme pour combiner l'appel <code>oracle()</code> avec l'appel r√©cursif gauche √† <code>expr()</code> .  Appelons-le <code>oracle_expr()</code> .  Code: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> oracle_expr() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> expect(<span class="hljs-string"><span class="hljs-string">'+'</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> term(): <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p>  Ensuite, nous allons √©crire un wrapper qui impl√©mente la logique d√©crite ci-dessus.  Il utilise une variable globale (ne vous inqui√©tez pas, je m'en d√©barrasserai plus tard).  La fonction <code>oracle_expr()</code> lira la variable globale et le wrapper la contr√¥lera: </p><br><pre> <code class="python hljs">saved_result = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">oracle_expr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> saved_result <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> saved_result <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">expr_wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> saved_result saved_result = <span class="hljs-keyword"><span class="hljs-keyword">None</span></span> parsed_length = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span>: new_result = expr() <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> new_result: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> new_parsed_length = &lt;calculate size of new_result&gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> new_parsed_length &lt;= parsed_length: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> saved_result = new_result parsed_length = new_parsed_length <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> saved_result</code> </pre> <br><p>  Le code, bien s√ªr, est terrible, mais au moins il transmet l'essence de l'algorithme.  Remodelons-le pour que nous puissions en √™tre fiers. </p><br><p>  La compr√©hension la plus importante (qui m'appartient, bien que je ne sois probablement pas le premier √† le remarquer) est que nous pouvons utiliser le cache de m√©morisation au lieu d'une variable globale.  Nous y stockons le r√©sultat d'un appel √† l'autre.  Nous nous d√©barrassons donc d'une fonction distincte <code>oracle_expr()</code> , car  nous pouvons g√©n√©rer un appel standard √† <code>expr()</code> qu'il soit en position r√©cursive √† gauche ou √† droite. </p><br><p>  Nous avons donc besoin d'un d√©corateur <code>@memoize_left_rec</code> distinct, qui n'est utilis√© que pour les r√®gles r√©cursives de gauche.  Il appelle la fonction <code>oracle_expr()</code> , tirant la valeur stock√©e du cache de m√©morisation, et contient une boucle qui appelle la fonction <code>expr()</code> plusieurs fois, jusqu'√† ce que chaque nouveau r√©sultat soit comparable √† une partie des donn√©es d'entr√©e plus longue que la pr√©c√©dente.  Et, bien s√ªr, puisque chaque position d'entr√©e et chaque m√©thode d'analyse sont mises en cache s√©par√©ment, il ne se soucie pas du retour en arri√®re ou de quelques r√®gles r√©cursives (par exemple, dans la grammaire du jouet que j'ai utilis√©e, <code>expr</code> et <code>term</code> restent r√©cursifs). </p><br><p>  Un autre avantage du prototype que j'ai cr√©√© dans la troisi√®me partie est qu'il permet de v√©rifier facilement si le nouveau r√©sultat est plus long que l'ancien: la m√©thode <code>mark()</code> renvoie l'index dans le tableau des jetons d'entr√©e, nous pouvons donc simplement l'utiliser au lieu de <code>parsed_length</code> . </p><br><p>  J'omets la preuve de la raison pour laquelle cet algorithme fonctionne toujours, quelle que soit la folie de la grammaire.  En fait, je ne l'ai m√™me pas lu.  Je vois que cela fonctionne pour les cas simples, tels que <code>expr</code> dans ma grammaire des jouets, ainsi que pour les cas un peu plus complexes (par exemple, en utilisant la r√©cursion gauche cach√©e derri√®re des √©l√©ments facultatifs dans une alternative, ou en utilisant la r√©cursion mutuelle entre plusieurs r√®gles).  La situation la plus difficile dont je me souvienne dans la grammaire Python est toujours r√©solue par cet algorithme, donc je fais confiance au th√©or√®me et aux personnes qui l'ont prouv√©. </p><br><p>  √âcrivons le code de bataille. </p><br><p>  Premi√®rement, le g√©n√©rateur d'analyseur doit d√©terminer quelles r√®gles restent r√©cursives.  Il s'agit d'un probl√®me r√©solu en th√©orie des graphes.  Je ne vais pas montrer l'algorithme ici, et en fait je veux m√™me le simplifier encore plus.  Je suppose que les seules r√®gles de grammaire r√©cursive √† gauche sont directement r√©cursives √† gauche, comme <code>expr</code> dans notre grammaire des jouets.  Ensuite, pour v√©rifier la r√©cursivit√© gauche, il vous suffit de rechercher une alternative qui commencera par le nom de la r√®gle actuelle: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">is_left_recursive</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(rule)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> alt <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> rule.alts: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> alt[<span class="hljs-number"><span class="hljs-number">0</span></span>] == rule.name: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">True</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">False</span></span></code> </pre> <br><p>  Maintenant, nous allons changer le g√©n√©rateur d'analyseur pour que pour les r√®gles r√©cursives √† gauche, il g√©n√®re un autre d√©corateur.  Rappelons que dans la troisi√®me partie, nous avons <code>@memoize</code> toutes les m√©thodes de l'analyseur dans <code>@memoize</code> .  Maintenant, nous allons faire un petit changement dans le g√©n√©rateur, de sorte que pour les r√®gles r√©cursives √† gauche, nous utilisons <code>@memoize_left_rec</code> , puis impl√©mentons la magie dans le d√©corateur <code>memoize_left_rec</code> .  Le reste du g√©n√©rateur et d'autres codes n'ont pas besoin d'√™tre modifi√©s!  (M√™me si je devais bricoler avec le code de visualisation) </p><br><p>  Pour r√©f√©rence, voici √† <code>@memoize</code> d√©corateur <code>@memoize</code> original, copi√© √† partir de la partie 3. Souvenez-vous que <code>self</code> est une instance de <code>Parser</code> qui a un attribut <code>memo</code> (initialis√© avec un dictionnaire vide) et les m√©thodes <code>mark()</code> et <code>reset()</code> qui obtiennent et d√©finissent la position actuelle tokenizer: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize_wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args)</span></span></span><span class="hljs-function">:</span></span> pos = self.mark() memo = self.memos.get(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> memo <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: memo = self.memos[pos] = {} key = (func, args) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> memo: res, endpos = memo[key] self.reset(endpos) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: res = func(self, *args) endpos = self.mark() memo[key] = res, endpos <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> res <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> memoize_wrapper</code> </pre> <br><p>  Le d√©corateur <code>@memoize</code> souvient des appels pr√©c√©dents pour chaque position dans le flux d'entr√©e - pour chaque position dans le tableau (paresseux) de jetons d'entr√©e, il existe un dictionnaire de <code>memo</code> s√©par√©.  Les quatre premi√®res lignes de <code>memoize_wrapper</code> d√©di√©es √† l'obtention du dictionnaire de <code>memoize_wrapper</code> correct. </p><br><p>  Et voici <code>@memoize_left_rec</code> .  Seule la branche <code>else</code> est l√©g√®rement diff√©rente de l'impl√©mentation dans <code>@memoize</code> ci-dessus: </p><br><pre> <code class="python hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize_left_rec</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(func)</span></span></span><span class="hljs-function">:</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">def</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">memoize_left_rec_wrapper</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(self, *args)</span></span></span><span class="hljs-function">:</span></span> pos = self.mark() memo = self.memos.get(pos) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> memo <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">None</span></span>: memo = self.memos[pos] = {} key = (func, args) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> key <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> memo: res, endpos = memo[key] self.reset(endpos) <span class="hljs-keyword"><span class="hljs-keyword">else</span></span>: <span class="hljs-comment"><span class="hljs-comment"># Prime the cache with a failure. memo[key] = lastres, lastpos = None, pos # Loop until no longer parse is obtained. while True: self.reset(pos) res = func(self, *args) endpos = self.mark() if endpos &lt;= lastpos: break memo[key] = lastres, lastpos = res, endpos res = lastres self.reset(lastpos) return res return memoize_left_rec_wrapper</span></span></code> </pre> <br><p>  Il est probablement int√©ressant de voir comment cela fonctionne pour la m√©thode <code>expr()</code> .  Voyons comment le code suivant s'ex√©cutera: </p><br><pre> <code class="python hljs"><span class="hljs-meta"><span class="hljs-meta"> @memoize_left_rec def expr(self): pos = self.mark() if ((expr := self.expr()) and self.expect('+') and (term := self.term())): return Node('expr', [expr, term]) self.reset(pos) if term := self.term(): return Node('term', [term]) self.reset(pos) return None</span></span></code> </pre> <br><p>  Sur l'exemple de l'analyse de <code>foo + bar + baz</code> . </p><br><p>  Chaque fois que vous appelez la fonction <code>expr()</code> , l'appel est ¬´accroch√©¬ª par le d√©corateur qui recherche l'appel pr√©c√©dent √† la position actuelle.  Au premier appel, nous arrivons √† la branche <code>else</code> , o√π nous appelons √† plusieurs reprises la fonction d√©cor√©e <code>expr()</code> .  √âvidemment, nous reviendrons d'abord au d√©corateur, mais cette fois, il y a d√©j√† une certaine valeur dans le cache, donc la r√©cursivit√© est interrompue. </p><br><p>  Que se passe-t-il ensuite?  La valeur de cache initiale est calcul√©e sur cette ligne: </p><br><pre> <code class="python hljs"> <span class="hljs-comment"><span class="hljs-comment"># Prime the cache with a failure. memo[key] = lastres, lastpos = None, pos</span></span></code> </pre> <br><p>  Cela conduit au fait que d√©cor <code>expr()</code> renvoie <code>None</code> , apr√®s quoi le premier <code>if</code> dans <code>expr()</code> tombe (lorsque <code>expr: = self.expr()</code> ).  Autrement dit, nous passons au deuxi√®me <code>if</code> , qui reconna√Æt avec succ√®s le <code>term</code> (dans notre exemple, <code>'foo'</code> ) et <code>expr</code> renvoie une instance de <code>Node</code> .  D'o√π revenons-nous?  √Ä la <code>while</code> dans le d√©corateur.  Nous mettons √† jour le cache de m√©morisation avec un nouveau r√©sultat (cette instance de <code>Node</code> ), puis ex√©cutons l'it√©ration suivante. </p><br><p>  <code>expr()</code> est √† nouveau appel√©e, et cette fois, l'appel r√©cursif intercept√© renvoie l'instance mise en cache de <code>Node</code> (term), puis passe √† l'appel pour <code>expect('+')</code> .  Tout est en ordre, puisque nous sommes d√©sormais le premier op√©rateur <code>'+'</code> .  Apr√®s cela, nous recherchons un terme qui r√©ussit √©galement (trouv√© <code>'bar'</code> ). </p><br><p>  Alors maintenant <code>expr()</code> , ayant d√©j√† reconnu <code>foo + bar</code> , retourne √† la <code>while</code> , qui effectue les m√™mes actions: il met √† jour le cache de m√©morisation avec un nouveau r√©sultat (plus long) et commence l'it√©ration suivante. </p><br><p>  Ce jeu se r√©p√®te √† nouveau.  Encore une fois, l'appel r√©cursif intercept√© <code>expr()</code> r√©cup√®re un nouveau r√©sultat (cette fois <code>foo + bar</code> ) du cache, et nous nous attendons √† voir un autre <code>'+'</code> (deuxi√®me) et un autre <code>term</code> ( <code>'baz'</code> ).  Nous cr√©ons un <code>Node</code> repr√©sentant <code>(foo + bar) + baz</code> , et le renvoyons √† la <code>while</code> , qui le place dans le cache et le r√©p√®te √† nouveau. </p><br><p>  Mais maintenant, nous allons suivre une autre branche de l'algorithme.  Nous nous attendons √† rencontrer un autre <code>'+'</code> , mais ne le trouvons pas!  Ainsi, cet appel √† <code>expr()</code> retourne √† sa deuxi√®me alternative et retourne uniquement <code>term</code> .  Lorsque cela appara√Æt avant la <code>while</code> , il s'av√®re que ce r√©sultat est plus court que le dernier.  Ainsi, il interrompt et renvoie un r√©sultat plus long ( <code>(foo + bar) + baz</code> ) √† celui qui a initi√© l'appel <code>expr()</code> (par exemple, l'appel de la <code>statement()</code> n'est pas affich√© ici). </p><br><p>  Donc, c'est l√† que l'histoire d'aujourd'hui se termine: nous avons r√©ussi √† impl√©menter la r√©cursion gauche dans un analyseur PEG.  La semaine prochaine, je pr√©vois de discuter de l'ajout d '¬´actions¬ª √† la grammaire, ce qui nous permettra de personnaliser le r√©sultat renvoy√© par la m√©thode de l'analyseur pour cette alternative (au lieu de toujours renvoyer une instance de <code>Node</code> ). </p><br><p>  Si vous souhaitez jouer avec le code, consultez <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">le r√©f√©rentiel GitHub</a> .  (J'ai √©galement ajout√© un code de visualisation pour la r√©cursion gauche, mais je ne suis pas tout √† fait satisfait, donc je ne fournirai pas de lien ici.) </p><br><p>  Licence pour cet article et code cit√©: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">CC BY-NC-SA 4.0</a> </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr471986/">https://habr.com/ru/post/fr471986/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr471974/index.html">Comment deux capitaines sont devenus g√©n√©raux: blanc et rouge</a></li>
<li><a href="../fr471976/index.html">Comment un informaticien obtient-il un emploi √† l'√©tranger?</a></li>
<li><a href="../fr471978/index.html">Nous ne pouvons pas faire confiance aux syst√®mes d'IA bas√©s uniquement sur le deep learning</a></li>
<li><a href="../fr471980/index.html">Escrocs au t√©l√©phone. Acte quatre, final ...</a></li>
<li><a href="../fr471982/index.html">Discuter de l'avenir de PHP</a></li>
<li><a href="../fr471988/index.html">Ajout d'actions √† la grammaire PEG</a></li>
<li><a href="../fr471990/index.html">M√©ta grammaire pour l'analyseur PEG</a></li>
<li><a href="../fr471992/index.html">Impl√©mentation des fonctionnalit√©s restantes de PEG</a></li>
<li><a href="../fr471994/index.html">Travail sur PEG sur Core Developer Sprint</a></li>
<li><a href="../fr471998/index.html">F # 10: Listes</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>