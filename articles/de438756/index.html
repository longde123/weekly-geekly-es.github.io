<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§ûüèø üè¨ üöÜ Sechster Chromcheck, Nachwort üçñ üîÄ üë®üèæ‚Äçüíº</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anfang 2018 wurde unser Blog durch eine Reihe von Artikeln zur sechsten √úberpr√ºfung des Quellcodes des Chromium-Projekts erg√§nzt. Die Reihe enth√§lt 8 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sechster Chromcheck, Nachwort</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/438756/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e3e/0f3/36b/e3e0f336b600672c601b8849d274d251.png" alt="schweres Einhorn"></div><br>  Anfang 2018 wurde unser Blog durch eine Reihe von Artikeln zur sechsten √úberpr√ºfung des Quellcodes des Chromium-Projekts erg√§nzt.  Die Reihe enth√§lt 8 Artikel zu Fehlern und Empfehlungen zu deren Vorbeugung.  Zwei Artikel l√∂sten heftige Diskussionen aus, und gelegentlich erhalte ich immer noch Kommentare per E-Mail zu den darin behandelten Themen.  Vielleicht sollte ich zus√§tzliche Erkl√§rungen geben und, wie sie sagen, den Rekord klarstellen. <br><a name="habracut"></a><br>  Ein Jahr ist vergangen, seit eine Reihe von Artikeln √ºber eine regelm√§√üige √úberpr√ºfung des Quellcodes des Chromium-Projekts geschrieben wurde: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chrom: Der sechste Projektcheck und 250 Bugs</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nettes Chrom und ungeschicktes Memset</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">brechen und durchfallen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chrom: Speicherlecks</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chrom: Tippfehler</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chrom: Verwendung nicht vertrauensw√ºrdiger Daten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warum ist es wichtig zu √ºberpr√ºfen, was die Malloc-Funktion zur√ºckgegeben hat?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chrom: Andere Fehler</a> </li></ol><br>  Artikel, die sich mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Memset</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Malloc befassen,</a> haben Debatten ausgel√∂st und f√ºhren auch weiterhin dazu, was mir seltsam vorkommt.  Anscheinend gab es einige Verwirrung aufgrund der Tatsache, dass ich bei der Formulierung meiner Gedanken nicht genau genug gewesen war.  Ich beschloss, zu diesen Artikeln zur√ºckzukehren und einige Klarstellungen vorzunehmen. <br><br><h2>  Memset </h2><br>  Beginnen wir mit einem Artikel √ºber <i>Memset</i> , denn hier ist alles einfach.  Es gab einige Argumente f√ºr den besten Weg, Strukturen zu initialisieren.  Nicht viele Programmierer haben geschrieben, dass es besser w√§re, die Empfehlung zu geben, nicht zu schreiben: <br><br><pre><code class="cpp hljs">HDHITTESTINFO hhti = {};</code> </pre> <br>  aber auf folgende Weise zu schreiben: <br><br><pre> <code class="cpp hljs">HDHITTESTINFO hhti = { <span class="hljs-number"><span class="hljs-number">0</span></span> };</code> </pre> <br>  Gr√ºnde: <br><br><ol><li>  Die Konstruktion {0} ist beim Lesen von Code leichter zu erkennen als {}. </li><li>  Die Konstruktion {0} ist intuitiver verst√§ndlich als {}.  Das hei√üt, 0 deutet darauf hin, dass die Struktur mit Nullen gef√ºllt ist. </li></ol><br>  Dementsprechend schlagen mir die Leser vor, dieses Initialisierungsbeispiel im Artikel zu √§ndern.  Ich bin mit den Argumenten nicht einverstanden und plane keine √Ñnderungen am Artikel.  Jetzt werde ich meine Meinung erkl√§ren und einige Gr√ºnde nennen. <br><br>  Ich denke, die Sichtbarkeit ist eine Frage des Geschmacks und der Gewohnheit.  Ich denke nicht, dass das Vorhandensein von 0 in den Klammern die Situation grundlegend ver√§ndert. <br><br>  Was das zweite Argument betrifft, stimme ich dem √ºberhaupt nicht zu.  Der Datensatz vom Typ {0} gibt einen Grund an, den Code falsch wahrzunehmen.  Sie k√∂nnen beispielsweise annehmen, dass alle Felder durch Einsen initialisiert werden, wenn Sie 0 durch 1 ersetzen.  Daher ist ein solcher Schreibstil eher sch√§dlich als hilfreich. <br><br>  Der PVS-Studio-Analysator verf√ºgt sogar √ºber eine zugeh√∂rige Diagnose <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V1009</a> , deren Beschreibung unten angegeben ist. <br><br>  <b>V1009.</b>  <b>√úberpr√ºfen Sie die Array-Initialisierung.</b>  <b>Nur das erste Element wird explizit initialisiert.</b> <br><br>  Der Analysator hat einen m√∂glichen Fehler festgestellt, der darauf zur√ºckzuf√ºhren ist, dass beim Deklarieren eines Arrays der Wert nur f√ºr ein Element angegeben wird.  Somit werden die verbleibenden Elemente implizit durch Null oder durch einen Standardkonstruktor initialisiert. <br><br>  Betrachten wir das Beispiel eines verd√§chtigen Codes: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arr[<span class="hljs-number"><span class="hljs-number">3</span></span>] = {<span class="hljs-number"><span class="hljs-number">1</span></span>};</code> </pre> <br>  Vielleicht w√ºrde der erwartete Programmierer als <i>arr</i> ganz aus solchen bestehen, aber das ist es nicht.  Das Array besteht aus den Werten 1, 0, 0. <br><br>  Richtiger Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arr[<span class="hljs-number"><span class="hljs-number">3</span></span>] = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>};</code> </pre> <br>  Eine solche Verwirrung kann aufgrund der √Ñhnlichkeit mit der Konstruktion <i>arr = {0} auftreten</i> , die das gesamte Array mit Nullen initialisiert. <br><br>  Wenn solche Konstruktionen in Ihrem Projekt aktiv verwendet werden, k√∂nnen Sie diese Diagnose deaktivieren. <br><br>  Wir empfehlen au√üerdem, die Klarheit Ihres Codes nicht zu vernachl√§ssigen. <br><br>  Beispielsweise wird der Code zum Codieren von Werten einer Farbe wie folgt aufgezeichnet: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> White[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0xff</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Black[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0x00</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Green[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span> };</code> </pre> <br>  Dank der impliziten Initialisierung werden alle Farben korrekt angegeben. Es ist jedoch besser, den Code klarer umzuschreiben: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> White[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0xff</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Black[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Green[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span> };</code> </pre> <br><h2>  malloc </h2><br>  Bevor Sie weiterlesen, erinnern Sie sich bitte an den Inhalt des Artikels " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warum es wichtig ist, zu √ºberpr√ºfen, was die Malloc-Funktion zur√ºckgegeben hat</a> ".  Dieser Artikel hat zu vielen Debatten und Kritik gef√ºhrt.  Hier sind einige der Diskussionen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">reddit.com/r/cpp</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">reddit.com/r/C_Programming</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">habr.com</a> (en).  Gelegentlich schreiben mir die Leser immer noch eine E-Mail √ºber diesen Artikel. <br><br>  Der Artikel wird von den Lesern f√ºr folgende Punkte kritisiert: <br><br>  <b>1. Wenn</b> <b><i>malloc</i></b> <b><i>NULL zur√ºckgegeben hat</i></b> <b>, ist es besser, das Programm sofort zu beenden, als eine Reihe von</b> <b><i>if</i></b> <b>-s</b> <b>zu schreiben</b> <b>und zu versuchen, den Speicher irgendwie zu handhaben, weshalb die Programmausf√ºhrung ohnehin h√§ufig unm√∂glich ist.</b> <br><br>  Ich habe bis zum Ende nicht darauf gedr√§ngt, mit den Folgen eines Speicherverlusts zu k√§mpfen, indem ich den Fehler immer h√∂her weitergegeben habe.  Wenn es Ihrer Anwendung gestattet ist, ihre Arbeit ohne Vorwarnung zu beenden, lassen Sie es so sein.  Zu diesem Zweck reicht bereits eine einzige √úberpr√ºfung direkt nach <i>malloc</i> oder mit <i>xmalloc</i> aus (siehe n√§chster Punkt). <br><br>  Ich protestierte und warnte vor dem Mangel an √úberpr√ºfungen, aufgrund derer das Programm weiter funktioniert, als w√§re nichts passiert.  Es ist ein ganz anderer Fall.  Dies ist gef√§hrlich, da es zu undefiniertem Verhalten, Datenkorruption usw. f√ºhrt. <br><br>  <b>2. Es gibt keine Beschreibung einer L√∂sung, die darin besteht, Wrapper-Funktionen zum Zuweisen von Speicher mit einer darauf folgenden Pr√ºfung oder zum Verwenden bereits vorhandener Funktionen wie</b> <b><i>xmalloc zu schreiben</i></b> <b>.</b> <br><br>  Ich stimme zu, ich habe diesen Punkt verpasst.  Beim Schreiben des Artikels habe ich einfach nicht dar√ºber nachgedacht, wie ich die Situation beheben kann.  F√ºr mich war es wichtiger, dem Leser die Gefahr der Scheckabwesenheit zu vermitteln.  Wie man einen Fehler behebt, ist eine Frage des Geschmacks und der Implementierungsdetails. <br><br>  Die <i>xmalloc-</i> Funktion ist nicht Teil der Standard-C-Bibliothek (siehe " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist der Unterschied zwischen xmalloc und malloc?</a> ").  Diese Funktion kann jedoch in anderen Bibliotheken deklariert werden, z. B. in der GNU utils-Bibliothek ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GNU libiberty</a> ). <br><br>  Der Hauptpunkt der Funktion ist, dass das Programm abst√ºrzt, wenn kein Speicher zugewiesen werden kann.  Die Implementierung dieser Funktion k√∂nnte wie folgt aussehen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xmalloc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* p = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!p) { <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"fatal: out of memory (xmalloc(%zu)).\n"</span></span>, s); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(EXIT_FAILURE); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; }</code> </pre> <br>  Dementsprechend k√∂nnen Sie durch Aufrufen einer <i>xmalloc-</i> Funktion anstelle von <i>malloc</i> jedes Mal sicher sein, dass aufgrund der Verwendung eines Nullzeigers kein undefiniertes Verhalten im Programm auftritt. <br><br>  Leider ist <i>xmalloc auch</i> kein Allheilmittel.  Man sollte bedenken, dass die Verwendung von <i>xmalloc</i> beim Schreiben von Bibliothekscode nicht <i>akzeptabel</i> ist.  Ich werde sp√§ter dar√ºber sprechen. <br><br>  <b>3. Die meisten Kommentare lauteten wie folgt: "In der Praxis gibt</b> <b><i>malloc</i></b> <b>niemals</b> <b><i>NULL zur√ºck</i></b> <b>."</b> <br><br>  Zum Gl√ºck bin ich nicht der einzige, der versteht, dass dies der falsche Ansatz ist.  Dieser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kommentar</a> in meiner Unterst√ºtzung hat mir sehr gut gefallen: <br><br>  <i>Nach meiner Erfahrung mit der Diskussion dieses Themas habe ich das Gef√ºhl, dass es im Internet zwei Sekten gibt.</i>  <i>Anh√§nger des ersten glauben fest daran, dass malloc unter Linux niemals NULL zur√ºckgibt.</i>  <i>Die Bef√ºrworter des zweiten behaupten von ganzem Herzen, dass, wenn in Ihrem Programm kein Speicher zugewiesen werden kann, nichts getan werden kann, Sie nur abst√ºrzen k√∂nnen.</i>  <i>Es gibt keine M√∂glichkeit, sie zu √ºberreden.</i>  <i>Besonders wenn sich diese beiden Sekten kreuzen.</i>  <i>Sie k√∂nnen es nur als gegeben annehmen.</i>  <i>Und es ist sogar nicht wichtig, auf welcher speziellen Ressource eine Diskussion stattfindet.</i> <br><br>  Ich dachte eine Weile nach und beschloss, dem Rat zu folgen, also werde ich nicht versuchen, jemanden zu √ºberzeugen :).  Hoffentlich schreiben diese Entwicklergruppen nur nicht t√∂dliche Programme.  Wenn zum Beispiel einige Daten im Spiel besch√§digt werden, ist nichts Entscheidendes daran. <br><br>  Das einzige, was z√§hlt, ist, dass Entwickler von Bibliotheken und Datenbanken dies nicht tun d√ºrfen. <br><br><h2>  Sprechen Sie die Entwickler von stark abh√§ngigem Code und Bibliotheken an </h2><br>  Wenn Sie eine Bibliothek oder einen anderen stark abh√§ngigen Code entwickeln, √ºberpr√ºfen Sie immer den Wert des von der Funktion <i>malloc / realloc zur√ºckgegebenen</i> Zeigers und geben Sie einen Fehlercode nach au√üen zur√ºck, wenn der Speicher nicht zugewiesen werden konnte. <br><br>  In Bibliotheken k√∂nnen Sie die <i>Exit-</i> Funktion nicht aufrufen, wenn die Speicherzuordnung fehlgeschlagen ist.  Aus dem gleichen Grund k√∂nnen Sie <i>xmalloc</i> nicht verwenden.  F√ºr viele Anwendungen ist es nicht akzeptabel, sie einfach abzubrechen.  Aus diesem Grund kann beispielsweise eine Datenbank besch√§digt werden.  Man kann Daten verlieren, die f√ºr viele Stunden ausgewertet wurden.  Aus diesem Grund kann das Programm zu "Denial-of-Service" -Schwachstellen f√ºhren, wenn eine Multithread-Anwendung anstelle einer korrekten Behandlung der wachsenden Arbeitslast einfach beendet wird. <br><br>  Es kann nicht davon ausgegangen werden, auf welche Weise und in welchen Projekten die Bibliothek genutzt wird.  Daher sollte davon ausgegangen werden, dass die Anwendung sehr kritische Aufgaben l√∂sen kann.  Deshalb ist es nicht gut, es nur zu t√∂ten, indem man den <i>Ausgang</i> ruft.  H√∂chstwahrscheinlich wird ein solches Programm unter Ber√ºcksichtigung der M√∂glichkeit eines Speichermangels geschrieben und kann in diesem Fall etwas bewirken.  Beispielsweise kann ein CAD-System aufgrund der starken Fragmentierung des Speichers keinen geeigneten Speicherpuffer zuweisen, der f√ºr den regul√§ren Betrieb ausreicht.  In diesem Fall ist es nicht der Grund, im Notfallmodus mit Datenverlust zu quetschen.  Das Programm bietet die M√∂glichkeit, das Projekt zu speichern und sich normal neu zu starten. <br><br>  In keinem Fall ist es unm√∂glich, sich auf <i>malloc</i> zu verlassen, dass es immer in der Lage sein wird, Speicher zuzuweisen.  Es ist nicht bekannt, auf welcher Plattform und wie die Bibliothek verwendet wird.  Wenn die Situation mit wenig Arbeitsspeicher auf einer Plattform exotisch ist, kann dies auf der anderen Plattform durchaus √ºblich sein. <br><br>  Wir k√∂nnen nicht erwarten, dass das Programm abst√ºrzt, wenn <i>malloc</i> <i>NULL</i> zur√ºckgibt.  Alles kann passieren.  Wie ich im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel beschrieben habe</a> , schreibt das Programm m√∂glicherweise Daten nicht mit der Nulladresse.  Infolgedessen k√∂nnen einige Daten besch√§digt werden, was zu unvorhersehbaren Konsequenzen f√ºhrt.  Sogar <i>Memset</i> ist gef√§hrlich.  Wenn das Auff√ºllen mit Daten in umgekehrter Reihenfolge erfolgt, werden zuerst einige Daten besch√§digt, und dann st√ºrzt das Programm ab.  Der Absturz kann jedoch zu sp√§t erfolgen.  Wenn fehlerhafte Daten in parallelen Threads verwendet werden, w√§hrend die <i>Memset-</i> Funktion funktioniert, k√∂nnen die Folgen schwerwiegend sein.  Sie k√∂nnen eine besch√§digte Transaktion in einer Datenbank erhalten oder Befehle zum Entfernen "unn√∂tiger" Dateien senden.  Alles hat eine Chance zu passieren.  Ich schlage einem Leser vor, sich auszudenken, was aufgrund der Verwendung von M√ºll im Speicher passieren k√∂nnte. <br><br>  Somit hat die Bibliothek nur eine korrekte Arbeitsweise mit den <i>Malloc-</i> Funktionen.  Sie m√ºssen SOFORT √ºberpr√ºfen, ob die Funktion zur√ºckgegeben wurde. Wenn sie NULL ist, geben Sie einen Fehlerstatus zur√ºck. <br><br><h2>  Zus√§tzliche Links </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OOM-Handhabung</a> </li><li>  Spa√ü mit NULL-Zeigern: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> </li><li>  Was jeder C-Programmierer √ºber undefiniertes Verhalten wissen sollte: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438756/">https://habr.com/ru/post/de438756/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438746/index.html">Auf dem Weg zu den physikalischen Prinzipien der biologischen Evolution. Fortsetzung</a></li>
<li><a href="../de438748/index.html">Infrastruktur als Code gewinnen wir auf einer Skala (Kirill Vetchinkin, TYME)</a></li>
<li><a href="../de438750/index.html">Zivilisation der Quellen, 4/5</a></li>
<li><a href="../de438752/index.html">Buchhaltung direkt bei der Bank: Wie man einzelne Unternehmer gl√ºcklich macht</a></li>
<li><a href="../de438754/index.html">Wie wir die Netzwerk√ºberwachung f√ºr 14.000 Objekte durchgef√ºhrt haben</a></li>
<li><a href="../de438758/index.html">Warum √§ndert Google die Standard-URL-Oberfl√§che im Browser?</a></li>
<li><a href="../de438762/index.html">DBX: Versuchen Sie, das Kompilieren von MySQL-Abfragen zu vermeiden</a></li>
<li><a href="../de438764/index.html">Sechster Chromtest, Nachwort</a></li>
<li><a href="../de438766/index.html">Extrazellul√§re DNA als Biomarker des Alterns und verschiedener Pathologien</a></li>
<li><a href="../de438768/index.html">Wie ich Alice half, nicht auf andere Namen zu antworten. Yandex Praktikum</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>