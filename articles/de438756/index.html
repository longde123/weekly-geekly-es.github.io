<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤞🏿 🏬 🚆 Sechster Chromcheck, Nachwort 🍖 🔀 👨🏾‍💼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Anfang 2018 wurde unser Blog durch eine Reihe von Artikeln zur sechsten Überprüfung des Quellcodes des Chromium-Projekts ergänzt. Die Reihe enthält 8 ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Sechster Chromcheck, Nachwort</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/pvs-studio/blog/438756/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/e3e/0f3/36b/e3e0f336b600672c601b8849d274d251.png" alt="schweres Einhorn"></div><br>  Anfang 2018 wurde unser Blog durch eine Reihe von Artikeln zur sechsten Überprüfung des Quellcodes des Chromium-Projekts ergänzt.  Die Reihe enthält 8 Artikel zu Fehlern und Empfehlungen zu deren Vorbeugung.  Zwei Artikel lösten heftige Diskussionen aus, und gelegentlich erhalte ich immer noch Kommentare per E-Mail zu den darin behandelten Themen.  Vielleicht sollte ich zusätzliche Erklärungen geben und, wie sie sagen, den Rekord klarstellen. <br><a name="habracut"></a><br>  Ein Jahr ist vergangen, seit eine Reihe von Artikeln über eine regelmäßige Überprüfung des Quellcodes des Chromium-Projekts geschrieben wurde: <br><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chrom: Der sechste Projektcheck und 250 Bugs</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Nettes Chrom und ungeschicktes Memset</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">brechen und durchfallen</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chrom: Speicherlecks</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chrom: Tippfehler</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chrom: Verwendung nicht vertrauenswürdiger Daten</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warum ist es wichtig zu überprüfen, was die Malloc-Funktion zurückgegeben hat?</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Chrom: Andere Fehler</a> </li></ol><br>  Artikel, die sich mit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Memset</a> und <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Malloc befassen,</a> haben Debatten ausgelöst und führen auch weiterhin dazu, was mir seltsam vorkommt.  Anscheinend gab es einige Verwirrung aufgrund der Tatsache, dass ich bei der Formulierung meiner Gedanken nicht genau genug gewesen war.  Ich beschloss, zu diesen Artikeln zurückzukehren und einige Klarstellungen vorzunehmen. <br><br><h2>  Memset </h2><br>  Beginnen wir mit einem Artikel über <i>Memset</i> , denn hier ist alles einfach.  Es gab einige Argumente für den besten Weg, Strukturen zu initialisieren.  Nicht viele Programmierer haben geschrieben, dass es besser wäre, die Empfehlung zu geben, nicht zu schreiben: <br><br><pre><code class="cpp hljs">HDHITTESTINFO hhti = {};</code> </pre> <br>  aber auf folgende Weise zu schreiben: <br><br><pre> <code class="cpp hljs">HDHITTESTINFO hhti = { <span class="hljs-number"><span class="hljs-number">0</span></span> };</code> </pre> <br>  Gründe: <br><br><ol><li>  Die Konstruktion {0} ist beim Lesen von Code leichter zu erkennen als {}. </li><li>  Die Konstruktion {0} ist intuitiver verständlich als {}.  Das heißt, 0 deutet darauf hin, dass die Struktur mit Nullen gefüllt ist. </li></ol><br>  Dementsprechend schlagen mir die Leser vor, dieses Initialisierungsbeispiel im Artikel zu ändern.  Ich bin mit den Argumenten nicht einverstanden und plane keine Änderungen am Artikel.  Jetzt werde ich meine Meinung erklären und einige Gründe nennen. <br><br>  Ich denke, die Sichtbarkeit ist eine Frage des Geschmacks und der Gewohnheit.  Ich denke nicht, dass das Vorhandensein von 0 in den Klammern die Situation grundlegend verändert. <br><br>  Was das zweite Argument betrifft, stimme ich dem überhaupt nicht zu.  Der Datensatz vom Typ {0} gibt einen Grund an, den Code falsch wahrzunehmen.  Sie können beispielsweise annehmen, dass alle Felder durch Einsen initialisiert werden, wenn Sie 0 durch 1 ersetzen.  Daher ist ein solcher Schreibstil eher schädlich als hilfreich. <br><br>  Der PVS-Studio-Analysator verfügt sogar über eine zugehörige Diagnose <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">V1009</a> , deren Beschreibung unten angegeben ist. <br><br>  <b>V1009.</b>  <b>Überprüfen Sie die Array-Initialisierung.</b>  <b>Nur das erste Element wird explizit initialisiert.</b> <br><br>  Der Analysator hat einen möglichen Fehler festgestellt, der darauf zurückzuführen ist, dass beim Deklarieren eines Arrays der Wert nur für ein Element angegeben wird.  Somit werden die verbleibenden Elemente implizit durch Null oder durch einen Standardkonstruktor initialisiert. <br><br>  Betrachten wir das Beispiel eines verdächtigen Codes: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arr[<span class="hljs-number"><span class="hljs-number">3</span></span>] = {<span class="hljs-number"><span class="hljs-number">1</span></span>};</code> </pre> <br>  Vielleicht würde der erwartete Programmierer als <i>arr</i> ganz aus solchen bestehen, aber das ist es nicht.  Das Array besteht aus den Werten 1, 0, 0. <br><br>  Richtiger Code: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> arr[<span class="hljs-number"><span class="hljs-number">3</span></span>] = {<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">1</span></span>};</code> </pre> <br>  Eine solche Verwirrung kann aufgrund der Ähnlichkeit mit der Konstruktion <i>arr = {0} auftreten</i> , die das gesamte Array mit Nullen initialisiert. <br><br>  Wenn solche Konstruktionen in Ihrem Projekt aktiv verwendet werden, können Sie diese Diagnose deaktivieren. <br><br>  Wir empfehlen außerdem, die Klarheit Ihres Codes nicht zu vernachlässigen. <br><br>  Beispielsweise wird der Code zum Codieren von Werten einer Farbe wie folgt aufgezeichnet: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> White[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0xff</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Black[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0x00</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Green[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span> };</code> </pre> <br>  Dank der impliziten Initialisierung werden alle Farben korrekt angegeben. Es ist jedoch besser, den Code klarer umzuschreiben: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">int</span></span> White[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0xff</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Black[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span> }; <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Green[<span class="hljs-number"><span class="hljs-number">3</span></span>] = { <span class="hljs-number"><span class="hljs-number">0x00</span></span>, <span class="hljs-number"><span class="hljs-number">0xff</span></span>, <span class="hljs-number"><span class="hljs-number">0x00</span></span> };</code> </pre> <br><h2>  malloc </h2><br>  Bevor Sie weiterlesen, erinnern Sie sich bitte an den Inhalt des Artikels " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Warum es wichtig ist, zu überprüfen, was die Malloc-Funktion zurückgegeben hat</a> ".  Dieser Artikel hat zu vielen Debatten und Kritik geführt.  Hier sind einige der Diskussionen: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">reddit.com/r/cpp</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">reddit.com/r/C_Programming</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">habr.com</a> (en).  Gelegentlich schreiben mir die Leser immer noch eine E-Mail über diesen Artikel. <br><br>  Der Artikel wird von den Lesern für folgende Punkte kritisiert: <br><br>  <b>1. Wenn</b> <b><i>malloc</i></b> <b><i>NULL zurückgegeben hat</i></b> <b>, ist es besser, das Programm sofort zu beenden, als eine Reihe von</b> <b><i>if</i></b> <b>-s</b> <b>zu schreiben</b> <b>und zu versuchen, den Speicher irgendwie zu handhaben, weshalb die Programmausführung ohnehin häufig unmöglich ist.</b> <br><br>  Ich habe bis zum Ende nicht darauf gedrängt, mit den Folgen eines Speicherverlusts zu kämpfen, indem ich den Fehler immer höher weitergegeben habe.  Wenn es Ihrer Anwendung gestattet ist, ihre Arbeit ohne Vorwarnung zu beenden, lassen Sie es so sein.  Zu diesem Zweck reicht bereits eine einzige Überprüfung direkt nach <i>malloc</i> oder mit <i>xmalloc</i> aus (siehe nächster Punkt). <br><br>  Ich protestierte und warnte vor dem Mangel an Überprüfungen, aufgrund derer das Programm weiter funktioniert, als wäre nichts passiert.  Es ist ein ganz anderer Fall.  Dies ist gefährlich, da es zu undefiniertem Verhalten, Datenkorruption usw. führt. <br><br>  <b>2. Es gibt keine Beschreibung einer Lösung, die darin besteht, Wrapper-Funktionen zum Zuweisen von Speicher mit einer darauf folgenden Prüfung oder zum Verwenden bereits vorhandener Funktionen wie</b> <b><i>xmalloc zu schreiben</i></b> <b>.</b> <br><br>  Ich stimme zu, ich habe diesen Punkt verpasst.  Beim Schreiben des Artikels habe ich einfach nicht darüber nachgedacht, wie ich die Situation beheben kann.  Für mich war es wichtiger, dem Leser die Gefahr der Scheckabwesenheit zu vermitteln.  Wie man einen Fehler behebt, ist eine Frage des Geschmacks und der Implementierungsdetails. <br><br>  Die <i>xmalloc-</i> Funktion ist nicht Teil der Standard-C-Bibliothek (siehe " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Was ist der Unterschied zwischen xmalloc und malloc?</a> ").  Diese Funktion kann jedoch in anderen Bibliotheken deklariert werden, z. B. in der GNU utils-Bibliothek ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GNU libiberty</a> ). <br><br>  Der Hauptpunkt der Funktion ist, dass das Programm abstürzt, wenn kein Speicher zugewiesen werden kann.  Die Implementierung dieser Funktion könnte wie folgt aussehen: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function">* </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">xmalloc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">size_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> s)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">void</span></span>* p = <span class="hljs-built_in"><span class="hljs-built_in">malloc</span></span>(s); <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (!p) { <span class="hljs-built_in"><span class="hljs-built_in">fprintf</span></span> (<span class="hljs-built_in"><span class="hljs-built_in">stderr</span></span>, <span class="hljs-string"><span class="hljs-string">"fatal: out of memory (xmalloc(%zu)).\n"</span></span>, s); <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>(EXIT_FAILURE); } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> p; }</code> </pre> <br>  Dementsprechend können Sie durch Aufrufen einer <i>xmalloc-</i> Funktion anstelle von <i>malloc</i> jedes Mal sicher sein, dass aufgrund der Verwendung eines Nullzeigers kein undefiniertes Verhalten im Programm auftritt. <br><br>  Leider ist <i>xmalloc auch</i> kein Allheilmittel.  Man sollte bedenken, dass die Verwendung von <i>xmalloc</i> beim Schreiben von Bibliothekscode nicht <i>akzeptabel</i> ist.  Ich werde später darüber sprechen. <br><br>  <b>3. Die meisten Kommentare lauteten wie folgt: "In der Praxis gibt</b> <b><i>malloc</i></b> <b>niemals</b> <b><i>NULL zurück</i></b> <b>."</b> <br><br>  Zum Glück bin ich nicht der einzige, der versteht, dass dies der falsche Ansatz ist.  Dieser <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Kommentar</a> in meiner Unterstützung hat mir sehr gut gefallen: <br><br>  <i>Nach meiner Erfahrung mit der Diskussion dieses Themas habe ich das Gefühl, dass es im Internet zwei Sekten gibt.</i>  <i>Anhänger des ersten glauben fest daran, dass malloc unter Linux niemals NULL zurückgibt.</i>  <i>Die Befürworter des zweiten behaupten von ganzem Herzen, dass, wenn in Ihrem Programm kein Speicher zugewiesen werden kann, nichts getan werden kann, Sie nur abstürzen können.</i>  <i>Es gibt keine Möglichkeit, sie zu überreden.</i>  <i>Besonders wenn sich diese beiden Sekten kreuzen.</i>  <i>Sie können es nur als gegeben annehmen.</i>  <i>Und es ist sogar nicht wichtig, auf welcher speziellen Ressource eine Diskussion stattfindet.</i> <br><br>  Ich dachte eine Weile nach und beschloss, dem Rat zu folgen, also werde ich nicht versuchen, jemanden zu überzeugen :).  Hoffentlich schreiben diese Entwicklergruppen nur nicht tödliche Programme.  Wenn zum Beispiel einige Daten im Spiel beschädigt werden, ist nichts Entscheidendes daran. <br><br>  Das einzige, was zählt, ist, dass Entwickler von Bibliotheken und Datenbanken dies nicht tun dürfen. <br><br><h2>  Sprechen Sie die Entwickler von stark abhängigem Code und Bibliotheken an </h2><br>  Wenn Sie eine Bibliothek oder einen anderen stark abhängigen Code entwickeln, überprüfen Sie immer den Wert des von der Funktion <i>malloc / realloc zurückgegebenen</i> Zeigers und geben Sie einen Fehlercode nach außen zurück, wenn der Speicher nicht zugewiesen werden konnte. <br><br>  In Bibliotheken können Sie die <i>Exit-</i> Funktion nicht aufrufen, wenn die Speicherzuordnung fehlgeschlagen ist.  Aus dem gleichen Grund können Sie <i>xmalloc</i> nicht verwenden.  Für viele Anwendungen ist es nicht akzeptabel, sie einfach abzubrechen.  Aus diesem Grund kann beispielsweise eine Datenbank beschädigt werden.  Man kann Daten verlieren, die für viele Stunden ausgewertet wurden.  Aus diesem Grund kann das Programm zu "Denial-of-Service" -Schwachstellen führen, wenn eine Multithread-Anwendung anstelle einer korrekten Behandlung der wachsenden Arbeitslast einfach beendet wird. <br><br>  Es kann nicht davon ausgegangen werden, auf welche Weise und in welchen Projekten die Bibliothek genutzt wird.  Daher sollte davon ausgegangen werden, dass die Anwendung sehr kritische Aufgaben lösen kann.  Deshalb ist es nicht gut, es nur zu töten, indem man den <i>Ausgang</i> ruft.  Höchstwahrscheinlich wird ein solches Programm unter Berücksichtigung der Möglichkeit eines Speichermangels geschrieben und kann in diesem Fall etwas bewirken.  Beispielsweise kann ein CAD-System aufgrund der starken Fragmentierung des Speichers keinen geeigneten Speicherpuffer zuweisen, der für den regulären Betrieb ausreicht.  In diesem Fall ist es nicht der Grund, im Notfallmodus mit Datenverlust zu quetschen.  Das Programm bietet die Möglichkeit, das Projekt zu speichern und sich normal neu zu starten. <br><br>  In keinem Fall ist es unmöglich, sich auf <i>malloc</i> zu verlassen, dass es immer in der Lage sein wird, Speicher zuzuweisen.  Es ist nicht bekannt, auf welcher Plattform und wie die Bibliothek verwendet wird.  Wenn die Situation mit wenig Arbeitsspeicher auf einer Plattform exotisch ist, kann dies auf der anderen Plattform durchaus üblich sein. <br><br>  Wir können nicht erwarten, dass das Programm abstürzt, wenn <i>malloc</i> <i>NULL</i> zurückgibt.  Alles kann passieren.  Wie ich im <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Artikel beschrieben habe</a> , schreibt das Programm möglicherweise Daten nicht mit der Nulladresse.  Infolgedessen können einige Daten beschädigt werden, was zu unvorhersehbaren Konsequenzen führt.  Sogar <i>Memset</i> ist gefährlich.  Wenn das Auffüllen mit Daten in umgekehrter Reihenfolge erfolgt, werden zuerst einige Daten beschädigt, und dann stürzt das Programm ab.  Der Absturz kann jedoch zu spät erfolgen.  Wenn fehlerhafte Daten in parallelen Threads verwendet werden, während die <i>Memset-</i> Funktion funktioniert, können die Folgen schwerwiegend sein.  Sie können eine beschädigte Transaktion in einer Datenbank erhalten oder Befehle zum Entfernen "unnötiger" Dateien senden.  Alles hat eine Chance zu passieren.  Ich schlage einem Leser vor, sich auszudenken, was aufgrund der Verwendung von Müll im Speicher passieren könnte. <br><br>  Somit hat die Bibliothek nur eine korrekte Arbeitsweise mit den <i>Malloc-</i> Funktionen.  Sie müssen SOFORT überprüfen, ob die Funktion zurückgegeben wurde. Wenn sie NULL ist, geben Sie einen Fehlerstatus zurück. <br><br><h2>  Zusätzliche Links </h2><br><ol><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">OOM-Handhabung</a> </li><li>  Spaß mit NULL-Zeigern: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> </li><li>  Was jeder C-Programmierer über undefiniertes Verhalten wissen sollte: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 3</a> </li></ol></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de438756/">https://habr.com/ru/post/de438756/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de438746/index.html">Auf dem Weg zu den physikalischen Prinzipien der biologischen Evolution. Fortsetzung</a></li>
<li><a href="../de438748/index.html">Infrastruktur als Code gewinnen wir auf einer Skala (Kirill Vetchinkin, TYME)</a></li>
<li><a href="../de438750/index.html">Zivilisation der Quellen, 4/5</a></li>
<li><a href="../de438752/index.html">Buchhaltung direkt bei der Bank: Wie man einzelne Unternehmer glücklich macht</a></li>
<li><a href="../de438754/index.html">Wie wir die Netzwerküberwachung für 14.000 Objekte durchgeführt haben</a></li>
<li><a href="../de438758/index.html">Warum ändert Google die Standard-URL-Oberfläche im Browser?</a></li>
<li><a href="../de438762/index.html">DBX: Versuchen Sie, das Kompilieren von MySQL-Abfragen zu vermeiden</a></li>
<li><a href="../de438764/index.html">Sechster Chromtest, Nachwort</a></li>
<li><a href="../de438766/index.html">Extrazelluläre DNA als Biomarker des Alterns und verschiedener Pathologien</a></li>
<li><a href="../de438768/index.html">Wie ich Alice half, nicht auf andere Namen zu antworten. Yandex Praktikum</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>