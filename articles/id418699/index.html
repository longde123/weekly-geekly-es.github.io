<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🐍 🍚 🥧 Membuat mesin arcade emulator. Bagian 3 🏖️ 👰🏼 📿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagian satu dan dua . 

 8080 prosesor emulator 
 Shell emulator 
 Anda sekarang harus memiliki semua pengetahuan yang diperlukan untuk mulai membuat ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Membuat mesin arcade emulator. Bagian 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/418699/"><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/4ec/e50/f3a/4ece50f3a555bfb39878326ec26addd5.jpg" alt="gambar"></div><br>  Bagian <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">satu</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dua</a> . <br><br><h1>  8080 prosesor emulator </h1><br><h1>  Shell emulator </h1><br>  Anda sekarang harus memiliki semua pengetahuan yang diperlukan untuk mulai membuat emulator prosesor 8080. <br><br>  <em>Saya akan mencoba membuat kode saya sejelas mungkin, setiap opcode diimplementasikan secara terpisah.</em>  <em>Ketika Anda merasa nyaman dengan itu, Anda mungkin ingin menulis ulang untuk mengoptimalkan kinerja atau menggunakan kembali kode.</em> <br><br>  Untuk memulainya, saya akan membuat struktur memori yang akan berisi bidang untuk semua yang tampaknya perlu bagi saya ketika menulis disassembler.  Juga akan ada tempat untuk buffer memori, yang akan menjadi RAM. <br><a name="habracut"></a><br><pre><code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConditionCodes</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> z:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> s:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> p:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> cy:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> ac:<span class="hljs-number"><span class="hljs-number">1</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> pad:<span class="hljs-number"><span class="hljs-number">3</span></span>; } ConditionCodes; <span class="hljs-keyword"><span class="hljs-keyword">typedef</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">State8080</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> a; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> b; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> c; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> d; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> e; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> h; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> l; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> sp; <span class="hljs-keyword"><span class="hljs-keyword">uint16_t</span></span> pc; <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> *memory; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ConditionCodes</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">cc</span></span></span><span class="hljs-class">;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">uint8_t</span></span> int_enable; } State8080;</code> </pre> <br>  Sekarang buat prosedur dengan panggilan kesalahan yang akan mengakhiri program dengan kesalahan.  Akan terlihat seperti ini: <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">UnimplementedInstruction</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State8080* state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// pc    ,     printf ("Error: Unimplemented instruction\n"); exit(1); } int Emulate8080Op(State8080* state) { unsigned char *opcode = &amp;state-&gt;memory[state-&gt;pc]; switch(*opcode) { case 0x00: UnimplementedInstruction(state); break; case 0x01: UnimplementedInstruction(state); break; case 0x02: UnimplementedInstruction(state); break; case 0x03: UnimplementedInstruction(state); break; case 0x04: UnimplementedInstruction(state); break; /*....*/ case 0xfe: UnimplementedInstruction(state); break; case 0xff: UnimplementedInstruction(state); break; } state-&gt;pc+=1; //  }</span></span></code> </pre> <br>  Mari kita implementasikan beberapa opcodes. <br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Emulate8080Op</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State8080* state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *opcode = &amp;state-&gt;memory[state-&gt;pc]; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(*opcode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span>; <span class="hljs-comment"><span class="hljs-comment">//NOP -  ! case 0x01: //LXI B, state-&gt;c = opcode[1]; state-&gt;b = opcode[2]; state-&gt;pc += 2; //   2  break; /*....*/ case 0x41: state-&gt;b = state-&gt;c; break; //MOV B,C case 0x42: state-&gt;b = state-&gt;d; break; //MOV B,D case 0x43: state-&gt;b = state-&gt;e; break; //MOV B,E } state-&gt;pc+=1; }</span></span></code> </pre> <br>  Itu dia.  Untuk setiap opcode, kami mengubah status dan memori, seperti yang dilakukan perintah pada 8080 yang sebenarnya. <br><br>  8080 memiliki sekitar 7 jenis, tergantung bagaimana Anda mengklasifikasikannya: <br><br><ul><li>  Transfer data </li><li>  Aritmatika </li><li>  Logis </li><li>  Cabang </li><li>  Tumpukan </li><li>  Input-output </li><li>  Spesial </li></ul><br>  Mari kita lihat masing-masing secara individual. <br><br><h1>  Grup aritmatika </h1><br>  Instruksi aritmatika banyak dari 256 opcode dari prosesor 8080, yang mencakup berbagai macam penjumlahan dan pengurangan.  Sebagian besar instruksi aritmatika bekerja dengan register A dan menyimpan hasilnya dalam A. (Register A juga disebut akumulator). <br><br>  Sangat menarik untuk dicatat bahwa perintah-perintah ini mempengaruhi kode kondisi.  Kode negara (juga disebut bendera) diatur tergantung pada hasil dari perintah yang dieksekusi.  Tidak semua perintah memengaruhi flag, dan tidak semua tim yang memengaruhi flag memengaruhi semua flag sekaligus. <br><br><h3>  Bendera 8080 </h3><br>  Dalam prosesor 8080, bendera disebut Z, S, P, CY, dan AC. <br><br><ul><li>  Z (nol, nol) mengambil nilai 1 saat hasilnya nol </li><li>  S (tanda) mengambil nilai 1 ketika bit 7 (bit paling signifikan, bit paling signifikan, MSB) dari perintah matematika diberikan </li><li>  P (parity, parity) diatur ketika hasilnya genap, dan diatur ulang ketika ganjil </li><li>  CY (carry) mengambil nilai 1 ketika, sebagai hasil dari perintah, transfer atau pinjam ke bit orde tinggi dilakukan </li><li>  AC (bantu bantu) terutama digunakan untuk matematika BCD (desimal berkode biner).  Untuk detail lebih lanjut, lihat manual, di Space Invaders flag ini tidak digunakan. </li></ul><br>  Kode negara digunakan dalam perintah cabang bersyarat, misalnya, JZ melakukan percabangan hanya jika bendera Z diatur. <br><br>  Sebagian besar instruksi memiliki tiga bentuk: untuk register, untuk nilai langsung, dan untuk memori.  Mari kita terapkan beberapa instruksi untuk memahami formulir mereka dan melihat seperti apa bentuk kode negara.  (Perhatikan bahwa saya tidak mengimplementasikan flag transfer tambahan karena tidak digunakan. Jika saya mengimplementasikannya, saya tidak bisa mengujinya.) <br><br><h4>  Formulir Pendaftaran </h4><br>  Berikut adalah contoh implementasi dari dua instruksi dengan formulir register;  di yang pertama, saya menggunakan kode untuk membuatnya lebih mudah dipahami, dan yang kedua, bentuk yang lebih ringkas yang melakukan hal yang sama disajikan. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x80</span></span>: <span class="hljs-comment"><span class="hljs-comment">//ADD B { //      , //      uint16_t answer = (uint16_t) state-&gt;a + (uint16_t) state-&gt;b; //  :    , //    , //      if ((answer &amp; 0xff) == 0) state-&gt;cc.z = 1; else state-&gt;cc.z = 0; //  :   7 , //    , //      if (answer &amp; 0x80) state-&gt;cc.s = 1; else state-&gt;cc.s = 0; //   if (answer &gt; 0xff) state-&gt;cc.cy = 1; else state-&gt;cc.cy = 0; //    state-&gt;cc.p = Parity( answer &amp; 0xff); state-&gt;a = answer &amp; 0xff; } //  ADD     case 0x81: //ADD C { uint16_t answer = (uint16_t) state-&gt;a + (uint16_t) state-&gt;c; state-&gt;cc.z = ((answer &amp; 0xff) == 0); state-&gt;cc.s = ((answer &amp; 0x80) != 0); state-&gt;cc.cy = (answer &gt; 0xff); state-&gt;cc.p = Parity(answer&amp;0xff); state-&gt;a = answer &amp; 0xff; }</span></span></code> </pre> <br>  Saya meniru perintah matematika 8-bit dengan angka 16-bit.  Ini membuatnya lebih mudah untuk melacak kasus di mana perhitungan menghasilkan carry. <br><br><h4>  Formulir untuk nilai langsung </h4><br>  Bentuk untuk nilai langsung hampir sama, kecuali bahwa byte setelah perintah adalah sumber yang ditambahkan.  Karena "opcode" adalah penunjuk ke perintah saat ini dalam memori, opcode [1] akan langsung menjadi byte berikutnya. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xC6</span></span>: <span class="hljs-comment"><span class="hljs-comment">//ADI  { uint16_t answer = (uint16_t) state-&gt;a + (uint16_t) opcode[1]; state-&gt;cc.z = ((answer &amp; 0xff) == 0); state-&gt;cc.s = ((answer &amp; 0x80) != 0); state-&gt;cc.cy = (answer &gt; 0xff); state-&gt;cc.p = Parity(answer&amp;0xff); state-&gt;a = answer &amp; 0xff; }</span></span></code> </pre> <br><h4>  Bentuk untuk memori </h4><br>  Dalam bentuk untuk memori, byte akan ditambahkan ke mana alamat yang disimpan dalam sepasang register HL menunjukkan. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x86</span></span>: <span class="hljs-comment"><span class="hljs-comment">//ADD M { uint16_t offset = (state-&gt;h&lt;&lt;8) | (state-&gt;l); uint16_t answer = (uint16_t) state-&gt;a + state-&gt;memory[offset]; state-&gt;cc.z = ((answer &amp; 0xff) == 0); state-&gt;cc.s = ((answer &amp; 0x80) != 0); state-&gt;cc.cy = (answer &gt; 0xff); state-&gt;cc.p = Parity(answer&amp;0xff); state-&gt;a = answer &amp; 0xff; }</span></span></code> </pre> <br><h3>  Catatan </h3><br>  Instruksi aritmatika yang tersisa diimplementasikan dengan cara yang serupa.  Tambahan: <br><br><ul><li>  Dalam versi yang berbeda dengan carry (ADC, ACI, SBB, SUI), sesuai dengan manual referensi, kami menggunakan bit carry dalam perhitungan. </li><li>  INX dan DCX mempengaruhi pasangan register, perintah ini tidak mempengaruhi flag. </li><li>  AYAH adalah perintah lain dari sepasang register, hanya memengaruhi flag carry </li><li>  INR dan DCR tidak mempengaruhi flag carry </li></ul><br><h1>  Grup cabang </h1><br>  Setelah Anda berurusan dengan kode negara, grup cabang akan menjadi cukup jelas untuk Anda.  Ada dua jenis percabangan - transisi (JMP) dan panggilan (PANGGILAN).  JMP hanya mengatur PC ke nilai tujuan lompat.  PANGGILAN digunakan untuk rutinitas, ia menulis alamat pengirim ke tumpukan, dan kemudian menetapkan alamat tujuan PC.  RET kembali dari CALL, menerima alamat dari tumpukan dan menuliskannya ke PC. <br><br>  Baik JMP dan CALL hanya pergi ke alamat absolut yang dikodekan dalam byte setelah opcode. <br><br><h3>  Jmp </h3><br>  Perintah JMP bercabang tanpa syarat ke alamat tujuan.  Ada juga perintah cabang bersyarat untuk semua kode status (kecuali untuk AC): <br><br><ul><li>  JNZ dan JZ untuk nol </li><li>  JNC dan JC untuk migrasi </li><li>  JPO dan JPE untuk paritas </li><li>  JP (plus) dan JM (minus) untuk tanda </li></ul><br>  Berikut ini adalah implementasi dari beberapa di antaranya: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xc2</span></span>: <span class="hljs-comment"><span class="hljs-comment">//JNZ  if (0 == state-&gt;cc.z) state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; else //    state-&gt;pc += 2; break; case 0xc3: //JMP  state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; break;</span></span></code> </pre> <br><h3>  PANGGILAN dan RET </h3><br>  PANGGILAN mendorong alamat instruksi ke tumpukan setelah panggilan, dan kemudian melompat ke alamat tujuan.  RET menerima alamat dari tumpukan dan menyimpannya di PC.  Versi bersyarat dari CALL dan RET ada untuk semua negara. <br><br><ul><li>  CZ, CNZ, RZ, RNZ untuk nol </li><li>  CNC, CC, RNC, RC untuk transfer </li><li>  CPO, CPE, RPO, RPE untuk paritas </li><li>  CP, CM, RP, RM untuk tanda </li></ul><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xcd</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CALL  { uint16_t ret = state-&gt;pc+2; state-&gt;memory[state-&gt;sp-1] = (ret &gt;&gt; 8) &amp; 0xff; state-&gt;memory[state-&gt;sp-2] = (ret &amp; 0xff); state-&gt;sp = state-&gt;sp - 2; state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; } break; case 0xc9: //RET state-&gt;pc = state-&gt;memory[state-&gt;sp] | (state-&gt;memory[state-&gt;sp+1] &lt;&lt; 8); state-&gt;sp += 2; break;</span></span></code> </pre> <br><h3>  Catatan </h3><br><ul><li>  Perintah PCHL tanpa syarat melompat ke alamat di sepasang register HL. </li><li>  Saya tidak memasukkan RST yang sebelumnya dibahas dalam grup ini.  Itu menulis alamat kembali ke tumpukan, dan kemudian melompat ke alamat yang telah ditentukan di bagian bawah memori. </li></ul><br><h1>  Grup yang logis </h1><br>  Grup ini melakukan operasi logis (lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">posting pertama</a> tutorial).  Secara alami, mereka mirip dengan grup aritmatika di mana sebagian besar operasi bekerja dengan register A (drive), dan sebagian besar operasi mempengaruhi flag.  Semua operasi dilakukan pada nilai 8-bit, dalam grup ini tidak ada perintah yang mempengaruhi pasangan register. <br><br><h3>  Operasi Boolean </h3><br>  DAN, ATAU, TIDAK (CMP) dan "eksklusif atau" (XOR) disebut operasi Boolean.  ATAU dan DAN saya jelaskan sebelumnya.  Perintah NOT (untuk prosesor 8080 itu disebut CMA, atau akumulator komplemen) hanya mengubah nilai bit - semua unit menjadi nol, dan nol menjadi yang. <br><br>  Saya menganggap XOR sebagai "pengenal perbedaan".  Tabel kebenarannya terlihat seperti ini: <br><br><table><tbody><tr><td>  x </td><td>  y </td><td>  Hasil </td></tr><tr><td>  0 </td><td>  0 </td><td>  0 </td></tr><tr><td>  0 </td><td>  1 </td><td>  1 </td></tr><tr><td>  1 </td><td>  0 </td><td>  1 </td></tr><tr><td>  1 </td><td>  1 </td><td>  0 </td></tr></tbody></table><br>  AND, OR, dan XOR memiliki formulir untuk register, memori, dan nilai langsung.  (CMP hanya memiliki perintah case-sensitive).  Berikut ini adalah implementasi dari sepasang opcode: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x2F</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CMA (not) state-&gt;a = ~state-&gt;a //  ,  CMA     break; case 0xe6: //ANI  { uint8_t x = state-&gt;a &amp; opcode[1]; state-&gt;cc.z = (x == 0); state-&gt;cc.s = (0x80 == (x &amp; 0x80)); state-&gt;cc.p = parity(x, 8); state-&gt;cc.cy = 0; //  ,  ANI  CY state-&gt;a = x; state-&gt;pc++; //   } break;</span></span></code> </pre> <br><h3>  Perintah shift siklik </h3><br>  Perintah-perintah ini mengubah urutan bit dalam register.  Pergeseran ke kanan menggerakkan mereka sedikit demi sedikit, dan pergeseran ke kiri - kiri sedikit: <br><br> <code>  (0b00010000) = 0b00001000</code> <br> <br> <code>  (0b00000001) = 0b00000010</code> <br> <br>  Mereka tampaknya tidak berharga, tetapi kenyataannya tidak demikian.  Mereka dapat digunakan untuk berkembang biak dan membelah dengan kekuatan dua.  Ambil shift kiri sebagai contoh.  <code>0b00000001</code> adalah desimal 1, dan menggesernya ke kiri menjadikannya <code>0b00000010</code> , yaitu, desimal 2. Jika kita melakukan shift lain ke kiri, kita mendapatkan <code>0b00000100</code> , yaitu 4. Pergeseran lain ke kiri, dan kita dikalikan dengan 8. Ini akan bekerja dengan semua dengan angka: 5 ( <code>0b00000101</code> ) ketika bergeser ke kiri memberi 10 ( <code>0b00001010</code> ).  Pergeseran kiri lain memberi 20 ( <code>0b00010100</code> ).  Pergeseran ke kanan melakukan hal yang sama, tetapi untuk pembagian. <br><br>  8080 tidak memiliki perintah multiplikasi, tetapi dapat diimplementasikan menggunakan perintah ini.  Jika Anda mengerti bagaimana melakukan ini, Anda akan menerima poin bonus.  Suatu kali pertanyaan semacam itu diajukan kepada saya pada sebuah wawancara.  (Ya, meskipun butuh beberapa menit.) <br><br>  Perintah-perintah ini memutar drive secara siklis dan hanya memengaruhi flag carry.  Berikut ini beberapa perintah: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x0f</span></span>: <span class="hljs-comment"><span class="hljs-comment">//RRC { uint8_t x = state-&gt;a; state-&gt;a = ((x &amp; 1) &lt;&lt; 7) | (x &gt;&gt; 1); state-&gt;cc.cy = (1 == (x&amp;1)); } break; case 0x1f: //RAR { uint8_t x = state-&gt;a; state-&gt;a = (state-&gt;cc.cy &lt;&lt; 7) | (x &gt;&gt; 1); state-&gt;cc.cy = (1 == (x&amp;1)); } break;</span></span></code> </pre> <br><h3>  Perbandingan </h3><br>  Tugas CMP dan CPI hanya mengatur bendera (untuk percabangan).  Mereka melakukan ini dengan mengurangi flag, tetapi tidak menyimpan hasilnya. <br><br><ul><li>  Sama: jika dua angka sama, maka bendera Z diatur, karena pengurangan satu sama lain memberi nol. </li><li>  Lebih besar dari: jika A lebih besar dari nilai yang dibandingkan, maka bendera CY dihapus (karena pengurangan dapat dilakukan tanpa meminjam). </li><li>  Lebih kecil: jika A kurang dari nilai yang dibandingkan, maka flag CY diatur (karena A harus menyelesaikan pinjaman untuk menyelesaikan pengurangan). </li></ul><br>  Ada versi perintah ini untuk register, memori, dan nilai langsung.  Implementasinya adalah pengurangan sederhana tanpa menyimpan hasilnya: <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xfe</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CPI  { uint8_t x = state-&gt;a - opcode[1]; state-&gt;cc.z = (x == 0); state-&gt;cc.s = (0x80 == (x &amp; 0x80)); //  ,    p -   state-&gt;cc.p = parity(x, 8); state-&gt;cc.cy = (state-&gt;a &lt; opcode[1]); state-&gt;pc++; } break;</span></span></code> </pre> <br><h3>  CMC dan STC </h3><br>  Mereka melengkapi grup logis.  Mereka digunakan untuk mengatur dan menghapus bendera carry. <br><br><h1>  Kelompok input-output dan perintah khusus </h1><br>  Perintah-perintah ini tidak dapat ditugaskan ke kategori lain mana pun.  Saya akan menyebut mereka untuk kelengkapan, tetapi bagi saya tampaknya kita harus kembali kepada mereka lagi ketika kita mulai meniru perangkat keras Space Invaders. <br><br><ul><li>  EI dan DI mengaktifkan atau menonaktifkan kemampuan prosesor untuk menangani interupsi.  Saya menambahkan flag interrupt_enabled ke struktur status prosesor, dan mengatur / mengatur ulang menggunakan perintah ini. </li><li>  Tampaknya RIM dan SIM terutama digunakan untuk serial I / O.  Jika Anda tertarik, Anda dapat membaca manual, tetapi perintah ini tidak digunakan di Space Invaders.  Saya tidak akan meniru mereka. </li><li>  HLT berhenti.  Saya pikir kami tidak perlu meniru, tetapi Anda dapat memanggil kode Anda yang keluar (atau keluar (0)) ketika Anda melihat perintah ini. </li><li>  IN dan OUT adalah perintah yang digunakan peralatan prosesor 8080 untuk berkomunikasi dengan peralatan eksternal.  Saat kami mengimplementasikannya, tetapi mereka tidak akan melakukan apa pun selain melewatkan byte data mereka.  (Nanti kita akan kembali ke mereka). </li><li>  NOP adalah "tidak ada operasi".  Salah satu aplikasi NOP adalah untuk mengontrol waktu panel (dibutuhkan empat siklus CPU untuk menjalankan). </li></ul><br>  Aplikasi NOP lainnya adalah modifikasi kode.  Katakanlah kita perlu mengubah kode ROM game.  Kami tidak bisa hanya menghapus opcodes yang tidak perlu, karena kami tidak ingin mengubah semua perintah CALL dan JMP (mereka akan salah jika setidaknya satu bagian dari kode bergerak).  Dengan NOP kita dapat menyingkirkan kode tersebut.  <em>Menambahkan kode jauh lebih sulit!</em>  <em>Anda dapat menambahkannya dengan menemukan ruang di suatu tempat di ROM dan mengubah perintah ke JMP.</em> <br><br><h1>  Kelompok tumpukan </h1><br>  Kami telah menyelesaikan mekanisme untuk sebagian besar tim dalam kelompok tumpukan.  Jika Anda melakukan pekerjaan dengan saya, maka perintah ini akan mudah diimplementasikan. <br><br><h3>  PUSH dan POP </h3><br>  PUSH dan POP hanya berfungsi dengan pasangan register.  PUSH menulis sepasang register ke stack, dan POP mengambil 2 byte dari atas stack dan menulisnya ke sepasang register. <br><br>  Ada empat opcode untuk PUSH dan POP, satu untuk masing-masing pasangan: BC, DE, HL dan PSW.  PSW adalah sepasang register bendera drive dan kode status khusus.  Berikut ini adalah implementasi PUSH dan POP untuk BC dan PSW.  Tidak ada komentar di dalamnya - Saya tidak berpikir ada sesuatu yang sangat rumit di sini. <br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xc1</span></span>: <span class="hljs-comment"><span class="hljs-comment">//POP B { state-&gt;c = state-&gt;memory[state-&gt;sp]; state-&gt;b = state-&gt;memory[state-&gt;sp+1]; state-&gt;sp += 2; } break; case 0xc5: //PUSH B { state-&gt;memory[state-&gt;sp-1] = state-&gt;b; state-&gt;memory[state-&gt;sp-2] = state-&gt;c; state-&gt;sp = state-&gt;sp - 2; } break; case 0xf1: //POP PSW { state-&gt;a = state-&gt;memory[state-&gt;sp+1]; uint8_t psw = state-&gt;memory[state-&gt;sp]; state-&gt;cc.z = (0x01 == (psw &amp; 0x01)); state-&gt;cc.s = (0x02 == (psw &amp; 0x02)); state-&gt;cc.p = (0x04 == (psw &amp; 0x04)); state-&gt;cc.cy = (0x05 == (psw &amp; 0x08)); state-&gt;cc.ac = (0x10 == (psw &amp; 0x10)); state-&gt;sp += 2; } break; case 0xf5: //PUSH PSW { state-&gt;memory[state-&gt;sp-1] = state-&gt;a; uint8_t psw = (state-&gt;cc.z | state-&gt;cc.s &lt;&lt; 1 | state-&gt;cc.p &lt;&lt; 2 | state-&gt;cc.cy &lt;&lt; 3 | state-&gt;cc.ac &lt;&lt; 4 ); state-&gt;memory[state-&gt;sp-2] = psw; state-&gt;sp = state-&gt;sp - 2; } break;</span></span></code> </pre> <br><h3>  SPHL dan XTHL </h3><br>  Ada dua tim lagi dalam kelompok tumpukan - SPHL dan XTHL. <br><br><ul><li>  <code>SPHL</code> memindahkan HL ke SP (memaksa SP untuk mendapatkan alamat baru). </li><li>  <code>XTHL</code> menukar apa yang ada di atas tumpukan dengan apa yang ada di sepasang register HL.  Mengapa Anda perlu melakukan ini?  Saya tidak tahu. </li></ul><br><h1>  Sedikit lagi tentang angka biner </h1><br>  Saat menulis program komputer, salah satu keputusan yang perlu Anda buat adalah memilih jenis data yang digunakan untuk angka - apakah Anda ingin mereka menjadi negatif dan berapa ukuran maksimumnya.  Untuk emulator CPU, kita membutuhkan tipe data yang cocok dengan tipe data CPU target. <br><br><h3>  Ditandatangani dan tidak ditandatangani </h3><br>  Ketika kami mulai berbicara tentang bilangan hex, kami menganggapnya tidak bertanda - yaitu, setiap digit biner dari bilangan heksadesimal memiliki nilai positif, dan masing-masing dianggap sebagai kekuatan dua (unit, dua, empat, dll.). <br><br>  Kami berurusan dengan masalah penyimpanan komputer dari angka negatif.  Jika Anda tahu bahwa data yang dimaksud memiliki tanda, yaitu, mereka bisa negatif, maka Anda dapat mengenali angka negatif dengan bit paling signifikan dari nomor tersebut (bit paling signifikan, MSB).  Jika ukuran data adalah satu byte, maka setiap angka dengan nilai bit MSB yang diberikan adalah negatif, dan masing-masing dengan nol MSB adalah positif. <br><br>  Nilai angka negatif disimpan sebagai kode tambahan.  Jika kami memiliki nomor yang ditandatangani, dan MSB sama dengan satu, dan kami ingin mengetahui apa nomor ini, maka kami dapat mengonversinya sebagai berikut: melakukan biner "TIDAK" untuk angka hex, dan kemudian menambahkannya. <br><br>  Misalnya, untuk bilangan hex 0x80, bit MSB diatur, yaitu negatif.  Biner “TIDAK” dari angka 0x80 adalah 0x7f, atau desimal 127. 127 + 1 = 128. Artinya, 0x80 dalam desimal adalah -128.  Contoh kedua: 0xC5.  Tidak (0xC5) = 0x3A = desimal 58 +1 = desimal 59. Artinya, 0xC5 adalah desimal -59. <br><br>  Yang mengejutkan dalam angka-angka dengan kode tambahan adalah kita dapat melakukan perhitungan dengan angka-angka itu seperti angka-angka yang tidak ditandatangani, dan mereka <em>akan</em> tetap <em>berfungsi</em> .  Komputer tidak perlu melakukan sesuatu yang khusus dengan tanda-tanda.  Saya akan menunjukkan beberapa contoh yang membuktikan hal ini. <br><br><pre>  Contoh 1<font></font>
<font></font>
      biner hex desimal    
       -3 0xFD 1111 1101    
    + 10 0x0A +0000 1010    
    ----- -----------    
        7 0x07 1 0000 0111    
                        ^ Ini direkam dalam carry bit<font></font>
<font></font>
    Contoh 2    <font></font>
<font></font>
      biner hex desimal    
      -59 0xC5 1100 0101    
    + 33 0x21 +0010 0001    
    ----- -----------    
      -26 0xE6 1110 0110 </pre><br><br>  Dalam Contoh 1, kita melihat bahwa menambahkan hasil 10 dan -3 di 7. Hasil tambahan ditransfer, sehingga bendera C. Dapat diatur dalam Contoh 2, hasil penambahan negatif, jadi kami memecahkan kode ini: Tidak (0xE6) = 0x19 = 25 + 1 = 26. <code>0xE6 = -26</code> Ledakan otak! <br><br>  Jika Anda mau, baca lebih lanjut tentang kode tambahan di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Wikipedia</a> . <br><br><h3>  Tipe data </h3><br>  Di C, ada hubungan antara tipe data dan jumlah byte yang digunakan untuk tipe ini.  Faktanya, kami hanya tertarik pada bilangan bulat.  Tipe data C sekolah standar / lama adalah char, int, dan long, serta teman-teman mereka unsigned char, unsigned int, dan unsigned long.  Masalahnya adalah bahwa pada platform yang berbeda dan pada kompiler yang berbeda, tipe ini dapat memiliki ukuran yang berbeda. <br><br>  Oleh karena itu, yang terbaik adalah memilih tipe data untuk platform kami yang menyatakan ukuran data secara eksplisit.  Jika platform Anda memiliki stdint.h, maka Anda dapat menggunakan int8_t, uint8_t, dll. <br><br>  Ukuran bilangan bulat menentukan jumlah maksimum yang dapat disimpan di dalamnya.  Dalam kasus bilangan bulat tak bertanda, Anda dapat menyimpan angka dari 0 hingga 255 dalam 8 bit. Jika Anda menerjemahkan ke dalam hex, maka dari 0x00 hingga 0xFF.  Karena 0xFF memiliki "semua bit diatur", dan itu sesuai dengan desimal 255, sangat logis bahwa interval integer unsigned byte tunggal adalah 0-255.  Interval memberi tahu kami bahwa semua ukuran bilangan bulat akan bekerja persis sama - angka sesuai dengan angka yang diperoleh saat semua bit diatur. <br><br><table><tbody><tr><th>  Jenis </th><th>  Interval </th><th>  Hex </th></tr><tr><td>  8-bit tidak ditandatangani </td><td>  0-255 </td><td>  0x0-0xFF </td></tr><tr><td>  8-bit ditandatangani </td><td>  -128-127 </td><td>  0x80-0x7F </td></tr><tr><td>  16-bit tidak ditandatangani </td><td>  0-65535 </td><td>  0x0-0xFFFF </td></tr><tr><td>  Ditandatangani 16-bit </td><td>  -32768-32767 </td><td>  0x8000-0x7FFF </td></tr><tr><td>  32-bit tidak ditandatangani </td><td>  0-4294967295 </td><td>  0x0-0xFFFFFFFFFF </td></tr><tr><td>  32-bit ditandatangani </td><td>  -2147483648-2147483647 </td><td>  0x80000000-0x7FFFFFFF </td></tr></tbody></table><br>  Yang lebih menarik adalah bahwa -1 dalam setiap tipe data yang ditandatangani adalah angka yang memiliki semua bit yang ditetapkan (0xFF untuk byte yang ditandatangani, 0xFFFF untuk nomor 16-bit yang ditandatangani, dan 0xFFFFFFFF untuk jumlah 32-bit yang ditandatangani).  Jika data dianggap tidak ditandatangani, maka untuk semua bit yang diberikan, jumlah maksimum yang mungkin untuk tipe data ini diperoleh. <br><br>  Untuk meniru register prosesor, kami memilih tipe data yang sesuai dengan ukuran register ini.  Mungkin bermanfaat untuk memilih jenis yang tidak ditandatangani secara default dan mengonversinya ketika Anda perlu mempertimbangkannya ditandatangani.  Misalnya, kami menggunakan tipe data uint8_t untuk mewakili register 8-bit. <br><br><h3>  Petunjuk: gunakan debugger untuk mengonversi tipe data </h3><br>  Jika gdb diinstal pada platform Anda, maka sangat nyaman untuk menggunakannya untuk bekerja dengan angka biner.  Di bawah ini saya akan menunjukkan contoh - dalam sesi yang ditunjukkan di bawah ini, baris yang dimulai dengan # adalah komentar yang saya tambahkan nanti. <br><br> <code>#  /c,   gdb      <br> (gdb) print /c 0xFD <br> $1 = -3 '?' <br> <br> #  /x,   gdb    hex <br> #   "p"  "print" <br> (gdb) p /c 0xA <br> $2 = 10 '\n' <br> <br> #    2  " " <br> (gdb) p /c 0xC5 <br> $3 = -59 '?' <br> (gdb) p /c 0xC5+0x21 <br> $4 = -26 '?' <br> <br> #  print  ,  gdb    <br> (gdb) p 0x21 <br> $9 = 33 <br> <br> #     ,     gdb, <br> #  ,      <br> (gdb) p 0xc5 <br> $5 = 197 # <br> (gdb) p /c 0xc5 <br> $3 = -59 '?' # <br> (gdb) p 0xfd <br> $6 = 253 <br> <br> #        (   32- ) <br> (gdb) p /x -3 <br> $7 = 0xfffffffd <br> <br> #   1     <br> (gdb) print (char) 0xff <br> $1 = -1 '?' <br> #   1     <br> (gdb) print (unsigned char) 0xff <br> $2 = 255 '?'</code> <br> <br>  Ketika saya bekerja dengan angka hex, saya selalu melakukannya di gdb - dan itu terjadi hampir setiap hari.  Jauh lebih mudah daripada membuka kalkulator programmer dengan GUI.  Pada mesin Linux (dan Mac OS X), untuk memulai sesi gdb, cukup buka terminal dan masukkan "gdb".  Jika Anda menggunakan Xcode pada OS X, maka setelah memulai program, Anda dapat menggunakan konsol di dalam Xcode (yang mana output printf adalah output).<font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Di Windows, debugger gdb tersedia dari Cygwin. </font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pemutusan Emulator CPU </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah menerima semua informasi ini, Anda siap untuk perjalanan panjang. </font><font style="vertical-align: inherit;">Anda harus memutuskan bagaimana Anda menerapkan emulator - baik membuat emulasi 8080 penuh, atau hanya menerapkan perintah yang diperlukan untuk menyelesaikan permainan. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda memutuskan untuk melakukan emulasi penuh, maka Anda akan memerlukan beberapa alat lagi. </font><font style="vertical-align: inherit;">Saya akan membicarakannya di bagian selanjutnya. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara lain adalah meniru hanya instruksi yang digunakan oleh gim. </font><font style="vertical-align: inherit;">Kami akan terus mengisi konstruksi sakelar besar yang kami buat di bagian Emulator Shell. </font><font style="vertical-align: inherit;">Kami akan mengulangi proses berikut ini sampai kami memiliki satu perintah yang belum direalisasi:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Luncurkan emulator dengan ROM Space Invaders </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Panggilan </font></font><code>UnimplementedInstruction()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">keluar jika perintah tidak siap</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tirulah instruksi ini </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kebagian 1 </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Hal pertama yang saya lakukan ketika mulai menulis emulator saya adalah menambahkan kode dari disassembler saya. </font><font style="vertical-align: inherit;">Jadi saya bisa menampilkan perintah yang harus dijalankan sebagai berikut:</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Emulate8080Op</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(State8080* state)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">char</span></span> *opcode = &amp;state-&gt;memory[state-&gt;pc]; Disassemble8080Op(state-&gt;memory, state-&gt;pc); <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (*opcode) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0x00</span></span>: <span class="hljs-comment"><span class="hljs-comment">//NOP /* ... */ } /*    */ printf("\tC=%d,P=%d,S=%d,Z=%d\n", state-&gt;cc.cy, state-&gt;cc.p, state-&gt;cc.s, state-&gt;cc.z); printf("\tA $%02x B $%02x C $%02x D $%02x E $%02x H $%02x L $%02x SP %04x\n", state-&gt;a, state-&gt;b, state-&gt;c, state-&gt;d, state-&gt;e, state-&gt;h, state-&gt;l, state-&gt;sp); }</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya juga menambahkan kode di akhir untuk menampilkan semua register dan flag negara. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Berita baik: untuk mempelajari program untuk 50 ribu tim, kita hanya perlu subset dari 8080 opcodes. Aku bahkan akan memberikan daftar opcode yang perlu diimplementasikan:</font></font><br><br><table><tbody><tr><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Opcode </font></font></th><th><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tim </font></font></th></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x00 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tidak </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x01 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LXI B, D16 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x05 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DCR B </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x06 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI B, D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x09 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ayah b </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x0d </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> DCR C </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x0e </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI C, D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x0f </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Rrc </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x11 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LXI D, D16 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x13 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inx d </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x19 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ayah d </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x1a </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LDAX D </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x21 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LXI H, D16 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x23 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Inx h </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x26 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI H, D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x29 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ayah h </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x31 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> LXI SP, D16 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x32 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> STA adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x36 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI M, D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x3a </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Lda adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x3e </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MVI A, D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x56 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV D, M </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x5e </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV E, M </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x66 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV H, M </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x6f </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV L, A </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x77 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV M, A </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x7a </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV A, D </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x7b </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV A, E </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x7c </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV A, H </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0x7e </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> MOV A, M </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xa7 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ANA A </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xaf </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> XRA A </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pop b </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc2 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jnz adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jmp adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PUSH B </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc6 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ADI D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xc9 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ret </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xcd </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Hubungi adr </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xd1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pop d </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xd3 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> OUT D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xd5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PUSH D </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xe1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Pop h </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xe5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PUSH H </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xe6 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ANI D8 </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xeb </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Xchg </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xf1 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> POP PSW </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xf5 </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> PUSH PSW </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xfb </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ei </font></font></td></tr><tr><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> 0xfe </font></font></td><td><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> CPI D8 </font></font></td></tr></tbody></table><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Ini hanya 50 instruksi, dan 10 di antaranya adalah gerakan yang diimplementasikan sepele. </font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Debugging </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tapi saya punya kabar buruk. </font><font style="vertical-align: inherit;">Emulator Anda hampir pasti tidak akan berfungsi dengan benar, dan bug dalam kode semacam itu sangat sulit ditemukan. </font><font style="vertical-align: inherit;">Jika Anda tahu perintah mana yang berperilaku buruk (misalnya, transisi atau panggilan ke kode yang tidak berarti), maka Anda dapat mencoba untuk memperbaiki kesalahan dengan memeriksa kode Anda. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Selain meneliti kode, ada cara lain untuk memperbaiki masalah - dengan membandingkan emulator Anda dengan yang benar-benar berfungsi. </font><font style="vertical-align: inherit;">Kami berasumsi bahwa emulator lain selalu berfungsi dengan benar, dan semua perbedaannya adalah bug di emulator Anda. </font><font style="vertical-align: inherit;">Misalnya, Anda dapat menggunakan emulator saya. </font><font style="vertical-align: inherit;">Anda dapat secara manual menjalankannya secara paralel. </font><font style="vertical-align: inherit;">Anda dapat menghemat waktu jika Anda mengintegrasikan kode saya ke proyek Anda untuk mendapatkan proses berikut:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Buat status untuk emulator Anda </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Buat negara untuk milikku </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Untuk tim selanjutnya </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Memanggil emulator Anda dengan negara Anda </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Memanggil milikku dengan keberuntunganku </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bandingkan dua negara kami </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mencari kesalahan dalam perbedaan apa pun </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> kebagian 3 </font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Cara lain adalah dengan menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">situs ini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> secara manual </font><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Ini adalah emulator prosesor Javascript 8080 yang bahkan menyertakan ROM Space Invaders. </font><font style="vertical-align: inherit;">Inilah prosesnya:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mulai ulang emulasi Space Invaders dengan mengklik tombol Space Invaders </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tekan tombol “Run 1” untuk menjalankan perintah. </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Kami menjalankan perintah berikut di emulator kami </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bandingkan status prosesor dengan milik Anda </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Jika kondisinya sesuai, goto 2 </font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika kondisinya tidak cocok, maka emulasi instruksi Anda salah. </font><font style="vertical-align: inherit;">Perbaiki itu, dan kemudian mulai lagi dari langkah 1.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya menggunakan metode ini di awal untuk men-debug emulator 8080 saya. Saya tidak akan berbohong - prosesnya bisa lama. Akibatnya, banyak masalah saya ternyata kesalahan ketik dan salin-tempel, yang setelah deteksi sangat mudah untuk diperbaiki. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda selangkah demi selangkah menjalankan kode Anda, maka sebagian besar dari 30 ribu instruksi pertama dieksekusi dalam siklus sekitar $ 1a5f. Jika Anda melihat </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">javascript</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> di </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">emulator</font></a><font style="vertical-align: inherit;"> , Anda dapat melihat bahwa kode ini menyalin data ke layar. Saya yakin kode ini sering dipanggil. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Setelah rendering layar pertama, setelah 50 ribu perintah, program macet di loop tanpa akhir ini:</font></font><br><br><pre> <code class="hljs pgsql"> <span class="hljs-number"><span class="hljs-number">0</span></span>ada LDA <span class="hljs-meta"><span class="hljs-meta">$20</span></span>c0 <span class="hljs-number"><span class="hljs-number">0</span></span><span class="hljs-keyword"><span class="hljs-keyword">add</span></span> ANA A <span class="hljs-number"><span class="hljs-number">0</span></span>ade JNZ <span class="hljs-meta"><span class="hljs-meta">$0</span></span>ada</code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ia menunggu hingga nilai dalam memori pada $ 20c0 berubah menjadi nol. </font><font style="vertical-align: inherit;">Karena kode dalam loop ini tidak benar-benar berubah $ 20c0, itu pasti sinyal dari tempat lain. </font><font style="vertical-align: inherit;">Sudah waktunya untuk berbicara tentang meniru "besi" dari mesin arcade. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebelum kita melanjutkan ke bagian selanjutnya, pastikan emulator CPU Anda termasuk dalam loop tanpa akhir ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Untuk referensi, lihat </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">sumber saya</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> .</font></font><br><br><h1><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Emulasi 8080 penuh </font></font></h1><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebuah pelajaran yang sangat merugikan saya: jangan menerapkan tim yang tidak dapat Anda uji. </font><font style="vertical-align: inherit;">Ini adalah aturan praktis yang baik untuk semua perangkat lunak yang sedang dikembangkan. </font><font style="vertical-align: inherit;">Jika Anda tidak memeriksa tim, maka itu pasti akan rusak. </font><font style="vertical-align: inherit;">Dan semakin jauh Anda menjauh dari implementasinya, semakin sulit untuk menemukan masalah. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada solusi lain jika Anda ingin membuat emulator 8080 penuh dan memastikannya bekerja. </font><font style="vertical-align: inherit;">Saya menemukan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">kode untuk 8080</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> bernama cpudiag.asm, yang dirancang untuk menguji setiap perintah prosesor 8080. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya memperkenalkan Anda pada proses ini setelah yang pertama karena beberapa alasan:</font></font><br><br><ol><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya ingin deskripsi proses ini diulang untuk prosesor lain. </font><font style="vertical-align: inherit;">Saya tidak berpikir bahwa analog cpudiag.asm ada untuk semua prosesor.</font></font></li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Seperti yang Anda lihat, prosesnya cukup melelahkan. </font><font style="vertical-align: inherit;">Saya pikir seorang pemula dalam debugging kode assembler akan mengalami kesulitan besar jika langkah-langkah ini tidak terdaftar.</font></font></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Begitulah cara saya menggunakan tes ini dengan emulator saya. </font><font style="vertical-align: inherit;">Anda dapat menggunakannya atau menghasilkan cara yang lebih baik untuk mengintegrasikannya.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Majelis uji </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya mencoba beberapa hal, tetapi sebagai hasilnya saya memutuskan untuk menggunakan </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">halaman yang bagus ini</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> . </font><font style="vertical-align: inherit;">Saya menempelkan teks cpudiag.asm ke panel kiri dan build selesai tanpa masalah. </font><font style="vertical-align: inherit;">Butuh beberapa saat bagi saya untuk mengetahui cara mengunduh hasil, tetapi dengan mengklik tombol "Make Beautiful Code" di kiri bawah, saya mengunduh file bernama test.bin, yang merupakan kode yang dikompilasi 8080. Saya dapat memverifikasi ini menggunakan disassembler saya. </font></font><br><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unduh cpudiag.asm</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> dari cermin di situs web saya. </font></font><br><br> <a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Unduh cpudiag.bin</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> (kode kompilasi 8080) dari situs saya.</font></font><br><br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Mengunggah tes ke emulator saya </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alih-alih memuat penyerang. * File, saya memuat biner ini. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kesulitan kecil muncul di sini. Pertama, ada baris dalam kode assembler sumber </font></font><code>ORG 00100H</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, yaitu, itu berarti bahwa seluruh file dikompilasi dengan asumsi bahwa baris pertama kode adalah 0x100 hex. Saya belum pernah menulis kode di assembler 8080 sebelumnya, jadi saya tidak tahu apa yang dilakukan baris ini. Saya hanya perlu satu menit untuk mengetahui bahwa semua alamat cabang tidak benar dan perlu untuk memulai memori pada 0x100. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Kedua, sejak emulator saya mulai dari awal, saya harus terlebih dahulu melakukan transisi ke kode sebenarnya. Setelah memasukkan nilai hex ke dalam memori di alamat nol </font></font><code>JMP $0100</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, saya berurusan dengan ini. (Atau Anda bisa menginisialisasi PC dengan nilai 0x100.)</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ketiga, saya menemukan bug dalam kode yang dikompilasi. </font><font style="vertical-align: inherit;">Saya pikir alasannya adalah pemrosesan yang salah dari baris kode terakhir </font></font><code>STACK EQU TEMPP+256</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, tapi saya tidak yakin. </font><font style="vertical-align: inherit;">Bagaimanapun, tumpukan selama kompilasi terletak pada $ 6ad, dan beberapa PUSH pertama mulai menulis ulang kode. </font><font style="vertical-align: inherit;">Saya menyarankan bahwa variabel juga harus diimbangi dengan 0x100, seperti sisa kode, jadi saya memperbaikinya dengan memasukkan "0x7" ke dalam baris kode yang menginisialisasi stack pointer. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Akhirnya, karena saya tidak mengimplementasikan DAA atau migrasi tambahan di emulator saya, saya memodifikasi kode untuk melewati pemeriksaan ini (kami hanya melewatkannya menggunakan JMP).</font></font><br><br><pre> <code class="cpp hljs"> ReadFileIntoMemoryAt(state, <span class="hljs-string"><span class="hljs-string">"/Users/kpmiller/Desktop/invaders/cpudiag.bin"</span></span>, <span class="hljs-number"><span class="hljs-number">0x100</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  ,   JMP 0x100 state-&gt;memory[0]=0xc3; state-&gt;memory[1]=0; state-&gt;memory[2]=0x01; //Fix the stack pointer from 0x6ad to 0x7ad // this 0x06 byte 112 in the code, which is // byte 112 + 0x100 = 368 in memory state-&gt;memory[368] = 0x7; //  DAA state-&gt;memory[0x59c] = 0xc3; //JMP state-&gt;memory[0x59d] = 0xc2; state-&gt;memory[0x59e] = 0x05;</span></span></code> </pre> <br><h3><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tes ini mencoba membuat kesimpulan </font></font></h3><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jelas, tes ini bergantung pada bantuan dari CP / M OS. Saya menemukan bahwa CP / M memiliki beberapa kode pada $ 0005 yang mencetak pesan ke konsol, dan mengubah emulasi PANGGILAN saya untuk menangani perilaku ini. Saya tidak yakin apakah semuanya ternyata benar, tetapi itu berfungsi untuk dua pesan yang coba dicetak oleh program. Emulasi PANGGILAN saya untuk menjalankan tes ini terlihat seperti ini:</font></font><br><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> <span class="hljs-number"><span class="hljs-number">0xcd</span></span>: <span class="hljs-comment"><span class="hljs-comment">//CALL  #ifdef FOR_CPUDIAG if (5 == ((opcode[2] &lt;&lt; 8) | opcode[1])) { if (state-&gt;c == 9) { uint16_t offset = (state-&gt;d&lt;&lt;8) | (state-&gt;e); char *str = &amp;state-&gt;memory[offset+3]; // - while (*str != '$') printf("%c", *str++); printf("\n"); } else if (state-&gt;c == 2) { //    ,   ,    printf ("print char routine called\n"); } } else if (0 == ((opcode[2] &lt;&lt; 8) | opcode[1])) { exit(0); } else #endif { uint16_t ret = state-&gt;pc+2; state-&gt;memory[state-&gt;sp-1] = (ret &gt;&gt; 8) &amp; 0xff; state-&gt;memory[state-&gt;sp-2] = (ret &amp; 0xff); state-&gt;sp = state-&gt;sp - 2; state-&gt;pc = (opcode[2] &lt;&lt; 8) | opcode[1]; } break;</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan tes ini, saya menemukan beberapa masalah di emulator saya. Saya tidak yakin yang mana dari mereka yang akan terlibat dalam permainan, tetapi jika mereka melakukannya, maka akan sangat sulit untuk menemukan mereka. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Saya melanjutkan dan mengimplementasikan semua opcodes (dengan pengecualian DAA dan teman-temannya). Saya membutuhkan 3-4 jam untuk memperbaiki masalah dalam tantangan saya dan menerapkan yang baru. Itu pasti lebih cepat daripada proses manual yang saya jelaskan di atas - sebelum saya menemukan tes ini, saya menghabiskan lebih dari 4 jam pada proses manual. Jika Anda bisa mengetahui penjelasan ini, maka saya sarankan menggunakan metode ini daripada membandingkan secara manual. Namun, mengetahui proses manual juga merupakan keterampilan yang hebat, dan jika Anda ingin meniru prosesor lain, maka Anda harus kembali ke sana.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jika Anda tidak dapat melakukan proses ini atau tampaknya terlalu rumit, maka sudah pasti layak untuk memilih pendekatan yang dijelaskan di atas dengan dua emulator berbeda yang berjalan di dalam program Anda. </font><font style="vertical-align: inherit;">Ketika beberapa juta perintah muncul dalam program dan interupsi ditambahkan, tidak mungkin membandingkan dua emulator secara manual.</font></font></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id418699/">https://habr.com/ru/post/id418699/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id418687/index.html">Revolusi 3,5 ": detail ledakan kecil floppy disk dengan uap</a></li>
<li><a href="../id418689/index.html">Cara membuat pustaka komponen di Figma, menghemat anggaran, menggunakan contoh lelang online</a></li>
<li><a href="../id418691/index.html">Peternak: Kubernet dalam 5 menit dengan logam kosong</a></li>
<li><a href="../id418693/index.html">Mengapa kebahagiaan begitu sulit dideteksi di otak</a></li>
<li><a href="../id418695/index.html">Perang Anti-Pembajakan - The Empire Strikes Back</a></li>
<li><a href="../id418701/index.html">Kami mempelajari parser sintaksis untuk bahasa Rusia</a></li>
<li><a href="../id418705/index.html">Dasar-dasar Futex</a></li>
<li><a href="../id418707/index.html">KDispatcher - eventbus yang ringan dan nyaman untuk penggunaan sehari-hari</a></li>
<li><a href="../id418709/index.html">Perlu memaksa diri Anda: driver dan hambatan antarmuka</a></li>
<li><a href="../id418711/index.html">Register Terkelola Token 1.0</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>