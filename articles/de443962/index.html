<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üõÉ üë©üèª‚Äçüé§ ü§¥ Einwegmuster (Prinzip des Einwegdesigns) Punkt 3 ‚ùÑÔ∏è üïâÔ∏è üßëüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Multithreading 


 Sprechen wir jetzt √ºber d√ºnnes Eis. In den vorherigen Abschnitten zu IDisposable haben wir ein sehr wichtiges Konzept angesprochen,...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Einwegmuster (Prinzip des Einwegdesigns) Punkt 3</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/clrium/blog/443962/"><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/nm/tj/eq/nmtjeqodhdjh27wvs0w6v8_0dhu.png"></a> </p><br><h2 id="multithreading">  Multithreading </h2><br><p>  Sprechen wir jetzt √ºber d√ºnnes Eis.  In den vorherigen Abschnitten zu IDisposable haben wir ein sehr wichtiges Konzept angesprochen, das nicht nur den Entwurfsprinzipien von Einweg-Typen, sondern allen Typen im Allgemeinen zugrunde liegt.  Dies ist das Integrit√§tskonzept des Objekts.  Dies bedeutet, dass sich ein Objekt zu einem bestimmten Zeitpunkt in einem streng festgelegten Zustand befindet und jede Aktion mit diesem Objekt seinen Zustand in eine der Optionen verwandelt, die beim Entwerfen eines Objekttyps im Voraus festgelegt wurden.  Mit anderen Worten, keine Aktion mit dem Objekt sollte es in einen undefinierten Zustand versetzen.  Dies f√ºhrt zu einem Problem mit den in den obigen Beispielen entworfenen Typen.  Sie sind nicht threadsicher.  Es besteht die M√∂glichkeit, dass die √∂ffentlichen Methoden dieser Art aufgerufen werden, wenn ein Objekt zerst√∂rt wird.  Lassen Sie uns dieses Problem l√∂sen und entscheiden, ob wir es √ºberhaupt l√∂sen sollen. </p><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Dieses Kapitel wurde vom Autor und von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">professionellen √úbersetzern</a> gemeinsam aus dem Russischen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºbersetzt</a> .  Sie k√∂nnen uns bei der √úbersetzung von Russisch oder Englisch in eine andere Sprache helfen, haupts√§chlich ins Chinesische oder Deutsche. <br><br>  Wenn Sie sich bei uns bedanken m√∂chten, k√∂nnen Sie dies am besten tun, indem Sie uns einen Stern auf Github geben oder das Repository teilen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote><a name="habracut"></a><br><pre><code class="plaintext hljs">public class FileWrapper : IDisposable { IntPtr _handle; bool _disposed; object _disposingSync = new object(); public FileWrapper(string name) { _handle = CreateFile(name, 0, 0, 0, 0, 0, IntPtr.Zero); } public void Seek(int position) { lock(_disposingSync) { CheckDisposed(); // Seek API call } } public void Dispose() { lock(_disposingSync) { if(_disposed) return; _disposed = true; } InternalDispose(); GC.SuppressFinalize(this); } [MethodImpl(MethodImplOptions.AggressiveInlining)] private void CheckDisposed() { lock(_disposingSync) { if(_disposed) { throw new ObjectDisposedException(); } } } private void InternalDispose() { CloseHandle(_handle); } ~FileWrapper() { InternalDispose(); } /// other methods }</code> </pre> <br><p>  Der <code>_disposed</code> Validierungscode in Dispose () sollte als kritischer Abschnitt initialisiert werden.  Tats√§chlich sollte der gesamte Code √∂ffentlicher Methoden als kritischer Abschnitt initialisiert werden.  Dies l√∂st das Problem des gleichzeitigen Zugriffs auf eine √∂ffentliche Methode eines Instanztyps und auf eine Methode ihrer Zerst√∂rung.  Es bringt jedoch andere Probleme mit sich, die zu einer Zeitbombe werden: </p><br><ul><li>  Der intensive Einsatz von Typinstanzmethoden sowie das Erstellen und Zerst√∂ren von Objekten verringern die Leistung erheblich.  Dies liegt daran, dass das Aufnehmen einer Sperre Zeit kostet.  Diese Zeit ist erforderlich, um SyncBlockIndex-Tabellen zuzuweisen, den aktuellen Thread und viele andere Dinge zu √ºberpr√ºfen (wir werden sie im Kapitel √ºber Multithreading behandeln).  Das hei√üt, wir m√ºssen die Leistung des Objekts w√§hrend seiner gesamten Lebensdauer f√ºr die ‚Äûletzte Meile‚Äú seines Lebens opfern. </li><li>  Zus√§tzlicher Speicherverkehr f√ºr Synchronisationsobjekte. </li><li>  Zus√§tzliche Schritte, die GC ausf√ºhren sollte, um ein Objektdiagramm zu durchlaufen. </li></ul><br><p>  Lassen Sie uns nun die zweite und meiner Meinung nach wichtigste Sache nennen.  Wir erlauben die Zerst√∂rung eines Objekts und erwarten gleichzeitig, wieder damit zu arbeiten.  Was hoffen wir in dieser Situation?  dass es scheitern wird?  Denn wenn Dispose zuerst ausgef√ºhrt wird, f√ºhrt die folgende Verwendung von Objektmethoden definitiv zu <code>ObjectDisposedException</code> .  Daher sollten Sie die Synchronisierung zwischen Dispose () -Aufrufen und anderen √∂ffentlichen Methoden eines Typs an die Serviceseite delegieren, dh an den Code, der die Instanz der <code>FileWrapper</code> Klasse erstellt hat.  Dies liegt daran, dass nur die erstellende Seite wei√ü, was sie mit einer Instanz einer Klasse tun wird und wann sie zerst√∂rt werden muss.  Andererseits sollte ein Dispose-Aufruf nur kritische Fehler erzeugen, wie z. B. <code>OutOfMemoryException</code> , nicht jedoch IOException.  Dies liegt an den Anforderungen an die Architektur von Klassen, die IDisposable implementieren.  Dies bedeutet, dass, wenn Dispose von mehr als einem Thread gleichzeitig aufgerufen wird, die Zerst√∂rung einer Entit√§t von zwei Threads gleichzeitig erfolgen kann (wir √ºberspringen die √úberpr√ºfung, <code>if(_disposed) return;</code> ).  Dies h√§ngt von der Situation ab: Wenn eine Ressource mehrmals freigegeben werden <em>kann</em> , sind keine zus√§tzlichen √úberpr√ºfungen erforderlich.  Andernfalls ist ein Schutz erforderlich: </p><br><pre> <code class="plaintext hljs">// I don't show the whole pattern on purpose as the example will be too long // and will not show the essence class Disposable : IDisposable { private volatile int _disposed; public void Dispose() { if(Interlocked.CompareExchange(ref _disposed, 1, 0) == 0) { // dispose } } }</code> </pre> <br><h2 id="two-levels-of-disposable-design-principle">  Zwei Ebenen des Einweg-Konstruktionsprinzips </h2><br><p>  Was ist das beliebteste Muster f√ºr die Implementierung von <code>IDisposable</code> , das Sie in .NET-B√ºchern und im Internet finden k√∂nnen?  Welches Muster wird von Ihnen w√§hrend der Vorstellungsgespr√§che f√ºr einen potenziellen neuen Job erwartet?  H√∂chstwahrscheinlich dieser: </p><br><pre> <code class="plaintext hljs">public class Disposable : IDisposable { bool _disposed; public void Dispose() { Dispose(true); GC.SuppressFinalize(this); } protected virtual void Dispose(bool disposing) { if(disposing) { // here we release managed resources } // here we release unmanaged resources } protected void CheckDisposed() { if(_disposed) { throw new ObjectDisposedException(); } } ~Disposable() { Dispose(false); } }</code> </pre> <br><p>  Was ist falsch an diesem Beispiel und warum haben wir noch nie so geschrieben?  In der Tat ist dies ein gutes Muster, das f√ºr alle Situationen geeignet ist.  Die allgegenw√§rtige Verwendung ist meiner Meinung nach jedoch kein guter Stil, da wir in der Praxis fast nicht mit nicht verwalteten Ressourcen umgehen, sodass die H√§lfte des Musters keinen Zweck erf√ºllt.  Da es gleichzeitig sowohl verwaltete als auch nicht verwaltete Ressourcen verwaltet, verst√∂√üt es au√üerdem gegen das Prinzip der Aufteilung der Verantwortung.  Ich denke das ist falsch.  Schauen wir uns einen etwas anderen Ansatz an.  <em>Prinzip des Einwegdesigns</em> .  Kurz gesagt, es funktioniert wie folgt: </p><br><p>  Die Entsorgung ist in zwei Klassenstufen unterteilt: </p><br><ul><li>  Level 0-Typen kapseln direkt nicht verwaltete Ressourcen <br><ul><li>  Sie sind entweder abstrakt oder verpackt. </li><li>  Alle Methoden sollten markiert sein: <br>  - PrePrepareMethod, damit beim Laden eines Typs eine Methode kompiliert werden kann <br><ul><li>  SecuritySafeCritical zum Schutz vor einem Aufruf aus dem Code unter Einschr√§nkungen </li><li>  ReliabilityContract (Consistency.WillNotCorruptState, Cer.Success / MayFail)], um CER f√ºr eine Methode und alle ihre untergeordneten Aufrufe zu setzen <br>  - Sie k√∂nnen auf Typen der Ebene 0 verweisen, sollten jedoch den Z√§hler f√ºr die Referenzierung von Objekten erh√∂hen, um die richtige Reihenfolge f√ºr die Eingabe der ‚Äûletzten Meile‚Äú zu gew√§hrleisten. </li></ul></li></ul></li><li>  Level 1-Typen kapseln nur verwaltete Ressourcen <br><ul><li>  Sie werden nur von Level 1-Typen geerbt oder implementieren IDisposable direkt </li><li>  Sie k√∂nnen keine Level 0-Typen oder CriticalFinalizerObject erben </li><li>  Sie k√∂nnen verwaltete Typen der Ebenen 1 und 0 kapseln </li><li>  Sie implementieren IDisposable. Entsorgen Sie, indem Sie gekapselte Objekte ab Level 0-Typen zerst√∂ren und zu Level 1 wechseln </li><li>  Sie implementieren keinen Finalizer, da sie sich nicht mit nicht verwalteten Ressourcen befassen </li><li>  Sie sollten eine gesch√ºtzte Eigenschaft enthalten, die den Zugriff auf Level 0-Typen erm√∂glicht. </li></ul></li></ul><br><p>  Aus diesem Grund habe ich die Unterteilung von Anfang an in zwei Typen verwendet: den mit einer verwalteten Ressource und den mit nicht verwalteten Ressourcen.  Sie sollten anders funktionieren. </p><br><h2 id="other-ways-to-use-dispose">  Andere Verwendungsm√∂glichkeiten Entsorgen </h2><br><p>  Die Idee hinter der Erstellung von IDisposable war die Freigabe nicht verwalteter Ressourcen.  Aber wie bei vielen anderen Mustern ist es sehr hilfreich f√ºr andere Aufgaben, z. B. Verweise auf verwaltete Ressourcen freizugeben.  Die Freigabe verwalteter Ressourcen klingt jedoch nicht sehr hilfreich.  Ich meine, sie werden absichtlich als verwaltet bezeichnet, damit wir uns mit einem Grinsen in Bezug auf C / C ++ - Entwickler entspannen k√∂nnen, oder?  Dies ist jedoch nicht der Fall.  Es kann immer vorkommen, dass wir einen Verweis auf ein Objekt verlieren, aber gleichzeitig denken, dass alles in Ordnung ist: GC sammelt M√ºll, einschlie√ülich unseres Objekts.  Es stellt sich jedoch heraus, dass der Speicher w√§chst.  Wir steigen in das Speicheranalyseprogramm ein und sehen, dass etwas anderes dieses Objekt enth√§lt.  Die Sache ist, dass es eine Logik f√ºr die implizite Erfassung eines Verweises auf Ihre Entit√§t sowohl in der .NET-Plattform als auch in der Architektur externer Klassen geben kann.  Da die Erfassung implizit ist, kann ein Programmierer die Notwendigkeit seiner Freigabe √ºbersehen und dann einen Speicherverlust erhalten. </p><br><h3 id="delegates-events">  Delegierte, Veranstaltungen </h3><br><p>  Schauen wir uns dieses synthetische Beispiel an: </p><br><pre> <code class="plaintext hljs">class Secondary { Action _action; void SaveForUseInFuture(Action action) { _action = action; } public void CallAction() { _action(); } } class Primary { Secondary _foo = new Secondary(); public void PlanSayHello() { _foo.SaveForUseInFuture(Strategy); } public void SayHello() { _foo.CallAction(); } void Strategy() { Console.WriteLine("Hello!"); } }</code> </pre> <br><p>  Welches Problem zeigt dieser Code?  Die sekund√§re Klasse speichert den Delegaten des <code>_action</code> Feld <code>_action</code> , der in der <code>SaveForUseInFuture</code> Methode akzeptiert wird.  Als N√§chstes <code>PlanSayHello</code> Methode in der <code>PlanSayHello</code> den Zeiger auf die <code>Strategy</code> an die <code>Secondary</code> .  Es ist merkw√ºrdig, aber wenn Sie in diesem Beispiel irgendwo eine statische Methode oder eine Instanzmethode √ºbergeben, wird die √ºbergebene <code>SaveForUseInFuture</code> nicht ge√§ndert, aber eine Instanz der <code>SaveForUseInFuture</code> wird <em>implizit</em> oder √ºberhaupt nicht referenziert.  √Ñu√üerlich scheinen Sie angewiesen zu haben, welche Methode aufgerufen werden soll.  Tats√§chlich wird ein Delegat jedoch nicht nur mithilfe eines Methodenzeigers erstellt, sondern auch mithilfe des Zeigers auf eine Instanz einer Klasse.  Ein anrufender Teilnehmer sollte verstehen, f√ºr welche Instanz einer Klasse er die <code>Strategy</code> aufrufen muss!  Dies ist die Instanz der <code>Secondary</code> , die implizit akzeptiert wurde und den Zeiger auf die Instanz der <code>Primary</code> , obwohl dies nicht explizit angegeben ist.  F√ºr uns bedeutet dies nur, dass GC <em>kein</em> <code>Primary</code> Objekt <em>sammelt</em> , wenn wir den <code>_foo</code> Zeiger an einer anderen Stelle √ºbergeben und den Verweis auf <code>Primary</code> verlieren, da <code>Secondary</code> ihn enth√§lt.  Wie k√∂nnen wir solche Situationen vermeiden?  Wir brauchen einen entschlossenen Ansatz, um einen Verweis auf uns zu ver√∂ffentlichen.  Ein Mechanismus, der perfekt zu diesem Zweck passt, ist <code>IDisposable</code> </p><br><pre> <code class="plaintext hljs">// This is a simplified implementation class Secondary : IDisposable { Action _action; public event Action&lt;Secondary&gt; OnDisposed; public void SaveForUseInFuture(Action action) { _action = action; } public void CallAction() { _action?.Invoke(); } void Dispose() { _action = null; OnDisposed?.Invoke(this); } }</code> </pre> <br><p>  Jetzt sieht das Beispiel akzeptabel aus.  Wenn eine Instanz einer Klasse an einen Dritten √ºbergeben wird und der Verweis auf <code>_action</code> delegate w√§hrend dieses Vorgangs verloren geht, setzen wir ihn auf Null und der Dritte wird √ºber die Zerst√∂rung der Instanz benachrichtigt und der Verweis darauf gel√∂scht . <br>  Die zweite Gefahr von Code, der auf Delegierten ausgef√ºhrt wird, sind die Funktionsprinzipien des <code>event</code> .  Schauen wir uns an, was daraus resultiert: </p><br><pre> <code class="plaintext hljs"> // a private field of a handler private Action&lt;Secondary&gt; _event; // add/remove methods are marked as [MethodImpl(MethodImplOptions.Synchronized)] // that is similar to lock(this) public event Action&lt;Secondary&gt; OnDisposed { add { lock(this) { _event += value; } } remove { lock(this) { _event -= value; } } }</code> </pre> <br><p>  C # -Nachrichten verbergen die Interna von Ereignissen und enthalten alle Objekte, die f√ºr die Aktualisierung √ºber ein <code>event</code> abonniert wurden.  Wenn etwas schief geht, bleibt ein Verweis auf ein signiertes Objekt in <code>OnDisposed</code> und enth√§lt das Objekt.  Es ist eine seltsame Situation, da wir in Bezug auf die Architektur ein Konzept der ‚ÄûEreignisquelle‚Äú erhalten, das logisch nichts enthalten sollte.  Tats√§chlich werden Objekte, die f√ºr die Aktualisierung abonniert wurden, implizit gehalten.  Dar√ºber hinaus k√∂nnen wir in diesem Array von Delegaten nichts √§ndern, obwohl die Entit√§t uns geh√∂rt.  Das einzige, was wir tun k√∂nnen, ist, diese Liste zu l√∂schen, indem wir einer Ereignisquelle null zuweisen. </p><br><p>  Die zweite M√∂glichkeit besteht darin <code>remove</code> Methoden zum <code>add</code> / <code>remove</code> explizit zu implementieren, damit wir eine Sammlung von Delegaten steuern k√∂nnen. </p><br><blockquote>  Eine andere implizite Situation kann hier auftreten.  Wenn Sie einer Ereignisquelle null zuweisen, f√ºhrt das folgende Abonnement f√ºr Ereignisse m√∂glicherweise zu einer <code>NullReferenceException</code> .  Ich denke, das w√§re logischer. </blockquote><p>  Dies ist jedoch nicht wahr.  Wenn externer Code Ereignisse abonniert, nachdem eine Ereignisquelle gel√∂scht wurde, erstellt FCL eine neue Instanz der Aktionsklasse und speichert sie in <code>OnDisposed</code> .  Diese implizite Aussage in C # kann einen Programmierer irref√ºhren: Der Umgang mit nullen Feldern sollte eher eine Art Wachsamkeit als Ruhe erzeugen.  Hier zeigen wir auch einen Ansatz, bei dem die Nachl√§ssigkeit eines Programmierers zu Speicherlecks f√ºhren kann. </p><br><h3 id="lambdas-closures">  Lambdas Verschl√ºsse </h3><br><p>  Die Verwendung von syntaktischem Zucker wie Lambdas ist besonders gef√§hrlich. </p><br><blockquote>  Ich m√∂chte den syntaktischen Zucker als Ganzes ansprechen.  Ich denke, Sie sollten es ziemlich vorsichtig und nur verwenden, wenn Sie das Ergebnis genau kennen.  Beispiele f√ºr Lambda-Ausdr√ºcke sind Verschl√ºsse, Verschl√ºsse in Ausdr√ºcken und viele andere Leiden, die Sie sich selbst zuf√ºgen k√∂nnen. </blockquote><p>  Nat√ºrlich k√∂nnen Sie sagen, dass Sie wissen, dass ein Lambda-Ausdruck einen Abschluss erzeugt und zu einem Risiko eines Ressourcenlecks f√ºhren kann.  Aber es ist so ordentlich, so angenehm, dass es schwer zu vermeiden ist, Lambda zu verwenden, anstatt die gesamte Methode zuzuweisen, die an einem anderen Ort als dem, an dem sie verwendet wird, beschrieben wird.  Tats√§chlich sollten Sie sich dieser Provokation nicht anschlie√üen, obwohl nicht jeder widerstehen kann.  Schauen wir uns das Beispiel an: </p><br><pre> <code class="plaintext hljs"> button.Clicked += () =&gt; service.SendMessageAsync(MessageType.Deploy);</code> </pre> <br><p>  Stimmen Sie zu, diese Linie sieht sehr sicher aus.  Aber es verbirgt ein gro√ües Problem: Jetzt verweist die <code>button</code> implizit auf den <code>service</code> und h√§lt ihn.  Selbst wenn wir entscheiden, dass wir keinen <code>service</code> mehr ben√∂tigen, enth√§lt die <code>button</code> die Referenz, solange diese Variable aktiv ist.  Eine M√∂glichkeit, dieses Problem zu l√∂sen, besteht darin, ein Muster zum Erstellen von <code>IDisposable</code> aus einer beliebigen <code>Action</code> ( <code>System.Reactive.Disposables</code> ) zu verwenden: </p><br><pre> <code class="plaintext hljs">// Here we create a delegate from a lambda Action action = () =&gt; service.SendMessageAsync(MessageType.Deploy); // Here we subscribe button.Clicked += action; // We unsubscribe var subscription = Disposable.Create(() =&gt; button.Clicked -= action); // where it is necessary subscription.Dispose();</code> </pre> <br><p>  Zugegeben, das sieht etwas langwierig aus und wir verlieren den ganzen Zweck der Verwendung von Lambda-Ausdr√ºcken.  Es ist viel sicherer und einfacher, g√§ngige private Methoden zu verwenden, um Variablen implizit zu erfassen. </p><br><h3 id="threadabort-protection">  Threadabort-Schutz </h3><br><p>  Wenn Sie eine Bibliothek f√ºr einen Drittanbieter erstellen, k√∂nnen Sie deren Verhalten in einer Drittanbieteranwendung nicht vorhersagen.  Manchmal k√∂nnen Sie nur raten, was ein Programmierer mit Ihrer Bibliothek gemacht hat, was zu einem bestimmten Ergebnis gef√ºhrt hat.  Ein Beispiel ist das Funktionieren in einer Multithread-Umgebung, in der die Konsistenz der Ressourcenbereinigung zu einem kritischen Problem werden kann.  Beachten Sie, dass wir beim Schreiben der <code>Dispose()</code> -Methode das Fehlen von Ausnahmen garantieren k√∂nnen.  Wir k√∂nnen jedoch nicht sicherstellen, dass beim Ausf√ºhren der <code>Dispose()</code> -Methode keine <code>ThreadAbortException</code> auftritt, die unseren Ausf√ºhrungsthread deaktiviert.  Hier sollten wir uns daran erinnern, dass beim <code>ThreadAbortException</code> ohnehin alle catch / finally-Bl√∂cke ausgef√ºhrt werden (am Ende eines catch / finally-Blocks tritt ThreadAbort weiter unten auf).  Um die Ausf√ºhrung eines bestimmten Codes mithilfe von Thread.Abort sicherzustellen, m√ºssen Sie einen kritischen Abschnitt in <code>try { ... } finally { ... }</code> einschlie√üen. Siehe das folgende Beispiel: </p><br><pre> <code class="plaintext hljs">void Dispose() { if(_disposed) return; _someInstance.Unsubscribe(this); _disposed = true; }</code> </pre> <br><p>  Mit <code>Thread.Abort</code> kann man dies jederzeit <code>Thread.Abort</code> .  Es zerst√∂rt teilweise ein Objekt, obwohl Sie auch in Zukunft damit arbeiten k√∂nnen.  Zur gleichen Zeit der folgende Code: </p><br><pre> <code class="plaintext hljs">void Dispose() { if(_disposed) return; // ThreadAbortException protection try {} finally { _someInstance.Unsubscribe(this); _disposed = true; } }</code> </pre> <br><p>  ist vor einem solchen Abbruch gesch√ºtzt und l√§uft reibungslos und sicher, auch wenn <code>Thread.Abort</code> zwischen dem Aufrufen der <code>Unsubscribe</code> Methode und der Ausf√ºhrung ihrer Anweisungen <code>Unsubscribe</code> wird. </p><br><h2 id="results">  Ergebnisse </h2><br><h3 id="advantages">  Vorteile </h3><br><p>  Nun, wir haben viel √ºber dieses einfachste Muster gelernt.  Lassen Sie uns seine Vorteile bestimmen: </p><br><ol><li>  Der Hauptvorteil des Musters ist die F√§higkeit, Ressourcen bestimmt freizugeben, dh wenn Sie sie ben√∂tigen. </li><li>  Der zweite Vorteil ist die Einf√ºhrung einer bew√§hrten Methode, um zu √ºberpr√ºfen, ob eine bestimmte Instanz ihre Instanzen nach der Verwendung zerst√∂ren muss. </li><li>  Wenn Sie das Muster korrekt implementieren, funktioniert ein entworfener Typ sicher in Bezug auf die Verwendung durch Komponenten von Drittanbietern sowie in Bezug auf das Entladen und Zerst√∂ren von Ressourcen, wenn ein Prozess abst√ºrzt (z. B. aufgrund von Speichermangel).  Dies ist der letzte Vorteil. </li></ol><br><h3 id="disadvantages">  Nachteile </h3><br><p>  Meiner Meinung nach hat dieses Muster mehr Nachteile als Vorteile. </p><br><ol><li>  Ein Typ weist jeden Typ, der dieses Muster implementiert, andere Teile an, dass sie, wenn sie es verwenden, eine Art √∂ffentliches Angebot annehmen.  Dies ist so implizit, dass ein Benutzer eines Typs wie bei √∂ffentlichen Angeboten nicht immer wei√ü, dass der Typ √ºber diese Schnittstelle verf√ºgt.  Daher m√ºssen Sie den IDE-Anweisungen folgen (geben Sie einen Punkt ein, Dis ... und pr√ºfen Sie, ob die gefilterte Mitgliederliste einer Klasse eine Methode enth√§lt).  Wenn Sie ein Dispose-Muster sehen, sollten Sie es in Ihren Code implementieren.  Manchmal passiert es nicht sofort und in diesem Fall sollten Sie ein Muster durch ein System von Typen implementieren, das Funktionen hinzuf√ºgt.  Ein gutes Beispiel ist, dass <code>IEnumerator&lt;T&gt;</code> <code>IDisposable</code> . </li><li>  Wenn Sie eine Schnittstelle entwerfen, m√ºssen Sie normalerweise IDisposable in das System der Schnittstellen eines Typs einf√ºgen, wenn eine der Schnittstellen IDisposable erben muss.  Meiner Meinung nach besch√§digt dies die von uns entworfenen Schnittstellen.  Ich meine, wenn Sie eine Schnittstelle entwerfen, erstellen Sie zuerst ein Interaktionsprotokoll.  Dies ist eine Reihe von Aktionen, die Sie mit <em>etwas</em> ausf√ºhren k√∂nnen, das sich hinter der Benutzeroberfl√§che verbirgt.  <code>Dispose()</code> ist eine Methode zum Zerst√∂ren einer Instanz einer Klasse.  Dies widerspricht dem Wesen eines <em>Interaktionsprotokolls</em> .  Tats√§chlich sind dies die Details der Implementierung, die in die Schnittstelle eingedrungen sind. </li><li>  Dispose () bedeutet trotz seiner Bestimmung nicht die direkte Zerst√∂rung eines Objekts.  Das Objekt wird nach seiner <em>Zerst√∂rung</em> noch existieren, jedoch in einem anderen Zustand.  Um dies zu erreichen, muss CheckDisposed () der erste Befehl jeder √∂ffentlichen Methode sein.  Dies sieht nach einer vor√ºbergehenden L√∂sung aus, die uns jemand mit den Worten gegeben hat: ‚ÄûGeh hinaus und vermehr dich‚Äú; </li><li>  Es gibt auch eine kleine Chance, einen Typ zu erhalten, der <code>IDisposable</code> durch <em>explizite</em> Implementierung implementiert.  Oder Sie k√∂nnen einen Typ erhalten, der die ID implementiert, ohne dass Sie bestimmen k√∂nnen, wer sie zerst√∂ren muss: Sie oder die Partei, die sie Ihnen gegeben hat.  Dies f√ºhrte zu einem Antimuster mehrerer Aufrufe von Dispose (), mit dem ein zerst√∂rtes Objekt zerst√∂rt werden kann. </li><li>  Die vollst√§ndige Implementierung ist schwierig und unterscheidet sich f√ºr verwaltete und nicht verwaltete Ressourcen.  Hier erscheint der Versuch, die Arbeit der Entwickler durch GC zu erleichtern, umst√§ndlich.  Sie k√∂nnen die <code>virtual void Dispose()</code> -Methode √ºberschreiben und einen DisposableObject-Typ einf√ºhren, der das gesamte Muster implementiert, andere mit dem Muster verbundene Probleme jedoch nicht l√∂st. </li><li>  In der Regel wird die Dispose () -Methode am Ende einer Datei implementiert, w√§hrend '.ctor' am Anfang deklariert wird.  Wenn Sie eine Klasse √§ndern oder neue Ressourcen einf√ºhren, k√∂nnen Sie leicht vergessen, die Entsorgung f√ºr diese hinzuzuf√ºgen. </li><li>  Schlie√ülich ist es schwierig, die Reihenfolge der <em>Zerst√∂rung</em> in einer Multithread-Umgebung zu bestimmen, wenn Sie ein Muster f√ºr Objektdiagramme verwenden, in denen Objekte dieses Muster ganz oder teilweise implementieren.  Ich meine Situationen, in denen Dispose () an verschiedenen Enden eines Diagramms beginnen kann.  Hier ist es besser, andere Muster zu verwenden, z. B. das Lifetime-Muster. </li><li>  Der Wunsch der Plattformentwickler, die Speichersteuerung in Kombination mit der Realit√§t zu automatisieren: Anwendungen interagieren sehr oft mit nicht verwaltetem Code. + Sie m√ºssen die Freigabe von Verweisen auf Objekte steuern, damit Garbage Collector sie erfassen kann.  Dies f√ºhrt zu gro√üer Verwirrung beim Verst√§ndnis von Fragen wie: ‚ÄûWie sollen wir ein Muster richtig implementieren?‚Äú.  "Gibt es √ºberhaupt ein verl√§ssliches Muster"?  Vielleicht <code>delete obj; delete[] arr;</code> <code>delete obj; delete[] arr;</code>  ist einfacher? </li></ol><br><h2 id="domain-unloading-and-exit-from-an-application">  Entladen der Dom√§ne und Beenden einer Anwendung </h2><br><p>  Wenn Sie zu diesem Teil gekommen sind, haben Sie mehr Vertrauen in den Erfolg zuk√ºnftiger Vorstellungsgespr√§che.  Wir haben jedoch nicht alle Fragen besprochen, die mit diesem einfachen Muster verbunden sind.  Die letzte Frage ist, ob sich das Verhalten einer Anwendung bei einfacher Speicherbereinigung unterscheidet und wenn beim Entladen der Dom√§ne und beim Beenden der Anwendung Speicherplatz gesammelt wird.  Diese Frage ber√ºhrt lediglich <code>Dispose()</code> ... <code>Dispose()</code> und Finalisierung gehen jedoch Hand in Hand, und wir treffen selten auf eine Implementierung einer Klasse, die Finalisierung hat, aber keine <code>Dispose()</code> -Methode hat.  Beschreiben wir die Finalisierung in einem separaten Abschnitt.  Hier f√ºgen wir nur einige wichtige Details hinzu. </p><br><p>  W√§hrend des Entladens der Anwendungsdom√§ne entladen Sie sowohl in die Anwendungsdom√§ne geladene Assemblys als auch alle Objekte, die als Teil der zu entladenden Dom√§ne erstellt wurden.  Tats√§chlich bedeutet dies die Bereinigung (Sammlung durch GC) dieser Objekte und das Aufrufen von Finalisierern f√ºr sie.  Wenn die Logik eines Finalizers darauf wartet, dass die Finalisierung anderer Objekte in der richtigen Reihenfolge zerst√∂rt wird, achten Sie m√∂glicherweise auf die Eigenschaft <code>Environment.HasShutdownStarted</code> angibt, dass eine Anwendung aus dem Speicher entladen wurde, und auf die Methode <code>AppDomain.CurrentDomain.IsFinalizingForUnload()</code> , die dies angibt Domain wird entladen, was der Grund f√ºr die Finalisierung ist.  Wenn diese Ereignisse eintreten, wird die Reihenfolge der Ressourcenabschluss im Allgemeinen unwichtig.  Wir k√∂nnen weder das Entladen einer Domain noch einer Anwendung verz√∂gern, da wir alles so schnell wie m√∂glich erledigen sollten. </p><br><p>  Auf diese Weise wird diese Aufgabe als Teil einer Klasse <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">LoaderAllocatorScout gel√∂st</a> </p><br><pre> <code class="plaintext hljs">// Assemblies and LoaderAllocators will be cleaned up during AppDomain shutdown in // an unmanaged code // So it is ok to skip reregistration and cleanup for finalization during appdomain shutdown. // We also avoid early finalization of LoaderAllocatorScout due to AD unload when the object was inside DelayedFinalizationList. if (!Environment.HasShutdownStarted &amp;&amp; !AppDomain.CurrentDomain.IsFinalizingForUnload()) { // Destroy returns false if the managed LoaderAllocator is still alive. if (!Destroy(m_nativeLoaderAllocator)) { // Somebody might have been holding a reference on us via weak handle. // We will keep trying. It will be hopefully released eventually. GC.ReRegisterForFinalize(this); } }</code> </pre> <br><h2 id="typical-implementation-faults">  Typische Implementierungsfehler </h2><br><p>  Wie ich Ihnen gezeigt habe, gibt es kein universelles Muster f√ºr die Implementierung von IDisposable.  Dar√ºber hinaus f√ºhrt ein gewisses Vertrauen in die automatische Speichersteuerung Menschen in die Irre und sie treffen verwirrende Entscheidungen bei der Implementierung eines Musters.  Das gesamte .NET Framework ist mit Fehlern in seiner Implementierung durchsetzt.  Schauen wir uns diese Fehler am Beispiel von .NET Framework genau an, um meinen Standpunkt zu belegen.  Alle Implementierungen sind verf√ºgbar √ºber: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">IDisposable Usages</a> </p><br><p>  <strong>FileEntry-Klasse</strong> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">cmsinterop.cs</a> </p><br><blockquote>  Dieser Code wurde in Eile geschrieben, um das Problem zu schlie√üen.  Offensichtlich wollte der Autor etwas tun, √ºberlegte es sich aber anders und behielt eine fehlerhafte L√∂sung bei </blockquote><br><pre> <code class="plaintext hljs">internal class FileEntry : IDisposable { // Other fields // ... [MarshalAs(UnmanagedType.SysInt)] public IntPtr HashValue; // ... ~FileEntry() { Dispose(false); } // The implementation is hidden and complicates calling the *right* version of a method. void IDisposable.Dispose() { this.Dispose(true); } // Choosing a public method is a serious mistake that allows for incorrect destruction of // an instance of a class. Moreover, you CANNOT call this method from the outside public void Dispose(bool fDisposing) { if (HashValue != IntPtr.Zero) { Marshal.FreeCoTaskMem(HashValue); HashValue = IntPtr.Zero; } if (fDisposing) { if( MuiMapping != null) { MuiMapping.Dispose(true); MuiMapping = null; } System.GC.SuppressFinalize(this); } } }</code> </pre> <br><p>  <strong>SemaphoreSlim Class</strong> <a href="">System / Threading / SemaphoreSlim.cs</a> </p><br><blockquote>  Dieser Fehler steht ganz oben auf den Fehlern von .NET Framework in Bezug auf IDisposable: SuppressFinalize f√ºr Klassen, in denen kein Finalizer vorhanden ist.  Es ist sehr h√§ufig. </blockquote><br><pre> <code class="plaintext hljs">public void Dispose() { Dispose(true); // As the class doesn't have a finalizer, there is no need in GC.SuppressFinalize GC.SuppressFinalize(this); } // The implementation of this pattern assumes the finalizer exists. But it doesn't. // It was possible to do with just public virtual void Dispose() protected virtual void Dispose(bool disposing) { if (disposing) { if (m_waitHandle != null) { m_waitHandle.Close(); m_waitHandle = null; } m_lockObj = null; m_asyncHead = null; m_asyncTail = null; } }</code> </pre> <br><p>  <strong>Aufruf von Close + Dispose</strong> <a href="">NativeWatcher-Projektcode</a> </p><br><blockquote>  Manchmal nennen die Leute sowohl Schlie√üen als auch Entsorgen.  Dies ist falsch, f√ºhrt jedoch nicht zu einem Fehler, da bei der zweiten Entsorgung keine Ausnahme generiert wird. </blockquote><p>  In der Tat ist Close ein weiteres Muster, um die Dinge f√ºr die Menschen klarer zu machen.  Es machte jedoch alles unklarer. </p><br><pre> <code class="plaintext hljs">public void Dispose() { if (MainForm != null) { MainForm.Close(); MainForm.Dispose(); } MainForm = null; }</code> </pre> <br><h2 id="general-results">  Allgemeine Ergebnisse </h2><br><ol><li>  IDposable ist ein Standard der Plattform und die Qualit√§t ihrer Implementierung beeinflusst die Qualit√§t der gesamten Anwendung.  Dar√ºber hinaus beeinflusst es in bestimmten Situationen die Sicherheit Ihrer Anwendung, die √ºber nicht verwaltete Ressourcen angegriffen werden kann. </li><li>  Die Implementierung von IDisposable muss maximal produktiv sein.  Dies gilt insbesondere f√ºr den Abschnitt der Finalisierung, der parallel zum Rest des Codes arbeitet und Garbage Collector l√§dt. </li><li>  Bei der Implementierung von IDisposable sollten Sie Dispose () nicht gleichzeitig mit √∂ffentlichen Methoden einer Klasse verwenden.  Die Zerst√∂rung kann nicht mit der Nutzung einhergehen.  Dies sollte beim Entwerfen eines Typs ber√ºcksichtigt werden, der ein IDisposable-Objekt verwendet. </li><li>  Es sollte jedoch ein Schutz gegen das gleichzeitige Aufrufen von 'Dispose ()' von zwei Threads bestehen.  Dies ergibt sich aus der Anweisung, dass Dispose () keine Fehler erzeugen sollte. </li><li>  Typen, die nicht verwaltete Ressourcen enthalten, sollten von anderen Typen getrennt werden.  Ich meine, wenn Sie eine nicht verwaltete Ressource umschlie√üen, sollten Sie einen separaten Typ daf√ºr zuweisen.  Dieser Typ sollte die Finalisierung enthalten und von <code>SafeHandle / CriticalHandle / CriticalFinalizerObject</code> geerbt werden.  Diese Aufgabentrennung f√ºhrt zu einer verbesserten Unterst√ºtzung des Typsystems und vereinfacht die Implementierung, um Instanzen von Typen √ºber Dispose () zu zerst√∂ren: Die Typen mit dieser Implementierung m√ºssen keinen Finalizer implementieren. </li><li>  Im Allgemeinen ist dieses Muster sowohl bei der Verwendung als auch bei der Codepflege nicht komfortabel.  Wahrscheinlich sollten wir den Inversion of Control-Ansatz verwenden, wenn wir den Status von Objekten √ºber das <code>Lifetime</code> Muster zerst√∂ren.  Wir werden jedoch im n√§chsten Abschnitt dar√ºber sprechen. </li></ol><br><blockquote><img src="https://habrastorage.org/webt/tu/qf/aq/tuqfaqcncvjtdmb_uxgcbbzyr9o.png" align="left">  Dieses Kapitel wurde vom Autor und von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">professionellen √úbersetzern</a> gemeinsam aus dem Russischen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">√ºbersetzt</a> .  Sie k√∂nnen uns bei der √úbersetzung von Russisch oder Englisch in eine andere Sprache helfen, haupts√§chlich ins Chinesische oder Deutsche. <br><br>  Wenn Sie sich bei uns bedanken m√∂chten, k√∂nnen Sie dies am besten tun, indem Sie uns einen Stern auf Github geben oder das Repository teilen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/5n/wo/6u/5nwo6uvyk2eafkzdd0cdofjqm-0.png" width="22"></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">github / sidristij / dotnetbook</a> . <br></blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de443962/">https://habr.com/ru/post/de443962/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de443952/index.html">Souver√§nes Internet - f√ºr unser Geld</a></li>
<li><a href="../de443954/index.html">Technologische Singularit√§t: der moderne Mythos vom Ende der Welt unter dem Deckmantel der Hypothese des Fortschritts</a></li>
<li><a href="../de443956/index.html">Soziales Netzwerk im Jahr 2019: Yandex startete Aura</a></li>
<li><a href="../de443958/index.html">Einwegmuster (Prinzip des Einwegdesigns) Punkt 1</a></li>
<li><a href="../de443960/index.html">Einwegmuster (Prinzip des Einwegdesigns) Punkt 2</a></li>
<li><a href="../de443964/index.html">Kolesa Conf ist die gr√∂√üte IT-Konferenz in Kasachstan. Ank√ºndigung von Berichten</a></li>
<li><a href="../de443966/index.html">Google Text & Tabellen - ein beliebter Chat unter Studenten</a></li>
<li><a href="../de443968/index.html">Wie wir ein Haus mit Sonnenkollektoren gekauft haben und was daraus wurde</a></li>
<li><a href="../de443972/index.html">Yandex wird mit einem Roboter nach Piraten suchen</a></li>
<li><a href="../de443974/index.html">Speicher und Spanne Punkt 1</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>