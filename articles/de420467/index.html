<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèæ‚Äçü§ù‚Äçüßëüèº ‚ñ∂Ô∏è üñêüèæ C ++ - Wrapper f√ºr "alle" Echtzeitbetriebssysteme f√ºr CortexM4 üê† üí† üßïüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Ich habe bereits im Artikel STM32, C ++ und FreeRTOS dar√ºber gesprochen, wie Sie FreeRtos f√ºr in C ++ geschriebene Projekte verwenden k√∂nnen . Entwick...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>C ++ - Wrapper f√ºr "alle" Echtzeitbetriebssysteme f√ºr CortexM4</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/420467/"><img src="https://habrastorage.org/webt/s0/2o/ve/s02ovegatxm9x39z6c8x_5fydki.png" alt="Bild"><br><br>  Ich habe bereits im Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">STM32, C ++ und FreeRTOS</a> dar√ºber gesprochen, wie Sie FreeRtos f√ºr in C ++ geschriebene Projekte verwenden k√∂nnen <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Entwicklung von Grund auf neu.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a>  Seitdem, bis zu 3 Jahre vergangen sind, bin ich ernsthaft gealtert und habe eine Reihe neuronaler Verbindungen verloren. Deshalb habe ich beschlossen, die alten Zeiten aufzur√ºtteln, um diese Verbindungen wiederherzustellen und den Wrapper nach "jedem" beliebten RTOS zu durchsuchen.  Dies ist nat√ºrlich ein Witz, ich habe absichtlich "alle" in Anf√ºhrungszeichen gesetzt, aber in jedem Witz steckt etwas Wahres. <br><a name="habracut"></a><br>  Also, was ist die Aufgabe und warum ist sie √ºberhaupt relevant?  Im Moment sind in C eine Million verschiedener Betriebssysteme geschrieben - ich m√∂chte nicht f√ºr jeden Geschmack w√§hlen, bezahlt, kostenlos, klein, gro√ü ... Aber f√ºr Projekte, an denen ich teilnehme, werden all diese Chips verschiedener Betriebssysteme nicht ben√∂tigt, grundlegende Funktionen wie eine Aufgabe reichen aus , Ereignisse, Aufgabenbenachrichtigung, kritischer Abschnitt, Mutexe und Semaphoren (obwohl ich versuche, sie nicht zu verwenden), Warteschlangen.  Und das alles in einer ziemlich einfachen Form, ohne Schnickschnack. <br><br>  Meiner Meinung nach ist der in C ++ geschriebene inl√§ndische <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b>OSRV MAX</b></a> ideal f√ºr meine Projekte geeignet, und es ist eine Freude, ihn zu verwenden. <br><br>  Der Haken ist jedoch, dass unsere Ger√§te der Norm IEC_61508 entsprechen m√ºssen. Eine der Anforderungen ist die <i>E.29-Anwendung einer bew√§hrten Zielbibliothek</i> .  Nun, oder in einfachen Worten, wenn Sie ein Ger√§t herstellen, das die <u>SIL3-</u> Stufe erf√ºllt, verwenden Sie bitte (H√∂her empfohlen) Bibliotheken, die dieser Stufe entsprechen und erprobt sind. <br><br>  In Bezug auf unsere Aufgabe bedeutet dies, dass es m√∂glich ist, das <b>MAX MAX RTOS</b> f√ºr solche Ger√§te zu verwenden, aber Zuverl√§ssigkeitspunkte werden nicht hinzugef√ºgt.  Daher stellen RTOS-Hersteller spezielle Versionen ihrer Betriebssysteme her, die den IEC_61508-Standards entsprechen. <i>FreeRTOS</i> verf√ºgt beispielsweise √ºber einen <i>SafeRTOS-</i> Klon und <i>embOs</i> √ºber einen <i>embOS-Safe-</i> Klon. Hersteller verdienen damit nat√ºrlich sehr viel Geld, da Lizenzen f√ºr diese Betriebssysteme mehrere tausend oder sogar zehn kosten tausend Dollar. <br><br>  Ein gutes Beispiel ist √ºbrigens der IAR-Compiler, dessen Lizenz ungef√§hr 1.500 US-Dollar kostet, aber IAR-zertifizierte Versionen kosten bereits ungef√§hr 10.000 Dollar, obwohl ich mehrere Projekte √ºberpr√ºft habe - die Ausgabedatei der Version ohne Zertifikat und mit Zertifikat ist v√∂llig identisch.  Nun, Sie verstehen, dass Sie f√ºr den Frieden bezahlen m√ºssen. <br><br>  Also haben wir zuerst <i>ein Betriebssystem verwendet</i> , dann habe ich angefangen, <i>FreeRTOS</i> f√ºr meine Bed√ºrfnisse zu verwenden, dann sind wir zu <i>einem anderen</i> gewechselt. Im Allgemeinen mussten wir den fertigen Code st√§ndig neu schreiben.  Au√üerdem m√∂chte ich, dass es sch√∂n und einfach aussieht, damit jeder anhand des Codes verstehen kann, was passiert. Dann wird die Codeunterst√ºtzung f√ºr Studenten und Praktiker eine einfache Aufgabe sein, und die Gurus k√∂nnen weiterhin an innovativen Ger√§ten arbeiten, anstatt den Stapel Nudeln zu verstehen .  Im Allgemeinen m√∂chte ich so etwas versteinert sehen: <br><br><img src="https://habrastorage.org/webt/rc/2z/_k/rc2z_kzdcpu6isdhwojtbbi4wac.png" alt="Bild"><br><br>  Na ja oder so ... <br><br><img src="https://habrastorage.org/webt/f7/li/48/f7li48lkaylpglvyjr-tiekmxai.png" alt="Bild"><br><br>  Aus diesem <i>Grund habe</i> ich beschlossen, einen Wrapper zu schreiben, der sowohl zu <i>FreeRTOS</i> als auch zu <i>embOS passt, also</i> auch f√ºr alle anderen :). Zun√§chst habe ich festgestellt, was ich wirklich f√ºr ein vollst√§ndiges Gl√ºck brauche: <br><br><ul><li>  Die Aufgaben </li><li>  Kritische Abschnitte </li><li>  Ereignisse und Aufgabenbenachrichtigung </li><li>  Semaphoren und Mutexe </li><li>  Warteschlangen </li></ul><br>  Der Wrapper sollte <u>SIL3-</u> ideologisch sein, und diese Ebene enth√§lt viele aller Arten von empfohlenen Dingen. Wenn Sie sie vollst√§ndig befolgen, stellt sich heraus, dass es besser ist, den Code √ºberhaupt nicht zu schreiben. <br><br>  Die Tatsache, dass der Standard eine Reihe von Regeln oder vielmehr Empfehlungen regelt, bedeutet jedoch nicht, dass diese nicht verletzt werden k√∂nnen - Sie k√∂nnen, aber Sie m√ºssen so viele Empfehlungen wie m√∂glich befolgen, um mehr Punkte zu erhalten.  Daher habe ich mich f√ºr einige wichtige Einschr√§nkungen entschieden: <br><br><ul><li>  <b>Keine Makros</b> , au√üer zum Schutz vor doppelter Aufnahme von Header-Dateien.  Makros sind b√∂se. Wenn Sie berechnen, wie viel Zeit f√ºr die Suche nach Fehlern im Zusammenhang mit Makros aufgewendet wurde, stellt sich heraus, dass das Universum nicht so alt ist und wie viel Gutes in dieser Zeit getan werden k√∂nnte. Wahrscheinlich ist es besser, sie auf gesetzlicher Ebene zu verbieten, da Torrents dies verbieten oder nehmen Sie einen Bonus f√ºr jedes Makro, das Sie schreiben </li><li>  <b>Verwenden Sie</b> nat√ºrlich <b>keine Zeiger</b> , wann immer dies m√∂glich ist.  Man k√∂nnte versuchen, sie √ºberhaupt nicht zu benutzen, aber es gibt immer noch Orte, an denen es ohne sie keinen Weg gibt.  In jedem Fall sollte der Benutzer des Wrappers, wenn m√∂glich, nicht einmal wissen, was ein Zeiger ist, da er nur von seinem Gro√üvater davon geh√∂rt hat, da er jetzt ausschlie√ülich mit Links arbeitet </li><li>  <b>Keine dynamische Speicherzuweisung verwenden</b> - alles ist klar, nur die Verwendung eines Heaps f√ºhrt zum einen dazu, dass RAM f√ºr diesen Heap reserviert werden muss, und zum anderen wird er bei h√§ufiger Verwendung des Heaps defragmentiert und es werden immer l√§nger neue Objekte darauf erstellt l√§nger.  Daher habe ich <i>FreeRTOS tats√§chlich</i> nur f√ºr statisch zugewiesenen Speicher konfiguriert, indem <i>ich configSUPPORT_STATIC_ALLOCATION 1 festgelegt habe</i> .  Aber wenn Sie im Standardmodus arbeiten m√∂chten.  Standardm√§√üig verwendet <i>FreeRTOS</i> dynamisch zugewiesenen Speicher, um Betriebssystemelemente zu erstellen. Setzen <i>Sie</i> dann einfach <i>configSUPPORT_STATIC_ALLOCATION 0</i> und <br>  <i>configSUPPORT_DYNAMIC_ALLOCATION 1</i> und vergessen Sie nicht, die Implementierung Ihrer eigenen Mallocs und Callocs √ºber den Speichermanager zu verbinden. Diese Datei lautet beispielsweise FreeRtos / portable / MemMang / heap_1.c.  Beachten Sie jedoch, dass Sie RAM mit einer Reserve f√ºr ein B√ºndel zuweisen m√ºssen, da Sie nicht in der Lage sind, die genaue ben√∂tigte RAM-Menge mit allen Einstellungen zu berechnen (Leerlauf ist aktiviert, die Programm-Timer-Aufgabe ist aktiviert, meine beiden Aufgaben, Warteschlangen, Warteschlangengr√∂√üe f√ºr Timer 10 und Nehmen wir an, es sind definitiv nicht die optimalsten Einstellungen, die funktioniert haben, als ich den Speicher wie folgt zugewiesen habe: <br><blockquote>  7 357 Bytes schreibgesch√ºtzter Codespeicher <br>  535 Bytes schreibgesch√ºtzter Datenspeicher <br>  6.053 Bytes Readwrite-Datenspeicher </blockquote><br>  Die statische Speicherzuordnung ist ‚Äûetwas‚Äú kompakter: <br><blockquote>  7.329 Bytes schreibgesch√ºtzter Codespeicher <br>  535 Bytes schreibgesch√ºtzter Datenspeicher <br>  3.877 Bytes Readwrite-Datenspeicher </blockquote><br>  Sie m√∂gen denken, "gro√üartig ... Sie selbst", aber jetzt interessiert uns die Frage nicht mehr, die im Artikel <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">"Ich habe dem Betriebssystem bis zu 3 KB zugewiesen und nur 3 Aufgaben mit einem 128B-Stapel gestartet, und aus irgendeinem Grund ist bereits nicht gen√ºgend Speicher f√ºr den vierten vorhanden"</a> . In dieser Situation habe ich es aus Gr√ºnden der Klarheit absichtlich gemacht, um den Unterschied zwischen dynamischer und statischer Speicherzuordnung mit denselben Einstellungen zu zeigen. <br></li><li>  <b>Gie√üen Sie</b> nach M√∂glichkeit <b>keine Typen</b> .  Ghosting-Typen f√ºr andere Typen an sich bedeuten, dass etwas im Design nicht stimmt. Manchmal m√ºssen Sie es jedoch aus Bequemlichkeitsgr√ºnden noch umwandeln (z. B. muss Enum in Ganzzahlen umgewandelt werden), und manchmal k√∂nnen Sie nicht darauf verzichten dies, aber dies muss vermieden werden. </li><li>  <b>Einfachheit und Bequemlichkeit</b> .  F√ºr den Benutzer des Wrappers m√ºssen alle Schwierigkeiten verborgen sein, damit sein Leben kein √ñl ist und er es noch nicht komplizieren m√∂chte - er hat die Aufgabe erstellt, alles implementiert, was darin ben√∂tigt wird, sie gestartet und das Leben genie√üen lassen. </li></ul><br>  Wir werden damit beginnen, also haben wir uns die Aufgabe gestellt, eine Aufgabe zu erstellen (es stellte sich direkt aus der Reihe "Verboten zu verbieten" heraus). <br><br><h2>  Aufgabenerstellung </h2><br>  Nach langem Nachforschen haben britische Wissenschaftler ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Die ganze Wahrheit √ºber RTOS von Colin Walls. Artikel Nr. 4. Aufgaben, Kontextwechsel und Unterbrechungen</a> ) (√ºbrigens, wenn Sie nicht wussten, wurde der Assembler f√ºr ARM auch von einem britischen Wissenschaftler erfunden, was mich auch nicht √ºberraschte einmal :)), und so fanden die britischen Wissenschaftler heraus, dass die Aufgabe f√ºr die Mehrheit aller RTOS einen <i>Namen</i> , einen <i>Stapel</i> , <i>eine Stapelgr√∂√üe</i> , eine <i>‚ÄûSteuereinheit‚Äú</i> , eine <i>Kennung oder einen Zeiger auf eine ‚ÄûSteuereinheit‚Äú</i> , eine <i>Priorit√§t</i> und eine <i>Funktion hat, die in der Aufgabe ausgef√ºhrt wird</i> .  Das ist alles, und es war m√∂glich, alles in eine Klasse zu packen, aber es war richtig, wenn wir mit Ihnen ein Betriebssystem geschrieben haben, aber wir machen einen Wrapper. Es macht also keinen Sinn, all diese Dinge in einem Wrapper zu speichern. All dies wird von <u>SIL3</u> ideological OS f√ºr Sie <u>erledigt</u> wir wickeln ab.  Tats√§chlich ben√∂tigen wir nur eine <i>Funktion, die in der Aufgabe ausgef√ºhrt wird,</i> und eine <i>Struktur, in der die ‚ÄûSteuereinheit‚Äú</i> gespeichert ist, die beim Erstellen der Aufgabe und <i>der Aufgabenkennung</i> ausgef√ºllt <i>wird</i> .  Daher kann die Task-Klasse, nennen wir sie <i>Thread,</i> sehr einfach aussehen: <br><br><pre><code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thread</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: tTaskHandle taskHandle ; tTaskContext context ; } ;</code> </pre> <br>  Ich m√∂chte nur die Klasse meiner Aufgabe deklarieren, in der ich alles implementieren kann, was ich brauche, und dann den Zeiger auf das Objekt dieser Klasse an den Wrapper √ºbergeben, der eine Aufgabe mithilfe der RTOS-API erstellt, in der die <i>Execute ()</i> -Methode ausgef√ºhrt wird: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyTask</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Thread { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-comment"><span class="hljs-comment">//do something.. } } ; using tMyTaskStack = std::array&lt;OsWrapper::tStack, static_cast&lt;tU16&gt;(OsWrapper::StackDepth::minimal)&gt; ; inline static tMyTaskStack Stack; //!C++17 } ; MyTask myDesiredTask int main() { Rtos::CreateThread(myTask, MyTask::Stack.data(), "myTask") ; }</span></span></code> </pre> <br>  In "all" RTOS muss zum Erstellen der Aufgabe ein Zeiger auf eine Funktion √ºbergeben werden, die vom Scheduler gestartet wird.  In unserem Fall ist dies die <i>Execute () -</i> Funktion, aber ich kann keinen Zeiger auf diese Methode √ºbergeben, da sie nicht statisch ist.  Daher sehen wir uns an, wie eine Aufgabe in der API "aller" Betriebssysteme erstellt wird, und stellen fest, dass wir eine Aufgabe erstellen k√∂nnen, indem wir einen Parameter an die Aufgabenfunktion √ºbergeben, z. B. f√ºr <i>embOS</i> : <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">OS_TASK_CreateEx</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( OS_TASK* pTask, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">char</span></span></span></span><span class="hljs-function"><span class="hljs-params">* pName, OS_PRIO Priority, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> (*pRoutine)(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> * pVoid ), </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> OS_STACKPTR *pStack, OS_UINT StackSize, OS_UINT TimeSlice, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params">* pContext)</span></span></span></span>;</code> </pre><br>  <b>void * pContext</b> - Dies ist der Schl√ºssel zur L√∂sung.  Lassen Sie uns eine statische Methode haben, einen Zeiger, auf den wir als Zeiger auf eine vom Scheduler aufgerufene Methode √ºbergeben, und als Parameter einen Zeiger auf ein Objekt vom Typ <i>Thread √ºbertragen,</i> wo wir die <i>Execute ()</i> -Methode direkt aufrufen k√∂nnen.  Dies ist genau der Moment, in dem es keinen Weg ohne Zeiger und Umwandlung in Typen gibt, dieser Code jedoch vor dem Benutzer verborgen bleibt: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pContext )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Thread*&gt;(pContext)-&gt;Execute() ; }</code> </pre> <br>  Das hei√üt,  Bei einem solchen Operationsalgorithmus startet der Scheduler die <i>Run-</i> Methode, ein Zeiger auf ein Objekt vom Typ <i>Thread</i> wird an die <i>Run-</i> Methode √ºbergeben.  Die <i>Run-</i> Methode ruft direkt die <i>Execute ()</i> -Methode auf, ein bestimmtes Objekt der <i>Thread-</i> Klasse, die nur unsere Implementierung der Aufgabe ist. <br><br>  Das Problem ist fast gel√∂st, jetzt m√ºssen wir die Methoden implementieren.  Alle Betriebssysteme verf√ºgen √ºber unterschiedliche APIs. <i>Um</i> beispielsweise die Funktion zum Erstellen von Aufgaben f√ºr <i>embOS</i> zu <i>implementieren,</i> m√ºssen Sie die Methode void <i>OS_TASK_CreateEx (..) aufrufen.</i> F√ºr <i>FreeRTOS</i> im dynamischen Speicherzuweisungsmodus ist dies <i>xTaskCreate (..).</i> Obwohl sie ein und dieselbe Essenz haben gleich, aber die Syntax und Parameter sind unterschiedlich.  Wir m√∂chten jedoch nicht jedes Mal die Dateien durchgehen und Code f√ºr jede der Methoden der Klasse f√ºr ein neues Betriebssystem schreiben. Daher m√ºssen wir dies irgendwie in eine Datei packen und ... in Form von Makros ausf√ºhren.  Gro√üartig, aber h√∂r auf, ich habe mir die Makros verboten - ich brauche einen anderen Ansatz. <br><br>  Am einfachsten fiel mir ein, f√ºr jedes Betriebssystem eine eigene Datei mit Inline-Funktionen zu erstellen.  Wenn wir ein anderes Betriebssystem verwenden m√∂chten, m√ºssen wir nur jede dieser Funktionen mithilfe der API dieses Betriebssystems implementieren.  Die folgende Datei <b>rtosFreeRtos.cpp hat</b> sich herausgestellt <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"rtos.hpp"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//For FreeRTOS functions prototypes #include &lt;FreeRTOS.h&gt; //For xTaskCreate #include &lt;task.h&gt; namespace OsWrapper { void wCreateThread(Thread &amp; thread, const char * pName, ThreadPriority prior,const tU16 stackDepth, tStack *pStack) { #if (configSUPPORT_STATIC_ALLOCATION == 1) if (pStack != nullptr) { thread.handle = xTaskCreateStatic(static_cast&lt;TaskFunction_t&gt;(Rtos::Run), pName, stackDepth, &amp;thread, static_cast&lt;uint32_t&gt;(prior), pStack, &amp;thread.taskControlBlock); } #else thread.handle = (xTaskCreate(static_cast&lt;TaskFunction_t&gt;(Rtos::Run), pName, stackDepth, &amp;thread, static_cast&lt;uint32_t&gt;(prior), &amp;thread.handle) == pdTRUE) ? thread.handle : nullptr ; #endif }</span></span></span></span></code> </pre><br>  Die Datei f√ºr embOS <b>rtosEmbOS.cpp sieht</b> m√∂glicherweise <b>genauso aus</b> <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"rtos.hpp"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">//For embOS functions prototypes #include &lt;rtos.h&gt; namespace OsWrapper { void wCreateThread(Thread &amp;thread, const char * pName, ThreadPriority prior,const tU16 stackDepth, tStack *pStack) { constexpr OS_UINT timeSliceNull = 0 ; if (pStack != nullptr) { OS_CreateTaskEx(&amp;(thread.handle), pName, static_cast&lt;OS_PRIO&gt;(prior), Rtos::Run, pStack, ((stackSize == 0U) ? sizeof(pStack) : stackSize), timeSliceNull, &amp;thread) ; } }</span></span></span></span></code> </pre> <br>  Die Typen verschiedener Betriebssysteme sind ebenfalls unterschiedlich, insbesondere die Struktur des Aufgabenkontexts. Erstellen wir daher die Datei rtosdefs.hpp mit unseren eigenen Wrapper-Aliasen. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;FreeRTOS.h&gt; //For TaskHandle_t namespace OsWrapper { using tTaskContext = StaticTask_t; using tTaskHandle = TaskHandle_t; using tStack = StackType_t ; }</span></span></span></span></code> </pre><br>  F√ºr <i>EmbOS</i> k√∂nnte es so aussehen: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;rtos.h&gt; //For OS_TASK namespace OsWrapper { using tTaskContext = OS_TASK; using tTaskHandle = OS_TASK; using tStack = tU16 //   void,      tU16 ; }</span></span></span></span></code> </pre><br>  Daher ist es f√ºr √Ñnderungen unter anderen RTOS ausreichend, √Ñnderungen nur in diesen beiden Dateien rtosdefs.cpp und rtos.cpp vorzunehmen.  Jetzt sehen <i>Thread-</i> und <i>Rtos-</i> Klassen wie c-Bilder aus <br><br><img src="https://habrastorage.org/webt/gp/wq/zl/gpwqzlgnristquzlrcdbxyfm9ro.png" alt="Bild"><br><br><h2>  Starten von Betriebssystemen und Abschlie√üen der Aufgabe </h2><br>  F√ºr Cortex M4 verwenden "alle" Betriebssysteme 3 Interrupts, einen <i>System-Tick-Timer</i> , einen <i>Systemdienst-Aufruf √ºber eine SWI-Anweisung</i> und eine <i>anh√§ngbare Anforderung f√ºr Systemdienst-Interrupts</i> , die haupts√§chlich f√ºr das RTOS erfunden wurden.  Einige RTOS verwenden auch andere Systeminterrupts, diese reichen jedoch f√ºr die meisten "alle" Betriebssysteme aus.  Wenn nicht, k√∂nnen Sie hinzuf√ºgen. Definieren Sie einfach drei Handler f√ºr diese Interrupts. Um das RTOS zu starten, ben√∂tigen Sie eine andere Startmethode: <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleSvcInterrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleSvInterrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">HandleSysTickInterrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Start</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>;</code> </pre><br>  Das erste, was ich brauchte und ohne das ich nicht leben kann, ist ein Benachrichtigungsmechanismus f√ºr Aufgaben.  Im Allgemeinen mag ich ereignisgesteuerte Programmierung, daher muss ich schnell einen Wrapper implementieren, um Aufgaben zu benachrichtigen. <br><br>  Alles stellte sich als recht einfach heraus, jedes Betriebssystem kann dies, au√üer vielleicht <i>uc-OS-II</i> und <i>III</i> , obwohl ich es vielleicht nicht gut gelesen habe, aber meiner Meinung nach ist der Mechanismus der Ereignisse dort im Allgemeinen schwierig, aber <i>na ja</i> , "alles" ist der Rest sie k√∂nnen es auf jeden Fall. <br><br>  Um eine Aufgabe zu benachrichtigen, m√ºssen Sie das Ereignis nur nicht an die Leere, sondern speziell an die Aufgabe senden. Dazu sollte die Benachrichtigungsmethode einen Zeiger auf den Aufgabenkontext oder die Aufgabenkennung haben.  Ich speichere diese nur in der <i>Thread-</i> Klasse, was bedeutet, dass die Thread-Klasse auch eine Alert-Methode haben sollte.  Es sollte auch eine Methode zum Warten auf eine Warnung geben.  Gleichzeitig f√ºgen wir die <i>Sleep (..)</i> -Methode hinzu, mit der die Ausf√ºhrung der aufrufenden Task angehalten wird.  Jetzt sehen beide Klassen so aus: <br><br><img src="https://habrastorage.org/webt/ie/r_/35/ier_35fgsut4a_gf_ismmm91tuk.png" alt="Bild"><br><br><div class="spoiler">  <b class="spoiler_title">rtos.hpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/******************************************************************************* * Filename : Rtos.hpp * * Details : Rtos class is used to create tasks, work with special Rtos * functions and also it contains a special static method Run. In this method * the pointer on Thread should be pass. This method is input point as * the task of Rtos. In the body of the method, the method of concrete Thread * will run. *******************************************************************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __RTOS_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __RTOS_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"thread.hpp"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// for Thread #include "../../Common/susudefs.hpp" #include "FreeRtos/rtosdefs.hpp" namespace OsWrapper { extern void wCreateThread(Thread &amp;, const char *, ThreadPriority, const tU16, tStack *) ; extern void wStart() ; extern void wHandleSvcInterrupt() ; extern void wHandleSvInterrupt() ; extern void wHandleSysTickInterrupt() ; extern void wEnterCriticalSection(); extern void wLeaveCriticalSection(); class Rtos { public: static void CreateThread(Thread &amp;thread , tStack * pStack = nullptr, const char * pName = nullptr, ThreadPriority prior = ThreadPriority::normal, const tU16 stackDepth = static_cast&lt;tU16&gt;(StackDepth::minimal)) ; static void Start() ; static void HandleSvcInterrupt() ; static void HandleSvInterrupt() ; static void HandleSysTickInterrupt() ; friend void wCreateThread(Thread &amp;, const char *, ThreadPriority, const tU16, tStack *); private: //cstat !MISRAC++2008-7-1-2 To prevent reinterpet_cast in the CreateTask static void Run(void *pContext ) { static_cast&lt;Thread*&gt;(pContext)-&gt;Execute() ; } } ; } ; #endif // __RTOS_HPP</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">thread.hpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/******************************************************************************* * Filename : thread.hpp * * Details : Base class for any Taskis which contains the pure virtual * method Execute(). Any active classes which will have a method for running as * a task of RTOS should inherit the Thread and override the Execute() method. * For example: * class MyTask : public OsWrapper::Thread * { * public: * virtual void Execute() override { * while(true) { * //do something.. * } * } ; * *******************************************************************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __THREAD_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __THREAD_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FreeRtos/rtosdefs.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../../Common/susudefs.hpp"</span></span></span><span class="hljs-meta"> namespace OsWrapper { extern void wSleep(const tTime) ; extern void wSleepUntil(tTime &amp;, const tTime) ; extern tTime wGetTicks() ; extern void wSignal(tTaskHandle const &amp;, const tTaskEventMask) ; extern tTaskEventMask wWaitForSignal(const tTaskEventMask, tTime) ; constexpr tTaskEventMask defaultTaskMaskBits = 0b010101010 ; enum class ThreadPriority { clear = 0, lowest = 10, belowNormal = 20, normal = 30, aboveNormal = 80, highest = 90, priorityMax = 255 } ; enum class StackDepth: tU16 { minimal = 128U, medium = 256U, big = 512U, biggest = 1024U }; class Thread { public: virtual void Execute() = 0 ; inline tTaskHandle GetTaskHanlde() const { return handle; } static void Sleep(const tTime timeOut = 1000ms) { wSleep(timeOut) ; }; inline void Signal(const tTaskEventMask mask = defaultTaskMaskBits) { wSignal(handle, mask); }; inline tTaskEventMask WaitForSignal(tTime timeOut = 1000ms, const tTaskEventMask mask = defaultTaskMaskBits) { return wWaitForSignal(mask, timeOut) ; } friend void wCreateThread(Thread &amp;, const char *, ThreadPriority, const tU16, tStack *); private: tTaskHandle handle ; tTaskContext context ; } ; } ; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// __THREAD_HPP</span></span></span></span></code> </pre><br></div></div><br>  Ich habe angefangen, es zu implementieren, und hier wartete das erste Problem auf mich. Es stellte sich heraus, dass ‚Äûjedes‚Äú Betriebssystem seine Funktionen von Interrupts auf unterschiedliche Weise aufruft.  <i>FreeRTOS</i> verf√ºgt beispielsweise √ºber spezielle Implementierungen von Funktionen, um sie aus Interrupts auszuf√ºhren. Wenn beispielsweise eine <i>xTaskNotify (..)</i> -Funktion vorhanden ist, k√∂nnen Sie diese nicht √ºber einen Interrupt aufrufen, sondern m√ºssen <i>xTaskNotifyFromISR (..)</i> aufrufen. <br>  Wenn Sie f√ºr <i>embOS</i> eine Funktion von einem Interrupt aus aufrufen, verwenden <i>Sie</i> beim Eingeben eines Interrupts <i>OS_InInterrupt () und</i> beim Beenden <i>OS_LeaveInterrupt ()</i> .  Ich musste eine <i>InterruptEntry-</i> Klasse <i>erstellen</i> , die nur einen Konstruktor und einen Destruktor hat: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> OsWrapper { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wEnterInterrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">extern</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">wLeaveInterrupt</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">InterruptEntry</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">InterruptEntry</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ wEnterInterrupt() ; } <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> ~InterruptEntry() { wLeaveInterrupt() ; } } ; } ;</code> </pre> <br>  Sie k√∂nnen es so verwenden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> Button::HandleInterrupt() { <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> OsWrapper::InterruptEntry ie; EXTI-&gt;PR = EXTI_PR_PR13 ; myDesiredTask.Signal(); } <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> myDesiredTask::Execute() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (WaitForSignal(<span class="hljs-number"><span class="hljs-number">100000</span></span>ms) == defaultTaskMaskBits) { GPIOC-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">5</span></span>) ; } } } ;</code> </pre> <br>  Bei <i>FreeRTOS sind</i> nat√ºrlich sowohl der Konstruktor als auch der Destruktor leer.  Und f√ºr die Benachrichtigung k√∂nnen Sie die Funktion <i>xTaskNotifyFromISR (..)</i> verwenden, die unabh√§ngig davon, von wo sie aufgerufen wird, ein wenig Aufwand bedeutet, aber aus Gr√ºnden der Universalit√§t nicht m√∂glich ist.  Sie k√∂nnen nat√ºrlich separate Methoden zum Aufrufen von Interrupts erstellen, aber im Moment habe ich beschlossen, dies nur universell zu tun. <br>  Der gleiche Trick wie bei <i>InterruptEntry</i> kann mit dem kritischen Abschnitt ausgef√ºhrt werden: <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> OsWrapper{ <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CriticalSection</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">inline</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CriticalSection</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ wEnterCriticalSection() ; } <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> ~CriticalSection() { wLeaveCriticalSection() ; } } ; } ;</code> </pre> <br>  <i>F√ºgen Sie</i> nun einfach die Implementierung von Funktionen mithilfe der <i>FreeRtos-</i> API zur Datei hinzu und f√ºhren Sie die Pr√ºfung aus, obwohl Sie sie nicht ausf√ºhren konnten. Es ist also klar, dass sie funktionieren wird :) <br><div class="spoiler">  <b class="spoiler_title">rtosFreeRtos.cpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/******************************************************************************* * Filename : rtosFreeRtos.cpp * * Details : This file containce implementation of functions of concrete * FreeRTOS to support another RTOS create the same file with the * same functions but another name&lt; for example rtosEmbOS.cpp and * implement these functions using EmbOS API. * *******************************************************************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../thread.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../mutex.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../rtos.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../../../Common/susudefs.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"rtosdefs.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../event.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;limits&gt; namespace OsWrapper { /***************************************************************************** * Function Name: wCreateThread * Description: Creates a new task and passes a parameter to the task. The * function should call appropriate RTOS API function to create a task. * * Assumptions: RTOS API create task function should get a parameter to pass the * paramete to task. * Some RTOS does not use pStack pointer so it should be set to nullptr * * Parameters: [in] thread - refernce on Thread object * [in] pName - name of task * [in] prior - task priority * [in] stackDepth - size of Stack * [in] pStack - pointer on task stack * Returns: No ****************************************************************************/ void wCreateThread(Thread &amp; thread, const char * pName, ThreadPriority prior, const tU16 stackDepth, tStack *pStack) { #if (configSUPPORT_STATIC_ALLOCATION == 1) if (pStack != nullptr) { thread.handle = xTaskCreateStatic(static_cast&lt;TaskFunction_t&gt;(Rtos::Run), pName, stackDepth, &amp;thread, static_cast&lt;uint32_t&gt;(prior), pStack, &amp;thread.context); } #else thread.handle = (xTaskCreate(static_cast&lt;TaskFunction_t&gt;(Rtos::Run), pName, stackDepth, &amp;thread, static_cast&lt;uint32_t&gt;(prior), &amp;thread.handle) == pdTRUE) ? thread.handle : nullptr ; #endif } /***************************************************************************** * Function Name: wStart() * Description: Starts the RTOS scheduler * * Assumptions: No * Parameters: No * Returns: No ****************************************************************************/ void wStart() { vTaskStartScheduler() ; } /***************************************************************************** * Function Name: wHandleSvcInterrupt() * Description: Handle of SVC Interrupt. The function should call appropriate * RTOS function to handle the interrupt * * Assumptions: No * Parameters: No * Returns: No ****************************************************************************/ void wHandleSvcInterrupt() { vPortSVCHandler() ; } /***************************************************************************** * Function Name: wHandleSvInterrupt() * Description: Handle of SV Interrupt. The function should call appropriate * RTOS function to handle the interrupt * * Assumptions: No * Parameters: No * Returns: No ****************************************************************************/ void wHandleSvInterrupt() { xPortPendSVHandler() ; } /***************************************************************************** * Function Name: wHandleSysTickInterrupt() * Description: Handle of System Timer Interrupt. The function should call * appropriate RTOS function to handle the interrupt * * Assumptions: No * Parameters: No * Returns: No ****************************************************************************/ void wHandleSysTickInterrupt() { xPortSysTickHandler() ; } /***************************************************************************** * Function Name: wSleep() * Description: Suspends the calling task for a specified period of time, * or waits actively when called from main() * * Assumptions: No * Parameters: [in] timeOut - specifies the time interval in system ticks * Returns: No ****************************************************************************/ void wSleep(const tTime timeOut) { vTaskDelay(timeOut) ; } /***************************************************************************** * Function Name: wEnterCriticalSection() * Description: Basic critical section implementation that works by simply * disabling interrupts * * Assumptions: No * Parameters: No * Returns: No ****************************************************************************/ void wEnterCriticalSection() { taskENTER_CRITICAL() ; } /***************************************************************************** * Function Name: wLeaveCriticalSection() * Description: Leave critical section implementation that works by simply * enabling interrupts * * Assumptions: No * Parameters: No * Returns: No ****************************************************************************/ void wLeaveCriticalSection() { taskEXIT_CRITICAL() ; } /**************************************************************************** * Function Name: wEnterInterrupt() * Description: Some RTOS requires to inform the kernel that interrupt code * is executing * * Assumptions: No * Parameters: No * Returns: No ****************************************************************************/ void wEnterInterrupt() { } /**************************************************************************** * Function Name: wLeaveInterrupt() * Description: Some RTOS requires to inform that the end of the interrupt r * outine has been reached; executes task switching within ISR * * Assumptions: No * Parameters: No * Returns: No ****************************************************************************/ void wLeaveInterrupt() { } /**************************************************************************** * Function Name: wSignal() * Description: Signals event(s) to a specified task * * Assumptions: No * Parameters: [in] taskHandle - Reference to the task structure * [in] mask - The event bit mask containing the event bits, * which shall be signaled. * Returns: No ****************************************************************************/ void wSignal(tTaskHandle const &amp;taskHandle, const tTaskEventMask mask) { BaseType_t xHigherPriorityTaskWoken = pdFALSE ; xTaskNotifyFromISR(taskHandle, mask, eSetBits, &amp;xHigherPriorityTaskWoken) ; portYIELD_FROM_ISR( xHigherPriorityTaskWoken ) ; } /**************************************************************************** * Function Name: wWaitForSignal() * Description: Waits for the specified events for a given time, and clears * the event memory when the function returns * * Assumptions: No * Parameters: [in] mask - The event bit mask containing the event bits, * which shall be waited for * [in] timeOut - Maximum time in system ticks waiting for events * to be signaled. * Returns: Set bits ****************************************************************************/ tTaskEventMask wWaitForSignal(const tTaskEventMask mask, tTime timeOut) { uint32_t ulNotifiedValue = 0U ; xTaskNotifyWait( 0U, std::numeric_limits&lt;uint32_t&gt;::max(), &amp;ulNotifiedValue, timeOut); return (ulNotifiedValue &amp; mask) ; } /**************************************************************************** * Function Name: wCreateEvent() * Description: Create an Event object * * Assumptions: No * Parameters: [in] event - reference on tEvent object * * Returns: Handle of created Event ****************************************************************************/ tEventHandle wCreateEvent(tEvent &amp;event) { #if (configSUPPORT_STATIC_ALLOCATION == 1) return xEventGroupCreateStatic(&amp;event); #else return xEventGroupCreate(); #endif } /**************************************************************************** * Function Name: wDeleteEvent() * Description: Create an Event object * * Assumptions: No * Parameters: [in] eventHandle - reference on tEventHandle object * * Returns: No ****************************************************************************/ void wDeleteEvent(tEventHandle &amp;eventHandle) { vEventGroupDelete(eventHandle); } /**************************************************************************** * Function Name: wSignalEvent() * Description: Sets an resumes tasks which are waiting at the event object * * Assumptions: No * Parameters: [in] event - reference on eventHandle object * [in] mask - The event bit mask containing the event bits, * which shall be signaled * * Returns: No ****************************************************************************/ void wSignalEvent(tEventHandle const &amp;eventHandle, const tEventBits mask) { BaseType_t xHigherPriorityTaskWoken = pdFALSE; xEventGroupSetBitsFromISR(eventHandle, mask, &amp;xHigherPriorityTaskWoken) ; portYIELD_FROM_ISR(xHigherPriorityTaskWoken) ; } /**************************************************************************** * Function Name: wWaitEvent() * Description: Waits for an event and suspends the task for a specified time * or until the event has been signaled. * * Assumptions: No * Parameters: [in] event - Reference on eventHandle object * [in] mask - The event bit mask containing the event bits, * which shall be signaled * [in] timeOut - Maximum time in RTOS system ticks until the * event must be signaled. * [in] mode - Indicate mask bit behaviour * * Returns: Set bits ****************************************************************************/ tEventBits wWaitEvent(tEventHandle const &amp;eventHandle, const tEventBits mask, const tTime timeOut, OsWrapper::EventMode mode) { BaseType_t xWaitForAllBits = pdFALSE ; if (mode == OsWrapper::EventMode::waitAnyBits) { xWaitForAllBits = pdFALSE; } return xEventGroupWaitBits(eventHandle, mask, pdTRUE, xWaitForAllBits, timeOut) ; } /**************************************************************************** * Function Name: wCreateMutex() * Description: Create an mutex. Mutexes are used for managing resources by * avoiding conflicts caused by simultaneous use of a resource. The resource * managed can be of any kind: a part of the program that is not reentrant, a * piece of hardware like the display, a flash prom that can only be written to * by a single task at a time, a motor in a CNC control that can only be * controlled by one task at a time, and a lot more. * * Assumptions: No * Parameters: [in] mutex - Reference on tMutex structure * [in] mode - Indicate mask bit behaviour * * Returns: Mutex handle ****************************************************************************/ tMutexHandle wCreateMutex(tMutex &amp;mutex) { #if (configSUPPORT_STATIC_ALLOCATION == 1) return xSemaphoreCreateMutexStatic(&amp;mutex) ; #else return xSemaphoreCreateMutex(); #endif } /**************************************************************************** * Function Name: wDeleteMutex() * Description: Delete the mutex. * * Assumptions: No * Parameters: [in] mutex - handle of mutex * * Returns: Mutex handle ****************************************************************************/ void wDeleteMutex(tMutexHandle &amp;handle) { vSemaphoreDelete(handle) ; } /**************************************************************************** * Function Name: wLockMutex() * Description: Claim the resource * * Assumptions: No * Parameters: [in] handle - handle of mutex * [in] timeOut - Maximum time until the mutex should be available * * Returns: true if resource has been claimed, false if timeout is expired ****************************************************************************/ bool wLockMutex(tMutexHandle const &amp;handle, tTime timeOut) { return static_cast&lt;bool&gt;(xSemaphoreTake(handle, timeOut)) ; } /**************************************************************************** * Function Name: wUnLockMutex() * Description: Releases a mutex currently in use by a task * * Assumptions: No * Parameters: [in] handle - handle of mutex * * Returns: No ****************************************************************************/ void wUnLockMutex(tMutexHandle const &amp;handle) { BaseType_t xHigherPriorityTaskWoken = pdFALSE ; xSemaphoreGiveFromISR(handle, &amp;xHigherPriorityTaskWoken) ; portYIELD_FROM_ISR( xHigherPriorityTaskWoken ) ; } /**************************************************************************** * Function Name: wSleepUntil() * Description: Suspends the calling task until a specified time, or waits * actively when called from main() * * Assumptions: No * Parameters: [in] last - Refence to a variable that holds the time at which * the task was last unblocked. The variable must be initialised * with the current time prior to its first use * [in] timeOut - Time to delay until, the task will be unblocked * at time * * Returns: No ****************************************************************************/ void wSleepUntil(tTime &amp; last, const tTime timeOut) { vTaskDelayUntil( &amp;last, timeOut) ; } /**************************************************************************** * Function Name: wGetTicks() * Description: Returns the current system time in ticks as a native integer * value * * Assumptions: No * Parameters: No * * Returns: Current system time in ticks ****************************************************************************/ tTime wGetTicks() { return xTaskGetTickCount(); } }</span></span></span></span></code> </pre><br></div></div><br><img src="https://habrastorage.org/webt/4a/sm/mm/4asmmm71hosjm510maad5hcadrm.png" alt="Bild"><br><br><h2>  Wir verfeinern die Aufgabe weiter </h2><br>  Die Aufgabe hat jetzt fast alles, was Sie brauchen, wir haben die Sleep () -Methode hinzugef√ºgt.  Diese Methode pausiert die Aufgabe f√ºr eine bestimmte Zeit.  In den meisten F√§llen reicht dies aus, aber wenn Sie eine klar festgelegte Zeit ben√∂tigen, kann Sleep () Ihnen Probleme bereiten.  Sie m√∂chten beispielsweise eine Berechnung durchf√ºhren, die LED blinken lassen und dies genau alle 100 ms tun <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">void</span></span> MyTask::Execute() { <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { DoCalculation(); <span class="hljs-comment"><span class="hljs-comment">//It takes about 10ms Led1.Toggle() ; Sleep(100ms) ; } }</span></span></code> </pre><br>  Dieser Code blinkt alle 110 ms eine LED.  Wenn Sie jedoch alle 100 ms einmal m√∂chten, k√∂nnen Sie die Berechnungszeit grob berechnen und den Ruhezustand (90 ms) festlegen.  Was aber, wenn die Berechnungszeit von den Eingabeparametern abh√§ngt, ist das Blinken √ºberhaupt nicht deterministisch.  F√ºr solche F√§lle gibt es in "allen" Betriebssystemen spezielle Methoden wie DelayUntil ().  Es funktioniert nach diesem Prinzip: Zuerst m√ºssen Sie sich den aktuellen Wert des Tick-Z√§hlers des Betriebssystems merken und dann zu diesem Wert die Anzahl der Ticks hinzuf√ºgen, f√ºr die Sie die Aufgabe anhalten m√ºssen. Sobald der Tick-Z√§hler diesen Wert erreicht, wird die Aufgabe entsperrt.  Somit wird die Aufgabe genau auf den von Ihnen eingestellten Wert festgelegt und Ihre LED blinkt unabh√§ngig von der Dauer der Berechnung genau alle 100 ms. <br>  Dieser Mechanismus ist in verschiedenen Betriebssystemen unterschiedlich implementiert, verf√ºgt jedoch √ºber einen Algorithmus.  Infolgedessen wird der beispielsweise auf FreeRTOS implementierte Mechanismus auf den im folgenden Bild gezeigten Zustand vereinfacht: <br><br><img src="https://habrastorage.org/webt/tg/n1/hb/tgn1hba-pczt2p5b0dzy0kut-ua.png" alt="Bild"><br><br>  Wie Sie sehen k√∂nnen, erfolgt das Lesen des Anfangszustands des Tick-Z√§hlers des Betriebssystems vor dem Eintritt in eine Endlosschleife, und wir m√ºssen uns etwas einfallen lassen, um dies zu implementieren.  Eine Entwurfsvorlage <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">hilft</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Template-Methode</a> .    ,         ,    ,      ,      Execute(),     , ..    .     ,        (   ),      . <br><br><pre> <code class="cpp hljs"> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Thread</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>= <span class="hljs-number"><span class="hljs-number">0</span></span> ; <span class="hljs-keyword"><span class="hljs-keyword">friend</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Rtos</span></span></span><span class="hljs-class"> ;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ lastWakeTime = wGetTicks() ; Execute(); } ... tTime lastWakeTime = <span class="hljs-number"><span class="hljs-number">0</span></span>ms ; ... }</code> </pre> <br>     Run  Rtos,      Execute(),   Run()  Thread.      Rtos ,       Run()   Thread. <br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Run</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">void</span></span></span></span><span class="hljs-function"><span class="hljs-params"> *pContext )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;Thread*&gt;(pContext)-&gt;Run() ; }</code> </pre><br>     <i>SleepUntil()</i> ,          .  ,           ,         ,     <i>SleepUntil()</i> ,        .        : <br><img src="https://habrastorage.org/webt/aw/nx/ts/awnxtsvd-odgyfaagkl3egc_tvs.png" alt="Bild"><br><br><div class="spoiler"> <b class="spoiler_title">thread.hpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/******************************************************************************* * Filename : thread.hpp * * Details : Base class for any Taskis which contains the pure virtual * method Execute(). Any active classes which will have a method for running as * a task of RTOS should inherit the Thread and override the Execute() method. * For example: * class MyTask : public OsWrapper::Thread * { * public: * virtual void Execute() override { * while(true) { * //do something.. * } * } ; * * Author : Sergey Kolody *******************************************************************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __THREAD_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __THREAD_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"FreeRtos/rtosdefs.hpp"</span></span></span><span class="hljs-meta"> #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"../../Common/susudefs.hpp"</span></span></span><span class="hljs-meta"> namespace OsWrapper { extern void wSleep(const tTime) ; extern void wSleepUntil(tTime &amp;, const tTime) ; extern tTime wGetTicks() ; extern void wSignal(tTaskHandle const &amp;, const tTaskEventMask) ; extern tTaskEventMask wWaitForSignal(const tTaskEventMask, tTime) ; constexpr tTaskEventMask defaultTaskMaskBits = 0b010101010 ; enum class ThreadPriority { clear = 0, lowest = 10, belowNormal = 20, normal = 30, aboveNormal = 80, highest = 90, priorityMax = 255 } ; enum class StackDepth: tU16 { minimal = 128U, medium = 256U, big = 512U, biggest = 1024U }; class Thread { public: virtual void Execute() = 0 ; inline tTaskHandle GetTaskHanlde() const { return handle; } static void Sleep(const tTime timeOut = 1000ms) { wSleep(timeOut) ; }; void SleepUntil(const tTime timeOut = 1000ms) { wSleepUntil(lastWakeTime, timeOut); }; inline void Signal(const tTaskEventMask mask = defaultTaskMaskBits) { wSignal(handle, mask); }; inline tTaskEventMask WaitForSignal(tTime timeOut = 1000ms, const tTaskEventMask mask = defaultTaskMaskBits) { return wWaitForSignal(mask, timeOut) ; } friend void wCreateThread(Thread &amp;, const char *, ThreadPriority, const tU16, tStack *); friend class Rtos ; private: tTaskHandle handle ; tTaskContext context ; tTime lastWakeTime = 0ms ; void Run() { lastWakeTime = wGetTicks() ; Execute(); } } ; } ; #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">endif</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// __THREAD_HPP</span></span></span></span></code> </pre><br></div></div><br><div class="spoiler"> <b class="spoiler_title">rtos.hpp</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">/******************************************************************************* * Filename : Rtos.hpp * * Details : Rtos class is used to create tasks, work with special Rtos * functions and also it contains a special static method Run. In this method * the pointer on Thread should be pass. This method is input point as * the task of Rtos. In the body of the method, the method of concrete Thread * will run. *******************************************************************************/</span></span> <span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">ifndef</span></span></span><span class="hljs-meta"> __RTOS_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">define</span></span></span><span class="hljs-meta"> __RTOS_HPP #</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"thread.hpp"</span></span></span><span class="hljs-meta"> </span><span class="hljs-comment"><span class="hljs-meta"><span class="hljs-comment">// for Thread #include "../../Common/susudefs.hpp" #include "FreeRtos/rtosdefs.hpp" namespace OsWrapper { extern void wCreateThread(Thread &amp;, const char *, ThreadPriority, const tU16, tStack *) ; extern void wStart() ; extern void wHandleSvcInterrupt() ; extern void wHandleSvInterrupt() ; extern void wHandleSysTickInterrupt() ; extern void wEnterCriticalSection(); extern void wLeaveCriticalSection(); class Rtos { public: static void CreateThread(Thread &amp;thread , tStack * pStack = nullptr, const char * pName = nullptr, ThreadPriority prior = ThreadPriority::normal, const tU16 stackDepth = static_cast&lt;tU16&gt;(StackDepth::minimal)) ; static void Start() ; static void HandleSvcInterrupt() ; static void HandleSvInterrupt() ; static void HandleSysTickInterrupt() ; friend void wCreateThread(Thread &amp;, const char *, ThreadPriority, const tU16, tStack *); friend class Thread ; private: //cstat !MISRAC++2008-7-1-2 To prevent reinterpet_cast in the CreateTask static void Run(void *pContext ) { static_cast&lt;Thread*&gt;(pContext)-&gt;Run() ; } } ; } ; #endif // __RTOS_HPP</span></span></span></span></code> </pre><br></div></div><br><br><h2>  Ereignisse </h2><br>  , ,    ,    ,      ,   ,     .  ,     . <br><br>         ,     ,        ,    ,     ,         ,     ,             . ,          .      ,      ,     ,            ,        . <br><br><img src="https://habrastorage.org/webt/gv/na/8k/gvna8ktlrzvrposxbpwhzpn0keq.png"><br><br>    : <br><br><pre> <code class="cpp hljs">OsWrapper::Event event{<span class="hljs-number"><span class="hljs-number">10000</span></span>ms, <span class="hljs-number"><span class="hljs-number">3</span></span>}; <span class="hljs-comment"><span class="hljs-comment">//  ,    10000ms,    0    1. void SomeTask::Execute() { while(true) { using OsWrapper::operator""ms ; Sleep(1000ms); event.Signal() ; //      0   1. Sleep(1000ms); event.SetMaskBits(4) //    2. event.Signal() ; //      2. } } ; void AnotherTask::Execute() { while(true) { using namespace::OsWrapper ; //,      ,    10000ms if ((event.Wait() &amp; defaultTaskMaskBits) != 0) { GPIOC-&gt;ODR ^= (1 &lt;&lt; 5) ; } } } ;</span></span></code> </pre><br><br><h2> ,    </h2><br>         ,         ,   : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">GitHub OsWrapper</a> .   ,   : <br><pre> <code class="cpp hljs">OsWrapper::MailBox&lt;tU32, <span class="hljs-number"><span class="hljs-number">10</span></span>&gt; <span class="hljs-built_in"><span class="hljs-built_in">queue</span></span>; <span class="hljs-comment"><span class="hljs-comment">//    10   int void ReceiveTask::Execute() { tU32 item; while(true) { using OsWrapper::operator""ms ; if (queue.Get(item, 10000ms)) { //    GPIOC-&gt;ODR ^= (1 &lt;&lt; 9); } } } ; void SendTask::Execute() { tU32 item = 0U; while(true) { queue.Put(item); item ++; SleepUntil(1000ms); } } ;</span></span></code> </pre><br><br><h2>      </h2><br>  ,       ,     ,   :  <i>LedTask</i> ,     2  ,    2     <i>myTask</i> ,   10  ,    ,    .          2 .      ,     <i>event</i> .      ,     :) <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> OsWrapper::<span class="hljs-keyword"><span class="hljs-keyword">operator</span></span><span class="hljs-string"><span class="hljs-string">""</span></span>ms ; OsWrapper::Event event{<span class="hljs-number"><span class="hljs-number">10000</span></span>ms, <span class="hljs-number"><span class="hljs-number">1</span></span>}; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyTask</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> OsWrapper::Thread { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">virtual</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Execute</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> override </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">while</span></span>(<span class="hljs-literal"><span class="hljs-literal">true</span></span>) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (event.Wait() != <span class="hljs-number"><span class="hljs-number">0</span></span>) { GPIOC-&gt;ODR ^= (<span class="hljs-number"><span class="hljs-number">1</span></span> &lt;&lt; <span class="hljs-number"><span class="hljs-number">9</span></span>); } } } <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> tMyTaskStack = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">array</span></span>&lt;OsWrapper::tStack, <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;tU16&gt;(OsWrapper::StackDepth::minimal)&gt; ; <span class="hljs-keyword"><span class="hljs-keyword">inline</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> tMyTaskStack Stack; <span class="hljs-comment"><span class="hljs-comment">//C++17   IAR 8.30 } ; class LedTask : public OsWrapper::Thread { public: virtual void Execute() override { while(true) { GPIOC-&gt;ODR ^= (1 &lt;&lt; 5) ; using OsWrapper::operator""ms ; SleepUntil(2000ms); event.Signal() ; } } using tLedStack = std::array&lt;OsWrapper::tStack, static_cast&lt;tU16&gt;(OsWrapper::StackDepth::minimal)&gt; ; inline static tLedStack Stack; //C++17   IAR 8.30 } ; MyTask myTask; LedTask ledTask; int main() { using namespace OsWrapper ; Rtos::CreateThread(myTask, MyTask::Stack.data(), "myTask", ThreadPriority::lowest, MyTask::Stack.size()) ; Rtos::CreateThread(ledTask, LedTask::Stack.data()) ; Rtos::Start(); return 0; }</span></span></code> </pre> <br><br><h2>  Fazit </h2><br>           . ,    ++           ++ .          ++. <br>         ,   ++, ,   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><b> </b></a> ,      ,    ,         ,    ,    .         ,       . <br><br>          ,   ,          ++ :) <br><br>       <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Clion</a> .     ,           ,      IAR toolchain,   ,  ,   elf ,   hex , ,      GDB.     ‚Äî   ,     ,      ,    2 ,      ,   ,    ,      .     ,     Clion.     ,   IAR toolchain ,  . <br><br>      IAR       8.30.1,        .   : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">XNUCLEO-F411RE</a> ,  ST-Link.   ,  ,      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Clion</a> ‚Äî   ,    :) <br><br><img src="https://habrastorage.org/webt/tx/m_/e8/txm_e8pms1viazgy6cypd-kjj3q.png" alt="Bild"><br><br>   <i>IAR</i>    : <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">  IAR 8.30.1</a>    ,    ,      github,   ,        ,               FreeRtos. <br><br>  Z.Y.      GitHub <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="> </a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de420467/">https://habr.com/ru/post/de420467/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de420457/index.html">√úbersicht √ºber die Simplify3D 3D-Drucksoftware</a></li>
<li><a href="../de420459/index.html">Symbol mit einem Z√§hler in der oberen Symbolleiste: Ein Beispiel f√ºr verschiedene Ans√§tze f√ºr eine Aufgabe</a></li>
<li><a href="../de420461/index.html">10 Zitate von schlechten Designern</a></li>
<li><a href="../de420463/index.html">ICO ist zu Recht im Niedergang, aber sie haben eine Chance, sich zu √§ndern</a></li>
<li><a href="../de420465/index.html">Nginx-Variablen mit njs: einfach, schmerzlos und √ºber JavaScript</a></li>
<li><a href="../de420469/index.html">Merkmale der Verwendung von Druiden am Beispiel von Klassenkameraden</a></li>
<li><a href="../de420471/index.html">Drei technische Berichte zur RIT 2018 von Plesk</a></li>
<li><a href="../de420473/index.html">B√ºcher f√ºr Anf√§nger oder warum es so wichtig ist zu lesen</a></li>
<li><a href="../de420475/index.html">Vergleich von Raylogic 11G- und Raylogic V12-Laserschneidmaschinen</a></li>
<li><a href="../de420477/index.html">HyperX Cloud Stinger Core-Test: Ein leichtes und robustes Charakter-Headset</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>