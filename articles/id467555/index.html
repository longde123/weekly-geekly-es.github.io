<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🔵 👫 👵🏼 Seberapa baik Anda mengenal CSS? (+ uji mini) 🙊 🍹 🧑🏼‍🤝‍🧑🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Perbedaan antara berhasil menggunakan CSS dan upaya menyakitkan untuk menghadapinya sering tergantung pada detail kecil. Padahal, CSS memiliki banyak ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Seberapa baik Anda mengenal CSS? (+ uji mini)</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467555/"><img src="https://habrastorage.org/webt/dz/qp/ty/dzqptyyxjsszvi4aqmupeqyqw98.png" alt="gambar"><br><br>  Perbedaan antara berhasil menggunakan CSS dan upaya menyakitkan untuk menghadapinya sering tergantung pada detail kecil.  Padahal, CSS memiliki banyak nuansa.  Salah satu area paling umum di mana saya sering melihat perjuangan seperti itu adalah tata letak styling.  Secara pribadi, saya suka belajar pola CSS.  Saya perhatikan bahwa saya cenderung menggunakan sejumlah kecil dari mereka untuk menyelesaikan sebagian besar masalah dengan tata letak.  Artikel ini adalah tentang pola-pola CSS yang saya gunakan untuk mengatasi masalah tata letak.  Situasi akan dipertimbangkan terlepas dari metodologi CSS yang digunakan: apakah itu SMACSS, BEM, atau bahkan topik CSS-in-JS yang panas, karena semuanya fokus pada properti CSS itu sendiri, dan bukan pada arsitektur, organisasi, atau strategi. <br><a name="habracut"></a><br><hr><br><h2>  Untuk bersenang-senang, mari kita mulai dengan tes. </h2><br>  Kami akan menggunakan platform yang saya kembangkan, disebut <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Questionable.io,</a> dan saya menggunakannya untuk membuat tes, yang akan kita lanjutkan ke bawah.  Jangan khawatir, tidak ada data pribadi yang dikumpulkan, hasilnya anonim dan itu benar-benar gratis. <br><br>  Tujuan pengujian adalah untuk melihat apakah Anda dapat mengenali perilaku CSS tertentu dan beberapa masalah tanpa terlebih dahulu membaca artikel.  Saya tidak akan mempersulit pengujian, tetapi nuansa gaya CSS bisa sangat rumit.  Ingat, pengujian ini hanya untuk bersenang-senang.  Hasil tes tidak menunjukkan kesejukan Anda, tetapi saya berharap mereka tetap berguna. <br><br>  Tes terdiri dari 10 pertanyaan dan harus memakan waktu tidak lebih dari 10 menit <br><blockquote>  <b>Dari penerjemah:</b> <br><br>  Di akhir artikel tentang Habr, jajak pendapat tentang jumlah poin yang dicetak dalam tes ditambahkan. <br></blockquote><br><h4>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Lulus tes</a> </h4><br>  <b>Catatan:</b> jika Anda tidak ingin membuang waktu, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berikut ini tautan</a> ke pertanyaan dengan jawaban yang benar. <br><br>  Apakah Anda lulus ujian?  Hebat!  Mari kita telusuri pertanyaan satu per satu untuk mendapatkan gambaran yang lebih baik tentang pola gaya yang terpengaruh dalam tes. <br><br><h2>  Pertanyaan 1: Model Blok </h2><br>  Mempelajari model blok harus menjadi prioritas dalam daftar pengembang FrontEnd.  Mungkin artikel " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Model Kotak CSS</a> " agak lama, jangan meremehkan nilai dan relevansinya dengan CSS modern.  Model blok adalah dasar untuk hampir setiap masalah terkait tata letak CSS. <br><br>  Pertanyaan khusus ini memeriksa bagaimana cara mencari lebar berdasarkan prinsip-prinsip model blok.  Blok memiliki lebar eksplisit melalui properti <code>width: 100px</code> , tetapi ternyata <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">aturan model blok default</a> menerapkan properti <code>width</code> ke layer "content" dari blok ini.  Lebar yang dihasilkan (seberapa lebar blok digambarkan pada halaman) adalah jumlah dari konten, lapisan dan lapisan perbatasan.  Untuk alasan ini, jawabannya adalah 112px. <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.box</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">width</span></span>: <span class="hljs-number"><span class="hljs-number">100px</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Take this */</span></span> <span class="hljs-attribute"><span class="hljs-attribute">height</span></span>: <span class="hljs-number"><span class="hljs-number">50px</span></span>; <span class="hljs-attribute"><span class="hljs-attribute">padding</span></span>: <span class="hljs-number"><span class="hljs-number">5px</span></span>; <span class="hljs-comment"><span class="hljs-comment">/* Plus this x2 for left and right */</span></span> <span class="hljs-attribute"><span class="hljs-attribute">border</span></span>: <span class="hljs-number"><span class="hljs-number">1px</span></span> solid red; <span class="hljs-comment"><span class="hljs-comment">/* Plus this x2 for left and right */</span></span> <span class="hljs-attribute"><span class="hljs-attribute">background-color</span></span>: red; <span class="hljs-comment"><span class="hljs-comment">/* = 112px of computed width */</span></span> }</code> </pre><br>  Jika Anda dihadapkan dengan situasi di mana kolom atau tab terakhir di antarmuka dipindahkan ke baris berikutnya, meskipun Anda menentukan semua <code>width: 20%;</code>  dan yakin bahwa mereka akan cocok dengan 100% elemen induk, mungkin ini menjadi masalah.  Lima kolom dengan lebar 20% ditempatkan di 100%, tetapi jika mereka diberi tambahan padding dan / atau perbatasan, ini akan menambah lebar masing-masing, sehingga tidak cukup ruang di baris saat ini untuk kolom terakhir. <br><br>  Ketika CSS3 diperkenalkan, alat baru yang disebut <code>box-sizing</code> .  Hal ini memungkinkan kita untuk mengontrol lapisan model blok yang ingin kita terapkan properti <code>width</code> .  Sebagai contoh, kita dapat menentukan <code>box-sizing: border-box</code> .  Ini berarti bahwa kami ingin aturan lebar diterapkan ke lapisan batas luar alih-alih lapisan konten.  Dalam pertanyaan dari tes, jika <code>box-sizing: border-box</code> properti <code>box-sizing: border-box</code> diterapkan, lebar blok yang dihasilkan adalah 100px. <br><br>  Bagi sebagian dari Anda, ini adalah fakta yang terkenal, tetapi tetap akan menjadi pengingat yang baik bagi para profesional dan pemula. <br><br>  Ada sejumlah artikel tentang model blok dan cara menggunakan properti ukuran kotak sebagai reset untuk segera menerapkannya ke seluruh proyek.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ukuran Kotak</a> dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Warisan ukuran kotak Mungkin Sedikit Lebih Baik Praktik Terbaik</a> adalah dua artikel Trik CSS yang baik untuk dibaca. <br><br><h2>  Pertanyaan 2: Batas Elemen </h2><br>  Pertanyaan tes kedua sebagian dapat dilihat sebagai kelanjutan dari yang pertama.  Ingat, itu satu hal untuk dibaca: "Model blok memiliki lapisan (konten, padding, perbatasan) dan mereka semua mempengaruhi lebar akhir dan tinggi elemen", hal lain adalah untuk dapat mengenali masalah model blok dalam situasi nyata.  Masalah khusus ini agak klasik di antara mereka yang telah bekerja dengan CSS selama beberapa waktu.  Ini mengikuti dari fakta bahwa frame akan menempati ruang tambahan tertentu dan menjauhkan elemen di sekitarnya, karena mereka adalah bagian dari model blok.  Menambahkan bingkai sambil mengubah keadaan elemen, seperti <code>:hover</code> , akan berarti bahwa blok akan menjadi lebih besar dan kemudian blok yang mengikuti akan didorong ke bawah.  Ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bisa mengganggu</a> : <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/bradwestfall/embed/preview/pqNoav" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Dari semua solusi yang mungkin disebutkan dalam pertanyaan pengujian, menambahkan <code>border: 2px solid transparent</code> ke keadaan semula (tanpa melayang) adalah satu-satunya solusi yang mungkin untuk masalah tersebut.  <code>box-sizing</code> tidak menyelesaikan masalah ini, karena kami tidak secara eksplisit mengatur ketinggian.  Jika kami melakukan ini, frame akan menjadi bagian dari keseluruhan tinggi elemen dan pergeseran tidak akan terjadi, tetapi ini bukan kasus kami. <br><br>  Ada solusi lain yang tidak kami sebutkan dalam opsi jawaban.  Salah satunya adalah menambahkan pseudo-border menggunakan properti <code>box-shadow</code> atau menggunakan <code>outline</code> alih-alih <code>border</code> .  Masing-masing tidak akan menyebabkan bias, karena itu bukan lapisan model blok.  Inilah <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">artikel Trik CSS</a> lain di mana Anda dapat membaca lebih lanjut tentang solusi semacam itu. <br><br>  Catatan: <br>  Ingatlah bahwa <code>outline</code> tidak mendukung <code>border-radius</code> <br><br><h2>  Pertanyaan 3: Posisi - absolut vs tetap </h2><br>  Selain memahami kapan harus menggunakan masing-masing jenis dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">bagaimana mereka berbeda dalam representasi visual</a> , juga sangat penting untuk mengetahui aturan tentang bagaimana masing-masing metode penentuan posisi terikat pada elemen induk menggunakan properti atas, kanan, bawah, atau kiri. <br><br>  Pertama-tama, mari kita lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">blok yang berisi</a> .  Definisi singkatnya adalah bahwa blok yang mengandung paling sering merupakan induk dari setiap elemen yang dipertanyakan.  Namun, aturan untuk blok berisi berbeda untuk elemen yang diposisikan secara mutlak dan tetap. <br><br>  <b>1) Untuk elemen absolut</b> .  Blok yang berisi adalah leluhur terdekat yang posisinya tidak <code>static</code> .  Misalnya, ketika sebuah elemen diposisikan secara absolut dan berisi properti <code>top</code> , <code>right</code> , <code>bottom</code> atau <code>left</code> , mereka akan diposisikan relatif terhadap setiap induk yang memiliki posisi <code>absolute</code> , <code>relative</code> , <code>fixed</code> atau <code>sticky</code> . <br>  <b>2) Untuk elemen tetap</b> .  Blok yang berisi adalah viewport, meskipun ada elemen induk dengan posisi selain <code>static</code> .  Selain itu, perilaku gulir berbeda dari elemen yang diposisikan benar-benar.  Elemen tetap tetap "tetap" di area tampilan, karenanya namanya. <br><br>  Banyak pengembang berpikir bahwa elemen yang diposisikan benar-benar hanya mencari elemen induk terdekat dengan posisi <code>position: relative</code> .  Kesalahpahaman ini telah menyebar luas hanya karena <code>position: relative</code> paling sering ditentukan berpasangan dengan <code>position: absolute</code> untuk membuat blok yang mengandung.  Alasan mengapa ini sering digunakan adalah bahwa posisi relatif dari blok induk membiarkannya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">dalam aliran</a> , yang sering lebih disukai.  Ada situasi di mana induk dari elemen yang diposisikan mutlak itu sendiri diposisikan sepenuhnya.  Ini sangat normal.  Jika semua orang tua statis, maka elemen yang benar-benar diposisikan akan dilampirkan ke viewport - tetapi agar itu bergulir bersama dengan viewport. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/bradwestfall/embed/preview/pqybLw" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Ada sedikit tambahan aturan yang disebutkan di atas: dalam situasi di mana elemen induk memiliki properti <code>transform</code> ( <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">antara lain</a> ) dengan nilai selain <code>none</code> , itu menjadi blok yang berisi elemen yang diposisikan secara mutlak dan tetap.  Konfirmasi ini dapat dilihat di CodePen, di mana elemen dengan teks "Perhatikan!"  Merupakan elemen tetap, dan induk memiliki properti transformasi, tetapi hanya ketika kursor mouse di atasnya (dalam status <code>:hover</code> ) <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/bradwestfall/embed/preview/EGKmZK" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Pertanyaan 4: Ciutkan margin elemen orang tua dan anak </h2><br>  Ini adalah salah satu dari hal-hal kecil CSS yang dapat menyebabkan banyak masalah jika Anda tidak tahu cara kerjanya.  Ada konsep yang disebut margin runtuh dan banyak orang yang akrab dengan manifestasi ini, yang disebut margin runtuh saudara kandung yang berdekatan.  Namun, ada bentuk lain, yang disebut Ciutkan margin dari orang tua dan anak pertama / terakhir, yang kurang dikenal.  Berikut ini adalah demonstrasi kedua kasus: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/bradwestfall/embed/preview/JwXEdp" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Setiap tag paragraf memiliki margin atas dan bawah sama dengan 1em, yang ditata oleh browser.  Sejauh ini ini adalah bagian termudah dari situasi ini.  Tapi mengapa jarak antar paragraf bukan 2em (jumlah atas dan bawah)?  Ini disebut runtuh margin saudara kandung yang berdekatan.  Margin tumpang tindih sedemikian rupa sehingga semakin besar dari dua margin akan menjadi ukuran kesenjangan, jadi dalam hal ini kesenjangan akan menjadi 1 em. <br><br>  Namun, sesuatu yang aneh sedang terjadi.  Apakah Anda memperhatikan bahwa margin atas paragraf pertama tidak membuat celah antara itu dan div wadah biru?  Alih-alih melanggar, tampaknya menanamkan margin di div induk, seolah-olah div memiliki margin atas.  Ini disebut Runtuh margin orang tua dan anak pertama / terakhir.  Jenis margin keruntuhan ini tidak akan terjadi dalam keadaan tertentu jika berikut ini merupakan karakteristik dari induk: <br><br><ul><li>  Ada padding atas / bawah lebih besar dari nol <br></li><li>  Ada batas atas / bawah lebih besar dari nol <br></li><li>  Konteks pemformatan blok ditentukan yang dapat dibuat menggunakan <code>overflow: hidden</code> atau <code>overflow: auto</code> <br></li><li>  Tampilan: rangkaian properti root-rooting (dukungan browser buruk) <br></li></ul><br>  Ketika saya senang menjelaskan kepada orang-orang ini detail CSS kecil dan menyelesaikannya dengan padding atau border, jawabannya hampir selalu: "Bagaimana dengan padding atau border sama dengan 0?".  Ya, ini tidak berhasil, karena nilainya harus bilangan bulat positif. <br><br>  Pada contoh sebelumnya, padding 1px memungkinkan kita untuk beralih antara menggunakan collapse dan mencegah margin yang menyusut dari induk dan anak.  Ruang yang muncul antara paragraf pertama / terakhir dan induk adalah padding 1px, tetapi sekarang margin dianggap bagian dalam wadah, karena lapisan padding menciptakan penghalang untuk mencegah margin dari runtuh. <br><br>  Adapun pertanyaannya, saya yakin Anda dapat melihat apa masalahnya di antarmuka ini: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/bradwestfall/embed/preview/BvKLpZ" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Elemen pertama dengan kelas <code>.comment</code> (tanpa kelas <code>.moderator</code> ) mengecilkan margin.  Bahkan tanpa melihat kode, kita dapat melihat bahwa elemen dengan kelas <code>.moderator</code> memiliki bingkai, dan elemen tanpa kelas ini tidak.  Sebenarnya ada tiga jawaban atas pertanyaan ini yang dianggap benar. Masing-masing, pada kenyataannya, sudah diterapkan di sumber CodePen, mereka hanya berkomentar. <br><br>  Salah satu alasan mengapa jenis margin keruntuhan ini tidak sebanyak yang dikenal sebagai yang lain adalah karena ada banyak situasi di mana kita dapat menghindarinya secara tidak sengaja.  Elemen Flexbox dan Grid membuat konteks pemformatan blok, jadi saat menggunakannya, kami tidak menemukan jenis margin runtuh ini.  Jika antarmuka komentar kami adalah proyek nyata, kemungkinan bagus bahwa bantalan ditetapkan pada keempat sisi untuk meninggalkan ruang sekitar, dan ini, pada gilirannya, memperbaiki keruntuhan margin bagi kami. <br><br><h2>  Pertanyaan 5: Persentase dari apa? </h2><br>  Ketika satuan persentase digunakan, persentase didasarkan pada lebar atau tinggi blok yang mengandung (biasanya induknya).  Seperti yang kami katakan sebelumnya, elemen dengan properti <code>transform</code> akan menjadi blok yang berisi, jadi ketika elemen menggunakan transformasi, unit dalam persen (hanya untuk <code>transform</code> ) <code></code> pada ukuran elemen itu sendiri, dan bukan pada ukuran induk. <br><br>  Dalam contoh di bawah ini, kita dapat melihat bahwa 50% mengambil dua nilai berbeda tergantung pada konteksnya.  Blok merah pertama memiliki properti <code>margin-left: 50%</code> , dan blok merah kedua menggunakan <code>transform: translateX(50%)</code> . <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/bradwestfall/embed/preview/Kbzyrq" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><h2>  Pertanyaan 6: Model blok mogok lagi ... </h2><br>  Hanya Anda yang berpikir bahwa kami telah selesai berbicara tentang model blok ... <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/bradwestfall/embed/preview/maOJmO" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Masalahnya adalah karena kami menggunakan <code>width: 100%</code> untuk footer dan pada saat yang sama menambahkan padding.  Lebar wadah adalah 500px, yang berarti bahwa lapisan konten footer (menjadi 100%) juga 500px sebelum paddings ditambahkan ke ukuran ini. <br><br>  Masalahnya dapat diperbaiki dengan salah satu dari dua teknik umum: <br><br><ol><li>  Gunakan properti ukuran kotak untuk footer secara langsung atau melalui reset yang disebutkan sebelumnya <br></li><li>  Hapus properti <code>width</code> dari elemen dan gunakan properti <code>left: 0</code> dan <code>right: 0</code> .  Ini adalah contoh yang baik untuk menggunakan properti <code>left</code> dan <code>right</code> pada saat yang bersamaan.  Pendekatan ini menghindari masalah model blok, karena properti <code>width</code> akan menggunakan nilai default <code>auto</code> untuk mengisi ruang yang tersedia antara padding dan batas ketika <code>left: 0</code> dan <code>right:0</code> . <br></li></ol><br>  <b>Catatan:</b> Salah satu opsi adalah untuk menghapus bantalan dari footer.  Secara teknis, ini akan memperbaiki masalah, karena lapisan konten akan 100% dan tidak memiliki bantalan atau perbatasan untuk memperluas di luar lebar wadah.  Tapi saya pikir solusi ini adalah pendekatan yang salah, karena kita tidak perlu mengubah antarmuka kita untuk beradaptasi dengan masalah model blok, yang mudah diperbaiki tanpa itu. <br><br>  Kenyataannya bagi saya adalah bahwa saya selalu memiliki <code>box-sizing: border-box</code> properti <code>box-sizing: border-box</code> sebagai bagian dari reset gaya umum saya.  Jika Anda melakukan hal yang sama, kemungkinan besar Anda jarang mengalami masalah ini.  Tapi saya masih suka teknik dengan mengatur properti <code>left:0</code> dan <code>right:0</code> pada saat yang sama, karena, seperti yang ditunjukkan oleh waktu, itu lebih dapat diandalkan (dalam hal apapun, menilai dari pengalaman saya) daripada memecahkan masalah model blok yang muncul karena lebar 100% <br><br><h2>  Pertanyaan 7: Memusatkan Elemen Mutlak dan Tetap </h2><br>  Sekarang kita benar-benar mulai menggabungkan semua materi yang dijelaskan di atas, dengan pemusatan elemen absolut dan tetap: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/bradwestfall/embed/preview/Orbywd" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Karena kita telah membahas sebagian besar materi dalam pertanyaan pengujian ini, saya hanya menunjukkan bahwa pemusatan horizontal dan vertikal dapat dilakukan dengan menggunakan metode old-school melalui margin negatif, atau yang lebih baru menggunakan properti transform.  Saya juga membawa kepada Anda <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">panduan pemusatan elemen CSS-Trik yang bagus</a> . <br><br>  <b>Catatan</b> : beberapa waktu lalu dikatakan bahwa jika kita mengetahui lebar dan tinggi blok, kita harus menggunakan margin negatif, karena mereka bekerja lebih stabil daripada properti transformasi baru.  Saat ini, transformasi bekerja dengan stabil dan saya hampir selalu menggunakan properti ini, kecuali saya perlu menghindari mengubah blok ke yang mengandung. <br><br><h2>  Pertanyaan 8: Memusatkan elemen dalam aliran normal </h2><br>  Flexbox memberi kami banyak alat luar biasa untuk menyelesaikan masalah tata letak yang rumit.  Sebelum dirilis, dilaporkan bahwa pemusatan vertikal adalah salah satu fitur paling kompleks yang diterapkan dalam CSS.  Dengan munculnya Flexbox, pemusatan vertikal telah menjadi rutin: <br><br><pre> <code class="css hljs"><span class="hljs-selector-class"><span class="hljs-selector-class">.parent</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">display</span></span>: flex; } <span class="hljs-selector-class"><span class="hljs-selector-class">.child</span></span> { <span class="hljs-attribute"><span class="hljs-attribute">margin</span></span>: auto; }</code> </pre><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">https://codepen.io/bradwestfall/pen/GPNmbM</a> <br>  <b>Catatan</b> : perhatikan bahwa untuk elemen flex, margin: otomatis diterapkan ke atas, bawah, kanan dan kiri untuk memusatkan elemen secara vertikal dan horizontal.  Sebelumnya, pemusatan vertikal tidak berfungsi untuk elemen blok, jadi <code>margin: 0 auto;</code> cukup umum <code>margin: 0 auto;</code> <br><br><h2>  Pertanyaan 9: Perhitungan dengan unit yang berbeda </h2><br>  Menggunakan fungsi calc () sangat bagus ketika Anda perlu bekerja dengan dua unit pengukuran yang tidak bisa kita tambahkan sendiri atau ketika kita perlu membuat pecahan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">lebih mudah dipahami</a> .  Pertanyaan tes ini menawarkan kita untuk mencari tahu seperti apa hasil dari ekspresi <code>calc(100% + 1em)</code> akan terlihat, mulai dari fakta bahwa lebar elemen div adalah 100px.  Ini bisa sedikit membingungkan, karena pada kenyataannya, tidak masalah bahwa lebar elemen div adalah 100px.  Persentase selalu dimulai dari lebar induk, jadi jawaban yang benar adalah: "100% dari blok yang berisi (induk) ditambah 1em". <br><br>  Ada beberapa situasi di mana saya secara teratur menggunakan <code>calc()</code> .  Pertama, setiap kali saya ingin mengubah sesuatu sebesar 100%, tetapi juga menambahkan jumlah ruang ekstra yang tetap.  Menu dropdown bisa menjadi contoh yang baik untuk ini: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/bradwestfall/embed/preview/Jwbgzm" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Keunikan di sini adalah bahwa kami ingin membuat menu tarik-turun yang dapat digunakan bersama-sama dengan elemen pemanggil ukuran yang berbeda (dalam hal ini, dua ukuran tombol yang berbeda).  Kami tidak tahu berapa tinggi elemen yang memanggil menu ini, tetapi kami tahu itu <code>top: 100%</code> akan menempatkan tepi atas menu tarik-turun di tepi bawah tombol panggil.  Jika setiap menu berada di tepi bawah tombol yang sesuai, ditambah 0,5em, ini dapat dicapai dengan <code>calc(100% + 0.5em)</code> .  Tentu saja, kita juga bisa menggunakan <code>top: 110%</code> , tetapi tambahan 10% ini akan tergantung pada ketinggian tombol dan wadah panggilan. <br><br><h2>  Pertanyaan 10: Margin negatif </h2><br>  Tidak seperti margin positif yang mengusir saudara kandung, margin negatif membuat mereka lebih dekat satu sama lain <b>tanpa mengubah saudara kandung</b> .  Pertanyaan tes akhir ini menawarkan dua solusi, yang keduanya secara teknis menghilangkan batas ganda pada kelompok tombol kami, tetapi saya sangat menyukai teknik margin negatif, karena menghapus bingkai akan membuatnya lebih sulit untuk melakukan teknik-teknik tertentu, seperti efek mouseover. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/bradwestfall/embed/preview/ZVBgGp" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Efek yang dihasilkan adalah "batas umum" yang ditampilkan di antara tombol.  Faktanya, tombol tidak dapat memiliki batas bersama, jadi kita perlu menggunakan teknik margin negatif sehingga satu frame saling tumpang tindih.  Kemudian saya menggunakan <code>z-index</code> untuk mengatur frame mana yang ingin saya paskan di atas yang lain, berdasarkan pada kondisi mouse hover.  Perhatikan bahwa <code>z-index</code> berguna di sini bahkan tanpa menggunakan penentuan posisi absolut, tetapi Anda harus mengatur <code>position: relative</code> .  Jika saya menggunakan teknik menghapus bingkai kiri tombol kedua, efek ini akan jauh lebih sulit untuk diterapkan. <br><br><h2>  Itu semua masuk akal. </h2><br>  Saya ingin menunjukkan kepada Anda demo terbaru lainnya yang menggunakan banyak trik yang telah kita bahas sebelumnya.  Tugasnya adalah membuat ubin yang meluas ke tepi kiri dan kanan wadah, dengan mempertimbangkan lekukan.  Dengan ubin, maksud saya kemampuan untuk memiliki daftar blok yang membungkus ke baris berikutnya ketika tidak ada cukup ruang lebar.  Arahkan kursor ke ubin untuk melihat hasilnya: <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://codepen.io/bradwestfall/embed/preview/JwbVRp" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br>  Hambatan dalam melakukan tugas ini adalah lekukan.  Tanpa bantalan, akan mudah untuk mendapatkan ubin yang berdekatan dengan tepi kiri dan kanan wadah.  Masalahnya adalah bahwa indentasi akan dibuat menggunakan margin, dan ketika kami menambahkan margin di semua sisi ubin, kami membuat dua masalah: <br><br><ol><li>  Kehadiran tiga ubin dengan lebar <code>33.33%</code> bersamaan dengan margin tidak akan bisa masuk berturut-turut.  Meskipun <code>box-sizing</code> memungkinkan kami memiliki lapisan dan tepi pada elemen <code>.tile</code> dan pas di <code>33.33%</code> , ini tidak akan membantu kami dalam hal margin - yang berarti bahwa lebar yang dihitung dari ketiga ubin akan lebih dari 100%, yang akan memaksa ubin terakhir untuk pindah ke yang berikutnya tali. <br></li><li>  Ubin kiri dan kanan tidak lagi terletak di tepi wadah. <br></li></ol><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Masalah pertama bisa diselesaikan dengan </font></font><code>calc((100% / 3) - 1em)</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. Yang berarti 33,33% dikurangi margin kiri dan kanan setiap ubin. Runtuhnya elemen saudari yang berdekatan tidak akan terjadi di sini, karena hanya mungkin pada margin atas dan bawah. Akibatnya, jarak horizontal antara dua ubin adalah jumlah dari dua margin (1em). Dalam hal ini, keruntuhan juga tidak berlaku untuk margin atas dan bawah, karena ubin pertama dan terakhir tidak berdekatan secara teknis, bahkan jika secara visual satu di bawah yang lain. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dengan membawa</font></font><code>calc()</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tiga ubin dapat masuk secara berurutan, tetapi mereka masih tidak menyentuh tepi wadah. Untuk melakukan ini, kita dapat menggunakan margin negatif dalam ukuran yang sama dengan margin kiri dan kanan setiap ubin. Garis putus-putus hijau dalam contoh adalah wadah tempat kami menerapkan margin negatif untuk menggambar ubin yang sesuai dengan tepi konten sekitarnya. Kita bisa melihat bagaimana mereka cocok dengan area padding dari elemen induk. Ini normal karena margin negatif tidak mengusir elemen tetangga. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sebagai hasilnya, kami mendapatkan ubin yang memiliki ruang yang cukup yang berkembang dari tepi ke tepi sehingga mereka sejajar dengan tag paragraf yang berdekatan di luar ubin.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ada banyak cara untuk membuat ubin (dan biasanya mereka memiliki kelebihan dan kekurangannya). Sebagai contoh, ada </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">solusi CSS Grid yang</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> cukup </font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;">elegan</font></a><font style="vertical-align: inherit;"> yang dibicarakan oleh Haydon Pickering. Solusi ini diimplementasikan menggunakan teknik yang mensimulasikan permintaan untuk kontainer (tetapi menggunakan Grid magic). Pada akhirnya, solusinya menggunakan Grid lebih baik daripada flexbox, yang saya contohkan tetapi memiliki dukungan browser yang lebih buruk.</font></font><br><br><h2>  Ringkasan </h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Pada awalnya, saya menyatakan bahwa saya cenderung mencari pola dalam memecahkan masalah. </font><font style="vertical-align: inherit;">Artikel ini tidak banyak membahas tentang skenario yang ditunjukkan di atas; </font><font style="vertical-align: inherit;">ini lebih tentang seperangkat alat yang dapat digunakan untuk memecahkan ini dan banyak masalah penyusunan huruf lain yang kita semua bisa hadapi. </font><font style="vertical-align: inherit;">Saya harap alat ini membantu Anda. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ngomong-ngomong, ada sejumlah sumber daya luar biasa yang dengan cermat memeriksa topik model blok. </font><font style="vertical-align: inherit;">Pertama-tama, artikel oleh Rachel Andrew dan Jen Simmons, yang pasti layak dibaca.</font></font><br><br><ul><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Box Alignment Cheatsheet</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> adalah materi hebat dengan elemen visual yang menekankan berbagai properti yang memengaruhi bagaimana elemen-elemen itu menyelaraskan baik elemennya sendiri atau relatif terhadap elemen lain.</font></font><br></li><li> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Jen Simmons Labs</a> —   ,        . </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id467555/">https://habr.com/ru/post/id467555/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id467543/index.html">Ssh-chat, bagian 2</a></li>
<li><a href="../id467545/index.html">ShIoTiny: jam tanpa pegas atau waktu nyata dan cara bekerja dengannya</a></li>
<li><a href="../id467547/index.html">Bypass ILV mengunci dengan DNSTap dan BGP</a></li>
<li><a href="../id467549/index.html">SpaceX berencana untuk menggunakan jaringan Internet satelit lebih awal dari yang direncanakan</a></li>
<li><a href="../id467551/index.html">Frontend Weekly Digest (9 - 15 September 2019)</a></li>
<li><a href="../id467557/index.html">Intisari bahan-bahan segar dari dunia front-end untuk minggu terakhir No. 380 (8-15 September, 2019)</a></li>
<li><a href="../id467559/index.html">Acara digital di Moskow dari 16 September hingga 22 September</a></li>
<li><a href="../id467561/index.html">Satu Hari dari Dukungan Pengguna PVS-Studio</a></li>
<li><a href="../id467563/index.html">Suatu hari dari dukungan pengguna PVS-Studio</a></li>
<li><a href="../id467567/index.html">Dukungan untuk warna 24-bit di terminal dalam banyak ssh + tmux + neovim</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>