<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚿 🦗 🙆🏿 Plongez dans Jetpack Compose 👨🏾‍🔧 🧑🏿‍🤝‍🧑🏼 🧝🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bonjour à tous. Avant de partir pour le week-end, nous nous empressons de partager avec vous une autre traduction préparée spécialement pour les étudi...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Plongez dans Jetpack Compose</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/otus/blog/458106/">  Bonjour à tous.  Avant de partir pour le week-end, nous nous empressons de partager avec vous une autre traduction préparée spécialement pour les étudiants du <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">développeur Android.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Cours avancé</a> . <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">"</a> <br><br><img src="https://habrastorage.org/webt/z6/qg/xa/z6qgxa6dlio2hf4bnnpwbvlk2j4.png"><br><br><h2>  Essayer un nouveau cadre d'interface utilisateur pour les applications Android </h2><br>  Au cours des dernières années, participant à de nombreux projets mobiles, j'ai dû utiliser diverses technologies, telles que Android, ReactNative et Flutter.  Passer de ReactNative à Android classique m'a fait des sentiments mitigés.  Le retour à Kotlin s'est bien passé, mais j'ai vraiment manqué le framework React UI.  Les petits composants réutilisables qui composent l'interface utilisateur sont excellents et offrent plus de flexibilité et de rapidité de développement. <a name="habracut"></a><br><br>  De retour dans Android classique, je devais m'inquiéter de garder la hiérarchie des vues aussi uniforme que possible.  De ce fait, il est difficile de se consacrer véritablement à l'approche composante.  Cela rend le copier-coller plus attrayant, ce qui conduit à un code plus complexe et moins pris en charge.  En fin de compte, nous nous gardons d'expérimenter avec une interface utilisateur qui pourrait améliorer l'UX. <br><br><img src="https://habrastorage.org/webt/9w/qc/oy/9wqcoytvuj4zccl4dbkrmpgx-v8.png"><br>  <i>Android révèle Jetpack Compose.</i>  <i>Illustration: Emanuel Bagilla</i> <br><br><h3>  Jetpack Compose à la rescousse </h3><br>  Par conséquent, après avoir regardé <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">les nouveautés d'Android lors</a> de la conférence Google I / O 2019, j'ai immédiatement commencé à traiter avec Compose et j'ai essayé d'en savoir plus.  Compose est une boîte à outils d'interface utilisateur réactive entièrement développée par Kotlin.  Compose ressemble beaucoup aux frameworks d'interface utilisateur existants tels que React, Litho ou Flutter. <br><br>  La structure actuelle du cadre de l'interface utilisateur Android existe depuis 2008, et au fil du temps est devenue plus complexe, elle est assez difficile à maintenir.  Jetpack Compose vise à partir du début, en tenant compte de la philosophie des composants modernes.  Le cadre est rédigé en gardant à l'esprit les principaux objectifs suivants: <br><br><ul><li>  <b>Incohérence avec les versions de la plate-forme:</b> cela vous permet de corriger rapidement les bogues, car Compose ne dépend pas des nouvelles versions d'Android. </li><li>  <b>Pile technologique plus petite:</b> le framework ne vous oblige pas à utiliser View ou Fragment lors de la création d'une interface utilisateur.  Tous les éléments sont des composants et peuvent être librement composés ensemble. </li><li>  <b>Gestion transparente des états et gestion des événements: l'</b> une des choses les plus importantes et les plus complexes que vous devez résoudre dans les grandes applications est le traitement du flux de données et de l'état dans votre interface utilisateur.  Compose précise qui est responsable de l'état et comment les événements doivent être gérés, de la même manière que React le gère. </li><li>  <b>Écrire moins de code: l'</b> écriture d'une interface utilisateur dans Android nécessite généralement beaucoup de code, en particulier lors de la création de mises en page plus complexes, par exemple, à l'aide de RecyclerView.  Compose vise à simplifier considérablement la façon de créer une interface utilisateur. </li></ul><br>  Cela facilite la création de composants isolés et réutilisables, ce qui facilite la création d'un nouvel écran avec des éléments existants.  Vous aider, en tant que développeur, à vous concentrer sur la création d'une interface utilisateur pratique, au lieu d'essayer de contrôler la hiérarchie des vues et d'apprivoiser la vue et le fragment. <br><br><h2>  Une application simple avec Compose: Hello World </h2><br>  Jetons un coup d'œil au code d'une application Hello World simple avec Jetpack Compose. <br><br><pre><code class="kotlin hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ComposeActivity</span></span></span><span class="hljs-class"> : </span><span class="hljs-type"><span class="hljs-class"><span class="hljs-type">Activity</span></span></span></span>() { <span class="hljs-keyword"><span class="hljs-keyword">override</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">onCreate</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(savedInstanceState: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Bundle</span></span></span></span><span class="hljs-function"><span class="hljs-params">?)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>.onCreate(savedInstanceState) setContent { CraneWrapper { MyApp() } } } <span class="hljs-meta"><span class="hljs-meta">@Composable</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyApp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { MaterialTheme { Text(text = <span class="hljs-string"><span class="hljs-string">"Hello world!"</span></span>, style = +themeTextStyle { h3 }) } } }</code> </pre> <br>  Dans la méthode <code>onCreate</code> nous définissons le contenu de notre application en appelant <code>setContent</code> .  Il s'agit d'une méthode qui initialise une arborescence de widgets composites et l'enveloppe dans un <code>FrameLayout</code> . <br><br>  Pour que cela fonctionne, nous devons envelopper notre application dans <code>CraneWrapper</code> et <code>MaterialTheme</code> .  <code>CraneWrapper</code> est responsable de la configuration des fournisseurs pour <code>Context</code> , <code>FocusManager</code> et <code>TextInputService</code> .  <code>MaterialTheme</code> nécessaire pour fournir les couleurs, les styles et les polices de vos widgets.  Dans cet esprit, nous pouvons ajouter le composant <code>Text</code> , qui affichera notre texte à l'écran dans un certain style. <br><br><h2>  Introduction de l'état </h2><br>  La gestion du flux de données et des états peut être une tâche ardue.  Pour illustrer la simplicité de Compose, créons une application de compteur simple. <br>  Pour travailler avec des états, Jetpack Compose utilise les idées d'autres frameworks d'interface utilisateur modernes, tels que Flutter et React.  Il existe un flux de données unidirectionnel et réactif qui entraîne la mise à jour ou la «reconstruction» de votre widget. <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Composable</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyApp</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { MaterialTheme { Counter() } } <span class="hljs-meta"><span class="hljs-meta">@Composable</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Counter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> amount = +state { <span class="hljs-number"><span class="hljs-number">0</span></span> } Column { Text(text = <span class="hljs-string"><span class="hljs-string">"Counter demo"</span></span>) Button(text = <span class="hljs-string"><span class="hljs-string">"Add"</span></span>, onClick = { amount.value++ }) Button(text = <span class="hljs-string"><span class="hljs-string">"Subtract"</span></span>, onClick = { amount.value-- }) Text(text = <span class="hljs-string"><span class="hljs-string">"Clicks: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${amount.value}</span></span></span><span class="hljs-string">"</span></span>) } }</code> </pre> <br><br>  Dans l'exemple ci-dessus, nous ajoutons les boutons «Ajouter» et «Soustraire» ainsi qu'une étiquette qui affiche le nombre actuel de clics.  Comme vous pouvez le voir dans l'exemple ci-dessous, en mettant à jour l'état «montant», les widgets sont intelligemment réorganisés lorsque l'état change. <br><br><img src="https://habrastorage.org/webt/ks/_y/ko/ks_ykoqxzmr24t-woc8o854dl_o.gif"><br>  <i>Lancer une application de démonstration</i> <br><br>  L'état de <code>amount</code> est initialisé avec <code>+state { 0 }</code> .  En essayant de comprendre quel genre de sorcellerie est, j'ai rampé dans le code source.  C'est mon avis, même si je ne suis toujours pas sûr de tout comprendre. <br><br>  <code>state {...}</code> crée un <code><code>Effect&lt;</code> State <code>&lt;</code> T <code>&lt;</code> code&gt;&gt;</code> .  La classe <code>Effect</code> est une classe floue qui contient un bloc de code exécutable qui s'exécute de manière positionnelle dans le contexte d'une composition.  La classe <code>State</code> contient une valeur avec le type <code>Model</code> , ce qui rend essentiellement cette valeur observable.  L'opérateur + est un opérateur temporaire qui résout l' <code>State</code> de l' <code>Effect</code> . <br><br><h3>  Modèles d'état personnalisés </h3><br>  Au lieu d'utiliser <code>+state {}</code> pour créer un modèle à valeur unique, nous pouvons également créer un modèle personnalisé à l'aide de l'annotation @Model.  Nous pouvons améliorer notre application de compteur en la divisant en petits widgets et en passant le modèle à d'autres widgets qui sont mis à jour et affichent l'état de ce modèle. <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Model</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">CounterModel</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> counter: <span class="hljs-built_in"><span class="hljs-built_in">Int</span></span> = <span class="hljs-number"><span class="hljs-number">0</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> header = <span class="hljs-string"><span class="hljs-string">"Counter demo"</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">add</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { counter++ } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">subtract</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { counter-- } }</code> </pre> <br><br>  En utilisant l'annotation <code>@Model</code> , le plugin Compose Compiler rend toutes les variables de votre modèle observables afin qu'elles puissent être utilisées pour réorganiser les widgets.  Mettons à jour notre widget pour utiliser <code>CounterModel</code> : <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Composable</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Counter</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(counterModel: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CounterModel</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { Column { CounterHeader(counterModel) AddSubtractButtons(counterModel) CounterLabel(counterModel) } } <span class="hljs-meta"><span class="hljs-meta">@Composable</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CounterHeader</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(counterModel: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CounterModel</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { Text(text = counterModel.header) } <span class="hljs-meta"><span class="hljs-meta">@Composable</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">AddSubtractButtons</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(counterModel: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CounterModel</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { Button( text = <span class="hljs-string"><span class="hljs-string">"Add"</span></span>, onClick = { counterModel.add() }) Button( text = <span class="hljs-string"><span class="hljs-string">"Subtract"</span></span>, onClick = { counterModel.subtract() }) } <span class="hljs-meta"><span class="hljs-meta">@Composable</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">CounterLabel</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(counterModel: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">CounterModel</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { Text(text = <span class="hljs-string"><span class="hljs-string">"Clicks: </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${counterModel.counter}</span></span></span><span class="hljs-string">"</span></span>) }</code> </pre> <br><br>  Le seul widget constitué par l'application spinner est désormais divisé en plusieurs widgets composables plus petits.  <code>CounterModel</code> est transmis à divers widgets, soit pour afficher l'état du modèle, soit pour changer l'état du modèle à l'aide des fonctions <code>add()</code> ou <code>subtract()</code> . <br><br><h2>  Plus de vue </h2><br>  Il est important de comprendre que les widgets Jetpack Compose n'utilisent pas de vue ou de fragment sous le capot, ce sont juste les fonctions qui dessinent sur le canevas.  Le plugin Compose Compiler traite toutes les fonctions avec l'annotation <code>@Composable</code> et met automatiquement à jour la hiérarchie de l'interface utilisateur. <br><br>  Par exemple, un widget <code>Divider</code> compose d'un widget <code>Padding</code> qui contient un widget <code>DrawFillRect</code> .  En regardant le code source de <code>DrawFillRect</code> , il devient clair qu'il dessine des lignes directement sur la toile.  Tous les autres widgets sont implémentés de la même manière. <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Composable</span></span> <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DrawFillRect</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(brush: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">Brush</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { Draw { canvas, parentSize -&gt; <span class="hljs-keyword"><span class="hljs-keyword">val</span></span> paint = Paint() brush.applyBrush(paint) canvas.drawRect(parentSize.toRect(), paint) } }</code> </pre> <br><br>  Le code source du DrawFillRect utilisé dans le widget Divider. <br>  Si nous regardons l'inspecteur de mise en page en lançant l'un des exemples d'applications de Google, nous verrons clairement que lors du lancement de l'application Android avec Compose, il n'y a ni <code>View</code> ni <code>ViewGroups</code> .  Nous voyons un <code>FrameLayout</code> contenant le <code>CraneWrapper</code> que nous avons créé dans le code, à partir de là, la hiérarchie de l'interface utilisateur de composition est affichée à l'écran. <br><br><img src="https://habrastorage.org/webt/fc/oa/bb/fcoabbcltglyqbogmtcywdxiums.png"><br>  <i>L'inspecteur de mise en page inspecte Jetpack Compose.</i> <br><br>  L'absence de vues signifie également que Jetpack Compose ne peut pas utiliser les vues actuellement disponibles, telles que <code>android.widget.Button</code> , et doit créer tous les widgets à partir de zéro.  Si vous regardez, par exemple, Flutter, qui utilise la même approche, vous pouvez voir que c'est un travail difficile.  C'est l'une des raisons pour lesquelles Jetpack Compose aura besoin de temps avant d'être prêt à être utilisé en production. <br><br><h2>  Tous les éléments sont des widgets. </h2><br>  Tout comme Flutter, dans Compose tous les éléments sont des widgets.  Des widgets plus complexes ont été décomposés en widgets élémentaires avec des responsabilités claires.  Par conséquent, même le rembourrage, les espaceurs, etc. sont des widgets.  Par exemple, si vous souhaitez ajouter une indentation autour d'un bouton, enveloppez-le simplement dans le widget de remplissage: <br><br><pre> <code class="kotlin hljs">Padding(padding = <span class="hljs-number"><span class="hljs-number">16</span></span>.dp) { Button(text = <span class="hljs-string"><span class="hljs-string">"Say hello"</span></span>, onClick = { ... }) }</code> </pre> <br><br><h2>  Connexion du code à l'interface utilisateur </h2><br>  La combinaison de code Kotlin avec des widgets d'interface utilisateur est très facile.  Par exemple, si vous souhaitez afficher une interface utilisateur qui se répète ou dépend de certaines conditions.  Ainsi, vous pouvez facilement afficher une liste de noms, comme indiqué ci-dessous. <br><br><pre> <code class="kotlin hljs">Column { listOf(<span class="hljs-string"><span class="hljs-string">"John"</span></span>, <span class="hljs-string"><span class="hljs-string">"Julia"</span></span>, <span class="hljs-string"><span class="hljs-string">"Alice"</span></span>, <span class="hljs-string"><span class="hljs-string">"Mark"</span></span>).forEach { Text(text = it) } }</code> </pre> <br><br>  C'est une fonctionnalité vraiment puissante, mais vous devez faire attention à ne pas programmer trop de logique au niveau de l'interface utilisateur. <br><br><h2>  Compatible avec vos applications Android </h2><br>  Compose est conçu pour que vous puissiez l'ajouter à une application existante et transférer progressivement certaines parties de votre interface utilisateur vers un nouveau cadre.  Les exemples ci-dessus ajoutent l'interface utilisateur Jetpack Compose à une activité.  Vous pouvez également incorporer des widgets Composer dans une présentation XML existante à l'aide de l'annotation <code>GenerateView</code> : <br><br><pre> <code class="kotlin hljs"><span class="hljs-meta"><span class="hljs-meta">@Composable</span></span> <span class="hljs-meta"><span class="hljs-meta">@GenerateView</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">fun</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Greeting</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(name: </span></span><span class="hljs-type"><span class="hljs-function"><span class="hljs-params"><span class="hljs-type">String</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { <span class="hljs-comment"><span class="hljs-comment">/* … */</span></span> } <span class="hljs-comment"><span class="hljs-comment">//  -  layout.xml &lt;GreetingView app:name=”John” /&gt;</span></span></code> </pre> <br><h2>  Conclusion </h2><br>  Je suis ravi de Compose, car il réduit la souffrance croissante que je ressens lors du développement pour Android.  Il permet d'être plus flexible, de se concentrer sur la création d'une interface utilisateur pratique et une responsabilité claire permet également d'éviter les erreurs. <br><br>  Compose a un long chemin à parcourir, à mon avis, il peut être utilisé en production au plus tôt dans un an ou deux.  Cependant, je pense que c'est le bon moment pour jeter un œil au Jetpack Compose.  Les créateurs recherchent activement des commentaires, à ce stade, vous pouvez toujours apporter des modifications.  Tous les avis contribueront à améliorer ce nouveau cadre. <br><br>  Lisez mon article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Try Jetpack Compose aujourd'hui</a> pour savoir comment brancher la pré-alpha de Compose.  De plus, je pense qu'il sera très intéressant pour vous de regarder une <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">vidéo sur les modèles d'interface déclarative</a> avec Google I / O. <br>  J'ai hâte de pouvoir utiliser Compose dans de vraies applications Android! <br><br>  C’est tout.  Nous attendons vos commentaires avec impatience et nous vous souhaitons un excellent week-end! </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr458106/">https://habr.com/ru/post/fr458106/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr458096/index.html">Qu'est-ce que la pile MERN et comment l'utiliser?</a></li>
<li><a href="../fr458098/index.html">Pièges du RGPD</a></li>
<li><a href="../fr458100/index.html">Python dans Visual Studio Code - Version de juin 2019</a></li>
<li><a href="../fr458102/index.html">Flux de travail de développement Web efficace: Confluence, Airtable, etc.</a></li>
<li><a href="../fr458104/index.html">RDMA à l'intérieur du centre de données dans la mise en œuvre de Huawei</a></li>
<li><a href="../fr458108/index.html">Redirection: 301, 302, 307 | Guide pratique 301</a></li>
<li><a href="../fr458110/index.html">Programmation dynamique dans le monde réel: découpe de couture</a></li>
<li><a href="../fr458112/index.html">Sony Xperia 10 critique</a></li>
<li><a href="../fr458114/index.html">Construire un réseau juridique mondial pour l'open source</a></li>
<li><a href="../fr458116/index.html">Abonnements SwiftUI et auto-renouvelables</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>