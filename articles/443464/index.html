<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ü§òüèΩ üíΩ üåö Gu√≠a completa para cambiar expresiones en Java 12 üë®üèø‚Äç‚úàÔ∏è üçó ‚õπÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="El viejo switch bueno switch estado en Java desde el primer d√≠a. Todos lo usamos y estamos acostumbrados, especialmente sus peculiaridades. (¬øAlguien ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Gu√≠a completa para cambiar expresiones en Java 12</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/443464/"><div style="text-align:center;"><img src="https://habrastorage.org/webt/pq/lt/a6/pqlta6vh4m5bec2xrtku1smn7em.jpeg"></div><br><p> El viejo <code>switch</code> bueno <code>switch</code> estado en Java desde el primer d√≠a.  Todos lo usamos y estamos acostumbrados, especialmente sus peculiaridades.  (¬øAlguien m√°s se molesta por el <code>break</code> ?) Pero ahora todo comienza a cambiar: en Java 12, el <strong>interruptor en</strong> lugar de un operador se ha convertido en una expresi√≥n: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE -&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FALSE -&gt; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FILE_NOT_FOUND -&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UncheckedIOException( <span class="hljs-string"><span class="hljs-string">"This is ridiculous!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileNotFoundException()); <span class="hljs-comment"><span class="hljs-comment">// as we'll see in "Exhaustiveness", `default` is not necessary default -&gt; throw new IllegalArgumentException("Seriously?!"); };</span></span></code> </pre> <br><p>  <strong>Switch ahora</strong> tiene la capacidad de devolver el resultado de su trabajo, que puede asignarse a una variable;  Tambi√©n puede usar la sintaxis de estilo lambda, que le permite deshacerse de la transferencia para todos los <code>case</code> en los que no hay una declaraci√≥n de <code>break</code> . </p><br><p>  En esta gu√≠a, le contar√© todo lo que necesita saber sobre las expresiones de cambio en Java 12. </p><a name="habracut"></a><br><h2 id="predvaritelnyy-obzor">  Vista previa </h2><br><p>  De acuerdo con la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">especificaci√≥n preliminar del lenguaje</a> , las <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">expresiones de cambio</a> reci√©n comienzan a implementarse en Java 12. </p><br><p>  Esto significa que esta construcci√≥n de control se puede cambiar en futuras versiones de la especificaci√≥n del lenguaje. </p><br><p>  Para comenzar a usar la nueva versi√≥n de <code>switch</code> debe usar la opci√≥n de l√≠nea de comando <code>--enable-preview</code> tanto durante la compilaci√≥n como durante el inicio del programa (tambi√©n debe usar la <code>--release 12</code> al compilar - nota del traductor). </p><br><p>  Tenga en cuenta que ese <strong>interruptor</strong> , como expresi√≥n, actualmente no tiene la sintaxis final en Java 12. </p><br><p>  Si desea jugar con todo esto usted mismo, puede visitar mi proyecto de demostraci√≥n Java X en un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">github</a> . </p><br><h2 id="problema-s-operatorami-v-switch">  Problema con declaraciones en el interruptor </h2><br><p>  Antes de pasar a una descripci√≥n general de las innovaciones en <strong>switch</strong> , eval√∫e r√°pidamente una situaci√≥n.  Supongamos que nos enfrentamos a un <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">boulean ternary</a> "terrible" y queremos convertirlo en un boulean regular.  Aqu√≠ hay una forma de hacer esto: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result; <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE: result = <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-comment"><span class="hljs-comment">// don't forget to `break` or you're screwed! break; case FALSE: result = false; break; case FILE_NOT_FOUND: // intermediate variable for demo purposes; // wait for it... var ex = new UncheckedIOException("This is ridiculous!", new FileNotFoundException()); throw ex; default: // ... here we go: // can't declare another variable with the same name var ex2 = new IllegalArgumentException("Seriously?!"); throw ex2; }</span></span></code> </pre> <br><p>  De acuerdo en que esto es muy inconveniente.  Al igual que muchas otras opciones de <strong>cambio</strong> que se encuentran en "naturaleza", el ejemplo anterior simplemente calcula el valor de una variable y lo asigna, pero la implementaci√≥n se omite (declara el <code>result</code> del identificador y lo usa m√°s tarde), se repite (mi <code>break</code> 'y siempre el resultado de copiar-pasta) y propenso a errores (¬øolvid√≥ otra rama? ¬°Oh!).  Claramente hay algo que mejorar. </p><br><p>  Intentemos resolver estos problemas colocando el <strong>interruptor</strong> en un m√©todo separado: </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">boolean</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">toBoolean</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bool ternaryBool)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FALSE: <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FILE_NOT_FOUND: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UncheckedIOException(<span class="hljs-string"><span class="hljs-string">"This is ridiculous!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileNotFoundException()); <span class="hljs-comment"><span class="hljs-comment">// without default branch, the method wouldn't compile default: throw new IllegalArgumentException("Seriously?!"); } }</span></span></code> </pre> <br><p>  Esto es mucho mejor: no hay una variable ficticia, no hay <code>break</code> saturan el c√≥digo y los mensajes del compilador sobre la ausencia de <code>default</code> (incluso si esto no es necesario, como en este caso). </p><br><p>  Pero, si lo piensa, no estamos obligados a crear m√©todos solo para eludir la caracter√≠stica de lenguaje inc√≥modo.  Y esto es incluso sin considerar que dicha refactorizaci√≥n no siempre es posible.  ¬°No, necesitamos una mejor soluci√≥n! </p><br><h2 id="predstavlyaem-switch-vyrazheniya">  ¬°Introduciendo expresiones de cambio! </h2><br><p>  Como mostr√© al comienzo del art√≠culo, comenzando con Java 12 y superior, puede resolver el problema anterior de la siguiente manera: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE -&gt; <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FALSE -&gt; <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FILE_NOT_FOUND -&gt; <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UncheckedIOException( <span class="hljs-string"><span class="hljs-string">"This is ridiculous!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileNotFoundException()); <span class="hljs-comment"><span class="hljs-comment">// as we'll see in "Exhaustiveness", `default` is not necessary default -&gt; throw new IllegalArgumentException("Seriously?!"); };</span></span></code> </pre> <br><p>  Creo que esto es bastante obvio: si <code>ternartBool</code> es <code>TRUE</code> , entonces el <code>result</code> 'se establecer√° en <code>true</code> (en otras palabras, <code>TRUE</code> convierte en <code>true</code> ).  <code>FALSE</code> convierte en <code>false</code> . </p><br><p>  Dos pensamientos surgen inmediatamente: </p><br><ul><li>  <code>switch</code> puede tener un resultado; </li><li>  ¬øQu√© pasa con las flechas? </li></ul><br><p>  Antes de profundizar en los detalles de las nuevas caracter√≠sticas del <strong>interruptor</strong> , al principio hablar√© sobre estos dos aspectos principales. </p><br><h3 id="vyrazhenie-ili-operator">  Expresi√≥n o declaraci√≥n </h3><br><p>  Puede que se sorprenda de que <strong>cambiar</strong> ahora sea una expresi√≥n.  ¬øPero qu√© era √©l antes? </p><br><p>  Antes de Java 12, un <strong>interruptor</strong> era un operador, una construcci√≥n imperativa que regula el flujo de control. </p><br><p>  Piense en las diferencias entre las versiones antigua y nueva de <strong>switch</strong> como la diferencia entre <code>if</code> y el operador ternario.  Ambos verifican la condici√≥n l√≥gica y realizan ramificaciones dependiendo de su resultado. </p><br><p>  La diferencia es que <code>if</code> solo ejecuta el bloque correspondiente, mientras que el operador ternario devuelve alg√∫n resultado: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">if</span></span>(condition) { result = doThis(); } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { result = doThat(); } result = condition ? doThis() : doThat();</code> </pre> <br><p>  Lo mismo es para el <strong>interruptor</strong> : antes de Java 12, si desea calcular el valor y guardar el resultado, puede asignarlo a una variable (y luego <code>break</code> ), o devolverlo desde un m√©todo creado espec√≠ficamente para la <code>switch</code> . </p><br><p>  Ahora, se eval√∫a la expresi√≥n completa de la <strong>instrucci√≥n switch</strong> (se selecciona la rama correspondiente para la ejecuci√≥n) y el resultado de los c√°lculos se puede asignar a una variable. </p><br><p>  Otra diferencia entre la expresi√≥n y la declaraci√≥n es que la <strong>declaraci√≥n de cambio</strong> , debido a que es parte de la declaraci√≥n, debe terminar con un punto y coma, a diferencia de la <strong>declaraci√≥n de cambio</strong> cl√°sica. </p><br><h3 id="strelka-ili-dvoetochie">  Flecha o dos puntos </h3><br><p>  El ejemplo introductorio utiliz√≥ la nueva sintaxis de estilo lambda con una flecha entre la etiqueta y la parte en ejecuci√≥n.  Es importante comprender que para esto no es necesario usar <code>switch</code> como expresi√≥n.  De hecho, el siguiente ejemplo es equivalente al c√≥digo dado al comienzo del art√≠culo: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">true</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FALSE: <span class="hljs-keyword"><span class="hljs-keyword">break</span></span> <span class="hljs-keyword"><span class="hljs-keyword">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> FILE_NOT_FOUND: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> UncheckedIOException( <span class="hljs-string"><span class="hljs-string">"This is ridiculous!"</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> FileNotFoundException()); <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">throw</span></span> <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> IllegalArgumentException(<span class="hljs-string"><span class="hljs-string">"Seriously?!!?"</span></span>); };</code> </pre> <br><p>  ¬°Tenga en cuenta que ahora puede usar <code>break</code> con un valor!  Esto encaja perfectamente con las <code>switch</code> estilo antiguo que usan <code>break</code> sin ning√∫n significado.  Entonces, en qu√© caso una flecha significa una expresi√≥n en lugar de un operador, ¬øpor qu√© est√° aqu√≠?  ¬øSolo sintaxis hipster? </p><br><p>  Hist√≥ricamente, las marcas de dos puntos simplemente marcan el punto de entrada al bloque de instrucciones.  A partir de este punto, comienza la ejecuci√≥n de todo el c√≥digo siguiente, incluso cuando se encuentra otra etiqueta.  En <code>switch</code> sabemos que esto pasa al siguiente <code>case</code> (fall-through): la etiqueta del <code>case</code> determina hacia d√≥nde salta el flujo de control.  Para completarlo, necesita un <code>break</code> o <code>return</code> . </p><br><p>  A su vez, usar la flecha significa que solo se ejecutar√° el bloque a la derecha.  Y no "fallar". </p><br><h2 id="podrobnee-ob-evolyucii-switch">  M√°s sobre la evoluci√≥n del interruptor </h2><br><h3 id="neskolko-metok-na-case">  M√∫ltiples etiquetas en caso </h3><br><p>  Hasta ahora, cada <code>case</code> una sola etiqueta.  Pero ahora todo ha cambiado: un <code>case</code> puede corresponder a varias etiquetas: </p><br><pre> <code class="java hljs">String result = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE, FALSE -&gt; <span class="hljs-string"><span class="hljs-string">"sane"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// `default, case FILE_NOT_FOUND -&gt; ...` does not work // (neither does other way around), but that makes // sense because using only `default` suffices default -&gt; "insane"; };</span></span></code> </pre> <br><p>  El comportamiento debe ser obvio: <code>TRUE</code> y <code>FALSE</code> producen el mismo resultado: se eval√∫a la expresi√≥n "cuerda". </p><br><p>  Esta es una innovaci√≥n bastante agradable que reemplaz√≥ el uso m√∫ltiple de <code>case</code> cuando se requer√≠a implementar una transici√≥n de paso al siguiente <code>case</code> . </p><br><h3 id="tipy-za-predelami-enum">  Tipos fuera de Enum </h3><br><p>  Todos los ejemplos de <code>switch</code> en este art√≠culo usan <code>enum</code> .  ¬øQu√© hay de otros tipos?  Las expresiones y las <code>switch</code> tambi√©n pueden funcionar con <code>String</code> , <code>int</code> , (consulte la <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">documentaci√≥n</a> ) <code>short</code> , <code>byte</code> , <code>char</code> y sus contenedores.  Hasta ahora, nada ha cambiado aqu√≠, aunque la idea de usar tipos de datos como <code>float</code> y <code>long</code> todav√≠a es <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">v√°lida</a> (del segundo al √∫ltimo p√°rrafo). </p><br><h2 id="podrobnee-o-strelke">  M√°s sobre la flecha </h2><br><p>  Veamos dos propiedades espec√≠ficas de la forma de flecha de un registro separador: </p><br><ul><li>  falta de una transici√≥n a trav√©s del siguiente <code>case</code> ; </li><li>  bloques de operadores. </li></ul><br><h3 id="otsutstvie-skvoznogo-perehoda-k-sleduyuschemu-case">  No pasa al siguiente caso </h3><br><p>  Esto es lo que dice <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">JEP 325</a> sobre esto: </p><br><blockquote>  El dise√±o actual de la <code>switch</code> en Java est√° estrechamente relacionado con lenguajes como C y C ++ y admite la sem√°ntica de extremo a extremo de forma predeterminada.  Aunque esta forma tradicional de control a menudo es √∫til para escribir c√≥digo de bajo nivel (como analizadores para codificaci√≥n binaria), dado que el <code>switch</code> usa en c√≥digo de nivel superior, los errores de este enfoque comienzan a superar su flexibilidad. </blockquote><p>  Estoy totalmente de acuerdo y agradezco la oportunidad de usar el <strong>interruptor</strong> sin un comportamiento predeterminado: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE, FALSE -&gt; System.out.println(<span class="hljs-string"><span class="hljs-string">"Bool was sane"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// in colon-form, if `ternaryBool` is `TRUE` or `FALSE`, // we would see both messages; in arrow-form, only one // branch is executed default -&gt; System.out.println("Bool was insane"); }</span></span></code> </pre> <br><p>  Es importante saber que esto no tiene nada que ver con el uso de <strong>switch</strong> como expresi√≥n o declaraci√≥n.  El factor decisivo aqu√≠ es la flecha contra el colon. </p><br><h3 id="bloki-operatorov">  Bloques de operador </h3><br><p>  Como en el caso de lambdas, la flecha puede apuntar a un operador (como arriba) o a un bloque resaltado con llaves: </p><br><pre> <code class="java hljs"><span class="hljs-keyword"><span class="hljs-keyword">boolean</span></span> result = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span>(Bool.random()) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE -&gt; { System.out.println(<span class="hljs-string"><span class="hljs-string">"Bool true"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// return with `break`, not `return` break true; } case FALSE -&gt; { System.out.println("Bool false"); break false; } case FILE_NOT_FOUND -&gt; { var ex = new UncheckedIOException("This is ridiculous!", new FileNotFoundException()); throw ex; } default -&gt; { var ex = new IllegalArgumentException("Seriously?!"); throw ex; } };</span></span></code> </pre> <br><p>  Los bloques que deben crearse para operadores de varias l√≠neas tienen una ventaja adicional (que no se requiere cuando se usan dos puntos), lo que significa que para usar los mismos nombres de variables en diferentes ramas, el <code>switch</code> no requiere un procesamiento especial. </p><br><p>  Si le parec√≠a inusual salir de los bloques utilizando el <code>break</code> lugar del <code>return</code> , entonces no se preocupe, esto tambi√©n me desconcert√≥ y me pareci√≥ extra√±o.  Pero luego lo pens√© y llegu√© a la conclusi√≥n de que tiene sentido, ya que conserva el viejo estilo de la construcci√≥n del <code>switch</code> , que usa <code>break</code> sin valores. </p><br><h2 id="podrobnee-o-vyrazheniyah-switch">  Obtenga m√°s informaci√≥n sobre las declaraciones de cambio </h2><br><p>  Y por √∫ltimo, pero no menos importante, los detalles del uso de <code>switch</code> como expresi√≥n: </p><br><ul><li>  m√∫ltiples expresiones; </li><li>  retorno temprano ( <code>return</code> temprano); </li><li>  cobertura de todos los valores. </li></ul><br><p>  ¬°Tenga en cuenta que no importa qu√© forma se use! </p><br><h3 id="mnozhestvennye-vyrazheniya">  Expresiones m√∫ltiples </h3><br><p>  Las expresiones de interruptor son expresiones m√∫ltiples.  Esto significa que no tienen su propio tipo, pero pueden ser uno de varios tipos.  Muy a menudo, las expresiones lambda se usan como tales expresiones: <code>s -&gt; s + " "</code> , puede ser <code>Function&lt;String, String&gt;</code> , pero tambi√©n puede ser <code>Function&lt;Serializable, Object&gt;</code> o <code>UnaryOperator&lt;String&gt;</code> . </p><br><p>  Usando expresiones de cambio, un tipo est√° determinado por la interacci√≥n entre el lugar donde <strong>se</strong> usa el <strong>cambio</strong> y los tipos de sus ramas.  Si se asigna una expresi√≥n de cambio a una variable con tipo, se pasa como argumento o se usa de otro modo en un contexto donde se conoce el tipo exacto (esto se llama el tipo de destino), entonces todas sus ramas deben coincidir con ese tipo.  Esto es lo que hemos hecho hasta ahora: </p><br><pre> <code class="java hljs">String result = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ternaryBool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE, FALSE -&gt; <span class="hljs-string"><span class="hljs-string">"sane"</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> -&gt; <span class="hljs-string"><span class="hljs-string">"insane"</span></span>; };</code> </pre> <br><p>  Como resultado, el <code>switch</code> asigna a la variable de <code>result</code> de tipo <code>String</code> .  Por lo tanto, <code>String</code> es el tipo de destino, y todas las ramas deben devolver un resultado de tipo <code>String</code> . </p><br><p>  Lo mismo sucede aqu√≠: </p><br><pre> <code class="java hljs">Serializable serializableMessage = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (bool) { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> TRUE, FALSE -&gt; <span class="hljs-string"><span class="hljs-string">"sane"</span></span>; <span class="hljs-comment"><span class="hljs-comment">// note that we don't throw the exception! // but it's `Serializable`, so it matches the target type default -&gt; new IllegalArgumentException("insane"); };</span></span></code> </pre> <br><p>  ¬øQu√© pasar√° ahora? </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// compiler infers super type of `String` and // `IllegalArgumentException` ~&gt; `Serializable` var serializableMessage = switch (bool) { case TRUE, FALSE -&gt; "sane"; // note that we don't throw the exception! default -&gt; new IllegalArgumentException("insane"); };</span></span></code> </pre> <br><p>  (Para usar el tipo var, lea en nuestro √∫ltimo art√≠culo <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">26 las recomendaciones para usar el tipo var en Java</a> - nota del traductor) </p><br><p>  Si el tipo de destino es desconocido, debido al hecho de que usamos var, el tipo se calcula al encontrar el supertipo m√°s espec√≠fico de los tipos creados por las ramas. </p><br><h3 id="ranniy-vozvrat">  Regreso temprano </h3><br><p>  La consecuencia de la diferencia entre la expresi√≥n y la <code>switch</code> es que puede usar <code>return</code> para salir de la <code>switch</code> : </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sanity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bool ternaryBool)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ternaryBool) { <span class="hljs-comment"><span class="hljs-comment">// `return` is only possible from block case TRUE, FALSE -&gt; { return "sane"; } default -&gt; { return "This is ridiculous!"; } }; }</span></span></code> </pre> <br><p>  ... no puedes usar <code>return</code> dentro de una expresi√≥n ... </p><br><pre> <code class="java hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> String </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">sanity</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(Bool ternaryBool)</span></span></span><span class="hljs-function"> </span></span>{ String result = <span class="hljs-keyword"><span class="hljs-keyword">switch</span></span> (ternaryBool) { <span class="hljs-comment"><span class="hljs-comment">// this does not compile - error: // "return outside of enclosing switch expression" case TRUE, FALSE -&gt; { return "sane"; } default -&gt; { return "This is ridiculous!"; } }; }</span></span></code> </pre> <br><p>  Esto tiene sentido si usa una flecha o dos puntos. </p><br><h3 id="pokrytie-vseh-variantov">  Cubriendo todas las opciones </h3><br><p>  Si utiliza <code>switch</code> como operador, no importa si todas las opciones est√°n cubiertas o no.  Por supuesto, puede omitir accidentalmente el <code>case</code> , y el c√≥digo no funcionar√° correctamente, pero al compilador no le importa: usted, su IDE y sus herramientas de an√°lisis de c√≥digo se quedar√°n solo con esto. </p><br><p>  Las expresiones de cambio exacerban este problema.  ¬øA d√≥nde deber√≠a ir si falta la etiqueta deseada?  La √∫nica respuesta que Java puede dar es devolver <code>null</code> para los tipos de referencia y un valor predeterminado para las primitivas.  Esto causar√≠a muchos errores en el c√≥digo principal. </p><br><p>  Para evitar tal resultado, el compilador puede ayudarlo.  Para las declaraciones de cambio, el compilador insistir√° en que todas las opciones posibles est√©n cubiertas.  Veamos un ejemplo que podr√≠a conducir a un error de compilaci√≥n: </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// compile error: // "the switch expression does not cover all possible input values" boolean result = switch (ternaryBool) { case TRUE -&gt; true; // no case for `FALSE` case FILE_NOT_FOUND -&gt; throw new UncheckedIOException( "This is ridiculous!", new FileNotFoundException()); };</span></span></code> </pre> <br><p>  La siguiente soluci√≥n es interesante: agregar la rama <code>default</code> ciertamente solucionar√° el error, pero esta no es la √∫nica soluci√≥n, a√∫n puede agregar un <code>case</code> para <code>FALSE</code> . </p><br><pre> <code class="java hljs"><span class="hljs-comment"><span class="hljs-comment">// compiles without `default` branch because // all cases for `ternaryBool` are covered boolean result = switch (ternaryBool) { case TRUE -&gt; true; case FALSE -&gt; false; case FILE_NOT_FOUND -&gt; throw new UncheckedIOException( "This is ridiculous!", new FileNotFoundException()); };</span></span></code> </pre> <br><p>  S√≠, el compilador finalmente podr√° determinar si todos los valores de enumeraci√≥n est√°n cubiertos (si todas las opciones est√°n agotadas) y no establecer valores predeterminados in√∫tiles.  Sent√©monos un momento en silenciosa gratitud. </p><br><p>  Aunque, esto todav√≠a plantea una pregunta.  ¬øQu√© pasa si alguien toma y convierte un <strong>Bool</strong> loco en un <strong>Booleano</strong> cuaternario agregando un cuarto valor?  Si vuelve a compilar la expresi√≥n de cambio para el <strong>Bool</strong> extendido, obtendr√° un error de compilaci√≥n (la expresi√≥n ya no es exhaustiva).  Sin recompilaci√≥n, esto se convertir√° en un problema de tiempo de ejecuci√≥n.  Para detectar este problema, el compilador va a la rama <code>default</code> , que se comporta igual que la que usamos hasta ahora, arrojando una excepci√≥n. </p><br><p>  En Java 12, abarcar todos los valores sin la rama <code>default</code> solo funciona para <code>enum</code> , pero cuando el <code>switch</code> vuelve m√°s poderoso en futuras versiones de Java, tambi√©n puede funcionar con tipos arbitrarios.  Si las etiquetas de los <code>case</code> no solo pueden verificar la igualdad, sino tambi√©n hacer comparaciones (por ejemplo, _ &lt;5 -&gt; ...), esto cubrir√° todas las opciones para los tipos num√©ricos. </p><br><h2 id="razmyshlenie">  Pensando </h2><br><p>  Aprendimos del art√≠culo que Java 12 convierte un <code>switch</code> en una expresi√≥n, d√°ndole nuevas caracter√≠sticas: </p><br><ul><li>  ahora un <code>case</code> puede corresponder a varias etiquetas; </li><li>  El nuevo <code>case ‚Ä¶ -&gt; ‚Ä¶</code> forma de flecha <code>case ‚Ä¶ -&gt; ‚Ä¶</code> sigue la sintaxis de las expresiones lambda: <br><ul><li>  se permiten operadores o bloques de una sola l√≠nea; </li><li>  <code>case</code> impide pasar al siguiente <code>case</code> ; </li></ul></li><li>  ahora toda la expresi√≥n se eval√∫a como un valor, que luego se puede asignar a una variable o pasar como parte de una declaraci√≥n m√°s grande; </li><li>  expresi√≥n m√∫ltiple: si se conoce el tipo de destino, todas las ramas deben corresponderle.  De lo contrario, se define un tipo espec√≠fico que coincide con todas las ramas; </li><li>  <code>break</code> puede devolver un valor de un bloque; </li><li>  para una expresi√≥n de <code>switch</code> usando <code>enum</code> , el compilador verifica el alcance de todos sus valores.  Si el <code>default</code> ausente, se agrega una rama que genera una excepci√≥n. </li></ul><br><p>  ¬øA d√≥nde nos llevar√°?  Primero, dado que esta no es la versi√≥n final de <code>switch</code> , todav√≠a tiene tiempo para dejar comentarios en la lista de correo de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Amber</a> si no est√° de acuerdo con algo. </p><br><p>  Luego, suponiendo que el <strong>interruptor</strong> permanezca como est√° en este momento, creo que la forma de la flecha se convertir√° en la nueva opci√≥n predeterminada.  Sin un pasaje directo al siguiente <code>case</code> y con expresiones concisas lambda (es muy natural tener un caso y una declaraci√≥n en una l√≠nea), el <code>switch</code> ve mucho m√°s compacto y no afecta la legibilidad del c√≥digo.  Estoy seguro de que solo usar√© dos puntos si necesito pasar por el pasaje. </p><br><p>  Que piensas  ¬øSatisfecho con c√≥mo resultaron las cosas? </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/443464/">https://habr.com/ru/post/443464/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../443452/index.html">El ej√©rcito ruso crear√° su propio Internet cerrado</a></li>
<li><a href="../443456/index.html">Te invitamos a Yandex NLP por una semana</a></li>
<li><a href="../443458/index.html">6 errores de sistema entretenidos en la operaci√≥n de Kubernetes [y su soluci√≥n]</a></li>
<li><a href="../443460/index.html">11 respuestas sobre Yandex.Directory</a></li>
<li><a href="../443462/index.html">Hackear c√°maras: vectores de ataque, herramientas de b√∫squeda de vulnerabilidades y anti-seguimiento</a></li>
<li><a href="../443466/index.html">Rey del desarrollo</a></li>
<li><a href="../443468/index.html">¬øQu√© herramientas de monitoreo de red se han convertido en l√≠deres en la versi√≥n de Gartner?</a></li>
<li><a href="../443470/index.html">La historia de escribir en el ejemplo de un gran proyecto</a></li>
<li><a href="../443472/index.html">¬øTienes un problema para ir a la nube? 7 consejos sobre c√≥mo no equivocarte</a></li>
<li><a href="../443476/index.html">C√≥mo SimCity inspir√≥ a toda una generaci√≥n de urbanistas</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>