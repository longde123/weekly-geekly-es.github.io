<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üîî ü§∂ üß§ Rendu graphique 3D avec OpenGL üë©üèæ‚Äçü§ù‚Äçüë®üèø üöè üëÜüèª</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©sentation 
 Le rendu de graphiques 3D n'est pas une t√¢che facile, mais extr√™mement int√©ressant et passionnant. Cet article s'adresse √† ceux qui com...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Rendu graphique 3D avec OpenGL</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/467599/"><h2>  Pr√©sentation </h2><br>  Le rendu de graphiques 3D n'est pas une t√¢che facile, mais extr√™mement int√©ressant et passionnant.  Cet article s'adresse √† ceux qui commencent tout juste √† se familiariser avec OpenGL ou √† ceux qui s'int√©ressent au fonctionnement des pipelines graphiques et √† ce qu'ils sont.  Cet article ne fournira pas d'instructions pr√©cises sur la fa√ßon de cr√©er un contexte et une fen√™tre OpenGL, ni sur la fa√ßon d'√©crire votre premi√®re application de fen√™tre OpenGL.  Cela est d√ª aux caract√©ristiques de chaque langage de programmation et au choix d'une biblioth√®que ou d'un framework pour travailler avec OpenGL (j'utiliserai C ++ et <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">GLFW</a> ), d'autant plus qu'il est facile de trouver un tutoriel sur le r√©seau pour le langage qui vous int√©resse.  Tous les exemples donn√©s dans l'article fonctionneront dans d'autres langues avec une s√©mantique l√©g√®rement modifi√©e des commandes, pourquoi il en est ainsi, je le dirai un peu plus tard. <br><a name="habracut"></a><br><h2>  Qu'est-ce qu'OpenGL? </h2><br><p>  OpenGL est une sp√©cification qui d√©finit une interface logicielle ind√©pendante de la plate-forme pour l'√©criture d'applications utilisant des graphiques informatiques bidimensionnels et tridimensionnels.  OpenGL n'est pas une impl√©mentation, mais d√©crit uniquement les ensembles d'instructions qui doivent √™tre impl√©ment√©s, c'est-√†-dire  est une API. </p><br><p>  Chaque version d'OpenGL a sa propre sp√©cification, nous travaillerons de la version 3.3 √† la version 4.6, car  toutes les innovations de la version 3.3 affectent des aspects qui ont peu d'importance pour nous.  Avant de commencer √† √©crire votre premi√®re application OpenGL, je vous recommande de d√©couvrir les versions prises en charge par votre pilote (vous pouvez le faire sur le site du fournisseur de votre carte vid√©o) et de mettre √† jour le pilote vers la derni√®re version. </p><br><h3>  P√©riph√©rique OpenGL </h3><br><p>  OpenGL peut √™tre compar√© √† une grande machine √† √©tats, qui a de nombreux √©tats et fonctions pour les changer.  L'√©tat OpenGL fait essentiellement r√©f√©rence au contexte OpenGL.  Tout en travaillant avec OpenGL, nous passerons par plusieurs fonctions de changement d'√©tat qui changeront le contexte et effectueront des actions en fonction de l'√©tat actuel d'OpenGL. </p><br><p>  Par exemple, si nous donnons √† OpenGL la commande d'utiliser des lignes au lieu de triangles avant le rendu, alors OpenGL utilisera les lignes pour tous les rendus suivants jusqu'√† ce que nous modifiions cette option ou que nous changions le contexte. </p><br><h3>  Objets dans OpenGL </h3><br><p>  Les biblioth√®ques OpenGL sont √©crites en <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">C</a> et ont de nombreuses API pour elles pour diff√©rents langages, mais ce sont n√©anmoins des biblioth√®ques C.  De nombreuses constructions √† partir de C ne sont pas traduites dans des langages de haut niveau, donc OpenGL a √©t√© d√©velopp√© en utilisant un grand nombre d'abstractions, l'une de ces abstractions √©tant des objets. </p><br><p>  Un objet dans OpenGL est un ensemble d'options qui d√©termine son √©tat.  Tout objet dans OpenGL peut √™tre d√©crit par son identifiant et l'ensemble d'options dont il est responsable.  Bien s√ªr, chaque type d'objet a ses propres options et une tentative de configuration d'options inexistantes pour l'objet entra√Ænera une erreur.  C'est l√† que r√©side l'inconv√©nient d'utiliser OpenGL: un ensemble d'options est d√©crit par une structure C similaire dont l'identifiant est souvent un nombre, ce qui ne permet pas au programmeur de trouver une erreur au stade de la compilation, car  un code erron√© et correct est impossible √† distinguer s√©mantiquement. </p><br><pre><code class="cpp hljs">glGenObject(&amp;objectId); glBindObject(GL_TAGRGET, objectId); glSetObjectOption(GL_TARGET, GL_CORRECT_OPTION, correct_option); <span class="hljs-comment"><span class="hljs-comment">//Ok glSetObjectOption(GL_TARGET, GL_WRONG_OPTION, wrong_option); //  , ..   </span></span></code> </pre> <br><p>  Vous rencontrerez un tel code tr√®s souvent, donc lorsque vous vous habituerez √† ce que c'est que de configurer une machine d'√©tat, cela deviendra beaucoup plus facile pour vous.  Ce code ne montre qu'un exemple du fonctionnement d'OpenGL.  Par la suite, de vrais exemples seront pr√©sent√©s. </p><br><p>  Mais il y a des avantages.  La principale caract√©ristique de ces objets est que nous pouvons d√©clarer de nombreux objets dans notre application, d√©finir leurs options, et chaque fois que nous d√©marrons des op√©rations en utilisant l'√©tat OpenGL, nous pouvons simplement lier l'objet avec nos param√®tres pr√©f√©r√©s.  Par exemple, cela peut √™tre des objets avec des donn√©es de mod√®le 3D ou quelque chose que nous voulons dessiner sur ce mod√®le.  La possession de plusieurs objets permet de basculer facilement entre eux pendant le processus de rendu.  Avec cette approche, nous pouvons configurer de nombreux objets n√©cessaires au rendu et utiliser leurs √©tats sans perdre un temps pr√©cieux entre les images. </p><br><p>  Pour commencer √† travailler avec OpenGL, vous devez vous familiariser avec plusieurs objets de base sans lesquels nous ne pouvons rien afficher.  En utilisant ces objets comme exemple, nous comprendrons comment lier des donn√©es et des instructions ex√©cutables dans OpenGL. </p><br><h2>  Objets de base: Shaders et programmes de shader. = </h2><br>  Shader est un petit programme qui s'ex√©cute sur un acc√©l√©rateur graphique (GPU) √† un certain point du pipeline graphique.  Si nous consid√©rons les shaders de mani√®re abstraite, nous pouvons dire que ce sont les √©tapes du pipeline graphique, qui: <br><br><ol><li>  Sachez o√π obtenir les donn√©es pour le traitement. </li><li>  Savoir comment traiter les donn√©es d'entr√©e. </li><li>  Ils savent o√π √©crire des donn√©es pour un traitement ult√©rieur. </li></ol><br><p>  Mais √† quoi ressemble le pipeline graphique?  Tr√®s simple, comme ceci: </p><br><img src="https://habrastorage.org/webt/vv/qi/au/vvqiaulrpglg1rnwq0woxh5xg_8.png"><br>  Jusqu'√† pr√©sent, dans ce sch√©ma, nous ne nous int√©ressons qu'√† la verticale principale, qui commence par la sp√©cification Vertex et se termine par Frame Buffer.  Comme mentionn√© pr√©c√©demment, chaque shader a ses propres param√®tres d'entr√©e et de sortie, qui diff√®rent par le type et le nombre de param√®tres. <br>  Nous d√©crivons bri√®vement chaque √©tape du pipeline afin de comprendre ce qu'il fait: <br><br><ol><li>  Vertex Shader - n√©cessaire pour traiter les donn√©es de coordonn√©es 3D et tous les autres param√®tres d'entr√©e.  Le plus souvent, le vertex shader calcule la position du vertex par rapport √† l'√©cran, calcule les normales (si n√©cessaire) et g√©n√®re des donn√©es d'entr√©e vers d'autres shaders. </li><li>  Shader de tessellation et shader de contr√¥le de tessellation - ces deux shaders sont charg√©s de d√©tailler les primitives provenant du vertex shader et de pr√©parer les donn√©es pour le traitement dans le shader g√©om√©trique.  Il est difficile de d√©crire ce que ces deux shaders sont capables de faire en deux phrases, mais pour que les lecteurs aient une petite id√©e, je vais donner quelques images avec des niveaux de chevauchement faibles et √©lev√©s: <br><div class="scrollable-table"><table><tbody><tr><td><img src="https://habrastorage.org/webt/pm/hu/gy/pmhugylrqwhvqkwnia4eby4k0us.png"></td><td><img src="https://habrastorage.org/webt/_p/rs/dl/_prsdlb_pbwgitigom09fj5fju0.png"></td></tr></tbody></table></div><br>  Je vous conseille de lire cet <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">article</a> si vous souhaitez en savoir plus sur la tessellation.  Dans cette s√©rie d'articles, nous couvrirons la tessellation, mais ce ne sera pas bient√¥t. </li><li>  Shader g√©om√©trique - est responsable de la formation de primitives g√©om√©triques √† partir de la sortie du shader de pavage.  En utilisant le shader g√©om√©trique, vous pouvez cr√©er de nouvelles primitives √† partir des primitives OpenGL de base (GL_LINES, GL_POINT, GL_TRIANGLES, etc.), par exemple, en utilisant le shader g√©om√©trique, vous pouvez cr√©er un effet de particule en d√©crivant la particule uniquement par couleur, centre de cluster, rayon et densit√©. </li><li>  Le shader de rast√©risation est l'un des shaders non programmables.  Parlant dans un langage compr√©hensible, il traduit toutes les primitives graphiques de sortie en fragments (pixels), c'est-√†-dire  d√©termine leur position sur l'√©cran. </li><li>  Le fragment shader est la derni√®re √©tape du pipeline graphique.  Le fragment shader calcule la couleur du fragment (pixel) qui sera d√©fini dans le tampon d'image actuel.  Le plus souvent, dans le shader de fragment, l'ombrage et l'√©clairage du fragment, la cartographie des textures et les cartes normales sont calcul√©s - toutes ces techniques vous permettent d'obtenir des r√©sultats incroyablement beaux. </li></ol><br><p>  Les shaders OpenGL sont √©crits dans un langage GLSL sp√©cial de type C √† partir duquel ils sont compil√©s et li√©s dans un programme de shaders.  D√©j√† √† ce stade, il semble que l'√©criture d'un programme de shader soit une t√¢che extr√™mement longue, car  vous devez d√©terminer les 5 √©tapes du pipeline graphique et les lier ensemble.  Heureusement, ce n'est pas le cas: les ombrages de tessellation et de g√©om√©trie sont d√©finis dans le pipeline graphique par d√©faut, ce qui nous permet de d√©finir seulement deux ombrages - le sommet et les fragments (parfois appel√©s pixel shader).  Il est pr√©f√©rable de consid√©rer ces deux shaders avec un exemple classique: </p><br><div class="spoiler">  <b class="spoiler_title">Vertex shader</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 layout (location = 0) in vec3 vertexCords; layout (location = 1) in vec3 color; out vec3 Color; void main(){ gl_Position = vec4(vertexCords,1.0f) ; Color = color; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Shader de fragment</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#version 450 in vec3 Color; out vec4 out_fragColor; void main(){ out_fragColor = Color; }</span></span></code> </pre><br></div></div><br><div class="spoiler">  <b class="spoiler_title">Exemple d'assemblage de shader</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> vShader = glCreateShader(GL_SHADER_VERTEX); <span class="hljs-comment"><span class="hljs-comment">//    glShaderSource(vShader,&amp;vShaderSource); //  glCompileShader(vShader); //  //        unsigned int shaderProgram = glCreateProgram(); glAttachShader(shaderProgram, vShader); //    glAttachShader(shaderProgram, fShader); //    glLinkProgram(shaderProgram); // </span></span></code> </pre><br></div></div><br><p>  Ces deux shaders simples ne calculent rien, ils transmettent simplement les donn√©es dans le pipeline.  Prenons attention √† la fa√ßon dont les vertex et fragments shaders sont connect√©s: dans le vertex shader, la variable Color est d√©clar√©e dans laquelle la couleur sera √©crite apr√®s l'ex√©cution de la fonction principale, tandis que dans le fragment shader, la m√™me variable exacte avec le qualificatif in est d√©clar√©e, c'est-√†-dire  comme d√©crit pr√©c√©demment, le fragment shader re√ßoit des donn√©es du sommet au moyen d'une simple pouss√©e des donn√©es plus loin dans le pipeline (mais en fait ce n'est pas si simple). <br></p><blockquote>  Remarque: Si vous ne d√©clarez pas et n'initialisez pas une variable de type vec4 dans le fragment shader, rien ne s'affichera √† l'√©cran. </blockquote><br>  Les lecteurs attentifs ont d√©j√† remarqu√© la d√©claration de variables d'entr√©e de type vec3 avec d'√©tranges qualificatifs de disposition au d√©but du vertex shader, il est logique de supposer qu'il s'agit d'une entr√©e, mais d'o√π l'obtenons-nous? <br><br><h2>  Objets de base: tampons et tableaux de sommets </h2><br>  Je pense que cela ne vaut pas la peine d'expliquer ce que sont les objets tampon, nous allons mieux r√©fl√©chir √† la fa√ßon de cr√©er et de remplir un tampon dans OpenGL <br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">float</span></span> vertices[] = { <span class="hljs-comment"><span class="hljs-comment">// // -0.8f, -0.8f, 0.0f, 1.0f, 0.0f, 0.0f, 0.8f, -0.8f, 0.0f, 0.0f, 1.0f, 0.0f, 0.0f, 0.8f, 0.0f, 0.0f, 0.0f, 1.0f }; unsigned int VBO; //vertex buffer object glGenBuffers(1,&amp;VBO); glBindBuffer(GL_SOME_BUFFER_TARGET,VBO); glBufferData(GL_SOME_BUFFER_TARGET, sizeof(vertices), vertices, GL_STATIC_DRAW);</span></span></code> </pre><br><p>  Il n'y a rien de difficile √† cela, nous attachons le tampon g√©n√©r√© √† la cible souhait√©e (nous d√©couvrirons plus tard laquelle) et chargeons les donn√©es en indiquant leur taille et leur type d'utilisation. </p><br><blockquote>  GL_STATIC_DRAW - les donn√©es du tampon ne seront pas modifi√©es. <br>  GL_DYNAMIC_DRAW - les donn√©es dans le tampon changeront, mais pas souvent. <br>  GL_STREAM_DRAW - les donn√©es du tampon changeront √† chaque appel de tirage. <br></blockquote><br><p>  C'est g√©nial, maintenant nos donn√©es sont situ√©es dans la m√©moire du GPU, le programme de shader est compil√© et li√©, mais il y a une mise en garde: comment le programme sait-il o√π obtenir les donn√©es d'entr√©e pour le vertex shader?  Nous avons t√©l√©charg√© les donn√©es, mais n'avons pas indiqu√© d'o√π proviendrait le programme de shader.  Ce probl√®me est r√©solu par un type distinct d'objets OpenGL - les tableaux de vertex. </p><br><img src="https://habrastorage.org/files/106/418/e11/106418e1122b4101af438ce2c6762518.png" alt="image"><br><blockquote>  L'image est tir√©e de ce <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">tutoriel</a> . </blockquote><br><p>  Comme pour les tampons, les tableaux de sommets sont mieux visualis√©s √† l'aide de leur exemple de configuration. </p><br><pre> <code class="cpp hljs"> <span class="hljs-keyword"><span class="hljs-keyword">unsigned</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> VBO, VAO; glGenBuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;VBO); glGenBuffers(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;EBO); glGenVertexArrays(<span class="hljs-number"><span class="hljs-number">1</span></span>, &amp;VAO); glBindVertexArray(VAO); <span class="hljs-comment"><span class="hljs-comment">//    glBindBuffer(GL_ARRAY_BUFFER, VBO); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW); //     () glEnableVertexAttribArray(0); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), nullptr); //     () glEnableVertexAttribArray(1); glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), reinterpret_cast&lt;void*&gt; (sizeof(float) * 3)); glBindBuffer(GL_ARRAY_BUFFER, 0); glBindVertexArray(0);</span></span></code> </pre><br><p>  La cr√©ation de tableaux de sommets n'est pas diff√©rente de la cr√©ation d'autres objets OpenGL, le plus int√©ressant commence apr√®s la ligne: </p><pre> <code class="plaintext hljs">glBindVertexArray(VAO);</code> </pre>  Un vertex array (VAO) se souvient de toutes les liaisons et configurations qui sont effectu√©es avec lui, y compris la liaison des objets tampon pour le d√©chargement des donn√©es.  Dans cet exemple, il n'y a qu'un seul objet de ce type, mais en pratique, il peut y en avoir plusieurs.  Apr√®s cela, l'attribut vertex avec un num√©ro sp√©cifique est configur√©: <p></p><br><pre> <code class="plaintext hljs"> glBindBuffer(GL_ARRAY_BUFFER, VBO); glEnableVertexAttribArray(0); glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 6 * sizeof(float), nullptr);</code> </pre><br>  O√π avons-nous obtenu ce num√©ro?  Vous vous souvenez des qualificatifs de disposition pour les variables d'entr√©e de vertex shader?  Ce sont eux qui d√©terminent √† quel attribut de sommet la variable d'entr√©e sera li√©e.  Passez maintenant bri√®vement en revue les arguments de la fonction pour qu'il n'y ait pas de questions inutiles: <br><ol><li>  Le num√©ro d'attribut que nous voulons configurer. </li><li>  Le nombre d'articles que nous voulons prendre.  (Puisque la variable d'entr√©e du vertex shader avec layout = 0 est de type vec3, alors nous prenons 3 √©l√©ments de type float) </li><li>  Type d'articles. </li><li>  Faut-il normaliser les √©l√©ments, s'il s'agit d'un vecteur. </li><li>  Le d√©calage pour le sommet suivant (puisque nous avons les coordonn√©es et les couleurs situ√©es s√©quentiellement et chacune a le type vec3, alors nous d√©calons de 6 * sizeof (float) = 24 octets). </li><li>  Le dernier argument montre quel d√©calage prendre pour le premier sommet.  (pour les coordonn√©es, cet argument est de 0 octet, pour les couleurs 12 octets) </li></ol><br><p>  Maintenant, nous sommes pr√™ts √† rendre notre premi√®re image </p><br><blockquote>  N'oubliez pas de lier le VAO et le programme shader avant d'appeler le rendu. <br><pre> <code class="cpp hljs">{ <span class="hljs-comment"><span class="hljs-comment">// your render loop glUseProgram(shaderProgram); glBindVertexArray(VAO); glDrawElements(GL_TRIANGLES,0,3); //        }</span></span></code> </pre><br></blockquote><br><p>  Si vous avez tout fait correctement, vous devriez obtenir ce r√©sultat: </p><br><img src="https://habrastorage.org/webt/nn/zt/w2/nnztw2prezwfkhm9dsx9viufl4m.png"><br><p>  Le r√©sultat est impressionnant, mais d'o√π vient le remplissage d√©grad√© dans le triangle, car nous n'avons indiqu√© que 3 couleurs: rouge, bleu et vert pour chaque sommet individuel?  C'est la magie du shader de pixellisation: le fait est que la valeur de couleur que nous avons d√©finie dans le sommet n'entre pas dans le shader de fragment.  Nous ne transmettons que 3 sommets, mais beaucoup plus de fragments sont g√©n√©r√©s (il y a exactement autant de fragments qu'il y a de pixels remplis).  Par cons√©quent, pour chaque fragment, la moyenne des trois valeurs de couleur est prise, en fonction de sa proximit√© avec chacun des sommets.  Ceci est tr√®s bien vu aux coins du triangle, o√π les fragments prennent la valeur de couleur que nous avons indiqu√©e dans les donn√©es de sommet. <br></p><blockquote>  √Ä l'avenir, je dirai que les coordonn√©es de texture sont transmises de la m√™me mani√®re, ce qui facilite la superposition de textures sur nos primitives. </blockquote><br><p>  Je pense que cela vaut la peine de terminer cet article, le plus difficile est derri√®re nous, mais le plus int√©ressant ne fait que commencer.  Si vous avez des questions ou si vous avez vu une erreur dans l'article, √©crivez √† ce sujet dans les commentaires, je vous en serai tr√®s reconnaissant. </p><br><p>  Dans le prochain article, nous examinerons les transformations, nous en apprendrons sur les variables unifrom et nous apprendrons √† imposer des textures aux primitives. </p><p></p><p></p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr467599/">https://habr.com/ru/post/fr467599/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr467589/index.html">Ce que vous devez savoir sur le RGPD en 2019</a></li>
<li><a href="../fr467591/index.html">La nouvelle preuve r√©sout l'approximation de nombres tels que pi</a></li>
<li><a href="../fr467593/index.html">(Sans objet, r√©par√©) Remarque. Comment Tele2 partage l'acc√®s au compte personnel des nouveaux abonn√©s</a></li>
<li><a href="../fr467595/index.html">Voyager √† travers le centre de donn√©es Selectel. Dinosaure en feu, VMware, C2F5H et le loup-garou invisible</a></li>
<li><a href="../fr467597/index.html">Personnalisation des directives de produit Big Data avec Vowpal Wabbit</a></li>
<li><a href="../fr467605/index.html">Tout ce dont vous avez besoin est une URL</a></li>
<li><a href="../fr467607/index.html">Confession de haineux docker</a></li>
<li><a href="../fr467609/index.html">Cr√©ation d'une application mobile sur React Native</a></li>
<li><a href="../fr467611/index.html">Algorithmes de d√©tection de contour d'image</a></li>
<li><a href="../fr467615/index.html">Comment cr√©er un wrapper Python et ne pas devenir fou</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>