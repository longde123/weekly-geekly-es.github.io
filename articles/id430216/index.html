<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🚴🏾 📛 🐥 Seperti yang saya pahami, saya makan banyak manisan, atau klasifikasi barang dengan memeriksa aplikasi 🆒 👐 🧚🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Tantangan 
 Dalam artikel ini, kami ingin berbicara tentang bagaimana kami menciptakan solusi untuk mengklasifikasikan nama produk dari tanda terima d...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Seperti yang saya pahami, saya makan banyak manisan, atau klasifikasi barang dengan memeriksa aplikasi</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/430216/"><h2>  Tantangan </h2><br>  Dalam artikel ini, kami ingin berbicara tentang bagaimana kami menciptakan solusi untuk mengklasifikasikan nama produk dari tanda terima dalam aplikasi untuk mencatat pengeluaran untuk cek dan asisten belanja.  Kami ingin memberi pengguna kesempatan untuk melihat statistik pembelian, dikumpulkan secara otomatis berdasarkan tanda terima yang dipindai, yaitu untuk mendistribusikan semua barang yang dibeli oleh pengguna berdasarkan kategori.  Karena memaksa pengguna untuk secara mandiri mengelompokkan produk sudah abad terakhir.  Ada beberapa pendekatan untuk menyelesaikan masalah ini: Anda dapat mencoba menerapkan algoritma pengelompokan dengan berbagai cara representasi vektor kata atau algoritma klasifikasi klasik.  Kami belum menemukan sesuatu yang baru, dan dalam artikel ini kami hanya ingin berbagi panduan kecil tentang kemungkinan solusi untuk masalah tersebut, contoh bagaimana tidak melakukan ini, analisis mengapa metode lain tidak berhasil dan masalah apa yang mungkin Anda temui dalam proses. <br><a name="habracut"></a><br><h2>  Clustering </h2><br>  Salah satu masalah adalah bahwa nama barang yang kita dapatkan dari cek tidak selalu mudah diuraikan, bahkan untuk seseorang.  Kecil kemungkinan Anda akan tahu produk seperti apa dengan nama <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"UTRUSTA krnsht"</a> yang dibeli di salah satu toko Rusia?  Penikmat sejati desain Swedia pasti akan menjawab kami segera: Bracket untuk oven Utrust, tetapi menjaga spesialis seperti itu di markas cukup mahal.  Selain itu, kami tidak memiliki sampel berlabel siap pakai yang sesuai untuk data kami, yang dapat digunakan untuk melatih model.  Oleh karena itu, pertama kita akan berbicara tentang bagaimana, dengan tidak adanya data untuk pelatihan, kami menerapkan algoritma pengelompokan dan mengapa kami tidak menyukainya. <br><br>  Algoritma tersebut didasarkan pada pengukuran jarak antara objek, yang membutuhkan representasi vektor atau penggunaan metrik untuk mengukur kemiripan kata-kata (misalnya, jarak Levenshtein).  Pada langkah ini, kesulitannya terletak pada representasi vektor yang bermakna dari nama-nama tersebut.  Merupakan masalah untuk mengekstrak properti dari nama-nama yang akan secara lengkap dan komprehensif menggambarkan produk dan hubungannya dengan produk lain. <br><br>  Opsi termudah adalah menggunakan Tf-Idf, tetapi dalam hal ini dimensi ruang vektor cukup besar, dan ruang itu sendiri jarang.  Selain itu, pendekatan ini tidak mengekstraksi informasi tambahan apa pun dari namanya.  Dengan demikian, dalam satu kelompok dapat terdapat banyak produk dari kategori yang berbeda, disatukan oleh kata yang sama, seperti, misalnya, "kentang" atau "salad": <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/pb/uh/bd/pbuhbdnf0bwmwvy0ywqwapil018.png"></div><br>  Kami juga tidak dapat mengontrol kelompok mana yang akan dirakit.  Satu-satunya hal yang dapat diindikasikan adalah jumlah cluster (jika algoritma berdasarkan puncak non-kepadatan di ruang digunakan).  Tetapi jika Anda menentukan jumlah yang terlalu kecil, maka satu cluster besar terbentuk, yang akan berisi semua nama yang tidak dapat masuk ke dalam cluster lain.  Jika Anda menentukan yang cukup besar, maka setelah algoritme berfungsi, kita harus melihat melalui ratusan cluster dan menggabungkannya ke dalam kategori semantik dengan tangan. <br><br>  Tabel di bawah ini memberikan informasi tentang cluster menggunakan algoritma KMeans dan Tf-Idf untuk representasi vektor.  Dari tabel ini kita melihat bahwa jarak antara pusat-pusat cluster kurang dari jarak rata-rata antara objek dan pusat-pusat cluster di mana mereka berada.  Data tersebut dapat dijelaskan oleh fakta bahwa dalam ruang vektor tidak ada puncak kepadatan yang jelas dan pusat cluster terletak pada lingkaran, di mana sebagian besar objek berada di luar lingkaran ini.  Selain itu, satu cluster terbentuk, yang berisi sebagian besar vektor.  Kemungkinan besar dalam klaster ini adalah nama-nama yang mengandung kata-kata yang lebih sering ditemukan daripada yang lain di antara semua produk dari kategori yang berbeda. <br><br><table><caption>  Tabel 1. Jarak antar cluster. </caption><tbody><tr><th>  Cluster </th><th>  C1 </th><th>  C2 </th><th>  C3 </th><th>  C4 </th><th>  C5 </th><th>  C6 </th><th>  C7 </th><th>  C8 </th><th>  C9 </th></tr><tr><th>  C1 </th><td>  0,0 </td><td>  0,502 </td><td>  0,354 </td><td>  0,475 </td><td>  0,481 </td><td>  0,527 </td><td>  0,498 </td><td>  0,501 </td><td>  0,524 </td></tr><tr><th>  C2 </th><td>  0,502 </td><td>  0,0 </td><td>  0,614 </td><td>  0,685 </td><td>  0,696 </td><td>  0,728 </td><td>  0,706 </td><td>  0,709 </td><td>  0,725 </td></tr><tr><th>  C3 </th><td>  0,354 </td><td>  0,614 </td><td>  0,0 </td><td>  0,590 </td><td>  0,597 </td><td>  0,635 </td><td>  0,610 </td><td>  0,613 </td><td>  0,632 </td></tr><tr><th>  C4 </th><td>  0,475 </td><td>  0,685 </td><td>  0,590 </td><td>  0,0 </td><td>  0,673 </td><td>  0,709 </td><td>  0,683 </td><td>  0,687 </td><td>  0,699 </td></tr><tr><th>  C5 </th><td>  0,481 </td><td>  0,696 </td><td>  0,597 </td><td>  0,673 </td><td>  0,0 </td><td>  0,715 </td><td>  0,692 </td><td>  0,694 </td><td>  0,711 </td></tr><tr><th>  C6 </th><td>  0,527 </td><td>  0,727 </td><td>  0,635 </td><td>  0,709 </td><td>  0,715 </td><td>  0,0 </td><td>  0,726 </td><td>  0,728 </td><td>  0,741 </td></tr><tr><th>  C7 </th><td>  0,498 </td><td>  0,706 </td><td>  0,610 </td><td>  0,683 </td><td>  0,692 </td><td>  0,725 </td><td>  0,0 </td><td>  0,707 </td><td>  0,714 </td></tr><tr><th>  C8 </th><td>  0,501 </td><td>  0,709 </td><td>  0,612 </td><td>  0,687 </td><td>  0,694 </td><td>  0,728 </td><td>  0,707 </td><td>  0,0 </td><td>  0,725 </td></tr><tr><th>  C9 </th><td>  0,524 </td><td>  0,725 </td><td>  0,632 </td><td>  0,699 </td><td>  0,711 </td><td>  0,741 </td><td>  0,714 </td><td>  0,725 </td><td>  0,0 </td></tr></tbody></table><br><table><caption>  Tabel 2. Informasi singkat tentang kluster </caption><tbody><tr><th>  Cluster </th><th>  Jumlah objek </th><th>  Jarak rata-rata </th><th>  Jarak minimum </th><th>  Jarak maksimum </th></tr><tr><th>  C1 </th><td>  62530 </td><td>  0,999 </td><td>  0,041 </td><td>  1,001 </td></tr><tr><th>  C2 </th><td>  2159 </td><td>  0,864 </td><td>  0,527 </td><td>  0,964 </td></tr><tr><th>  C3 </th><td>  1099 </td><td>  0,934 </td><td>  0,756 </td><td>  0,993 </td></tr><tr><th>  C4 </th><td>  1292 </td><td>  0,879 </td><td>  0,733 </td><td>  0,980 </td></tr><tr><th>  C5 </th><td>  746 </td><td>  0,875 </td><td>  0,731 </td><td>  0,965 </td></tr><tr><th>  C6 </th><td>  2451 </td><td>  0,847 </td><td>  0,719 </td><td>  0,994 </td></tr><tr><th>  C7 </th><td>  1133 </td><td>  0,866 </td><td>  0,724 </td><td>  0,986 </td></tr><tr><th>  C8 </th><td>  876 </td><td>  0,863 </td><td>  0,704 </td><td>  0,999 </td></tr><tr><th>  C9 </th><td>  1879 </td><td>  0,849 </td><td>  0,526 </td><td>  0,981 </td></tr></tbody></table><br><br>  Tetapi di beberapa tempat, kluster-kluster itu ternyata cukup baik, seperti, misalnya, pada gambar di bawah ini - di sana, hampir semua produk adalah makanan kucing. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/oh/uy/5p/ohuy5p_bgiignp9ah_gokvvbzs4.png"></div><br><br>  Doc2Vec adalah salah satu dari algoritma yang memungkinkan Anda untuk mewakili teks dalam bentuk vektor.  Dengan menggunakan pendekatan ini, setiap nama akan dideskripsikan dengan vektor berdimensi lebih kecil daripada menggunakan Tf-Idf.  Dalam ruang vektor yang dihasilkan, teks yang mirip akan dekat satu sama lain, dan yang berbeda jauh. <br><br>  Pendekatan ini dapat menyelesaikan masalah dimensi besar dan ruang kosong yang diperoleh dengan metode Tf-Idf.  Untuk algoritme ini, kami menggunakan opsi tokenization yang paling sederhana: kami memecah nama menjadi kata-kata yang terpisah dan mengambil bentuk awalnya.  Dia dilatih tentang data dengan cara ini: <br><br><pre><code class="python hljs">max_epochs = <span class="hljs-number"><span class="hljs-number">100</span></span> vec_size = <span class="hljs-number"><span class="hljs-number">20</span></span> alpha = <span class="hljs-number"><span class="hljs-number">0.025</span></span> model = doc2vec.Doc2Vec(vector_size=vec_size, alpha=alpha, min_alpha=<span class="hljs-number"><span class="hljs-number">0.00025</span></span>, min_count=<span class="hljs-number"><span class="hljs-number">1</span></span>, dm =<span class="hljs-number"><span class="hljs-number">1</span></span>) model.build_vocab(train_corpus) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> epoch <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> range(max_epochs): print(<span class="hljs-string"><span class="hljs-string">'iteration {0}'</span></span>.format(epoch)) model.train(train_corpus, total_examples=model.corpus_count, epochs=model.iter) <span class="hljs-comment"><span class="hljs-comment"># decrease the learning rate model.alpha -= 0.0002 # fix the learning rate, no decay model.min_alpha = model.epochs</span></span></code> </pre> <br>  Tetapi dengan pendekatan ini, kami mendapat vektor yang tidak membawa informasi tentang nama - dengan kesuksesan yang sama Anda dapat menggunakan nilai acak.  Berikut adalah salah satu contoh pengoperasian algoritma: gambar menunjukkan produk yang serupa menurut pendapat algoritme dengan “Roti Borodino dalam bentuk n pn 0.45k”. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/qd/m9/lp/qdm9lplwaidbilivtpb3jjskopo.png"></div><br>  Mungkin masalahnya ada pada panjang dan konteks nama: pas di nama "__ klub. Pisang 200ml" bisa berupa yogurt, jus, atau sekaleng krim besar.  Anda dapat mencapai hasil yang lebih baik menggunakan pendekatan yang berbeda untuk tokenization nama.  Kami tidak memiliki pengalaman menggunakan metode ini, dan pada saat upaya pertama gagal, kami sudah menemukan beberapa set yang ditandai dengan nama produk, jadi kami memutuskan untuk meninggalkan sementara metode ini dan beralih ke algoritma klasifikasi. <br><br><h2>  Klasifikasi </h2><br><h3>  Pra-pemrosesan data </h3><br>  Nama-nama barang dari cek datang kepada kita dengan cara yang tidak selalu jelas: Latin dan Cyrillic dicampur dalam kata-kata.  Misalnya, huruf "a" dapat diganti dengan "a" Latin, dan ini menambah jumlah nama unik - misalnya, kata "susu" dan "susu" akan dianggap berbeda.  Nama-nama itu juga mengandung banyak kesalahan ketik dan singkatan lainnya. <br><br>  Kami memeriksa basis data kami dan menemukan kesalahan khas pada namanya.  Pada tahap ini, kami mengeluarkan ekspresi reguler, dengan bantuan yang kami membersihkan nama dan membawanya ke pandangan umum tertentu.  Dengan menggunakan pendekatan ini, hasilnya meningkat sekitar 7%.  Bersama dengan opsi SGD Classifier sederhana berdasarkan pada fungsi Huber loss dengan parameter twisted, kami mendapatkan akurasi 81% untuk F1 (akurasi rata-rata untuk semua kategori produk). <br><br><pre> <code class="python hljs">sgd_model = SGDClassifier() parameters_sgd = { <span class="hljs-string"><span class="hljs-string">'max_iter'</span></span>:[<span class="hljs-number"><span class="hljs-number">100</span></span>], <span class="hljs-string"><span class="hljs-string">'loss'</span></span>:[<span class="hljs-string"><span class="hljs-string">'modified_huber'</span></span>], <span class="hljs-string"><span class="hljs-string">'class_weight'</span></span>:[<span class="hljs-string"><span class="hljs-string">'balanced'</span></span>], <span class="hljs-string"><span class="hljs-string">'penalty'</span></span>:[<span class="hljs-string"><span class="hljs-string">'l2'</span></span>], <span class="hljs-string"><span class="hljs-string">'alpha'</span></span>:[<span class="hljs-number"><span class="hljs-number">0.0001</span></span>] } sgd_cv = GridSearchCV(sgd_model, parameters_sgd,n_jobs=<span class="hljs-number"><span class="hljs-number">-1</span></span>) sgd_cv.fit(tf_idf_data, prod_cat) sgd_cv.best_score_, sgd_cv.best_params_</code> </pre> <br>  Juga, jangan lupa bahwa beberapa kategori orang membeli lebih sering daripada yang lain: misalnya, "Teh dan permen" dan "Sayuran dan buah-buahan" jauh lebih populer daripada "Layanan" dan "Kosmetik".  Dengan distribusi data seperti itu, lebih baik menggunakan algoritma yang memungkinkan Anda untuk mengatur bobot (tingkat kepentingan) untuk setiap kelas.  Berat kelas dapat ditentukan secara terbalik dengan nilai yang sama dengan rasio jumlah produk di kelas terhadap jumlah total produk.  Tetapi Anda tidak perlu memikirkannya, karena dalam penerapan algoritme ini, dimungkinkan untuk menentukan bobot kategori secara otomatis. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/ty/o9/pk/tyo9pkfhw-ibby5jopobc5okotc.png"></div><br><h2>  Memperoleh data baru untuk pelatihan </h2><br>  Aplikasi kami membutuhkan kategori yang sedikit berbeda dari yang digunakan dalam kompetisi, dan nama-nama produk dari database kami sangat berbeda dari yang disajikan dalam kontes.  Oleh karena itu, kami perlu menandai barang dari tanda terima kami.  Kami mencoba melakukan ini sendiri, tetapi kami menyadari bahwa meskipun kami menghubungkan seluruh tim kami, itu akan memakan waktu yang sangat lama.  Oleh karena itu, kami memutuskan untuk menggunakan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">"Toloka" Yandex</a> . <br><br>  Di sana kami menggunakan bentuk penugasan ini: <br><br><ul><li>  di setiap sel kami menyajikan produk, kategori yang harus ditentukan </li><li>  kategori hipotetisnya ditentukan oleh salah satu model kami sebelumnya </li><li>  bidang respons (jika kategori yang diajukan salah) </li></ul><br>  Kami membuat instruksi terperinci dengan contoh-contoh yang menjelaskan fitur masing-masing kategori, dan juga menggunakan metode kontrol kualitas: satu set dengan jawaban standar yang ditunjukkan bersama dengan tugas-tugas biasa (kami menerapkan jawaban standar sendiri, menandai beberapa ratus produk).  Menurut hasil jawaban untuk tugas-tugas ini, pengguna yang salah menandai data disaring.  Namun, untuk keseluruhan proyek, kami melarang hanya tiga pengguna dari 600+. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/fx/ib/xt/fxibxt-v5h7vouodjoffwtl6egy.png"></div><br>  Dengan data baru, kami mendapatkan model yang lebih sesuai dengan data kami, dan akurasi meningkat sedikit lebih banyak (~ 11%) dan sudah mendapatkan 92%. <br><br><h2>  Model akhir </h2><br>  Kami memulai proses klasifikasi dengan kombinasi data dari beberapa dataset dengan Kaggle - 74%, setelah itu kami meningkatkan preprocessing - 81%, mengumpulkan set data baru - 92% dan akhirnya memperbaiki proses klasifikasi: awalnya, dengan menggunakan regresi logistik kami mendapatkan probabilitas awal barang yang dimiliki SGD memberikan akurasi yang lebih besar untuk kategori berdasarkan nama produk, tetapi masih memiliki nilai besar pada fungsi kerugian, yang sangat mempengaruhi hasil klasifikasi akhir.  Selanjutnya, kami menggabungkan data yang diperoleh dengan data lain pada produk (harga produk, toko tempat pembelian, statistik di toko, cek dan informasi meta lainnya), dan XGBoost dilatih pada semua volume data ini, yang memberikan akurasi 98% (peningkatan 6% lainnya).  Ternyata, kontribusi terbesar dibuat oleh kualitas sampel pelatihan. <br><br><h2>  Berjalan di server </h2><br>  Untuk mempercepat penyebaran, kami mengangkat server sederhana di Flask ke Docker.  Ada satu metode yang menerima barang dari server yang perlu dikategorikan dan mengembalikan barang dengan kategori sudah.  Dengan demikian, kami dengan mudah diintegrasikan ke dalam sistem yang ada, yang pusatnya adalah Tomcat, dan kami tidak perlu membuat perubahan pada arsitektur - kami hanya menambahkan satu blok lagi ke dalamnya. <br><br><h2>  Tanggal rilis </h2><br>  Beberapa minggu yang lalu kami memposting rilis kategorisasi di Google Play (akan muncul di App Store setelah beberapa saat).  Ternyata seperti ini: <br><br><div style="text-align:center;"><img src="https://habrastorage.org/webt/h1/tj/ie/h1tjiekixykrb_liuwftfnd8ufy.png" width="50%"></div><br>  Dalam rilis mendatang, kami berencana untuk menambahkan kemampuan untuk memperbaiki kategori, yang akan memungkinkan kami untuk dengan cepat mengumpulkan kesalahan kategorisasi dan melatih kembali model kategorisasi (sementara kami melakukannya sendiri). <br><br>  Kompetisi yang disebutkan di Kaggle: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.kaggle.com/c/receipt-categorisation</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.kaggle.com/c/market-basket-analysis</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">www.kaggle.com/c/prod-price-prediction</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id430216/">https://habr.com/ru/post/id430216/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id430204/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 18: “Penjelajahan Pribadi Internet”, bagian 1</a></li>
<li><a href="../id430206/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 18: Penjelajahan Pribadi Internet, Bagian 2</a></li>
<li><a href="../id430208/index.html">Kursus MIT "Keamanan Sistem Komputer". Kuliah 18: "Penjelajahan Internet Pribadi", bagian 3</a></li>
<li><a href="../id430210/index.html">Tes Kesabaran Saya oleh Akademi Keamanan Titik Centang</a></li>
<li><a href="../id430212/index.html">OpenSceneGraph: Dasar-dasar Geometri Adegan</a></li>
<li><a href="../id430218/index.html">Optimalisasi Energi STM32: Panduan Praktis</a></li>
<li><a href="../id430220/index.html">Bagaimana mengubah hub usb "seratus tahun" menjadi smart dikelola dan menghemat $ 300</a></li>
<li><a href="../id430222/index.html">Insinyur Senior dalam mencari pekerjaan. Bagaimana saya melewati 20 wawancara dengan HR dan apa yang saya pikirkan</a></li>
<li><a href="../id430224/index.html">Gangguan Skizotip: An Inside Look</a></li>
<li><a href="../id430226/index.html">Dari var b ke wawancara</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>