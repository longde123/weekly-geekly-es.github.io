<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🕚 🎉 🤱🏻 React＆BEM-官方合作。 历史部分 👨🏻‍🏫 ⚪️ 🤛🏼</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="这是将BEM方法集成到React世界中的故事。 您将阅读的材料是基于Yandex开发人员开发俄罗斯最大，负载最大的服务的经验-Yandex.Search。 我们之前从未如此详细，深入地谈论过我们这样做的原因，而没有其他方面谈到过激励我们的动机以及我们真正想要的是什么。 局外人在发布会上发布了发布和评...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>React＆BEM-官方合作。 历史部分</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/yandex/blog/438598/"><p> 这是将BEM方法集成到React世界中的故事。 您将阅读的材料是基于Yandex开发人员开发俄罗斯最大，负载最大的服务的经验-Yandex.Search。 我们之前从未如此详细，深入地谈论过我们这样做的原因，而没有其他方面谈到过激励我们的动机以及我们真正想要的是什么。 局外人在发布会上发布了发布和评论。 只有在场外才能听到类似的声音。 作为合著者，我很愤慨，因为每次我谈论图书馆的新版本时，外界信息的匮乏。 但是这次我们将分享所有细节。 </p><br><img src="https://habrastorage.org/webt/wb/mt/xc/wbmtxcvurtd6cdv1aomjrtcyfw8.png"><br><p> 每个人都听说过BEM方法论。 带下划线的CSS选择器。 讨论<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">组件方法</a>时要牢记CSS CSS选择器的编写方式。 但是本文中不会涉及CSS。 只有JS，只有铁杆！ </p><a name="habracut"></a><br><p> 为了了解这种方法为何出现以及Yandex当时面临什么问题，我建议您<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">熟悉</a> BEM <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的历史</a> 。 </p><br><h2 id="prolog"> 序言 </h2><br><p> BEM实际上是从CSS中强大的连接性和嵌套的拯救中诞生的。 但是，将<code>style.css</code>表分为每个块，元素或修饰符的文件不可避免地导致了类似的JavaScript代码结构。 </p><br><p>  2011年，开放源代码获得了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>i-bem.js</code></a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">第一批提交，该</a> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>i-bem.js</code></a>与<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>bem-xjst</code></a>模板引擎<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>bem-xjst</code></a> 。 两种技术均源于<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">XSLT</a> ，并为当时流行的将业务逻辑和组件表示分离的想法服务。 在外部世界，这是Handlebars和Underscore的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">美好时光</a> 。 </p><br><p>  <code>bem-xjst</code>是另一种类型的模板引擎。 为了增加我对标准化方法的体系结构的了解，我强烈推荐<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Sergei Berezhnoy</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">报告</a> 。  <code>bem-xjst</code>可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在线沙箱中</a>尝试使用<code>bem-xjst</code>模板引擎。 </p><br><p> 由于Yandex搜索服务的特殊性，用户界面是使用数据构建的。 搜索结果页面对于每个查询都是唯一的。 </p><br><p><img src="https://habrastorage.org/webt/6g/af/sc/6gafsczppz4ul8glzeliauwnkjc.png"><br>  <em>通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">参考</a>搜索查询</em> </p><br><p><img src="https://habrastorage.org/webt/ni/z5/nc/niz5ncgv3rlci2jfymornobfvcy.png"><br>  <em>通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">参考</a>搜索查询</em> </p><br><p><img src="https://habrastorage.org/webt/eb/6q/ws/eb6qws6vwtclkce_jsumewy4jkk.png"><br>  <em>通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">参考</a>搜索查询</em> </p><br><p> 当分为块，元素和修饰符的划分扩展到文件系统时，这仅允许为每个用户请求的每个页面收集尽可能多的必需代码。 但是如何？ </p><br><pre> <code class="plaintext hljs">src/components ├── ComponentName │ ├── _modName │ │ ├── ComponentName_modName.tsx —   │ │ └── ComponentName_modName_modVal.tsx —    │ ├── ElementName │ │ └── ComponentName-ElementName.tsx —   ComponentName │ ├── ComponentName.i18n —   │ │ ├── ru.ts —     │ │ ├── en.ts —     │ │ └── index.ts —    │ ├── ComponentName.test —   │ │ ├── ComponentName.page-object.js — Page Object │ │ ├── ComponentName.hermione.js —   │ │ └── ComponentName.test.tsx — unit- │ ├── ComponentName.tsx —    │ ├── ComponentName.scss —   │ ├── ComponentName.examples.tsx —    Storybook │ └── README.md —  </code> </pre> <br><p>  <em>现代组件目录结构</em> </p><br><p> 与其他公司一样，在Yandex中，界面开发人员负责前端，前端由浏览器中的客户端部分和<code>Node.js</code>上的服务器部分组成<code>Node.js</code> 服务器部分处理“大”搜索的数据并在其上加上模板。 主数据处理将JSON转换为<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">BEMJSON</a> ， <code>bem-xjst</code>模板引擎的数据结构。 模板引擎围绕树的每个节点并在其上强加一个模板。 由于主要转换发生在服务器上，并且由于分为小实体，所以节点对应于文件，因此在模板生成期间，我们将代码推送到仅在当前页面上使用的浏览器中。 </p><br><p> 下面是BEMJSON节点与文件系统上文件的对应关系。 </p><br><pre> <code class="javascript hljs"><span class="hljs-built_in"><span class="hljs-built_in">module</span></span>.exports = { <span class="hljs-attr"><span class="hljs-attr">block</span></span>: <span class="hljs-string"><span class="hljs-string">'Select'</span></span>, <span class="hljs-attr"><span class="hljs-attr">elem</span></span>: <span class="hljs-string"><span class="hljs-string">'Item'</span></span>, <span class="hljs-attr"><span class="hljs-attr">elemMods</span></span>: { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'navigation'</span></span> } };</code> </pre> <br><pre> <code class="plaintext hljs">src/components ├── Select │ ├── Item │ │ _type │ │ ├── Select-Item_type_navigation.js │ │ └── Select-Item_type_navigation.css</code> </pre> <br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>YModules</code></a>模块化系统负责隔离浏览器中JavaScript代码的组件。 它允许您同步和异步将模块交付给浏览器。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">可以在此处找到</a>有关组件如何与<code>YModules</code>和<code>i-bem.js</code>一起使用的示例。 如今，对于大多数开发人员而言， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>  webpack</code></a>和未发布<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的动态导入标准都可以做到这一点</a> 。 </p><br><p> 一套BEM方法论，声明性模板引擎和带有模块化系统的JS框架使解决任何问题成为可能。 但是随着时间的流逝，动态性已经进入用户界面。 </p><br><h2 id="novaya-nadezhda"> 新希望 </h2><br><p> 在2013年， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">React迷上了</a>开源。 实际上，Facebook早在2011年就开始使用它。 詹姆斯·朗（James Long）在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">JS Conf US</a>会议上的笔记中说： </p><br><blockquote> 最后两节令人惊讶。 第一个是由两名Facebook开发人员提供的，他们宣布了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Facebook React</a> 。 我没有记很多笔记，因为我对这个想法有多么糟糕感到震惊。 本质上，他们创建了一种称为JSX的语言，该语言使您可以将XML嵌入JavaScript中以创建实时响应式用户界面。  XML格式 在JavaScript中。 </blockquote><p>  React已经改变了设计Web应用程序的方法。 它变得如此流行，以至于今天您找不到没有听说过React的开发人员。 但是另一件事很重要：应用程序变得不同， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SPA</a>进入了我们的生活。 </p><br><p>  Yandex开发人员在技术方面具有特殊的美感，这是公认的。 有时很奇怪，很难与之抗争，但从来没有没有道理。 当React <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在GitHub上广为人知时</a> ，许多熟悉Yandex网络技术的人坚持认为：Facebook赢了，放弃您的技术，并在一切都太晚之前运行重写React上的一切。 了解两件事很重要。 </p><br><p> 首先，没有战争。 公司在创建地球上最好的框架方面没有竞争。 如果一家公司开始以相同的生产力减少在基础架构任务上花费的时间（读钱），那么每个人都会从中受益。 编写框架来编写框架是没有意义的。 最好的开发人员创建工具，以最佳方式解决公司的任务。 公司，服务，目标-都是不同的。 因此，工具多种多样。 </p><br><p> 其次，我们正在寻找一种以自己希望的方式使用React的方法。 具有上述技术所提供的所有功能。 </p><br><p> 人们普遍认为使用React的代码默认情况下是快速的。 如果您也这样认为，那您就深深地误会了。 在大多数情况下，React唯一要做的就是帮助与DOM进行最佳交互。 </p><br><p> 在版本16之前，React有一个致命缺陷。 它比服务器上的<code>bem-xjst</code>慢10倍。 我们负担不起这种浪费。  Yandex的响应时间是关键指标之一。 想象一下，当您要求甜酒配方时，您会得到比平时慢10倍的答案。 即使您对网络开发有所了解，您也不会为借口感到高兴。 我们可以说些什么，例如“但使开发人员与DOM通信变得更加方便”。 在此处加上实施价格与利润的比率-您自己将做出唯一正确的决定。 </p><br><p> 幸运的是，开发人员是陌生的人。 如果无法解决问题，那么这并不是丢弃所有内容的理由... </p><br><h2 id="shivorot-navyvorot"> 倒挂 </h2><br><p> 我们坚信我们可以战胜React的缓慢发展。 我们已经有一个快速的模板引擎。 您所需<code>bem-xjst</code>使用<code>bem-xjst</code>在服务器上生成HTML，并在客户端上“强制” React接受此标记作为其自身。 这个想法很简单，没有什么预示着失败。 </p><br><p> 在15以下的版本中，React使用哈希和验证了标记的有效性，该算法将所有优化转化为南瓜。 为了使React确信标记的有效性，有必要为每个节点设置一个id，并计算所有节点的哈希和。 它还意味着要支持<code>bem-xjst</code>模板：针对客户端的React和针对服务器的<code>bem-xjst</code> 。 使用id安装进行简单的速度测试可以清楚地表明继续进行毫无意义。 </p><br><p>  bem <code>bem-xjst</code>是一个非常被低估的工具。 查看<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Glory Oliyanchuk主要维护者</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">报告，亲自看看</a> 。  <code>bem-xjst</code>基于一种体系结构，该体系结构允许您将一种模板语法用于源树的不同转换。 与React非常相似，不是吗？ 如今，此功能允许<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>react-sketchapp</code></a>诸如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>react-sketchapp</code></a>工具。 </p><br><p> 开箱即用<code>bem-xjst</code>包含两种类型的转换：HTML和JSON。 任何足够勤奋的开发人员都可以编写自己的引擎，以将模板转换为任何东西。 我们教<code>bem-xjst</code>将数据树转换为对<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">HyperScript函数</a>的调用序列。 这意味着与React以及虚拟DOM算法的其他实现（例如<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">Preact）</a>完全兼容。 </p><br><iframe width="560" height="315" src="https://www.youtube.com/embed/yPV6pcMdezM" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><p>  <em>HyperScript函数调用生成的详细介绍</em> </p><br><p> 由于React模板需要布局和业务逻辑共存，因此我们不得不将<code>i-bem.js</code>的逻辑引入我们的模板中，而这并不是为此而设计的。 对于他们来说，这是不自然的。 他们走的不一样。 对了！ </p><br><p> 下面是在一个运行时中融合不同世界的示例。 </p><br><pre> <code class="javascript hljs">block(<span class="hljs-string"><span class="hljs-string">'select'</span></span>).elem(<span class="hljs-string"><span class="hljs-string">'menu'</span></span>)( def()(<span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> React = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'react'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> Menu = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../components/menu/menu'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> MenuItem = <span class="hljs-built_in"><span class="hljs-built_in">require</span></span>(<span class="hljs-string"><span class="hljs-string">'../components/menu-item/menu-item'</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> _select = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.ctx._select; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> selectComponent = _select._select; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> React.createElement.apply(React, [ Menu, { <span class="hljs-attr"><span class="hljs-attr">mix</span></span>: { <span class="hljs-attr"><span class="hljs-attr">block</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.block, <span class="hljs-attr"><span class="hljs-attr">elem</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.elem }, <span class="hljs-attr"><span class="hljs-attr">ref</span></span>: <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">menu</span></span></span><span class="hljs-function"> =&gt;</span></span> selectComponent._menu = menu, <span class="hljs-attr"><span class="hljs-attr">size</span></span>: _select.mods.size, <span class="hljs-attr"><span class="hljs-attr">disabled</span></span>: _select.mods.disabled, <span class="hljs-attr"><span class="hljs-attr">mode</span></span>: _select.mods.mode, <span class="hljs-attr"><span class="hljs-attr">content</span></span>: _select.options, <span class="hljs-attr"><span class="hljs-attr">checkedItems</span></span>: _select.bindings.checkedItems, <span class="hljs-attr"><span class="hljs-attr">style</span></span>: _select.bindings.popupMenuWidth, <span class="hljs-attr"><span class="hljs-attr">onKeyDown</span></span>: _select.bindings.onKeyDown, <span class="hljs-attr"><span class="hljs-attr">theme</span></span>: _select.mods.theme, }].concat(_select.options.map(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">option</span></span></span><span class="hljs-function"> =&gt;</span></span> React.createElement( MenuItem, { <span class="hljs-attr"><span class="hljs-attr">onClick</span></span>: _select.bindings.onOptionCheck, <span class="hljs-attr"><span class="hljs-attr">theme</span></span>: _select.mods.theme, <span class="hljs-attr"><span class="hljs-attr">val</span></span>: option.value, }, option.content) )) ); }) );</code> </pre> <br><p> 当然，我们有自己的程序集。 如您所知，最快的操作是字符串连接。  <code>bem-xjst</code>引擎建立在其上，组件建立在其上。 块，元素和修饰符的文件位于文件夹中，而装配只需要按正确的顺序粘贴文件即可。 使用这种方法，您可以并行粘合JS，CSS和模板以及实体本身。 也就是说，如果您在一个项目中有四个组件，在笔记本电脑上有四个内核，并且组装一个组件技术需要一秒钟，那么构建项目将需要两秒钟。 在这里，应该更加清楚我们如何设法仅将必要的代码推入浏览器。 </p><br><p> 这一切对我们来说都是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">ENB</a> 。 我们仅在运行时收到了最后一棵用于标准化的树，并且由于组件之间的依赖性必须提早出现才能收集包，因此该功能由鲜为人知的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>deps.js</code></a>技术<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>deps.js</code></a> 。 它允许您在组件之间建立依赖关系图，然后收集器可以按所需顺序粘贴代码，从而绕过该图。 </p><br><p>  React版本16停止朝这个方向工作，服务器上模板的执行速度是<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">相等的</a> 。 在生产设备上，差异变得难以察觉。 </p><br><p> 节点： <strong>v8.4.0</strong> <br> 儿童： <strong>5K</strong> </p><br><table><thead><tr><th> 渲染器 </th><th> 平均时间 </th><th> 运算/秒 </th></tr></thead><tbody><tr><td> 预设v8.2.6 </td><td>  66.235毫秒 </td><td>  15 </td></tr><tr><td>  <strong>bem-xjst</strong> v8.8.4 </td><td>  71.326毫秒 </td><td>  14 </td></tr><tr><td>  <strong>反应</strong> v16.1.0 </td><td>  73.966毫秒 </td><td>  14 </td></tr></tbody></table><br><p> 使用下面的链接，您可以恢复该方法的历史记录： </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://ru.bem.info/forum/961/</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/awinogradov/react-bl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/awinogradov/xjst-ddsl</a> </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/awinogradov/ddsl-react</a> </li></ul><br><p> 我们还尝试了其他吗？ </p><br><ul><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/veged/bem-components-react-</a>在React中实现方法论的第一种方法 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/Yeti-or/bem-hazard-</a>一种基于BH模板引擎的类似方法。 顺便说一下，有了BH，您就可以在线玩； </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/dfilatov/bem-react-</a>通过BEMJSON创建组件 </li><li>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">https://github.com/rebem-React</a>世界中的BEM实用程序 </li></ul><br><p><img src="https://habrastorage.org/webt/uv/si/wt/uvsiwtsrexhffeuznrqhpxvtjva.png"></p><br><h2 id="motivaciya"> 动机 </h2><br><p> 在故事的中间，谈论促使我们前进的因素会很有用。 在一开始就值得这样做，但是-谁记得那只老眼睛作为礼物。 为什么我们需要所有这些？  BEM可以带来React无法做的事情？ 几乎每个人都提出的问题。 </p><br><h3 id="dekompoziciya"> 分解 </h3><br><p> 组件的功能逐年变得更加复杂，并且变体的数量增加。 这由<code>if</code>或<code>switch</code>构造表示，结果，代码库不可避免地增长，结果，组件的重量以及使用这种组件的项目增加了。  React组件逻辑的主要部分包含在<code>render()</code>方法中。 要更改组件的功能，必须重写大多数方法，这不可避免地导致高度专用组件的数量呈指数增长。 </p><br><p> 每个人都知道<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">material-ui</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">fabric-ui</a>和<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">react-bootstrap库</a> 。 通常，所有带有组件<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">的知名库</a>都具有相同的缺点。 假设您有多个项目，并且所有项目都使用相同的库。 您使用相同的组件，但是变化形式不同：这里有带有复选框的选择，没有，带有按钮的蓝色按钮，没有按钮的红色按钮。 该库带给您的CSS和JS的权重在所有项目中都相同。 但是为什么呢？ 组件的各种变体都嵌入在组件本身内部，并随组件一起提供，无论您是否想要。 对我们来说这是不可接受的。 </p><br><p>  Yandex还拥有自己的带有组件的库-Lego。 它适用于约200个服务。 我们是否要在Yandex.Health中以相同的价格使用Lego in Search？ 你知道答案。 </p><br><h3 id="krossplatformennaya-razrabotka"> 跨平台开发 </h3><br><p> 为了支持多个平台，大多数情况下，它们为每个平台创建一个单独的版本，或者为一个自适应版本创建一个。 </p><br><p> 各个版本的开发需要更多资源：平台越多，工作量就越大。 在不同版本中保持产品属性的同步状态将引起新的困难。 </p><br><p> 自适应版本的开发使代码变得复杂，增加了重量，降低了产品的速度，并且平台之间存在适当的差异。 </p><br><p> 我们是否希望我们的父母/朋友/同事/孩子在移动设备上使用台式机版本，从而降低互联网速度并降低生产率？ 你知道答案。 </p><br><h3 id="eksperimenty"> 实验 </h3><br><p> 如果您正在为大量受众开发项目，则需要确保每一个更改。  A / B实验是获得这种信心的一种方法。 </p><br><p> 组织实验代码的方式： </p><br><ul><li> 项目的分支和生产中服务实例的创建； </li><li> 代码库中的点条件。 </li></ul><br><p> 如果项目有大量冗长的实验，则分支代码库将导致大量成本。 有必要使每个分支机构都与实验保持最新：端口更正的错误和产品功能。 代码库分支使相交的实验多次复杂化。 </p><br><p> 点条件可以更灵活地工作，但会使代码库复杂化：实验条件可以影响项目的不同部分。 大量情况会通过增加浏览器的代码量来降低性能。 必须删除条件，使代码基本化或完全删除失败的实验。 </p><br><p> 在搜索中〜针对不同受众的100种在线实验，以各种组合形式出现。 您可以自己看到它。 请记住，也许您注意到了该功能，但是一周后它神奇地消失了。 我们是否要以维护500,000行的活动代码库的数百个分支为代价来测试产品理论，而这些分支每天约有60个开发人员进行更改？ 你知道答案。 </p><br><h3 id="globalnye-izmeneniya"> 全球变化 </h3><br><p> 例如，您可以创建从库继承自<code>Button</code>的<code>CustomButton</code>组件。 但是继承的<code>CustomButton</code>不适用于包含<code>Button</code>的库中的所有组件。 一个库可能具有一个由<code>Input</code>和<code>Button</code>构建的<code>Search</code>组件。 在这种情况下，继承的<code>CustomButton</code>不会出现在<code>Search</code>组件内。 我们是否要手动<code>Button</code>使用<code>Button</code>的整个代码库？ </p><br><p><img src="https://habrastorage.org/webt/po/7j/fg/po7jfgnxrawurvtkoi-3ch2wneu.jpeg"></p><br><h2 id="dolgaya-doroga-v-kompoziciyu"> 漫长的创作之路 </h2><br><p> 我们决定改变策略。 在以前的方法中，他们以Yandex技术为基础，并试图让React在此基础上工作。 新的策略则相反。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">bem-react-core</a>项目就是这样产生的。 </p><br><blockquote> 别说了 为什么要做出反应？ </blockquote><p> 我们在其中看到了摆脱HTML显式初始呈现的机会，并在稍后的运行时从手动支持JS组件的状态中摆脱了机会-实际上，将BEMHMTL模板和JS组件合并为一种技术成为可能。 </p><br><h3 id="v100httpsgithubcombembem-reacttreev100">  <a href="">v1.0.0</a> </h3><br><p> 最初，我们计划将<code>bem-xjst</code>所有最佳实践和属性<code>bem-xjst</code>到React之上的库中。 首先引起您注意的是签名，或者，如果您愿意，还可以描述组件的语法。 </p><br><p>  <em>你做了什么，有JSX！</em> </p><br><p> 第一个版本是在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">继承</a>的基础上构建的-一个有助于实现类和继承的库。 就像您中有些人记得的那样，当时JavaScript的原型原型没有类，也没有<code>super</code> 。 通常，它们仍然不存在，更确切地说，这些不是首先要想到的类。  <code>inherit</code>完成了ES2015标准中的类现在可以做的所有事情，以及所谓的黑魔法：多重继承和原型合并而不是重建链，这对性能产生了积极影响。 如果您认为像<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">在Node.js中继承</a>那样看起来很有意义，那么您不会误会，但它们的工作原理有所不同。 </p><br><p> 以下是模板<code>bem-react-core@v1.0.0</code>的语法<code>bem-react-core@v1.0.0</code> 。 </p><br><p>  <strong>App-Header.js</strong> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { decl } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'bem-react-core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> decl({ <span class="hljs-attr"><span class="hljs-attr">block</span></span>: <span class="hljs-string"><span class="hljs-string">'App'</span></span>, <span class="hljs-attr"><span class="hljs-attr">elem</span></span>: <span class="hljs-string"><span class="hljs-string">'Header'</span></span>, <span class="hljs-attr"><span class="hljs-attr">attrs</span></span>: { <span class="hljs-attr"><span class="hljs-attr">role</span></span>: <span class="hljs-string"><span class="hljs-string">'heading'</span></span> }, content() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">' '</span></span>; } });</code> </pre> <br><p>  <strong>App-Header@desktop.js</strong> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { decl } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'bem-react-core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> decl({ <span class="hljs-attr"><span class="hljs-attr">block</span></span>: <span class="hljs-string"><span class="hljs-string">'App'</span></span>, <span class="hljs-attr"><span class="hljs-attr">elem</span></span>: <span class="hljs-string"><span class="hljs-string">'Header'</span></span>, <span class="hljs-attr"><span class="hljs-attr">tag</span></span>: <span class="hljs-string"><span class="hljs-string">'h1'</span></span>, attrs() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { ...this.__base(...arguments), <span class="hljs-string"><span class="hljs-string">'aria-level'</span></span>: <span class="hljs-number"><span class="hljs-number">1</span></span> }, }, content() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">` </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.__base(...</span></span><span class="hljs-built_in"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-built_in">arguments</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">     h1`</span></span>; } });</code> </pre> <br><p>  <strong>App-Header@touch.js</strong> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { decl } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'bem-react-core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-keyword"><span class="hljs-keyword">default</span></span> decl({ <span class="hljs-attr"><span class="hljs-attr">block</span></span>: <span class="hljs-string"><span class="hljs-string">'App'</span></span>, <span class="hljs-attr"><span class="hljs-attr">elem</span></span>: <span class="hljs-string"><span class="hljs-string">'Header'</span></span>, <span class="hljs-attr"><span class="hljs-attr">tag</span></span>: <span class="hljs-string"><span class="hljs-string">'h2'</span></span>, content() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">` </span><span class="hljs-subst"><span class="hljs-string"><span class="hljs-subst">${</span></span><span class="hljs-keyword"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-keyword">this</span></span></span></span><span class="hljs-string"><span class="hljs-subst">.__base(...</span></span><span class="hljs-built_in"><span class="hljs-string"><span class="hljs-subst"><span class="hljs-built_in">arguments</span></span></span></span><span class="hljs-string"><span class="hljs-subst">)}</span></span></span><span class="hljs-string">  `</span></span>; } });</code> </pre> <br><p>  <strong>index.js</strong> </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ReactDomServer <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-dom/server'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> AppHeader <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'b:App e:Header'</span></span>; ReactDomServer.renderToStaticMarkup(<span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">AppHeader</span></span></span></span><span class="xml"><span class="hljs-tag"> /&gt;</span></span></span><span class="xml">);</span></span></code> </pre> <br><p>  <strong>output@desktop.html</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h1</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"App-Header"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">role</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"heading"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">aria-level</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"1"</span></span></span><span class="hljs-tag">&gt;</span></span>A       h1<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h2</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  <strong>output@touch.html</strong> </p><br><pre> <code class="html hljs xml"><span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h2</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">class</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"App-Header"</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">role</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"heading"</span></span></span><span class="hljs-tag">&gt;</span></span>   <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h2</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre> <br><p>  <em>可以在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">此处</a>找到用于更复杂组件的设备模板。</em> </p><br><p> 由于类是对象，并且使用JavaScript处理对象最方便，因此语法是合适的。  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">语法</a>后来<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">迁移</a>到其主脑<code>bem-xjst</code> 。 </p><br><p> 该库是对象声明的全局存储库-执行<code>decl</code>函数的结果，实体的一部分：块，元素或修饰符。  BEM提供了独特的命名机制，因此适合在保管库中创建密钥。 所得的React组件在其使用地点被粘上。 诀窍是在导入模块时可以找到<code>decl</code> 。 这样就可以使用简单的导入列表来指示每个特定位置需要组件的哪些部分。 但是请记住：组件很复杂，有很多部分，导入列表很长，开发人员很懒。 </p><br><h4 id="magiya-importov"> 导入魔术 </h4><br><p> 如您所见，在代码示例中，有<code>import AppHeader from 'b:App e:Header'</code>行<code>import AppHeader from 'b:App e:Header'</code> 。 </p><br><p>  <em>您违反了标准！</em>  <em>不可能！</em>  <em>只是行不通！</em> </p><br><p> 首先，导入标准并未以“必须在导入行中有通往实际模块的路径”这一精神进行操作。 其次，是使用Babel转换的语法糖。 第三， <code>import txt from 'raw-loader!./file.txt';</code> webpack <code>import txt from 'raw-loader!./file.txt';</code>奇怪的<code>import txt from 'raw-loader!./file.txt';</code>标点构造<code>import txt from 'raw-loader!./file.txt';</code> 由于某种原因，他们没有打扰任何人。 <br> 因此，我们的代码块存在于两个平台中： <code>desktop</code> ， <code>touch</code> 。 </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> Hello <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'b:Hello'</span></span>; <span class="hljs-comment"><span class="hljs-comment">//     : var Hello = [ require('path/to/desktop/Hello/Hello.js'), require('path/to/touch/Hello/Hello.js') ][0].applyDecls();</span></span></code> </pre> <br><p>          <code>Hello</code> ,     <code>applyDecls</code> ,          <code>inherit</code>   ,       React-. </p><br><p>   Babel,   ,  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> .    webpack,       , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> . </p><br><p>  ,   : </p><br><ul><li> ,   ,         ; </li><li>     ; </li><li>  React-    . </li></ul><br><p>    : </p><br><ul><li>   TypeScript/Flow; </li><li>    React- ; </li><li> -         ; </li><li>      . </li></ul><br><h3 id="v200httpsgithubcombembem-reacttreev200"> <a href="">v2.0.0</a> </h3><br><p>     <code>bem-react-core@v1.0.0</code>  ,       . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Elem } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'bem-react-core'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Button } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'../Button'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">export</span></span> <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">AppHeader</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Elem</span></span></span><span class="hljs-class"> </span></span>{ block = <span class="hljs-string"><span class="hljs-string">'App'</span></span>; elem = <span class="hljs-string"><span class="hljs-string">'Header'</span></span>; tag() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">'h2'</span></span>; } content() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> ( <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml"> </span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">Button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); } }</code> </pre> <br><p>     ,     .    ,   ,      TypeScript/Flow.   ,     <code>inherit</code>  «» ,     ,            . </p><br><p>   : <br> —         webpack    Babel; <br> —      ; <br> —       ,    . </p><br><p>        <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">HOC</a> ,             . </p><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> React <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> * <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> ReactDOM <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'react-dom'</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> { Block, Elem, withMods } <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> <span class="hljs-string"><span class="hljs-string">'bem-react-core'</span></span>; interface IButtonProps { <span class="hljs-attr"><span class="hljs-attr">children</span></span>: string; } interface IModsProps extends IButtonProps { <span class="hljs-attr"><span class="hljs-attr">type</span></span>: <span class="hljs-string"><span class="hljs-string">'link'</span></span> | <span class="hljs-string"><span class="hljs-string">'button'</span></span>; } <span class="hljs-comment"><span class="hljs-comment">//   Text class Text extends Elem { block = 'Button'; elem = 'Text'; tag() { return 'span'; } } //   Button class Button&lt;T extends IModsProps&gt; extends Block&lt;T&gt; { block = 'Button'; tag() { return 'button'; } mods() { return { type: this.props.type }; } content() { return ( &lt;Text&gt;{this.props.children}&lt;/Text&gt; ); } } //    Button,    type   link class ButtonLink extends Button&lt;IModsProps&gt; { static mod = ({ type }: any) =&gt; type === 'link'; tag() { return 'a'; } mods() { return { type: this.props.type }; } attrs() { return { href: 'www.yandex.ru' }; } } //   Button  ButtonLink const ButtonView = withMods(Button, ButtonLink); ReactDOM.render( &lt;React.Fragment&gt; &lt;ButtonView type='button'&gt;Click me&lt;/ButtonView&gt; &lt;ButtonView type='link'&gt;Click me&lt;/ButtonView&gt; &lt;/React.Fragment&gt;, document.getElementById('root') );</span></span></code> </pre> <br><p>              ,     . </p><br><p> <code>withMods</code>       ,   (),      .   ,     , withMods        ,      .      .       , ,     ,   ( )   .               .       ,   ,    —    ,    . </p><br><p> ,   : </p><br><ul><li>    . ,        .   ,    TS.        ,      .    ES5 TS   super   ,         . , TS     ,    . </li><li>    . TS  ES6  Babel  ES5.      ,    npm-    .  ,          Babel. </li></ul><br><p>  : </p><br><ul><li>       ,   . ,     . :    DOM-.     HOC,      .   withMods       . </li><li>   (, , )       .             <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">SFC</a> . </li><li>  CSS-.  CSS-   JS-     .      ,   ,          . </li></ul><br><p>      v2. </p><br><h2 id="manifest">  </h2><br><p> ,    .   .  ,    ,      1  2.      <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> . </p><br><p>   —    .   CSS-     HOC,        —  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=">dependency injection</a> . </p><br><p>       React: </p><br><ul><li>   CSS-. </li><li>     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="></a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="> </a> (, ); </li></ul><br><p>         .         .        <code>React.ComponentType</code>     -.         HOC     compose    . </p><br><p>             . </p><br><p>        dependency injection,     <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u="><code>React.ContextAPI</code></a>    .             ,        ,        .        ,      .   DI —  HOC,     .         .     ,  ,         . </p><br><p> ,    ,         .   ,      ,    4 ,    <code>1.5Kb</code> . </p><br><p>     . 感谢那些读到最后的人。     ,     React  . . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN438598/">https://habr.com/ru/post/zh-CN438598/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN438588/index.html">网站的自定义googleTranslate小部件</a></li>
<li><a href="../zh-CN438590/index.html">雷霆天堂或为什么不应该使用FlylinkDC ++</a></li>
<li><a href="../zh-CN438592/index.html">选择阅读器时要寻找的内容-我们正在谈论外形尺寸和显示</a></li>
<li><a href="../zh-CN438594/index.html">工作场所和4k @ 60Hz</a></li>
<li><a href="../zh-CN438596/index.html">页面重新加载后保存用户数据</a></li>
<li><a href="../zh-CN438600/index.html">SciPy，在MATLAB中输入和输出</a></li>
<li><a href="../zh-CN438602/index.html">我们反汇编寻呼机消息POCSAG的协议，第1部分</a></li>
<li><a href="../zh-CN438604/index.html">一堆Nginx + PHP-FPM中的Bitrix，设置了CNC，以及通过nginx反馈的复合缓存。 修改后的配置</a></li>
<li><a href="../zh-CN438606/index.html">优雅降级。 报告Yandex.Taxi</a></li>
<li><a href="../zh-CN438610/index.html">响应式Figma模板：为iOS移动导航制作灵活的设计组件</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>