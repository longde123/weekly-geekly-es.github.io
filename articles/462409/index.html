<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßëüèº‚Äçü§ù‚Äçüßëüèª üë©üèª ‚úçüèΩ Biblioteca generadora de c√≥digo ensamblador para microcontroladores AVR. Parte 1 üï∞Ô∏è üéå üò™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Parte 2. Comenzando ‚Üí 
 Biblioteca de generador de c√≥digo ensamblador para microcontroladores AVR 
 Parte 1. Primer conocido 


 Buenas tardes, querid...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Biblioteca generadora de c√≥digo ensamblador para microcontroladores AVR. Parte 1</h1><div class="post__body post__body_full">
      <div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/462409/"><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=es&amp;u=">Parte 2. Comenzando ‚Üí</a> </p><br><h1>  Biblioteca de generador de c√≥digo ensamblador para microcontroladores AVR </h1><br><h2>  Parte 1. Primer conocido </h2><br><p>  Buenas tardes, queridos Khabrovites.  Quiero llamar su atenci√≥n sobre el pr√≥ximo proyecto (de los muchos disponibles) para programar los populares microcontroladores de la serie AVR. </p><br><p>  Ser√≠a posible gastar una gran cantidad de texto para explicar por qu√© esto era necesario, pero en su lugar, solo mire ejemplos de c√≥mo difiere de otras soluciones.  Y todas las explicaciones y comparaciones con los sistemas de programaci√≥n existentes estar√°n, seg√∫n sea necesario, en el proceso de an√°lisis de ejemplos.  La biblioteca est√° ahora en proceso de finalizaci√≥n, por lo que la implementaci√≥n de algunas funciones puede no parecer √≥ptima.  Adem√°s, se supone que algunas de las tareas que se asignan al programador en esta versi√≥n deben optimizarse o automatizarse a√∫n m√°s. </p><a name="habracut"></a><br><p>  Entonces comencemos.  Quiero aclarar de inmediato que el material presentado no debe considerarse en modo alguno como una descripci√≥n completa, sino solo como una demostraci√≥n de algunas de las caracter√≠sticas de la biblioteca desarrollada para ayudar a comprender cu√°n interesante puede ser este enfoque para los lectores. </p><br><p>  No nos desviaremos de la pr√°ctica establecida y comenzaremos con un ejemplo cl√°sico, una especie de "Hola mundo" para los microcontroladores.  Es decir, parpadeamos el LED conectado a una de las patas del procesador.  Abramos VisualStudio de Microsoft (cualquier versi√≥n servir√°) y creemos una aplicaci√≥n de consola para C #.  Para aquellos que no est√°n al tanto, Community Edition, suficiente para el trabajo, es absolutamente gratis. </p><br><p>  En realidad, el texto en s√≠ es el siguiente: </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo fuente Ejemplo 1</b> <div class="spoiler_text"><pre><code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> NanoRTOSLib; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">ConsoleApp</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); m.PortB[<span class="hljs-number"><span class="hljs-number">0</span></span>].Mode = ePinMode.OUT; m.PortB.Activate(); m.LOOP(m.TempL, (r, l) =&gt; m.GO(l), (r) =&gt; { m.PortB[<span class="hljs-number"><span class="hljs-number">0</span></span>].Toggle();}); Console.WriteLine(AVRASM.Text(m)); } } }</code> </pre> </div></div><br><p>  Por supuesto, para que todo funcione y necesites la biblioteca que yo represento. <br>  Despu√©s de compilar y ejecutar el programa, en la salida de la consola veremos el siguiente resultado de este programa. </p><br><div class="spoiler">  <b class="spoiler_title">Resultado de la compilaci√≥n del ejemplo 1</b> <div class="spoiler_text"><pre> <code class="dos hljs">#include ‚Äúcommon.inc‚Äù RESET: ldi r16, high(RAMEND) out SPH,r16 ldi r16, low(RAMEND) out SPL,r16 outi DDRB,<span class="hljs-number"><span class="hljs-number">0</span></span>x1 L0000: <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> TempL,PORTB ldi TempH,<span class="hljs-number"><span class="hljs-number">1</span></span> eor TempL,TempH out PORTB,TempL xjmp L0000 .DSEG</code> </pre> </div></div><br><p>  Si copia el resultado a cualquier entorno que pueda funcionar con el ensamblador AVR y conecte la <i>biblioteca de</i> macros <i>Common.inc</i> (la biblioteca de macros tambi√©n es uno de los elementos constitutivos del sistema de programaci√≥n presentado y funciona junto con <i>NanoRTOSLib</i> ), entonces este programa puede compilarse y verificarse en un emulador o un chip real y Aseg√∫rate de que todo funcione. </p><br><p>  Considere el c√≥digo fuente del programa con m√°s detalle.  En primer lugar, asignamos a la variable m el tipo de cristal utilizado.  A continuaci√≥n, configure el modo de salida digital para el bit cero del puerto B del cristal y active el puerto.  La siguiente l√≠nea parece un poco extra√±a, pero su significado es bastante simple.  En √©l, decimos que queremos organizar un bucle infinito, en cuyo cuerpo cambiamos el valor del bit cero del puerto B al opuesto.  La √∫ltima l√≠nea del programa realmente visualiza el resultado de todo lo escrito previamente en forma de c√≥digo ensamblador.  Todo es extremadamente simple y compacto.  Y el resultado pr√°cticamente no es diferente de lo que se podr√≠a escribir en ensamblador.  Solo puede haber dos preguntas para el c√≥digo de salida: la primera: ¬øpor qu√© inicializar la pila si a√∫n no la usamos, y qu√© <i>tipo de xjmp</i> ?  La respuesta a la primera pregunta y, al mismo tiempo, una explicaci√≥n de por qu√© se genera el ensamblador, en lugar de un HEX preparado, ser√° la siguiente: el resultado en forma de ensamblador le permite analizar y optimizar a√∫n m√°s el programa, permitiendo al programador seleccionar y modificar fragmentos de c√≥digo que no le gustan.  Y la inicializaci√≥n de la pila se dej√≥ al menos por las razones por las que sin usar la pila no se pueden encontrar muchos programas.  Sin embargo, si no le gusta, no dude en limpiarlo.  La salida al ensamblador es para este prop√≥sito.  En cuanto a <i>xjmp</i> , este es un ejemplo del uso de macros para aumentar la legibilidad del ensamblador de salida.  Espec√≠ficamente, <i>xjmp</i> es un reemplazo para <i>jmp</i> y <i>rjmp</i> con la sustituci√≥n correcta dependiendo de la duraci√≥n de la transici√≥n. </p><br><p>  Si llena el programa con un chip, por supuesto, no veremos el parpadeo del diodo, a pesar de que el estado del pin cambia.  Simplemente sucede demasiado r√°pido para poder verlo a trav√©s de los ojos.  Por lo tanto, consideramos el siguiente programa, en el que seguimos parpadeando con un diodo, pero para que se pueda ver.  Por ejemplo, un retraso de 0,5 segundos es bastante adecuado: ni demasiado r√°pido ni demasiado lento.  Ser√≠a posible hacer muchos bucles anidados con NOP para formar un retraso, pero omitiremos este paso ya que no agregaremos nada a la descripci√≥n de las capacidades de la biblioteca e inmediatamente aprovecharemos la oportunidad de usar el hardware disponible.  Cambiamos nuestra aplicaci√≥n de la siguiente manera. </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo fuente Ejemplo 2</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">ConsoleApp</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); m.PortB[<span class="hljs-number"><span class="hljs-number">0</span></span>].Mode = ePinMode.OUT; m.PortB.Activate(); m.WDT.Clock = eWDTClock.WDT500ms; m.WDT.OnTimeout = () =&gt; m.PortB[<span class="hljs-number"><span class="hljs-number">0</span></span>].Toggle(); m.WDT.Activate(); m.EnableInterrupt(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.newLabel(); m.GO(loop); Console.WriteLine(AVRASM.Text(m)); } } }</code> </pre> </div></div><br><p>  Obviamente, el programa es similar al anterior, por lo que solo consideraremos lo que ha cambiado.  Primero, en este ejemplo, utilizamos WDT (temporizador de vigilancia).  Para trabajar con grandes retrasos que no requieren una precisi√≥n extrema, esta es la mejor opci√≥n.  Todo lo que se necesita para usarlo es establecer la frecuencia requerida configurando el divisor a trav√©s de la propiedad WDT.Clock y determinar las acciones que deben realizarse en el momento en que se desencadena el evento, definiendo el c√≥digo a trav√©s de la propiedad WDT.OnTimeout.  Como necesitamos interrupciones para trabajar, deben habilitarse con el comando EnableInterrupt.  Pero el ciclo principal puede ser reemplazado por un maniqu√≠.  En √©l, todav√≠a no planeamos hacer nada.  Por lo tanto, declararemos y estableceremos una etiqueta y haremos una transici√≥n incondicional para organizar un ciclo vac√≠o.  Si te gusta LOOP m√°s, por favor.  El resultado de esto no cambiar√°. <br>  Bueno, en la final, veamos el c√≥digo resultante. </p><br><div class="spoiler">  <b class="spoiler_title">Resultado de la compilaci√≥n del ejemplo 2</b> <div class="spoiler_text"><pre> <code class="dos hljs">#include ‚Äúcommon.inc‚Äù jmp RESET reti ; IRQ0 Handler nop reti ;IRQ1 Handler nop reti ;PC_INT0 Handler nop reti ;PC_INT1 Handler nop reti ;PC_INT2 Handler nop jmp WDT ;Watchdog Timer Handler RESET: ldi r16, high(RAMEND) out SPH,r16 ldi r16, low(RAMEND) out SPL,r16 outi DDRB,<span class="hljs-number"><span class="hljs-number">0</span></span>x1 ldi TempL, (<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;WDCE) | (<span class="hljs-number"><span class="hljs-number">1</span></span>&lt;&lt;WDE) sts WDTCSR,TempL ldi TempL, <span class="hljs-number"><span class="hljs-number">0</span></span>x42 sts WDTCSR,TempL sei L0000: xjmp L0000 WDT: push r17 push r16 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> r16,SREG push r16 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> TempL,PORTB ldi TempH,<span class="hljs-number"><span class="hljs-number">1</span></span> eor TempL,TempH out PORTB,TempL pop r16 out SREG,r16 pop r16 pop r17 reti .DSEG</code> </pre> </div></div><br><p>  Aquellos que est√©n familiarizados con este procesador sin duda tendr√°n una pregunta sobre d√≥nde se han ido varios vectores de interrupci√≥n m√°s.  Aqu√≠ usamos la siguiente l√≥gica, si el c√≥digo no se usa, el c√≥digo no es necesario.  Por lo tanto, la tabla de interrupci√≥n termina en el √∫ltimo vector utilizado. <br>  A pesar del hecho de que el programa hace frente a la tarea perfectamente, al m√°s exigente puede no gustarle el hecho de que el conjunto de posibles retrasos es limitado y el paso es demasiado dif√≠cil.  Por lo tanto, consideraremos otra forma y, al mismo tiempo, veremos c√≥mo se organiza el trabajo con temporizadores en la biblioteca.  En el cristal Mega328, que se toma como muestra, hay hasta 3 de ellos.  2 de 8 bits y uno de 16 bits.  Los arquitectos se esforzaron mucho por invertir la mayor cantidad de caracter√≠sticas posibles en estos temporizadores, por lo tanto, su entorno es bastante voluminoso. </p><br><p>  Primero, calculamos qu√© contador debe usarse para nuestro retraso de 0.5 segundos.  Si tomamos la frecuencia del reloj de cristal de 16 MHz, incluso con el divisor perif√©rico m√°ximo es imposible mantenerlo dentro del contador de 8 bits.  Por lo tanto, no complicaremos y utilizaremos el √∫nico contador Timer1 de 16 bits disponible para nosotros. </p><br><p>  Como resultado, el programa toma la siguiente forma: </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo fuente Ejemplo 3</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> NanoRTOSLib; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">ConsoleApp</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> {<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); m.FCLK = <span class="hljs-number"><span class="hljs-number">16000000</span></span>; m.CKDIV8 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bit1 = m.PortB[<span class="hljs-number"><span class="hljs-number">0</span></span>]; bit1.Mode = ePinMode.OUT; m.PortB.Activate(); m.Timer1.Mode = eWaveFormMode.CTC_OCRA; m.Timer1.Clock = eTimerClockSource.CLK256; m.Timer1.OCRA = (<span class="hljs-keyword"><span class="hljs-keyword">ushort</span></span>)((<span class="hljs-number"><span class="hljs-number">0.5</span></span> * m.FCLK) / <span class="hljs-number"><span class="hljs-number">256</span></span>); m.Timer1.OnCompareA = () =&gt; bit1.Toggle(); m.Timer1.Activate(); m.EnableInterrupt(); m.LOOP(m.TempH, (r, l) =&gt; m.GO(l), (r) =&gt; { }); Console.WriteLine(AVRASM.Text(m)); } } }</code> </pre> </div></div><br><p>  Como utilizamos el generador principal como fuente de reloj para nuestro temporizador, para el c√°lculo correcto del retraso, debe especificar la frecuencia del reloj del procesador, la configuraci√≥n del divisor y el fusible del reloj perif√©rico.  El texto principal del programa est√° configurando el temporizador en el modo deseado.  Aqu√≠, se elige deliberadamente un deliberador de 256 y no un m√°ximo para la sincronizaci√≥n, porque cuando selecciona un divisor de 1024 para la frecuencia de reloj requerida de 500 ms, que queremos obtener, se obtiene un n√∫mero fraccionario. </p><br><p>  El c√≥digo de ensamblador resultante de nuestro programa se ver√° as√≠: </p><br><div class="spoiler">  <b class="spoiler_title">Resultado de la compilaci√≥n del ejemplo 3</b> <div class="spoiler_text"><pre> <code class="dos hljs">#include ‚Äúcommon.inc‚Äù jmp RESET reti ; IRQ0 Handler nop reti ;IRQ1 Handler nop reti ;PC_INT0 Handler nop reti ;PC_INT1 Handler nop reti ;PC_INT2 Handler nop reti ;Watchdog Timer Handler nop reti ;Timer2 Compare A Handler nop reti ;Timer2 Compare B Handler nop reti ;Timer2 Overflow Handler nop reti ;Timer1 Capture Handler nop jmp TIM1_COMPA ;Timer1 Compare A Handler RESET: ldi r16, high(RAMEND) out SPH,r16 ldi r16, low(RAMEND) out SPL,r16 outi DDRB,<span class="hljs-number"><span class="hljs-number">0</span></span>x1 outiw OCR1A,<span class="hljs-number"><span class="hljs-number">0</span></span>x7A12 outi TCCR1A,<span class="hljs-number"><span class="hljs-number">0</span></span> outi TCCR1B,<span class="hljs-number"><span class="hljs-number">0</span></span>xC outi TCCR1C,<span class="hljs-number"><span class="hljs-number">0</span></span>x0 outi TIMSK1,<span class="hljs-number"><span class="hljs-number">0</span></span>x2 outi DDRB,<span class="hljs-number"><span class="hljs-number">0</span></span>x1 sei L0000: xjmp L0000 TIM1_COMPA: push r17 push r16 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> r16,SREG push r16 <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> TempL,PORTB ldi TempH,<span class="hljs-number"><span class="hljs-number">1</span></span> eor TempL,TempH out PORTB,TempL pop r16 out SREG,r16 pop r16 pop r17 reti .DSEG</code> </pre> </div></div><br><p>  Parece que ya no hay nada m√°s que comentar.  Inicializamos los dispositivos, configuramos interrupciones y disfrutamos del programa. </p><br><p>  Trabajar a trav√©s de interrupciones es la forma m√°s f√°cil de crear programas para trabajar en tiempo real.  Desafortunadamente, no siempre es posible cambiar entre tareas paralelas utilizando solo controladores de interrupciones para realizar estas tareas.  La restricci√≥n es la prohibici√≥n del manejo de interrupciones anidadas, lo que lleva al hecho de que hasta que el procesador salga, el procesador no responde a todas las otras interrupciones, lo que puede conducir a la p√©rdida de eventos si el procesador funciona durante demasiado tiempo. </p><br><p>  Una soluci√≥n es separar el c√≥digo de registro del evento y su procesamiento.  El n√∫cleo de procesamiento de subprocesos m√∫ltiples en paralelo de la biblioteca est√° organizado de tal manera que cuando ocurre un evento, el controlador de interrupciones solo registra el evento dado y, si es necesario, realiza las operaciones m√≠nimas de captura de datos necesarias, y todo el procesamiento se realiza en la secuencia principal.  El kernel verifica secuencialmente la presencia de indicadores no procesados ‚Äã‚Äãy, si se encuentra, contin√∫a con la tarea correspondiente. </p><br><p>  El uso de este enfoque simplifica el dise√±o de sistemas con varias tareas asincr√≥nicas, lo que le permite considerar cada una de ellas de forma aislada, sin centrarse en los problemas de conmutar recursos entre tareas.  Como ejemplo, considere la implementaci√≥n de dos tareas independientes, cada una de las cuales cambia su salida con un cierto retraso. </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo fuente Ejemplo 4</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> NanoRTOSLib; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">ConsoleApp</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); m.FCLK = <span class="hljs-number"><span class="hljs-number">16000000</span></span>; m.CKDIV8 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; m.PortB.Direction(<span class="hljs-number"><span class="hljs-number">0x07</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bit1 = m.PortB[<span class="hljs-number"><span class="hljs-number">1</span></span>]; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bit2 = m.PortB[<span class="hljs-number"><span class="hljs-number">2</span></span>]; m.PortB.Activate(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tasks = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Parallel(m, <span class="hljs-number"><span class="hljs-number">4</span></span>); tasks.Heap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticHeap(tasks, <span class="hljs-number"><span class="hljs-number">64</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t1 = tasks.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); bit1.Toggle(); tsk.Delay(<span class="hljs-number"><span class="hljs-number">32</span></span>); tsk.TaskContinue(loop); },<span class="hljs-string"><span class="hljs-string">"Task1"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> t2 = tasks.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); bit2.Toggle(); tsk.Delay(<span class="hljs-number"><span class="hljs-number">48</span></span>); tsk.TaskContinue(loop); }, <span class="hljs-string"><span class="hljs-string">"Task2"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ca = tasks.ContinuousActivate(tasks.AlwaysOn, t1); tasks.ActivateNext(ca, tasks.AlwaysOn, t2); ca.Dispose(); m.EnableInterrupt(); tasks.Loop(); Console.WriteLine(AVRASM.Text(m)); } } }</code> </pre> </div></div><br><p>  En esta tarea, configuramos las salidas cero y primera del puerto B a salida y cambiamos el valor de 0 a 1 y viceversa con un per√≠odo de 32 ms para cero y 48 ms para la primera salida.  Una tarea separada es responsable de administrar cada puerto.  Lo primero a tener en cuenta es la definici√≥n de una instancia de Paralelo.  Esta clase es el n√∫cleo de la gesti√≥n de tareas.  En su constructor, determinamos el n√∫mero m√°ximo permitido de subprocesos que se ejecutan simult√°neamente.  La siguiente es una asignaci√≥n de memoria para almacenar flujos de datos.  La clase StaticHeap utilizada en el ejemplo asigna un n√∫mero fijo de bytes para cada flujo.  Para resolver nuestro problema, esto es aceptable, y el uso de una asignaci√≥n de memoria fija en comparaci√≥n con la din√°mica simplifica los algoritmos y hace que el c√≥digo sea m√°s compacto y r√°pido.  M√°s adelante en el c√≥digo, describimos un conjunto de tareas que est√°n dise√±adas para ejecutarse bajo el control del n√∫cleo.  Debe prestar atenci√≥n a la funci√≥n as√≠ncrona Delay, que usamos para formar un retraso.  Su peculiaridad es que cuando se llama a esta funci√≥n, el retraso requerido se establece en la configuraci√≥n de flujo y el control se transfiere al n√∫cleo.  Una vez transcurrido el intervalo establecido, el n√∫cleo devuelve el control a la tarea desde el comando que sigue al comando Delay.  Otra caracter√≠stica de la tarea es programar el comportamiento del flujo de la tarea al finalizar en el √∫ltimo comando de la tarea.  En nuestro caso, ambas tareas est√°n configuradas para ejecutarse en un bucle infinito con el control regresando al n√∫cleo al final de cada ciclo.  Si es necesario, completar una tarea puede liberar el hilo o pasarlo para realizar otra tarea. </p><br><p>  La raz√≥n para invocar la tarea es activar la se√±al asignada al flujo de la tarea.  La se√±al se puede activar tanto mediante programaci√≥n como por hardware mediante interrupciones desde dispositivos perif√©ricos.  Una llamada de tarea restablece la se√±al.  Una excepci√≥n es la se√±al predefinida AlwaysOn, que siempre est√° en estado activo.  Esto hace posible crear tareas que recibir√°n control en cada ciclo de sondeo.  La funci√≥n LOOP es necesaria para invocar el ciclo de ejecuci√≥n principal.  Desafortunadamente, el tama√±o del c√≥digo de salida cuando se usa Parallel ya se est√° volviendo significativamente m√°s grande que en los ejemplos anteriores (aproximadamente 600 comandos) y no se puede citar por completo en el art√≠culo. </p><br><p>  Y para dulce, algo m√°s parecido a un proyecto en vivo, a saber, un term√≥metro digital.  Todo es como siempre simple.  Un sensor digital con una interfaz SPI, un indicador de 7 segmentos y 4 d√≠gitos y varios hilos de procesamiento para mantener las cosas frescas.  En uno, manejamos un ciclo para indicaci√≥n din√°mica, en otro, eventos que desencadenan un ciclo de lectura de temperatura, en el tercero leemos los valores recibidos del sensor y lo convertimos de un c√≥digo binario a BCD y luego en un c√≥digo de segmento para un b√∫fer de indicaci√≥n din√°mica. </p><br><p>  El programa en s√≠ es el siguiente. </p><br><div class="spoiler">  <b class="spoiler_title">C√≥digo fuente Ejemplo 5</b> <div class="spoiler_text"><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> NanoRTOSLib; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">ConsoleApp</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">string</span></span></span></span><span class="hljs-function"><span class="hljs-params">[] args</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> m = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Mega328(); m.FCLK = <span class="hljs-number"><span class="hljs-number">16000000</span></span>; m.CKDIV8 = <span class="hljs-literal"><span class="hljs-literal">false</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> led7s = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Led_7(); led7s.SegPort = m.PortC; led7s.Activate(); m.PortD.Direction(<span class="hljs-number"><span class="hljs-number">0xFF</span></span>); m.PortD.Activate(); m.PortB[<span class="hljs-number"><span class="hljs-number">0</span></span>].Mode = ePinMode.OUT; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tc77 = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> TC77(); tc77.CS = m.PortB[<span class="hljs-number"><span class="hljs-number">0</span></span>]; tc77.Port = m.SPI; m.Timer0.Clock = eTimerClockSource.CLK64; m.Timer0.Mode = eWaveFormMode.Normal; <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> reader = m.DREG(<span class="hljs-string"><span class="hljs-string">"Temperature"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bcdRes = m.DREG(<span class="hljs-string"><span class="hljs-string">"digits"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tmp = m.BYTE(); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bcd = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> BCD(reader, bcdRes); m.subroutines.Add(bcd); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> os = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> Parallel(m, <span class="hljs-number"><span class="hljs-number">4</span></span>); os.Heap = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> StaticHeap(os, <span class="hljs-number"><span class="hljs-number">64</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tmrSig = os.AddSignal(m.Timer0.OVF_Handler); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> spiSig = os.AddSignal(m.SPI.Handler, () =&gt; { m.SPI.Read(m.TempL); m.TempL.MStore(tmp); }); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> actuator = os.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); tc77.ReadTemperatureAsync(); tsk.Delay(<span class="hljs-number"><span class="hljs-number">16</span></span>); tsk.TaskContinue(loop); }, <span class="hljs-string"><span class="hljs-string">"actuator"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> treader = os.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); tc77.ReadTemperatureCallback(os, reader, tmp); reader &gt;&gt;= <span class="hljs-number"><span class="hljs-number">7</span></span>; m.CALL(bcd); tsk.TaskContinue(loop); }, <span class="hljs-string"><span class="hljs-string">"reader"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> display = os.CreateTask((tsk) =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> loop = AVRASM.NewLabel(); m.PortD.Write(<span class="hljs-number"><span class="hljs-number">0xFE</span></span>); m.TempQL.Load(bcdRes.Low); m.TempQL &amp;= <span class="hljs-number"><span class="hljs-number">0x0F</span></span>; led7s.Show(m.TempQL); os.AWAIT(); m.PortD.Write(<span class="hljs-number"><span class="hljs-number">0xFD</span></span>); m.TempQL.Load(bcdRes.Low); m.TempQL &gt;&gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>; led7s.Show(m.TempQL); os.AWAIT(); m.PortD.Write(<span class="hljs-number"><span class="hljs-number">0xFB</span></span>); m.TempQL.Load(bcdRes.High); m.TempQL &amp;= <span class="hljs-number"><span class="hljs-number">0x0F</span></span>; led7s.Show(m.TempQL); os.AWAIT(); m.PortD.Write(<span class="hljs-number"><span class="hljs-number">0xF7</span></span>); m.TempQL.Load(bcdRes.High); m.TempQL &gt;&gt;= <span class="hljs-number"><span class="hljs-number">4</span></span>; led7s.Show(m.TempQL); os.AWAIT(); tsk.TaskContinue(loop); }, <span class="hljs-string"><span class="hljs-string">"display"</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> ct = os.ContinuousActivate(os.AlwaysOn, actuator); os.ActivateNext(ct, spiSig, treader); os.ActivateNext(ct, tmrSig, display); tc77.Activate(); m.Timer0.Activate(); m.EnableInterrupt(); os.Loop(); Console.WriteLine(AVRASM.Text(m)); } } }</code> </pre> </div></div><br><p>  Est√° claro que este no es un borrador funcional, sino solo una demostraci√≥n tecnol√≥gica dise√±ada para demostrar las capacidades de la biblioteca NanoRTOS.  Pero en cualquier caso, menos de 100 l√≠neas de c√≥digo fuente y menos de 1 kb de c√≥digo de salida es un resultado bastante bueno para una aplicaci√≥n viable. </p><br><p>  En los siguientes art√≠culos, planeo, en caso de inter√©s en este proyecto, profundizar m√°s en los principios y caracter√≠sticas de la programaci√≥n usando esta biblioteca. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/462409/">https://habr.com/ru/post/462409/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../462397/index.html">C√≥mo atrapar un gato con TLA +</a></li>
<li><a href="../462399/index.html">El an√°lisis est√°tico mejorar√° la base de c√≥digo de proyectos complejos de C ++</a></li>
<li><a href="../462401/index.html">Desarrollador Deadly Sins</a></li>
<li><a href="../462403/index.html">Selecci√≥n del tama√±o del monitor: teor√≠a del tama√±o angular, justificaci√≥n y comparaci√≥n</a></li>
<li><a href="../462407/index.html">Food Design Digest Julio 2019</a></li>
<li><a href="../462411/index.html">Resuelve Sudoku con Algoritmo X</a></li>
<li><a href="../462415/index.html">Implemente aplicaciones de Symfony + React en AWS a trav√©s de CI</a></li>
<li><a href="../462417/index.html">Petici√≥n de Apple</a></li>
<li><a href="../462421/index.html">Apollo Guidance Computer: software de arquitectura y sistema. Parte 2</a></li>
<li><a href="../462423/index.html">Project Management</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>