<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üí´ üèø üìì ChaiScript: lenguaje de script para C ++ ‚§µÔ∏è üëêüèΩ üë®üèø‚Äçüé®</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Cuando existe la necesidad de incrustar un lenguaje de script en un proyecto C ++, lo primero que la mayor√≠a de la gente recuerda es Lua. En este art√≠...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ChaiScript: lenguaje de script para C ++</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/483540/">  Cuando existe la necesidad de incrustar un lenguaje de script en un proyecto C ++, lo primero que la mayor√≠a de la gente recuerda es Lua.  En este art√≠culo no ser√°, hablar√© de otro lenguaje no menos conveniente y f√°cil de aprender llamado ChaiScript. <br><br><img src="https://habrastorage.org/webt/zh/vl/py/zhvlpyg_87wuf7gg0alk-s7qeyo.png" alt="imagen"><br><a name="habracut"></a><br><h4>  Breve introducci√≥n </h4><br>  Yo mismo me top√© con ChaiScript por accidente cuando vi <a href="https://youtu.be/uzF4u9KgUWI">una de las conferencias de</a> Jason Turner, uno de los creadores del lenguaje.  Me interes√≥, y en ese momento, cuando era necesario elegir un lenguaje de script en el proyecto, decid√≠: ¬øpor qu√© no probar ChaiScript?  El resultado me sorprendi√≥ gratamente (mi experiencia personal se escribir√° m√°s cerca del final del art√≠culo), sin embargo, no importa cu√°n extra√±o pueda sonar, no hab√≠a un solo art√≠culo en el centro que mencionara este idioma al menos de alguna manera, y decid√≠ que Ser√≠a bueno escribir sobre √©l.  Por supuesto, el lenguaje tiene <a href="">documentaci√≥n</a> y un <a href="http://chaiscript.com/">sitio oficial</a> , pero no todos lo leer√°n de las observaciones, y el formato del art√≠culo est√° m√°s cerca de muchos (incluido yo). <br><br>  Primero, hablaremos sobre la sintaxis del lenguaje y todas sus caracter√≠sticas, luego sobre c√≥mo implementarlo en su proyecto C ++, y al final hablar√© un poco sobre mi experiencia.  Si alguna parte de usted no est√° interesada, o si desea leer el art√≠culo en un orden diferente, puede usar la tabla de contenido: <br><br><ul><li>  <a href="https://habr.com/ru/post/483540/">Sintaxis ChaiScript</a> </li><li>  <a href="https://habr.com/ru/post/483540/">Implementaci√≥n en C ++</a> </li><li>  <a href="https://habr.com/ru/post/483540/">Experiencia personal</a> </li></ul><br><a name="syntax"></a><br><h2>  Sintaxis del lenguaje </h2><br>  ChaiScript es muy similar a C ++ y JS en su sintaxis.  En primer lugar, al igual que la gran mayor√≠a de los lenguajes de secuencias de comandos, se escribe din√°micamente, sin embargo, a diferencia de JavaScript, tiene una escritura estricta (no <code>1 + "2"</code> ).  Tambi√©n hay un recolector de basura incorporado, el lenguaje es totalmente interpretable, lo que le permite ejecutar c√≥digo l√≠nea por l√≠nea, sin compilar en bytecode.  Tiene soporte para excepciones (adem√°s, conjunto, lo que le permite atraparlos tanto dentro del script como en C ++), funciones lambda, sobrecarga del operador.  No es sensible a los espacios, lo que le permite escribir como una sola l√≠nea a trav√©s de un punto y coma, o en estilo python, separando las expresiones con una nueva l√≠nea. <br><br><h4>  Tipos primitivos </h4><br>  ChaiScript almacena de forma predeterminada las variables enteras como int, real como double y cadenas con std :: string.  Esto se hace principalmente para garantizar la compatibilidad con el c√≥digo de llamada.  El lenguaje incluso tiene sufijos para los n√∫meros, por lo que podemos indicar expl√≠citamente de qu√© tipo es nuestra variable: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">/*   chaiscript    js    ,  var / auto `;`      */</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> myInt = <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-comment"><span class="hljs-comment">// int var myLongLong = 1ll // long long int var myFloating = 3.3 // double var myBoolean = false // bool var myString = "hello world!\n" // std::string</span></span></code> </pre><br>  Cambiar el tipo de variables simplemente no funciona, lo m√°s probable es que necesite definir su propio operador `=` para estos tipos, de lo contrario corre el riesgo de lanzar una excepci√≥n (hablaremos de esto m√°s adelante) o convertirse en una v√≠ctima de redondeo, as√≠: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> integer = <span class="hljs-number"><span class="hljs-number">3</span></span> integer = <span class="hljs-number"><span class="hljs-number">5.433</span></span> print(integer) <span class="hljs-comment"><span class="hljs-comment">//  5    double    int! integer = true //   -   `=`  (int, bool)</span></span></code> </pre><br>  Sin embargo, puede declarar una variable sin asignarle un valor, en cuyo caso contendr√° una especie de indefinido hasta que se le asigne un valor. <br><br><h4>  Contenedores en l√≠nea </h4><br>  El lenguaje tiene dos contenedores: Vector y Mapa.  Funcionan de manera muy similar a sus contrapartes en C ++ (std :: vector y std :: map, respectivamente), pero no requieren un tipo, ya que pueden almacenar cualquiera.  La indexaci√≥n se puede hacer como de costumbre con ints, pero Map requiere una clave con una cadena.  Aparentemente inspirados en python, los autores tambi√©n agregaron la capacidad de declarar r√°pidamente contenedores en c√≥digo usando la siguiente sintaxis: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> v = [ <span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>u, <span class="hljs-number"><span class="hljs-number">4</span></span>ll, <span class="hljs-string"><span class="hljs-string">"16"</span></span>, <span class="hljs-string"><span class="hljs-string">`+`</span></span> ] <span class="hljs-comment"><span class="hljs-comment">//      var m = [ "key1" : 1, "key2": "Bob" ]; //    - var M = Map() //    var V = Vector() //    //        C++ : v.push_back(123) //    ,     v.push_back_ref(m); // m -   //      m["key"] = 3 //       (reference assignment): m["key"] := m //      </span></span></code> </pre><br>  Ambas clases repiten casi por completo sus contrapartes en C ++, con la excepci√≥n de los iteradores, porque en su lugar hay clases especiales Range y Const_Range.  Por cierto, todos los contenedores se pasan por referencia, incluso si usa la asignaci√≥n a trav√©s de =, lo cual es muy extra√±o para m√≠, porque para todos los dem√°s tipos se produce la copia por valor. <br><br><h4>  Construcciones condicionales </h4><br>  Casi todas las construcciones de condiciones y ciclos se pueden describir literalmente en un c√≥digo de ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> a = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> b = <span class="hljs-number"><span class="hljs-number">-1</span></span> <span class="hljs-comment"><span class="hljs-comment">//  if-else if (a &gt; b) { print("a &gt; b") } else if (a == b){ print("a == b") } else { print("a &lt; b") } // switch -    if- //      //  break    ,    C++ var str = "hello" switch(str) { case("hi") { print("hi!"); break; } case("hello") { print("hello!" break; } case("bye") { print("bye-bye!") break; } default { print("what have you said?") } } var x = true //     ,       while (x) { print("x was true") x = false; } //    C.        ,    ,    ,    for (var i = 0; i &lt; 10; ++i) //   -,    { print(i); //  0 ... 9  10  } // ranged-for loop for(element : [1, 2, 3, 4, 5]) { puts(element) //   12345 } //  :   C++17 if-init statements: if(var x = get_value(); x &lt; 10) { print(x) // x     if }</span></span></code> </pre><br>  Creo que las personas familiarizadas con C ++ no han encontrado nada nuevo.  Esto no es sorprendente, porque ChaiScript se posiciona como un lenguaje f√°cil de aprender para los "estudiantes" y, por lo tanto, toma prestados todos los dise√±os cl√°sicos conocidos.  Los autores decidieron resaltar incluso dos palabras clave para declarar variables: <code>var</code> y <code>auto</code> , en caso de que realmente te gusten las ventajas con auto. <br><br><h4>  Contexto de ejecuci√≥n </h4><br>  ChaiScript tiene un contexto local y global.  El c√≥digo se ejecuta de arriba a abajo l√≠nea por l√≠nea, sin embargo, se puede extraer en funciones y llamar m√°s tarde (¬°pero no antes!).  Las variables declaradas dentro de las funciones o condiciones / bucles no son visibles por defecto desde el exterior, pero puede cambiar este comportamiento utilizando el identificador <code>global</code> lugar de <code>var</code> .  Las variables globales difieren de las ordinarias en que, en primer lugar, son visibles fuera del contexto local y, en segundo lugar, se pueden volver a declarar (si el valor no se establece durante la declaraci√≥n repetida, entonces permanece igual) <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//     chaiscript def foo(x) { global G = 2 print(x) } foo(0) //  foo(x), G = 2 print(G) //  2 global G = 3 //  G = 3,   global -  !</span></span></code> </pre><br>  Por cierto, si tiene una variable y necesita verificar si se le asigna un valor, use la <code>is_var_undef</code> incorporada <code>is_var_undef</code> , que devuelve verdadero si la variable no est√° definida. <br><br><h4>  Interpolaci√≥n de cuerdas </h4><br>  Los objetos base u objetos de usuario que tienen un m√©todo <code>to_string()</code> se pueden poner en una cadena usando la sintaxis <code>${object}</code> .  Esto evita concatenaciones de cadenas innecesarias y generalmente se ve mucho m√°s ordenado: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-comment"><span class="hljs-comment">//  sum of 3 + 4 = 7 print("sum of ${x} + ${y} = ${x + y}")</span></span></code> </pre><br>  Vector, Map, MapPair y todas las primitivas tambi√©n admiten esta funci√≥n.  El vector se muestra en el formato <code>[o1, o2, ...]</code> , Mapa como <code>[&lt;key1, val1&gt;, &lt;key2, val2&gt;, ...]</code> y MapPair: <code>&lt;key, val&gt;</code> . <br><br><h4>  Funciones y sus matices. </h4><br>  Las funciones ChaiScript son objetos como todo lo dem√°s.  Se pueden capturar, asignar a variables, anidar en otras funciones y pasar como argumento.  Tambi√©n para ellos puede especificar el tipo de valores de entrada (que es lo que les faltaba a los idiomas escritos din√°micamente). Para esto, debe especificar el tipo antes de declarar el par√°metro de funci√≥n.  Si, cuando se llama, el par√°metro se puede convertir al especificado, la conversi√≥n se realizar√° de acuerdo con las reglas de C ++; de lo contrario, se generar√° una excepci√≥n: <br><br><pre> <code class="javascript hljs">def adder(int x, int y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x + y } def adder(bool x, bool y) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> x || y } adder(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>) <span class="hljs-comment"><span class="hljs-comment">// ,  3 adder(1.22, -3.7) // ,  1 + (-3) = 2 adder(true, true) // ,  true adder(true, 3) // ,    adder(bool, int)</span></span></code> </pre><br>  Las funciones en el idioma tambi√©n se pueden establecer condiciones de llamada (guardia de llamada).  Si no se respeta, se lanza una excepci√≥n; de lo contrario, se realiza una llamada.  Tambi√©n noto que si la funci√≥n no tiene una declaraci√≥n de retorno al final, entonces se devolver√° la √∫ltima expresi√≥n.  Muy conveniente para peque√±as rutinas: <br><br><pre> <code class="javascript hljs">def div(x, y) : y != <span class="hljs-number"><span class="hljs-number">0</span></span> { x / y } <span class="hljs-comment"><span class="hljs-comment">//  `y`    -    `x`  `y` print(div(2, 0.5)) //  4.0 print(div(2, 0)) // , `y`  0!</span></span></code> </pre><br><h4>  Clases y Dynamic_Object </h4><br>  ChaiScript tiene los rudimentos de OOP, que es una ventaja definitiva si necesita manipular objetos complejos.  El idioma tiene un tipo especial: Dynamic_Object.  De hecho, todas las instancias de clases y espacios de nombres son exactamente Dynamic_Object con propiedades predefinidas.  Un objeto din√°mico le permite agregarle campos durante la ejecuci√≥n del script y luego acceder a ellos: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> obj = Dynamic_Object(); obj.x = <span class="hljs-number"><span class="hljs-number">3</span></span>; obj.f = fun(arg) { print(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.x + arg); } <span class="hljs-comment"><span class="hljs-comment">//  obj   f (     `x` obj.f(-3); //  0</span></span></code> </pre><br>  Las clases se definen de manera bastante simple.  Se pueden establecer en campos, m√©todos, constructores.  Desde el <code>set_explicit(object, value)</code> interesante <code>set_explicit(object, value)</code> trav√©s de la funci√≥n especial <code>set_explicit(object, value)</code> puede "arreglar" los campos del objeto al prohibir la adici√≥n de nuevos m√©todos o atributos despu√©s de la declaraci√≥n de clase (esto generalmente se hace en el constructor): <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> id; <span class="hljs-comment"><span class="hljs-comment">//  id def Widget() { this.id= 0 } //    def Widget(id) { this.id = id } //   1  def get_id() { id } //   } var w = Widget(10) print(w.get_id()) //  10 (w.id) print(w.get_id) //   10,        set_explicit(w, true) //    wx = 3 //      Widget   x</span></span></code> </pre><br>  Un punto importante: de hecho, los m√©todos de clase son solo funciones cuyo primer argumento es un objeto de una clase con un tipo expl√≠citamente especificado.  Por lo tanto, el siguiente c√≥digo es equivalente a agregar un m√©todo a una clase existente: <br><br><pre> <code class="javascript hljs">def set_id(Widget w, id) { w.id = id } w.set_id(<span class="hljs-number"><span class="hljs-number">9</span></span>) <span class="hljs-comment"><span class="hljs-comment">// w.id = 9 set_id(w, 9) //  , w.id = 9</span></span></code> </pre><br>  Cualquier persona familiarizada con C # puede reemplazar lo que dolorosamente parece un m√©todo de extensi√≥n, y estar√° cerca de la verdad.  Por lo tanto, en el lenguaje puede agregar una nueva funcionalidad incluso para las clases integradas, por ejemplo, para una cadena o int.  Los autores tambi√©n ofrecen una forma complicada de sobrecargar a los operadores: para hacer esto, debe rodear el s√≠mbolo del operador con una tilde (`) como en el siguiente ejemplo: <br><br><pre> <code class="javascript hljs"><span class="hljs-comment"><span class="hljs-comment">//   +     Widget def `+`(Widget w1, Widget w2) { print("merging two widgets!") } var widget1 = Widget() var widget2 = Widget() widget1 + widget2 //      //        : var plus = `+` print(plus(1, 7)) //  8</span></span></code> </pre><br><h4>  Espacios de nombres </h4><br>  Hablando sobre el espacio de nombres en ChaiScript, debe tenerse en cuenta que estas son esencialmente clases que siempre est√°n en un contexto global.  Puede crearlos utilizando la funci√≥n de <code>namespace(name)</code> y luego agregar las funciones y clases necesarias.  De manera predeterminada, no hay bibliotecas en el idioma, sin embargo, puede instalarlas usando extensiones, de las que hablaremos m√°s adelante.  En general, la inicializaci√≥n del espacio de nombres podr√≠a verse as√≠: <br><br><pre> <code class="javascript hljs">namespace(<span class="hljs-string"><span class="hljs-string">"math"</span></span>) <span class="hljs-comment"><span class="hljs-comment">//    math //   math.square = fun(x) { x * x } math.hypot_squared= fun(x, y) { math.square(x) + math.square(y) } print(math.square(4)) //  16 print(math.hypot_squared(3, 4)) //  25</span></span></code> </pre><br><h4>  Expresiones lambda y otras caracter√≠sticas </h4><br>  Las expresiones lambda en ChaiScript son similares a lo que sabemos de C ++.  La palabra clave <b>divertida</b> se usa para ellos, y tambi√©n requieren que se especifiquen expl√≠citamente las variables capturadas, sin embargo, siempre lo hacen por referencia.  El lenguaje tambi√©n tiene una funci√≥n de vinculaci√≥n que le permite vincular valores a par√°metros de funci√≥n: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> func_object = fun(x) { x * x } func_object(<span class="hljs-number"><span class="hljs-number">9</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  81 var name = "John" var greet = fun[name]() { "Hello, " + name } print(greet()) //  Hello, John name = "Bob" print(greet()) //  Hello, Bob var message = bind(fun(msg, name) { msg + " from " + name }, _, "ChaiScript"); print(message("Hello")) //  Hello from ChaiScript</span></span></code> </pre><br><h4>  Excepciones </h4><br>  Pueden ocurrir excepciones durante la ejecuci√≥n del script.  Se pueden interceptar tanto en ChaiScript (que discutiremos aqu√≠) como en C ++.  La sintaxis es absolutamente id√©ntica a las ventajas, incluso puede arrojar un n√∫mero o una cadena: <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(x + <span class="hljs-number"><span class="hljs-number">1</span></span>) <span class="hljs-comment"><span class="hljs-comment">// x   } catch (e) { print("Error during evaluation")) } //   C++   ChaiScript //   Vector -   std::vector,    std::exception      try { var vec = [1, 2] var val = vec[3] //     } catch (e) { print("index out of range: " + e.what()); // e.what    ChaiScript } //  atch   guard     ,    `:` try { throw(5.2) } catch(e) : is_type(e, "int") { print("Int: ${e}"); //   `e`  int } catch(e) : is_type(e, "double") { print("Double: ${e}"); //  `e`  double }</span></span></code> </pre><br>  En el buen sentido, debe definir su clase de excepciones y lanzarla.  Hablaremos sobre c√≥mo interceptarlo en C ++ en la segunda secci√≥n.  Para las excepciones de int√©rpretes, ChaiScript arroja sus excepciones, como eval_error, bad_boxed_cast, etc. <br><br><h4>  Constantes de int√©rprete </h4><br>  Para mi sorpresa, el lenguaje result√≥ ser alg√∫n tipo de macros de compilaci√≥n: solo hay 4 de ellas y todas sirven para identificar el contexto y se utilizan principalmente para el manejo de errores: <br><div class="scrollable-table"><table><tbody><tr><td>  __LINE__ </td><td>  l√≠nea actual, si el c√≥digo no se ejecuta desde un archivo, entonces '1' </td></tr><tr><td>  __FILE__ </td><td>  archivo actual, si el c√≥digo no se llama desde un archivo, entonces "__EVAL__" </td></tr><tr><td>  __CLASE__ </td><td>  clase actual o "NOT_IN_CLASS" </td></tr><tr><td>  __FUNC__ </td><td>  funci√≥n actual o "NOT_IN_FUNCTION" </td></tr></tbody></table></div><br><h4>  Error de captura </h4><br>  Si la funci√≥n que est√° llamando no se ha declarado, se produce una excepci√≥n.  Si esto es inaceptable para usted, puede definir una funci√≥n especial: <code>method_missing(object, func_name, params)</code> , que se llamar√° con los argumentos correspondientes en caso de error: <br><br><pre> <code class="javascript hljs">def method_missing(Widget w, string name, Vector v) { print(<span class="hljs-string"><span class="hljs-string">"widget method ${name} with params {v} was not found"</span></span>) } w = Widget() w.invoke_error(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-number"><span class="hljs-number">2</span></span>, <span class="hljs-number"><span class="hljs-number">3</span></span>) <span class="hljs-comment"><span class="hljs-comment">//  widget method invoke_error with params [1, 2, 3] was not found</span></span></code> </pre><br><h4>  Funciones incorporadas </h4><br>  ChaiScript define muchas funciones integradas, y en el art√≠culo me gustar√≠a hablar sobre funciones especialmente √∫tiles.  Entre ellos: <code>eval(str)</code> , <code>eval_file(filename)</code> , <code>to_json(object)</code> , <code>from_json(str)</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> x = <span class="hljs-number"><span class="hljs-number">3</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> y = <span class="hljs-number"><span class="hljs-number">5</span></span> <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> res = <span class="hljs-built_in"><span class="hljs-built_in">eval</span></span>(<span class="hljs-string"><span class="hljs-string">"x * y"</span></span>) <span class="hljs-comment"><span class="hljs-comment">// res = 15,  eval     //     : //  eval_file eval_file("source.chai") //   use,  ,         use("source.chai") // to_json    Map    var w = Widget(0) var j = to_json(w) // j = "{ "id" : 0 }" // from_json    Map ( ,   ) var m = from_json(" { "x": 0, "y": 3, "z": 2 }") print(m) //  Map  [&lt;x, 0&gt;, &lt;y, 3&gt;, &lt;z, 2&gt;]</span></span></code> </pre><br><a name="cppchai"></a><br><h2>  Implementaci√≥n en C ++ </h2><br><h4>  Instalaci√≥n </h4><br>  ChaiScript es una biblioteca de solo encabezado basada en plantillas C ++.  En consecuencia, para la instalaci√≥n solo necesita hacer un <a href="https://github.com/ChaiScript/ChaiScript">repositorio de</a> clones o simplemente poner todos los archivos de <a href="https://github.com/ChaiScript/ChaiScript/tree/develop/include/chaiscript">esta carpeta</a> en su proyecto.  Dado que, dependiendo del IDE, todo esto se hace de manera diferente y se ha descrito en detalle en los foros durante mucho tiempo, entonces asumiremos que logr√≥ conectar la biblioteca, y el c√≥digo con incluye: <code>#include &lt;chaiscript/chaiscript.hpp&gt;</code> compilado. <br><br><h4>  Invocaci√≥n de c√≥digo C ++ y carga de script </h4><br>  El c√≥digo de muestra m√°s peque√±o que usa ChaiScript es el que se muestra a continuaci√≥n.  Definimos una funci√≥n simple en C ++ que toma std :: string y devuelve la cadena modificada, y luego le agregamos un enlace en el objeto ChaiScript para llamarla.  La compilaci√≥n puede llevar un tiempo considerable, pero esto se debe principalmente al hecho de que crear instancias de una gran cantidad de plantillas para el compilador no es f√°cil: <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;string&gt; #include &lt;chaiscript/chaiscript.hpp&gt; std::string greet_name(const std::string&amp; name) { return "hello, " + name; } int main() { chaiscript::ChaiScript chai; //  chaiscript chai.add(chaiscript::fun(&amp;greet_name), "greet"); //    greet //  eval      chai.eval(R"( print(greet("John")); )"); }</span></span></span></span></code> </pre> <br>  Espero que haya tenido √©xito y haya visto el resultado de la funci√≥n.  Quiero notar un matiz de inmediato: si declara un objeto ChaiScript como est√°tico, obtendr√° un error de tiempo de ejecuci√≥n desagradable.  Esto se debe al hecho de que el lenguaje admite subprocesos m√∫ltiples de forma predeterminada y almacena variables de flujo locales a las que se accede en su destructor.  Sin embargo, se destruyen antes de que se llame al destructor de la instancia est√°tica y, como resultado, tenemos una infracci√≥n de acceso o un error de segmentaci√≥n.  Seg√∫n el <a href="https://github.com/ChaiScript/ChaiScript/issues/338">problema en github</a> , la soluci√≥n m√°s simple ser√≠a simplemente poner <b><code>#define CHAISCRIPT_NO_THREADS</code></b> en la configuraci√≥n del compilador o antes de incluir el archivo de la biblioteca, deshabilitando as√≠ el subprocesamiento m√∫ltiple.  Seg√∫n tengo entendido, no fue posible corregir este error. <br><br>  Ahora analizaremos en detalle c√≥mo se produce la interacci√≥n entre C ++ y ChaiScript.  La biblioteca define una funci√≥n de plantilla especial <code>fun</code> , que puede llevar un puntero a una funci√≥n, functor o puntero a una variable de clase, y luego devolver un objeto especial que almacena el estado.  Como ejemplo, definamos la clase Widget en c√≥digo C ++ e intentemos asociarla con ChaiScript de diferentes maneras: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Widget(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id) : Id(id) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Id; } }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Widget&amp; w)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"widget #"</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(w.GetId()); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ chaiscript::ChaiScript chai; <span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">w</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">2</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Widget  C++  chai.add(chaiscript::fun([&amp;w] { return w; }), "get_widget"); //         chai.add(chaiscript::fun(ToString), "to_string"); //   chai.add(chaiscript::fun(&amp;Widget::GetId), "get_id"); //   //    ,   Widget    GetId,    to_string,    chai.eval(R"( var w = get_widget() print(w.get_id) //  2 print(w) //  widget #2 )"); }</span></span></code> </pre><br>  Como puede ver, ChaiScript funciona con absoluta calma con clases de C ++ desconocidas y puede llamar a sus m√©todos.  Si comete un error en alg√∫n lugar del c√≥digo, lo m√°s probable es que el script arroje una excepci√≥n del <code>error in function dispatch</code> amable <code>error in function dispatch</code> , que no es cr√≠tico en absoluto.  Sin embargo, no solo se pueden importar funciones, veamos c√≥mo agregar una variable a un script usando la biblioteca.  Para hacer esto, seleccione la tarea un poco m√°s dif√≠cil: importe std :: vector &lt;Widget&gt;.  La funci√≥n <code>chaiscript::var</code> y el m√©todo <code>add_global</code> nos ayudar√°n con esto.  Tambi√©n agregaremos el campo p√∫blico <code>Data</code> a nuestro widget para ver c√≥mo importar el campo de clase: <br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Data = <span class="hljs-number"><span class="hljs-number">0</span></span>; Widget(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : Id(id) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Id; } }; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-function"><span class="hljs-built_in"><span class="hljs-function"><span class="hljs-built_in">string</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ToString</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> Widget&amp; w)</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-string"><span class="hljs-string">"widget #"</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(w.GetId()) + <span class="hljs-string"><span class="hljs-string">" with data: "</span></span> + <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::to_string(w.Data); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ chaiscript::ChaiScript chai; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;Widget&gt; W; <span class="hljs-comment"><span class="hljs-comment">//    Widget W.emplace_back(1); W.emplace_back(2); W.emplace_back(3); chai.add(chaiscript::fund(ToString), "to_string"); chai.add(chaiscript::fun(&amp;Widget::Data), "data"); //     //     ChaiScript chai.add_global(chaiscript::var(std::ref(W)), "widgets"); //     std::ref chai.add(chaiscript::fun(&amp;std::vector&lt;Widget&gt;::size), "size"); //   // .        using IndexFuncType = Widget&amp; (std::vector&lt;Widget&gt;::*)(const size_t); chai.add(chaiscript::fun(IndexFuncType(&amp;std::vector&lt;Widget&gt;::operator[])), "[]"); chai.eval(R"( for(var i = 0; i &lt; vec.size; ++i) { vec[i].data = i * 2; print(vec[i]) } )"); }</span></span></code> </pre><br>  El c√≥digo anterior muestra: <b><code>widget #1 with data: 0</code> , <code>widget #2 with data: 2</code> , <code>widget #3 with data: 4</code></b> .  Agregamos un puntero al campo de clase en ChaiScript, y dado que el campo result√≥ ser un tipo primitivo, cambiamos su valor.  Adem√°s, se agregaron varios m√©todos para trabajar con <code>std::vector</code> , incluido el <code>operator[]</code> .  Quienes est√©n familiarizados con STL saben que <code>std::vector</code> dos m√©todos de indexaci√≥n: uno devuelve un enlace constante y el otro un enlace simple.  Es por eso que para las funciones sobrecargadas, debe indicar expl√≠citamente su tipo; de lo contrario, surge la ambig√ºedad y el compilador arrojar√° un error. <br><br>  La biblioteca proporciona varios m√©todos m√°s para agregar objetos, pero todos son casi id√©nticos, por lo que no veo el punto de considerarlos en detalle.  Como una peque√±a pista, aqu√≠ est√° el siguiente c√≥digo: <br><br><pre> <code class="cpp hljs">chai.add(chaiscript::var(x), <span class="hljs-string"><span class="hljs-string">"x"</span></span>); <span class="hljs-comment"><span class="hljs-comment">// x   ChaiScript chai.add(chaiscript::var(std::ref(x), "x"); //  ,    C++  ChaiScript auto shared_x = std::make_shared&lt;int&gt;(5); chai.add(chaiscript::var(shared_x), "x"); // shared_ptr      C++  ChaiScript chai.add(chaiscript::const_var(x), "x"); //   ChaiScript    chai.add_global_const(chaiscript::const_var(x), "x"); // global const . ,  x   chai.add_global(chaiscript::var(x), "x"); // global , .  x   chai.set_global(chaiscript::var(x), "x"); //   global ,    const</span></span></code> </pre><br><h4>  Usando contenedores STL </h4><br>  Si desea pasar contenedores STL que contienen tipos <b>primitivos</b> a ChaiScript, puede agregar una instancia de contenedor de plantillas a su script para que no importe m√©todos para cada tipo. <br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> MyVector = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span>&gt;&gt;; MyVector V; V.emplace_back(<span class="hljs-number"><span class="hljs-number">1</span></span>, <span class="hljs-string"><span class="hljs-string">"John"</span></span>); V.emplace_back(<span class="hljs-number"><span class="hljs-number">3</span></span>, <span class="hljs-string"><span class="hljs-string">"Bob"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    - vector  pair chai.add(chaiscript::bootstrap::standard_library::vector_type&lt;MyVector&gt;("MyVec")); chai.add(chaiscript::bootstrap::standard_library::pair_type&lt;MyVector::value_type&gt;("MyVecData")); chai.add(chaiscript::var(std::ref(V)), "vec"); chai.eval(R"( for(var i = 0; i &lt; vec.size; ++i) { print(to_string(vec[i].first) + " " + vec[i].second) } )");</span></span></code> </pre> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Bajo el cap√≥, se llaman varias funciones ChaiScript, que a su vez agregan los m√©todos necesarios. </font><font style="vertical-align: inherit;">En general, si su clase admite operaciones similares con contenedores STL, tambi√©n puede agregarlo de esta manera. </font><font style="vertical-align: inherit;">En el caso de c, </font></font><code>std::vector&lt;Widget&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">esto, desafortunadamente, es imposible, ya que ChaiScript requiere un constructor sin par√°metros para el elemento </font></font><code>vector_type</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, que nuestro Widget no ten√≠a.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Clases de C ++ dentro de ChaiScript </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Quiz√°s como parte de su tarea, necesita no solo modificar objetos en ChaiScript, sino tambi√©n crearlos en un script. </font><font style="vertical-align: inherit;">Bueno, esto es completamente posible. </font><font style="vertical-align: inherit;">Tomemos la clase Widget nuevamente, por ejemplo, y heredemos la clase WindowWidget de ella, y luego agreguemos al script la capacidad de crear ambos y tambi√©n convertir la clase heredada a la base:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Widget</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Id; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: Widget(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id) : Id(id) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetId</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Id; } }; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">WindowWidget</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Widget { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::pair&lt;<span class="hljs-keyword"><span class="hljs-keyword">int</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span>&gt; Size; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: WindowWidget(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> id, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> width, <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> height) : Widget(id), Size(width, height) { } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetWidth</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Size.first; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GetHeight</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;Size.second; } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ chaiscript::ChaiScript chai; <span class="hljs-comment"><span class="hljs-comment">//   Widget    chai.add(chaiscript::user_type&lt;Widget&gt;(), "Widget"); chai.add(chaiscript::constructor&lt;Widget(int)&gt;(), "Widget"); //   WindowWidget    chai.add(chaiscript::user_type&lt;WindowWidget&gt;(), "WindowWidget"); chai.add(chaiscript::constructor&lt;WindowWidget(int, int, int)&gt;(), "WindowWidget"); // ,  Widget -    WindowWidget chai.add(chaiscript::base_class&lt;Widget, WindowWidget&gt;()); //   Widget  WindowWidget chai.add(chaiscript::fun(&amp;Widget::GetId), "get_id"); chai.add(chaiscript::fun(&amp;WindowWidget::GetWidth), "width"); chai.add(chaiscript::fun(&amp;WindowWidget::GetHeight), "height"); //  WindowWidget     chai.eval(R"( var window = WindowWidget(1, 800, 600) print("${window.width} * ${window.height}") print("widget.id is ${window.get_id}") )"); }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El polimorfismo funciona en ChaiScript exactamente de la misma manera que en C ++ para los tipos sobre los que proporciona informaci√≥n. </font><font style="vertical-align: inherit;">Si por alguna raz√≥n hay ambig√ºedad al agregar un puntero a un m√©todo heredado (tal vez la clase se hereda de varios m√©todos b√°sicos a la vez), tr√°igala a la clase deseada expl√≠citamente, como se hizo en el ejemplo anterior con el operador de indexaci√≥n </font></font><code>std::vector&lt;Widget&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Vinculando una instancia a un m√©todo y convirtiendo un tipo </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Para objetos singleton, es conveniente usar la captura de enlaces a ellos junto con un m√©todo o campo. </font><font style="vertical-align: inherit;">En este caso, en ChaiScript obtenemos una funci√≥n o una variable global a la que se puede acceder sin mencionar este objeto:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-function">Widget </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">w</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-number"><span class="hljs-function"><span class="hljs-params"><span class="hljs-number">3</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span>; w.Data = <span class="hljs-number"><span class="hljs-number">4444</span></span>; <span class="hljs-comment"><span class="hljs-comment">//  Widget w chai.add(chaiscript::fun(&amp;Widget::GetId, &amp;w), "widget_id"); chai.add(chaiscript::fun(&amp;Widget::Data, &amp;w), "widget_data"); chai.eval(R"( print(widget_id) print(widget_data) )");</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Adem√°s, al exportar m√°s clases de "biblioteca" de C ++ a ChaiScript (por ejemplo, vec3, complejo, matriz), a menudo se requiere la posibilidad de conversi√≥n impl√≠cita de un tipo a otro. En ChaiScript, este problema se resuelve agregando </font></font><code>type_conversion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">un script al objeto. Por ejemplo, considere la clase compleja y la implementaci√≥n de convertir int y double a ella durante la suma:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Complex</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> Re, Im; Complex(<span class="hljs-keyword"><span class="hljs-keyword">float</span></span> re, <span class="hljs-keyword"><span class="hljs-keyword">float</span></span> im = <span class="hljs-number"><span class="hljs-number">0.0f</span></span>) : Re(re), Im(im) { } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ chaiscript::ChaiScript chai; <span class="hljs-comment"><span class="hljs-comment">//  Complex,   re, im,    `=` chai.add(chaiscript::user_type&lt;Complex&gt;(), "Complex"); chai.add(chaiscript::bootstrap::standard_library::assignable_type&lt;Complex&gt;("Complex")); chai.add(chaiscript::constructor&lt;Complex(float, float)&gt;(), "Complex"); chai.add(chaiscript::fun(&amp;Complex::Re), "re"); chai.add(chaiscript::fun(&amp;Complex::Im), "im"); //     double  int  Complex chai.add(chaiscript::type_conversion&lt;int, Complex&gt;()); chai.add(chaiscript::type_conversion&lt;double, Complex&gt;()); //     `+`    chai.eval(R"( def `+`(Complex c, x) { var res = Complex(0, 0) res.re = c.re + x.re res.im = c.im + x.im return res } var c = Complex(1, 2) c = c + 3 print("${c.re} + ${c.im}i") )"); // : `4 + 2i` }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por lo tanto, no es necesario escribir una funci√≥n de conversi√≥n en C ++, y solo luego exportarla a ChaiScript. </font><font style="vertical-align: inherit;">Puede agregar transformaciones y ya describir la nueva funcionalidad en el c√≥digo del script. </font><font style="vertical-align: inherit;">Si la conversi√≥n para los dos tipos no es trivial, puede pasar el lambda como argumento a una funci√≥n </font></font><code>type_conversion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Se llamar√° cuando se lance. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Se utiliza un principio similar para convertir ChaiScript Vector o Map en su tipo personalizado. </font><font style="vertical-align: inherit;">Para esto, </font></font><code>vector_conversion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y se </font><font style="vertical-align: inherit;">definen en la biblioteca </font></font><code>map_conversion</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Desempaquetando los valores de retorno de ChaiScript </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">M√©todos </font></font><code>eval</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">y </font></font><code>eval_file</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">devolver el valor de la √∫ltima expresi√≥n ejecutada como un objeto </font></font><code>Boxed_Value</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Para descomprimirlo y usar el resultado en c√≥digo C ++, puede especificar expl√≠citamente el tipo del valor de retorno o usar una funci√≥n </font></font><code>boxed_cast&lt;T&gt;</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">. </font><font style="vertical-align: inherit;">Si existe la conversi√≥n entre tipos, se ejecutar√°, de lo contrario se generar√° una excepci√≥n </font></font><code>bad_boxed_cast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//       double d = chai.eval&lt;double&gt;("5.3 + 2.1"); //     Boxed_Value,     auto v = chai.eval("5.3 + 2.1"); double d = chai.boxed_cast&lt;double&gt;(v);</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Dado que todos los objetos dentro de ChaiScript se almacenan usando shared_ptr, puede obtener el objeto como un puntero para seguir trabajando con √©l. </font><font style="vertical-align: inherit;">Para hacer esto, especifique expl√≠citamente el tipo shared_ptr al convertir el valor de retorno:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> x = chai.eval&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">double</span></span>&gt;&gt;(<span class="hljs-string"><span class="hljs-string">"var x = 3.2"</span></span>);</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lo principal es no mantener una referencia al valor de shared_ptr desreferenciado, de lo contrario corre el riesgo de obtener una infracci√≥n de acceso despu√©s de que la variable se elimine durante la recolecci√≥n de basura autom√°tica en el script. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Al igual que las variables, puede obtener funciones de ChaiScript en forma de functores empaquetados que capturan el estado de un objeto ChaiScript. </font><font style="vertical-align: inherit;">Por ejemplo, usaremos la funcionalidad ya implementada de la clase Complex e intentaremos usarla para llamar a una funci√≥n en la etapa de ejecuci√≥n del programa:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> printComplex = chai.eval&lt;<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::function&lt;<span class="hljs-keyword"><span class="hljs-keyword">void</span></span>(Complex)&gt;&gt;(<span class="hljs-string"><span class="hljs-string">R"( fun(Complex c) { print("${c.re} + ${c.im}i"); } )"</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  ,   ,      C++ printComplex(Complex(2, 3)); //  chaiscript,  `2 + 3i`</span></span></code> </pre><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Captura de excepciones ChaiScript </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Los autores recomiendan capturar tres tipos de excepciones adem√°s de las que usted genera. </font><font style="vertical-align: inherit;">Esto es </font></font><code>eval_error</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para errores de tiempo de ejecuci√≥n, </font></font><code>bad_boxed_cast</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">que se llama cuando los valores de retorno se desempaquetan incorrectamente y </font></font><code>std::exception</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">para todo lo dem√°s. </font><font style="vertical-align: inherit;">Si planea lanzar sus propias excepciones, puede configurar la conversi√≥n autom√°tica a tipos C ++:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">MyException</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> Data; MyException(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> data) : <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::exception(<span class="hljs-string"><span class="hljs-string">"MyException"</span></span>), Data(data) { } }; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ chaiscript::ChaiScript chai; <span class="hljs-comment"><span class="hljs-comment">//      chaiscript chai.add(chaiscript::user_type&lt;MyException&gt;(), "MyException"); chai.add(chaiscript::constructor&lt;MyException(int)&gt;(), "MyException"); try { //          chai.eval("throw(MyException(11111))", chaiscript::exception_specification&lt;MyException, std::exception&gt;()); } catch (MyException&amp; e) { std::cerr &lt;&lt; e.Data; //   `11111` } catch (chaiscript::exception::eval_error&amp; e) { std::cerr &lt;&lt; e.pretty_print(); } catch(std::exception&amp; e) { std::cerr &lt;&lt; e.what(); } }</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">El ejemplo anterior muestra c√≥mo capturar la mayor√≠a de las excepciones en C ++. </font><font style="vertical-align: inherit;">Adem√°s del m√©todo </font></font><code>pretty_print</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">, </font></font><code>eval_error</code><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">todav√≠a hay muchos datos √∫tiles, como la pila de llamadas, el nombre del archivo, los detalles del error, pero no entraremos tanto en esta clase en este art√≠culo.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Bibliotecas ChaiScript </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Desafortunadamente, por defecto, ChaiScript no proporciona funcionalidad adicional en t√©rminos de bibliotecas. </font><font style="vertical-align: inherit;">Por ejemplo, carece de funciones matem√°ticas, tablas hash y la mayor√≠a de los algoritmos. </font><font style="vertical-align: inherit;">Puede descargar algunos de ellos en forma de bibliotecas de m√≥dulos desde el repositorio oficial de </font></font><a href="https://github.com/ChaiScript/ChaiScript_Extras"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Extras de ChaiScript</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y luego importarlos a su script. </font><font style="vertical-align: inherit;">Por ejemplo, tome la biblioteca </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">matem√°tica</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> y la funci√≥n acos (x):</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta">#</span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">include</span></span></span><span class="hljs-meta"> </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;chaiscript/chaiscript.hpp&gt; #include &lt;chaiscript/extras/math.hpp&gt; int main() { chaiscript::ChaiScript chai; //   auto mathlib = chaiscript::extras::math::bootstrap(); chai.add(mathlib); std::cout &lt;&lt; chai.eval&lt;double&gt;("acos(0.5)"); // ~1.047 }</span></span></span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Tambi√©n puede escribir su biblioteca para el idioma y luego importar. </font><font style="vertical-align: inherit;">Esto se hace de manera bastante simple, por lo que le aconsejo que se familiarice con las matem√°ticas de c√≥digo abierto o cualquier otra fuente en el repositorio. </font><font style="vertical-align: inherit;">En principio, como parte de la integraci√≥n con C ++, examinamos casi todo, por lo que creo que la secci√≥n se puede completar al respecto.</font></font><br><a name="myexp"></a><br><h2><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Experiencia personal </font></font></h2><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En este momento estoy escribiendo un motor 3D en OpenGL como un proyecto personal, y tuve una idea completamente l√≥gica de implementar una consola de depuraci√≥n para controlar el estado de la aplicaci√≥n en tiempo real a trav√©s de comandos. Por supuesto, uno podr√≠a hacer </font></font><a href="https://github.com/MomoDeve/MSL"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ciclismo</font></font></a><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> , pero como dicen, "el juego no valdr√≠a la pena", as√≠ que decid√≠ tomar la biblioteca terminada.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Como mencion√© al principio del art√≠culo, ya sab√≠a sobre ChaiScript, as√≠ que ten√≠a que elegir entre √©l y Lua. </font><font style="vertical-align: inherit;">Hasta ese momento, no estaba familiarizado con ninguno de los dos idiomas, por lo tanto, factores tales como: sintaxis clara, facilidad de incrustaci√≥n en el c√≥digo existente y soporte para C ++ en lugar de C influyeron m√°s para no hacer la valla de los contenedores OOP sobre C- funciones de estilo </font><font style="vertical-align: inherit;">Creo que, mientras le√≠a este art√≠culo, ya adivin√≥ en qu√© consist√≠a mi elecci√≥n.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Por el momento, el idioma es m√°s que adecuado para m√≠, y escribir sobre las clases no es gran cosa. </font><font style="vertical-align: inherit;">En el c√≥digo del motor, una instancia de la consola en ImGui se adjunta a la aplicaci√≥n iniciada, en la que se inicializa el objeto chaiscript. </font><font style="vertical-align: inherit;">Con un par de macros, la tarea de introducir una nueva clase en un script se reduce a una descripci√≥n simple de todos los m√©todos que deben exportarse:</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">//      3D-: // rotation CHAI_IMPORT(&amp;GLInstance::RotateX, rotate_x); CHAI_IMPORT(&amp;GLInstance::RotateY, rotate_y); CHAI_IMPORT(&amp;GLInstance::RotateZ, rotate_z); // scale CHAI_IMPORT((GLInstance&amp;(GLInstance::*)(float))&amp;GLInstance::Scale, scale); CHAI_IMPORT((GLInstance&amp;(GLInstance::*)(float, float, float))&amp;GLInstance::Scale, scale); // translation CHAI_IMPORT(&amp;GLInstance::Translate, translate); CHAI_IMPORT(&amp;GLInstance::TranslateX, translate_x); CHAI_IMPORT(&amp;GLInstance::TranslateY, translate_y); CHAI_IMPORT(&amp;GLInstance::TranslateZ, translate_z); // hide / show CHAI_IMPORT(&amp;GLInstance::Hide, hide); CHAI_IMPORT(&amp;GLInstance::Show, show); // getters CHAI_IMPORT(&amp;GLInstance::GetTranslation, translation); CHAI_IMPORT(&amp;GLInstance::GetRotation, rotation); CHAI_IMPORT(&amp;GLInstance::GetScale, scale);</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Del mismo modo, se exportan varias clases m√°s, y luego todo se conecta entre s√≠ mediante funciones lambda declaradas directamente en el c√≥digo de inicializaci√≥n. Puede ver el resultado del script en la captura de pantalla: la </font></font><br><br><img src="https://habrastorage.org/webt/rl/bo/td/rlbotdpcfl4pdpbplwxfrvsk73i.png" alt="imagen"><br> <i><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">consola de chaiscript a ImGui: descarga e instalaci√≥n del objeto a trav√©s de comandos</font></font></i> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Dada la flexibilidad general de la biblioteca, cambiar el enfoque para exportar clases al script ser√° casi sencillo. Por supuesto, Lua tiene una documentaci√≥n m√°s extensa y una comunidad, y este lenguaje ser√≠a preferible si necesita obtener m√°s rendimiento del c√≥digo de script (JIT todav√≠a hace su trabajo), pero a√∫n as√≠ no debe descartar ChaiScript. Si tiene un proyecto peque√±o que necesita secuencias de comandos, puede experimentar con seguridad con las alternativas disponibles.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">En esta nota, me gustar√≠a completar este art√≠culo. </font><font style="vertical-align: inherit;">Si ya ten√≠a experiencia trabajando con lenguajes de secuencias de comandos dentro de C ++ (ya sea Lua u otro idioma), en los comentarios me complacer√° escuchar su opini√≥n sobre ChaiScript y las secuencias de comandos en general. </font><font style="vertical-align: inherit;">Tambi√©n agradezco cualquier pregunta o comentario sobre la publicaci√≥n. </font><font style="vertical-align: inherit;">Gracias a todos por leer.</font></font><br><br><h4>  Enlaces utiles </h4><br><ul><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sitio web oficial de </font><a href="http://chaiscript.com/"><font style="vertical-align: inherit;">ChaiScript</font></a><font style="vertical-align: inherit;"> : </font></font><a href="http://chaiscript.com/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">chaiscript.com</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Referencia r√°pida de sintaxis y biblioteca: </font></font><a href=""><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">hoja de trucos ChaiScript</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Documentaci√≥n oficial: </font></font><a href="https://codedocs.xyz/ChaiScript/ChaiScript/"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">codedocs.xyz/ChaiScript/ChaiScript</font></font></a> </li><li><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mi proyecto usando ChaiScript: </font></font><a href="https://github.com/MomoDeve/MomoEngine"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">github.com/MomoDeve/MomoEngine</font></font></a> </li></ul></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/483540/">https://habr.com/ru/post/483540/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../483528/index.html">REST API debe basarse en hipertexto</a></li>
<li><a href="../483530/index.html">C√≥mo hicimos un juego de mesa. ¬øPor qu√© y por qu√©?</a></li>
<li><a href="../483532/index.html">Conferencia DefCon 27: Detr√°s de escena de la creaci√≥n de insignias electr√≥nicas Parte 1</a></li>
<li><a href="../483536/index.html">La historia del microprocesador y la computadora personal: 1974 - 1980</a></li>
<li><a href="../483538/index.html">Conexi√≥n de una pantalla ER-TFT101-1 de 10 "al STM32F429 a trav√©s de FMC</a></li>
<li><a href="../483542/index.html">Resumen de telecomunicaciones: materiales sobre el trabajo de los proveedores</a></li>
<li><a href="../483544/index.html">Nueva suposici√≥n clave de refutaci√≥n de datos de energ√≠a oscura</a></li>
<li><a href="../483550/index.html">Servicio y desarrollo de IaaS: una compilaci√≥n de nube, almacenamiento de datos y evoluci√≥n de 1cloud</a></li>
<li><a href="../483552/index.html">MVVM y selecci√≥n de elementos en el adaptador</a></li>
<li><a href="../483554/index.html">Nueva plataforma tecnol√≥gica de los a√±os 20. ¬øPor qu√© no estoy de acuerdo con Zuckerberg?</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>