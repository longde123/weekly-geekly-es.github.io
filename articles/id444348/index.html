<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🧓🏽 ❓ 📘 Bagaimana komponen Bereaksi fungsional berbeda dari komponen berbasis kelas? 💅🏻 🔊 🧖🏻</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bagaimana komponen Bereaksi fungsional berbeda dari komponen berbasis kelas? Untuk beberapa waktu sekarang, jawaban tradisional untuk pertanyaan ini a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bagaimana komponen Bereaksi fungsional berbeda dari komponen berbasis kelas?</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/444348/">  Bagaimana komponen Bereaksi fungsional berbeda dari komponen berbasis kelas?  Untuk beberapa waktu sekarang, jawaban tradisional untuk pertanyaan ini adalah: "Penggunaan kelas memungkinkan Anda untuk menggunakan sejumlah besar fitur komponen, misalnya, menyatakan."  Sekarang, dengan munculnya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kait</a> , jawaban ini tidak lagi mencerminkan keadaan sebenarnya. <br><br>  Anda mungkin pernah mendengar bahwa salah satu dari jenis komponen ini memiliki kinerja yang lebih baik daripada yang lain.  Tapi yang mana?  Sebagian besar tolok ukur yang menguji ini memiliki <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kekurangan</a> , jadi saya akan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menarik kesimpulan</a> berdasarkan hasil mereka dengan sangat hati-hati.  Kinerja terutama tergantung pada apa yang terjadi dalam kode, dan bukan pada apakah komponen fungsional atau komponen berbasis kelas dipilih untuk mengimplementasikan kemampuan tertentu.  Studi kami menunjukkan bahwa perbedaan kinerja antara berbagai jenis komponen dapat diabaikan.  Namun, perlu dicatat bahwa strategi optimasi yang digunakan untuk bekerja dengannya sedikit <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berbeda</a> . <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/webt/x-/vn/je/x-vnjetrulggl4xjpo2jmitqjvg.jpeg"></a> <br><br>  Bagaimanapun, saya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak merekomendasikan</a> penulisan ulang komponen yang ada menggunakan teknologi baru jika tidak ada alasan yang baik untuk itu, dan jika Anda tidak keberatan berada di antara mereka yang mulai menggunakan teknologi ini sebelum orang lain.  Hooks masih merupakan teknologi baru (sama seperti React library pada 2014), dan beberapa "praktik terbaik" untuk aplikasi mereka belum dimasukkan dalam manual React. <br><a name="habracut"></a><br>  Ke mana akhirnya kami sampai?  Apakah ada perbedaan mendasar antara komponen fungsional React dan komponen berdasarkan kelas?  Tentu saja ada perbedaan seperti itu.  Ini adalah perbedaan dalam model mental menggunakan komponen tersebut.  Dalam artikel ini saya akan mempertimbangkan perbedaan paling serius mereka.  Itu sudah ada sejak, pada 2015, komponen fungsional muncul, tetapi sering diabaikan.  Terdiri dari fakta bahwa komponen fungsional menangkap nilai yang diberikan.  Mari kita bicara tentang apa artinya itu. <br><br>  Perlu dicatat bahwa bahan ini bukan merupakan upaya untuk mengevaluasi komponen dari berbagai jenis.  Saya hanya menjelaskan perbedaan antara dua model pemrograman dalam Bereaksi.  Jika Anda ingin tahu lebih banyak tentang penggunaan komponen fungsional berdasarkan inovasi - rujuk ke daftar pertanyaan dan jawaban tentang kaitan ini. <br><br><h2>  <font color="#3AC1EF">Apa saja fitur kode komponen berdasarkan fungsi dan kelas?</font> </h2><br>  Pertimbangkan komponen ini: <br><br><pre><code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {    alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + props.user);  };  <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {    setTimeout(showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>);  };  <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (    <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>  ); }</code> </pre> <br>  Ini menampilkan tombol, yang, dengan menekan fungsi <code>setTimeout</code> , mensimulasikan permintaan jaringan, dan kemudian menampilkan kotak pesan yang mengkonfirmasi operasi.  Misalnya, jika ' <code>props.user</code> <code>'Dan'</code> disimpan di <code>props.user</code> , maka di jendela pesan, setelah tiga detik, <code>'Followed Dan'</code> akan ditampilkan. <br><br>  Perhatikan bahwa tidak masalah jika fungsi tanda panah atau deklarasi fungsi digunakan di sini.  Konstruksi dari form <code>function handleClick()</code> akan bekerja dengan cara yang persis sama. <br><br>  Bagaimana cara menulis ulang komponen ini sebagai kelas?  Jika Anda baru saja mengulang kode yang baru saja diperiksa, mengubahnya menjadi kode komponen berdasarkan kelas, Anda mendapatkan yang berikut ini: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.user); }; handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } }</code> </pre> <br>  Secara umum diterima bahwa dua fragmen kode tersebut adalah setara.  Dan pengembang sering kali sepenuhnya bebas, dalam proses refactoring kode, mengubah satu menjadi yang lain, tanpa memikirkan konsekuensi yang mungkin terjadi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/1d3/c7a/341/1d3c7a341ee3fcadc79df00e7d872e4b.gif"></div><br>  <i><font color="#999999">Potongan-potongan kode ini tampaknya setara</font></i> <br><br>  Namun, ada sedikit perbedaan antara cuplikan kode ini.  Lihatlah lebih dekat pada mereka.  Lihat perbedaannya?  Misalnya, saya tidak langsung melihatnya. <br><br>  Selanjutnya kami akan mempertimbangkan perbedaan ini, oleh karena itu, bagi mereka yang ingin memahami esensi dari apa yang terjadi sendiri, contoh kerja dari kode ini. <br><br>  Sebelum kita melanjutkan, saya ingin menekankan bahwa perbedaan dalam pertanyaan tidak ada hubungannya dengan React hooks.  Dalam contoh sebelumnya, omong-omong, kait bahkan tidak digunakan.  Ini tentang perbedaan antara fungsi dan kelas dalam Bereaksi.  Dan jika Anda berencana untuk menggunakan banyak komponen fungsional dalam aplikasi Bereaksi Anda, maka Anda mungkin ingin memahami perbedaan ini. <br><br>  Sebagai soal fakta, kami akan menggambarkan perbedaan antara fungsi dan kelas dengan contoh kesalahan yang sering dijumpai dalam aplikasi Bereaksi. <br><br><h2>  <font color="#3AC1EF">Kesalahan yang biasa terjadi pada Bereaksi aplikasi.</font> </h2><br>  Buka <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">halaman contoh</a> yang menampilkan daftar yang memungkinkan Anda memilih profil pengguna, dan dua tombol <code>Follow</code> yang ditampilkan oleh <code>ProfilePageClass</code> dan <code>ProfilePageClass</code> , fungsional, dan berdasarkan kelas, kode yang ditunjukkan di atas. <br><br>  Coba, untuk masing-masing tombol ini, untuk melakukan urutan tindakan berikut: <br><br><ol><li>  Klik pada tombol. </li><li>  Ubah profil yang dipilih sebelum 3 detik berlalu setelah mengklik tombol. </li><li>  Baca teks yang ditampilkan di kotak pesan. </li></ol><br>  Setelah melakukan ini, Anda akan melihat fitur-fitur berikut: <br><br><ul><li>  Ketika Anda mengklik tombol yang dibentuk oleh komponen fungsional dengan profil <code>Dan</code> dipilih dan kemudian beralih ke profil <code>Sophie</code> , <code>'Followed Dan'</code> akan ditampilkan di kotak pesan. </li><li>  Jika Anda melakukan hal yang sama dengan tombol yang dibentuk oleh komponen berdasarkan kelas, <code>'Followed Sophie'</code> akan ditampilkan. </li></ul><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/386/a44/911/386a449110202d5140d67336a0ade5a0.gif"></div><br>  <i><font color="#999999">Fitur Komponen Berbasis Kelas</font></i> <br><br>  Dalam contoh ini, perilaku komponen fungsional sudah benar.  Jika saya berlangganan profil seseorang, dan kemudian beralih ke profil lain, komponen saya seharusnya tidak meragukan profil siapa saya berlangganan.  Jelas, implementasi mekanisme yang dimaksud berdasarkan penggunaan kelas mengandung kesalahan (ngomong-ngomong, Anda harus menjadi pelanggan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sofia</a> ). <br><br><h2>  <font color="#3AC1EF">Penyebab kerusakan komponen berbasis kelas</font> </h2><br>  Mengapa komponen berbasis kelas berperilaku seperti ini?  Untuk memahami ini, mari kita lihat metode <code>showMessage</code> di kelas kami: <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.user); };</code> </pre> <br>  Metode ini membaca data dari <code>this.props.user</code> .  Properti di Bereaksi tidak berubah, sehingga tidak berubah.  Namun, <code>this</code> , seperti biasa, adalah entitas yang bisa berubah. <br><br>  Sebenarnya, tujuan memiliki <code>this</code> di kelas terletak pada kemampuan <code>this</code> untuk berubah.  Pustaka Bereaksi itu sendiri secara berkala melakukan mutasi <code>this</code> , yang memungkinkan bekerja dengan versi terbaru dari metode <code>render</code> dan metode siklus hidup komponen. <br><br>  Akibatnya, jika komponen kami <code>this.props</code> ulang selama eksekusi permintaan, <code>this.props</code> akan berubah.  Setelah itu, metode <code>showMessage</code> membaca nilai <code>user</code> dari entitas properti "terlalu baru". <br><br>  Ini memungkinkan Anda untuk melakukan pengamatan menarik tentang antarmuka pengguna.  Jika kita mengatakan bahwa antarmuka pengguna, secara konseptual, adalah fungsi dari kondisi aplikasi saat ini, maka pengendali event adalah bagian dari hasil render - seperti hasil render yang terlihat.  Penangan acara kami "milik" operasi rendering tertentu bersama dengan properti dan keadaan tertentu. <br><br>  Namun, penjadwalan batas waktu dengan callback <code>this.props</code> berbunyi melanggar koneksi ini.  <code>showMessage</code> showMessage tidak "terikat" dengan operasi rendering tertentu, sebagai hasilnya, "kehilangan" properti yang benar.  Membaca data dari <code>this</code> memutuskan koneksi ini. <br><br><h2>  <font color="#3AC1EF">Bagaimana, dengan menggunakan komponen berbasis kelas, untuk memecahkan masalah?</font> </h2><br>  Bayangkan bahwa tidak ada komponen fungsional dalam Bereaksi.  Lalu bagaimana mengatasi masalah ini? <br><br>  Kami membutuhkan beberapa mekanisme untuk "mengembalikan" koneksi antara metode <code>render</code> dengan properti yang benar dan <code>showMessage</code> showMessage, yang membaca data dari properti.  Mekanisme ini harus ditempatkan di suatu tempat di mana esensi <code>props</code> dengan data yang benar hilang. <br><br>  Salah satu cara untuk melakukannya adalah dengan membaca <code>this.props</code> terlebih dahulu di event handler, dan kemudian secara eksplisit meneruskan apa yang dibacakan ke fungsi callback yang digunakan di <code>setTimeout</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ showMessage = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">user</span></span></span><span class="hljs-function">) =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + user); }; handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> {user} = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props;   setTimeout(<span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showMessage(user), <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } }</code> </pre> <br>  Pendekatan ini <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berhasil</a> .  Namun konstruksi tambahan yang digunakan di sini, seiring waktu, akan mengarah pada peningkatan volume kode dan fakta bahwa kemungkinan kesalahan di dalamnya akan meningkat.  Bagaimana jika kita membutuhkan lebih dari satu properti?  Bagaimana jika kita juga perlu bekerja dengan negara?  Jika metode <code>showMessage</code> metode lain dan metode ini membaca <code>this.props.something</code> atau <code>this.state.something</code> , maka kita akan kembali menghadapi masalah yang sama.  Dan untuk menyelesaikannya, kita harus meneruskan <code>this.props</code> dan <code>this.state</code> sebagai argumen untuk semua metode yang dipanggil dari <code>showMessage</code> . <br><br>  Jika itu benar untuk dilakukan, itu akan menghancurkan semua kenyamanan yang diberikan oleh komponen berdasarkan kelas.  Kenyataan bahwa Anda perlu bekerja dengan metode dengan cara ini sulit untuk diingat, sulit untuk mengotomatisasi, sebagai akibatnya, pengembang sering, daripada menggunakan metode yang sama, setuju bahwa ada kesalahan dalam proyek mereka. <br><br>  Demikian juga, menanamkan kode <code>alert</code> di <code>handleClick</code> tidak memecahkan masalah yang lebih global.  Kita perlu menyusun kode sehingga dapat dibagi menjadi banyak metode, tetapi juga agar kita dapat membaca properti dan menyatakan yang berhubungan dengan operasi rendering yang terkait dengan panggilan tertentu.  Masalah ini, omong-omong, bahkan tidak berlaku secara khusus untuk Bereaksi.  Anda dapat memainkannya di perpustakaan apa pun untuk mengembangkan antarmuka pengguna, yang menempatkan data dalam objek yang bisa berubah seperti <code>this</code> . <br><br>  Mungkin untuk mengatasi masalah ini, Anda dapat mengikat metode <code>this</code> di konstruktor? <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">constructor</span></span>(props) {   <span class="hljs-keyword"><span class="hljs-keyword">super</span></span>(props);   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showMessage = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showMessage.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>);   <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handleClick = <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.handleClick.bind(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>); } showMessage() {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.props.user); } handleClick() {   setTimeout(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>.showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); } render() {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{this.handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span>; } }</code> </pre> <br>  Tapi ini tidak menyelesaikan masalah kita.  Ingatlah bahwa kita membaca data dari <code>this.props</code> terlambat, dan tidak dalam sintaks yang digunakan!  Namun, masalah ini akan teratasi jika kita mengandalkan penutupan JavaScript. <br><br>  Pengembang sering mencoba menghindari penutupan, karena <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">tidak mudah untuk</a> memikirkan nilai-nilai yang, dari waktu ke waktu, tidak dapat bermutasi.  Tetapi properti di Bereaksi tidak berubah!  (Atau, minimal, ini sangat dianjurkan).  Hal ini memungkinkan Anda untuk berhenti menganggap penutupan sebagai sesuatu karena programmer dapat, seperti yang mereka katakan, "menembak dirinya sendiri di kaki". <br><br>  Ini berarti bahwa jika Anda “mengunci” properti atau keadaan operasi rendering tertentu dalam penutupan, Anda selalu dapat mengandalkannya untuk tidak berubah. <br><br><pre> <code class="javascript hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-class"> </span><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">extends</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">React</span></span></span><span class="hljs-class">.</span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">Component</span></span></span><span class="hljs-class"> </span></span>{ render() {   <span class="hljs-comment"><span class="hljs-comment">//  !   const props = this.props;   //    ,      render.   //   -   .   const showMessage = () =&gt; {     alert('Followed ' + props.user);   };   const handleClick = () =&gt; {     setTimeout(showMessage, 3000);   };   return &lt;button onClick={handleClick}&gt;Follow&lt;/button&gt;; } }</span></span></code> </pre> <br>  Seperti yang Anda lihat, di sini kita “menangkap” properti selama panggilan ke metode <code>render</code> . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fa4/83d/d56/fa483dd5699aac1350c57591770a49be.gif"></div><br>  <i><font color="#999999">Properti ditangkap oleh panggilan render</font></i> <br><br>  Dengan pendekatan ini, kode apa pun yang ditemukan dalam metode <code>render</code> (termasuk <code>showMessage</code> ) dijamin untuk melihat properti yang ditangkap selama panggilan tertentu ke metode ini.  Akibatnya, Bereaksi tidak lagi dapat menghentikan kita dari melakukan apa yang kita butuhkan. <br><br>  Dalam metode <code>render</code> , Anda bisa mendeskripsikan sebanyak mungkin fungsi bantu yang Anda inginkan dan semuanya akan dapat menggunakan properti dan status "yang ditangkap".  Inilah cara penutupan menyelesaikan masalah kami. <br><br><h2>  <font color="#3AC1EF">Analisis solusi untuk masalah menggunakan penutupan</font> </h2><br>  Apa yang baru saja kami lakukan memungkinkan kami untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menyelesaikan masalah</a> , tetapi kode seperti itu terlihat aneh.  Mengapa kelas diperlukan sama sekali jika fungsi dideklarasikan di dalam metode <code>render</code> , dan bukan sebagai metode kelas? <br><br>  Kami, pada kenyataannya, dapat menyederhanakan kode ini dengan menyingkirkan "shell" dalam bentuk kelas yang mengelilinginya: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">props</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + props.user); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (   <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); }</code> </pre> <br>  Di sini, seperti dalam contoh sebelumnya, properti ditangkap dalam fungsi, karena Bereaksi melewati mereka sebagai argumen.  Tidak seperti <code>this</code> , Bereaksi tidak pernah <code>props</code> objek <code>props</code> . <br><br>  Ini menjadi sedikit lebih jelas jika <code>props</code> dihancurkan dalam deklarasi fungsi: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">ProfilePage</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">{ user }</span></span></span><span class="hljs-function">) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'Followed '</span></span> + user); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (   <span class="xml"><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag"> </span></span><span class="hljs-attr"><span class="xml"><span class="hljs-tag"><span class="hljs-attr">onClick</span></span></span></span><span class="xml"><span class="hljs-tag">=</span></span><span class="hljs-string"><span class="xml"><span class="hljs-tag"><span class="hljs-string">{handleClick}</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span><span class="xml">Follow</span><span class="hljs-tag"><span class="xml"><span class="hljs-tag">&lt;/</span></span><span class="hljs-name"><span class="xml"><span class="hljs-tag"><span class="hljs-name">button</span></span></span></span><span class="xml"><span class="hljs-tag">&gt;</span></span></span></span> ); }</code> </pre> <br>  Ketika komponen induk <code>ProfilePage</code> dengan properti lain, React akan memanggil fungsi <code>ProfilePage</code> .  Tetapi event handler yang telah dipanggil milik panggilan sebelumnya ke fungsi ini, panggilan ini menggunakan nilai <code>user</code> sendiri dan <code>showMessage</code> showMessage sendiri, yang membaca nilai ini.  Semua ini tetap tidak tersentuh. <br><br>  Itulah sebabnya dalam versi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">asli</a> dari contoh kita, ketika bekerja dengan komponen fungsional, memilih profil lain setelah mengklik tombol yang sesuai sebelum pesan ditampilkan tidak mengubah apa pun.  Jika profil <code>Sophie</code> dipilih sebelum mengklik tombol, <code>'Followed Sophie'</code> akan ditampilkan di jendela pesan, apa pun yang terjadi. <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/843/96c/4b3/84396c4b3982827bead96912a947904e.gif"></div><br>  <i><font color="#999999">Menggunakan komponen fungsional</font></i> <br><br>  Perilaku ini benar (Anda mungkin juga ingin mendaftar untuk <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Sunil</a> ). <br><br>  Sekarang kita telah mengetahui apa perbedaan besar antara fungsi dan kelas di Bereaksi.  Seperti yang telah disebutkan, kita berbicara tentang fakta bahwa komponen fungsional menangkap nilai.  Sekarang mari kita bicara tentang kait. <br><br><h2>  <font color="#3AC1EF">Kait</font> </h2><br>  Saat menggunakan kait, prinsip "menangkap nilai" berlaku untuk negara.  Perhatikan contoh berikut: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MessageThread</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [message, setMessage] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'You said: '</span></span> + message); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleSendClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleMessageChange = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) =&gt;</span></span> {   setMessage(e.target.value); }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> (   &lt;&gt;     &lt;input value={message} onChange={handleMessageChange} /&gt;     &lt;button onClick={handleSendClick}&gt;Send&lt;/button&gt;   &lt;/&gt; ); }</code> </pre> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Di sini</a> Anda dapat bereksperimen dengannya <br><br>  Meskipun ini bukan contoh terbaik dari antarmuka aplikasi pesan, proyek ini menggambarkan ide yang sama: jika pengguna mengirim pesan, komponen tidak boleh bingung tentang pesan mana yang dikirim.  Konstanta <code>message</code> dari komponen fungsional ini menangkap status "milik" dari komponen yang menjadikan browser pengendali klik untuk tombol yang dipanggil.  Akibatnya, <code>message</code> menyimpan apa yang ada di bidang input pada saat mengklik tombol <code>Send</code> . <br><br><h2>  <font color="#3AC1EF">Masalah menangkap properti dan status oleh komponen fungsional</font> </h2><br>  Kita tahu bahwa komponen fungsional dalam Bereaksi, secara default, menangkap properti dan status.  Tetapi bagaimana jika kita perlu membaca data terbaru dari properti atau negara bagian yang tidak termasuk pemanggilan fungsi tertentu?  Bagaimana jika kita ingin " <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">membacanya dari masa depan</a> "? <br><br>  Dalam komponen berbasis kelas, ini bisa dilakukan hanya dengan merujuk <code>this.props</code> atau <code>this.state</code> , karena <code>this</code> adalah entitas yang bisa berubah.  Perubahannya terlibat dalam Bereaksi.  Komponen fungsional juga dapat bekerja dengan nilai yang dapat diubah yang dibagi oleh semua komponen.  Nilai-nilai ini disebut <code>ref</code> : <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MyComponent</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> ref = useRef(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-comment"><span class="hljs-comment">//     `ref.current`. // ... }</span></span></code> </pre> <br>  Namun, programmer perlu mengelola nilai-nilai tersebut secara mandiri. <br><br>  Inti dari <code>ref</code> memainkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">peran yang</a> sama dengan bidang instance kelas.  Ini adalah "pintu darurat" ke dunia imperatif yang bisa berubah.  Anda mungkin akrab dengan konsep referensi DOM, tetapi ide ini jauh lebih umum.  Ini dapat dibandingkan dengan kotak di mana programmer dapat meletakkan sesuatu. <br><br>  Bahkan secara eksternal, konstruksi dari bentuk ini. <code>this.something</code> seperti cermin dari konstruksi <code>something.current</code> .  Mereka adalah representasi dari konsep yang sama. <br><br>  Secara default, Bereaksi tidak membuat entitas <code>ref</code> dalam komponen fungsional untuk nilai properti atau status terkini.  Dalam banyak kasus, Anda tidak akan membutuhkannya, dan pembuatan otomatisnya akan membuang-buang waktu.  Namun, bekerja dengan mereka, jika perlu, dapat diatur sendiri: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MessageThread</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [message, setMessage] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> latestMessage = useRef(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> showMessage = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   alert(<span class="hljs-string"><span class="hljs-string">'You said: '</span></span> + latestMessage.current); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleSendClick = <span class="hljs-function"><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> =&gt;</span></span> {   setTimeout(showMessage, <span class="hljs-number"><span class="hljs-number">3000</span></span>); }; <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> handleMessageChange = <span class="hljs-function"><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">e</span></span></span><span class="hljs-function">) =&gt;</span></span> {   setMessage(e.target.value);   latestMessage.current = e.target.value; };</code> </pre> <br>  Jika kita membaca <code>message</code> di <code>showMessage</code> , maka kita akan melihat pesan yang ada di kolom pada saat mengklik tombol <code>Send</code> .  Tetapi jika Anda membaca <code>latestMessage.current</code> , Anda bisa mendapatkan nilai terbaru - bahkan jika kami terus memasukkan teks di lapangan setelah mengklik tombol <code>Send</code> . <br><br>  Anda dapat membandingkan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> dan contoh <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">ini</a> untuk mengevaluasi perbedaan secara independen.  Nilai <code>ref</code> adalah cara "menghindari" keseragaman rendering, dalam beberapa kasus itu bisa sangat berguna. <br><br>  Secara umum, Anda harus menghindari membaca atau menulis nilai <code>ref</code> selama proses rendering karena nilai-nilai ini bisa berubah.  Kami berusaha agar rendering dapat diprediksi.  Namun, jika kita perlu mendapatkan nilai terbaru dari sesuatu yang disimpan di properti atau dalam keadaan, memperbarui nilai <code>ref</code> secara manual bisa menjadi tugas yang membosankan.  Itu dapat diotomatisasi menggunakan efek: <br><br><pre> <code class="javascript hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MessageThread</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>) </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> [message, setMessage] = useState(<span class="hljs-string"><span class="hljs-string">''</span></span>); <span class="hljs-comment"><span class="hljs-comment">//    . const latestMessage = useRef(''); useEffect(() =&gt; {   latestMessage.current = message; }); const showMessage = () =&gt; {   alert('You said: ' + latestMessage.current); };</span></span></code> </pre> <br>  → <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Ini adalah</a> contoh yang menggunakan kode ini <br><br>  Kami memberikan nilai di dalam efek, sebagai hasilnya, nilai <code>ref</code> hanya akan berubah setelah DOM diperbarui.  Ini memastikan bahwa mutasi kami tidak mengganggu fitur seperti <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Time Slicing dan Suspense</a> , yang bergantung pada kontinuitas operasi rendering. <br><br>  Menggunakan nilai <code>ref</code> dengan cara ini tidak sering dibutuhkan.  Menangkap sifat atau keadaan biasanya tampak sebagai pola perilaku sistem standar yang jauh lebih baik.  Namun, ini bisa nyaman saat bekerja dengan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">API imperatif</a> , seperti yang menggunakan interval atau langganan.  Ingatlah bahwa Anda dapat bekerja dengan cara ini dengan nilai apa pun - dengan properti, dengan variabel yang disimpan di negara bagian, dengan seluruh objek <code>props</code> atau bahkan dengan fungsi. <br><br>  Pola ini, di samping itu, mungkin berguna untuk keperluan optimasi.  Misalnya, ketika sesuatu seperti <code>useCallback</code> berubah terlalu sering.  Benar, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">solusi yang disukai adalah</a> sering <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menggunakan peredam</a> . <br><br><h2>  <font color="#3AC1EF">Ringkasan</font> </h2><br>  Pada artikel ini, kami melihat salah satu pola yang salah untuk menggunakan komponen berbasis kelas dan berbicara tentang bagaimana menyelesaikan masalah ini dengan penutupan.  Namun, Anda mungkin memperhatikan bahwa ketika Anda mencoba untuk mengoptimalkan kait dengan menentukan susunan dependensi, Anda mungkin mengalami kesalahan terkait dengan penutupan yang ketinggalan zaman.  Apakah ini berarti bahwa kesalahan itu sendiri adalah masalah.  Saya kira tidak. <br><br>  Seperti yang ditunjukkan di atas, penutupan, pada kenyataannya, membantu kami memperbaiki masalah kecil yang sulit diperhatikan.  Mereka, juga, membuatnya lebih mudah untuk menulis kode yang bekerja dengan benar secara <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">paralel</a> .  Hal ini dimungkinkan karena fakta bahwa di dalam komponen, properti dan status yang benar dengan komponen yang diberikan ini "dikunci". <br><br>  Dalam semua kasus yang saya lihat sejauh ini, masalah "penutupan usang" terjadi karena asumsi yang salah bahwa "fungsi tidak berubah", atau bahwa "properti selalu tetap sama".  Saya harap setelah membaca materi ini, Anda yakin bahwa ini tidak benar. <br><br>  Fungsi “menangkap” sifat dan statusnya - dan karenanya memahami fungsi mana yang dipertanyakan juga penting.  Ini bukan kesalahan, itu adalah fitur komponen fungsional.  Fungsi tidak boleh dikecualikan dari "array dependensi" untuk <code>useEffect</code> atau <code>useCalback</code> , misalnya.  (Alat yang cocok untuk menyelesaikan masalah biasanya menggunakan <code>useReducer</code> atau <code>useRef</code> . Kami membicarakan hal ini di atas, dan segera kami akan menyiapkan bahan yang akan dikhususkan untuk pilihan pendekatan ini atau itu). <br><br>  Jika sebagian besar kode dalam aplikasi kita akan didasarkan pada komponen fungsional, ini berarti bahwa kita perlu tahu lebih banyak tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">optimasi kode</a> , dan nilai apa yang dapat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">berubah</a> dari waktu ke waktu. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="></a>     : «  ,   ,    ,   ,    ,         ». <br><br>          .  ,        React    ,   .     ,    « »,     . ,         React  . <br><br>      ,      ,   . <br><br><div style="text-align:center;"><img src="https://habrastorage.org/getpro/habr/post_images/fc3/bdd/f6d/fc3bddf6d4ca14bc77917ac0cfad3608.gif"></div><br> <i><font color="#999999">  React —    </font></i> <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id444348/">https://habr.com/ru/post/id444348/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id444338/index.html">Enkapsulasi dalam Python 3</a></li>
<li><a href="../id444340/index.html">Fitur menggunakan tipe data Simbol dalam JavaScript</a></li>
<li><a href="../id444342/index.html">Mengembangkan aplikasi JavaScript sederhana dan modern menggunakan Webpack dan teknologi web canggih</a></li>
<li><a href="../id444344/index.html">10 langkah untuk proyek Python yang sukses</a></li>
<li><a href="../id444346/index.html">GraphQL dan Golang</a></li>
<li><a href="../id444350/index.html">Untuk beberapa alasan MVP (produk minimum yang layak) tidak dimulai</a></li>
<li><a href="../id444352/index.html">Kontur.Kampus: kami mengundang Anda ke kemah mahasiswa gratis pengembangan industri dekat St. Petersburg</a></li>
<li><a href="../id444356/index.html">React Tutorial Bagian 24: Pelajaran Bentuk Kedua</a></li>
<li><a href="../id444358/index.html">Enumerable: Cara menghasilkan nilai bisnis</a></li>
<li><a href="../id444360/index.html">Ketidakadilan Google Play sebagai pengalaman hidup yang baik</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>