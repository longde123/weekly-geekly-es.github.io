<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï¥üèø üëÜüèº üç≤ ConfigureAwait: H√§ufig gestellte Fragen üíô üì¥ ‚öôÔ∏è</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Hallo habr Ich pr√§sentiere Ihnen die √úbersetzung des FAQ- Artikels zu ConfigureAwait von Stephen Taub. 



 Async / await √ºber sieben Jahren zu .NET h...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>ConfigureAwait: H√§ufig gestellte Fragen</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/482354/"> Hallo habr  Ich pr√§sentiere Ihnen die √úbersetzung des <a href="https://devblogs.microsoft.com/dotnet/configureawait-faq/" rel="nofollow">FAQ-</a> Artikels zu <a href="https://devblogs.microsoft.com/dotnet/configureawait-faq/" rel="nofollow">ConfigureAwait</a> von Stephen Taub. <br><br><img src="https://habrastorage.org/webt/ps/pj/sm/pspjsmmgsimr2lachonj6idmnj8.png" alt="Bild"><br><br>  <code>Async</code> / <code>await</code> √ºber sieben Jahren zu .NET hinzugef√ºgt.  Diese Entscheidung hatte nicht nur erhebliche Auswirkungen auf das .NET-√ñkosystem, sondern spiegelt sich auch in vielen anderen Sprachen und Frameworks wider.  Derzeit wurden viele Verbesserungen in .NET in Bezug auf zus√§tzliche Sprachkonstrukte implementiert, die Asynchronit√§t verwenden, APIs mit Asynchronit√§tsunterst√ºtzung wurden implementiert, grundlegende Verbesserungen in der Infrastruktur wurden vorgenommen, dank derer <code>async</code> / <code>await</code> wie eine Uhr funktioniert (insbesondere wurden Leistung und Diagnosefunktionen verbessert) in .NET Core). <br><br>  <code>ConfigureAwait</code> ist ein Aspekt von <code>async</code> / <code>await</code> , der weiterhin Fragen <code>async</code> .  Ich hoffe, ich kann viele von ihnen beantworten.  Ich werde versuchen, diesen Artikel von Anfang bis Ende lesbar zu machen und ihn gleichzeitig im Stil von Antworten auf h√§ufig gestellte Fragen (FAQ) auszuf√ºhren, damit in Zukunft auf ihn verwiesen werden kann. <a name="habracut"></a><br><br>  Um wirklich mit <code>ConfigureAwait</code> umzugehen, werden wir ein wenig zur√ºckgehen. <br><br><h3>  Was ist ein SynchronizationContext? </h3><br>  Gem√§√ü der <a href="https://docs.microsoft.com/en-us/dotnet/api/system.threading.synchronizationcontext%3Fview%3Dnetframework-4.8" rel="nofollow">System.Threading.SynchronizationContext-</a> Dokumentation "Bietet grundlegende Funktionen zum Verteilen des Synchronisationskontexts in verschiedenen Synchronisationsmodellen."  Diese Definition ist nicht ganz offensichtlich. <br><br>  In 99,9% der F√§lle wird der <code>SynchronizationContext</code> einfach als Typ mit einer virtuellen <code>Post</code> Methode verwendet, die einen Delegaten f√ºr die asynchrone Ausf√ºhrung akzeptiert (der <code>SynchronizationContext</code> andere virtuelle Mitglieder, die jedoch seltener vorkommen und in diesem Artikel nicht behandelt werden).  Die <code>Post</code> Methode des Basistyps <a href="" rel="nofollow">ruft</a> <code>ThreadPool.QueueUserWorkItem</code> <a href="" rel="nofollow">einfach</a> auf, um den angegebenen Delegaten asynchron auszuf√ºhren.  Abgeleitete Typen √ºberschreiben " <code>Post</code> damit der Delegat zur richtigen Zeit am richtigen Ort ausgef√ºhrt werden kann. <br><br>  Beispielsweise verf√ºgt Windows Forms √ºber einen von SynchronizationContext abgeleiteten <a href="" rel="nofollow">Typ</a> , der <code>Post</code> neu definiert, dass er <code>Control.BeginInvoke</code> .  Dies bedeutet, dass jeder Aufruf dieser <code>Post</code> Methode zu einem sp√§teren Zeitpunkt zu einem Aufruf an den Delegaten in dem Thread f√ºhrt, der dem entsprechenden Steuerelement zugeordnet ist - dem sogenannten UI-Thread.  Das Herzst√ºck von Windows Forms ist die Win32-Nachrichtenverarbeitung.  Die Nachrichtenschleife wird in einem UI-Thread ausgef√ºhrt, der nur darauf wartet, dass neue Nachrichten verarbeitet werden.  Diese Meldungen werden durch Mausbewegungen, Klicken, Tastatureingaben, Systemereignisse ausgel√∂st, die f√ºr die Ausf√ºhrung durch Stellvertreter verf√ºgbar sind. Wenn Sie also eine <code>SynchronizationContext</code> Instanz f√ºr einen UI-Thread in einer Windows Forms-Anwendung haben, m√ºssen Sie den Stellvertreter an die <code>Post</code> Methode √ºbergeben, um darin einen Vorgang auszuf√ºhren. <br><br>  Windows Presentation Foundation (WPF) verf√ºgt auch √ºber einen von <code>SynchronizationContext</code> abgeleiteten <a href="" rel="nofollow">Typ</a> mit einer √ºberschriebenen <code>Post</code> Methode, die den Delegaten auf √§hnliche Weise (mithilfe von <code>Dispatcher.BeginInvoke</code> ) mit WPF Dispatcher-Steuerelement und nicht mit Windows Forms Control an den UI-Stream ‚Äûleitet‚Äú. <br><br>  Und Windows RunTime (WinRT) verf√ºgt √ºber einen eigenen von <code>SynchronizationContext</code> abgeleiteten <a href="" rel="nofollow">Typ</a> , der den Delegaten mithilfe von <code>CoreDispatcher</code> auch in die UI- <code>CoreDispatcher</code> . <br><br>  Dies ist, was hinter der Phrase "Run Delegate in UI-Thread" liegt.  Sie k√∂nnen Ihren <code>SynchronizationContext</code> mit der <code>Post</code> Methode und einigen Implementierungen implementieren.  Beispielsweise muss ich mir keine Gedanken dar√ºber machen, in welchem ‚Äã‚ÄãThread der Stellvertreter ausgef√ºhrt wird, aber ich m√∂chte sicherstellen, dass alle <code>Post</code> Methode in meinem <code>SynchronizationContext</code> mit einem begrenzten Grad an Parallelit√§t ausgef√ºhrt werden.  Sie k√∂nnen einen benutzerdefinierten <code>SynchronizationContext</code> implementieren: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">internal</span></span> <span class="hljs-keyword"><span class="hljs-keyword">sealed</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">MaxConcurrencySynchronizationContext</span></span> : <span class="hljs-title"><span class="hljs-title">SynchronizationContext</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> SemaphoreSlim _semaphore; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">MaxConcurrencySynchronizationContext</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params"> maxConcurrencyLevel</span></span></span><span class="hljs-function">)</span></span> =&gt; _semaphore = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SemaphoreSlim(maxConcurrencyLevel); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Post</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SendOrPostCallback d, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> state</span></span></span><span class="hljs-function">)</span></span> =&gt; _semaphore.WaitAsync().ContinueWith(<span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { d(state); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { _semaphore.Release(); } }, <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, TaskContinuationOptions.None, TaskScheduler.Default); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">override</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Send</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">SendOrPostCallback d, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> state</span></span></span><span class="hljs-function">)</span></span> { _semaphore.Wait(); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { d(state); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { _semaphore.Release(); } } }</code> </pre> <br>  Das xUnit-Framework verf√ºgt √ºber eine √§hnliche <a href="" rel="nofollow">Implementierung von</a> SynchronizationContext.  Hier wird es verwendet, um die Menge an Code zu reduzieren, die mit parallelen Tests verbunden ist. <br><br>  Die Vorteile sind dieselben wie bei jeder Abstraktion: Es wird eine einzige API bereitgestellt, mit der der Delegierte f√ºr die Ausf√ºhrung in die Warteschlange gestellt werden kann, wie es der Programmierer w√ºnscht, ohne die Implementierungsdetails kennen zu m√ºssen.  Angenommen, ich schreibe eine Bibliothek, in der ich etwas arbeiten muss, und stelle dann einen Delegierten in den urspr√ºnglichen Kontext zur√ºck.  Dazu muss ich den <code>SynchronizationContext</code> des Kontexts erfassen. Wenn ich die erforderlichen Schritte abgeschlossen habe, muss ich nur die <code>Post</code> Methode dieses Kontexts aufrufen und sie zur Ausf√ºhrung an einen Delegaten √ºbergeben.  Ich muss nicht wissen, dass Sie f√ºr Windows Forms die <code>Control</code> √ºbernehmen und <code>BeginInvoke</code> , f√ºr WPF <code>BeginInvoke</code> von <code>Dispatcher</code> oder den Kontext und die Warteschlange f√ºr xUnit abrufen m√ºssen.  Ich muss nur den aktuellen <code>SynchronizationContext</code> und sp√§ter verwenden.  Zu diesem <code>SynchronizationContext</code> verf√ºgt der <code>SynchronizationContext</code> √ºber eine <code>Current</code> Eigenschaft.  Dies kann wie folgt implementiert werden: <br><br><pre> <code class="cs hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">public</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">DoWork</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">Action worker, Action completion</span></span></span><span class="hljs-function">)</span></span> { SynchronizationContext sc = SynchronizationContext.Current; ThreadPool.QueueUserWorkItem(_ =&gt; { <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { worker(); } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { sc.Post(_ =&gt; completion(), <span class="hljs-literal"><span class="hljs-literal">null</span></span>); } }); }</code> </pre> <br>  Sie k√∂nnen einen speziellen Kontext in der <code>Current</code> Eigenschaft mit der <code>SynchronizationContext.SetSynchronizationContext</code> Methode festlegen. <br><br><h3>  Was ist ein Taskplaner? </h3><br>  <code>SynchronizationContext</code> ist eine gebr√§uchliche Abstraktion f√ºr den "Scheduler".  Einige Frameworks verwenden daf√ºr ihre eigenen Abstraktionen, und <code>System.Threading.Tasks</code> keine Ausnahme.  Wenn sich in der <code>Task</code> <code>System.Threading.Tasks.TaskScheduler</code> befinden, die in die Warteschlange gestellt und ausgef√ºhrt werden k√∂nnen, werden sie mit <code>System.Threading.Tasks.TaskScheduler</code> .  Es gibt auch eine virtuelle <code>Post</code> Methode zum Einreihen eines Delegaten (ein Delegatenaufruf wird mithilfe von Standardmechanismen implementiert). <code>TaskScheduler</code> stellt eine abstrakte <code>QueueTask</code> Methode <code>QueueTask</code> (ein <code>QueueTask</code> wird mithilfe der <code>ExecuteTask</code> Methode implementiert). <br><br>  Der Standard-Scheduler, der <code>TaskScheduler.Default</code> ist ein Thread-Pool.  In <code>TaskScheduler</code> k√∂nnen auch Methoden zum Festlegen von Zeitpunkt und Ort des <code>TaskScheduler</code> und √ºberschrieben werden.  Zu den Kernbibliotheken geh√∂rt beispielsweise der Typ <code>System.Threading.Tasks.ConcurrentExclusiveSchedulerPair</code> .  Eine Instanz dieser Klasse bietet zwei <code>TaskScheduler</code> Eigenschaften: <code>ExclusiveScheduler</code> und <code>ConcurrentScheduler</code> .  Im <code>ConcurrentScheduler</code> geplante Aufgaben k√∂nnen parallel ausgef√ºhrt werden, wobei jedoch die vom <code>ConcurrentExclusiveSchedulerPair</code> beim <code>MaxConcurrencySynchronizationContext</code> festgelegte Einschr√§nkung ber√ºcksichtigt wird (√§hnlich wie bei <code>MaxConcurrencySynchronizationContext</code> ).  Es wird keine <code>ConcurrentScheduler</code> Aufgabe ausgef√ºhrt, wenn die Aufgabe in <code>ExclusiveScheduler</code> und jeweils nur eine exklusive Aufgabe ausgef√ºhrt werden darf.  Dieses Verhalten ist einer Lese- / Schreibsperre sehr √§hnlich. <br><br>  Wie <code>SynchronizationContext</code> verf√ºgt <code>TaskScheduler</code> √ºber eine <code>Current</code> Eigenschaft, die den aktuellen <code>TaskScheduler</code> .  Im Gegensatz zu <code>SynchronizationContext</code> fehlt jedoch eine Methode zum Festlegen des aktuellen Schedulers.  Stattdessen ist der Scheduler der aktuellen Aufgabe zugeordnet.  So zeigt dieses Programm beispielsweise <code>True</code> , da das in <code>StartNew</code> verwendete Lambda in der <code>ExclusiveScheduler</code> Instanz von <code>ConcurrentExclusiveSchedulerPair</code> wird und <code>TaskScheduler.Current</code> auf diesem Scheduler installiert <code>TaskScheduler.Current</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> System.Threading.Tasks; <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">Program</span></span> { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">static</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Main</span></span></span><span class="hljs-function">(</span><span class="hljs-params"></span><span class="hljs-function"><span class="hljs-params"></span>)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> cesp = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> ConcurrentExclusiveSchedulerPair(); Task.Factory.StartNew(() =&gt; { Console.WriteLine(TaskScheduler.Current == cesp.ExclusiveScheduler); }, <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>, TaskCreationOptions.None, cesp.ExclusiveScheduler).Wait(); } }</code> </pre> <br>  Interessanterweise bietet <code>TaskScheduler</code> eine statische <code>FromCurrentSynchronizationContext</code> Methode.  Die Methode erstellt einen neuen <code>TaskScheduler</code> und stellt die auszuf√ºhrenden Tasks mithilfe der <code>Post</code> Methode in den zur√ºckgegebenen <code>SynchronizationContext.Current</code> Kontext. <br><br><h3>  In welcher Beziehung stehen SynchronizationContext und TaskScheduler zum Warten? </h3><br>  Angenommen, Sie m√ºssen eine UI-Anwendung mit einer Schaltfl√§che schreiben.  Durch Dr√ºcken der Taste wird der Download von Text von der Website gestartet und auf die Schaltfl√§che <code>Content</code> .  Der Zugriff auf die Schaltfl√§che sollte nur √ºber die Benutzeroberfl√§che des Streams erfolgen, in dem sie sich befindet. Wenn wir Datum und Uhrzeit erfolgreich laden und sie in den <code>Content</code> der Schaltfl√§che <code>Content</code> m√∂chten, m√ºssen wir dies √ºber den Stream tun, der die Kontrolle √ºber sie hat.  Wenn diese Bedingung nicht erf√ºllt ist, erhalten wir eine Ausnahme: <br><br><pre> <code class="cs hljs">System.InvalidOperationException: <span class="hljs-string"><span class="hljs-string">'        ,     .'</span></span></code> </pre><br>  Wir k√∂nnen den <code>SynchronizationContext</code> manuell verwenden, um den <code>Content</code> im <code>TaskScheduler</code> , z. B. √ºber <code>TaskScheduler</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HttpClient s_httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBtn_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { s_httpClient.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"http://example.com/currenttime"</span></span>).ContinueWith(downloadTask =&gt; { downloadBtn.Content = downloadTask.Result; }, TaskScheduler.FromCurrentSynchronizationContext()); }</code> </pre> <br>  Und wir k√∂nnen den <code>SynchronizationContext</code> direkt verwenden: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HttpClient s_httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBtn_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { SynchronizationContext sc = SynchronizationContext.Current; s_httpClient.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"http://example.com/currenttime"</span></span>).ContinueWith(downloadTask =&gt; { sc.Post(<span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> { downloadBtn.Content = downloadTask.Result; }, <span class="hljs-literal"><span class="hljs-literal">null</span></span>); }); }</code> </pre> <br>  Beide Optionen verwenden jedoch explizit einen R√ºckruf.  Stattdessen k√∂nnen wir <code>async</code> / <code>await</code> : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HttpClient s_httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBtn_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> s_httpClient.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"http://example.com/currenttime"</span></span>); downloadBtn.Content = text; }</code> </pre> <br>  All dies ‚Äûfunktioniert einfach‚Äú und konfiguriert den <code>Content</code> im UI-Thread erfolgreich, da das Warten auf eine Aufgabe bei der oben manuell implementierten Version standardm√§√üig auf <code>SynchronizationContext.Current</code> und <code>TaskScheduler.Current</code> .  Wenn Sie in C # etwas ‚Äûerwarten‚Äú, konvertiert der Compiler den Code zum <code>GetAwaiter</code> (durch Aufrufen von <code>GetAwaiter</code> ) des ‚Äûerwarteten‚Äú (in diesem Fall Task) in ‚ÄûWarten‚Äú ( <code>TaskAwaiter</code> ).  Das "Warten" ist verantwortlich f√ºr das Anh√§ngen eines R√ºckrufs (oft als "Fortsetzung" bezeichnet), der nach Beendigung des Wartens zum Zustandsautomaten zur√ºckruft.  Er implementiert dies mit dem Kontext / Scheduler, den er bei der Callback-Registrierung erfasst hat.  Wir werden ein bisschen optimieren und konfigurieren, es ist ungef√§hr so: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> scheduler = SynchronizationContext.Current; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scheduler <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; TaskScheduler.Current != TaskScheduler.Default) { scheduler = TaskScheduler.Current; }</code> </pre> <br>  Hier wird zun√§chst gepr√ºft, ob der <code>SynchronizationContext</code> ist und wenn nicht, ob ein nicht standardm√§√üiger <code>TaskScheduler</code> .  Wenn einer vorhanden ist, wird der erfasste Scheduler verwendet, wenn der R√ºckruf f√ºr den Anruf bereit ist.  Andernfalls wird der R√ºckruf als Teil des Vorgangs ausgef√ºhrt, der die erwartete Aufgabe abschlie√üt. <br><br><h3>  Was macht ConfigureAwait (false) </h3><br>  Die <code>ConfigureAwait</code> Methode ist nicht speziell: Sie wird weder vom Compiler noch von der Laufzeit auf bestimmte Weise erkannt.  Dies ist eine normale Methode, die eine Struktur zur√ºckgibt ( <code>ConfiguredTaskAwaitable</code> - umschlie√üt die urspr√ºngliche Aufgabe) und einen Booleschen Wert annimmt.  Denken Sie daran, dass <code>await</code> mit jedem Typ verwendet werden kann, der das richtige Muster implementiert.  Wenn ein anderer Typ zur√ºckgegeben wird, bedeutet dies, dass der Compiler Zugriff auf die <code>GetAwaiter</code> Methode (Teil des Musters) der Instanzen erh√§lt, dies jedoch vom von <code>ConfigureAwait</code> Typ und nicht direkt von der Task.  Auf diese Weise k√∂nnen Sie das Warteverhalten f√ºr diesen speziellen Kellner √§ndern. <br><br>  Das Warten auf den von <code>ConfigureAwait(continueOnCapturedContext: false)</code> Typ <code>ConfigureAwait(continueOnCapturedContext: false)</code> anstatt auf <code>Task</code> warten, wirkt sich direkt auf die oben beschriebene Implementierung der Kontext- / Scheduler-Erfassung aus.  Die Logik wird ungef√§hr so: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">object</span></span> scheduler = <span class="hljs-literal"><span class="hljs-literal">null</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (continueOnCapturedContext) { scheduler = SynchronizationContext.Current; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> (scheduler <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-literal"><span class="hljs-literal">null</span></span> &amp;&amp; TaskScheduler.Current != TaskScheduler.Default) { scheduler = TaskScheduler.Current; } }</code> </pre> <br>  Mit anderen Worten, wenn Sie <code>false</code> angeben, bedeutet dies, dass der R√ºckruf nicht vorhanden ist, auch wenn ein aktueller Kontext oder Planer vorhanden ist. <br><br><h3>  Warum muss ich ConfigureAwait (false) verwenden? </h3><br>  <code>ConfigureAwait(continueOnCapturedContext: false)</code> verwendet, um zu verhindern, dass der R√ºckruf gezwungen wird, den Quellkontext oder den Scheduler aufzurufen.  Dies gibt uns mehrere Vorteile: <br><br>  <b>Leistungssteigerung.</b>  Im Gegensatz zum reinen Anrufen entsteht beim Einreihen eines R√ºckrufs ein Mehraufwand, da dies zus√§tzlichen Arbeitsaufwand (und in der Regel zus√§tzliche Zuordnung) erfordert.  Au√üerdem k√∂nnen wir zur Laufzeit keine Optimierung verwenden (wir k√∂nnen mehr optimieren, wenn wir genau wissen, wie der R√ºckruf aufgerufen wird, aber wenn er an eine beliebige Implementierung der Abstraktion √ºbergeben wird, sind manchmal Einschr√§nkungen erforderlich).  Bei stark belasteten Abschnitten k√∂nnen selbst die zus√§tzlichen Kosten f√ºr die √úberpr√ºfung des aktuellen <code>SynchronizationContext</code> und des aktuellen <code>TaskScheduler</code> (die beide den Zugriff auf die statischen Fl√ºsse implizieren) den Overhead erheblich erh√∂hen.  Wenn f√ºr den Code nach dem <code>await</code> keine Ausf√ºhrung im urspr√ºnglichen Kontext mithilfe von <code>ConfigureAwait(false)</code> erforderlich ist, k√∂nnen alle diese Ausgaben vermieden werden, da er nicht unn√∂tig in die Warteschlange gestellt werden muss, alle verf√ºgbaren Optimierungen verwendet und auch unn√∂tigen Zugriff auf die Stream-Statik vermieden werden kann. <br><br>  <b>Deadlock-Pr√§vention.</b>  Betrachten Sie die Bibliotheksmethode, <code>await</code> zum Herunterladen von Daten aus dem Netzwerk verwendet wird.  Sie rufen diese Methode auf und blockieren sie synchron und warten auf den Abschluss der Aufgabe, z. B. mit <code>.Wait()</code> oder <code>.Result</code> oder <code>.GetAwaiter()</code> <code>.GetResult()</code> .  <code>MaxConcurrencySynchronizationContext</code> , was passiert, wenn der Aufruf erfolgt, wenn der aktuelle <code>SynchronizationContext</code> die Anzahl der darin enthaltenen Vorg√§nge explizit mithilfe von <code>MaxConcurrencySynchronizationContext</code> auf 1 <code>MaxConcurrencySynchronizationContext</code> oder implizit, wenn es sich um einen Kontext mit einem einzelnen Thread handelt, der verwendet werden soll (z. B. ein UI-Thread).  Auf diese Weise rufen Sie die Methode in einem einzelnen Thread auf und blockieren sie, bis der Vorgang abgeschlossen ist.  Der Download startet √ºber das Netzwerk und wartet auf den Abschluss.  Wenn Sie auf eine <code>Task</code> warten, <code>Task</code> standardm√§√üig der aktuelle <code>SynchronizationContext</code> (und in diesem Fall) erfasst. Wenn der Download vom Netzwerk abgeschlossen ist, wird er in die Warteschlange des <code>SynchronizationContext</code> R√ºckrufs gestellt, der den Rest des Vorgangs aufruft.  Der einzige Thread, der den R√ºckruf in der Warteschlange verarbeiten kann, wird derzeit blockiert, w√§hrend auf den Abschluss des Vorgangs gewartet wird.  Dieser Vorgang wird erst abgeschlossen, wenn der R√ºckruf verarbeitet wurde.  Deadlock!  Dies kann auch dann auftreten, wenn der Kontext die Parallelit√§t nicht auf 1 beschr√§nkt, die Ressourcen jedoch in gewisser Weise begrenzt sind.  Stellen Sie sich dieselbe Situation nur mit einem Wert von 4 f√ºr <code>MaxConcurrencySynchronizationContext</code> .  Anstatt die Operation einmal auszuf√ºhren, stellen wir 4 Aufrufe an den Kontext in die Warteschlange.  Jeder Anruf wird get√§tigt und in Erwartung seines Abschlusses gesperrt.  Alle Ressourcen werden jetzt blockiert und warten auf den Abschluss asynchroner Methoden. Sie k√∂nnen nur dann abgeschlossen werden, wenn ihre R√ºckrufe in diesem Kontext verarbeitet werden.  Er ist jedoch bereits voll besetzt.  Schon wieder Deadlock.  Wenn die Bibliotheksmethode stattdessen <code>ConfigureAwait(false)</code> verwendet, wird der R√ºckruf nicht in den urspr√ºnglichen Kontext eingereiht, wodurch Deadlock-Skripts vermieden werden. <br><br><h3>  Muss ich ConfigureAwait (true) verwenden? </h3><br>  Nein, es sei denn, Sie m√ºssen explizit angeben, dass Sie <code>ConfigureAwait(false)</code> nicht verwenden <code>ConfigureAwait(false)</code> (z. B. um Warnungen zur statischen Analyse usw. auszublenden).  <code>ConfigureAwait(true)</code> keine Bedeutung.  Wenn Sie <code>await task.ConfigureAwait(true)</code> <code>await task</code> und <code>await task.ConfigureAwait(true)</code> , sind sie funktional identisch.  Wenn also <code>ConfigureAwait(true)</code> im Code vorhanden ist, kann es ohne negative Folgen gel√∂scht werden. <br><br>  Die <code>ConfigureAwait</code> Methode nimmt einen booleschen Wert an, da in einigen Situationen m√∂glicherweise eine Variable √ºbergeben werden muss, um die Konfiguration zu steuern.  In 99% der F√§lle wird der Wert jedoch auf false ( <code>ConfigureAwait(false)</code> . <br><br><h3>  Wann sollte ConfigureAwait (false) verwendet werden? </h3><br>  Dies h√§ngt davon ab, ob Sie Code auf Anwendungsebene oder universellen Bibliothekscode implementieren. <br><br>  Beim Schreiben von Anwendungen ist normalerweise ein gewisses Standardverhalten erforderlich.  Wenn das Anwendungsmodell / die Umgebung (z. B. Windows Forms, WPF, ASP.NET Core) einen speziellen <code>SynchronizationContext</code> , gibt es mit ziemlicher Sicherheit einen guten Grund daf√ºr: Der Code erm√∂glicht es Ihnen, den Synchronisierungskontext f√ºr die ordnungsgem√§√üe Interaktion mit dem Anwendungsmodell / der Umgebung zu ber√ºcksichtigen.  Wenn Sie beispielsweise einen Ereignishandler in einer Windows Forms-Anwendung, einen Test in xUnit oder Code in einem ASP.NET MVC-Controller schreiben, unabh√§ngig davon, ob das Anwendungsmodell einen <code>SynchronizationContext</code> , m√ºssen Sie gegebenenfalls <code>SynchronizationContext</code> .  Das hei√üt, wenn sowohl <code>ConfigureAwait(true)</code> als auch <code>await</code> , werden R√ºckrufe / Fortsetzungen an den urspr√ºnglichen Kontext zur√ºckgesendet - alles l√§uft wie es sollte.  Hier k√∂nnen Sie eine allgemeine Regel formulieren: <b><i>Verwenden Sie</i> <code>ConfigureAwait(false)</code> <i>nicht,</i> wenn Sie Code auf Anwendungsebene schreiben</b> .  Kehren wir zum Click-Handler zur√ºck: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HttpClient s_httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBtn_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> s_httpClient.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"http://example.com/currenttime"</span></span>); downloadBtn.Content = text; }</code> </pre> <br>  <code>downloadBtn.Content = text</code> sollte im urspr√ºnglichen Kontext ausgef√ºhrt werden.  Wenn der Code gegen diese Regel <code>ConfigureAwait (false)</code> und stattdessen <code>ConfigureAwait (false)</code> verwendet, wird er im urspr√ºnglichen Kontext nicht verwendet: <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">private</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">readonly</span></span> HttpClient s_httpClient = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> HttpClient(); <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">private</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">async</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">downloadBtn_Click</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">object</span></span></span></span><span class="hljs-function"><span class="hljs-params"> sender, RoutedEventArgs e</span></span></span><span class="hljs-function">)</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> text = <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> s_httpClient.GetStringAsync(<span class="hljs-string"><span class="hljs-string">"http://example.com/currenttime"</span></span>).ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>); <span class="hljs-comment"><span class="hljs-comment">//  downloadBtn.Content = text; }</span></span></code> </pre> <br>  Dies f√ºhrt zu unangemessenem Verhalten.  Gleiches gilt f√ºr Code in einer klassischen ASP.NET-Anwendung, der von <code>HttpContext.Current</code> abh√§ngt.  Bei Verwendung von <code>ConfigureAwait(false)</code> nachfolgender Versuch, die <code>Context.Current</code> Funktion zu verwenden, wahrscheinlich zu Problemen. <br><br>  Dies ist es, was Universalbibliotheken auszeichnet.  Sie sind zum Teil universell, weil sie sich nicht um die Umgebung k√ºmmern, in der sie verwendet werden.  Sie k√∂nnen sie von einer Webanwendung, von einer Clientanwendung oder von einem Test aus verwenden - das spielt keine Rolle, da der Bibliothekscode f√ºr das Anwendungsmodell, in dem er verwendet werden kann, unabh√§ngig ist.  Agnostisch bedeutet auch, dass die Bibliothek nichts unternimmt, um mit dem Anwendungsmodell zu interagieren. Beispielsweise erh√§lt sie keinen Zugriff auf Steuerelemente der Benutzeroberfl√§che, da die Universalbibliothek nichts √ºber sie wei√ü.  Da der Code nicht in einer bestimmten Umgebung ausgef√ºhrt werden muss, k√∂nnen wir vermeiden, dass Fortsetzungen / R√ºckrufe in den urspr√ºnglichen Kontext zur√ºckgesetzt werden. Dies <code>ConfigureAwait(false)</code> mithilfe von <code>ConfigureAwait(false)</code> , wodurch die Leistung verbessert und die Zuverl√§ssigkeit erh√∂ht wird.  Dies f√ºhrt uns zu Folgendem: <b>Wenn Sie Universalbibliothekscode schreiben, verwenden Sie <code>ConfigureAwait(false)</code></b> .  Aus diesem Grund verwendet jedes (oder fast jedes), das in den .NET Core-Laufzeitbibliotheken erwartet wird, ConfigureAwait (false).  Mit wenigen Ausnahmen, die h√∂chstwahrscheinlich Fehler sind, werden sie behoben. , <a href="https://github.com/dotnet/corefx/pull/38610" rel="nofollow"> PR</a>    <code>ConfigureAwait(false)</code>  <code>HttpClient</code> . <br><br>      . ,     (,   , ,   )      ,     API,     .   ,         ,       ‚Äù "  . , ,    Where LINQ: <code>public static async IAsyncEnumerable&lt;T&gt; WhereAsync(this IAsyncEnumerable&lt;T&gt; source, Func&lt;T, bool&gt; predicate)</code> .   <code>predicate</code>    <code>SynchronizationContext</code>  ?     <code>WhereAsync</code> ,   ,        <code>ConfigureAwait(false)</code> . <br><br>       :  <code>ConfigureAwait(false)</code>      /app-model-agnostic . <br><br><h3>   ConfigureAwait (false),         ? </h3><br> ,  ,          .    ,    <code>await</code>      .    ,      ,      . ,    ,      ,   ,   <code>ConfigureAwait(false)</code> ,            ,     . <br><br><h3>    ConfigureAwait (false)       ,    ‚Äî ? </h3><br>  , .   FAQ.  <code>await task.ConfigureAwait(false)</code>  ,       (      ),   <code>ConfigureAwait(false)</code>  ,           -    ,    . <br><br>     ,   <code>await</code>    ,         ,    <code>SynchronizationContext</code>  <code>TaskScheduler</code> . , <code>CryptoStream</code>     .NET ,                 .      <code><a href="" rel="nofollow">awaiter</a></code> ,  ,          .       ,   await -  <code>ConfigureAwait(false)</code> ;     ,      ,     ,     <code>ConfigureAwait(false)</code> . <br><br><h3>    Task.Run,    ConfigureAwait (false)? </h3><br> ,   : <br><br><pre> <code class="cs hljs">Task.Run(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> SomethingAsync(); <span class="hljs-comment"><span class="hljs-comment">//     });</span></span></code> </pre> <br>  <code>ConfigureAwait(false)</code>  <code>SomethingAsync()</code>  ,   ,   <code>Task.Run</code>      ,       , <code>SynchronizationContext.Current</code>   <code>null</code> .  , <code>Task.Run</code>   <code>TaskScheduler.Default</code> ,  <code>TaskScheduler.Current</code>      <code>Default</code> .  ,  <code>await</code>        ,    <code>ConfigureAwait(false)</code> .        ,       .     : <br><br><pre> <code class="cs hljs">Task.Run(<span class="hljs-keyword"><span class="hljs-keyword">async</span></span> <span class="hljs-keyword"><span class="hljs-keyword">delegate</span></span> { SynchronizationContext.SetSynchronizationContext(<span class="hljs-keyword"><span class="hljs-keyword">new</span></span> SomeCoolSyncCtx()); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> SomethingAsync(); <span class="hljs-comment"><span class="hljs-comment">//    SomeCoolSyncCtx });</span></span></code> </pre> <br>    <code>SomethingAsync</code>   <code>SynchronizationContext.Current</code>  <code>SomeCoolSyncCtx</code> .   <code>await</code> ,       SomethingAsync     .  ,    ,  ,        ,     ,       . <br><br>        /     .         /      . <br><br>    ,        ,  ,     . ,       ,    <code>ConfigureAwait(false)</code> <a href="https://docs.microsoft.com/en-us/visualstudio/code-quality/ca2007%3Fview%3Dvs-2019" rel="nofollow">CA2007</a> .    ,         <code>ConfigureAwait</code> ,   ,    .        , ,      -  ,            ,       <code>ConfigureAwait(false)</code> . <br><br><h3>    SynchronizationContext.SetSynchronizationContext,    ConfigureAwait (false)? </h3><br>  Nein. , .      <br><br>    : <br><br><pre> <code class="cs hljs">Task t; SynchronizationContext old = SynchronizationContext.Current; SynchronizationContext.SetSynchronizationContext(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { t = CallCodeThatUsesAwaitAsync(); <span class="hljs-comment"><span class="hljs-comment">// await'      } finally { SynchronizationContext.SetSynchronizationContext(old); } await t; //  -    </span></span></code> </pre> <br><br>  ,      <code>CallCodeThatUsesAwaitAsync</code>     <code>null</code> .   .       ,  <code>await</code>  <code>TaskScheduler.Current</code> .       <code>TaskScheduler</code> , <code>await</code> '  <code>CallCodeThatUsesAwaitAsync</code>          <code>TaskScheduler</code> . <br><br>    <code>Task.Run</code> FAQ,      :     ,     <code>try</code>     ,    (       ). <br><br>          : <br><br><pre> <code class="cs hljs">SynchronizationContext old = SynchronizationContext.Current; SynchronizationContext.SetSynchronizationContext(<span class="hljs-literal"><span class="hljs-literal">null</span></span>); <span class="hljs-keyword"><span class="hljs-keyword">try</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> t; } <span class="hljs-keyword"><span class="hljs-keyword">finally</span></span> { SynchronizationContext.SetSynchronizationContext(old); }</code> </pre><br>    ?   ,   .  ,       /   .  ,   <code>SynchronizationContext</code>        ,     ,          .   ,    ,    ,  ,            .        ,    ,          .       ,       .  Usw.    . <br><br><h3>    ConfigureAwait(false)    GetAwaiter ().GetResult ()? </h3><br>  Nein. <code>ConfigureAwait</code>   .  ,  <code>awaiter</code> ,  <code>awaiter</code> '   <code>IsCompleted</code> ,  <code>GetResult</code>  <code>OnCompleted</code> (   UnsafeOnCompleted). <code>ConfigureAwait</code>     <code>{Unsafe}OnCompleted</code> ,       <code>GetResult()</code> ,       <code>TaskAwaiter</code>  <code>ConfiguredTaskAwaitable.ConfiguredTaskAwaiter</code>    .     <code>task.ConfigureAwait(false).GetAwaiter().GetResult()</code>      <code>task.GetAwaiter().GetResult()</code> (  ,       ). <br><br><h3>  ,     ,       SynchronizationContext   TaskScheduler.     ConfigureAwait(false)? </h3><br>  M√∂glicherweise.    ,      ¬´¬ª.     ,  ,   ,    ,    <code>SynchronizationContext</code>        <code>TaskScheduler</code> ,  ,         .       ,     ,    . <br><br><h3>  ,   .NET Core    ConfigureAwait (false).  Ist es so? </h3><br>  .      .NET Core    ,      .NET Framework.      . <br><br>  ,      <code>SynchronizationContext</code> .  ,      ASP.NET  .NET Framework   <code><a href="" rel="nofollow">SynchronizationContext</a></code> ,  ASP.NET Core  .  ,  ,    ASP.NET Core       <code>SynchronizationContext</code> ,     <code>ConfigureAwait(false)</code>   . <br><br>    ,       <code>SynchronizationContext</code>  <code>TaskScheduler</code> .  -   (   ,  )             ,     ,  <code>await</code> '  ASP.NET Core      ,       <code>ConfigureAwait(false)</code> . ,  ,      (       -)             ,      <code>ConfigureAwait(false)</code> . <br><br><h3>     ConfigureAwait,  ¬´  foreach¬ª  IAsyncEnumerable? </h3><br>  Ja  .  <a href="https://docs.microsoft.com/en-us/archive/msdn-magazine/2019/november/csharp-iterating-with-async-enumerables-in-csharp-8" rel="nofollow"> MSDN</a> . <br><br> <code>Await foreach</code>   ,  ,      <code>IAsyncEnumerable&lt;T&gt;</code> .       ,     API.    .NET   <a href="" rel="nofollow"></a> <code>ConfigureAwait</code>  <code>IAsyncEnumerable&lt;T&gt;</code> ,    ,   <code>IAsyncEnumerable&lt;T&gt;</code>  <code>Boolean</code>    .      <code>MoveNextAsync</code>  <code>DisposeAsync</code> .         ,    ,    . <br><br><h3>    ConfigureAwait,  'await using' IAsyncDisposable? </h3><br> ,     . <br><br>    <code>IAsyncEnumerable&lt;T&gt;</code> , .NET       <code>ConfigureAwait</code>  <code>IAsyncDisposable</code>  <code>await using</code> ,   ,      ( ,    <code>DisposeAsync</code> ): <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyAsyncDisposableClass().ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)) { ... }</code> </pre> <br>     ,   <code>c</code> ‚Äî   <code>MyAsyncDisposableClass</code> ,   <code>System.Runtime.CompilerServices.ConfiguredAsyncDisposable</code> ,      <code>ConfigureAwait</code>  <code>IAsyncDisposable</code> . <br><br>   ,   : <br><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> c = <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> MyAsyncDisposableClass(); <span class="hljs-keyword"><span class="hljs-keyword">await</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> (c.ConfigureAwait(<span class="hljs-literal"><span class="hljs-literal">false</span></span>)) { ... }</code> </pre> <br>   <code>c</code>    <code>MyAsyncDisposableClass</code> .         <code>c</code> ;  ,        . <br><br><h3>   ConfigureAwait (false),   AsyncLocal       .  ? </h3><br> ,   .   <code>AsyncLocal&lt;T&gt;</code>   <code>ExecutionContext</code> ,    <code>SynchronizationContext</code> .       <code>ExecutionContext</code>   <code>ExecutionContext.SuppressFlow()</code> , <code>ExecutionContext</code> (,  ,  <code>AsyncLocal &lt;T&gt;</code> )     <code>awaits</code> ,   ,   <code>ConfigureAwait</code>     <code>SynchronizationContext</code> .      <a href="https://devblogs.microsoft.com/pfxteam/executioncontext-vs-synchronizationcontext/" rel="nofollow"></a> . <br><br><h3>           ConfigureAwait(false)   ? </h3><br>        <code>ConfigureAwait(false)</code>     . <br><br>     ,   ,     // .      ,    , : <a href="https://github.com/dotnet/csharplang/issues/645" rel="nofollow">1</a> , <a href="https://github.com/dotnet/csharplang/issues/2542" rel="nofollow">2</a> , <a href="https://github.com/dotnet/csharplang/issues/2649" rel="nofollow">3</a> , <a href="https://github.com/dotnet/csharplang/issues/2746" rel="nofollow">4</a> . <br><br>     ,        ,  <a href="https://devblogs.microsoft.com/dotnet/configureawait-faq/" rel="nofollow"> </a>    . </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de482354/">https://habr.com/ru/post/de482354/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de482338/index.html">Visual Studio f√ºr Mac: Steuern Sie Ihre IDE mit Schl√ºsseln</a></li>
<li><a href="../de482340/index.html">Von Junior'a nach Middle'a: Parser</a></li>
<li><a href="../de482344/index.html">Machen Sie sich bereit f√ºr die Einf√ºhrung eines Social Ratings in Russland</a></li>
<li><a href="../de482348/index.html">Topologie und umfassende Analyse f√ºr einen ahnungslosen Spieleentwickler: Komprimieren einzelner 3D-Vektoren</a></li>
<li><a href="../de482352/index.html">Als ich fast 150k in den Wind warf oder die Geschichte der Installation von Fremdbel√ºftung in der Wohnung</a></li>
<li><a href="../de482356/index.html">Verwenden von Windows Server ohne Explorer aus der Sicht eines normalen Windows-Benutzers</a></li>
<li><a href="../de482358/index.html">Wie Panik in Rust wirkt</a></li>
<li><a href="../de482360/index.html">Habra-Detektiv: Sie sind mit UFOs befreundet</a></li>
<li><a href="../de482362/index.html">Fast Anarchie: Eine kurze Geschichte von Fidonet, einem Projekt, bei dem es nicht darum geht, √ºber das Internet zu gewinnen</a></li>
<li><a href="../de482364/index.html">Dinge, die Sie [vielleicht] nicht √ºber Java wussten</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>