<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üï£ üî¢ üëÉ Transa√ß√µes Globais da InterSystems IRIS üîâ üõÄüèæ üòî</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="O InterSystems IRIS DBMS suporta estruturas curiosas de armazenamento de dados - globais. De fato, s√£o chaves de v√°rios n√≠veis com v√°rios benef√≠cios a...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Transa√ß√µes Globais da InterSystems IRIS</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/461753/"><img src="https://habrastorage.org/webt/fh/h6/kb/fhh6kbibffqggpvpjk1bpabnj1w.png" alt="InterSystems IRIS e transa√ß√£o" align="left">  O InterSystems IRIS DBMS suporta estruturas curiosas de armazenamento de dados - globais.  De fato, s√£o chaves de v√°rios n√≠veis com v√°rios benef√≠cios adicionais na forma de transa√ß√µes, fun√ß√µes r√°pidas para percorrer √°rvores de dados, bloqueios e sua pr√≥pria linguagem ObjectScript. <br><br>  Mais sobre globais na s√©rie de artigos ‚ÄúGlobals - espadas-pedreiros para armazenamento de dados‚Äù: <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">As √°rvores</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 1</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">As √°rvores</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 2</a> <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Matrizes esparsas.</a>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Parte 3</a> <br><br>  Tornou-se interessante para mim como as transa√ß√µes s√£o implementadas no mundo, quais recursos existem.  Afinal, essa √© uma estrutura completamente diferente para armazenar dados do que as tabelas usuais.  N√≠vel muito mais baixo. <br><a name="habracut"></a><br>  Como voc√™ sabe pela teoria do banco de dados relacional, uma boa implementa√ß√£o de transa√ß√£o deve atender aos requisitos do <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">ACID</a> : <br><br>  <b>A - At√¥mica (atomicidade).</b>  Todas as altera√ß√µes feitas na transa√ß√£o ou nenhuma s√£o registradas. <br><br>  <b>C - Consist√™ncia.</b>  Ap√≥s a conclus√£o da transa√ß√£o, o estado l√≥gico do banco de dados deve ser consistente internamente.  De muitas maneiras, esse requisito se aplica ao programador, mas, no caso de bancos de dados SQL, tamb√©m se aplica a chaves estrangeiras. <br><br>  <b>I - isolar (isolamento).</b>  Transa√ß√µes paralelas n√£o devem se afetar. <br><br>  <b>D - Dur√°vel.</b>  Depois que a transa√ß√£o √© conclu√≠da com √™xito, problemas nos n√≠veis mais baixos (falta de energia, por exemplo) n√£o devem afetar os dados alterados pela transa√ß√£o. <br><br>  Globals s√£o estruturas de dados n√£o relacionais.  Eles foram criados para um trabalho ultra-r√°pido em hardware muito limitado.  Vamos entender a implementa√ß√£o de transa√ß√µes em globais usando a imagem <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">oficial do docker IRIS</a> . <br><br>  Para oferecer suporte a transa√ß√µes no IRIS, os seguintes comandos s√£o usados: <a href="">TSTART</a> , <a href="">TCOMMIT</a> , <a href="">TROLLBACK</a> . <br><br><h2>  1. Atomicidade </h2><br>  A maneira mais f√°cil de verificar a atomicidade.  Verificando no console do banco de dados. <br><br><pre><code class="bash hljs">Kill ^a TSTART Set ^a(1) = 1 Set ^a(2) = 2 Set ^a(3) = 3 TCOMMIT</code> </pre> <br>  Ent√£o conclu√≠mos: <br><br><pre> <code class="bash hljs">Write ^a(1), ‚Äú ‚Äù, ^a(2), ‚Äú ‚Äù, ^a(3)</code> </pre> <br>  Temos: <br><br><pre> <code class="bash hljs">1 2 3</code> </pre> <br>  Est√° tudo bem.  Atomicidade observada: todas as altera√ß√µes s√£o registradas. <br><br>  N√≥s complicamos a tarefa, apresentamos um erro e vemos como a transa√ß√£o √© salva, parcialmente ou n√£o. <br><br>  Vamos verificar a atomicidade mais uma vez: <br><br><pre> <code class="bash hljs">Kill ^A TSTART Set ^a(1) = 1 Set ^a(2) = 2 Set ^a(3) = 3</code> </pre> <br>  Em seguida, pare o recipiente √† for√ßa, inicie e veja. <br><br><pre> <code class="bash hljs">docker <span class="hljs-built_in"><span class="hljs-built_in">kill</span></span> my-iris</code> </pre> <br>  Este comando √© quase equivalente ao desligamento for√ßado da energia, pois envia um sinal para interromper imediatamente o processo SIGKILL. <br><br>  Talvez a transa√ß√£o tenha sido parcialmente salva? <br><br><pre> <code class="bash hljs">WRITE ^a(1), ^a(2), ^a(3) ^ &lt;UNDEFINED&gt; ^a(1)</code> </pre> <br>  - N√£o, n√£o preservado. <br><br>  Teste o comando de revers√£o: <br><br><pre> <code class="bash hljs">Kill ^A TSTART Set ^a(1) = 1 Set ^a(2) = 2 Set ^a(3) = 3 TROLLBACK WRITE ^a(1), ^a(2), ^a(3) ^ &lt;UNDEFINED&gt; ^a(1)</code> </pre> <br>  Nada foi preservado tamb√©m. <br><br><h2>  2. Consist√™ncia </h2><br>  Como em bancos de dados globais, as chaves tamb√©m s√£o feitas em globais (lembro-me de que uma global √© uma estrutura de n√≠vel inferior para armazenar dados que uma tabela relacional), para cumprir o requisito de consist√™ncia, voc√™ deve incluir a altera√ß√£o de chave na mesma transa√ß√£o que a altera√ß√£o global. <br><br>  Por exemplo, temos uma pessoa global em que armazenamos personalidades e usamos o TIN como chave. <br><br><pre> <code class="bash hljs">^person(1234567, <span class="hljs-string"><span class="hljs-string">'firstname'</span></span>) = <span class="hljs-string"><span class="hljs-string">'Sergey'</span></span> ^person(1234567, <span class="hljs-string"><span class="hljs-string">'lastname'</span></span>) = <span class="hljs-string"><span class="hljs-string">'Kamenev'</span></span> ^person(1234567, <span class="hljs-string"><span class="hljs-string">'phone'</span></span>) = <span class="hljs-string"><span class="hljs-string">'+74995555555 ...</span></span></code> </pre> <br>  Para fazer uma pesquisa r√°pida por sobrenome e nome, criamos o √≠ndice ^ chave. <br><br><pre> <code class="bash hljs">^index(<span class="hljs-string"><span class="hljs-string">'Kamenev'</span></span>, <span class="hljs-string"><span class="hljs-string">'Sergey'</span></span>, 1234567) = 1</code> </pre> <br>  Para que a base seja acordada, precisamos adicionar personalidades como esta: <br><br><pre> <code class="bash hljs">TSTART ^person(1234567, <span class="hljs-string"><span class="hljs-string">'firstname'</span></span>) = <span class="hljs-string"><span class="hljs-string">'Sergey'</span></span> ^person(1234567, <span class="hljs-string"><span class="hljs-string">'lastname'</span></span>) = <span class="hljs-string"><span class="hljs-string">'Kamenev'</span></span> ^person(1234567, <span class="hljs-string"><span class="hljs-string">'phone'</span></span>) = <span class="hljs-string"><span class="hljs-string">'+74995555555 ^index('</span></span>Kamenev<span class="hljs-string"><span class="hljs-string">', '</span></span>Sergey<span class="hljs-string"><span class="hljs-string">', 1234567) = 1 TCOMMIT</span></span></code> </pre> <br>  Assim, ao excluir, tamb√©m devemos usar a transa√ß√£o: <br><br><pre> <code class="bash hljs">TSTART Kill ^person(1234567) ZKill ^index(<span class="hljs-string"><span class="hljs-string">'Kamenev'</span></span>, <span class="hljs-string"><span class="hljs-string">'Sergey'</span></span>, 1234567) TCOMMIT</code> </pre> <br>  Em outras palavras, o cumprimento do requisito de consist√™ncia cabe inteiramente ao programador.  Mas quando se trata de globais, isso √© normal, devido √† sua natureza de baixo n√≠vel. <br><br><h2>  3. Isolamento </h2><br>  √â aqui que os selvagens come√ßam.  Muitos usu√°rios trabalham simultaneamente no mesmo banco de dados, modificam os mesmos dados. <br><br>  A situa√ß√£o √© compar√°vel √† situa√ß√£o em que muitos usu√°rios trabalham simultaneamente com o mesmo reposit√≥rio com o c√≥digo e tentam confirmar altera√ß√µes em muitos arquivos ao mesmo tempo. <br><br>  O banco de dados deve resolver isso em tempo real.  Considerando que, em empresas s√©rias, existe mesmo uma pessoa especial respons√°vel pelo controle de vers√£o (para mesclar filiais, resolver conflitos etc.), e o banco de dados deve fazer tudo isso em tempo real, a complexidade da tarefa e o design correto do banco de dados. o c√≥digo que o serve. <br><br>  O banco de dados n√£o pode entender o significado das a√ß√µes executadas pelos usu√°rios para evitar conflitos se eles trabalharem nos mesmos dados.  S√≥ pode cancelar uma transa√ß√£o contr√°ria a outra ou execut√°-las sequencialmente. <br><br>  Outro problema √© que, durante a execu√ß√£o da transa√ß√£o (antes da confirma√ß√£o), o estado do banco de dados pode ser inconsistente; portanto, √© desej√°vel que outras transa√ß√µes n√£o tenham acesso ao estado inconsistente do banco de dados, o que √© alcan√ßado em bancos de dados relacionais de v√°rias maneiras: cria√ß√£o de instant√¢neos, linhas multivers√µes e etc. <br><br>  Na execu√ß√£o paralela de transa√ß√µes, √© importante para n√≥s que elas n√£o interfiram entre si.  Essa √© a propriedade do isolamento. <br><br>  O SQL define 4 n√≠veis de isolamento: <br><br><ul><li>  LEIA N√ÉO COMPROMISSO </li><li>  LEIA COMPROMISSO </li><li>  LEITURA REPET√çVEL </li><li>  SERIALIZABLE </li></ul><br>  Vamos considerar cada n√≠vel separadamente.  Os custos de implementa√ß√£o de cada n√≠vel est√£o crescendo quase exponencialmente. <br><br>  <b>LER N√ÉO COMPROMISSO</b> √© o n√≠vel mais baixo de isolamento, mas o mais r√°pido.  As transa√ß√µes podem ler as altera√ß√µes feitas uma pela outra. <br><br>  <b>LEIA COMPROMISSO</b> √© o pr√≥ximo n√≠vel de isolamento, que √© um compromisso.  As transa√ß√µes n√£o podem ler as altera√ß√µes feitas antes da confirma√ß√£o, mas podem ler as altera√ß√µes feitas ap√≥s uma confirma√ß√£o. <br><br>  Se tivermos uma transa√ß√£o longa T1, durante a qual houve confirma√ß√µes nas transa√ß√µes T2, T3 ... Tn que funcionaram com os mesmos dados que T1, quando solicitarmos dados em T1, obteremos resultados diferentes a cada vez.  Esse fen√¥meno √© chamado de leitura n√£o repet√≠vel. <br><br>  <b>REPEATABLE READ</b> - neste n√≠vel de isolamento, n√£o temos o fen√¥meno de leitura n√£o repet√≠vel, devido ao fato de que, para cada solicita√ß√£o de leitura de dados, √© criado um instant√¢neo dos dados resultantes e, quando reutilizados na mesma transa√ß√£o, os dados do instant√¢neo s√£o usados.  No entanto, os dados fantasmas podem ser lidos nesse n√≠vel de isolamento.  Isso se refere √† leitura de novas linhas que foram adicionadas por transa√ß√µes confirmadas simult√¢neas. <br><br>  <b>SERIALIZABLE</b> √© o n√≠vel mais alto de isolamento.  √â caracterizado pelo fato de que os dados utilizados de qualquer forma na transa√ß√£o (leitura ou altera√ß√£o) ficam dispon√≠veis para outras transa√ß√µes somente ap√≥s a conclus√£o da primeira transa√ß√£o. <br><br>  Primeiro, vamos descobrir se h√° isolamento de opera√ß√µes em uma transa√ß√£o do thread principal.  Vamos abrir 2 janelas de terminal. <br><div class="scrollable-table"><table><tbody><tr><td><pre> <code class="bash hljs">Kill ^t Write ^t(1) 2</code> </pre> </td><td><pre> <code class="bash hljs">TSTART Set ^t(1)=2</code> </pre> </td></tr></tbody></table></div><br>  N√£o h√° isolamento.  Um segmento v√™ o que o segundo que abriu a transa√ß√£o faz. <br><br>  Vamos ver se transa√ß√µes de diferentes fluxos veem o que est√° acontecendo dentro deles. <br><br>  Abrimos 2 janelas de terminal e 2 transa√ß√µes em paralelo. <br><div class="scrollable-table"><table><tbody><tr><td><pre> <code class="bash hljs"><span class="hljs-built_in"><span class="hljs-built_in">kill</span></span> ^t TSTART Write ^t(1) 3</code> </pre> </td><td><pre> <code class="bash hljs">TSTART Set ^t(1)=3</code> </pre></td></tr></tbody></table></div><br>  As transa√ß√µes simult√¢neas veem os dados um do outro.  Portanto, obtivemos o n√≠vel de isolamento mais simples, mas tamb√©m o mais r√°pido, LEIA N√ÉO COMPROMISSO. <br><br>  Em princ√≠pio, isso poderia ser esperado para os globais, para os quais a velocidade sempre foi primordial. <br><br>  Mas e se precisarmos de um n√≠vel mais alto de isolamento nas opera√ß√µes globais? <br><br>  Aqui voc√™ precisa pensar sobre por que os n√≠veis de isolamento s√£o necess√°rios e como eles funcionam. <br><br>  O n√≠vel mais alto de isolamento de SERIALIZE significa que o resultado de transa√ß√µes executadas simultaneamente √© equivalente √† sua execu√ß√£o sequencial, o que garante a aus√™ncia de colis√µes. <br><br>  Podemos fazer isso com a ajuda de bloqueios competentes no ObjectScript, que possuem diversas formas de aplica√ß√£o: voc√™ pode executar bloqueios regulares, incrementais e m√∫ltiplos com o comando <a href="">LOCK</a> . <br><br>  N√≠veis mais baixos de isolamento s√£o compensa√ß√µes projetadas para aumentar a velocidade do banco de dados. <br><br>  Vamos ver como podemos alcan√ßar diferentes n√≠veis de isolamento usando bloqueios. <br><br>  Esse operador permite que voc√™ fa√ßa n√£o apenas os bloqueios exclusivos necess√°rios para alterar dados, mas tamb√©m os chamados compartilhados, que podem receber v√°rios encadeamentos ao mesmo tempo, quando eles precisam ler dados que n√£o devem ser alterados por outros processos durante a leitura. <br><br>  Mais informa√ß√µes sobre o m√©todo de bloqueio bif√°sico em russo e ingl√™s: <br><br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bloqueio de duas fases</a> <br>  ‚Üí <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=pt&amp;u=">Bloqueio bif√°sico</a> <br><br>  A dificuldade √© que, durante a transa√ß√£o, o estado do banco de dados pode ser inconsistente; no entanto, esses dados inconsistentes s√£o vis√≠veis para outros processos.  Como evitar isso? <br><br>  Usando bloqueios, criaremos essas janelas de visibilidade nas quais o estado do banco de dados ser√° acordado.  E todas as chamadas para essas janelas de visibilidade do estado acordado ser√£o controladas por bloqueios. <br><br>  Bloqueios compartilhados dos mesmos dados s√£o reutiliz√°veis ‚Äã‚Äã- v√°rios processos podem execut√°-los.  Esses bloqueios impedem que outros processos alterem dados, ou seja,  eles s√£o usados ‚Äã‚Äãpara formar janelas com um estado consistente do banco de dados. <br><br>  Bloqueios exclusivos s√£o usados ‚Äã‚Äãpara modificar dados - apenas um processo pode aceitar esse bloqueio.  O bloqueio exclusivo pode levar: <br><br><ol><li>  Qualquer processo se os dados estiverem livres </li><li>  Somente o processo que possui um bloqueio compartilhado nesses dados e o primeiro solicitou um bloqueio exclusivo. </li></ol><br><img src="https://habrastorage.org/webt/ba/pu/mx/bapumxoivygurvclagw-mkw9p8w.png"><br><br>  Quanto mais estreita a janela de visibilidade, mais tempo leva para outros processos aguardarem, mas mais consistente pode ser o estado do banco de dados. <br><br>  <b>READ_COMMITED</b> - a ess√™ncia desse n√≠vel √© que apenas vemos dados de outros fluxos que est√£o bloqueados.  Se os dados em outra transa√ß√£o ainda n√£o foram confirmados, vemos a vers√£o antiga. <br><br>  Isso nos permite paralelizar o trabalho em vez de esperar que o bloqueio seja liberado. <br><br>  Sem truques especiais, n√£o poderemos ver a vers√£o antiga dos dados no IRIS, portanto, temos a ver com bloqueios. <br><br>  Assim, teremos que usar bloqueios compartilhados para permitir a leitura de dados apenas em momentos de consist√™ncia. <br><br>  Suponha que tenhamos uma base de usu√°rios ^ pessoa que transfira dinheiro entre si. <br><br>  O momento da transfer√™ncia da pessoa 123 para a pessoa 242: <br><br><pre> <code class="bash hljs">LOCK +^person(123), +^person(242) Set ^person(123, amount) = ^person(123, amount) - amount Set ^person(242, amount) = ^person(242, amount) + amount LOCK -^person(123), -^person(242)</code> </pre> <br>  O momento de solicitar a quantia em dinheiro da pessoa 123 antes do d√©bito deve ser acompanhado por um bloqueio exclusivo (por padr√£o): <br><br><pre> <code class="bash hljs">LOCK +^person(123) Write ^person(123)</code> </pre> <br>  E se voc√™ precisar mostrar o status da conta, poder√° usar o bloqueio compartilhado ou n√£o us√°-lo: <br><br><pre> <code class="bash hljs">LOCK +^person(123)<span class="hljs-comment"><span class="hljs-comment">#‚ÄùS‚Äù Write ^person(123)</span></span></code> </pre> <br>  No entanto, se assumirmos que as opera√ß√µes do banco de dados s√£o executadas quase instantaneamente (lembro que os globais s√£o uma estrutura de n√≠vel muito inferior a uma tabela relacional), a necessidade desse n√≠vel diminui. <br><br>  <b>LEITURA REPETIDA</b> - Nesse n√≠vel de isolamento, <b>sup√µe</b> - <b>se</b> que possa haver v√°rias leituras de dados que podem ser modificadas por transa√ß√µes simult√¢neas. <br><br>  Assim, teremos de colocar um bloqueio compartilhado na leitura dos dados que estamos alterando e bloqueios exclusivos nos dados que estamos alterando. <br><br>  Felizmente, o operador LOCK permite que um operador liste em detalhes todos os bloqueios necess√°rios, que podem ser muitos. <br><br><pre> <code class="bash hljs">LOCK +^person(123, amount)<span class="hljs-comment"><span class="hljs-comment">#‚ÄùS‚Äù  ^person(123, amount)</span></span></code> </pre> <br>  outras opera√ß√µes (no momento, threads paralelos tentam alterar ^ person (123, quantidade), mas n√£o podem) <br><br><pre> <code class="bash hljs">LOCK +^person(123, amount)  ^person(123, amount) LOCK -^person(123, amount)  ^person(123, amount) LOCK -^person(123, amount)<span class="hljs-comment"><span class="hljs-comment">#‚ÄùS‚Äù</span></span></code> </pre> <br>  Ao listar bloqueios separados por v√≠rgulas, eles s√£o obtidos sequencialmente e, se voc√™ fizer isso: <br><br><pre> <code class="bash hljs">LOCK +(^person(123),^person(242))</code> </pre> <br>  ent√£o eles s√£o tomados atomicamente de uma s√≥ vez. <br><br>  <b>SERIALIZE</b> - teremos que definir os bloqueios para que, finalmente, todas as transa√ß√µes que tenham dados comuns sejam executadas seq√ºencialmente.  Para essa abordagem, a maioria dos bloqueios deve ser exclusiva e levada para as menores √°reas do mundo para desempenho. <br><br>  Se falarmos sobre baixas cont√°beis na pessoa global ^, somente o n√≠vel de isolamento SERIALIZE √© aceit√°vel para ele, pois o dinheiro deve ser gasto estritamente em sequ√™ncia, caso contr√°rio, √© poss√≠vel gastar a mesma quantia v√°rias vezes. <br><br><h2>  4. Durabilidade </h2><br>  Realizei testes com o corte duro do cont√™iner atrav√©s <br><br><pre> <code class="bash hljs">docker <span class="hljs-built_in"><span class="hljs-built_in">kill</span></span> my-iris</code> </pre> <br>  A base os tolerou bem.  Nenhum problema foi identificado. <br><br><h2>  Conclus√£o </h2><br>  Para globais, o InterSystems IRIS tem suporte a transa√ß√µes.  Eles s√£o verdadeiramente at√¥micos, confi√°veis.  Para garantir a consist√™ncia do banco de dados em globais, s√£o necess√°rios os esfor√ßos do programador e o uso de transa√ß√µes, pois n√£o h√° constru√ß√µes internas complexas, como chaves estrangeiras. <br><br>  O n√≠vel de isolamento de globais sem o uso de bloqueios √© LIDO N√ÉO COMPROMETIDO e, ao usar bloqueios, pode ser garantido at√© o n√≠vel SERIALIZE. <br><br>  A corre√ß√£o e a velocidade das transa√ß√µes em globais dependem muito da habilidade do programador: quanto mais bloqueios compartilhados forem usados ‚Äã‚Äãna leitura, maior ser√° o n√≠vel de isolamento e mais bloqueios exclusivos ser√£o realizados, maior a velocidade. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/pt461753/">https://habr.com/ru/post/pt461753/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../pt461743/index.html">Semana 31 de Seguran√ßa: Vulnerabilidade no VLC e telefone quebrado</a></li>
<li><a href="../pt461745/index.html">DeviceLock DLP: Pre√ßos do mercado negro russo pela quebra de dados pessoais (mais uma resposta √† resposta do Tinkoff Bank)</a></li>
<li><a href="../pt461747/index.html">Como implementamos o ML em um aplicativo com quase 50 milh√µes de usu√°rios. Experi√™ncia Sberbank</a></li>
<li><a href="../pt461749/index.html">Beleza nos olhos de quem v√™</a></li>
<li><a href="../pt461751/index.html">Contribui√ß√£o do designer para o desenvolvimento de aplicativos para dispositivos m√≥veis</a></li>
<li><a href="../pt461755/index.html">A psicologia da vis√£o sonora. Svetlana Lebedeva contou como as pessoas aprendem uma nova maneira de perceber</a></li>
<li><a href="../pt461759/index.html">Ouvindo comunica√ß√µes VoIP criptografadas</a></li>
<li><a href="../pt461761/index.html">DPKI: abordando as desvantagens da PKI centralizada com blockchain</a></li>
<li><a href="../pt461763/index.html">As ag√™ncias de publicidade podem matar neg√≥cios no in√≠cio da jornada</a></li>
<li><a href="../pt461765/index.html">Cruzamos k8s com Kafka, salvamos cont√™ineres e escapamos do lixo no Ansible: os 10 principais relat√≥rios do DevOops 2018</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>