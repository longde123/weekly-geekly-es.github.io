<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏾‍🌾 🚗 🧡 Masalah arsitektur dalam proyek besar 🈁 🙅🏽 🧑🏽‍🤝‍🧑🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pengembangan aplikasi seluler sepertinya tugas yang cukup sederhana. Tampaknya apa yang harus dilakukan di sana? Saya melemparkan beberapa pandangan, ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Masalah arsitektur dalam proyek besar</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/surfstudio/blog/485172/"><p>  Pengembangan aplikasi seluler sepertinya tugas yang cukup sederhana.  Tampaknya apa yang harus dilakukan di sana?  Saya melemparkan beberapa pandangan, mengurapi dengan beberapa arsitektur, dan hanya itu, proyek sudah siap, Anda dapat mengirim aplikasi ke stasiun.  Dalam serangkaian artikel saya akan membagikan fitur yang kami temui ketika mengembangkan aplikasi untuk bank besar. </p><br><p>  Pertimbangkan 5 topik penting.  Tentu saja, kebanyakan dari mereka telah dibahas lebih dari satu kali di komunitas, tetapi di balik setiap topik adalah rasa sakit, air mata, waktu yang hilang dan, yang paling penting, pengalaman yang bermanfaat bagi kami, dan saya harap ini akan bermanfaat bagi Anda. </p><br><p><img src="https://habrastorage.org/webt/ix/2q/wk/ix2qwkfsj5gueik1fd0-r5pjuog.png" alt="gambar"></p><a name="habracut"></a><br><p>  Pada awal pengembangan aplikasi seluler, pemimpin atau perancang menghadapi pertanyaan - pola arsitektur apa yang digunakan?  Studio kami memiliki pola arsitektur MVP yang umum.  MVP murni memang bagus dalam bentuknya yang murni (lihat gambar di bawah), tetapi kami tidak akan menjadi pengembang nyata jika kami belum menyelesaikan pola ini.  Mereka tidak berhenti pada satu opsi, dan kami mendapat dua cabang dari MVP murni. </p><br><p><img src="https://habrastorage.org/webt/cf/4d/2v/cf4d2vj2mn9rbneovqjig0lce7y.jpeg" alt="gambar"></p><br><p>  Oleh karena itu, pada tahap desain, kami dihadapkan dengan tugas memilih satu, dan atas dasar pola arsitektur yang diterima secara umum dan dapat dipahami, lanjutkan.  Tapi, sudah pada tahap awal, kami berhasil membuat kesalahan, yang kemudian membawa kami banyak masalah. </p><br><p>  Mari kita lihat dua MVP kami tentang steroid. </p><br><h2 id="surfmvphttpsgithubcomsurfstudiosurf-ios-developersblobmastersurf_mvpmd">  <a href="">SurfMVP</a> </h2><br><p><img src="https://habrastorage.org/webt/l7/aa/fu/l7aafucodquvixudd7ygcsn_tbk.jpeg" alt="gambar"></p><br><p>  Gambar menunjukkan bahwa, dibandingkan dengan MVP biasa, tidak banyak yang berubah.  Kami melihat beberapa masalah saat beralih antar layar di aplikasi iOS.  Sejumlah besar logika untuk membuat layar baru sebelum transisi terkonsentrasi langsung di UIViewController, tampaknya bagi kami kurang tepat, jadi hal pertama yang kami lakukan adalah menyoroti entitas Router yang terpisah, yang bertanggung jawab untuk membuat transisi antar layar dalam aplikasi. <br>  Model dalam SurfMVP adalah layanan yang diminta oleh Presenter untuk mengambil data.  Seringkali, satu layanan menyelesaikan tugas untuk seluruh modul, tetapi dalam situasi sulit Anda harus berinteraksi dengan beberapa modul. <br>  Entitas Configurator bertanggung jawab untuk membangun modul terpisah, ia menginisialisasi semua komponen yang diperlukan dan bertanggung jawab untuk membuat dependensi di antara mereka. </p><br><p><img src="https://habrastorage.org/webt/ws/bc/pz/wsbcpzpyevuhps1taqnd-m0gy3w.jpeg" alt="gambar"></p><br><p>  Fitur utama SurfMVP adalah bahwa setiap lapisan dalam MVP dipisahkan oleh protokol.  Gambar menunjukkan diagram lapisan dan hubungan protokol di antara mereka.  Protokol diperlukan agar setiap lapisan terpisah dari yang lain dan secara teori mudah diganti.  Setiap lapisan tidak boleh mengungkapkan rincian implementasi. </p><br><p>  <strong>Mari kita pertimbangkan secara terpisah:</strong> </p><br><p>  <strong>ViewInput</strong> - mengimplementasikan <strong>Lihat</strong> sendiri, <strong>Presenter</strong> menyimpan tautannya.  Protokol ini menjelaskan metode yang dengannya <strong>Presenter</strong> dapat mengontrol <strong>Lihat</strong> , mentransfer data, mengubah status, dan sebagainya. </p><br><p> <strong>ViewOutput</strong> - mengimplementasikan <strong>Presenter</strong> , <strong>View</strong> memegang tautannya.  Protokol menjelaskan serangkaian tindakan yang dapat terjadi dalam metode <strong>Tampilan</strong> , dan siklus hidup, misalnya, peristiwa interaksi pengguna dengan layar. </p><br><p>  <strong>RouterInput</strong> - mengimplementasikan <strong>Router</strong> , dan <strong>Presenter</strong> menyimpan tautan, karena itu adalah satu-satunya yang bertanggung jawab untuk memulai navigasi lebih lanjut dalam aplikasi. </p><br><p>  <strong>ModuleTransitionable</strong> - <strong>View</strong> diimplementasikan, <strong>Router</strong> menyimpan tautan ke sana.  Ini adalah satu-satunya protokol "dasar" di <strong>SurfMVP</strong> .  Diperlukan untuk menyediakan kepada Router serangkaian metode untuk bekerja dengan navigasi aplikasi. </p><br><p>  <strong>ModuleInput</strong> - Menerapkan <strong>Presenter</strong> .  Protokol ini harus berisi metode dimana modul lain yang memiliki tautan ke protokol ini dapat mengubah keadaan modul saat ini. </p><br><p>  <strong>ModuleOutput</strong> - mengimplementasikan <strong>Presenter dari</strong> modul pemanggil, tautannya menyimpan <strong>Presenter dari</strong> module yang dipanggil.  Jika layar profil dapat ditampilkan dari modul berita, maka <em>NewsPresenter</em> harus mengimplementasikan <em>ProfileModuleOutput</em> , dan <em>ProfilePresenter harus</em> berisi tautan ke sana. <br>  <strong>ModuleOutput</strong> diteruskan ke <strong>Configurator</strong> modul yang disebut dan diinstal di sana di <strong>Presenter</strong> .  Berisi metode modul yang memengaruhi perilaku modul pemanggilan. </p><br><h2 id="problema-surfmvp">  Masalah SurfMVP </h2><br><p>  Berdasarkan semua hal di atas, ada satu masalah utama - navigasi.  Meskipun pesan untuk menyoroti entitas Router yang terpisah adalah masalah navigasi, ternyata, mereka hilang, tetapi tidak lama.  SurfMVP telah berhasil digunakan pada proyek-proyek dengan <a href="https://developer.apple.com/design/human-interface-guidelines/ios/app-architecture/navigation/">navigasi datar yang</a> sederhana, tanpa DeepLinks dan Pemberitahuan-Push yang kompleks. </p><br><p>  Gambar di bawah ini secara skematis menunjukkan navigasi dalam aplikasi dengan SurfMVP.  Setiap modul individu berkomunikasi dengan yang lain melalui Router sendiri.  Dengan demikian, navigasi setiap aliran dalam aplikasi dibangun. </p><br><p><img src="https://habrastorage.org/webt/-v/jp/r_/-vjpr_9j8vrlfqrtr25aoislf_m.jpeg" alt="gambar"></p><br><p>  Jenis navigasi ini sangat cocok untuk kasus ketika pengguna melewati aliran pilihannya dalam aplikasi.  Sebagai contoh, pada gambar di bawah ini: pengguna melewati layar dari titik A ke titik D, jadi dia sendiri membangun tumpukan tempat dia harus pergi dan kembali dengan cara yang sama. </p><br><p><img src="https://habrastorage.org/webt/3x/qu/dp/3xqudpqcov2oqn32vx9cltkg9um.jpeg" alt="gambar"></p><br><p>  Masalah mulai pada saat ketika perlu untuk mentransfer pengguna dari titik A ke titik D, dan ini harus terjadi tanpa partisipasinya.  Misalnya, jika pengguna mengklik Pemberitahuan Push atau mengikuti tautan dari aplikasi pihak ketiga.  Dalam hal SurfMVP, kita harus menambahkan Router global yang akan mengontrol navigasi terlepas dari di mana pengguna saat ini berada di aplikasi.  Untuk mengatasi masalah ini secara global, kami memutuskan untuk menggunakan koordinator, mari beralih ke mereka. </p><br><p><img src="https://habrastorage.org/webt/rn/fn/mb/rnfnmbs2b7lias_cqvmpp6mvpz0.jpeg" alt="gambar"></p><br><h2 id="coordinated-surfmvp">  SurfMVP terkoordinasi </h2><br><p><img src="https://habrastorage.org/webt/bz/q3/qr/bzq3qrf53ggr3iczo32ex_rpcs0.jpeg" alt="gambar"></p><br><p>  SurfMVP terkoordinasi adalah pola arsitektur di mana, tidak seperti SurfMVP, kami menghapus entitas Router yang ada di dalam setiap modul individu.  Paradigma membangun aplikasi telah sedikit berubah.  Modul tidak lagi sepenuhnya independen.  Setiap modul, kecuali yang sepenuhnya dapat digunakan kembali, terletak di UserFlow terpisah yang terpisah, yang, seperti yang direncanakan, harus melakukan beberapa tindakan umum yang mengarahkan pengguna ke hasil yang diinginkan. </p><br><p>  Contoh aliran seperti itu dalam aplikasi kita adalah aliran pembayaran.  Pembayaran adalah seperangkat layar yang memungkinkan pengguna untuk melakukan transfer atau pembayaran dengan berbagai cara. </p><br><p>  Dalam SurfMVP Terkoordinasi, entitas Router menggantikan entitas <a href="http://khanlou.com/2015/01/the-coordinator/">Koordinator</a> , yang sekarang bertanggung jawab untuk menavigasi tidak satu modul terpisah, tetapi satu set modul yang secara logis terhubung satu sama lain.  Ini menyederhanakan navigasi dan bekerja dengan aplikasi.  Secara skematis, aplikasi kita terlihat seperti ini: </p><br><p><img src="https://habrastorage.org/webt/ln/uv/ce/lnuvcepenm_ai5xuufuxn_3eff8.jpeg" alt="gambar"></p><br><p>  Di bagian paling atas adalah ApplicationCoordinator, yang bertanggung jawab untuk perutean awal dalam aplikasi.  Misalnya, sebuah kasus, ketika pengguna diotorisasi, maka kami akan segera mengirimnya ke bagian utama aplikasi, jika tidak, kami akan mengirimnya ke layar otorisasi. </p><br><p>  Jika kita memiliki Deeplinks atau Push-Notifications di aplikasi kita, kita selalu dapat mengatur inisialisasi dan memulai aturan untuk koordinator sehingga mereka membangun tumpukan langsung ke titik D yang diinginkan, yang telah kita bicarakan sebelumnya. </p><br><p><img src="https://habrastorage.org/webt/bz/i6/i3/bzi6i3mk9bfzl6dgi1oselxjmxm.jpeg" alt="gambar"></p><br><p>  Secara skematis, navigasi kami sekarang terlihat seperti ini.  Setiap individu UserFlow merujuk pada koordinatornya sendiri, yang pada gilirannya memutuskan apa yang akan terjadi di masa depan.  Tanggung jawab untuk mentransmisikan data dan memulai navigasi lebih lanjut sekarang berada di tangan koordinator, ia sudah dikaitkan dengan modul lain atau koordinator lain untuk terus membangun tumpukan navigasi. </p><br><h2 id="plyusy-i-minusy-coordinated-surfmvp">  Pro dan Kontra dari SurfMVP Terkoordinasi </h2><br><p>  <strong>Keuntungan:</strong> </p><br><ol><li>  Keuntungan utama dari pendekatan koordinator adalah kemampuan untuk menggunakan kembali seluruh blok navigasi dalam aplikasi.  Sekarang, dari mana saja dalam aplikasi, dimungkinkan untuk memanggil koordinator ini dan tidak memikirkan apa pun selain menyelesaikan pekerjaannya. </li><li>  Karena logika navigasi terisolasi di dalam koordinator yang terpisah, sekarang jauh lebih nyaman untuk mengikuti navigasi: cukup buka satu file dan seluruh gambar di depan mata Anda.  Tidak ada lagi kebutuhan untuk menembus semua modul individu untuk memahami apa yang mereka raih, merakit aplikasi dan melihat desain. </li><li>  Lebih nyaman untuk mendesain dalam tim besar.  Cukup pada tahap desain fitur baru yang terpisah untuk mengalokasikan waktu untuk membangun seluruh navigasi dan menginisialisasi semua modul, setelah itu akan mendelegasikan pengembangan ke sejumlah besar pengembang, dan akan ada jauh lebih sedikit masalah dengan integrasi layar ini antara satu sama lain. </li><li>  Integrasi Deeplinks dan Push-Notifications tidak lagi memusingkan. </li></ol><br><p>  <strong>Kekurangan:</strong> </p><br><p>  Seperti halnya pendekatan arsitektur, ada kerugian untuk SurfMVP terkoordinasi. </p><br><ol><li>  Koordinator besar terluka.  Karena konsentrasi semua logika di satu tempat, menjadi jauh lebih sulit untuk tidak tenggelam dalam sejumlah besar baris kode.  Jika Anda tidak mengikuti prinsip tanggung jawab bersama, maka tentu saja, koordinator dapat tumbuh menjadi monster besar, dan semua keuntungan dari keterbacaan kode akan mudah menguap. </li><li>  Anda harus banyak menulis untuk mencapai kode yang indah.  Karena banyaknya lapisan dalam aplikasi, yang masing-masing bertanggung jawab atas tindakan terpisah, Anda harus menerobos lapisan ini untuk mencapai koordinator yang diinginkan. </li><li>  Kebocoran Memori - masalahnya bukan hal baru, tetapi Anda harus mengikuti masalah ini agar tidak masuk ke dalam lubang.  Alasan utama kebocoran memori ketika bekerja dengan koordinator adalah mempertahankan siklus dalam modul panggilan balik.  Jadi, Anda perlu memantau dengan seksama tautan kuat di dalam penutupan. </li></ol><br><div class="spoiler">  <b class="spoiler_title">Kasus khas</b> <div class="spoiler_text"><p> Kasus khas adalah inisialisasi Koordinator baru dan implementasi penutupan akhir.  Menangkap <code>weak coordinator</code> adalah wajib, jika tidak, Koordinator akan merujuk pada dirinya sendiri, yang akan menyebabkan kebocoran dalam bentuk AuthCoordinator. </p><br><pre> <code class="swift hljs"> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">runAuthFlow</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">let</span></span> coordinator = <span class="hljs-type"><span class="hljs-type">AuthCoordinator</span></span>(router: <span class="hljs-type"><span class="hljs-type">MainRouter</span></span>()) coordinator.finishFlow = { [<span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>, <span class="hljs-keyword"><span class="hljs-keyword">weak</span></span> coordinator] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>?.removeDependency(coordinator) } <span class="hljs-keyword"><span class="hljs-keyword">self</span></span>.addDependency(coordinator) coordinator.start() }</code> </pre> </div></div><br><h2 id="vyvody">  Kesimpulan </h2><br><p>  Pada tahap desain, kami meremehkan kompleksitas proyek dan memilih pendekatan arsitektur yang salah.  Tetapi kesalahan ini membantu membentuk seperangkat aturan dan lebih hati-hati mendekati pilihan arsitektur ketika memulai proyek. </p><br><h3 id="kogda-ispolzovat-coordinated-surfmvp">  Kapan menggunakan SurfMVP Terkoordinasi </h3><br><p>  Bahkan, saat Anda inginkan, maka gunakan, tetapi kami mematuhi ketentuan berikut: </p><br><ul><li>  Struktur layarnya kompleks dan dapat berubah; </li><li>  Ada Deeplinks dan / atau Pemberitahuan Push dengan navigasi; </li><li>  Penting untuk bekerja dalam tim besar; </li></ul><br><h3 id="kogda-ispolzovat-surfmvp">  Kapan menggunakan SurfMVP </h3><br><p>  Kami tidak melupakan pola arsitektur pertama kami.  Kami masih menggunakannya di studio ketika mengembangkan proyek jika memenuhi persyaratan berikut: </p><br><ul><li>  Proyek ini cukup kecil dan tidak berencana untuk berkembang pesat; </li><li>  Proyek ini memiliki struktur layar yang sangat sederhana, dan tidak mengalami perubahan yang kuat. </li></ul><br><h2 id="dopolnitelnye-materialy">  Bahan tambahan </h2><br><ul><li>  <a href="https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52">Arsitektur di iOS</a> <a href="https://medium.com/ios-os-x-development/ios-architecture-patterns-ecba4c38de52"><br></a> </li><li>  <a href="https://en.wikipedia.org/wiki/Model%25E2%2580%2593view%25E2%2580%2593presenter">Apa itu MVP murni?</a> </li><li>  <a href="https://developer.apple.com/design/human-interface-guidelines/ios/app-architecture/navigation/">Apa itu navigasi datar?</a> </li><li>  Artikel dan cerita oleh Soroush Khanlou tentang koordinator (yang digunakan istilah "koordinator"). <br><ol><li>  <a href="http://khanlou.com/2015/01/the-coordinator/">Koordinator</a> </li><li>  <a href="http://khanlou.com/2015/10/coordinators-redux/">Koordinator Redux</a> </li><li>  <a href="https://youtu.be/a1g3k3NObkE">CocoaHeads Stockholm \ Koordinator - Soroush Khanlou</a> </li></ol></li><li>  Artikel dan contoh implementasi oleh Andrey Panov <br><ol><li>  <a href="https://github.com/AndreyPanov/ApplicationCoordinator">AndreyPanov / ApplicationCoordinator: Tutorial Koordinator Esensial</a> </li><li>  <a href="https://medium.com/blacklane-engineering/coordinators-essential-tutorial-part-i-376c836e9ba7">Artikel “Tutorial Penting Koordinator.</a>  <a href="https://medium.com/blacklane-engineering/coordinators-essential-tutorial-part-i-376c836e9ba7">Bagian I »</a> </li><li>  <a href="https://medium.com/%40panovdev/coordinators-essential-tutorial-part-ii-b5ab3eb4a74">Artikel “Tutorial Penting Koordinator.</a>  <a href="https://medium.com/%40panovdev/coordinators-essential-tutorial-part-ii-b5ab3eb4a74">Bagian II »</a> </li></ol></li><li>  <a href="https://badootech.badoo.com/screen-navigation-in-ios-dd99b09228b2">Sebuah artikel oleh</a> Bogdan Orlov dengan pemikirannya tentang navigasi aplikasi </li><li>  Materi laporan Andrey Rychkov tentang penggunaan praktis koordinator <br><ol><li>  <a href="https://speakerdeck.com/cocoaheads/andriei-rychkov-how-to-deal-with-navigation">Andrey Rychkov: Cara menangani navigasi</a> </li><li>  <a href="https://github.com/Moonko/CoordinatorExample">Moonko / CoordinatorExample: Contoh koordinator aplikasi</a> </li></ol></li></ul><br><p>  Pada artikel ini, saya berbagi masalah dengan arsitektur yang kami temui saat bekerja.  Tentu saja, pilihan arsitektur mana yang akan digunakan tetap ada pada Anda.  Pada artikel selanjutnya saya akan berbagi masalah backend dalam proyek-proyek besar dan memberi tahu bagaimana kami menyelesaikannya.  Tetap disini! </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id485172/">https://habr.com/ru/post/id485172/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id485156/index.html">Bagaimana menjadi crowdfunder domestik (bagian satu)</a></li>
<li><a href="../id485158/index.html">Nikolay Vavilov. Pria yang ingin memberi makan seluruh dunia dan meninggal karena kelaparan di sel penjara</a></li>
<li><a href="../id485160/index.html">Apa yang saya dalam ACID atau perspektif yang berbeda</a></li>
<li><a href="../id485162/index.html">Bagaimana komentar kode berkembang dari tahun 1940-an hingga 2020</a></li>
<li><a href="../id485164/index.html">Transformer dan Benci di Vancouver: Bagaimana Anti-Plagiarisme Mengendarai NeurIPS-2019</a></li>
<li><a href="../id485174/index.html">Jenis bergantung Haskell: mengapa masa depan pengembangan perangkat lunak</a></li>
<li><a href="../id485176/index.html">Enam skema untuk membantu menjelaskan konsep manajemen produk</a></li>
<li><a href="../id485178/index.html">Metodologi untuk rekonstruksi bangunan yang hilang dari foto</a></li>
<li><a href="../id485180/index.html">Apakah kita memerlukan data lake? Apa yang harus dilakukan dengan data warehouse?</a></li>
<li><a href="../id485182/index.html">Sennheiser pada tahun 2020 - headphone nirkabel yang diperbarui untuk peringatan tersebut</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>