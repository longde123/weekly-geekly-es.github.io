<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚ÄçüöÄ üë©‚Äç‚ù§Ô∏è‚Äçüë© ü•¶ Quelques aspects de la surveillance de MS SQL Server. Recommandations pour d√©finir des indicateurs de trace üóúÔ∏è ‚ñ´Ô∏è üëàüèæ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Pr√©face 
 Tr√®s souvent, les utilisateurs, les d√©veloppeurs et les administrateurs de SGBD MS SQL Server sont confront√©s √† des probl√®mes de performance...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Quelques aspects de la surveillance de MS SQL Server. Recommandations pour d√©finir des indicateurs de trace</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/448044/"><h3>  Pr√©face </h3><br>  Tr√®s souvent, les utilisateurs, les d√©veloppeurs et les administrateurs de SGBD MS SQL Server sont confront√©s √† des probl√®mes de performances de base de donn√©es ou de SGBD en g√©n√©ral, donc la surveillance de MS SQL Server est tr√®s pertinente. <br><br>  Cet article est un ajout √† l'article <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utilisation de Zabbix pour surveiller la base de donn√©es MS SQL Server</a> et il examinera certains aspects de la surveillance de MS SQL Server, en particulier: comment d√©terminer rapidement les ressources manquantes, ainsi que des recommandations pour d√©finir des indicateurs de trace. <br><br>  Pour que les scripts suivants fonctionnent, vous devez cr√©er le sch√©ma inf dans la base de donn√©es souhait√©e comme suit: <br><br><div class="spoiler">  <b class="spoiler_title">Cr√©ation d'un sch√©ma inf</b> <div class="spoiler_text"><pre><code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">use</span></span> &lt;_&gt;; go <span class="hljs-keyword"><span class="hljs-keyword">create</span></span> <span class="hljs-keyword"><span class="hljs-keyword">schema</span></span> inf;</code> </pre> </div></div><a name="habracut"></a><br><h3>  M√©thode pour d√©tecter une p√©nurie de RAM </h3><br>  Le premier indicateur d'un manque de RAM est le cas lorsqu'une instance de MS SQL Server mange toute la RAM qui lui est allou√©e. <br><br>  Pour ce faire, cr√©ez la vue inf.vRAM suivante: <br><br><div class="spoiler">  <b class="spoiler_title">Cr√©ation d'une vue inf.vRAM</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> [inf].[vRAM] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> a.[TotalAvailOSRam_Mb] <span class="hljs-comment"><span class="hljs-comment">--       , a.[RAM_Avail_Percent] --     , a.[Server_physical_memory_Mb] --       , a.[SQL_server_committed_target_Mb] --     MS SQL Server   , a.[SQL_server_physical_memory_in_use_Mb] --    MS SQL Server       , a.[SQL_RAM_Avail_Percent] --    MS SQL Server      MS SQL Server , a.[StateMemorySQL] --    MS SQL Server , a.[SQL_RAM_Reserve_Percent] --    MS SQL Server     --     , (case when a.[RAM_Avail_Percent]&lt;10 and a.[RAM_Avail_Percent]&gt;5 and a.[TotalAvailOSRam_Mb]&lt;8192 then 'Warning' when a.[RAM_Avail_Percent]&lt;=5 and a.[TotalAvailOSRam_Mb]&lt;2048 then 'Danger' else 'Normal' end) as [StateMemoryServer] from ( select cast(a0.available_physical_memory_kb/1024.0 as int) as TotalAvailOSRam_Mb , cast((a0.available_physical_memory_kb/casT(a0.total_physical_memory_kb as float))*100 as numeric(5,2)) as [RAM_Avail_Percent] , a0.system_low_memory_signal_state , ceiling(b.physical_memory_kb/1024.0) as [Server_physical_memory_Mb] , ceiling(b.committed_target_kb/1024.0) as [SQL_server_committed_target_Mb] , ceiling(a.physical_memory_in_use_kb/1024.0) as [SQL_server_physical_memory_in_use_Mb] , cast(((b.committed_target_kb-a.physical_memory_in_use_kb)/casT(b.committed_target_kb as float))*100 as numeric(5,2)) as [SQL_RAM_Avail_Percent] , cast((b.committed_target_kb/casT(a0.total_physical_memory_kb as float))*100 as numeric(5,2)) as [SQL_RAM_Reserve_Percent] , (case when (ceiling(b.committed_target_kb/1024.0)-1024)&lt;ceiling(a.physical_memory_in_use_kb/1024.0) then 'Warning' else 'Normal' end) as [StateMemorySQL] from sys.dm_os_sys_memory as a0 cross join sys.dm_os_process_memory as a cross join sys.dm_os_sys_info as b cross join sys.dm_os_sys_memory as v ) as a;</span></span></code> </pre></div></div><br>  Ensuite, vous pouvez d√©terminer que l'instance de MS SQL Server consomme toute la m√©moire qui lui est allou√©e par la requ√™te suivante: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> SQL_server_physical_memory_in_use_Mb, SQL_server_committed_target_Mb <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> [inf].[vRAM];</code> </pre><br>  Si l'indicateur SQL_server_physical_memory_in_use_Mb n'est pas constamment inf√©rieur √† SQL_server_committed_target_Mb, vous devez v√©rifier les statistiques des attentes. <br><br>  Pour d√©terminer le manque de RAM via les statistiques d'attente, cr√©ez une vue inf.vWaits: <br><br><div class="spoiler">  <b class="spoiler_title">Cr√©ation d'une vue inf.vWaits</b> <div class="spoiler_text"><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">CREATE</span></span> <span class="hljs-keyword"><span class="hljs-keyword">view</span></span> [inf].[vWaits] <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> <span class="hljs-keyword"><span class="hljs-keyword">WITH</span></span> [Waits] <span class="hljs-keyword"><span class="hljs-keyword">AS</span></span> (<span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> [wait_type], <span class="hljs-comment"><span class="hljs-comment">--   [wait_time_ms] / 1000.0 AS [WaitS],--      .    signal_wait_time_ms ([wait_time_ms] - [signal_wait_time_ms]) / 1000.0 AS [ResourceS],--        signal_wait_time_ms [signal_wait_time_ms] / 1000.0 AS [SignalS],--           [waiting_tasks_count] AS [WaitCount],--   .         100.0 * [wait_time_ms] / SUM ([wait_time_ms]) OVER() AS [Percentage], ROW_NUMBER() OVER(ORDER BY [wait_time_ms] DESC) AS [RowNum] FROM sys.dm_os_wait_stats WHERE [waiting_tasks_count]&gt;0 and [wait_type] NOT IN ( N'BROKER_EVENTHANDLER', N'BROKER_RECEIVE_WAITFOR', N'BROKER_TASK_STOP', N'BROKER_TO_FLUSH', N'BROKER_TRANSMITTER', N'CHECKPOINT_QUEUE', N'CHKPT', N'CLR_AUTO_EVENT', N'CLR_MANUAL_EVENT', N'CLR_SEMAPHORE', N'DBMIRROR_DBM_EVENT', N'DBMIRROR_EVENTS_QUEUE', N'DBMIRROR_WORKER_QUEUE', N'DBMIRRORING_CMD', N'DIRTY_PAGE_POLL', N'DISPATCHER_QUEUE_SEMAPHORE', N'EXECSYNC', N'FSAGENT', N'FT_IFTS_SCHEDULER_IDLE_WAIT', N'FT_IFTSHC_MUTEX', N'HADR_CLUSAPI_CALL', N'HADR_FILESTREAM_IOMGR_IOCOMPLETION', N'HADR_LOGCAPTURE_WAIT', N'HADR_NOTIFICATION_DEQUEUE', N'HADR_TIMER_TASK', N'HADR_WORK_QUEUE', N'KSOURCE_WAKEUP', N'LAZYWRITER_SLEEP', N'LOGMGR_QUEUE', N'ONDEMAND_TASK_QUEUE', N'PWAIT_ALL_COMPONENTS_INITIALIZED', N'QDS_PERSIST_TASK_MAIN_LOOP_SLEEP', N'QDS_CLEANUP_STALE_QUERIES_TASK_MAIN_LOOP_SLEEP', N'REQUEST_FOR_DEADLOCK_SEARCH', N'RESOURCE_QUEUE', N'SERVER_IDLE_CHECK', N'SLEEP_BPOOL_FLUSH', N'SLEEP_DBSTARTUP', N'SLEEP_DCOMSTARTUP', N'SLEEP_MASTERDBREADY', N'SLEEP_MASTERMDREADY', N'SLEEP_MASTERUPGRADED', N'SLEEP_MSDBSTARTUP', N'SLEEP_SYSTEMTASK', N'SLEEP_TASK', N'SLEEP_TEMPDBSTARTUP', N'SNI_HTTP_ACCEPT', N'SP_SERVER_DIAGNOSTICS_SLEEP', N'SQLTRACE_BUFFER_FLUSH', N'SQLTRACE_INCREMENTAL_FLUSH_SLEEP', N'SQLTRACE_WAIT_ENTRIES', N'WAIT_FOR_RESULTS', N'WAITFOR', N'WAITFOR_TASKSHUTDOWN', N'WAIT_XTP_HOST_WAIT', N'WAIT_XTP_OFFLINE_CKPT_NEW_LOG', N'WAIT_XTP_CKPT_CLOSE', N'XE_DISPATCHER_JOIN', N'XE_DISPATCHER_WAIT', N'XE_TIMER_EVENT') ) , ress as ( SELECT [W1].[wait_type] AS [WaitType], CAST ([W1].[WaitS] AS DECIMAL (16, 2)) AS [Wait_S],--      .    signal_wait_time_ms CAST ([W1].[ResourceS] AS DECIMAL (16, 2)) AS [Resource_S],--        signal_wait_time_ms CAST ([W1].[SignalS] AS DECIMAL (16, 2)) AS [Signal_S],--           [W1].[WaitCount] AS [WaitCount],--   .         CAST ([W1].[Percentage] AS DECIMAL (5, 2)) AS [Percentage], CAST (([W1].[WaitS] / [W1].[WaitCount]) AS DECIMAL (16, 4)) AS [AvgWait_S], CAST (([W1].[ResourceS] / [W1].[WaitCount]) AS DECIMAL (16, 4)) AS [AvgRes_S], CAST (([W1].[SignalS] / [W1].[WaitCount]) AS DECIMAL (16, 4)) AS [AvgSig_S] FROM [Waits] AS [W1] INNER JOIN [Waits] AS [W2] ON [W2].[RowNum] &lt;= [W1].[RowNum] GROUP BY [W1].[RowNum], [W1].[wait_type], [W1].[WaitS], [W1].[ResourceS], [W1].[SignalS], [W1].[WaitCount], [W1].[Percentage] HAVING SUM ([W2].[Percentage]) - [W1].[Percentage] &lt; 95 -- percentage threshold ) SELECT [WaitType] ,MAX([Wait_S]) as [Wait_S] ,MAX([Resource_S]) as [Resource_S] ,MAX([Signal_S]) as [Signal_S] ,MAX([WaitCount]) as [WaitCount] ,MAX([Percentage]) as [Percentage] ,MAX([AvgWait_S]) as [AvgWait_S] ,MAX([AvgRes_S]) as [AvgRes_S] ,MAX([AvgSig_S]) as [AvgSig_S] FROM ress group by [WaitType];</span></span></code> </pre></div></div><br>  Dans ce cas, vous pouvez d√©terminer le manque de RAM par la requ√™te suivante: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">SELECT</span></span> [Percentage]      ,[AvgWait_S]  <span class="hljs-keyword"><span class="hljs-keyword">FROM</span></span> [inf].[vWaits]  <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> [WaitType] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (    <span class="hljs-string"><span class="hljs-string">'PAGEIOLATCH_XX'</span></span>,    <span class="hljs-string"><span class="hljs-string">'RESOURCE_SEMAPHORE'</span></span>,    <span class="hljs-string"><span class="hljs-string">'RESOURCE_SEMAPHORE_QUERY_COMPILE'</span></span>  );</code> </pre><br>  Ici, vous devez faire attention aux performances de Pourcentage et AvgWait_S.  S'ils sont significatifs dans leur totalit√©, alors il y a une tr√®s forte probabilit√© que la RAM ne soit pas suffisante pour une instance de MS SQL Server.  Les valeurs essentielles sont d√©termin√©es individuellement pour chaque syst√®me.  Cependant, vous pouvez commencer avec la m√©trique suivante: Pourcentage&gt; = 1 et AvgWait_S&gt; = 0,005. <br><br>  Pour g√©n√©rer des indicateurs vers un syst√®me de surveillance (par exemple, Zabbix), vous pouvez cr√©er les deux requ√™tes suivantes: <br><br><ol><li>  combien en pourcentage les types d'attentes pour la RAM occupent (la somme de tous ces types d'attentes): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">coalesce</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">sum</span></span>([Percentage]), <span class="hljs-number"><span class="hljs-number">0.00</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [Percentage] <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> [inf].[vWaits] <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> [WaitType] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (    <span class="hljs-string"><span class="hljs-string">'PAGEIOLATCH_XX'</span></span>,    <span class="hljs-string"><span class="hljs-string">'RESOURCE_SEMAPHORE'</span></span>,    <span class="hljs-string"><span class="hljs-string">'RESOURCE_SEMAPHORE_QUERY_COMPILE'</span></span>  );</code> </pre></li><li>  combien de millisecondes occupent les types d'attentes pour la RAM (la valeur maximale de tous les retards moyens pour tous ces types d'attentes): <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">coalesce</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">max</span></span>([AvgWait_S])*<span class="hljs-number"><span class="hljs-number">1000</span></span>, <span class="hljs-number"><span class="hljs-number">0.00</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [AvgWait_MS] <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> [inf].[vWaits] <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> [WaitType] <span class="hljs-keyword"><span class="hljs-keyword">in</span></span> (    <span class="hljs-string"><span class="hljs-string">'PAGEIOLATCH_XX'</span></span>,    <span class="hljs-string"><span class="hljs-string">'RESOURCE_SEMAPHORE'</span></span>,    <span class="hljs-string"><span class="hljs-string">'RESOURCE_SEMAPHORE_QUERY_COMPILE'</span></span>  );</code> </pre></li></ol><br>  Sur la base de la dynamique des valeurs obtenues pour ces deux indicateurs, nous pouvons conclure s'il y a suffisamment de RAM pour l'instance de MS SQL Server. <br><br><h3>  M√©thode de d√©tection de surcharge du processeur </h3><br>  Pour identifier le manque de temps CPU, utilisez simplement la vue syst√®me sys.dm_os_schedulers.  Ici, si l'indicateur runnable_tasks_count est constamment sup√©rieur √† 1, il y a une forte probabilit√© que le nombre de c≈ìurs ne soit pas suffisant pour une instance de MS SQL Server. <br><br>  Pour afficher l'indicateur dans un syst√®me de surveillance (par exemple, Zabbix), vous pouvez cr√©er la requ√™te suivante: <br><br><pre> <code class="sql hljs"><span class="hljs-keyword"><span class="hljs-keyword">select</span></span> <span class="hljs-keyword"><span class="hljs-keyword">max</span></span>([runnable_tasks_count]) <span class="hljs-keyword"><span class="hljs-keyword">as</span></span> [runnable_tasks_count] <span class="hljs-keyword"><span class="hljs-keyword">from</span></span> sys.dm_os_schedulers <span class="hljs-keyword"><span class="hljs-keyword">where</span></span> scheduler_id&lt;<span class="hljs-number"><span class="hljs-number">255</span></span>;</code> </pre><br>  Sur la base de la dynamique des valeurs obtenues pour cet indicateur, nous pouvons conclure s'il y a suffisamment de temps processeur (le nombre de c≈ìurs CPU) pour une instance de MS SQL Server. <br>  Cependant, il est important de se rappeler que les requ√™tes elles-m√™mes peuvent demander plusieurs threads √† la fois.  Et parfois, l'optimiseur ne peut pas √©valuer correctement la complexit√© de la demande elle-m√™me.  Ensuite, la demande peut se voir allouer trop de threads qui, √† un moment donn√©, ne peuvent pas √™tre trait√©s simultan√©ment.  Et cela provoque √©galement un type d'attente associ√© √† un manque de temps processeur, et la croissance de la file d'attente pour les planificateurs qui utilisent des c≈ìurs de processeur sp√©cifiques, c'est-√†-dire que l'indicateur runnable_tasks_count augmentera dans de telles conditions. <br><br>  Dans ce cas, avant d'augmenter le nombre de c≈ìurs de CPU, vous devez configurer correctement les propri√©t√©s de parall√©lisme de l'instance de MS SQL Server, et √† partir de la version 2016, configurer correctement les propri√©t√©s de parall√©lisme des bases de donn√©es requises: <br><br><img src="https://habrastorage.org/webt/iu/dz/ul/iudzulebjpipajxjwgxc9vkgoka.png"><br><br><img src="https://habrastorage.org/webt/7u/pk/qf/7upkqfeuffvrmi98yx5bid3h3wm.png"><br><br>  Ici, il convient de pr√™ter attention aux param√®tres suivants: <br><br><ol><li>  Degr√© maximal de parall√©lisme: d√©finit le nombre maximal de threads pouvant √™tre allou√©s √† chaque demande (la valeur par d√©faut est 0-restriction uniquement par le syst√®me d'exploitation et l'√©dition MS SQL Server) </li><li>  Seuil de co√ªt pour le parall√©lisme - co√ªt estim√© du parall√©lisme (la valeur par d√©faut est 5) </li><li>  Max DOP-d√©finit le nombre maximal de threads qui peuvent √™tre allou√©s √† chaque requ√™te au niveau de la base de donn√©es (mais pas plus que la valeur de la propri√©t√© "Max Degree of Parallelism") (la valeur par d√©faut est 0-restriction uniquement par le syst√®me d'exploitation et l'√©dition MS SQL Server, ainsi que la restriction sur la propri√©t√© "Max Degree of Parallelism" de toute l'instance MS SQL Server) </li></ol><br>  Il est impossible de donner une recette aussi bonne pour tous les cas, c'est-√†-dire que vous devez analyser les demandes difficiles. <br><br>  D'apr√®s ma propre exp√©rience, je recommande l'algorithme d'actions suivant pour les syst√®mes OLTP pour configurer les propri√©t√©s de parall√©lisme: <br><br><ol><li>  interdire d'abord la concurrence en d√©finissant le niveau de l'instance enti√®re de Max Degree of Parallelism sur 1 </li><li>  analyser les requ√™tes les plus difficiles et choisir le nombre optimal de threads pour elles </li><li>  d√©finir le degr√© maximal de parall√©lisme au nombre optimal s√©lectionn√© de threads obtenus √† partir de l'√©l√©ment 2, et pour des bases de donn√©es sp√©cifiques d√©finir la valeur DOP maximale obtenue √† partir de l'√©l√©ment 2 pour chaque base de donn√©es </li><li>  analyser les demandes les plus difficiles et identifier l'effet n√©gatif du multithreading.  Si tel est le cas, augmentez le seuil de co√ªt pour le parall√©lisme. <br>  Pour des syst√®mes tels que 1C, Microsoft CRM et Microsoft NAV, dans la plupart des cas, l'interdiction du multithreading convient. </li></ol><br>  De plus, si l'√©dition Standard est install√©e, alors dans la plupart des cas, l'interdiction du multithreading convient √©tant donn√© que cette √©dition est limit√©e par le nombre de c≈ìurs de processeur. <br><br>  Pour les syst√®mes OLAP, l'algorithme d√©crit ci-dessus ne convient pas. <br><br>  D'apr√®s ma propre exp√©rience, je recommande l'algorithme d'actions suivant pour les syst√®mes OLAP pour d√©finir les propri√©t√©s de parall√©lisme: <br><br><ol><li>  analyser les requ√™tes les plus difficiles et choisir le nombre optimal de threads pour elles </li><li>  d√©finir le degr√© maximal de parall√©lisme au nombre optimal s√©lectionn√© de threads obtenus √† partir de l'√©l√©ment 1, ainsi que pour des bases de donn√©es sp√©cifiques d√©finir la valeur DOP maximale obtenue √† partir de l'√©l√©ment 1 pour chaque base de donn√©es </li><li>  analyser les demandes les plus difficiles et identifier l'effet n√©gatif de la limite de concurrence.  Si tel est le cas, r√©duisez la valeur du seuil de co√ªt pour le parall√©lisme ou r√©p√©tez les √©tapes 1 √† 2 de cet algorithme. </li></ol><br>  Autrement dit, pour les syst√®mes OLTP, nous passons du simple thread au multithread, et pour les syst√®mes OLAP, au contraire, nous passons du multithreading au single thread.  Ainsi, il est possible de s√©lectionner les param√®tres de concurrence optimale pour √† la fois une base de donn√©es sp√©cifique et l'ensemble de l'instance MS SQL Server. <br>  Il est √©galement important de comprendre que les param√®tres des propri√©t√©s de concurrence doivent √™tre modifi√©s au fil du temps en fonction des r√©sultats de la surveillance des performances de MS SQL Server. <br><br><h3>  Recommandations pour d√©finir des indicateurs de trace </h3><br>  D'apr√®s ma propre exp√©rience et celle de mes coll√®gues, je recommande de d√©finir les indicateurs de trace suivants au niveau du d√©marrage du service MS SQL Server pour les versions 2008-2016 pour des performances optimales: <br><br><ol><li>  610 - R√©duction de la journalisation des insertions dans les tables index√©es.  Il peut aider avec des insertions dans des tables avec un grand nombre d'enregistrements et de nombreuses transactions, avec de longues attentes fr√©quentes de WRITELOG pour les changements d'index </li><li>  1117 - Si un fichier d'un groupe de fichiers atteint le seuil de croissance automatique, tous les fichiers du groupe de fichiers sont d√©velopp√©s </li><li>  1118 - Force tous les objets √† se trouver dans diff√©rentes √©tendues (interdiction des extensions mixtes), ce qui minimise la n√©cessit√© de num√©riser la page SGAM, qui est utilis√©e pour suivre les extensions mixtes </li><li>  1224 - D√©sactive l'escalade des verrous en fonction du nombre de verrous.  Une utilisation excessive de la m√©moire peut inclure une escalade des verrous. </li><li>  2371 - Change le seuil pour les mises √† jour automatiques de statistiques fixes en seuil pour les mises √† jour dynamiques de statistiques automatiques.  Il est important de mettre √† jour les plans de requ√™te pour les grandes tables o√π la d√©termination incorrecte du nombre d'enregistrements conduit √† des plans d'ex√©cution erron√©s </li><li>  3226 - Supprime les messages de sauvegarde r√©ussis dans le journal des erreurs </li><li>  4199 - Inclut les modifications apport√©es √† l'optimiseur de requ√™tes publi√© dans la mise √† jour cumulative et les service packs SQL Server </li><li>  6532-6534 - Comprend des performances de requ√™te am√©lior√©es pour les types de donn√©es spatiales </li><li>  8048 - Convertit les objets de m√©moire partitionn√©e NUMA en CPU partitionn√© </li><li>  8780 - Permet une allocation de temps suppl√©mentaire pour la planification d'une demande.  Certaines demandes sans cet indicateur peuvent √™tre rejet√©es car elles n'ont pas de plan de demande (erreur tr√®s rare) </li><li>  9389 - Comprend un tampon de m√©moire dynamique suppl√©mentaire temporairement fourni pour les op√©rateurs en mode batch, qui permet √† l'op√©rateur en mode batch de demander de la m√©moire suppl√©mentaire et d'√©viter de transf√©rer des donn√©es vers tempdb si de la m√©moire suppl√©mentaire est disponible </li></ol><br>  Avant la version 2016, il est utile d'inclure l'indicateur de trace 2301, qui inclut l'optimisation de l'aide √† la d√©cision √©tendue et aide ainsi √† choisir des plans de requ√™te plus corrects.  Cependant, √† partir de la version 2016, cela a souvent un effet n√©gatif dans un temps d'ex√©cution de requ√™te global assez long. <br><br>  De plus, pour les syst√®mes dans lesquels il y a beaucoup d'index (par exemple, pour les bases de donn√©es 1C), je vous recommande d'activer l'indicateur de trace 2330, qui d√©sactive la collecte sur l'utilisation des index, ce qui a g√©n√©ralement un effet positif sur le syst√®me. <br><br>  En savoir plus sur les indicateurs de trace <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici</a> . <br><br>  En utilisant le lien ci-dessus, il est √©galement important de prendre en compte les versions et les assemblys de MS SQL Server, car pour les versions plus r√©centes, certains indicateurs de trace sont activ√©s par d√©faut ou n'ont aucun effet.  Par exemple, dans la version 2017, il est pertinent de d√©finir uniquement les 5 indicateurs de trace suivants: 1224, 3226, 6534, 8780 et 9389. <br><br>  Vous pouvez activer ou d√©sactiver l'indicateur de trace √† l'aide des commandes DBCC TRACEON et DBCC TRACEOFF, respectivement.  Voir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">ici pour</a> plus de d√©tails. <br><br>  Vous pouvez obtenir l'√©tat des indicateurs de trace √† l'aide de la commande DBCC TRACESTATUS: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">plus</a> . <br><br>  Pour que les indicateurs de trace soient inclus dans l'ex√©cution automatique du service MS SQL Server, vous devez acc√©der au Gestionnaire de configuration SQL Server et ajouter ces indicateurs de trace dans les propri√©t√©s du service via -T: <br><br><img src="https://habrastorage.org/webt/nt/oe/l7/ntoel7jpaujursvrp07tvcbnw80.png"><br><br><h3>  R√©sum√© </h3><br>  Dans cet article, certains aspects de la surveillance de MS SQL Server ont √©t√© examin√©s, √† l'aide desquels vous pouvez rapidement identifier un manque de RAM et de temps libre CPU, ainsi qu'un certain nombre d'autres probl√®mes moins √©vidents.  Les indicateurs de trace les plus couramment utilis√©s ont √©t√© pris en compte. <br><br><h3>  Les sources </h3><br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Statistiques de mise en veille de SQL Server</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Statistiques sur les attentes de SQL Server ou dites-moi o√π √ßa fait mal</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Vue syst√®me sys.dm_os_schedulers</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Utilisation de Zabbix pour suivre la base de donn√©es MS SQL Server</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Mode de vie SQL</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Trace drapeaux</a> <br>  ¬ª <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Sql.ru</a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr448044/">https://habr.com/ru/post/fr448044/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr448032/index.html">Plus de robots: Walmart pr√©sente des milliers de machines pour fonctionner dans ses magasins</a></li>
<li><a href="../fr448034/index.html">Recherche de t√¢ches dans JIRA (langage simple). Partie 1: Recherche rapide et basique</a></li>
<li><a href="../fr448036/index.html">Importer vers J. Connect √† partir du fichier de liste d'utilisateurs via l'API</a></li>
<li><a href="../fr448038/index.html">Nouvelles fonctionnalit√©s pour les auteurs d'extensions dans Visual Studio 2019 v.16.1</a></li>
<li><a href="../fr448040/index.html">Le condens√© de mat√©riaux int√©ressants pour le d√©veloppeur mobile # 294 (du 8 au 14 avril)</a></li>
<li><a href="../fr448046/index.html">Radio Day: brevets Marconi et Popov</a></li>
<li><a href="../fr448048/index.html">Comprendre le lierre angulaire: DOM incr√©mentiel et DOM virtuel</a></li>
<li><a href="../fr448050/index.html">Holographie amateur - mat√©riaux aux halog√©nures d'argent</a></li>
<li><a href="../fr448052/index.html">Mikrotik. VPN IPSEC pour NAT en tant que client</a></li>
<li><a href="../fr448054/index.html">SciPy, optimisation sous conditions</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>