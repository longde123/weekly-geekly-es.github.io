<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤸 🧠 🎮 使用C＃和深度学习编写十亿首歌曲 👐🏿 💂 🤛🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="在本文中，我将解释如何构建一个ASP.NET Core网站 ，该网站使用AI只需单击一下按钮即可生成独特的歌曲歌词，并允许用户投票选出最佳歌曲。 

 神经网络 
 大约2.5个月前， OpenAI发表了一篇博客文章 ，其中展示了几乎不可能的事情：一种深度学习模型，可以撰写文章，与人类撰写的文章没有...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>使用C＃和深度学习编写十亿首歌曲</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/453232/"> 在本文中，我将解释如何构建一个<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">ASP.NET Core网站</a> ，该<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">网站</a>使用AI只需单击一下按钮即可生成独特的歌曲歌词，并允许用户投票选出最佳歌曲。 <br><a name="habracut"></a><br><h1> 神经网络 </h1><br> 大约2.5个月前， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">OpenAI</a>发表<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">了一篇博客文章</a> ，其中展示了几乎不可能的事情：一种深度学习模型，可以撰写文章，与人类撰写的文章没有区别。 它产生的文本令人印象深刻，以至于我不得不检查日历以确保它不是愚人节的玩笑（请注意那是2月，西雅图被雪覆盖了）。 <br><br><p><img src="https://habrastorage.org/webt/df/ok/nc/dfoknc5wbfxrkyvigyygtz9kctw.png" alt="GPT-2文字范例"></p><br><p>到目前为止，他们还没有发布拥有超过10亿个参数的最大神经网络（这是一个颇有争议的决定），但是他们在MIT许可下<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">在GitHub上</a>开源了一个较小的117M参数版本。 该模型的名称非常难忘： <b>GPT-2</b> 。 </p><br><p> 因此，大约一个月前，当我试图考虑使用TensorFlow可以完成什么样的出色项目时，该网络便成为了起点。 如果它已经可以生成英文文本，那么在有足够大的数据集的情况下，对其进行<i>微调</i>以生成歌曲歌词应该不会太困难。 </p><br><h2>  GPT-2如何工作？ </h2><br><p> 深度学习研究取得了几项重要成就，使GPT-2成为可能： </p><br><h3> 自我监督学习 </h3><br><p> 在我撰写本文的第一版后几天，这项技术就由Yan LeCunn最终确定。 这是一项非常强大的技术，几乎可以应用于任何类型的现实世界数据。 为了训练GPT-2，OpenAI从各种来源收集了<i>数十GB的文章</i> ，这些<i>文章</i>在Reddit上得到了好评。 </p><br><p> 按照惯例，必须要有人来阅读所有这些文章，例如，将它们标记为“阳性”或“阴性”。 然后他们将以监督的方式教一个神经网络，以与人类相同的方式对这些文章进行分类。 </p><br><p><img src="https://habrastorage.org/webt/cn/sl/_2/cnsl_21o1f-vio39rn5auufl_lw.jpeg" alt="RECAPTCHA：找到路牌"></p><br><p> 这里的新想法是创建一个深度学习模型，该模型对数据有高层次的了解，您只需破坏数据，然后指定模型来恢复原始数据即可。 这使模型能够理解数据片段及其周围上下文之间的联系。 </p><br><p> 让我们以文本为例。  GPT-2提取了原始文本的样本，选择了要破坏的令牌的15％，然后屏蔽了80％的令牌（例如，用特殊的屏蔽令牌替换，通常是___），用字典中的其他随机令牌替换了10％，并保持剩余的10％完整。  <i>我把一个球扔了，它掉到了草地上</i> 。 腐败之后，它看起来可能像这样： <i>我把球扔了，然后___扔到草地上</i> 。 用外行人的话来说，要使网络恢复原始状态，需要了解到，抛出的东西很可能会掉下来，而在这种情况下，汽车球是非常不常见的。 </p><br><p> 像这样训练过的模型可以很好地生成/完成部分数据，但是通过学习模型（作为内层的输出），可以在其上添加一层或两层并进行微调，从而将其用于其他目的。以常规方式<b>仅</b>在实际的， <b>较小的</b> ，人工标记的数据集上添加<b>新的最后一层</b> 。 </p><br><h3> 自我注意力稀疏 </h3><br><p>  GPT-2使用了一种称为稀疏自我注意的东西。 从本质上讲，它是一种技术，它使神经网络能够处理大量输入，从而比其他部分更专注于某些部分。 网络会在训练过程中了解应该“看”的地方。 注意机制在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">此博客文章中</a>有更好的解释。 </p><br><p> 本节标题中的<i>稀疏</i>部分是指对注意力机制可以选择的输入段的限制。 最初的注意力可以从整个输入中选择。 这导致其权重矩阵为O（input_size ^ 2），随输入大小的增长非常快。 稀疏的关注通常以某种方式限制了这一点。 有关更多信息，请<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">参阅</a>另<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">一篇OpenAI博客文章</a> 。 </p><br><p>  GPT-2中的注意力是<i>多头的</i> 。 想象一下，您可能有另外一两只眼睛可以用来检查上一段的内容，而不必停止阅读当前的内容。 </p><br><h3> 还有更多 </h3><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">剩余连接</a> ， <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">字节对编码</a> ，下一句预测等。 </p><br><h2> 移植GPT-2（通常转换为Python） </h2><br><p> 原始的模型代码在Python中，但是我是C＃家伙。 幸运的是，源代码具有很好的可读性，并且<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">症结仅存在于</a> 5个文件中，总共可能有500行。 因此，我创建了一个新的.NET Standard项目，安装了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Gradient</a> （用于.NET的TensorFlow绑定），并将这些文件逐行转换为C＃。 我花了大约2个小时。 代码中剩下的唯一pythonic事情是使用了pip（Python最常用的包管理器）中的Python regex模块，因为我不想浪费时间学习Python正则表达式的复杂性（ <i>好像还不够）已经处理.NET了</i> ）。 </p><br><p> 通常，转换包括定义相似的类，添加类型以及将Python <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">列表理解</a>重写为相应的LINQ构造。 除了标准库中的LINQ，我还使用了<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">MoreLinq</a> ，它稍微扩展了LINQ的功能，例如： </p><br><p></p><pre><code class="python hljs">bs = list(range(ord(<span class="hljs-string"><span class="hljs-string">"!"</span></span>), ord(<span class="hljs-string"><span class="hljs-string">"~"</span></span>)+<span class="hljs-number"><span class="hljs-number">1</span></span>)) + list(range(ord(<span class="hljs-string"><span class="hljs-string">"¡"</span></span>), ord(<span class="hljs-string"><span class="hljs-string">"¬"</span></span>)+<span class="hljs-number"><span class="hljs-number">1</span></span>)) + list(range(ord(<span class="hljs-string"><span class="hljs-string">""</span></span>), ord(<span class="hljs-string"><span class="hljs-string">"ÿ"</span></span>)+<span class="hljs-number"><span class="hljs-number">1</span></span>))</code> </pre> <br><p> 变成： </p><br><p></p><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> bs = Range(<span class="hljs-string"><span class="hljs-string">'!'</span></span>, <span class="hljs-string"><span class="hljs-string">'~'</span></span> - <span class="hljs-string"><span class="hljs-string">'!'</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>) .Concat(Range(<span class="hljs-string"><span class="hljs-string">'¡'</span></span>, <span class="hljs-string"><span class="hljs-string">'¬'</span></span> -<span class="hljs-string"><span class="hljs-string">'¡'</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>)) .Concat(Range(<span class="hljs-string"><span class="hljs-string">''</span></span>, <span class="hljs-string"><span class="hljs-string">'ÿ'</span></span> - <span class="hljs-string"><span class="hljs-string">''</span></span> + <span class="hljs-number"><span class="hljs-number">1</span></span>)) .ToList();</code> </pre> <br><p> 我必须解决的另一件事是Python处理范围的方式与即将到来的C＃8中新的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Ranges和indexs功能</a>之间的差异，我在调试初始运行时发现了这一点：在C＃8中，范围的末尾是<b>包含端点的</b> ，而在Python中则是<b>排他的</b> （要在Python中包含最后一个元素，您必须省略<i>..</i>表达式的右侧）。 </p><br><blockquote> 计算机科学中有两件难事：缓存无效，命名和一次错误。 </blockquote><br><p> 不幸的是，原始的源代码降落不包含任何培训甚至微调代码，但<b>Neil Shepperd</b>在他的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">GitHub上</a>提供了一个简单的微调器，我也必须移植。 无论如何，这种努力的结果是可以用于<b>GPT-2</b>的<b>C＃代码</b>现在已成为Gradient <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Samples</a>存储库的一部分。 </p><br><p> 移植的目的有两个方面：移植后，一个人就可以<b>在他最喜欢的C＃IDE中使用模型代码</b> ，并表明， <b>现在可以在定制中使用最新的深度学习模型了。 .NET</b>在发布后不久（在GPT-2的代码下降与“十亿首歌曲”的第一发布之间-仅仅一个月的时间）内进行了开发。 </p><br><h2> 微调歌曲歌词 </h2><br><p> 有几种方法可以获取大量的歌词。 您可以使用HTML解析器抓取托管它的Internet网站之一，将其从您的卡拉OK集合中拉出，或mp3文件。 幸运的是，有人为我们做到了。 我在<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">Kaggle</a>上找到了很多准备好的歌词数据集。  “ <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">您听到的每首歌</a> ”似乎都是最大的。 在尝试将GPT-2调整为它时，我遇到了两个问题。 </p><br><h3>  CSV阅读 </h3><br><p> 是的，您没有看错， <i>CSV分析是一个问题</i> 。 最初，我想使用ML.NET（用于机器学习的新Microsoft库）读取文件。 但是，浏览完文档并进行设置后，我意识到它无法正确处理歌曲中的换行符。 不管我做什么，在经过数百个示例之后，它还是很挣扎，并开始将歌词与标题和艺术家混在一起。 </p><br><p> 因此，我不得不求助于一个较低级的库，该库以前具有更好的经验： <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">CsvHelper</a> 。 它提供了类似<i>DataReader</i>的界面。 您可以在<a href="" rel="nofollow">此处</a>使用它查看代码。 本质上，您打开文件，配置<i>CsvReader</i> ，然后<i>将对.Read</i> <i>（）</i>的调用与对<i>.GetField（fieldName）的</i>调用交错。 </p><br><h3> 短歌 </h3><br><p> 与OpenAI使用的原始数据集中的普通文章相比，大多数歌曲都简短。  GPT-2训练对大块文本更有效，因此我不得不将几首歌曲捆绑成连续的文本块，以将其输入给训练者。  OpenAI似乎也使用了这种技术，因此它们有一个特殊的标记<i>&lt;| endoftext |&gt;</i> ，它充当块内完整文本之间的分隔符，并兼作起始标记。 我将歌曲捆绑在一起，直到达到一定数量的令牌，然后将整个块返回到训练数据中。 相关代码在<a href="" rel="nofollow">这里</a> 。 </p><br><h3> 调整的硬件要求 </h3><br><p> 甚至较小的GPT-2版本也很大。 使用<b>12GB的GPU RAM，</b>我<b>只能将批处理大小设置为2</b> （例如，一次训练两个块，较大的批处理大小可以提高GPU性能和训练结果）。  3将在CUDA中<i>耗尽内存</i> 。 并且花了半天时间将其调整到我的V100上所需的性能。 好处是您可以看到进度，因为训练代码会不时地输出一些生成的样本，这些样本以简单的纯文本开头，并且随着训练的进行越来越像歌曲的歌词。 </p><br><p> 我没有尝试过，但是<b>在CPU上的培训可能会非常慢</b> 。 </p><br><h3> 预先调整的模型 </h3><br><p> 在准备此博客文章时，我意识到最好不要强迫每个人都花数小时来微调<b>歌词</b> <b>模型</b> ，因此我在<a href="" rel="nofollow">Billion Songs资料库中</a> <b>发布了</b> <b>预先调好的</b> <a href="" rel="nofollow">音乐</a> 。 如果您只是尝试运行“十亿首歌曲”，则无需手动下载。 默认情况下，该项目将为您完成。 </p><br><div class="spoiler">  <b class="spoiler_title">在我身上玩HAL9000的半训练模型</b> <div class="spoiler_text"> 我发誓，我应该写信给你 <br> 我发誓，我发誓 <br> 你现在毁了它，我希望你能做到 <br> 我希望你的梦想，我希望你的梦想，我希望你的梦想，我希望你的梦想，我希望你的梦想 <br> 关于 <br> 我要去的 我要走了 我要走了 我要去，我要去，我要去，我要去，我要去，我要去，我要去， <br> 我要去，我要去，我要去... </div></div><br><h1> 建立一个网站 </h1><br><p> 好啦 看起来就像一首歌，现在让我们建立一个网站！ </p><br><p> 由于我不打算提供任何API，因此我选择了Razor Pages模板而不是MVC。 我也启用了授权功能，因为我们将允许用户投票选出最佳歌词并获得前10名的图表。 </p><br><p> 赶上MVP，我继续创建了Song.cshtml网页，目前它的目标是简单地调用GPT-2并获得随机歌曲。 该页面的布局很简单，基本上由歌曲及其标题组成： </p><br><pre> <code class="xml hljs">@page "/song/{id}" @model BillionSongs.Pages.SongModel<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">p</span></span></span><span class="hljs-tag">&gt;</span></span> @{ ViewData["Title"] = @Model.Song.Title ?? "Untitled"; } <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">article</span></span></span><span class="hljs-tag"> </span><span class="hljs-attr"><span class="hljs-tag"><span class="hljs-attr">style</span></span></span><span class="hljs-tag">=</span><span class="hljs-string"><span class="hljs-tag"><span class="hljs-string">"text-align: center"</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h3</span></span></span><span class="hljs-tag">&gt;</span></span>@(Model.Song.Title ?? "Untitled")<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">h3</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">pre</span></span></span><span class="hljs-tag">&gt;</span></span>@Model.Song.Lyrics<span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">pre</span></span></span><span class="hljs-tag">&gt;</span></span> <span class="hljs-tag"><span class="hljs-tag">&lt;/</span><span class="hljs-name"><span class="hljs-tag"><span class="hljs-name">article</span></span></span><span class="hljs-tag">&gt;</span></span></code> </pre><br><br><p> 现在，因为我喜欢代码可重用，所以我创建了一个接口，该接口可让我稍后插入不同的歌词生成器，然后将其通过ASP.NET注入SongModel中。 </p><br><pre> <code class="cs hljs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">ILyricsGenerator</span></span> { <span class="hljs-function"><span class="hljs-function">Task&lt;</span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">string</span></span></span><span class="hljs-function">&gt; </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">GenerateLyrics</span></span></span><span class="hljs-function">(</span><span class="hljs-params"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint</span></span></span></span><span class="hljs-function"><span class="hljs-params"> song, CancellationToken cancellation</span></span></span><span class="hljs-function">)</span></span>; }</code> </pre><br><p> 现在省略歌曲标题，我们要做的就是在<i>Startup中</i>注册<i>Gpt2LyricsGenerator</i> ， <i>配置Services</i>并从<i>SongModel中</i>调用它。 因此，让我们开始使用生成器。 我们需要确保的第一件事是 </p><br><h2> 可重复的歌词生成 </h2><br><p> 因为我在标题中做了一个大胆的声明，那就是说将会有超过10亿首歌曲，所以甚至不用考虑生成和存储所有歌曲。 首先，没有任何元数据，这将占用超过1TB的磁盘空间。 其次，在我的网络上大约需要3分钟才能生成一首新歌曲，因此要永久生成所有歌曲。 而且我希望能够通过在需要时切换到<i>Int64</i>来<i>将这</i>十亿变成一百万分之一！ 试想一下，如果每增加一千亿首歌曲，我们就能赚一分钱？ 那将超过世界目前每年的GDP！ </p><br><p> 相反，我们需要做的是确保GPT-2一次又一次生成同一首歌曲，并给出我在路由中指定的<i>id</i> 。 为此，TensorFlow可以随时通过<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">tf.set_random_seed</a>函数（如<i>tf.set_random_seed（songNumber））</i>设置其内部数字生成器的种子。 然后，我只想调用<i>Gpt2Sampler.SampleSequence</i> ，以获取编码的歌曲文本，对其进行解码并返回结果，从而完成<i>Gpt2LyricsGenerator</i> 。 </p><br><p> 不幸的是，第一次尝试并没有按预期工作。 每次点击刷新按钮时，页面上都会返回一个新的唯一文本。 经过大量的调试后，我终于发现TensorFlow 1.X在可重复性方面存在重大问题：许多操作具有内部状态，不受<i>set_random_seed的</i>影响，并且很难重置。 </p><br><p> 重新初始化模型变量有助于解决该问题，但也意味着必须重新创建会话，并且每次调用都必须重新加载模型权重。 重新加载该大小的会话会导致巨大的内存泄漏。 为了避免在TensorFlow C ++源代码中查找其原因，我决定不在进程内进行文本生成，而是决定使用<i>Process.Start</i>生成一个新进程，在此生成文本，然后从标准输出中读取文本。 在稳定TensorFlow中的重置模型状态的方法之前，这就是要走的路。 </p><br><p> 因此，我最终得到了两个类： <a href="" rel="nofollow">Gpt2LyricsGenerator</a> ，它通过使用命令行参数（包括歌曲ID）产生BillionSongs.exe的新实例，从上面实现<i>ILyricsGenerator</i> ，并最终实例化了<a href="" rel="nofollow">Gpt2TextGenerator</a> ，该实例实际上调用了GPT-2来生成歌词，以及简单地打印出来。 </p><br><p> 现在刷新页面总是给我相同的文本。 </p><br><h2> 处理3分钟的时间来生成歌曲 </h2><br><p> 这将是多么可怕的用户体验！ 您访问一个网站，单击“制作新歌曲”，并且<b>3分钟内完全没有任何反应，</b>而我的nettop花时间来生成您请求的歌曲歌词。 </p><br><p> 我从多个层面解决了这个问题： </p><br><h3> 预先生成歌曲 </h3><br><p> 如上所述，您无法预先生成所有歌曲，也无法从数据库中提供它们。 而且您不能只按需生成，因为那样会很慢。 那你该怎么办？ </p><br><p> 很简单！ 由于用户观看新歌曲的主要方式是单击“随机”按钮，因此我们预先预先生成很多歌曲，将它们放入<i>ConcurrentQueue中</i> ，然后让“随机”从中弹出歌曲。 当访问者数量很少时，服务器将在他们之间花费一些时间来生成一些歌曲，然后可以方便地访问它们。 </p><br><p> 我使用的另一个技巧是使该队列循环几次，以便许多用户可以看到同一首预生成的歌曲。 只需在RAM使用情况和用户单击“随机”以查看他之前看到的内容之间保持平衡即可。 我只是选择了50,000首歌曲作为一个合理的数量，这只占用了50MB的RAM，同时提供了大量的点击次数。 </p><br><p> 我在类<a href="" rel="nofollow">PregenicSongProvider中</a>实现了该功能： <i>IRandomSongProvider</i> （接口已插入代码中，负责处理“随机”按钮）。 </p><br><h3> 快取 </h3><br><p> 预生成的歌曲被缓存到内存中，但是我还将HTTP <i>缓存</i>标头设置为<i>public，</i>以允许浏览器使用，而CDN（我使用CloudFlare）则将其缓存，以避免受到用户涌入的打击。 </p><br><pre> <code class="cs hljs">[<span class="hljs-meta"><span class="hljs-meta">ResponseCache(VaryByHeader = </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"User-Agent"</span></span></span><span class="hljs-meta">, Duration = 3*60*60)</span></span>] <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">class</span></span> <span class="hljs-title"><span class="hljs-title">SongModel</span></span>: <span class="hljs-title"><span class="hljs-title">PageModel</span></span> { … }</code> </pre><br><h3> 返回流行歌曲 </h3><br><p> 以这种方式微调的GPT-2生成的大多数歌曲，即使不是基本的，也相当乏味。 为了使“随机”的点击更具吸引力，我添加了25％的概率，即您会获得一些歌曲，而不是完全随机的歌曲，该歌曲先前已被其他用户赞成。 除了增加参与度之外，它还增加了您请求存储在CDN或内存中的歌曲的机会。 </p><br><p> 上面的所有技巧都使用<a href="" rel="nofollow">Startup</a>类中的ASP.NET依赖项注入连接在一起。 </p><br><h2> 投票 </h2><br><p> 投票实施没有什么特别之处。 有<a href="" rel="nofollow">SongVoteCache</a> ，可以使计数保持最新。 并在歌曲页面上<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">托管一个带投票按钮</a>的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">iframe</a> ，该页面允许页面的基本部分-标题和歌词被缓存，而投票计数和登录状态将在以后加载。 </p><br><h1> 最终结果 </h1><br><p> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow"><img src="https://habrastorage.org/webt/aw/c7/wf/awc7wfzablt9gotcrrv8nsihrvu.png" alt="生成的歌曲样本"></a> <br></p><br><p> 现在已冻结在<s>我的</s>网上<s>桌面</s>上运行<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">的演示版本</a> <s>，并以CloudFlare为首（给它一点放松，它的Core i3），并将其</s>转移到Azure应用服务免费层。 </p><br><p>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">GitHub存储库</a> ，包含源代码以及运行网站和调整模型的说明。 </p><br><h1> 未来计划/练习 </h1><br><h2> 产生标题 </h2><br><p>  GPT-2非常易于微调。 可以通过在数据集的每个歌词样本前添加前缀或后缀，例如<i>&lt;| startoftitle |&gt;</i>以及同一数据集的标题，使它生成歌曲标题。 </p><br><p> 或者，可以允许用户对标题进行建议和/或投票。 </p><br><h2> 产生音乐 </h2><br><p> 在开发十亿首歌曲的过程中，我认为下载一堆MIDI文件（这是一种老式的音乐格式，比mp3格式更接近文本，并训练它们上的GPT-2）会很酷。 。 其中一些文件甚至嵌入了文本，因此<b>可以产生卡拉OK</b> 。 </p><br><p> 我知道以这种方式进行音乐创作是很有可能的，因为昨天<b>OpenAI实际上</b> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">在他们的博客中</a> <b>发布了该想法的实现</b> 。 但是，万岁， <b>他们没有</b>唱<b>卡拉OK！</b> 我发现，可以出于此目的刮取<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">http://www.midi-karaoke.info</a> 。 </p><br><h2>  NET的梯度aka TensorFlow </h2><br> 请查看我们的<a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=zh-CN&amp;u=" rel="nofollow">博客</a>以获取任何更新。 </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/zh-CN453232/">https://habr.com/ru/post/zh-CN453232/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../zh-CN453216/index.html">VoIP网络中的流量监控系统。 第二部分-组织原则</a></li>
<li><a href="../zh-CN453218/index.html">YaC 2019的主要内容：路上行驶的一百架无人机，Yandex模块，食品，智能家居</a></li>
<li><a href="../zh-CN453220/index.html">避免更好地参与的13个电子邮件营销错误</a></li>
<li><a href="../zh-CN453222/index.html">SphinxSearch-meetup SuperJob</a></li>
<li><a href="../zh-CN453228/index.html">数码时钟IN-18</a></li>
<li><a href="../zh-CN453234/index.html">EOS设备中交换协议的逆向工程</a></li>
<li><a href="../zh-CN453236/index.html">制作手机游戏的原型，从哪里开始以及如何做。 第二部分</a></li>
<li><a href="../zh-CN453238/index.html">继电器上的行车灯</a></li>
<li><a href="../zh-CN453242/index.html">夏季活动的游乐场</a></li>
<li><a href="../zh-CN453246/index.html">ERP-连续降级系统</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>