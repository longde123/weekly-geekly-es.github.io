<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üßòüèº üë©üèª‚Äçü§ù‚Äçüë®üèΩ üèâ Byte-Maschine f√ºr das Fort (und nicht nur) in Native American (Teil 3) ‚èÆÔ∏è ‚öíÔ∏è üï°</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Das Jahr 2019 ist gekommen. Die Neujahrsferien gehen zu Ende. Es ist Zeit, sich an Bytes, Befehle, Variablen, Schleifen zu erinnern ... 

 Etwas, das ...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Byte-Maschine f√ºr das Fort (und nicht nur) in Native American (Teil 3)</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/435236/"><img src="https://habrastorage.org/getpro/habr/post_images/dbb/a59/e93/dbba59e932ecdb4b0c28896a7e6fc3e3.jpg" alt="Bild"><br><br>  Das Jahr 2019 ist gekommen. Die Neujahrsferien gehen zu Ende.  Es ist Zeit, sich an Bytes, Befehle, Variablen, Schleifen zu erinnern ... <br><br>  Etwas, das ich mit diesen Feiertagen bereits vergessen habe.  Muss zusammen erinnern! <br><br>  Heute werden wir einen Interpreter f√ºr unsere Byte-Maschine erstellen.  Dies ist der dritte Artikel, die ersten Teile sind hier: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 1</a> , <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Teil 2</a> . <br><br>  Frohes Neues Jahr an alle und willkommen zum Schnitt! <br><a name="habracut"></a><br>  Zun√§chst werde ich Fragen von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">fpauk</a> beantworten.  Diese Fragen sind absolut richtig.  Die Architektur dieser Byte-Maschine ist nun so, dass wir mit direkten Prozessoradressen arbeiten.  Im Bytecode sind diese Adressen jedoch nicht, sie werden nach dem Start des Systems gebildet.  Nach dem Start des Systems k√∂nnen wir beliebige Zeiger erstellen, und dieser Code funktioniert auf jeder Plattform ordnungsgem√§√ü.  Beispielsweise kann die Adresse einer Variablen oder eines Arrays mit dem Befehl var0 abgerufen werden.  Dieser Befehl funktioniert auf jeder Plattform und gibt die richtige Adresse zur√ºck, die f√ºr diese Plattform spezifisch ist.  Dann k√∂nnen Sie mit dieser Adresse arbeiten, wie Sie m√∂chten. <br><br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">Trotzdem</a> hat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=" class="user_link">fpauk</a> recht.  Die Adresse kann nicht im Bytecode gespeichert werden.  Es stellt sich heraus, dass wir plattformunabh√§ngigen Code schreiben k√∂nnen, aber daf√ºr m√ºssen wir einige Anstrengungen unternehmen.  Stellen Sie insbesondere sicher, dass sich die Adressen nicht im Bytecode befinden.  Und sie k√∂nnen beispielsweise eintreten, wenn Sie den kompilierten Code in einer Datei speichern.  Es enth√§lt Daten und kann Adressen sein.  Zum Beispiel die Werte der Variablen hier, des Kontexts und anderer. <br><br>  Um ein solches Problem zu beheben, m√ºssen Sie die Adressen virtuell machen.  Die Adressierung des x86-Prozessors ist sehr leistungsf√§hig und f√ºgt in den meisten F√§llen nicht einmal zus√§tzliche Befehle hinzu.  Trotzdem werde ich in der aktuellen Architektur mit absoluten Adressen weitermachen.  Wenn wir dann zu den Tests kommen, k√∂nnen wir die Adressen in virtuelle Adressen umwandeln und sehen, wie sich dies auf die Leistung auswirkt.  Das ist interessant. <br><br><h4>  Aufw√§rmen </h4><br>  Und jetzt ein kleines Training.  Lassen Sie uns einen weiteren Teil kleiner, aber n√ºtzlicher Bytebefehle erstellen.  Dies sind die Befehle nip, emit, 1+, + !, - !, Count, Arbeitsw√∂rter mit dem R√ºckgabestapel r&gt;,&gt; r, r @, ein String-Literal (") und konstante W√∂rter 1, 2, 3, 4, 8. Vergessen Sie nicht, sie in die Befehlstabelle aufzunehmen. <br><br><div class="spoiler">  <b class="spoiler_title">Hier ist der Code f√ºr diese Befehle</b> <div class="spoiler_text"><pre><code class="cpp hljs">b_nip = <span class="hljs-number"><span class="hljs-number">0x39</span></span> bcmd_nip: pop rax mov [rsp], rax jmp _next b_emit = <span class="hljs-number"><span class="hljs-number">0x81</span></span> bcmd_emit: pop rax mov rsi, offset emit_buf #   mov [rsi], al mov rax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> - sys_write mov rdi, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> mov rdx, <span class="hljs-number"><span class="hljs-number">1</span></span> #   push r8 syscall #   pop r8 jmp _next b_wp = <span class="hljs-number"><span class="hljs-number">0x18</span></span> bcmd_wp: incq [rsp] jmp _next b_setp = <span class="hljs-number"><span class="hljs-number">0x48</span></span> bcmd_setp: pop rcx pop rax add [rcx], rax jmp _next b_setm = <span class="hljs-number"><span class="hljs-number">0x49</span></span> bcmd_setm: pop rcx pop rax sub [rcx], rax jmp _next b_2r = <span class="hljs-number"><span class="hljs-number">0x60</span></span> bcmd_2r: pop rax sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> mov [rbp], rax jmp _next b_r2 = <span class="hljs-number"><span class="hljs-number">0x61</span></span> bcmd_r2: push [rbp] add rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> jmp _next b_rget = <span class="hljs-number"><span class="hljs-number">0x62</span></span> bcmd_rget: push [rbp] jmp _next b_str = <span class="hljs-number"><span class="hljs-number">0x82</span></span> bcmd_str: movzx rax, byte ptr [r8] lea r8, [r8 + rax + <span class="hljs-number"><span class="hljs-number">1</span></span>] jmp _next b_count = <span class="hljs-number"><span class="hljs-number">0x84</span></span> bcmd_count: pop rcx movzx rax, byte ptr [rcx] inc rcx push rcx push rax jmp _next b_num1 = <span class="hljs-number"><span class="hljs-number">0x03</span></span> bcmd_num1: push <span class="hljs-number"><span class="hljs-number">1</span></span> jmp _next b_num2 = <span class="hljs-number"><span class="hljs-number">0x04</span></span> bcmd_num2: push <span class="hljs-number"><span class="hljs-number">2</span></span> jmp _next b_num3 = <span class="hljs-number"><span class="hljs-number">0x05</span></span> bcmd_num3: push <span class="hljs-number"><span class="hljs-number">3</span></span> jmp _next b_num4 = <span class="hljs-number"><span class="hljs-number">0x06</span></span> bcmd_num4: push <span class="hljs-number"><span class="hljs-number">4</span></span> jmp _next b_num8 = <span class="hljs-number"><span class="hljs-number">0x07</span></span> bcmd_num8: push <span class="hljs-number"><span class="hljs-number">8</span></span> jmp _next</code> </pre> <br></div></div><br>  Der Befehl nip entfernt das Wort unter dem oberen Rand des Stapels.  Dies entspricht dem Austauschen von Drop-Befehlen.  Dies kann manchmal hilfreich sein. <br><br>  Der Befehl emit schiebt ein Zeichen vom Stapel.  Es wird dieselbe Systemaufrufnummer 1 verwendet, das Zeichen wird in einem Puffer mit einer L√§nge von 1 abgelegt. <br><br>  Der Befehl count ist sehr einfach - er nimmt die Adresse der Zeile mit dem Z√§hler vom Stapel und wandelt sie in zwei Werte um - die Adresse der Zeile ohne Z√§hler und die L√§nge. <br><br>  Die Befehle b_2r, b_r2, b_rget sind die Fort-W√∂rter r&gt;,&gt; r, r @.  Der erste nimmt das Wort aus dem R√ºckgabestapel und legt es auf den arithmetischen Stapel.  Die zweite f√ºhrt die entgegengesetzte Operation aus.  Der dritte kopiert das Wort vom R√ºckgabestapel, platziert es in der arithmetischen, der R√ºckgabestapel √§ndert sich nicht. <br><br>  Die Befehle b_setp und b_setm sind die W√∂rter +!  und -! .. Sie nehmen den Wert und die Adresse vom Stapel und √§ndern das Wort an der angegebenen Adresse, indem sie den Wert zum Stapel hinzuf√ºgen oder daraus entfernen. <br><br>  Der Befehl b_str hat einen Parameter beliebiger L√§nge - eine Zeile mit einem Z√§hler.  Diese Zeile befindet sich im Bytecode nach dem Befehlsbyte, und der Befehl schiebt einfach die Adresse dieser Zeile auf den Stapel.  In der Tat ist dies ein String-Literal. <br><br>  Der Rest des Teams braucht meiner Meinung nach keine Kommentare. <br><br>  Wir werden auch einen Befehl zum Drucken einer konstanten Zeichenfolge (. ") Ausgeben. Wir werden ihn wie folgt als Einstiegspunkt f√ºr die Eingabe implementieren: <br><br><pre> <code class="cpp hljs">b_strp = <span class="hljs-number"><span class="hljs-number">0x83</span></span> bcmd_strp: movsx rax, byte ptr [r8] inc r8 push rax push r8 add r8, rax b_type = <span class="hljs-number"><span class="hljs-number">0x80</span></span> bcmd_type: mov rax, <span class="hljs-number"><span class="hljs-number">1</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> - sys_write mov rdi, <span class="hljs-number"><span class="hljs-number">1</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx #   pop rsi #   push r8 syscall #   pop r8 jmp _next</code> </pre><br>  Dieser Befehl ist √§hnlich wie b_str aufgebaut.  Nur legt sie nichts auf den Stapel.  Die Zeile hinter diesem Befehl als Parameter wird dem Benutzer einfach angezeigt. <br><br>  Das Aufw√§rmen ist vorbei, es ist Zeit f√ºr etwas Ernsthafteres.  Besch√§ftigen wir uns mit den Wortgeneratoren und anderen var-Befehlen. <br><br><h4>  Generatorw√∂rter </h4><br>  Erinnern Sie sich an die Variablen.  Wir wissen, wie sie auf Bytecode-Ebene angeordnet sind (Befehl var0).  Um eine neue Variable zu erstellen, verwendet das Fort die folgende Konstruktion: <br><br><pre> <code class="cpp hljs">variable &lt; &gt;</code> </pre><br>  Nach dem Ausf√ºhren dieser Sequenz wird ein neues Wort &lt;Variablenname&gt; erstellt.  Bei der Ausf√ºhrung dieses neuen Wortes wird die Adresse auf dem Stapel verschoben, um den Wert der Variablen zu speichern.  Es gibt auch Konstanten in der Festung, sie sind wie folgt erstellt: <br><br><pre> <code class="cpp hljs">&lt;&gt; constant &lt; &gt;</code> </pre><br>  Nach dem Erstellen der Konstante wird die Ausf√ºhrung des Wortes &lt;Konstantenname&gt; auf dem Stapel &lt;Wert&gt; platziert. <br><br>  Somit sind sowohl die Wortvariable als auch die Wortkonstante Generatorw√∂rter.  Sie sollen neue W√∂rter schaffen.  In einer Festung werden solche W√∂rter mit dem Konstrukt create ... does&gt; beschrieben. <br><br>  Variablen und Konstanten k√∂nnen wie folgt definiert werden: <br><br><pre> <code class="cpp hljs">: variable create <span class="hljs-number"><span class="hljs-number">0</span></span> , does&gt; ; : constant create , does&gt; @ ;</code> </pre><br>  Was bedeutet das alles? <br><br>  Wenn das Wort create ausgef√ºhrt wird, wird ein neues Wort mit dem Namen erstellt, den es beim Ausf√ºhren aus dem Eingabestream erh√§lt.  Nach der Erstellung wird eine Folge von W√∂rtern ausgef√ºhrt, bevor das Wort&gt; ausf√ºhrt.  Aber im Moment der Ausf√ºhrung dieses Wortes wird das, was danach geschrieben wird, ausgef√ºhrt.  Gleichzeitig befindet sich die Datenadresse bereits auf dem Stapel (wie im Fort ‚ÄûDatenfelder‚Äú angegeben). <br><br>  Beim Erstellen einer Variablen wird also die Sequenz "0" ausgef√ºhrt - dies ist die Reservierung eines Maschinenworts mit Nullf√ºllung.  Und wenn das erstellte Wort ausgef√ºhrt wird, wird nichts getan (danach tut es nichts).  Die Speicheradresse, in der der Wert gespeichert ist, verbleibt einfach auf dem Stapel. <br><br>  Bei der Definition einer Konstante wird ein Wort mit einem Wert reserviert, der den Stapel ausf√ºllt.  Wenn das erstellte Wort ausgef√ºhrt wird, wird "@" ausgef√ºhrt, wodurch der Wert an der angegebenen Adresse abgerufen wird. <br><br>  Lassen Sie uns nun dar√ºber nachdenken, wie das von uns erstellte Wort angeordnet werden kann.  Es schiebt die Datenadresse auf den Stapel (wie var0) und √ºbertr√§gt dann die Steuerung an eine bestimmte Adresse, den Bytecode.  Der Befehl var0 kehrt sofort zur√ºck.  Aber in diesem Fall m√ºssen wir keine R√ºckkehr machen, sondern tats√§chlich einen √úbergang. <br><br>  Ich formuliere noch einmal, was zu tun ist: <br><br><ul><li>  Datenadresse auf den Stapel legen </li><li>  Springe zu einem Code, nachdem&gt; </li></ul><br>  Es stellt sich heraus, dass Sie nur die Steuerung an eine andere Bytecode-Adresse √ºbertragen m√ºssen, aber zuerst die Adresse des n√§chsten Bytes (R8) auf den Stapel legen m√ºssen. <br><br>  Es ist fast ein Verzweigungsbefehl!  Und hier ist sie nicht allein.  Habe bereits branch8 und branch16.  Wir werden die neuen Befehle var8 und var16 benennen und dies nur die Einstiegspunkte f√ºr die Verzweigungsbefehle sein lassen.  Wir sparen beim √úbergang zum √úbergangsteam :) Also wird es so sein: <br><br><pre> <code class="cpp hljs">b_var8 = <span class="hljs-number"><span class="hljs-number">0x29</span></span> bcmd_var8: push r8 b_branch8 = <span class="hljs-number"><span class="hljs-number">0x10</span></span> bcmd_branch8: movsx rax, byte ptr [r8] add r8, rax jmp _next b_var16 = <span class="hljs-number"><span class="hljs-number">0x30</span></span> bcmd_var16: push r8 b_branch16 = <span class="hljs-number"><span class="hljs-number">0x11</span></span> bcmd_branch16: movsx rax, word ptr [r8] add r8, rax jmp _next</code> </pre><br>  In guter Weise funktioniert der Befehl var32 weiterhin und var64 auch.  Wir haben keine so langen √úberg√§nge, da gew√∂hnliche √úberg√§nge nicht so lang sind.  F√ºr den Befehl var ist dies jedoch ein sehr realistischer Fall.  Aber im Moment werden wir diese Befehle nicht ausf√ºhren.  Wir werden es sp√§ter tun, falls n√∂tig. <br><br>  Mit den Wortgeneratoren aussortiert.  Es war an der Zeit, sich f√ºr das W√∂rterbuch zu entscheiden. <br><br><h4>  Wortschatz </h4><br>  Wenn sie vereinfacht √ºber das Fort-W√∂rterbuch sprechen, wird es normalerweise in Form einer unidirektionalen Liste von W√∂rterbucheintr√§gen dargestellt.  Tats√§chlich ist alles etwas komplizierter, da die Festung viele W√∂rterb√ºcher unterst√ºtzt.  In der Tat sind sie ein Baum.  Die Suche nach einem Wort in einem solchen Baum beginnt mit einem ‚ÄûBlatt‚Äú - dies ist das letzte Wort im aktuellen W√∂rterbuch.  Das aktuelle W√∂rterbuch wird durch die Kontextvariable definiert, und die Adresse des letzten Wortes befindet sich im W√∂rterbuchwort.  Eine weitere Variable wird zum Verwalten von W√∂rterb√ºchern verwendet. Sie definiert ein W√∂rterbuch, in dem neue W√∂rter hinzugef√ºgt werden.  Somit kann ein W√∂rterbuch f√ºr eine Suche installiert werden und ein anderes, um neue W√∂rter aufzunehmen. <br><br>  F√ºr unseren einfachen Fall w√§re es m√∂glich, nicht die Unterst√ºtzung vieler W√∂rterb√ºcher zu leisten, aber ich habe beschlossen, nichts zu vereinfachen.  Um den Bytecode, die Byte-Maschine, zu verstehen, ist es nicht erforderlich, zu wissen, was in diesem Abschnitt beschrieben wird.  Wenn Sie nicht interessiert sind, k√∂nnen Sie diesen Abschnitt einfach √ºberspringen.  Nun, wer will die Details wissen - mach weiter! <br><br>  Zun√§chst gibt es ein grundlegendes W√∂rterbuch mit dem Namen.  Dies bedeutet, dass es ein solches Wort gibt.  Dieses Wort wird auch als "W√∂rterbuch" bezeichnet, es gibt einige Verwirrung.  Wenn es um ein Wort geht, werde ich es daher ein W√∂rterbuchwort nennen. <br><br>  Mit dieser Konstruktion werden neue W√∂rterb√ºcher erstellt: <br><br><pre> <code class="cpp hljs">vocabulary &lt;  &gt;</code> </pre><br>  Dadurch wird ein Wort mit dem Namen &lt;Name des erstellten W√∂rterbuchs&gt; erstellt.  Bei der Ausf√ºhrung legt dieses Wort das erstellte W√∂rterbuch als Startw√∂rterbuch f√ºr die Suche fest. <br><br>  Tats√§chlich enth√§lt das W√∂rterbuchwort einen Link zum letzten Artikel dieses W√∂rterbuchs, mit dem die Suche beginnt.  Und zum Zeitpunkt der Ausf√ºhrung schreibt dieses W√∂rterbuchwort einen Link zu seinem Datenfeld in die Kontextvariable. <br><br>  Sp√§ter wird es m√∂glich sein, das Wort Vokabular zu erstellen, das in der aktuellen Implementierung auf dem Fort ganz einfach beschrieben wird: <br><br><pre> <code class="cpp hljs">: vocabulary create context @ , does&gt; context ! ;</code> </pre><br>  Also, erschaffe das Wort weiter.  Wir werden den Befehl var8 verwenden.  Bytecode "Kontext!"  Platz direkt hinter dem Datenfeld: <br><br><pre> <code class="cpp hljs">forth: .byte b_var8 .byte does_voc - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .quad <span class="hljs-number"><span class="hljs-number">0</span></span> # &lt;--      .      ,    -    . does_voc: .byte b_call8 .byte context - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_set .byte b_exit</code> </pre><br>  Nun zur√ºck zum Erstellen des W√∂rterbuchs. <br><br>  Im Allgemeinen wird in einer Festung eine Beschreibung eines Wortes im Speicher als ‚ÄûW√∂rterbucheintrag‚Äú bezeichnet.  Normalerweise w√ºrde ich sagen, dass es einen Artikeltitel und seinen Code gibt.  In einer Festung ist jedoch nicht alles √ºblich. Dort wird es als "Namensfeld", "Kommunikationsfeld", "Codefeld" und "Datenfeld" bezeichnet.  Ich werde versuchen, Ihnen zu sagen, was dies alles auf traditionelle Weise bedeutet. <br><br>  Das Namensfeld ist der Name des Wortes "Zeile mit einem Z√§hler".  Es ist wie im alten Pascal - Byte der Stringl√§nge, dann String.  Das Linkfeld ist ein Link zum vorherigen Artikel.  Fr√ºher gab es nur eine Adresse, aber wir werden einen plattformunabh√§ngigen Code haben, und dies wird ein Offset sein.  Das Codefeld, traditionell in der Festung, ist Maschinencode (wenn sich die Implementierung in einer direkten Linie befindet). F√ºr W√∂rter au√üerhalb des Kernels wurde _call aufgerufen.  Wir werden nur einen Bytecode haben.  Und das Datenfeld ist f√ºr W√∂rter, die Daten enthalten - zum Beispiel f√ºr Variablen oder Konstanten.  Das Wort W√∂rterbuch bezieht sich √ºbrigens auch darauf. <br><br>  F√ºr den Compiler ben√∂tigen wir noch Flags.  Normalerweise ben√∂tigt eine Festung nur eine Flagge - sofort, und sie befindet sich in einem langen Byte (manchmal gibt es eine andere - versteckt).  Dies gilt jedoch f√ºr direkt gen√§hten Code, bei dem die Prozessorsteuerung beim Aufruf in das Codefeld √ºbertragen wird.  Und wir haben verschiedene W√∂rter - Bytecode und Maschinencode, und mindestens zwei oder sogar drei Flags werden ben√∂tigt. <br><br>  Wie viel wird f√ºr das Kommunikationsfeld ben√∂tigt?  Am Anfang wollte ich 16 Bit verwenden.  Dies ist ein Link zum vorherigen Wort, und das Wort ist definitiv kleiner als 64 KB.  Aber dann erinnerte ich mich, dass das Wort Daten fast jeder Gr√∂√üe enthalten kann.  Au√üerdem kann der Link in Gegenwart mehrerer W√∂rterb√ºcher viele W√∂rter umfassen.  Es stellt sich heraus, dass in den meisten F√§llen 8 Bit ausreichen, aber es k√∂nnen 16 und 32 sein. Und sogar 64 Bit, wenn Daten mit mehr als 4 GB vorhanden sind.  Lassen Sie uns alle Optionen unterst√ºtzen.  Welche Option wird verwendet - setzen Sie die Flags.  Es werden mindestens 4 Flags ausgegeben: das unmittelbare Attribut, das Kernwortattribut und 2 Bits pro Variante des verwendeten Kommunikationsfelds.  Auf keine andere Weise muss ein separates Byte f√ºr Flags verwendet werden. <br><br>  Wir definieren die Flags wie folgt: <br><br><pre> <code class="cpp hljs">f_code = <span class="hljs-number"><span class="hljs-number">0x80</span></span> f_immediate = <span class="hljs-number"><span class="hljs-number">0x60</span></span></code> </pre><br>  Das f_code-Flag steht f√ºr Kernelw√∂rter, die in Assembler geschrieben wurden. Das f_immediate-Flag ist f√ºr den Compiler im n√§chsten Artikel hilfreich.  Und die zwei niedrigstwertigen Bits bestimmen die L√§nge des Kommunikationsfeldes (1, 2, 4 oder 8 Bytes). <br><br>  Der Titel des Artikels lautet also wie folgt: <br><br><ul><li>  Flags (1 Byte) </li><li>  Kommunikationsfeld (1-8 Bytes) </li><li>  Name L√§nge Byte </li><li>  Name (1-255 Bytes) </li></ul><br>  Bis zu diesem Punkt habe ich die Funktionen des "Makro" -Assemblers nicht verwendet.  Und jetzt brauchen wir sie.  So habe ich ein Makro mit dem Namenselement erhalten, um den Titel des Wortes zu bilden: <br><br><pre> <code class="cpp hljs">.macro item name, flags = <span class="hljs-number"><span class="hljs-number">0</span></span> link = . - p_item <span class="hljs-number"><span class="hljs-number">9</span></span>: .<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> link &gt;= <span class="hljs-number"><span class="hljs-number">-256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; link &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> .byte \flags .byte link .elseif link &gt;= <span class="hljs-number"><span class="hljs-number">-256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; link &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> .byte \flags | <span class="hljs-number"><span class="hljs-number">1</span></span> .word . - p_item .elseif link &gt;= <span class="hljs-number"><span class="hljs-number">-256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; link &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> .byte \flags | <span class="hljs-number"><span class="hljs-number">2</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> . - p_item .elseif link &gt;= <span class="hljs-number"><span class="hljs-number">-256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; link &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> .byte \flags | <span class="hljs-number"><span class="hljs-number">3</span></span> .quad . - p_item .endif p_item = <span class="hljs-number"><span class="hljs-number">9b</span></span> .byte <span class="hljs-number"><span class="hljs-number">9f</span></span> - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .ascii <span class="hljs-string"><span class="hljs-string">"\name"</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>: .endm</code> </pre><br>  Dieses Makro verwendet den Wert p_item - dies ist die Adresse des vorherigen W√∂rterbucheintrags.  Dieser Wert am Ende wird f√ºr die zuk√ºnftige Verwendung aktualisiert: p_item = 9b.  Hier ist 9b eine Bezeichnung, keine Zahl, nicht verwirren :) Das Makro hat zwei Parameter - den Namen des Wortes und Flags (optional).  Zu Beginn des Makros wird der Versatz zum vorherigen Wort berechnet.  Dann werden abh√§ngig von der Gr√∂√üe des Versatzes die Flags und das Kommunikationsfeld der gew√ºnschten Gr√∂√üe kompiliert.  Dann das Byte der L√§nge des Namens und des Namens selbst. <br><br>  Definieren Sie vor dem ersten Wort p_item wie folgt: <br><br><pre> <code class="cpp hljs">p_item = .</code> </pre><br>  Der Punkt ist die aktuelle Kompilierungsadresse im Assembler.  Aufgrund dieser Definition bezieht sich das erste Wort auf sich selbst (das Kommunikationsfeld ist 0).  Dies ist ein Zeichen f√ºr das Ende der W√∂rterb√ºcher. <br><br>  Was steht √ºbrigens im Codefeld der Kernelw√∂rter?  Sie m√ºssen den Befehlscode mindestens irgendwo speichern.  Ich beschloss, den einfachsten Weg zu gehen.  F√ºr Kernelw√∂rter gibt es auch einen Bytecode.  F√ºr die meisten Teams ist dies nur ein Bytebefehl, gefolgt von b_exit.  Daher muss f√ºr den Interpreter das Flag f_code nicht analysiert werden, und die Befehle daf√ºr unterscheiden sich in keiner Weise.  Sie m√ºssen nur den Bytecode f√ºr alle aufrufen. <br><br>  Diese Option bietet einen weiteren Vorteil.  F√ºr Befehle mit Parametern k√∂nnen Sie sichere Parameter angeben.  Wenn Sie beispielsweise den Befehl lit in Fort-Implementierungen mit direkt gen√§htem Code aufrufen, st√ºrzt das System ab.  Und hier wird es dort geschrieben, zum Beispiel leuchtet 0, und diese Sequenz setzt einfach 0 auf den Stapel.  Auch f√ºr die Verzweigung kann sicher gearbeitet werden! <br><br><pre> <code class="cpp hljs"> .byte branch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit</code> </pre><br>  Bei einem solchen Anruf entsteht ein gewisser Aufwand, der f√ºr den Dolmetscher jedoch nicht von Bedeutung ist.  Der Compiler analysiert die Flags und kompiliert den richtigen und schnellen Code. <br><br>  Das erste Wort wird nat√ºrlich das Wort ‚Äûher‚Äú sein - das Grundvokabular, das wir erstellen.  Hier kommen Sie einfach in den praktischen var-Befehl mit einem Link zum Code nach does&gt;.  Ich habe diesen Code bereits im vorherigen Abschnitt zitiert, werde ihn aber mit der √úberschrift noch einmal wiederholen: <br><br><pre> <code class="cpp hljs">p_item = . item forth .byte b_var8 .byte does_voc - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .quad <span class="hljs-number"><span class="hljs-number">0</span></span> does_voc: .byte b_call8 .byte context - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_set .byte b_exit</code> </pre><br>  Und wir werden sofort die Kontextvariablen erstellen und sie ben√∂tigen, um nach W√∂rtern zu suchen: <br><br><pre> <code class="cpp hljs"> item .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">0</span></span> item context context: .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">0</span></span></code> </pre><br>  Und jetzt m√ºssen Sie geduldig sein und einen Titel f√ºr jedes Wort schreiben, das wir in Assembler mit dem Flag f_code geschrieben haben: <br><br><pre> <code class="cpp hljs"> item <span class="hljs-number"><span class="hljs-number">0</span></span>, f_code .byte b_num0 .byte b_exit item <span class="hljs-number"><span class="hljs-number">1</span></span>, f_code .byte b_num1 .byte b_exit ... item <span class="hljs-number"><span class="hljs-number">1</span></span>-, f_code .byte b_wm .byte b_exit item <span class="hljs-number"><span class="hljs-number">1</span></span>+, f_code .byte b_wp .byte b_exit item +, f_code .byte b_add .byte b_exit item -, f_code .byte b_sub .byte b_exit item *, f_code .byte b_mul .byte b_exit</code> </pre><br>  Usw‚Ä¶ <br><br>  Mit in Bytecode geschriebenen Teams ist das noch einfacher.  Es reicht aus, nur eine √úberschrift vor dem Bytecode einzuf√ºgen, genau wie das vierte Wort, zum Beispiel: <br><br><pre> <code class="cpp hljs"> item hold hold: .byte b_call8 .byte holdpoint - . - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-meta"><span class="hljs-meta"># holdpoint ...</span></span></code> </pre><br>  F√ºr Befehle mit Parametern erstellen wir sichere Parameter.  Lassen Sie zum Beispiel die Lite-Befehle die Nummer Pi zur√ºckgeben. Wenn jemand sie interaktiv aufruft, gibt es so ein Osterfest :) <br><br><pre> <code class="cpp hljs"> item lit8, f_code .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">31</span></span> .byte b_exit item lit16, f_code .byte b_lit16 .word <span class="hljs-number"><span class="hljs-number">31415</span></span> .byte b_exit item lit32, f_code .byte b_lit32 .<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">31415926</span></span> .byte b_exit item lit64, f_code .byte b_lit64 .quad <span class="hljs-number"><span class="hljs-number">31415926535</span></span> .byte b_exit</code> </pre><br>  Das letzte Wort in der Liste bringt das Wort symbolisch zum Abschied.  Wir m√ºssen jedoch noch die Adresse dieses Wortes im Datenfeld weiter initialisieren.  Verwenden Sie den Befehl var0, um die Adresse dieses Wortes abzurufen: <br><br><pre> <code class="cpp hljs">last_item: .byte b_var0 item bye, f_code .byte b_bye</code> </pre><br>  Wenn wir in diesem Entwurf die Adresse last_item im Bytecode aufrufen, erhalten wir die Adresse des Wortes bye.  Um es in die Datenfelder des vierten Wortes zu schreiben, f√ºhren Sie es aus, und die gew√ºnschte Adresse befindet sich im Kontext.  Der Systeminitialisierungscode sieht also folgenderma√üen aus: <br><br><pre> <code class="cpp hljs">forth last_item context @ !</code> </pre><br>  Und jetzt gehen wir direkt zum Dolmetscher.  Zuerst m√ºssen wir mit dem Eingabepuffer arbeiten und W√∂rter daraus extrahieren.  Ich m√∂chte Sie daran erinnern, dass der Dolmetscher in der Festung sehr einfach ist.  Er extrahiert nacheinander W√∂rter aus dem Eingabepuffer und versucht, sie zu finden.  Wenn das Wort gefunden wird, startet der Interpreter es zur Ausf√ºhrung. <br><br><h4>  Eingabepuffer und Wortextraktion </h4><br>  Um ehrlich zu sein, m√∂chte ich nicht viel Zeit damit verbringen, die Standards der Festung zu studieren.  Trotzdem werde ich versuchen, es ihnen so nahe wie m√∂glich zu bringen, haupts√§chlich aus dem Ged√§chtnis.  Wenn Fort-Experten hier eine starke Diskrepanz feststellen - schreiben Sie, ich werde sie beheben. <br><br>  Das Fort verf√ºgt √ºber drei Variablen f√ºr die Arbeit mit dem Puffer: tib, #tib und&gt; in.  Die tib-Variable √ºbertr√§gt die Adresse des Eingabepuffers auf den Stapel.  Die Variable #tib schiebt die Anzahl der Zeichen, die sich im Puffer befinden, auf den Stapel.  Und die Variable&gt; in enth√§lt den Offset im Eingabepuffer, hinter dem sich der Rohtext befindet.  Definieren Sie diese Variablen. <br><br><pre> <code class="cpp hljs"> item tib .byte b_var0 v_tib: .quad <span class="hljs-number"><span class="hljs-number">0</span></span> item <span class="hljs-meta"><span class="hljs-meta">#tib .byte b_var0 v_ntib: .quad 0 item &gt;in .byte b_var0 v_in: .quad 0</span></span></code> </pre><br>  Als n√§chstes machen wir das Wort blword.  Dieses Wort erh√§lt unter Verwendung der angegebenen Variablen das n√§chste Wort aus dem Eingabestream.  Ein Leerzeichen wird als Trennzeichen und alle Zeichen mit einem Code verwendet, der kleiner als ein Leerzeichen ist.  Dieses Wort wird im Assembler sein.  Nach dem Debuggen stellte sich Folgendes heraus: <br><br><pre> <code class="cpp hljs">b_blword = <span class="hljs-number"><span class="hljs-number">0xF0</span></span> bcmd_blword: mov rsi, v_tib #    mov rdx, rsi #   RDX       mov rax, v_in #     mov rcx, v_ntib #    add rsi, rax #  RSI -      sub rcx, rax #     jz <span class="hljs-number"><span class="hljs-number">3f</span></span> word2: lodsb #   AL  RSI   cmp al, <span class="hljs-string"><span class="hljs-string">' '</span></span> ja <span class="hljs-number"><span class="hljs-number">1f</span></span> #    (    ) dec rcx jnz word2 #    <span class="hljs-number"><span class="hljs-number">3</span></span>: sub rsi, rdx mov v_in, rsi push rcx jmp _next <span class="hljs-number"><span class="hljs-number">1</span></span>: lea rdi, [rsi - <span class="hljs-number"><span class="hljs-number">1</span></span>] # RDI = RSI - <span class="hljs-number"><span class="hljs-number">1</span></span> ( ) dec rcx word3: lodsb cmp al, <span class="hljs-string"><span class="hljs-string">' '</span></span> jbe <span class="hljs-number"><span class="hljs-number">2f</span></span> dec rcx jnz word3 <span class="hljs-number"><span class="hljs-number">2</span></span>: mov rax, rsi sub rsi, rdx #        (   ) mov v_in, rsi sub rax, rdi dec rax jz word1 push rdi #   word1: push rax #   jmp _next</code> </pre><br>  Dieses Wort √§hnelt dem Standardwort, ber√ºcksichtigt jedoch im Gegensatz dazu alle Trennzeichen und kopiert das Wort nicht in den Puffer.  Es werden nur zwei Werte auf dem Stapel zur√ºckgegeben - Adresse und L√§nge.  Wenn das Wort nicht abgerufen werden kann, wird 0 zur√ºckgegeben. Es ist an der Zeit, mit dem Schreiben des Interpreters zu beginnen. <br><br><h4>  Wortsuche und Dolmetscher </h4><br>  Lassen Sie uns zun√§chst das Wort interpretieren.  Dieses Wort w√§hlt mit blworld ein neues Wort aus dem Puffer aus, sucht es im W√∂rterbuch und f√ºhrt es aus.  Und so wiederholt es sich, bis der Puffer ersch√∂pft ist.  Wir haben immer noch nicht die M√∂glichkeit, nach einem Wort zu suchen, daher schreiben wir einen Teststub, der das Wort einfach mit dem Typ aus dem Puffer druckt.  Dies gibt uns die M√∂glichkeit, blworld zu √ºberpr√ºfen und zu debuggen: <br><br><pre> <code class="cpp hljs"># : interpret begin blword dup <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> type repeat drop ; item interpret <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_blword .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . .byte b_type .byte b_branch8 .byte <span class="hljs-number"><span class="hljs-number">1b</span></span> - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_drop .byte b_exit</code> </pre><br>  Lassen Sie jetzt das Wort aufh√∂ren.  Normalerweise tun sie dies bei der Implementierung von Fort-Systemen: Sie verwenden das Wort Quit oder Abort, um in den Interpreter-Modus zu gelangen.  Das Wort quit sp√ºlt Stapel und startet eine Endlosschleife der Puffereingabe und -interpretation.  Bei uns ist es nur ein Aufruf zur Interpretation.  Der Code f√ºr dieses Wort besteht aus zwei Teilen.  Der erste Teil befindet sich im Assembler, der zweite Teil im Bytecode.  Der erste Teil: <br><br><pre> <code class="cpp hljs">b_quit = <span class="hljs-number"><span class="hljs-number">0xF1</span></span> bcmd_quit: lea r8, quit mov sp, init_stack mov bp, init_rstack jmp _next</code> </pre><br>  Der zweite Teil: <br><br><pre> <code class="cpp hljs">quit: .byte b_call16 .word interpret - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_bye</code> </pre><br>  Wie √ºblich befindet sich der Assembler-Code im Textabschnitt, der Bytecode im Datenabschnitt. <br><br>  Und schlie√ülich √§ndern Sie den Startbytecode.  Das W√∂rterbuch wird nur initialisiert, ein Puffer in der Startzeile gesetzt und quit beendet. <br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta"># forth last_item context @ ! start_code tib ! </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt;  &gt; #tib ! quit start: .byte b_call16 .word forth - . - 2 .byte b_call16 .word last_item - . - 2 .byte b_call16 .word context - . - 2 .byte b_get .byte b_set .byte b_call8 .byte start_code - . - 1 .byte b_call16 .word tib - . - 2 .byte b_set .byte b_lit16 .world 1f - 0f .byte b_call16 .word ntib - . - 2 .byte b_set .byte b_quit start_code: .byte b_var0 0: .ascii "word1 word2 word3" 1:</span></span></span></span></code> </pre><br>  Kompilieren, verkn√ºpfen, ausf√ºhren! <br><br><pre> <code class="plaintext hljs">$ as forth.s -o forth.o -g -ahlsm &gt;list.txt $ ld forth.o -o forth $ ./forth word1word2wordBye!</code> </pre><br>  Es ist ein bisschen wie Haferbrei, aber genau das sollte das Ergebnis sein.  Wir geben ohne Trennzeichen aus.  √úbrigens, setzen Sie den Zeilenvorschub vor dem Kauf f√ºr die Zukunft, dies wird nicht schaden. <br><br>  Nat√ºrlich musste ich am Debuggen basteln.  Zus√§tzlich zu dem bereits erw√§hnten ‚ÄûSegmentierungsfehler (Core Dumped)‚Äú wurden manchmal interessante Ergebnisse erzielt.  Zum Beispiel: <br><br><pre> <code class="plaintext hljs">$ ./forth word1word2word3forth)%60Acurrent(context(%600lit8lit16zlit32v%5E%DF%80lit64v%5E%DF%80call8call16call32branch8branch16qbranch8qbranch16exit1-+!-%22*#/$mod%25/mod&amp;abs'dup0drop1swap2rot3-rot4over5pick6roll7depth8@@!Ac@Bc!Cw@Dw!Ei@Fi!G0=P0%3CQ0%3ER=S%3CT%3EU%3C=V%3E=Wvar8)var160base(holdbuf(Qholdpoint(hold@0U110ACp@&amp;20T0!?!%3CgF!A0@RF!5%220'%DE%A61Q-%DD%80:tib(%7F%60(%3Ein(%20%20%20%20%20%20%20interpret01('byeSegmentation%20fault%20(core%20dumped)</code> </pre><br>  Dies scheint unser gesamtes bin√§res W√∂rterbuch mit in Trennzeichen geschnittenem Text zu sein :) Es geschah, als ich "dec rcx" vor word3 im Befehl b_blword verga√ü. <br><br>  Wir k√∂nnen W√∂rter aus dem Eingabestream ausw√§hlen, es gibt ein W√∂rterbuch.  Jetzt m√ºssen Sie eine W√∂rterbuchsuche implementieren und W√∂rter zur Ausf√ºhrung starten.  Dies erfordert die W√∂rter find, cfa und execute. <br><br>  Die Wortsuche nimmt die Adresse des Wortes und seine L√§nge vom Stapel.  Dieses Wort wird von der Adresse des W√∂rterbucheintrags oder von 0 zur√ºckgegeben, wenn es nicht gefunden wird. <br><br>  Das Wort cfa an der Artikeladresse berechnet die Adresse des ausf√ºhrbaren Bytecodes. <br><br>  Und das Wort execute f√ºhrt den Bytecode aus. <br><br>  Beginnen wir mit find.  In Fort-Standards wird eine Adresse ben√∂tigt - eine Zeile mit einem Z√§hler.  Aber ich m√∂chte den String nicht noch einmal in den Puffer kopieren, deshalb werde ich ein wenig von den Standards abweichen.  Die Wortsuche nimmt zwei Parameter auf dem Stapel an - die Adresse und die L√§nge der Zeichenfolge (die tats√§chlich das Wort blword zur√ºckgibt).  Nach dem Debuggen nahm dieses Wort die folgende Form an: <br><br><pre> <code class="cpp hljs">b_find = <span class="hljs-number"><span class="hljs-number">0xF2</span></span> bcmd_find: pop rbx #   pop r9 #   mov rdx, v_context mov rdx, [rdx] #        #   find0: mov al, [rdx] #  <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> al, <span class="hljs-number"><span class="hljs-number">3</span></span> #   -     ,     ,    <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> al, al jz find_l8 cmp al, <span class="hljs-number"><span class="hljs-number">1</span></span> jz find_l16 cmp al, <span class="hljs-number"><span class="hljs-number">2</span></span> jz find_l32 mov r10, [rdx + <span class="hljs-number"><span class="hljs-number">1</span></span>] #  <span class="hljs-number"><span class="hljs-number">64</span></span>  lea rsi, [rdx + <span class="hljs-number"><span class="hljs-number">9</span></span>] #   jmp find1 find_l32: movsx r10, dword ptr [rdx + <span class="hljs-number"><span class="hljs-number">1</span></span>] #  <span class="hljs-number"><span class="hljs-number">32</span></span>  lea rsi, [rdx + <span class="hljs-number"><span class="hljs-number">5</span></span>] #   jmp find1 find_l16: movsx r10, word ptr [rdx + <span class="hljs-number"><span class="hljs-number">1</span></span>] #  <span class="hljs-number"><span class="hljs-number">16</span></span>  lea rsi, [rdx + <span class="hljs-number"><span class="hljs-number">3</span></span>] #   jmp find1 find_l8: movsx r10, byte ptr [rdx + <span class="hljs-number"><span class="hljs-number">1</span></span>] #  <span class="hljs-number"><span class="hljs-number">8</span></span>  lea rsi, [rdx + <span class="hljs-number"><span class="hljs-number">2</span></span>] #   find1: movzx rax, byte ptr [rsi] #       cmp rax, rbx jz find2 #      find3: <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> r10, r10 jz find_notfound #  ,    add rdx, r10 #     jmp find0 #  ,   find2: inc rsi mov rdi, r9 mov rcx, rax repz cmpsb jnz find3 #   push rdx jmp _next find_notfound: push r10 jmp _next</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vielleicht ist dies das schwierigste Wort f√ºr heute. </font><font style="vertical-align: inherit;">Jetzt √§ndern wir das Wort interpret und ersetzen den Typ durch "find":</font></font><br><br><pre> <code class="cpp hljs"># : interpret begin blword dup <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> find . repeat drop ; item interpret interpret: .byte b_blword .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . .byte b_find .byte b_call16 .word dot - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_branch8 .byte interpret - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_drop .byte b_exit</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">In die Testzeile m√ºssen Sie die W√∂rter einf√ºgen, die sich im W√∂rterbuch befinden, z. B. "0 1 - dup +.". </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alles ist startbereit!</font></font><br><br><pre> <code class="plaintext hljs">$ ld forth.o -o forth $ ./forth 6297733 6297898 6298375 Bye!</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gro√üartig, die Suche funktioniert. </font><font style="vertical-align: inherit;">Dies sind die Adressen von W√∂rtern (dezimal). </font><font style="vertical-align: inherit;">Nun das Wort cfa. </font><font style="vertical-align: inherit;">Lassen Sie es auch in Assembler sein, es ist sehr einfach, das Arbeiten mit Flags ist √§hnlich zu finden:</font></font><br><br><pre> <code class="cpp hljs">b_cfa = <span class="hljs-number"><span class="hljs-number">0xF3</span></span> bcmd_cfa: pop rdx #    mov al, [rdx] #  <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> al, <span class="hljs-number"><span class="hljs-number">3</span></span> #   -     ,     ,    <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> al, al jz cfa_l8 cmp al, <span class="hljs-number"><span class="hljs-number">1</span></span> jz cfa_l16 cmp al, <span class="hljs-number"><span class="hljs-number">2</span></span> jz cfa_l32 lea rsi, [rdx + <span class="hljs-number"><span class="hljs-number">9</span></span>] #   (<span class="hljs-number"><span class="hljs-number">64</span></span>  ) jmp cfa1 find_l32: lea rsi, [rdx + <span class="hljs-number"><span class="hljs-number">5</span></span>] #   (<span class="hljs-number"><span class="hljs-number">32</span></span>  ) jmp cfa1 find_l16: lea rsi, [rdx + <span class="hljs-number"><span class="hljs-number">3</span></span>] #   (<span class="hljs-number"><span class="hljs-number">16</span></span>  ) jmp cfa1 find_l8: lea rsi, [rdx + <span class="hljs-number"><span class="hljs-number">2</span></span>] #   (<span class="hljs-number"><span class="hljs-number">8</span></span>  ) xor rax, rax lodsb add rsi, rax push rsi jmp _next</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und schlie√ülich ist das Wort ausf√ºhren noch einfacher: </font></font><br><br><pre> <code class="cpp hljs">b_execute = <span class="hljs-number"><span class="hljs-number">0xF4</span></span> bcmd_execute: sub rbp, <span class="hljs-number"><span class="hljs-number">8</span></span> mov [rbp], r8 #       pop r8 #  - jmp _next</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Korrigieren Sie das Wort interpretieren und ausf√ºhren! </font></font><br><br><pre> <code class="cpp hljs"># : interpret begin blword dup <span class="hljs-keyword"><span class="hljs-keyword">while</span></span> find cfa execute repeat drop ; item interpret interpret: .byte b_blword .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . .byte b_find .byte b_cfa .byte b_execute .byte b_branch8 .byte interpret - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_drop .byte b_exit</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Start: </font></font><br><br><pre> <code class="plaintext hljs">$ as forth.s -o forth.o -g -ahlsm &gt;list.txt $ ld forth.o -o forth $ ./forth -2 Bye!</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Urrra, verdient! </font></font><s><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">(C) Cat Matroskin</font></font></s> <br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wenn Sie 1 von 0 subtrahieren und das Ergebnis zu sich selbst addieren, ist es -2 :) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das ist gro√üartig, aber ich m√∂chte die Befehle trotzdem √ºber die Tastatur eingeben. Und es gibt noch ein weiteres Problem: Unser Interpreter versteht nur die Zahlen 0, 1, 2, 3, 4 und 8 (die als Konstanten definiert sind). Was w√ºrde er lernen, irgendwelche Zahlen zu verstehen, brauchen Sie das Wort "Zahl"? Auf die gleiche Weise wie f√ºr das Wort find werde ich den Puffer nicht verwenden. Das Wort "Nummer?" nimmt zwei Parameter auf dem Stapel - die Adresse des Strings und die L√§nge. Bei Erfolg werden die empfangene Nummer und das Flag 1 zur√ºckgegeben. Wenn die Konvertierung nicht erfolgreich ist, befindet sich eine Nummer auf dem Stapel: 0. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Code erwies sich als lang, aber ziemlich einfach und linear:</font></font><br><br><pre> <code class="cpp hljs">b_number = <span class="hljs-number"><span class="hljs-number">0xF5</span></span> bcmd_number: pop rcx #   pop rsi #  xor rax, rax #   xor rbx, rbx #     mov r9, v_base #  xor r10, r10 #   <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rcx, rcx jz num_false mov bl, [rsi] cmp bl, <span class="hljs-string"><span class="hljs-string">'+'</span></span> jnz <span class="hljs-number"><span class="hljs-number">1f</span></span> inc rsi dec rcx jz num_false jmp num0 <span class="hljs-number"><span class="hljs-number">1</span></span>: cmp bl, <span class="hljs-string"><span class="hljs-string">'-'</span></span> jnz num0 mov r10, <span class="hljs-number"><span class="hljs-number">1</span></span> inc rsi dec rcx jz num_false num0: mov bl, [rsi] cmp bl, <span class="hljs-string"><span class="hljs-string">'0'</span></span> ja num_false cmp bl, <span class="hljs-string"><span class="hljs-string">'9'</span></span> jae num_09 cmp bl, <span class="hljs-string"><span class="hljs-string">'A'</span></span> ja num_false cmp bl, <span class="hljs-string"><span class="hljs-string">'Z'</span></span> jae num_AZ cmp bl, <span class="hljs-string"><span class="hljs-string">'a'</span></span> ja num_false sub bl, <span class="hljs-string"><span class="hljs-string">'a'</span></span> - <span class="hljs-number"><span class="hljs-number">10</span></span> jmp num_check num_AZ: sub bl, <span class="hljs-string"><span class="hljs-string">'A'</span></span> - <span class="hljs-number"><span class="hljs-number">10</span></span> jmp num_check num_09: sub bl, <span class="hljs-string"><span class="hljs-string">'0'</span></span> num_check: cmp rbx, r9 jge num_false add rax, rbx mul r9 inc rsi dec rcx jnz num0 <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> r10, r10 push rax push <span class="hljs-number"><span class="hljs-number">1</span></span> jmp _next num_false: xor rcx, rcx push rcx jmp _next</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Interpretieren √§ndern. </font><font style="vertical-align: inherit;">Wenn das Wort nicht im W√∂rterbuch enthalten ist, werden wir versuchen, es als Zahl zu interpretieren:</font></font><br><br><pre> <code class="cpp hljs"># : interpret <span class="hljs-meta"><span class="hljs-meta"># begin # blword dup # while # over over find dup # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> -rot drop drop cfa execute </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">else</span></span></span><span class="hljs-meta"> number? drop then # repeat # drop ; item interpret interpret: .byte b_blword .byte b_dup .byte b_qnbranch8 .byte 0f - . .byte b_over .byte b_over .byte b_find .byte b_dup .byte b_qnbranch8 .byte 1f - . .byte b_mrot .byte b_drop .byte b_drop .byte b_cfa .byte b_execute .byte b_branch8 .byte 2f - . 1: .byte b_numberq .byte b_drop 2: .byte b_branch8 .byte interpret - . 0: .byte b_drop .byte b_exit last_item: .byte b_var0 item bye, f_code .byte b_bye</span></span></code> </pre><br> <b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und hier habe ich! </font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Debuggen Sie einen solchen Bytecode im Assembler, ohne Haltepunkte im Bytecode, ohne die M√∂glichkeit, einfach entlang des Bytecodes zu "schreiten" ... Au√üerdem mit nicht den einfachsten Bewegungen auf dem Stapel und ohne die einfache M√∂glichkeit, den Inhalt des Stapels anzuzeigen ... und auf GDB, wo Nur die Kommandozeile ... Ich sage es dir - es ist nur eine Gehirnexplosion! </font><font style="vertical-align: inherit;">Nicht schlimmer. </font><font style="vertical-align: inherit;">Dies ist eine </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Gehirnexplosion</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> ! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Aber ... wir sind Inder, wir werden immer Problemumgehungen finden :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Allgemeinen habe ich diese L√∂sung gefunden: Ich habe einen Befehl implementiert, um den Inhalt des Stapels anzuzeigen - "s". </font><font style="vertical-align: inherit;">Der Befehl ist nicht der einfachste, aber dennoch einfacher zu interpretieren. </font><font style="vertical-align: inherit;">Und wie sich herausstellte , </font></font><b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">ochchchen</font></font></b><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> n√ºtzlich.</font></font> Da ist sie: <br><br><pre> <code class="cpp hljs"># : .s depth dup . c<span class="hljs-string"><span class="hljs-string">": emit do dup while dup pick . 1- again drop ; item .s # 11 22 33 prstack: .byte b_depth # 11 22 33 3 .byte b_dup # 11 22 33 3 3 .byte b_lit8 .byte '(' .byte b_emit .byte b_call16 # 11 22 33 3 .word dot - . - 2 .byte b_strp # 11 22 33 3 .byte 3 .ascii "</span></span>): <span class="hljs-string"><span class="hljs-string">" 1: .byte b_dup # 11 22 33 3 3 .byte b_qnbranch8 # 11 22 33 3 .byte 2f - . .byte b_dup # 11 22 33 3 3 .byte b_pick # 11 22 33 3 11 .byte b_call16 # 11 22 33 3 .word dot - . - 2 .byte b_wm # 11 22 33 2 .byte b_branch8 .byte 1b - . 2: .byte b_drop # 11 22 33 .byte b_exit</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Rechts habe ich nach der Ausf√ºhrung jedes Befehls ein Beispiel f√ºr den Inhalt des Stapels gegeben. </font><font style="vertical-align: inherit;">Nat√ºrlich gibt es einen Zyklus, und dies ist nur der erste Durchgang. </font><font style="vertical-align: inherit;">Der Rest ist jedoch sehr √§hnlich, nur der Wert oben im Stapel √§ndert sich. </font><font style="vertical-align: inherit;">Nach einer solchen "Spur" hat das Team sofort verdient! </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Zum Debuggen habe ich folgende Makros erstellt:</font></font><br><br><pre> <code class="cpp hljs">.macro prs new_line = <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_call16 .word prstack - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> \new_line &gt; <span class="hljs-number"><span class="hljs-number">0</span></span> .byte b_lit8, <span class="hljs-string"><span class="hljs-string">'\n'</span></span> .byte b_emit .endif .endm</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Wird durch Einf√ºgen an den richtigen Stellen auf folgende Weise verwendet: </font></font><br><br><pre> <code class="cpp hljs"> item interpret interpret: .byte b_blword prs .byte b_dup prs .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . .byte b_over .byte b_over ......</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Infolgedessen ergab der erste Start die folgende Ausgabe: </font></font><br><br><pre> <code class="plaintext hljs">$ ./forth (2 ): 6297664 1 (3 ): 6297664 1 1 (3 ): 2 6297666 1 (4 ): 2 6297666 1 1 (4 ): 2 3 6297668 1 (5 ): 2 3 6297668 1 1 (3 ): 6 6297670 2 (4 ): 6 6297670 2 2 (4 ): 6 6297670 6297673 1 (5 ): 6 6297670 6297673 1 1 6297670 (2 ): 6 0 (3 ): 6 0 0 Bye!</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jede Bewegung auf dem Stapel ist deutlich zu sehen. </font><font style="vertical-align: inherit;">Es war notwendig, dies fr√ºher zu tun :) </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Ich ging weiter, indem ich ein weiteres Debug-Makro erstellte:</font></font><br><br><pre> <code class="cpp hljs">.macro pr <span class="hljs-built_in"><span class="hljs-built_in">string</span></span> .byte b_strp .byte <span class="hljs-number"><span class="hljs-number">9f</span></span> - <span class="hljs-number"><span class="hljs-number">8f</span></span> <span class="hljs-number"><span class="hljs-number">8</span></span>: .ascii <span class="hljs-string"><span class="hljs-string">"\n\string"</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>: .endm</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Infolgedessen wurde es m√∂glich, dies zu tun: </font></font><br><br><pre> <code class="cpp hljs"> item interpret interpret: .byte b_blword pr blworld prs .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . .byte b_over .byte b_over prs .byte b_find pr find prs .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_mrot .byte b_drop .byte b_drop .byte b_cfa pr execute prs .byte b_execute .byte b_branch8 .byte <span class="hljs-number"><span class="hljs-number">2f</span></span> - . <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_numberq pr numberq prs .byte b_drop <span class="hljs-number"><span class="hljs-number">2</span></span>: .byte b_branch8 .byte interpret - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_drop .byte b_exit</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und hol dir das: </font></font><br><br><pre> <code class="plaintext hljs">$ ./forth blworld(2 ): 6297664 2 (4 ): 6297664 2 6297664 2 find(3 ): 6297664 2 0 numberq(2 ): 6297664 0 blworld(3 ): 6297664 6297667 2 (5 ): 6297664 6297667 2 6297667 2 find(4 ): 6297664 6297667 2 0 numberq(3 ): 6297664 6297667 0 blworld(4 ): 6297664 6297667 6297670 1 (6 ): 6297664 6297667 6297670 1 6297670 1 find(5 ): 6297664 6297667 6297670 1 6297958 execute(3 ): 6297664 6297667 6297962 blworld(3 ): 39660590749888 6297672 1 (5 ): 39660590749888 6297672 1 6297672 1 find(4 ): 39660590749888 6297672 1 6298496 execute(2 ): 39660590749888 6298500 39660590749888 blworld(1 ): 0 Bye!</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es war ein Versuch, die Zeichenfolge "20 30 *" zu interpretieren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und Sie k√∂nnen die Quellzeilennummern anzeigen ... okay, vielleicht dann ... </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Nat√ºrlich ist dies eine klassische Protokollierungstechnik zum Debuggen, aber etwas, an das ich mich nicht sofort erinnerte. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Im Allgemeinen habe ich beim Debuggen einen Stapel gefunden, der ins Ausland geht. Dies ist das Gegenteil von √úberlauf, wenn sie versuchen, mehr zu nehmen, als sie setzen. F√ºgte ihre Kontrolle zu ".s" hinzu. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Mit Hilfe neuer Makros war das Debuggen schnell. Vorher habe ich √ºbrigens einen Bytecode pro Zeile gepostet. Mit Assembler k√∂nnen Sie jedoch mehrere Bytes in eine Zeichenfolge einf√ºgen. Warum nicht? </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Lassen Sie uns die Wortinterpretation mit zwei √úberpr√ºfungen abschlie√üen: dass das Wort nicht in eine Zahl konvertiert wurde, und um den Stapel im Ausland zu verlassen. Infolgedessen ist die Interpretation wie folgt:</font></font><br><br><pre> <code class="cpp hljs"> item interpret interpret: .byte b_blword .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . .byte b_over .byte b_over .byte b_find .byte b_dup .byte b_qnbranch8 .byte <span class="hljs-number"><span class="hljs-number">1f</span></span> - . .byte b_mrot .byte b_drop .byte b_drop .byte b_cfa .byte b_execute .byte b_branch8 .byte <span class="hljs-number"><span class="hljs-number">2f</span></span> - . <span class="hljs-number"><span class="hljs-number">1</span></span>: .byte b_drop .byte b_over, b_over .byte b_numberq # ,    .byte b_qbranch8, <span class="hljs-number"><span class="hljs-number">3f</span></span> - . #     <span class="hljs-number"><span class="hljs-number">0</span></span>, ,      <span class="hljs-number"><span class="hljs-number">3</span></span> .byte b_type #    .byte b_strp #   .byte <span class="hljs-number"><span class="hljs-number">19</span></span> #     .ascii <span class="hljs-string"><span class="hljs-string">" : word not found!\n"</span></span> .byte b_quit #    <span class="hljs-number"><span class="hljs-number">3</span></span>: .byte b_nip, b_nip #  ,     ( b_over, b_over) <span class="hljs-number"><span class="hljs-number">2</span></span>: #       .byte b_depth #    .byte b_zlt # ,   <span class="hljs-number"><span class="hljs-number">0</span></span> ( <span class="hljs-number"><span class="hljs-number">0</span></span>&lt;) .byte b_qnbranch8, interpret_ok - . #   ,    ,   .byte b_strp #    .byte <span class="hljs-number"><span class="hljs-number">14</span></span> .ascii <span class="hljs-string"><span class="hljs-string">"\nstack fault!\n"</span></span> .byte b_quit #    interpret_ok: .byte b_branch8 .byte interpret - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_drop .byte b_exit</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">√úbrigens ist es erw√§hnenswert, dass der Befehl quit jetzt Stapel l√∂scht und die Interpretation erneut startet, ohne den Status des Puffers zu √§ndern. </font><font style="vertical-align: inherit;">Somit geht die Interpretation weiter, jedoch mit ‚Äûfrischen‚Äú Stapeln. </font><font style="vertical-align: inherit;">Wir werden das etwas sp√§ter beheben. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Sie m√ºssen nur noch die Tastatureingabe organisieren.</font></font><br><br><h4><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Tastatureingabe </font></font></h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Die Tastatureingabe im Fort ist einfach. </font><font style="vertical-align: inherit;">Es gibt das Wort erwarten, es braucht zwei Parameter - die Adresse des Puffers und seine Gr√∂√üe. </font><font style="vertical-align: inherit;">Dieses Wort f√ºhrt die Tastatureingabe durch. </font><font style="vertical-align: inherit;">Die tats√§chlich eingegebene Anzahl von Zeichen wird in die Bereichsvariable eingef√ºgt. </font><font style="vertical-align: inherit;">Lassen Sie uns diese Worte machen. </font><font style="vertical-align: inherit;">Wir werden von der Standardeingabe eingeben.</font></font><br><br><pre> <code class="cpp hljs">.data item span span: .byte b_var0 v_span: .quad <span class="hljs-number"><span class="hljs-number">0</span></span> .text b_expect = <span class="hljs-number"><span class="hljs-number">0x88</span></span> bcmd_expect: mov rax, <span class="hljs-number"><span class="hljs-number">0</span></span> #   ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> - sys_read mov rdi, <span class="hljs-number"><span class="hljs-number">0</span></span> #  ‚Ññ <span class="hljs-number"><span class="hljs-number">1</span></span> - <span class="hljs-built_in"><span class="hljs-built_in">stdout</span></span> pop rdx #   pop rsi #   push r8 syscall #   pop r8 mov rbx, rax <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> rax, rax jge <span class="hljs-number"><span class="hljs-number">1f</span></span> xor rbx, rbx <span class="hljs-number"><span class="hljs-number">1</span></span>: mov v_span, rbx jmp _next</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt m√ºssen wir einen Tastatureingabepuffer erstellen. </font><font style="vertical-align: inherit;">Lassen Sie es 256 Zeichen lang sein. </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Machen wir es anstelle der vorherigen Testlinie.</font></font><br><br><pre> <code class="cpp hljs">inbuf_size = <span class="hljs-number"><span class="hljs-number">256</span></span> inbuf: .byte b_var0 .space inbuf_size</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und wir √§ndern das Beenden sowie den Startbytecode. </font><font style="vertical-align: inherit;">Setzen Sie die tib-Variable auf den Inbuf-Eingabepuffer, rufen Sie Expect auf und kopieren Sie den Wert von span nach #tib. </font><font style="vertical-align: inherit;">Die Variable&gt; in wird annulliert, wir nennen interpret. </font><font style="vertical-align: inherit;">Und so wiederholen wir in einem Zyklus. </font><font style="vertical-align: inherit;">Es gibt Kugeln - um eine Eingabeaufforderung hinzuzuf√ºgen, und es w√§re sch√∂n, den Status des Stapels anzuzeigen (und wir haben bereits einen vorgefertigten Befehl daf√ºr!). </font><font style="vertical-align: inherit;">Nach mehreren Iterationen haben wir den folgenden Code erhalten (Befehl start and quit):</font></font><br><br><pre> <code class="cpp hljs"><span class="hljs-meta"><span class="hljs-meta"># forth last_item context @ ! quit start: .byte b_call16 .word forth - . - 2 .byte b_call16 .word last_item - . - 2 .byte b_call16 .word context - . - 2 .byte b_get .byte b_set .byte b_quit inbuf: .byte b_var0 .space inbuf_size # begin inbuf dup tib ! inbuf_size expect span @ #tib ! 0 &gt;in ! interpret again quit: .byte b_strp, 1 .ascii </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"\n"</span></span></span><span class="hljs-meta"> .byte b_call16 .word prstack - . - 2 .byte b_strp .byte 2 .ascii </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">"&gt; "</span></span></span><span class="hljs-meta"> .byte b_call16 .word inbuf - . - 2 .byte b_dup .byte b_call16 .word tib - . - 2 .byte b_set .byte b_lit16 .word inbuf_size .byte b_expect .byte b_call16 .word span - . - 2 .byte b_get .byte b_call16 .word ntib - . - 2 .byte b_set .byte b_num0 .byte b_call16 .word bin - . - 2 .byte b_set .byte b_call16 .word interpret - . - 2 .byte b_branch8, quit - .</span></span></code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> Und hier ist das Ergebnis: </font></font><br><br><pre> <code class="plaintext hljs">$ ./forth ( 0 ): &gt; 60 ( 1 ): 60 &gt; 60 24 ( 3 ): 60 60 24 &gt; rot ( 3 ): 60 24 60 &gt; -rot ( 3 ): 60 60 24 &gt; swap ( 3 ): 60 24 60 &gt; * * . 86400 ( 0 ): &gt; 200 30 /mod ( 2 ): 20 6 &gt; bye Bye! $</code> </pre><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Alles nach dem Symbol "&gt;" ist meine Tastatureingabe. </font><font style="vertical-align: inherit;">Der Rest ist die Antwort des Systems. </font><font style="vertical-align: inherit;">Ich spielte ein wenig mit Befehlen und tippte √ºber die Tastatur. </font><font style="vertical-align: inherit;">Er f√ºhrte mehrere Stapeloperationen durch und berechnete die Anzahl der Sekunden in Tagen.</font></font><br><br><h4>  Zusammenfassung </h4><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Dolmetscher ist vollst√§ndig und arbeitet. </font><font style="vertical-align: inherit;">Und verabschiedet sich h√∂flich - von ihm "Tsch√ºss" und er "Tsch√ºss" :) </font></font><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Als Einladung - der Inhalt des Rechenstapels. </font><font style="vertical-align: inherit;">Die erste Zahl in Klammern ist die Gr√∂√üe des Stapels, dann der Inhalt und die Eingabeaufforderung zur Eingabe von "&gt;". </font><font style="vertical-align: inherit;">Sie k√∂nnen beliebige implementierte Befehle eingeben (ich habe 76 Befehle gez√§hlt). </font><font style="vertical-align: inherit;">Richtig, viele sind nur f√ºr den Compiler sinnvoll - zum Beispiel Literale, √úberg√§nge, Aufrufbefehle.</font></font><br><br><div class="spoiler"> <b class="spoiler_title"><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Vollst√§ndige Quelle (ca. 1300 Zeilen)</font></font></b> <div class="spoiler_text"><pre> <code class="cpp hljs">.intel_syntax noprefix stack_size = <span class="hljs-number"><span class="hljs-number">1024</span></span> f_code = <span class="hljs-number"><span class="hljs-number">0x80</span></span> f_immediate = <span class="hljs-number"><span class="hljs-number">0x60</span></span> .macro item name, flags = <span class="hljs-number"><span class="hljs-number">0</span></span> link = p_item - . <span class="hljs-number"><span class="hljs-number">9</span></span>: .<span class="hljs-keyword"><span class="hljs-keyword">if</span></span> link &gt;= <span class="hljs-number"><span class="hljs-number">-256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; link &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> .byte \flags .byte link .elseif link &gt;= <span class="hljs-number"><span class="hljs-number">-256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; link &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> .byte \flags | <span class="hljs-number"><span class="hljs-number">1</span></span> .word link .elseif link &gt;= <span class="hljs-number"><span class="hljs-number">-256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; link &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> .byte \flags | <span class="hljs-number"><span class="hljs-number">2</span></span> .<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> link .elseif link &gt;= <span class="hljs-number"><span class="hljs-number">-256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> &amp;&amp; link &lt; <span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>*<span class="hljs-number"><span class="hljs-number">256</span></span>/<span class="hljs-number"><span class="hljs-number">2</span></span> .byte \flags | <span class="hljs-number"><span class="hljs-number">3</span></span> .quad link .endif p_item = <span class="hljs-number"><span class="hljs-number">9b</span></span> .byte <span class="hljs-number"><span class="hljs-number">9f</span></span> - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .ascii <span class="hljs-string"><span class="hljs-string">"\name"</span></span> <span class="hljs-number"><span class="hljs-number">9</span></span>: .endm .section .data init_stack: .quad <span class="hljs-number"><span class="hljs-number">0</span></span> init_rstack: .quad <span class="hljs-number"><span class="hljs-number">0</span></span> emit_buf: .byte <span class="hljs-number"><span class="hljs-number">0</span></span> inbuf_size = <span class="hljs-number"><span class="hljs-number">256</span></span> msg_bad_byte: .ascii <span class="hljs-string"><span class="hljs-string">"Bad byte code!\n"</span></span> msg_bad_byte_len = . - msg_bad_byte #  len    msg_bye: .ascii <span class="hljs-string"><span class="hljs-string">"\nBye!\n"</span></span> msg_bye_len = . - msg_bye bcmd: .quad bcmd_bad, bcmd_bye, bcmd_num0, bcmd_num1, bcmd_num2, bcmd_num3, bcmd_num4, bcmd_num8 # <span class="hljs-number"><span class="hljs-number">0x00</span></span> .quad bcmd_lit8, bcmd_lit16, bcmd_lit32, bcmd_lit64, bcmd_call8, bcmd_call16, bcmd_call32, bcmd_bad .quad bcmd_branch8, bcmd_branch16, bcmd_qbranch8, bcmd_qbranch16, bcmd_qnbranch8, bcmd_qnbranch16,bcmd_bad, bcmd_exit # <span class="hljs-number"><span class="hljs-number">0x10</span></span> .quad bcmd_wp, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_wm, bcmd_add, bcmd_sub, bcmd_mul, bcmd_div, bcmd_mod, bcmd_divmod, bcmd_abs # <span class="hljs-number"><span class="hljs-number">0x20</span></span> .quad bcmd_var0, bcmd_var8, bcmd_var16, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_dup, bcmd_drop, bcmd_swap, bcmd_rot, bcmd_mrot, bcmd_over, bcmd_pick, bcmd_roll # <span class="hljs-number"><span class="hljs-number">0x30</span></span> .quad bcmd_depth, bcmd_nip, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_get, bcmd_set, bcmd_get8, bcmd_set8, bcmd_get16, bcmd_set16, bcmd_get32, bcmd_set32 # <span class="hljs-number"><span class="hljs-number">0x40</span></span> .quad bcmd_setp, bcmd_setm, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_zeq, bcmd_zlt, bcmd_zgt, bcmd_eq, bcmd_lt, bcmd_gt, bcmd_lteq, bcmd_gteq # <span class="hljs-number"><span class="hljs-number">0x50</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_2r, bcmd_r2, bcmd_rget, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x60</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_type, bcmd_emit, bcmd_str, bcmd_strp, bcmd_count, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x80</span></span> .quad bcmd_expect, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0x90</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad .quad bcmd_blword, bcmd_quit, bcmd_find, bcmd_cfa, bcmd_execute, bcmd_numberq, bcmd_bad, bcmd_bad # <span class="hljs-number"><span class="hljs-number">0xF0</span></span> .quad bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad, bcmd_bad # forth last_item context @ ! quit start: .byte b_call16 .word forth - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word last_item - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_call16 .word context - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_get .byte b_set .byte b_quit inbuf: .byte b_var0 .space inbuf_size # begin inbuf dup tib ! inbuf_size expect span @ #tib ! <span class="hljs-number"><span class="hljs-number">0</span></span> &gt;in ! interpret again quit: .byte b_strp, <span class="hljs-number"><span class="hljs-number">1</span></span> .ascii <span class="hljs-string"><span class="hljs-string">"\n"</span></span> .byte b_call16 .word prstack - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_strp .byte <span class="hljs-number"><span class="hljs-number">2</span></span> .ascii <span class="hljs-string"><span class="hljs-string">"&gt; "</span></span> .byte b_call16 .word inbuf - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_dup .byte b_call16 .word tib - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_set .byte b_lit16 .word inbuf_size .byte b_expect .byte b_call16 .word span - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_get .byte b_call16 .word ntib - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_set .byte b_num0 .byte b_call16 .word bin - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_set .byte b_call16 .word interpret - . - <span class="hljs-number"><span class="hljs-number">2</span></span> .byte b_branch8, quit - . p_item = . item forth forth: .byte b_var8 .byte does_voc - . .quad <span class="hljs-number"><span class="hljs-number">0</span></span> does_voc: .byte b_call8 .byte context - . - <span class="hljs-number"><span class="hljs-number">1</span></span> .byte b_set .byte b_exit item current .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">0</span></span> item context context: .byte b_var0 v_context: .quad <span class="hljs-number"><span class="hljs-number">0</span></span> item <span class="hljs-number"><span class="hljs-number">0</span></span>, f_code .byte b_num0 .byte b_exit item <span class="hljs-number"><span class="hljs-number">1</span></span>, f_code .byte b_num1 .byte b_exit item <span class="hljs-number"><span class="hljs-number">2</span></span>, f_code .byte b_num2 .byte b_exit item <span class="hljs-number"><span class="hljs-number">3</span></span>, f_code .byte b_num3 .byte b_exit item <span class="hljs-number"><span class="hljs-number">4</span></span>, f_code .byte b_num4 .byte b_exit item <span class="hljs-number"><span class="hljs-number">8</span></span>, f_code .byte b_num8 .byte b_exit item lit8, f_code .byte b_lit8 .byte <span class="hljs-number"><span class="hljs-number">31</span></span> .byte b_exit item lit16, f_code .byte b_lit16 .word <span class="hljs-number"><span class="hljs-number">31415</span></span> .byte b_exit item lit32, f_code .byte b_lit32 .<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">31415926</span></span> .byte b_exit item lit64, f_code .byte b_lit64 .quad <span class="hljs-number"><span class="hljs-number">31415926</span></span> .byte b_exit item call8, f_code .byte b_call8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item call16, f_code .byte b_call16 .word <span class="hljs-number"><span class="hljs-number">0f</span></span> - . - <span class="hljs-number"><span class="hljs-number">2</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item call32, f_code .byte b_call32 .<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> <span class="hljs-number"><span class="hljs-number">0f</span></span> - . - <span class="hljs-number"><span class="hljs-number">4</span></span> <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item branch8, f_code .byte b_branch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item branch16, f_code .byte b_branch16 .word <span class="hljs-number"><span class="hljs-number">0f</span></span> - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item qbranch8, f_code .byte b_qbranch8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item qbranch16, f_code .byte b_qbranch16 .word <span class="hljs-number"><span class="hljs-number">0f</span></span> - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item <span class="hljs-built_in"><span class="hljs-built_in">exit</span></span>, f_code .byte b_exit item <span class="hljs-number"><span class="hljs-number">1</span></span>-, f_code .byte b_wm .byte b_exit item <span class="hljs-number"><span class="hljs-number">1</span></span>+, f_code .byte b_wp .byte b_exit item +, f_code .byte b_add .byte b_exit item -, f_code .byte b_sub .byte b_exit item *, f_code .byte b_mul .byte b_exit item /, f_code .byte b_div .byte b_exit item mod, f_code .byte b_mod .byte b_exit item /mod, f_code .byte b_divmod .byte b_exit item <span class="hljs-built_in"><span class="hljs-built_in">abs</span></span>, f_code .byte b_abs .byte b_exit item dup, f_code .byte b_dup .byte b_exit item drop, f_code .byte b_drop .byte b_exit item swap, f_code .byte b_swap .byte b_exit item rot, f_code .byte b_rot .byte b_exit item -rot, f_code .byte b_mrot .byte b_exit item over, f_code .byte b_over .byte b_exit item pick, f_code .byte b_pick .byte b_exit item roll, f_code .byte b_roll .byte b_exit item depth, f_code .byte b_depth .byte b_exit item @, f_code .byte b_get .byte b_exit item !, f_code .byte b_set .byte b_exit item c@, f_code .byte b_get8 .byte b_exit item c!, f_code .byte b_set8 .byte b_exit item w@, f_code .byte b_get16 .byte b_exit item w!, f_code .byte b_set16 .byte b_exit item i@, f_code .byte b_get32 .byte b_exit item i!, f_code .byte b_set32 .byte b_exit item +!, f_code .byte b_setp .byte b_exit item -!, f_code .byte b_setm .byte b_exit item &gt;r, f_code .byte b_2r .byte b_exit item r&gt;, f_code .byte b_r2 .byte b_exit item r@, f_code .byte b_rget .byte b_exit item <span class="hljs-string"><span class="hljs-string">"0="</span></span>, f_code .byte b_zeq .byte b_exit item <span class="hljs-number"><span class="hljs-number">0</span></span>&lt;, f_code .byte b_zlt .byte b_exit item <span class="hljs-number"><span class="hljs-number">0</span></span>&gt;, f_code .byte b_zgt .byte b_exit item <span class="hljs-string"><span class="hljs-string">"="</span></span>, f_code .byte b_eq .byte b_exit item &lt;, f_code .byte b_lt .byte b_exit item &gt;, f_code .byte b_gt .byte b_exit item <span class="hljs-string"><span class="hljs-string">"&lt;="</span></span>, f_code .byte b_lteq .byte b_exit item <span class="hljs-string"><span class="hljs-string">"&gt;="</span></span>, f_code .byte b_gteq .byte b_exit item type, f_code .byte b_type .byte b_exit item expect, f_code .byte b_expect .byte b_exit item emit, f_code .byte b_emit .byte b_exit item count, f_code .byte b_count .byte b_exit item <span class="hljs-string"><span class="hljs-string">"(\")"</span></span>, f_code .byte b_str .byte b_exit item <span class="hljs-string"><span class="hljs-string">"(.\")"</span></span>, f_code .byte b_strp .byte b_exit item var8, f_code .byte b_var8 .byte <span class="hljs-number"><span class="hljs-number">0f</span></span> - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item var16, f_code .byte b_var16 .word <span class="hljs-number"><span class="hljs-number">0f</span></span> - . <span class="hljs-number"><span class="hljs-number">0</span></span>: .byte b_exit item base base: .byte b_var0 v_base: .quad <span class="hljs-number"><span class="hljs-number">10</span></span> holdbuf_len = <span class="hljs-number"><span class="hljs-number">70</span></span> item holdbuf holdbuf: .byte b_var0 .space holdbuf_len item holdpoint holdpoint: .byte b_var0 .quad <span class="hljs-number"><span class="hljs-number">0</span></span> item span span: .byte b_var0 v_span: .quad <span class="hljs-number"><span class="hljs-number">0</span></span> # : hold holdpoint @ <span class="hljs-number"><span class="hljs-number">1</span></span>- dup holdbuf &gt; <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> drop drop <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> dup holdpoint ! c! then ; item hold hold: .byte b_call8 .byte holdpoint - . - <span class="hljs-number"><span class="hljs-number">1</span></span> <span class="hljs-meta"><span class="hljs-meta"># holdpoint .byte b_get # @ .byte b_wm # 1- .byte b_dup # dup .byte b_call8 .byte holdbuf - . - 1 # holdbuf .byte b_gt # &gt; .byte b_qbranch8 # </span><span class="hljs-meta-keyword"><span class="hljs-meta"><span class="hljs-meta-keyword">if</span></span></span><span class="hljs-meta"> .byte 0f - . .byte b_drop # drop .byte b_drop # drop .byte b_branch8 #     ( then) .byte 1f - . 0: .byte b_dup # dup .byte b_call8 .byte holdpoint - . - 1 # holdpoint .byte b_set # ! .byte b_set8 # c! 1: .byte b_exit # ; # : # base /mod swap dup 10 </span><span class="hljs-meta-string"><span class="hljs-meta"><span class="hljs-meta-string">&lt; if c" 0 + else 10 - c" A + then hold ; item # conv: .byte b_call16 .word base - . - 2 # base .byte b_get # @ .byte b_divmod # /mod .byte b_swap # swap .byte b_dup # dup .byte b_lit8 .byte 10 # 10 .byte b_lt # &lt; .byte b_qnbranch8 # if .byte 0f - . .byte b_lit8 .byte '0' # c" 0 .byte b_add # + .byte b_branch8 # else .byte 1f - . 0: .byte b_lit8 .byte '?' # c" A .byte b_add # + 1: .byte b_call16 .word hold - . - 2 # hold .byte b_exit # ; # : &lt;# holdbuf 70 + holdpoint ! ; item &lt;# conv_start: .byte b_call16 .word holdbuf - . - 2 .byte b_lit8 .byte holdbuf_len .byte b_add .byte b_call16 .word holdpoint - . - 2 .byte b_set .byte b_exit # : #s do # dup 0=until ; item #s conv_s: .byte b_call8 .byte conv - . - 1 .byte b_dup .byte b_qbranch8 .byte conv_s - . .byte b_exit # : #&gt; holdpoint @ holdbuf 70 + over - ; item #&gt; conv_end: .byte b_call16 .word holdpoint - . - 2 .byte b_get .byte b_call16 .word holdbuf - . - 2 .byte b_lit8 .byte holdbuf_len .byte b_add .byte b_over .byte b_sub .byte b_exit item . dot: .byte b_dup .byte b_abs .byte b_call8 .byte conv_start - . - 1 .byte b_lit8 .byte ' ' .byte b_call16 .word hold - . - 2 .byte b_call8 .byte conv_s - . - 1 .byte b_drop .byte b_zlt .byte b_qnbranch8 .byte 1f - . .byte b_lit8 .byte '-' .byte b_call16 .word hold - . - 2 1: .byte b_call8 .byte conv_end - . - 1 .byte b_type .byte b_exit item tib tib: .byte b_var0 v_tib: .quad 0 item #tib ntib: .byte b_var0 v_ntib: .quad 0 item &gt;in bin: .byte b_var0 v_in: .quad 0 # : .s depth dup . c": emit do dup while dup pick . 1- again drop ; item .s # 11 22 33 prstack: .byte b_depth # 11 22 33 3 .byte b_dup # 11 22 33 3 3 .byte b_strp .byte 2 .ascii "( " .byte b_call16 # 11 22 33 3 .word dot - . - 2 .byte b_strp # 11 22 33 3 .byte 3 .ascii "): " .byte b_dup, b_zlt .byte b_qnbranch8, 1f - . .byte b_strp .byte 14 .ascii "\nStack fault!\n" .byte b_quit 1: .byte b_dup # 11 22 33 3 3 .byte b_qnbranch8 # 11 22 33 3 .byte 2f - . .byte b_dup # 11 22 33 3 3 .byte b_pick # 11 22 33 3 11 .byte b_call16 # 11 22 33 3 .word dot - . - 2 .byte b_wm # 11 22 33 2 .byte b_branch8 .byte 1b - . 2: .byte b_drop # 11 22 33 .byte b_exit .macro prs new_line = 1 .byte b_call16 .word prstack - . - 2 .if \new_line &gt; 0 .byte b_lit8, '\n' .byte b_emit .endif .endm .macro pr string .byte b_strp .byte 9f - 8f 8: .ascii "\n\string" 9: .endm item interpret interpret: .byte b_blword .byte b_dup .byte b_qnbranch8 .byte 0f - . .byte b_over .byte b_over .byte b_find .byte b_dup .byte b_qnbranch8 .byte 1f - . .byte b_mrot .byte b_drop .byte b_drop .byte b_cfa .byte b_execute .byte b_branch8 .byte 2f - . 1: .byte b_drop .byte b_over, b_over .byte b_numberq # ,    .byte b_qbranch8, 3f - . #     0, ,      3 .byte b_type #    .byte b_strp #   .byte 19 #     .ascii " : word not found!\n" .byte b_quit #    3: .byte b_nip, b_nip #  ,     ( b_over, b_over) 2: #       .byte b_depth #    .byte b_zlt # ,   0 ( 0&lt;) .byte b_qnbranch8, interpret_ok - . #   ,    ,   .byte b_strp #    .byte 14 .ascii "\nstack fault!\n" .byte b_quit #    interpret_ok: .byte b_branch8 .byte interpret - . 0: .byte b_drop .byte b_exit last_item: .byte b_var0 item bye, f_code .byte b_bye .section .text .global _start #     _start: mov rbp, rsp sub rbp, stack_size lea r8, start mov init_stack, rsp mov init_rstack, rbp jmp _next b_var0 = 0x28 bcmd_var0: push r8 b_exit = 0x17 bcmd_exit: mov r8, [rbp] add rbp, 8 _next: movzx rcx, byte ptr [r8] inc r8 jmp [bcmd + rcx*8] b_num0 = 0x02 bcmd_num0: push 0 jmp _next b_num1 = 0x03 bcmd_num1: push 1 jmp _next b_num2 = 0x04 bcmd_num2: push 2 jmp _next b_num3 = 0x05 bcmd_num3: push 3 jmp _next b_num4 = 0x06 bcmd_num4: push 4 jmp _next b_num8 = 0x07 bcmd_num8: push 8 jmp _next b_lit8 = 0x08 bcmd_lit8: movsx rax, byte ptr [r8] inc r8 push rax jmp _next b_lit16 = 0x09 bcmd_lit16: movsx rax, word ptr [r8] add r8, 2 push rax jmp _next b_call8 = 0x0C bcmd_call8: movsx rax, byte ptr [r8] sub rbp, 8 inc r8 mov [rbp], r8 add r8, rax jmp _next b_call16 = 0x0D bcmd_call16: movsx rax, word ptr [r8] sub rbp, 8 add r8, 2 mov [rbp], r8 add r8, rax jmp _next b_call32 = 0x0E bcmd_call32: movsx rax, dword ptr [r8] sub rbp, 8 add r8, 4 mov [rbp], r8 add r8, rax jmp _next b_lit32 = 0x0A bcmd_lit32: movsx rax, dword ptr [r8] add r8, 4 push rax jmp _next b_lit64 = 0x0B bcmd_lit64: mov rax, [r8] add r8, 8 push rax jmp _next b_dup = 0x30 bcmd_dup: push [rsp] jmp _next b_wm = 0x20 bcmd_wm: decq [rsp] jmp _next b_wp = 0x18 bcmd_wp: incq [rsp] jmp _next b_add = 0x21 bcmd_add: pop rax add [rsp], rax jmp _next b_sub = 0x22 bcmd_sub: pop rax sub [rsp], rax jmp _next b_mul = 0x23 bcmd_mul: pop rax pop rbx imul rbx push rax jmp _next b_div = 0x24 bcmd_div: pop rbx pop rax cqo idiv rbx push rax jmp _next b_mod = 0x25 bcmd_mod: pop rbx pop rax cqo idiv rbx push rdx jmp _next b_divmod = 0x26 bcmd_divmod: pop rbx pop rax cqo idiv rbx push rdx push rax jmp _next b_abs = 0x27 bcmd_abs: mov rax, [rsp] or rax, rax jge _next neg rax mov [rsp], rax jmp _next b_drop = 0x31 bcmd_drop: add rsp, 8 jmp _next b_swap = 0x32 bcmd_swap: pop rax pop rbx push rax push rbx jmp _next b_rot = 0x33 bcmd_rot: pop rax pop rbx pop rcx push rbx push rax push rcx jmp _next b_mrot = 0x34 bcmd_mrot: pop rcx pop rbx pop rax push rcx push rax push rbx jmp _next b_over = 0x35 bcmd_over: push [rsp + 8] jmp _next b_pick = 0x36 bcmd_pick: pop rcx push [rsp + 8*rcx] jmp _next b_roll = 0x37 bcmd_roll: pop rcx mov rbx, [rsp + 8*rcx] roll1: mov rax, [rsp + 8*rcx - 8] mov [rsp + 8*rcx], rax dec rcx jnz roll1 push rbx jmp _next b_depth = 0x38 bcmd_depth: mov rax, init_stack sub rax, rsp sar rax, 3 push rax jmp _next b_nip = 0x39 bcmd_nip: pop rax mov [rsp], rax jmp _next b_get = 0x40 bcmd_get: pop rcx push [rcx] jmp _next b_set = 0x41 bcmd_set: pop rcx pop rax mov [rcx], rax jmp _next b_get8 = 0x42 bcmd_get8: pop rcx movsx rax, byte ptr [rcx] push rax jmp _next b_set8 = 0x43 bcmd_set8: pop rcx pop rax mov [rcx], al jmp _next b_get16 = 0x44 bcmd_get16: pop rcx movsx rax, word ptr [rcx] push rax jmp _next b_set16 = 0x45 bcmd_set16: pop rcx pop rax mov [rcx], ax jmp _next b_get32 = 0x46 bcmd_get32: pop rcx movsx rax, dword ptr [rcx] push rax jmp _next b_set32 = 0x47 bcmd_set32: pop rcx pop rax mov [rcx], eax jmp _next b_setp = 0x48 bcmd_setp: pop rcx pop rax add [rcx], rax jmp _next b_setm = 0x49 bcmd_setm: pop rcx pop rax sub [rcx], rax jmp _next b_2r = 0x60 bcmd_2r: pop rax sub rbp, 8 mov [rbp], rax jmp _next b_r2 = 0x61 bcmd_r2: push [rbp] add rbp, 8 jmp _next b_rget = 0x62 bcmd_rget: push [rbp] jmp _next # 0= b_zeq = 0x50 bcmd_zeq: pop rax or rax, rax jnz rfalse rtrue: push -1 jmp _next rfalse: push 0 jmp _next # 0&lt; b_zlt = 0x51 bcmd_zlt: pop rax or rax, rax jl rtrue push 0 jmp _next # 0&gt; b_zgt = 0x52 bcmd_zgt: pop rax or rax, rax jg rtrue push 0 jmp _next # = b_eq = 0x53 bcmd_eq: pop rbx pop rax cmp rax, rbx jz rtrue push 0 jmp _next # &lt; b_lt = 0x54 bcmd_lt: pop rbx pop rax cmp rax, rbx jl rtrue push 0 jmp _next # &gt; b_gt = 0x55 bcmd_gt: pop rbx pop rax cmp rax, rbx jg rtrue push 0 jmp _next # &lt;= b_lteq = 0x56 bcmd_lteq: pop rbx pop rax cmp rax, rbx jle rtrue push 0 jmp _next # &gt;= b_gteq = 0x57 bcmd_gteq: pop rbx pop rax cmp rax, rbx jge rtrue push 0 jmp _next b_var8 = 0x29 bcmd_var8: push r8 b_branch8 = 0x10 bcmd_branch8: movsx rax, byte ptr [r8] add r8, rax jmp _next b_var16 = 0x30 bcmd_var16: push r8 b_branch16 = 0x11 bcmd_branch16: movsx rax, word ptr [r8] add r8, rax jmp _next b_qbranch8 = 0x12 bcmd_qbranch8: pop rax or rax, rax jnz bcmd_branch8 inc r8 jmp _next b_qbranch16 = 0x13 bcmd_qbranch16: pop rax or rax, rax jnz bcmd_branch16 add r8, 2 jmp _next b_qnbranch8 = 0x14 bcmd_qnbranch8: pop rax or rax, rax jz bcmd_branch8 inc r8 jmp _next b_qnbranch16 = 0x15 bcmd_qnbranch16:pop rax or rax, rax jz bcmd_branch16 add r8, 2 jmp _next b_bad = 0x00 bcmd_bad: mov rax, 1 #    1 - sys_write mov rdi, 1 #   1  stdout mov rsi, offset msg_bad_byte #     mov rdx, msg_bad_byte_len #   syscall #   mov rax, 60 #    1 - sys_exit mov rbx, 1 #    1 syscall #   b_bye = 0x01 bcmd_bye: mov rax, 1 #    1 - sys_write mov rdi, 1 #   1  stdout mov rsi, offset msg_bye #     mov rdx, msg_bye_len #   syscall #   mov rax, 60 #    60 - sys_exit mov rdi, 0 #    0 syscall #   b_strp = 0x83 bcmd_strp: movsx rax, byte ptr [r8] inc r8 push r8 add r8, rax push rax b_type = 0x80 bcmd_type: mov rax, 1 #    1 - sys_write mov rdi, 1 #   1 - stdout pop rdx #   pop rsi #   push r8 syscall #   pop r8 jmp _next b_expect = 0x88 bcmd_expect: mov rax, 0 #    1 - sys_read mov rdi, 0 #   1 - stdout pop rdx #   pop rsi #   push r8 syscall #   pop r8 mov rbx, rax or rax, rax jge 1f xor rbx, rbx 1: mov v_span, rbx jmp _next b_str = 0x82 bcmd_str: movzx rax, byte ptr [r8] lea r8, [r8 + rax + 1] jmp _next b_count = 0x84 bcmd_count: pop rcx movzx rax, byte ptr [rcx] inc rcx push rcx push rax jmp _next b_emit = 0x81 bcmd_emit: pop rax mov rsi, offset emit_buf #   mov [rsi], al mov rax, 1 #    1 - sys_write mov rdi, 1 #   1 - stdout mov rdx, 1 #   push r8 syscall #   pop r8 jmp _next b_blword = 0xF0 bcmd_blword: mov rsi, v_tib #    mov rdx, rsi #   RDX       mov rax, v_in #     mov rcx, v_ntib #    mov rbx, rcx add rsi, rax #  RSI -      sub rcx, rax #     jz 3f word2: lodsb #   AL  RSI   cmp al, ' ' ja 1f #    (    ) dec rcx jnz word2 #    3: sub rsi, rdx mov v_in, rsi push rcx jmp _next 1: lea rdi, [rsi - 1] # RDI = RSI - 1 ( ) dec rcx jz word9 word3: lodsb cmp al, ' ' jbe 2f dec rcx jnz word3 word9: inc rsi 2: mov rax, rsi sub rsi, rdx #        (   ) cmp rsi, rbx jle 4f mov rsi, rbx 4: mov v_in, rsi sub rax, rdi dec rax jz word1 push rdi #   word1: push rax #   jmp _next b_quit = 0xF1 bcmd_quit: lea r8, quit mov rsp, init_stack mov rbp, init_rstack jmp _next b_find = 0xF2 bcmd_find: pop rbx #   pop r9 #   mov rdx, v_context mov rdx, [rdx] #        #   find0: mov al, [rdx] #  and al, 3 #   -     ,     ,    or al, al jz find_l8 cmp al, 1 jz find_l16 cmp al, 2 jz find_l32 mov r10, [rdx + 1] #  64  lea rsi, [rdx + 9] #   jmp find1 find_l32: movsx r10, dword ptr [rdx + 1] #  32  lea rsi, [rdx + 5] #   jmp find1 find_l16: movsx r10, word ptr [rdx + 1] #  16  lea rsi, [rdx + 3] #   jmp find1 find_l8: movsx r10, byte ptr [rdx + 1] #  8  lea rsi, [rdx + 2] #   find1: movzx rax, byte ptr [rsi] #       cmp rax, rbx jz find2 #      find3: or r10, r10 jz find_notfound #  ,    add rdx, r10 #     jmp find0 #  ,   find2: inc rsi mov rdi, r9 mov rcx, rax repz cmpsb jnz find3 #   push rdx jmp _next find_notfound: push r10 jmp _next b_cfa = 0xF3 bcmd_cfa: pop rdx #    mov al, [rdx] #  and al, 3 #   -     ,     ,    or al, al jz cfa_l8 cmp al, 1 jz cfa_l16 cmp al, 2 jz cfa_l32 lea rsi, [rdx + 9] #   (64  ) jmp cfa1 cfa_l32: lea rsi, [rdx + 5] #   (32  ) jmp cfa1 cfa_l16: lea rsi, [rdx + 3] #   (16  ) jmp cfa1 cfa_l8: lea rsi, [rdx + 2] #   (8  ) cfa1: xor rax, rax lodsb add rsi, rax push rsi jmp _next b_execute = 0xF4 bcmd_execute: sub rbp, 8 mov [rbp], r8 #       pop r8 #  - jmp _next b_numberq = 0xF5 bcmd_numberq: pop rcx #   pop rsi #  xor rax, rax #   xor rbx, rbx #     mov r9, v_base #  xor r10, r10 #   or rcx, rcx jz num_false mov bl, [rsi] cmp bl, '+' jnz 1f inc rsi dec rcx jz num_false jmp num0 1: cmp bl, '-' jnz num0 mov r10, 1 inc rsi dec rcx jz num_false num0: mov bl, [rsi] cmp bl, '0' jb num_false cmp bl, '9' jbe num_09 cmp bl, 'A' jb num_false cmp bl, 'Z' jbe num_AZ cmp bl, 'a' jb num_false cmp bl, 'z' ja num_false sub bl, 'a' - 10 jmp num_check num_AZ: sub bl, 'A' - 10 jmp num_check num_09: sub bl, '0' num_check: cmp rbx, r9 jge num_false mul r9 add rax, rbx inc rsi dec rcx jnz num0 or r10, r10 push rax push 1 jmp _next num_false: xor rcx, rcx push rcx jmp _next</span></span></span></span></code> </pre></div></div><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Der Quellcode wird immer gr√∂√üer, deshalb bringe ich ihn zum letzten Mal hierher. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Jetzt befindet sich sein Wohnort auf dem Github: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">https://github.com/hal9000cc/forth64</font></font></a> <br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;"> An derselben Stelle finden Sie im Ordner bin die Version, die bereits f√ºr Linux x64 kompiliert wurde. Wer Linux hat, kann herunterladen und ausf√ºhren. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Und wer hat Windows - Sie k√∂nnen WSL (Windows Subsystem f√ºr Linux) installieren. Ich ging in die Ferien und tat genau das. Es stellte sich als sehr einfach heraus, es dauerte ungef√§hr 5 Minuten. Es gab nur einen Moment, es startete nicht sofort, das Subsystem musste √ºber den PowerShell-Befehl ‚Äûeingeschaltet‚Äú werden. Folgen Sie dem Link aus der Fehlermeldung, f√ºhren Sie den Befehl aus und es hat funktioniert. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es gibt aber auch eine M√∂glichkeit f√ºr echte Inder, alles unter Windows auszuf√ºhren :) Es ist nicht schwierig, dies zu tun. Wiederholen Sie einfach ein paar W√∂rter, die mit dem System interagieren.</font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Das ist alles! </font><font style="vertical-align: inherit;">N√§chstes Mal f√ºhren wir den Compiler aus. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Es wird die M√∂glichkeit geben, neue W√∂rter zusammenzustellen, es wird Bedingungen und Zyklen geben. </font><font style="vertical-align: inherit;">Tats√§chlich wird es m√∂glich sein, auf eine mehr oder weniger standardm√§√üige Festung zu schreiben, sie in Bytecode zu kompilieren und auszuf√ºhren. </font><font style="vertical-align: inherit;">Nun, es wird m√∂glich sein, ernstere Tests durchzuf√ºhren und die Leistung der Byte-Maschine zu √ºberpr√ºfen. </font></font><br><br><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Fortsetzung: </font></font><a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><font style="vertical-align: inherit;"><font style="vertical-align: inherit;">Byte-Maschine f√ºr das Fort (und nicht nur) in Native American (Teil 4)</font></font></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de435236/">https://habr.com/ru/post/de435236/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de435220/index.html">Kotlin Native: Verfolgen Sie die Dateien</a></li>
<li><a href="../de435224/index.html">So kommunizieren Sie in einem englischsprachigen B√ºro: 14 n√ºtzliche Redewendungen</a></li>
<li><a href="../de435226/index.html">Stellen Sie die Daten von Grund auf neu her</a></li>
<li><a href="../de435228/index.html">Kubernetes Cluster f√ºr 20 US-Dollar pro Monat</a></li>
<li><a href="../de435234/index.html">Kl√ºger, genauer gesagt: Wie KI Fl√ºge in den Weltraum ver√§ndert</a></li>
<li><a href="../de435240/index.html">Unreal Engine4 - PostProcess-Scan-Effekt</a></li>
<li><a href="../de435242/index.html">Warum habe ich Angst, ein "gepumpter Mann" zu werden?</a></li>
<li><a href="../de435244/index.html">ITER-Projekt im Jahr 2018</a></li>
<li><a href="../de435246/index.html">Tesla hat Vorbestellungen f√ºr Modell 3 in Europa und China er√∂ffnet</a></li>
<li><a href="../de435248/index.html">Navigation in der Android-Anwendung</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>