<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>🤷🏼 👨🏼‍⚕️ 🧞 Golang: masalah kinerja tertentu 🧝 👩🏾‍🤝‍👩🏼 🍞</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bahasa Go semakin populer. Begitu yakin bahwa ada semakin banyak konferensi, misalnya, GolangConf , dan bahasanya adalah salah satu dari sepuluh tekno...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Golang: masalah kinerja tertentu</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/company/oleg-bunin/blog/461291/">  Bahasa Go semakin populer.  Begitu yakin bahwa ada semakin banyak konferensi, misalnya, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GolangConf</a> , dan bahasanya <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">adalah salah satu dari sepuluh</a> teknologi yang paling berbayar.  Karena itu, sudah masuk akal untuk membicarakan masalah spesifiknya, misalnya kinerja.  Selain masalah umum untuk semua bahasa yang dikompilasi, Go memiliki masalahnya sendiri.  Mereka terkait dengan optimizer, stack, sistem tipe, dan model multitasking.  Cara untuk menyelesaikannya dan penyelesaiannya terkadang sangat spesifik. <br><br>  <strong>Daniel Podolsky</strong> , meskipun penginjil Go, juga menemukan banyak hal aneh dalam dirinya.  Semuanya aneh dan, yang paling penting, menarik, mengumpulkan dan <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">menguji</a> , dan kemudian membicarakannya di HighLoad ++.  Transkrip laporan akan mencakup angka, grafik, contoh kode, hasil profiler, perbandingan kinerja algoritme yang sama dalam berbagai bahasa - dan yang lainnya, yang kami benci dengan kata "optimisasi".  Tidak akan ada wahyu dalam transkrip - dari mana mereka berasal dalam bahasa yang begitu sederhana - dan segala sesuatu yang dapat dibaca di koran. <br><br><iframe width="560" height="315" src="https://www.youtube.com/embed/8UESXMJwTpc" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen=""></iframe><br><a name="habracut"></a><br>  <strong>Tentang pembicara.</strong>  <b>Daniil Podolsky</b> : 26 tahun pengalaman, 20 dalam operasi, termasuk pemimpin grup, 5 tahun pemrograman on Go.  <b>Kirill Danshin</b> : pencipta Gramework, Maintainer, HTTP Cepat, Black Go-mage. <br><br>  <em>Laporan itu disusun bersama oleh Daniel Podolsky dan Kirill Danshin, tetapi Daniel membuat laporan, dan Kirill membantu secara mental.</em> <br><br><h2>  Konstruksi bahasa </h2><br>  Kami memiliki standar kinerja - <code>direct</code> .  Ini adalah fungsi yang menambah variabel dan tidak lagi melakukan apa pun. <br><br><pre> <code class="go hljs"><span class="hljs-comment"><span class="hljs-comment">//   var testInt64 int64 func BenchmarkDirect(b *testing.B) { for i := 0; i &lt; bN; i++ { incDirect() } } func incDirect() { testInt64++ }</span></span></code> </pre> <br>  Hasil dari fungsi adalah <b>1,46 ns per operasi</b> .  Ini adalah opsi minimum.  Lebih cepat dari 1,5 ns per operasi, mungkin tidak akan berfungsi. <br><br><h3>  Tunda betapa kami mencintainya </h3><br>  Banyak yang tahu dan suka menggunakan konstruksi bahasa menunda.  Cukup sering kita menggunakannya seperti ini. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkDefer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { incDefer() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incDefer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">defer</span></span> incDirect() }</code> </pre> <br>  Tapi Anda tidak bisa menggunakannya seperti itu!  Setiap penundaan makan 40 ns per operasi. <br><br><pre> <code class="plaintext hljs">//   BenchmarkDirect-4 2000000000 1.46 / // defer BenchmarkDefer-4 30000000 40.70 /</code> </pre> <br>  Saya pikir mungkin ini karena inline?  Mungkin inline sangat cepat? <br><br>  Direct adalah inline, dan fungsi defer tidak bisa inline.  Karena itu, susun fungsi tes terpisah tanpa inline. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkDirectNoInline</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { incDirectNoInline() } } <span class="hljs-comment"><span class="hljs-comment">//go:noinline func incDirectNoInline() { testInt64++ }</span></span></code> </pre> <br>  Tidak ada yang berubah, menunda mengambil 40 ns yang sama.  Tunda sayang, tapi tidak bencana. <br><br><blockquote>  Di mana fungsi membutuhkan waktu kurang dari 100 ns, Anda dapat melakukannya tanpa menunda. </blockquote><br>  Tetapi jika fungsinya membutuhkan lebih dari satu mikrodetik, semuanya tetap sama - Anda dapat menggunakan penundaan. <br><br><h3>  Melewati parameter dengan referensi </h3><br>  Pertimbangkan mitos populer. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkDirectByPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { incDirectByPointer(&amp;testInt64) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">incDirectByPointer</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(n *</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { *n++ }</code> </pre> <br>  Tidak ada yang berubah - tidak ada yang sepadan. <br><br><pre> <code class="plaintext hljs">//     BenchmarkDirectByPointer-4 2000000000 1.47 / BenchmarkDeferByPointer-4 30000000 43.90 /</code> </pre> <br>  Kecuali untuk 3 ns per penundaan, tetapi ini dihapuskan karena fluktuasi. <br><br><h3>  Fungsi Anonim </h3><br>  Terkadang pemula bertanya, "Apakah fungsi anonim mahal?" <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkDirectAnonymous</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { testInt64++ }() } }</code> </pre> <br><blockquote>  Fungsi anonim tidak mahal, dibutuhkan 40,4 ns. </blockquote><br><h3>  Antarmuka </h3><br>  Ada antarmuka dan struktur yang mengimplementasikannya. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> testTypeInterface <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> { Inc() } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> testTypeStruct <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { n <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(s *testTypeStruct)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Inc</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { s.n++ }</code> </pre> <br>  Ada tiga opsi untuk menggunakan metode kenaikan.  Langsung dari Struct: <code>var testStruct = testTypeStruct{}</code> . <br><br>  Dari antarmuka konkret yang sesuai: <code>var testInterface testTypeInterface = &amp;testStruct</code> . <br><br>  Dengan konversi antarmuka runtime: <code>var testInterfaceEmpty interface{} = &amp;testStruct</code> . <br><br>  Di bawah ini adalah konversi antarmuka runtime dan penggunaan langsung. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkInterface</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { testInterface.Inc() } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkInterfaceRuntime</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { testInterfaceEmpty.(testTypeInterface).Inc() } }</code> </pre> <br><blockquote>  Antarmuka, dengan demikian, tidak ada biaya. </blockquote><br><pre> <code class="plaintext hljs">//  BenchmarkStruct-4 2000000000 1.44 / BenchmarkInterface-4 2000000000 1.88 / BenchmarkInterfaceRuntime-4 200000000 9.23 /</code> </pre> <br><br>  Konversi antarmuka Runtime sepadan, tetapi tidak mahal - Anda tidak perlu menolak secara khusus.  Tapi coba lakukan tanpanya jika memungkinkan. <br><br>  <b>Mitos:</b> <br><br><ul><li>  Dereference - petunjuk dereferencing - gratis. </li><li>  Fitur anonim gratis. </li><li>  Antarmuka gratis. </li><li>  Konversi antarmuka runtime - TIDAK GRATIS. </li></ul><br><h3>  Beralih, petakan, dan iris </h3><br>  Setiap pendatang baru Go bertanya apa yang terjadi jika Anda mengganti sakelar dengan peta.  Akankah ini lebih cepat? <br><br>  Switch datang dalam berbagai ukuran.  Saya menguji pada tiga ukuran: kecil untuk 10 kasus, sedang untuk 100 dan besar untuk 1000 kasus.  Beralih untuk 1000 kasus ditemukan dalam kode produksi nyata.  Tentu saja, tidak ada yang menulisnya dengan tangannya.  Ini adalah kode yang dibuat secara otomatis, biasanya tipe switch.  Diuji pada dua jenis: int dan string.  Tampaknya itu akan menjadi lebih jelas. <br><br>  <strong>Sedikit beralih.</strong>  Opsi tercepat adalah saklar aktual.  Mengikutinya segera pergi slice, di mana indeks integer yang sesuai berisi referensi ke fungsi.  Peta bukan pemimpin di int atau string. <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkSwitchIntSmall-4 </td><td>  500000000 </td><td>  3,26 ns / op </td></tr><tr><td>  BenchmarkMapIntSmall-4 </td><td>  100.000.000 </td><td>  11,70 ns / op </td></tr><tr><td>  BenchmarkSliceIntSmall-4 </td><td>  500000000 </td><td>  3,85 ns / op </td></tr><tr><td>  BenchmarkSwitchStringSmall-4 </td><td>  100.000.000 </td><td>  12.70 ns / op </td></tr><tr><td>  BenchmarkMapStringSmall-4 </td><td>  100.000.000 </td><td>  15.60 ns / op </td></tr></tbody></table></div><br>  Mengaktifkan string secara signifikan lebih lambat daripada di int.  Jika Anda dapat beralih bukan ke string, tetapi ke int, maka lakukanlah. <br><br>  <strong>Saklar tengah.</strong>  Beralih sendiri masih aturan int, tetapi irisan telah menyusul sedikit.  Peta masih buruk.  Tetapi pada kunci string, peta lebih cepat daripada beralih - seperti yang diharapkan. <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkSwitchIntMedium-4 </td><td>  300000000 </td><td>  4,55 ns / op </td></tr><tr><td>  BenchmarkMapIntMedium-4 </td><td>  100.000.000 </td><td>  17.10 ns / op </td></tr><tr><td>  BenchmarkSliceIntMedium-4 </td><td>  300000000 </td><td>  3,76 ns / op </td></tr><tr><td>  BenchmarkSwitchStringMedium-4 </td><td>  50.000.000 </td><td>  28,50 ns / op </td></tr><tr><td>  BenchmarkMapStringMedium-4 </td><td>  100.000.000 </td><td>  20.30 ns / op </td></tr></tbody></table></div><br>  <strong>Sakelar besar.</strong>  Seribu kasus menunjukkan kemenangan peta tanpa syarat dalam nominasi "switch by string".  Secara teoritis, slice menang, tetapi dalam praktiknya saya menyarankan Anda untuk menggunakan switch yang sama di sini.  Peta masih lambat, bahkan mengingat peta memiliki kunci integer dengan fungsi hash khusus.  Secara umum, fungsi ini tidak melakukan apa-apa.  Int itu sendiri memiliki hash untuk int. <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkSwitchIntLarge-4 </td><td>  100.000.000 </td><td>  13,6 ns / op </td></tr><tr><td>  BenchmarkMapIntLarge-4 </td><td>  50.000.000 </td><td>  34,3 ns / op </td></tr><tr><td>  BenchmarkSliceIntLarge-4 </td><td>  100.000.000 </td><td>  12,8 ns / op </td></tr><tr><td>  BenchmarkSwitchStringLarge-4 </td><td>  20.000.000 </td><td>  100.0 ns / op </td></tr><tr><td>  BenchmarkMapStringLarge-4 </td><td>  30000000 </td><td>  37,4 ns / op </td></tr></tbody></table></div><br>  <strong>Kesimpulan</strong>  Peta hanya lebih baik dalam jumlah besar dan tidak dalam kondisi bilangan bulat.  Saya yakin bahwa pada salah satu kondisi kecuali int, itu akan berperilaku sama seperti pada string.  Slice selalu mengarahkan ketika kondisinya bilangan bulat.  Gunakan jika Anda ingin "mempercepat" program Anda sebanyak 2 ns. <br><br><h2>  Interaksi antar rutin </h2><br>  Topiknya kompleks, saya telah melakukan banyak tes dan akan menyajikan yang paling terbuka.  Kita tahu cara- <strong>cara interaksi antarlembaga</strong> berikut. <br><br><ul><li>  Atom  Ini adalah cara penerapan terbatas - Anda dapat mengganti pointer atau menggunakan int. </li><li>  Mutex telah digunakan secara luas sejak Jawa. </li><li>  Saluran unik untuk GO. </li><li>  Buffered Channel - saluran buffered. </li></ul><br>  Tentu saja, saya menguji sejumlah besar goroutine yang bersaing untuk satu sumber daya.  Tetapi ia memilih tiga untuk dirinya sendiri sebagai indikasi: sedikit - 100, menengah - 1000 dan banyak - 10.000. <br><br>  <strong>Profil beban berbeda</strong> .  Terkadang semua gorutin ingin menulis dalam satu variabel, tetapi ini jarang terjadi.  Biasanya, setelah semua, beberapa menulis, beberapa membaca.  Dari sebagian besar pembaca - 90% membaca, dari mereka yang menulis - 90% menulis. <br><br>  Ini adalah kode yang digunakan sehingga goroutine yang melayani saluran dapat menyediakan bacaan dari dan penulisan ke variabel. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">go</span></span> <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">select</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> n, ok := &lt;-cw: <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> !ok { wgc.Done() <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> } testInt64 += n <span class="hljs-keyword"><span class="hljs-keyword">case</span></span> cr &lt;- testInt64: } } }()</code> </pre> <br>  Jika pesan sampai kepada kami melalui saluran yang kami gunakan untuk menulis, kami melaksanakannya.  Jika saluran ditutup, kami menyelesaikan goroutin.  Kapan saja, kami siap menulis ke saluran yang digunakan oleh goroutine lain untuk membaca. <br><div class="scrollable-table"><table><tbody><tr><td>  Benchmarkmutex-4 </td><td>  100.000.000 </td><td>  16.30 ns / op </td></tr><tr><td>  Benchmarkatomic-4 </td><td>  200000000 </td><td>  6,72 ns / op </td></tr><tr><td>  Benchmarkcan-4 </td><td>  5.000.000 </td><td>  239.00 ns / op </td></tr></tbody></table></div><br>  Ini adalah data untuk satu goroutine.  Tes saluran dilakukan pada dua goroutine: satu memproses Saluran, yang lain menulis ke Saluran ini.  Dan opsi ini telah diuji pada satu. <br><br><ul><li>  Menulis langsung ke variabel. </li><li>  Mutex mengambil log, menulis ke variabel, dan merilis log. </li><li>  Atomic menulis ke variabel melalui Atomic.  Ini tidak gratis, tetapi masih jauh lebih murah daripada Mutex pada satu garutin. </li></ul><br>  Dengan sejumlah kecil goroutine, Atomic adalah cara yang efektif dan cepat untuk menyinkronkan, yang tidak mengejutkan.  Direct tidak ada di sini, karena kami memerlukan sinkronisasi, yang tidak disediakannya.  Tapi Atomic memiliki kekurangan, tentu saja. <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkMutexFew-4 </td><td>  30000 </td><td>  55894 ns / op </td></tr><tr><td>  BenchmarkAtomicFew-4 </td><td>  100.000 </td><td>  14585 ns / op </td></tr><tr><td>  BenchmarkChanFew-4 </td><td>  5000 </td><td>  323859 ns / op </td></tr><tr><td>  BenchmarkChanBufferedFew-4 </td><td>  5000 </td><td>  341321 ns / op </td></tr><tr><td>  BenchmarkChanBufferedFullFew-4 </td><td>  20000 </td><td>  70052 ns / op </td></tr><tr><td>  BenchmarkMutexMostlyReadFew-4 </td><td>  30000 </td><td>  56402 ns / op </td></tr><tr><td>  BenchmarkAtomicMostlyReadFew-4 </td><td>  1.000.000 </td><td>  2094 ns / op </td></tr><tr><td>  BenchmarkChanMostlyReadFew-4 </td><td>  3000 </td><td>  442689 ns / op </td></tr><tr><td>  BenchmarkChanBufferedMostlyReadFew-4 </td><td>  3000 </td><td>  449.666 ns / op </td></tr><tr><td>  BenchmarkChanBufferedFullMostlyReadFew-4 </td><td>  5000 </td><td>  442.708 ns / op </td></tr><tr><td>  BenchmarkMutexMostlyWriteFew-4 </td><td>  20000 </td><td>  79708 ns / op </td></tr><tr><td>  BenchmarkAtomicMostlyWriteFew-4 </td><td>  100.000 </td><td>  13358 ns / op </td></tr><tr><td>  BenchmarkChanMostlyWriteFew-4 </td><td>  3000 </td><td>  449.556 ns / op </td></tr><tr><td>  BenchmarkChanBufferedMostlyWriteFew-4 </td><td>  3000 </td><td>  445423 ns / op </td></tr><tr><td>  BenchmarkChanBufferedFullMostlyWriteFew-4 </td><td>  3000 </td><td>  414626 ns / op </td></tr></tbody></table></div><br>  Selanjutnya adalah Mutex.  Saya berharap Channel akan secepat Mutex, tapi tidak. <br><br><blockquote>  Saluran adalah urutan besarnya lebih mahal daripada Mutex. </blockquote><br>  Selain itu, Saluran dan Saluran yang disangga keluar dengan harga yang sama.  Dan ada Channel, di mana buffer tidak pernah meluap.  Ini adalah urutan besarnya lebih murah daripada yang buffernya meluap.  Hanya jika buffer di Channel tidak penuh, maka harganya hampir sama dalam urutan besarnya seperti Mutex.  Inilah yang saya harapkan dari ujian. <br><br>  Gambar ini dengan distribusi berapa biayanya diulang pada profil beban apa pun - baik di MostlyRead dan MostlyWrite.  Selain itu, Saluran MostlyRead lengkap harganya sama dengan yang tidak lengkap.  Dan Channel buffered MostlyWrite, di mana buffer tidak penuh, harganya sama dengan yang lainnya.  Saya tidak bisa mengatakan mengapa demikian - saya belum mempelajari masalah ini. <br><br><h2>  Melewati parameter </h2><br>  <strong>Bagaimana cara melewati parameter lebih cepat - dengan referensi atau berdasarkan nilai?</strong>  Mari kita periksa. <br><br>  Saya memeriksa sebagai berikut - membuat tipe bersarang dari 1 hingga 10. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TP001 <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { I001 <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> TV002 <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { I001 <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> S001 TV001 I002 <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> S002 TV001 }</code> </pre> <br>  Tipe bersarang kesepuluh akan memiliki 10 bidang int64, dan tipe bersarang dari sarang sebelumnya juga akan menjadi 10. <br><br>  Lalu dia menulis fungsi yang membuat jenis bersarang. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewTP001</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> *</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TP001</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> &amp;TP001{ I001: rand.Int63(), } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">NewTV002</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">TV002</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> TV002{ I001: rand.Int63(), S001: NewTV001(), I002: rand.Int63(), S002: NewTV001(), } }</code> </pre> <br>  Untuk pengujian, saya menggunakan tiga opsi tipe: kecil dengan nesting 2, medium dengan nesting 3, besar dengan nesting 5. Saya harus melakukan tes yang sangat besar dengan nesting 10 pada malam hari, tetapi di sana gambarnya persis sama dengan untuk 5. <br><br>  <b>Dalam fungsi, melewati dengan nilai setidaknya dua kali lebih cepat daripada melewati dengan referensi</b> .  Ini disebabkan oleh fakta bahwa passing oleh nilai tidak memuat analisis escape.  Dengan demikian, variabel yang kami alokasikan ada di tumpukan.  Ini jauh lebih murah untuk runtime, untuk pengumpul sampah.  Meskipun dia mungkin tidak punya waktu untuk terhubung.  Tes ini berlangsung selama beberapa detik - pengumpul sampah mungkin masih tertidur. <br><div class="scrollable-table"><table><tbody><tr><td>  BenchmarkCreateSmallByValue-4 </td><td>  200.000 </td><td>  8942 ns / op </td></tr><tr><td>  BenchmarkCreateSmallByPointer-4 </td><td>  100.000 </td><td>  15985 ns / op </td></tr><tr><td>  BenchmarkCreateMediuMByValue-4 </td><td>  2000 </td><td>  862317 ns / op </td></tr><tr><td>  BenchmarkCreateMediuMByPointer-4 </td><td>  2000 </td><td>  1228130 ns / op </td></tr><tr><td>  BenchmarkCreateLargeByValue-4 </td><td>  30 </td><td>  47398456 ns / op </td></tr><tr><td>  BenchmarkCreateLargeByPointer-4 </td><td>  20 </td><td>  61928751 ns / op </td></tr></tbody></table></div><br><h2>  Ilmu hitam </h2><br>  Apakah Anda tahu apa yang akan dihasilkan oleh program ini? <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> main <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> A <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { a, b <span class="hljs-keyword"><span class="hljs-keyword">int32</span></span> } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span></span> { a := <span class="hljs-built_in"><span class="hljs-built_in">new</span></span>(A) aa = <span class="hljs-number"><span class="hljs-number">0</span></span> ab = <span class="hljs-number"><span class="hljs-number">1</span></span> z := (*(*<span class="hljs-keyword"><span class="hljs-keyword">int64</span></span>)(unsafe.Pointer(a))) fmt.Println(z) }</code> </pre> <br>  Hasil program tergantung pada arsitektur di mana ia dieksekusi.  Pada little endian, misalnya, AMD64, program ditampilkan <math></math><span class="MathJax_Preview" style="color: inherit; display: none;"></span><span class="MathJax_SVG" id="MathJax-Element-1-Frame" tabindex="0" style="font-size: 100%; display: inline-block; position: relative;" data-mathml="<math xmlns=&quot;http://www.w3.org/1998/Math/MathML&quot;><msup><mn>2</mn><mrow class=&quot;MJX-TeXAtom-ORD&quot;><mn>32</mn></mrow></msup></math>" role="presentation"><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="3.039ex" height="2.419ex" viewBox="0 -935.7 1308.3 1041.5" role="img" focusable="false" style="vertical-align: -0.246ex;" aria-hidden="true"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><use xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/oleg-bunin/blog/461291/&amp;usg=ALkJrhgGeqaFP5iFJBOKTacqx00I_Per7Q#MJMAIN-32" x="0" y="0"></use><g transform="translate(500,393)"><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/oleg-bunin/blog/461291/&amp;usg=ALkJrhgGeqaFP5iFJBOKTacqx00I_Per7Q#MJMAIN-33"></use><use transform="scale(0.707)" xlink:href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=https://habr.com/ru/company/oleg-bunin/blog/461291/&amp;usg=ALkJrhgGeqaFP5iFJBOKTacqx00I_Per7Q#MJMAIN-32" x="500" y="0"></use></g></g></svg><span class="MJX_Assistive_MathML" role="presentation"><math xmlns="http://www.w3.org/1998/Math/MathML"><msup><mn>2</mn><mrow class="MJX-TeXAtom-ORD"><mn>32</mn></mrow></msup></math></span></span><script type="math/tex" id="MathJax-Element-1"> 2 ^ {32} </script>  .  Pada big endian, satu.  Hasilnya berbeda, karena pada endian kecil unit ini muncul di tengah-tengah angka, dan pada endian besar - di akhir. <br><br>  Masih ada prosesor di dunia di mana endian beralih, misalnya, Power PC.  Penting untuk mengetahui endian apa yang dikonfigurasikan pada komputer Anda saat startup, sebelum membuat kesimpulan tentang apa trik yang tidak aman dilakukan.  Misalnya, jika Anda menulis kode Go yang akan dieksekusi pada beberapa server multiprosesor IBM. <br><br>  Saya mengutip kode ini untuk menjelaskan mengapa saya menganggap semua ilmu hitam tidak aman.  Anda tidak perlu menggunakannya.  Tetapi Cyril percaya bahwa itu perlu.  Dan inilah alasannya. <br><br>  Ada fungsi yang melakukan hal yang sama dengan GOB - Go Binary Marshaller.  Ini Encoder, tetapi tidak aman. <br><br><pre> <code class="go hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">encodeMut</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(data []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">uint64</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(res []</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">byte</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { sz := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(data) * <span class="hljs-number"><span class="hljs-number">8</span></span> dh := (*header)(unsafe.Pointer(&amp;data)) rh := &amp;header{ data: dh.data, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>: sz, <span class="hljs-built_in"><span class="hljs-built_in">cap</span></span>: sz, } res = *(*[]<span class="hljs-keyword"><span class="hljs-keyword">byte</span></span>)(unsafe.Pointer(&amp;rh)) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> }</code> </pre> <br>  Bahkan, dibutuhkan sepotong memori dan menarik array byte darinya. <br><br>  Ini bahkan bukan pesanan - ini adalah dua pesanan.  Oleh karena itu, Cyril Danshin, ketika ia menulis kode kinerja tinggi, tidak ragu untuk masuk ke nyali programnya dan membuatnya tidak aman. <br><br><div class="scrollable-table"><table><tbody><tr><td>  Patokan gob-4 </td><td>  200.000 </td><td>  8466 ns / op </td><td>  120,94 MB / s </td></tr><tr><td>  BenchmarkUnsafeMut-4 </td><td>  50.000.000 </td><td>  37 ns / op </td><td>  27691,06 MB / s </td></tr></tbody></table></div><blockquote>  Kami akan membahas fitur Go yang lebih spesifik pada 7 Oktober di <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">GolangConf</a> - sebuah konferensi untuk mereka yang menggunakan Go dalam pengembangan profesional, dan mereka yang menganggap bahasa ini sebagai alternatif.  Daniil Podolsky hanyalah anggota Komite Program, jika Anda ingin berdebat dengan artikel ini atau mengungkapkan masalah terkait - <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">kirimkan aplikasi</a> untuk laporan. <br><br>  Untuk yang lainnya, mengenai kinerja tinggi, tentu saja, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">HighLoad ++</a> .  Kami juga menerima aplikasi di sana.  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">Daftarkan diri Anda</a> untuk menerima buletin dan dapatkan berita terbaru dari semua konferensi kami untuk pengembang web. </blockquote></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id461291/">https://habr.com/ru/post/id461291/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id461281/index.html">Panduan untuk menyiapkan server BIND DNS di lingkungan chroot untuk Red Hat (RHEL / CentOS) 7</a></li>
<li><a href="../id461283/index.html">Arsitektur Perangkat Lunak dan Desain Sistem: Gambaran Besar dan Panduan Sumber Daya</a></li>
<li><a href="../id461285/index.html">5 algoritma pengambilan sampel utama</a></li>
<li><a href="../id461287/index.html">Mengembangkan AI yang licik dalam permainan taktis berdasarkan heuristik dan mutasi</a></li>
<li><a href="../id461289/index.html">CLion 2019.2 dirilis: dukungan pengembangan tertanam, debugger untuk MSVC, mencari file header yang tidak digunakan</a></li>
<li><a href="../id461297/index.html">Seperti apa serangan bertarget modern itu</a></li>
<li><a href="../id461299/index.html">Bagaimana PC menaklukkan industri media dengan perangkat lunak yang sukses: mendiskusikan Pro Tools dan Media Composer</a></li>
<li><a href="../id461303/index.html">Menggunakan kartu Troika sebagai polis asuransi kesehatan wajib</a></li>
<li><a href="../id461305/index.html">Jaringan perusahaan dan MitM. Bagian 2</a></li>
<li><a href="../id461307/index.html">Kami mengundang Anda ke VK Hackathon 2019. Kelompok hadiah tahun ini adalah dua juta rubel.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>