<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>ğŸ§ ğŸ¤¸ğŸ½ ğŸ”¼ Benchmark sebagai dasar untuk memutuskan perubahan kode ğŸŒ ğŸ’‡ğŸ¾ ğŸ§™</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Bill Kennedy mengatakan dalam sebuah kuliah tentang program pemrograman Ultimate Go yang luar biasa: 
 Banyak pengembang berusaha untuk mengoptimalkan...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Benchmark sebagai dasar untuk memutuskan perubahan kode</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/438446/">  Bill Kennedy mengatakan dalam sebuah kuliah tentang <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">program pemrograman Ultimate Go yang</a> luar biasa: <br><blockquote>  Banyak pengembang berusaha untuk mengoptimalkan kode mereka.  Mereka mengambil garis dan menulis ulang, mengatakan bahwa ini akan menjadi lebih cepat.  Perlu berhenti.  Mengatakan bahwa kode ini atau itu lebih cepat hanya mungkin setelah diprofilkan dan dibuat tolok ukur.  Bercerita bukanlah pendekatan yang tepat untuk menulis kode. </blockquote>  Saya sudah lama ingin menunjukkan dengan contoh praktis bagaimana ini bisa berhasil.  Dan beberapa hari yang lalu, perhatian saya tertuju pada kode berikut, yang bisa digunakan sebagai contoh: <br><a name="habracut"></a><br><pre><code class="go hljs">builds := store.Instance.GetBuildsFromNumberToNumber(stageBuild.BuildNumber, lastBuild.BuildNumber) tempList := model.BuildsList{} <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(builds) - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; i-- { b := builds[i] b.PatchURLs = b.ReversePatchURLs b.ExtractedSize = b.RPatchExtractedSize tempList = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(tempList, b) }</code> </pre> <br>  Di sini, di semua elemen slice <i>build yang</i> dikembalikan dari database, <i>PatchURL</i> digantikan oleh <i>ReversePatchURLs</i> , <i>ExtractedSize</i> oleh <i>RPatchExtractedSize</i> dan membalikkan dilakukan - urutan elemen diubah sehingga elemen terakhir menjadi yang pertama dan yang terakhir terakhir. <br><br>  Menurut pendapat saya, kode sumber agak rumit untuk dibaca dan dapat dioptimalkan.  Kode ini melakukan algoritma sederhana yang terdiri dari dua bagian logis: mengubah elemen slice dan menyortir.  Tetapi bagi programmer untuk mengisolasi dua komponen ini, itu akan memakan waktu. <br><br>  Terlepas dari kenyataan bahwa kedua bagian itu penting, kode terbalik tidak ditekankan seperti yang kita inginkan.  Ini tersebar di sepanjang tiga garis yang terkoyak: menginisialisasi irisan baru, mengiris irisan yang ada dalam urutan terbalik, menambahkan elemen ke ujung irisan baru.  Namun demikian, seseorang tidak dapat mengabaikan keuntungan yang tidak diragukan dari kode ini: kode ini berfungsi dan diuji, dan berbicara secara objektif, itu cukup memadai.  Persepsi subyektif dari kode oleh pengembang individu tidak bisa menjadi alasan untuk menulis ulang.  Sayangnya atau untungnya, kami tidak menulis ulang kode hanya karena kami tidak menyukainya (atau, seperti yang sering terjadi, hanya karena itu bukan milik kami, lihat <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">cacat fatal</a> ). <br><br>  Tetapi bagaimana jika kita berhasil tidak hanya meningkatkan persepsi kode, tetapi juga mempercepatnya secara signifikan?  Ini masalah yang sangat berbeda.  Anda dapat menawarkan beberapa algoritma alternatif yang menjalankan fungsi yang tertanam dalam kode. <br><br>  Opsi pertama: iterasi semua elemen dalam <i>rentang</i> lingkaran;  Untuk membalikkan irisan asli di setiap iterasi, tambahkan elemen ke awal array akhir.  Jadi kita bisa menghilangkan kerumitan <i>untuk</i> , variabel <i>i</i> , gunakan fungsi <i>len</i> , sulit untuk merasakan iterasi pada elemen dari akhir, dan juga mengurangi jumlah kode dengan dua baris (dari tujuh baris menjadi lima), dan semakin kecil kode, semakin kecil kemungkinan untuk memperbolehkannya sebuah kesalahan. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tempList []*store.Build <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, build := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> builds { build.PatchUrls, build.ExtractedSize = build.ReversePatchUrls, build.RPatchExtractedSize tempList = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>([]*store.Build{build}, tempList...) }</code> </pre><br>  Setelah menghapus enumerasi slice dari akhir, kami dengan jelas membedakan antara operasi elemen yang berubah (baris ketiga) dan membalikkan array asli (baris keempat). <br><br>  Gagasan utama dari opsi kedua adalah untuk lebih lanjut meledakkan variasi elemen dan penyortiran.  Pertama, kita memilah-milah elemen dan mengubahnya, dan kemudian mengurutkan irisan dengan operasi terpisah.  Metode ini akan membutuhkan implementasi tambahan antarmuka pengurutan untuk slice, tetapi akan meningkatkan keterbacaan dan benar-benar memisahkan dan mengisolasi balik dari perubahan elemen, dan metode <i>Balik</i> pasti akan menunjukkan kepada pembaca hasil yang diinginkan. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tempList []*store.Build <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, build := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> builds { build.PatchUrls, build.ExtractedSize = build.ReversePatchUrls, build.RPatchExtractedSize } sort.Sort(sort.Reverse(sort.IntSlice(keys)))</code> </pre><br>  Opsi ketiga hampir merupakan pengulangan dari yang kedua, tetapi <i>sort. Iris</i> digunakan untuk menyortir, yang meningkatkan jumlah kode per satu baris, tetapi menghindari implementasi tambahan dari antarmuka penyortiran. <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, build := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> builds { build.PatchUrls, build.ExtractedSize = build.ReversePatchUrls, build.RPatchExtractedSize } sort.Slice(builds, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, j </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> builds[i].Id &gt; builds[j].Id })</code> </pre><br>  Sekilas, dalam hal kompleksitas internal, jumlah iterasi, fungsi yang diterapkan, kode awal dan algoritma pertama sudah dekat;  opsi kedua dan ketiga mungkin tampak lebih sulit, tetapi tidak mungkin untuk mengatakan dengan tegas mana dari empat opsi yang optimal. <br><br>  Jadi, kami melarang diri untuk mengambil keputusan berdasarkan asumsi yang tidak didukung oleh bukti, tetapi jelas bahwa yang paling menarik di sini adalah bagaimana fungsi append berperilaku ketika menambahkan elemen ke akhir dan ke awal irisan.  Lagi pula, sebenarnya, fungsi ini tidak sesederhana kelihatannya. <br><br>  <i>Tambah</i> berfungsi <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=id&amp;u=">sebagai berikut</a> : ia menambahkan elemen baru ke irisan yang ada jika kapasitasnya lebih besar dari total panjang, atau cadangan dalam memori tempat untuk irisan baru, menyalin data dari irisan pertama ke dalamnya, menambahkan data yang kedua dan mengembalikan yang baru sebagai hasilnya mengiris. <br><br>  Nuansa yang paling menarik dalam karya fungsi ini adalah algoritma yang digunakan untuk menyimpan memori untuk array baru.  Karena operasi yang paling mahal adalah mengalokasikan memori baru, pengembang Go membuat sedikit trik untuk membuat operasi <i>penambahan</i> lebih murah.  Pada awalnya, agar tidak cadangan memori baru setiap kali elemen ditambahkan, jumlah memori dialokasikan dengan margin tertentu - dua kali lipat aslinya, tetapi setelah sejumlah elemen ukuran bagian memori yang baru dicadangkan menjadi tidak lebih dari dua kali, tetapi sebesar 25%. <br><br>  Dengan adanya pemahaman baru tentang fungsi <i>append,</i> jawaban atas pertanyaan: "Apa yang akan lebih cepat: tambahkan satu elemen ke akhir slice yang ada atau tambahkan slice yang ada ke slice dari satu elemen?"  - sudah lebih transparan.  Dapat diasumsikan bahwa dalam kasus kedua, dibandingkan dengan yang pertama, akan ada lebih banyak alokasi memori, yang secara langsung akan mempengaruhi kecepatan kerja. <br><br>  Jadi kami dengan lancar mendekati tolok ukur.  Dengan bantuan benchmark, Anda dapat mengevaluasi beban algoritme pada sumber daya paling kritis, seperti runtime dan RAM. <br><br>  Mari kita menulis tolok ukur untuk mengevaluasi keempat algoritma kami, pada saat yang sama kami akan mengevaluasi pertumbuhan apa yang dapat memberi kami penolakan penyortiran (untuk memahami berapa banyak waktu total yang dihabiskan untuk menyortirnya).  Kode Benchmark: <br><br><pre> <code class="go hljs"><span class="hljs-keyword"><span class="hljs-keyword">package</span></span> services <span class="hljs-keyword"><span class="hljs-keyword">import</span></span> ( <span class="hljs-string"><span class="hljs-string">"testing"</span></span> <span class="hljs-string"><span class="hljs-string">"sort"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Build <span class="hljs-keyword"><span class="hljs-keyword">struct</span></span> { Id <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> ExtractedSize <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> PatchUrls <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> ReversePatchUrls <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> RPatchExtractedSize <span class="hljs-keyword"><span class="hljs-keyword">int64</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> Builds []*Build <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a Builds)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Len</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">int</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(a) } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a Builds)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, j </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span></span> { a[i], a[j] = a[j], a[i] } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(a Builds)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Less</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i, j </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> a[i].Id &lt; a[j].Id } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">prepare</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Builds</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> builds Builds <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; <span class="hljs-number"><span class="hljs-number">100000</span></span>; i++ { builds = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(builds, &amp;Build{Id: i}) } <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> builds } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkF1</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { data := prepare() builds := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(Builds, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(data)) b.ResetTimer() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tempList Builds <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>(builds, data) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(builds) - <span class="hljs-number"><span class="hljs-number">1</span></span>; i &gt;= <span class="hljs-number"><span class="hljs-number">0</span></span>; i-- { b := builds[i] b.PatchUrls, b.ExtractedSize = b.ReversePatchUrls, b.RPatchExtractedSize tempList = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>(tempList, b) } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkF2</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { data := prepare() builds := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(Builds, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(data)) b.ResetTimer() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { <span class="hljs-keyword"><span class="hljs-keyword">var</span></span> tempList Builds <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>(builds, data) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, build := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> builds { build.PatchUrls, build.ExtractedSize = build.ReversePatchUrls, build.RPatchExtractedSize tempList = <span class="hljs-built_in"><span class="hljs-built_in">append</span></span>([]*Build{build}, tempList...) } } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkF3</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { data := prepare() builds := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(Builds, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(data)) b.ResetTimer() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>(builds, data) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, build := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> builds { build.PatchUrls, build.ExtractedSize = build.ReversePatchUrls, build.RPatchExtractedSize } sort.Sort(sort.Reverse(builds)) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkF4</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { data := prepare() builds := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(Builds, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(data)) b.ResetTimer() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>(builds, data) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, build := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> builds { build.PatchUrls, build.ExtractedSize = build.ReversePatchUrls, build.RPatchExtractedSize } sort.Slice(builds, <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(i </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">, j </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">int</span></span></span></span><span class="hljs-function"><span class="hljs-params">)</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> builds[i].Id &gt; builds[j].Id }) } } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">func</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">BenchmarkF5</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(b *testing.B)</span></span></span></span> { data := prepare() builds := <span class="hljs-built_in"><span class="hljs-built_in">make</span></span>(Builds, <span class="hljs-built_in"><span class="hljs-built_in">len</span></span>(data)) b.ResetTimer() <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> i := <span class="hljs-number"><span class="hljs-number">0</span></span>; i &lt; bN; i++ { <span class="hljs-built_in"><span class="hljs-built_in">copy</span></span>(builds, data) <span class="hljs-keyword"><span class="hljs-keyword">for</span></span> _, build := <span class="hljs-keyword"><span class="hljs-keyword">range</span></span> builds { build.PatchUrls, build.ExtractedSize = build.ReversePatchUrls, build.RPatchExtractedSize } } }</code> </pre><br>  Luncurkan benchmark dengan perintah <i>go test -bench =.</i>  <i>-benchmem</i> . <br><br>  Hasil perhitungan untuk irisan 10, 100, 1000, 10 000 dan 100 000 elemen disajikan dalam grafik di bawah ini, di mana F1 adalah algoritma awal, F2 adalah penambahan elemen ke awal array, F3 adalah penggunaan <i>sort. Kembali</i> ke sortir, F4 adalah penggunaan <i>sort.</i> , F5 - penolakan penyortiran. <br><br>  <i>Waktu operasi</i> <br><br><img src="https://habrastorage.org/webt/f_/i2/qp/f_i2qp8xvo7iqoj0k1noa9x1fii.png" alt="Waktu operasi"><br><br>  <i>Jumlah alokasi memori</i> <br><br><img src="https://habrastorage.org/webt/vh/fk/lu/vhfkluqv8_spb0-hnd482kgxigm.png"><br><br>  Seperti yang dapat Anda lihat dari grafik, Anda dapat meningkatkan array, tetapi hasil akhirnya pada prinsipnya dapat dibedakan pada sepotong 10 elemen.  <b>Tak satu pun dari algoritma alternatif yang diusulkan (F2, F3, F4) dapat melebihi algoritma asli (F1) dalam kecepatan.</b>  Meskipun fakta bahwa semua kecuali F2 memiliki alokasi memori lebih sedikit daripada yang asli.  Algoritma pertama (F2) dengan penambahan elemen pada awal irisan ternyata menjadi yang paling tidak efisien: seperti yang diharapkan, ia memiliki alokasi memori terlalu banyak, sehingga sangat mustahil untuk menggunakannya dalam pengembangan produk.  Algoritma yang menggunakan fungsi sortir terbalik bawaan (F3) secara signifikan lebih lambat dari yang asli.  Dan hanya sorting. <i>Algoritma</i> sortasi <i>kutu</i> sebanding dalam kecepatan dengan algoritma asli, tetapi sedikit lebih rendah dari itu. <br><br>  Anda juga dapat melihat bahwa menolak sorting (F5) memberikan akselerasi yang signifikan.  Oleh karena itu, jika Anda benar-benar ingin menulis ulang kode, Anda bisa menuju ke arah ini, misalnya, meningkatkan potongan <i>build</i> awal dari database, gunakan pengurutan berdasarkan id DESC daripada ASC dalam permintaan.  Tetapi pada saat yang sama, kami dipaksa untuk melampaui batas-batas bagian kode yang dianggap, yang berisiko menimbulkan banyak perubahan. <br><br><h3>  Kesimpulan </h3><br>  Tulis tolok ukur. <br><br>  Tidak masuk akal untuk menghabiskan waktu Anda memikirkan apakah suatu kode tertentu akan lebih cepat.  Informasi dari Internet, penilaian kolega dan orang lain, tidak peduli seberapa otoritatif mereka, dapat berfungsi sebagai argumen tambahan, tetapi peran hakim kepala, memutuskan apakah akan menjadi algoritma baru atau tidak, harus tetap dengan tolok ukur. <br><br>  Sekilas, Go adalah bahasa yang cukup sederhana.  Aturan 80â„20 yang komprehensif berlaku di sini.  20% ini mewakili seluk-beluk struktur internal bahasa, pengetahuan yang membedakan pemula dari pengembang berpengalaman.  Praktik menulis tolok ukur untuk menyelesaikan pertanyaan Anda adalah salah satu cara termurah dan paling efektif untuk mendapatkan jawaban maupun pemahaman yang lebih mendalam tentang struktur internal dan prinsip-prinsip bahasa Go. </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/id438446/">https://habr.com/ru/post/id438446/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../id438430/index.html">Saya terjebak! Atau cara mengatasi efek dataran tinggi dalam belajar bahasa Inggris</a></li>
<li><a href="../id438434/index.html">Lab Peretas: P1. Libssh auth bypass</a></li>
<li><a href="../id438436/index.html">Gagasan tentang bagaimana memberi karyawan akses sementara ke sumber daya pelanggan tanpa menyinari kembali kata sandi</a></li>
<li><a href="../id438438/index.html">Makanan untuk Bitrix Parrots. Kami menguji kinerja, pilih besi</a></li>
<li><a href="../id438442/index.html">Meneruskan permintaan dari Apache ke Payara Server 5 di Ubuntu</a></li>
<li><a href="../id438448/index.html">Apa yang PC Speaker mampu lakukan</a></li>
<li><a href="../id438450/index.html">Mengapa templat kebijakan privasi tidak cocok untuk Anda?</a></li>
<li><a href="../id438454/index.html">OpenSceneGraph: Levels of detail (LOD) dan pemuatan latar belakang objek</a></li>
<li><a href="../id438456/index.html">Menyiapkan Sistem Masuk Tunggal di Zimbra Collaboration Suite</a></li>
<li><a href="../id438458/index.html">Konferensi DUMP 2019 akan diadakan pada 19 April. Kami mengundang Anda untuk berbicara di bagian Frontend, Backend, dan Science.</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>