<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏽‍🚀 🛩️ 🕺🏻 TypeScript School of Magic: Generika und Typerweiterung 🤷 🍊 🕧</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Autor des Artikels, den wir heute übersetzen, sagt, TypeScript sei großartig. Als er anfing, TS zu benutzen, mochte er die Freiheit, die dieser Sp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>TypeScript School of Magic: Generika und Typerweiterung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/426729/"> Der Autor des Artikels, den wir heute übersetzen, sagt, TypeScript sei großartig.  Als er anfing, TS zu benutzen, mochte er die Freiheit, die dieser Sprache innewohnt.  Je mehr Aufwand ein Programmierer in seine Arbeit mit TS-spezifischen Mechanismen steckt, desto größer sind die Vorteile, die er erhält.  Dann verwendete er nur periodisch Typanmerkungen.  Manchmal nutzte er die Möglichkeiten zur Code-Vervollständigung und zu Compiler-Hinweisen, stützte sich jedoch hauptsächlich auf seine eigene Vision der von ihm gelösten Aufgaben. <br><br>  Im Laufe der Zeit stellte der Autor dieses Materials fest, dass er jedes Mal, wenn er Fehler umgeht, die bei der Kompilierung festgestellt wurden, eine Zeitbombe in seinen Code einfügt, die während der Programmausführung explodieren kann.  Jedes Mal, wenn er mit einem einfachen Konstrukt mit Fehlern „kämpfte“, musste er dafür mit vielen Stunden hartem Debuggen bezahlen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/8x/yn/4p/8xyn4p7bv34meq9s1o9k1i-hy0e.jpeg"></a> <br><br>  Infolgedessen kam er zu dem Schluss, dass es besser ist, dies nicht zu tun.  Er freundete sich mit dem Compiler an und begann, auf seine Hinweise zu achten.  Der Compiler findet Probleme im Code und meldet sie, lange bevor sie echten Schaden anrichten können.  Der Autor des Artikels, der sich selbst als Entwickler betrachtete, erkannte, dass der Compiler sein bester Freund ist, da er ihn vor sich selbst schützt.  Wie kann man sich nicht an die Worte von Albus Dumbledore erinnern: "Es erfordert viel Mut, sich Ihren Feinden zu widersetzen, aber nicht weniger, als sich Ihren Freunden zu widersetzen." <br><br>  Egal wie gut der Compiler sein mag, es ist nicht immer einfach zu gefallen.  Manchmal ist es sehr schwierig, die Verwendung eines <code>any</code> Typs zu vermeiden.  Und manchmal scheint es, dass <code>any</code> die einzig vernünftige Lösung für ein Problem ist. <br><br>  Dieses Material konzentriert sich auf zwei Situationen.  Indem Sie die Verwendung eines <code>any</code> Typs vermeiden, können Sie die Typensicherheit des Codes gewährleisten, die Möglichkeiten für dessen Wiederverwendung eröffnen und ihn intuitiv gestalten. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Generika</font> </h2><br>  Angenommen, wir arbeiten an einer Datenbank einer Schule.  Wir haben eine sehr praktische <code>getBy</code> .  Um das Objekt zu erhalten, das den Schüler mit seinem Namen darstellt, können wir einen Befehl der Form <code>getBy(model, "name", "Harry")</code> .  Werfen wir einen Blick auf die Implementierung dieses Mechanismus (um den Code nicht zu komplizieren, wird die Datenbank durch ein gewöhnliches Array dargestellt). <br><br><pre> <code class="hljs powershell">type Student = { name: string; age: number; hasScar: boolean; }; const students: Student[] = [ { <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Harry"</span></span>, <span class="hljs-type"><span class="hljs-type">age</span></span>: <span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-type"><span class="hljs-type">hasScar</span></span>: <span class="hljs-type"><span class="hljs-type">true</span></span> }, { <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Ron"</span></span>, <span class="hljs-type"><span class="hljs-type">age</span></span>: <span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-type"><span class="hljs-type">hasScar</span></span>: <span class="hljs-type"><span class="hljs-type">false</span></span> }, { <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Hermione"</span></span>, <span class="hljs-type"><span class="hljs-type">age</span></span>: <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-type"><span class="hljs-type">hasScar</span></span>: <span class="hljs-type"><span class="hljs-type">false</span></span> } ]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model, prop, value)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.filter(item =&gt; item[<span class="hljs-type"><span class="hljs-type">prop</span></span>] === value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] }</code> </pre> <br>  Wie Sie sehen können, haben wir eine gute Funktion, aber sie verwendet keine Typanmerkungen, und ihre Abwesenheit bedeutet auch, dass eine solche Funktion nicht als typsicher bezeichnet werden kann.  Repariere es. <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model: Student[], prop: string, value)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Student</span></span></span><span class="hljs-function"> | </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">null</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.filter(item =&gt; item[<span class="hljs-type"><span class="hljs-type">prop</span></span>] === value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] || null } const result = getBy(students, <span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-string"><span class="hljs-string">"Hermione"</span></span>) // result: Student</code> </pre> <br>  Unsere Funktion sieht also schon viel besser aus.  Der Compiler kennt jetzt die Art des von ihm erwarteten Ergebnisses, dies wird später nützlich sein.  Um jedoch ein sicheres Arbeiten mit Typen zu erreichen, haben wir die Möglichkeiten der Wiederverwendung der Funktion geopfert.  Was ist, wenn wir es jemals brauchen, um andere Entitäten zu bekommen?  Es kann nicht sein, dass diese Funktion in keiner Weise verbessert werden konnte.  Und das ist es wirklich. <br><br>  In TypeScript können wir wie in anderen stark typisierten Sprachen Generika verwenden, die auch als "generische Typen", "universelle Typen" und "Verallgemeinerungen" bezeichnet werden. <br><br>  Ein Generikum ähnelt einer regulären Variablen, enthält jedoch anstelle eines Werts eine Typdefinition.  Wir schreiben den Code unserer Funktion so um, dass anstelle des <code>Student</code> Typs der universelle Typ <code>T</code> <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBy</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model: T[], prop: string, value)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> | </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">null</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.filter(item =&gt; item[<span class="hljs-type"><span class="hljs-type">prop</span></span>] === value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] } const result = getBy&lt;Student&gt;(students, <span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-string"><span class="hljs-string">"Hermione"</span></span>) // result: Student</code> </pre> <br>  Schönheit!  Jetzt ist die Funktion ideal für die Wiederverwendung, während die Typensicherheit noch auf unserer Seite steht.  Beachten Sie, wie der <code>Student</code> Typ in der letzten Zeile des obigen Code-Snippets, in dem das generische <code>T</code> wird, explizit festgelegt <code>T</code> .  Dies geschieht, um das Beispiel so klar wie möglich zu gestalten. Der Compiler kann jedoch unabhängig den erforderlichen Typ ableiten. In den folgenden Beispielen werden solche Typverfeinerungen daher nicht durchgeführt. <br><br>  Jetzt haben wir eine zuverlässige Hilfsfunktion, die zur Wiederverwendung geeignet ist.  Es kann jedoch noch verbessert werden.  Was ist, wenn bei der Eingabe des zweiten Parameters ein Fehler auftritt und anstelle von <code>"name"</code> <code>"naem"</code> ?  Die Funktion verhält sich so, als ob sich der gesuchte Schüler einfach nicht in der Datenbank befindet und, was am unangenehmsten ist, keine Fehler erzeugt.  Dies kann zu einem langfristigen Debugging führen. <br><br>  Zum Schutz vor solchen Fehlern führen wir einen anderen universellen Typ ein, <code>P</code>  In diesem Fall ist es erforderlich, dass <code>P</code> ein Schlüssel vom Typ <code>T</code> ist. Wenn hier <code>Student</code> verwendet wird, ist es daher erforderlich, dass <code>P</code> die Zeichenfolge <code>"name"</code> , <code>"age"</code> oder <code>"hasScar"</code> .  Hier erfahren Sie, wie es geht. <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBy</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">P</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extends</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyof</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model: T[], prop: P, value)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> | </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">null</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.filter(item =&gt; item[<span class="hljs-type"><span class="hljs-type">prop</span></span>] === value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] || null } const result = getBy(students, <span class="hljs-string"><span class="hljs-string">"naem"</span></span>, <span class="hljs-string"><span class="hljs-string">"Hermione"</span></span>) // Error: Argument of type <span class="hljs-string"><span class="hljs-string">'"naem"'</span></span> is not assignable to <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> of type <span class="hljs-string"><span class="hljs-string">'"name" | "age" | "hasScar"'</span></span>.</code> </pre> <br>  Die Verwendung von Generika und dem <code>keyof</code> ist ein sehr mächtiger Trick.  Wenn Sie Programme in eine IDE schreiben, die TypeScript unterstützt, können Sie durch Eingabe von Argumenten die Funktionen zur automatischen Vervollständigung nutzen, was sehr praktisch ist. <br><br>  Wir haben die Arbeit an der <code>getBy</code> Funktion jedoch noch nicht abgeschlossen.  Sie hat ein drittes Argument, dessen Art wir noch nicht festgelegt haben.  Das passt uns überhaupt nicht.  Bisher konnten wir nicht im Voraus wissen, um welchen Typ es sich handeln sollte, da dies davon abhängt, was wir als zweites Argument übergeben.  Da wir nun Typ <code>P</code> , können wir den Typ für das dritte Argument dynamisch ableiten.  Der Typ des dritten Arguments ist letztendlich <code>T[P]</code> .  Wenn <code>T</code> <code>Student</code> und <code>P</code> <code>"age"</code> , hat <code>T[P]</code> die Typennummer. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> getBy&lt;T, P extends keyof T&gt;(model: T[], prop: P, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: T[P]): T | <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(item =&gt; item[prop] === <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>] || <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> } const result = getBy(students, "age", "17") // Error: Argument <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">'"17"'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> assignable <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parameter <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">'number'</span></span>. const anotherResult = getBy(students, "hasScar", "true") // Error: Argument <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">'"true"'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> assignable <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parameter <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">'boolean'</span></span>. const yetAnotherResult = getBy(students, "name", "Harry") //     </code> </pre> <br>  Ich hoffe, dass Sie jetzt ein absolut klares Verständnis für die Verwendung von Generika in TypeScript haben. Wenn Sie jedoch mit allem, was Sie mit dem hier beschriebenen Code experimentieren möchten, sehr gut experimentieren möchten, können Sie hier einen Blick darauf werfen. <br><br><h2>  <font color="#3AC1EF">Bestehende Typen erweitern</font> </h2><br>  Manchmal müssen wir Daten oder Funktionen zu Schnittstellen hinzufügen, deren Code wir nicht ändern können.  Möglicherweise müssen Sie das Standardobjekt ändern, z. B. dem <code>window</code> eine Eigenschaft hinzufügen oder das Verhalten einer externen Bibliothek wie <code>Express</code> .  In beiden Fällen können Sie das Objekt, mit dem Sie arbeiten möchten, nicht direkt beeinflussen. <br><br>  Wir werden eine Lösung für dieses Problem suchen, indem wir die bereits bekannte Funktion <code>getBy</code> zum <code>Array</code> Prototyp hinzufügen.  Auf diese Weise können wir mit dieser Funktion genauere syntaktische Konstruktionen erstellen.  Im Moment sprechen wir nicht darüber, ob es gut oder schlecht ist, Standardobjekte zu erweitern, da unser Hauptziel darin besteht, den betrachteten Ansatz zu untersuchen. <br><br>  Wenn wir versuchen, dem <code>Array</code> Prototyp eine Funktion hinzuzufügen, wird dem Compiler dies nicht sehr gefallen: <br><br><pre> <code class="hljs powershell">Array.prototype.getBy = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> &lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">P</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extends</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyof</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(   this: T[],   prop: P,   value: T[P] )</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> | </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">null</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.filter(item =&gt; item[<span class="hljs-type"><span class="hljs-type">prop</span></span>] === value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] || null; }; // Error: Property <span class="hljs-string"><span class="hljs-string">'getBy'</span></span> does not exist on type <span class="hljs-string"><span class="hljs-string">'any[]'</span></span>. const bestie = students.getBy(<span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-string"><span class="hljs-string">"Ron"</span></span>); // Error: Property <span class="hljs-string"><span class="hljs-string">'getBy'</span></span> does not exist on type <span class="hljs-string"><span class="hljs-string">'Student[]'</span></span>. const potionsTeacher = (teachers as any).getBy(<span class="hljs-string"><span class="hljs-string">"subject"</span></span>, <span class="hljs-string"><span class="hljs-string">"Potions"</span></span>) //  ...   ?</code> </pre> <br>  Wenn wir versuchen, den Compiler zu beruhigen, indem wir das Konstrukt regelmäßig <code>as any</code> Konstrukt verwenden, werden wir alles, was wir erreicht haben, aufheben.  Der Compiler ist stumm, aber Sie können die sichere Arbeit mit Typen vergessen. <br><br>  Es wäre besser, den <code>Array</code> Typ zu erweitern, aber bevor wir dies tun, wollen wir uns damit befassen, wie TypeScript Situationen behandelt, in denen zwei Schnittstellen desselben Typs im Code vorhanden sind.  Hier wird ein einfaches Aktionsschema angewendet.  Anzeigen werden nach Möglichkeit kombiniert.  Wenn Sie sie nicht kombinieren können, gibt das System einen Fehler aus. <br><br>  Dieser Code funktioniert also: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Wand</span></span> { length: number } <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Wand</span></span> {   core: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myWand: Wand = { length: <span class="hljs-number"><span class="hljs-number">11</span></span>, core: <span class="hljs-string"><span class="hljs-string">"phoenix feather"</span></span> } <span class="hljs-comment"><span class="hljs-comment">//  !</span></span></code> </pre> <br>  Und dieser ist nicht: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Wand</span></span> { length: number } <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Wand</span></span> {   length: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-comment"><span class="hljs-comment">// Error: Subsequent property declarations must have the same type.  Property 'length' must be of type 'number', but here has type 'string'.</span></span></code> </pre> <br>  Nachdem wir uns damit befasst haben, sehen wir, dass wir vor einer ziemlich einfachen Aufgabe stehen.  Wir müssen <code>getBy</code> die <code>Array&lt;T&gt;</code> -Schnittstelle deklarieren und die Funktion <code>getBy</code> hinzufügen. <br><br><pre> <code class="hljs powershell">interface Array&lt;T&gt; {  getBy&lt;P extends keyof T&gt;(prop: P, value: T[<span class="hljs-type"><span class="hljs-type">P</span></span>]): T | null; } Array.prototype.getBy = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> &lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">P</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extends</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyof</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(   this: T[],   prop: P,   value: T[P] )</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> | </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">null</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.filter(item =&gt; item[<span class="hljs-type"><span class="hljs-type">prop</span></span>] === value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] || null; }; const bestie = students.getBy(<span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-string"><span class="hljs-string">"Ron"</span></span>); //   ! const potionsTeacher = (teachers as any).getBy(<span class="hljs-string"><span class="hljs-string">"subject"</span></span>, <span class="hljs-string"><span class="hljs-string">"Potions"</span></span>) //    </code> </pre> <br>  Beachten Sie, dass der größte Teil des Codes, den Sie wahrscheinlich in Moduldateien schreiben, erforderlich ist. Um Änderungen an der <code>Array</code> Schnittstelle vorzunehmen, benötigen Sie Zugriff auf den globalen Bereich.  Sie können dies tun, indem Sie die Typdefinition in <code>declare global</code> .  Zum Beispiel so: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> {   interface <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>&lt;T&gt; {       getBy&lt;P extends keyof T&gt;(prop: P, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: T[P]): T | <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;   } }</code> </pre> <br>  Wenn Sie die Schnittstelle einer externen Bibliothek erweitern möchten, benötigen Sie höchstwahrscheinlich Zugriff auf den <code>namespace</code> dieser Bibliothek.  Hier ist ein Beispiel für das Hinzufügen des <code>userId</code> zu <code>Request</code> aus der <code>Express</code> Bibliothek: <br><br><pre> <code class="hljs cs">declare <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Express</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Request</span></span> {     userId: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>;   } } }</code> </pre> <br>  Sie können hier mit dem Code in diesem Abschnitt experimentieren. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  In diesem Artikel haben wir uns mit Techniken zur Verwendung von Generika und Typerweiterungen in TypeScript befasst.  Wir hoffen, dass das, was Sie heute gelernt haben, Ihnen hilft, zuverlässigen, verständlichen und typsicheren Code zu schreiben. <br><br>  <b>Liebe Leser!</b>  Wie stehen Sie zu einem Typ in TypeScript? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426729/">https://habr.com/ru/post/de426729/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426719/index.html">Hackathon über Data Science in SIBUR: wie es war</a></li>
<li><a href="../de426721/index.html">Vermeiden von Fehlern während der Produktentwicklung: 10 Tipps von Rookee</a></li>
<li><a href="../de426723/index.html">Microsoft und Partner hoffen, eine Zeitkapsel auf dem Mond zu schaffen</a></li>
<li><a href="../de426725/index.html">Wie man Dinge macht, wenn man keine Lust dazu hat</a></li>
<li><a href="../de426727/index.html">EME? Cdm? DRM? CENC? IDK! Was Sie brauchen, um Ihren eigenen Video-Player in einem Browser zu erstellen</a></li>
<li><a href="../de426731/index.html">CSS: interessante Merkmale des Randradius</a></li>
<li><a href="../de426733/index.html">Eisen wird nicht versagen. Wie ich Dutzende von Servern pro Tag für den Kampf vorbereite</a></li>
<li><a href="../de426735/index.html">Willkommen beim JETHACK Hackathon</a></li>
<li><a href="../de426737/index.html">Kurz über die Architektur neuromorpher Prozessoren: ein Einblick</a></li>
<li><a href="../de426739/index.html">Proxy-Dateien von AWS S3 mit nginx</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>