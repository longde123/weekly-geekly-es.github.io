<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèΩ‚ÄçüöÄ üõ©Ô∏è üï∫üèª TypeScript School of Magic: Generika und Typerweiterung ü§∑ üçä üïß</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Der Autor des Artikels, den wir heute √ºbersetzen, sagt, TypeScript sei gro√üartig. Als er anfing, TS zu benutzen, mochte er die Freiheit, die dieser Sp...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>TypeScript School of Magic: Generika und Typerweiterung</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/company/ruvds/blog/426729/"> Der Autor des Artikels, den wir heute √ºbersetzen, sagt, TypeScript sei gro√üartig.  Als er anfing, TS zu benutzen, mochte er die Freiheit, die dieser Sprache innewohnt.  Je mehr Aufwand ein Programmierer in seine Arbeit mit TS-spezifischen Mechanismen steckt, desto gr√∂√üer sind die Vorteile, die er erh√§lt.  Dann verwendete er nur periodisch Typanmerkungen.  Manchmal nutzte er die M√∂glichkeiten zur Code-Vervollst√§ndigung und zu Compiler-Hinweisen, st√ºtzte sich jedoch haupts√§chlich auf seine eigene Vision der von ihm gel√∂sten Aufgaben. <br><br>  Im Laufe der Zeit stellte der Autor dieses Materials fest, dass er jedes Mal, wenn er Fehler umgeht, die bei der Kompilierung festgestellt wurden, eine Zeitbombe in seinen Code einf√ºgt, die w√§hrend der Programmausf√ºhrung explodieren kann.  Jedes Mal, wenn er mit einem einfachen Konstrukt mit Fehlern ‚Äûk√§mpfte‚Äú, musste er daf√ºr mit vielen Stunden hartem Debuggen bezahlen. <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/webt/8x/yn/4p/8xyn4p7bv34meq9s1o9k1i-hy0e.jpeg"></a> <br><br>  Infolgedessen kam er zu dem Schluss, dass es besser ist, dies nicht zu tun.  Er freundete sich mit dem Compiler an und begann, auf seine Hinweise zu achten.  Der Compiler findet Probleme im Code und meldet sie, lange bevor sie echten Schaden anrichten k√∂nnen.  Der Autor des Artikels, der sich selbst als Entwickler betrachtete, erkannte, dass der Compiler sein bester Freund ist, da er ihn vor sich selbst sch√ºtzt.  Wie kann man sich nicht an die Worte von Albus Dumbledore erinnern: "Es erfordert viel Mut, sich Ihren Feinden zu widersetzen, aber nicht weniger, als sich Ihren Freunden zu widersetzen." <br><br>  Egal wie gut der Compiler sein mag, es ist nicht immer einfach zu gefallen.  Manchmal ist es sehr schwierig, die Verwendung eines <code>any</code> Typs zu vermeiden.  Und manchmal scheint es, dass <code>any</code> die einzig vern√ºnftige L√∂sung f√ºr ein Problem ist. <br><br>  Dieses Material konzentriert sich auf zwei Situationen.  Indem Sie die Verwendung eines <code>any</code> Typs vermeiden, k√∂nnen Sie die Typensicherheit des Codes gew√§hrleisten, die M√∂glichkeiten f√ºr dessen Wiederverwendung er√∂ffnen und ihn intuitiv gestalten. <br><a name="habracut"></a><br><h2>  <font color="#3AC1EF">Generika</font> </h2><br>  Angenommen, wir arbeiten an einer Datenbank einer Schule.  Wir haben eine sehr praktische <code>getBy</code> .  Um das Objekt zu erhalten, das den Sch√ºler mit seinem Namen darstellt, k√∂nnen wir einen Befehl der Form <code>getBy(model, "name", "Harry")</code> .  Werfen wir einen Blick auf die Implementierung dieses Mechanismus (um den Code nicht zu komplizieren, wird die Datenbank durch ein gew√∂hnliches Array dargestellt). <br><br><pre> <code class="hljs powershell">type Student = { name: string; age: number; hasScar: boolean; }; const students: Student[] = [ { <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Harry"</span></span>, <span class="hljs-type"><span class="hljs-type">age</span></span>: <span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-type"><span class="hljs-type">hasScar</span></span>: <span class="hljs-type"><span class="hljs-type">true</span></span> }, { <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Ron"</span></span>, <span class="hljs-type"><span class="hljs-type">age</span></span>: <span class="hljs-number"><span class="hljs-number">17</span></span>, <span class="hljs-type"><span class="hljs-type">hasScar</span></span>: <span class="hljs-type"><span class="hljs-type">false</span></span> }, { <span class="hljs-type"><span class="hljs-type">name</span></span>: <span class="hljs-string"><span class="hljs-string">"Hermione"</span></span>, <span class="hljs-type"><span class="hljs-type">age</span></span>: <span class="hljs-number"><span class="hljs-number">16</span></span>, <span class="hljs-type"><span class="hljs-type">hasScar</span></span>: <span class="hljs-type"><span class="hljs-type">false</span></span> } ]; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model, prop, value)</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.filter(item =&gt; item[<span class="hljs-type"><span class="hljs-type">prop</span></span>] === value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] }</code> </pre> <br>  Wie Sie sehen k√∂nnen, haben wir eine gute Funktion, aber sie verwendet keine Typanmerkungen, und ihre Abwesenheit bedeutet auch, dass eine solche Funktion nicht als typsicher bezeichnet werden kann.  Repariere es. <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBy</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model: Student[], prop: string, value)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">Student</span></span></span><span class="hljs-function"> | </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">null</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.filter(item =&gt; item[<span class="hljs-type"><span class="hljs-type">prop</span></span>] === value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] || null } const result = getBy(students, <span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-string"><span class="hljs-string">"Hermione"</span></span>) // result: Student</code> </pre> <br>  Unsere Funktion sieht also schon viel besser aus.  Der Compiler kennt jetzt die Art des von ihm erwarteten Ergebnisses, dies wird sp√§ter n√ºtzlich sein.  Um jedoch ein sicheres Arbeiten mit Typen zu erreichen, haben wir die M√∂glichkeiten der Wiederverwendung der Funktion geopfert.  Was ist, wenn wir es jemals brauchen, um andere Entit√§ten zu bekommen?  Es kann nicht sein, dass diese Funktion in keiner Weise verbessert werden konnte.  Und das ist es wirklich. <br><br>  In TypeScript k√∂nnen wir wie in anderen stark typisierten Sprachen Generika verwenden, die auch als "generische Typen", "universelle Typen" und "Verallgemeinerungen" bezeichnet werden. <br><br>  Ein Generikum √§hnelt einer regul√§ren Variablen, enth√§lt jedoch anstelle eines Werts eine Typdefinition.  Wir schreiben den Code unserer Funktion so um, dass anstelle des <code>Student</code> Typs der universelle Typ <code>T</code> <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBy</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model: T[], prop: string, value)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> | </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">null</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.filter(item =&gt; item[<span class="hljs-type"><span class="hljs-type">prop</span></span>] === value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] } const result = getBy&lt;Student&gt;(students, <span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-string"><span class="hljs-string">"Hermione"</span></span>) // result: Student</code> </pre> <br>  Sch√∂nheit!  Jetzt ist die Funktion ideal f√ºr die Wiederverwendung, w√§hrend die Typensicherheit noch auf unserer Seite steht.  Beachten Sie, wie der <code>Student</code> Typ in der letzten Zeile des obigen Code-Snippets, in dem das generische <code>T</code> wird, explizit festgelegt <code>T</code> .  Dies geschieht, um das Beispiel so klar wie m√∂glich zu gestalten. Der Compiler kann jedoch unabh√§ngig den erforderlichen Typ ableiten. In den folgenden Beispielen werden solche Typverfeinerungen daher nicht durchgef√ºhrt. <br><br>  Jetzt haben wir eine zuverl√§ssige Hilfsfunktion, die zur Wiederverwendung geeignet ist.  Es kann jedoch noch verbessert werden.  Was ist, wenn bei der Eingabe des zweiten Parameters ein Fehler auftritt und anstelle von <code>"name"</code> <code>"naem"</code> ?  Die Funktion verh√§lt sich so, als ob sich der gesuchte Sch√ºler einfach nicht in der Datenbank befindet und, was am unangenehmsten ist, keine Fehler erzeugt.  Dies kann zu einem langfristigen Debugging f√ºhren. <br><br>  Zum Schutz vor solchen Fehlern f√ºhren wir einen anderen universellen Typ ein, <code>P</code>  In diesem Fall ist es erforderlich, dass <code>P</code> ein Schl√ºssel vom Typ <code>T</code> ist. Wenn hier <code>Student</code> verwendet wird, ist es daher erforderlich, dass <code>P</code> die Zeichenfolge <code>"name"</code> , <code>"age"</code> oder <code>"hasScar"</code> .  Hier erfahren Sie, wie es geht. <br><br><pre> <code class="hljs powershell"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">getBy</span></span></span><span class="hljs-function">&lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">P</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extends</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyof</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(model: T[], prop: P, value)</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> | </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">null</span></span></span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.filter(item =&gt; item[<span class="hljs-type"><span class="hljs-type">prop</span></span>] === value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] || null } const result = getBy(students, <span class="hljs-string"><span class="hljs-string">"naem"</span></span>, <span class="hljs-string"><span class="hljs-string">"Hermione"</span></span>) // Error: Argument of type <span class="hljs-string"><span class="hljs-string">'"naem"'</span></span> is not assignable to <span class="hljs-keyword"><span class="hljs-keyword">parameter</span></span> of type <span class="hljs-string"><span class="hljs-string">'"name" | "age" | "hasScar"'</span></span>.</code> </pre> <br>  Die Verwendung von Generika und dem <code>keyof</code> ist ein sehr m√§chtiger Trick.  Wenn Sie Programme in eine IDE schreiben, die TypeScript unterst√ºtzt, k√∂nnen Sie durch Eingabe von Argumenten die Funktionen zur automatischen Vervollst√§ndigung nutzen, was sehr praktisch ist. <br><br>  Wir haben die Arbeit an der <code>getBy</code> Funktion jedoch noch nicht abgeschlossen.  Sie hat ein drittes Argument, dessen Art wir noch nicht festgelegt haben.  Das passt uns √ºberhaupt nicht.  Bisher konnten wir nicht im Voraus wissen, um welchen Typ es sich handeln sollte, da dies davon abh√§ngt, was wir als zweites Argument √ºbergeben.  Da wir nun Typ <code>P</code> , k√∂nnen wir den Typ f√ºr das dritte Argument dynamisch ableiten.  Der Typ des dritten Arguments ist letztendlich <code>T[P]</code> .  Wenn <code>T</code> <code>Student</code> und <code>P</code> <code>"age"</code> , hat <code>T[P]</code> die Typennummer. <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">function</span></span> getBy&lt;T, P extends keyof T&gt;(model: T[], prop: P, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: T[P]): T | <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> model.<span class="hljs-keyword"><span class="hljs-keyword">filter</span></span>(item =&gt; item[prop] === <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>)[<span class="hljs-number"><span class="hljs-number">0</span></span>] || <span class="hljs-keyword"><span class="hljs-keyword">null</span></span> } const result = getBy(students, "age", "17") // Error: Argument <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">'"17"'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> assignable <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parameter <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">'number'</span></span>. const anotherResult = getBy(students, "hasScar", "true") // Error: Argument <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">'"true"'</span></span> <span class="hljs-keyword"><span class="hljs-keyword">is</span></span> <span class="hljs-keyword"><span class="hljs-keyword">not</span></span> assignable <span class="hljs-keyword"><span class="hljs-keyword">to</span></span> parameter <span class="hljs-keyword"><span class="hljs-keyword">of</span></span> <span class="hljs-keyword"><span class="hljs-keyword">type</span></span> <span class="hljs-string"><span class="hljs-string">'boolean'</span></span>. const yetAnotherResult = getBy(students, "name", "Harry") //     </code> </pre> <br>  Ich hoffe, dass Sie jetzt ein absolut klares Verst√§ndnis f√ºr die Verwendung von Generika in TypeScript haben. Wenn Sie jedoch mit allem, was Sie mit dem hier beschriebenen Code experimentieren m√∂chten, sehr gut experimentieren m√∂chten, k√∂nnen Sie hier einen Blick darauf werfen. <br><br><h2>  <font color="#3AC1EF">Bestehende Typen erweitern</font> </h2><br>  Manchmal m√ºssen wir Daten oder Funktionen zu Schnittstellen hinzuf√ºgen, deren Code wir nicht √§ndern k√∂nnen.  M√∂glicherweise m√ºssen Sie das Standardobjekt √§ndern, z. B. dem <code>window</code> eine Eigenschaft hinzuf√ºgen oder das Verhalten einer externen Bibliothek wie <code>Express</code> .  In beiden F√§llen k√∂nnen Sie das Objekt, mit dem Sie arbeiten m√∂chten, nicht direkt beeinflussen. <br><br>  Wir werden eine L√∂sung f√ºr dieses Problem suchen, indem wir die bereits bekannte Funktion <code>getBy</code> zum <code>Array</code> Prototyp hinzuf√ºgen.  Auf diese Weise k√∂nnen wir mit dieser Funktion genauere syntaktische Konstruktionen erstellen.  Im Moment sprechen wir nicht dar√ºber, ob es gut oder schlecht ist, Standardobjekte zu erweitern, da unser Hauptziel darin besteht, den betrachteten Ansatz zu untersuchen. <br><br>  Wenn wir versuchen, dem <code>Array</code> Prototyp eine Funktion hinzuzuf√ºgen, wird dem Compiler dies nicht sehr gefallen: <br><br><pre> <code class="hljs powershell">Array.prototype.getBy = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> &lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">P</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extends</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyof</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(   this: T[],   prop: P,   value: T[P] )</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> | </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">null</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.filter(item =&gt; item[<span class="hljs-type"><span class="hljs-type">prop</span></span>] === value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] || null; }; // Error: Property <span class="hljs-string"><span class="hljs-string">'getBy'</span></span> does not exist on type <span class="hljs-string"><span class="hljs-string">'any[]'</span></span>. const bestie = students.getBy(<span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-string"><span class="hljs-string">"Ron"</span></span>); // Error: Property <span class="hljs-string"><span class="hljs-string">'getBy'</span></span> does not exist on type <span class="hljs-string"><span class="hljs-string">'Student[]'</span></span>. const potionsTeacher = (teachers as any).getBy(<span class="hljs-string"><span class="hljs-string">"subject"</span></span>, <span class="hljs-string"><span class="hljs-string">"Potions"</span></span>) //  ...   ?</code> </pre> <br>  Wenn wir versuchen, den Compiler zu beruhigen, indem wir das Konstrukt regelm√§√üig <code>as any</code> Konstrukt verwenden, werden wir alles, was wir erreicht haben, aufheben.  Der Compiler ist stumm, aber Sie k√∂nnen die sichere Arbeit mit Typen vergessen. <br><br>  Es w√§re besser, den <code>Array</code> Typ zu erweitern, aber bevor wir dies tun, wollen wir uns damit befassen, wie TypeScript Situationen behandelt, in denen zwei Schnittstellen desselben Typs im Code vorhanden sind.  Hier wird ein einfaches Aktionsschema angewendet.  Anzeigen werden nach M√∂glichkeit kombiniert.  Wenn Sie sie nicht kombinieren k√∂nnen, gibt das System einen Fehler aus. <br><br>  Dieser Code funktioniert also: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Wand</span></span> { length: number } <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Wand</span></span> {   core: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> myWand: Wand = { length: <span class="hljs-number"><span class="hljs-number">11</span></span>, core: <span class="hljs-string"><span class="hljs-string">"phoenix feather"</span></span> } <span class="hljs-comment"><span class="hljs-comment">//  !</span></span></code> </pre> <br>  Und dieser ist nicht: <br><br><pre> <code class="hljs cs"><span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Wand</span></span> { length: number } <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Wand</span></span> {   length: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span> } <span class="hljs-comment"><span class="hljs-comment">// Error: Subsequent property declarations must have the same type.  Property 'length' must be of type 'number', but here has type 'string'.</span></span></code> </pre> <br>  Nachdem wir uns damit befasst haben, sehen wir, dass wir vor einer ziemlich einfachen Aufgabe stehen.  Wir m√ºssen <code>getBy</code> die <code>Array&lt;T&gt;</code> -Schnittstelle deklarieren und die Funktion <code>getBy</code> hinzuf√ºgen. <br><br><pre> <code class="hljs powershell">interface Array&lt;T&gt; {  getBy&lt;P extends keyof T&gt;(prop: P, value: T[<span class="hljs-type"><span class="hljs-type">P</span></span>]): T | null; } Array.prototype.getBy = <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> &lt;</span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">, </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">P</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">extends</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">keyof</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function">&gt;</span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(   this: T[],   prop: P,   value: T[P] )</span></span></span><span class="hljs-function">: </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">T</span></span></span><span class="hljs-function"> | </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">null</span></span></span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> this.filter(item =&gt; item[<span class="hljs-type"><span class="hljs-type">prop</span></span>] === value)[<span class="hljs-number"><span class="hljs-number">0</span></span>] || null; }; const bestie = students.getBy(<span class="hljs-string"><span class="hljs-string">"name"</span></span>, <span class="hljs-string"><span class="hljs-string">"Ron"</span></span>); //   ! const potionsTeacher = (teachers as any).getBy(<span class="hljs-string"><span class="hljs-string">"subject"</span></span>, <span class="hljs-string"><span class="hljs-string">"Potions"</span></span>) //    </code> </pre> <br>  Beachten Sie, dass der gr√∂√üte Teil des Codes, den Sie wahrscheinlich in Moduldateien schreiben, erforderlich ist. Um √Ñnderungen an der <code>Array</code> Schnittstelle vorzunehmen, ben√∂tigen Sie Zugriff auf den globalen Bereich.  Sie k√∂nnen dies tun, indem Sie die Typdefinition in <code>declare global</code> .  Zum Beispiel so: <br><br><pre> <code class="hljs pgsql"><span class="hljs-keyword"><span class="hljs-keyword">declare</span></span> <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> {   interface <span class="hljs-keyword"><span class="hljs-keyword">Array</span></span>&lt;T&gt; {       getBy&lt;P extends keyof T&gt;(prop: P, <span class="hljs-keyword"><span class="hljs-keyword">value</span></span>: T[P]): T | <span class="hljs-keyword"><span class="hljs-keyword">null</span></span>;   } }</code> </pre> <br>  Wenn Sie die Schnittstelle einer externen Bibliothek erweitern m√∂chten, ben√∂tigen Sie h√∂chstwahrscheinlich Zugriff auf den <code>namespace</code> dieser Bibliothek.  Hier ist ein Beispiel f√ºr das Hinzuf√ºgen des <code>userId</code> zu <code>Request</code> aus der <code>Express</code> Bibliothek: <br><br><pre> <code class="hljs cs">declare <span class="hljs-keyword"><span class="hljs-keyword">global</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">namespace</span></span> <span class="hljs-title"><span class="hljs-title">Express</span></span> {   <span class="hljs-keyword"><span class="hljs-keyword">interface</span></span> <span class="hljs-title"><span class="hljs-title">Request</span></span> {     userId: <span class="hljs-keyword"><span class="hljs-keyword">string</span></span>;   } } }</code> </pre> <br>  Sie k√∂nnen hier mit dem Code in diesem Abschnitt experimentieren. <br><br><h2>  <font color="#3AC1EF">Zusammenfassung</font> </h2><br>  In diesem Artikel haben wir uns mit Techniken zur Verwendung von Generika und Typerweiterungen in TypeScript befasst.  Wir hoffen, dass das, was Sie heute gelernt haben, Ihnen hilft, zuverl√§ssigen, verst√§ndlichen und typsicheren Code zu schreiben. <br><br>  <b>Liebe Leser!</b>  Wie stehen Sie zu einem Typ in TypeScript? <br><br> <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="><img src="https://habrastorage.org/files/1ba/550/d25/1ba550d25e8846ce8805de564da6aa63.png"></a> </div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de426729/">https://habr.com/ru/post/de426729/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de426719/index.html">Hackathon √ºber Data Science in SIBUR: wie es war</a></li>
<li><a href="../de426721/index.html">Vermeiden von Fehlern w√§hrend der Produktentwicklung: 10 Tipps von Rookee</a></li>
<li><a href="../de426723/index.html">Microsoft und Partner hoffen, eine Zeitkapsel auf dem Mond zu schaffen</a></li>
<li><a href="../de426725/index.html">Wie man Dinge macht, wenn man keine Lust dazu hat</a></li>
<li><a href="../de426727/index.html">EME? Cdm? DRM? CENC? IDK! Was Sie brauchen, um Ihren eigenen Video-Player in einem Browser zu erstellen</a></li>
<li><a href="../de426731/index.html">CSS: interessante Merkmale des Randradius</a></li>
<li><a href="../de426733/index.html">Eisen wird nicht versagen. Wie ich Dutzende von Servern pro Tag f√ºr den Kampf vorbereite</a></li>
<li><a href="../de426735/index.html">Willkommen beim JETHACK Hackathon</a></li>
<li><a href="../de426737/index.html">Kurz √ºber die Architektur neuromorpher Prozessoren: ein Einblick</a></li>
<li><a href="../de426739/index.html">Proxy-Dateien von AWS S3 mit nginx</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>