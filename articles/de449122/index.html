<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>📧 ✝️ 🌘 Bedauern, dass in C ++ keine vollwertige statische Aufladung vorhanden ist, wenn oder ... 🤱🏽 🖇️ 🈹</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="... wie man eine Vorlagenklasse mit unterschiedlichen Inhalten füllt, abhängig von den Werten der Vorlagenparameter? 


 Es war einmal, seit einiger Z...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Bedauern, dass in C ++ keine vollwertige statische Aufladung vorhanden ist, wenn oder ...</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/449122/"><p> <strong>... wie man eine Vorlagenklasse mit unterschiedlichen Inhalten füllt, abhängig von den Werten der Vorlagenparameter?</strong> </p><br><p> Es war einmal, seit einiger Zeit wurde die D-Sprache unter Berücksichtigung der in C ++ gesammelten Erfahrungen als "das richtige C ++" bezeichnet.  Im Laufe der Zeit ist D nicht weniger komplex und ausdrucksstärker geworden als C ++.  Und bereits begann C ++, D auszuspionieren. Zum Beispiel erschien es in C ++ 17, <code>if constexpr</code> meiner Meinung nach eine direkte Entlehnung von D ist, dessen Prototyp <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">D-shny static if war</a> . </p><br><p>  Leider hat <code>if constexpr</code> in C ++ nicht die gleiche Leistung wie <code>static if</code> in D. Es gibt <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">Gründe dafür</a> , aber es gibt immer noch Fälle, in denen Sie nur bedauern können, dass <code>if constexpr</code> in C ++ es Ihnen nicht erlaubt, den Inhalt von C + zu steuern + Klasse.  Ich möchte über einen dieser Fälle sprechen. </p><br><p>  Wir werden darüber sprechen, wie eine Vorlagenklasse erstellt wird, deren Inhalt (d. H. Die Zusammensetzung der Methoden und die Logik einiger Methoden) sich abhängig davon ändert, welche Parameter an diese Vorlagenklasse übergeben wurden.  Ein Beispiel stammt aus dem wirklichen Leben, aus der Erfahrung mit der Entwicklung einer <a href="">neuen Version von SObjectizer</a> . </p><br><h1 id="zadacha-kotoruyu-trebuetsya-reshit">  Die zu lösende Aufgabe </h1><br><p>  Es ist erforderlich, eine clevere Version des "intelligenten Zeigers" zum Speichern von Nachrichtenobjekten zu erstellen.  Damit Sie etwas schreiben können wie: </p><a name="habracut"></a><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>&lt;my_message&gt; msg{ <span class="hljs-keyword"><span class="hljs-keyword">new</span></span> my_message{...} }; send(target, msg); send(another_target, msg);</code> </pre> <br><p>  Der Trick dieser <code>message_holder_t</code> Klasse besteht darin, dass drei wichtige Faktoren zu berücksichtigen sind. </p><br><h2 id="ot-chego-otnasledovan-tip-soobscheniya">  Von welcher Art von Nachricht wurde geerbt? </h2><br><p>  Die Nachrichtentypen, die <code>message_holder_t</code> parametrisieren, sind in zwei Gruppen unterteilt.  Die erste Gruppe sind Nachrichten, die vom speziellen Basistyp <code>message_t</code> erben.  Zum Beispiel: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">so5_message</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> b_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds c_; so5_message(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> b, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds c) : a_{a}, b_{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(b)}, c_{c} {} };</code> </pre> <br><p>  In diesem Fall sollte message_holder_t in sich nur einen Zeiger auf ein Objekt dieses Typs enthalten.  Der gleiche Zeiger sollte in Getter-Methoden zurückgegeben werden.  Das heißt, für den Erben von <code>message_t</code> sollte es so etwas wie <code>message_t</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">message_holder_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt;M&gt; m_msg; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> M * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_msg.get(); } };</code> </pre> <br><p>  Die zweite Gruppe sind Nachrichten beliebiger Benutzertypen, die nicht von <code>message_t</code> geerbt <code>message_t</code> .  Zum Beispiel: </p><br><pre> <code class="cpp hljs"><span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">user_message</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">final</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> b_; <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds c_; user_message(<span class="hljs-keyword"><span class="hljs-keyword">int</span></span> a, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">string</span></span> b, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::chrono::milliseconds c) : a_{a}, b_{<span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(b)}, c_{c} {} };</code> </pre> <br><p>  Instanzen dieser Typen in SObjectizer werden nicht von sich aus gesendet, sondern sind in einem speziellen Wrapper eingeschlossen, <code>user_type_message_t&lt;M&gt;</code> , der bereits von <code>message_t</code> geerbt wurde.  Daher muss <code>message_holder_t</code> für solche Typen einen Zeiger auf <code>user_type_message_t&lt;M&gt;</code> enthalten, und Getter-Methoden müssen einen Zeiger auf M zurückgeben: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M&gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">message_holder_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">user_type_message_t</span></span>&lt;M&gt;&gt; m_msg; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span>: ... <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> M * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::addressof(m_msg-&gt;m_payload); } };</code> </pre> <br><h2 id="immutabelnost-ili-mutabelnost-soobscheniy">  Immunität oder Veränderlichkeit von Nachrichten </h2><br><p>  Der zweite Faktor ist die Aufteilung von Nachrichten in unveränderliche und veränderbare.  Wenn die Nachricht unveränderlich ist (und standardmäßig unveränderlich ist), müssen Getter-Methoden einen konstanten Zeiger auf die Nachricht zurückgeben.  Und wenn veränderlich, müssen Getter einen nicht konstanten Zeiger zurückgeben.  Das heißt,  sollte so etwas sein wie: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>&lt;so5_message&gt; msg1{...}; <span class="hljs-comment"><span class="hljs-comment">//  . const int a = msg1-&gt;a_; // OK. msg1-&gt;a_ = 0; //     ! message_holder_t&lt;mutable_msg&lt;user_message&gt;&gt; msg2{...}; //  . const int a = msg2-&gt;a_; // OK. msg2-&gt;a_ = 0; // OK.</span></span></code> </pre> <br><h2 id="shared_ptr-vs-unique_ptr">  shared_ptr vs unique_ptr </h2><br><p>  Der dritte Faktor ist die Logik des Verhaltens von <code>message_holder_t</code> als intelligenter Zeiger.  Sobald es sich wie <code>std::shared_ptr</code> verhalten sollte, d.h.  Sie können mehrere Nachrichteninhaber haben, die auf dieselbe Nachrichteninstanz verweisen.  Und sobald es sich wie <code>std::unique_ptr</code> verhalten sollte, d.h.  Nur eine message_holder-Instanz kann auf eine Nachrichteninstanz verweisen. </p><br><p>  Standardmäßig sollte das Verhalten von <code>message_holder_t</code> von der Veränderbarkeit / Unveränderlichkeit der Nachricht abhängen.  Das heißt,  Bei unveränderlichen Nachrichten sollte sich <code>message_holder_t</code> wie <code>std::shared_ptr</code> verhalten, und bei veränderlichen <code>std::unique_ptr</code> wie <code>std::unique_ptr</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>&lt;so5_message&gt; msg1{...}; <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>&lt;so5_message&gt; msg2 = msg; <span class="hljs-comment"><span class="hljs-comment">// OK. message_holder_t&lt;mutable_msg&lt;user_message&gt;&gt; msg3{...}; message_holder_t&lt;mutable_msg&lt;user_message&gt;&gt; msg4 = msg3; // !  ! message_holder_t&lt;mutable_msg&lt;user_message&gt;&gt; msg5 = std::move(msg3); // OK.</span></span></code> </pre> <br><p>  Das Leben ist jedoch eine komplizierte Sache, daher müssen Sie auch in der Lage sein, das Verhalten von <code>message_holder_t</code> manuell <code>message_holder_t</code> .  Damit können Sie message_holder für eine unveränderliche Nachricht erstellen, die sich wie unique_ptr verhält.  Und damit Sie message_holder für eine veränderbare Nachricht erstellen können, die sich wie shared_ptr verhält: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> unique_so5_message = so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>&lt; so5_message, so_5::<span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::unique&gt;; unique_so5_message msg1{...}; unique_so5_message msg2 = msg1; <span class="hljs-comment"><span class="hljs-comment">// !  ! unique_so5_message msg3 = std::move(msg); // OK,   msg3. using shared_user_messsage = so_5::message_holder_t&lt; so_5::mutable_msg&lt;user_message&gt;, so_5::message_ownership_t::shared&gt;; shared_user_message msg4{...}; shared_user_message msg5 = msg4; // OK.</span></span></code> </pre> <br><p>  Wenn <code>message_holder_t</code> wie shared_ptr funktioniert, sollte es <code>message_holder_t</code> die üblichen Konstruktoren und Zuweisungsoperatoren enthalten: sowohl Kopieren als auch Verschieben.  Außerdem muss es eine konstante Methode <code>make_reference</code> , die eine Kopie des in <code>message_holder_t</code> gespeicherten Zeigers <code>message_holder_t</code> . </p><br><p>  Wenn <code>message_holder_t</code> wie unique_ptr funktioniert, sollten der Konstruktor und der <code>message_holder_t</code> dafür <code>message_holder_t</code> werden.  Und die Methode <code>make_reference</code> sollte <em>den</em> Zeiger vom Objekt <code>message_holder_t</code> : Nach dem Aufruf von <code>make_reference</code> ursprüngliche <code>message_holder_t</code> leer bleiben. </p><br><h2 id="chut-bolee-formalno">  Ein bisschen formeller </h2><br><p>  Sie müssen also eine Vorlagenklasse erstellen: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M, <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span> Ownership = <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::autodetected&gt; class <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> {...};</code> </pre> <br><p>  welche: </p><br><ul><li>  innen sollte <code>intrusive_ptr_t&lt;M&gt;</code> oder <code>intrusive_ptr&lt;user_type_message_t&lt;M&gt;&gt;</code> gespeichert werden, je nachdem, ob M von <code>message_t</code> geerbt <code>message_t</code> ; </li><li>  Getter-Methoden müssen je nach Veränderbarkeit / Unveränderlichkeit der Nachricht entweder <code>const M*</code> oder <code>M*</code> . </li><li>  Es sollte entweder einen vollständigen Satz von Konstruktoren und Kopier- / Verschiebungsoperatoren oder nur einen Konstruktor- und Verschiebungsoperator geben. </li><li>  Die Methode <code>make_reference()</code> sollte entweder eine Kopie des gespeicherten intrusive_ptr zurückgeben oder den Wert von intrusive_ptr <code>message_holder_t</code> und den ursprünglichen <code>message_holder_t</code> leer lassen.  Im ersten Fall muss <code>make_reference()</code> konstant sein, im zweiten Fall - nicht konstant. </li></ul><br><p>  Die letzten beiden Elemente aus der Liste werden durch den Eigentümerparameter bestimmt (sowie durch die Veränderbarkeit der Nachricht, wenn <code>autodetected</code> für die Eigentümerschaft verwendet wird). </p><br><h1 id="kak-eto-bylo-resheno">  Wie es entschieden wurde </h1><br><p>  In diesem Abschnitt werden alle Komponenten betrachtet, aus denen die endgültige Lösung besteht.  Nun, die resultierende Lösung selbst.  Die Codefragmente, die von allen störenden Details befreit sind, werden angezeigt.  Wenn sich jemand für den echten Code interessiert, können Sie ihn <a href="">hier sehen</a> . </p><br><h2 id="disclaimer">  Haftungsausschluss </h2><br><p>  Die unten gezeigte Lösung gibt nicht vor, schön, ideal oder ein Vorbild zu sein.  Es wurde in kurzer Zeit unter Termindruck gefunden, implementiert, getestet und dokumentiert.  Vielleicht, wenn es mehr Zeit gab und mehr nach einer Lösung suchte <del>  jung </del>  Sinnvoll und kenntnisreich in modernen C ++ - Entwicklern, würde es sich als kompakter, einfacher und verständlicher herausstellen.  Aber wie sich herausstellte, passierte es im Allgemeinen ... "Erschieß den Pianisten nicht". </p><br><h2 id="posledovatelnost-shagov-i-uzhe-gotovaya-shablonnaya-magiya">  Abfolge von Schritten und vorgefertigte Vorlagenmagie </h2><br><p>  Wir brauchen also eine Klasse mit mehreren Methoden.  Der Inhalt dieser Kits muss von irgendwoher kommen.  Woher? </p><br><p>  In D könnten wir <code>static if</code> und abhängig von verschiedenen Bedingungen verschiedene Teile der Klasse definieren.  In einigen Ruby-Versionen können wir <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">mithilfe der include-Methode Methoden in unsere Klasse mischen</a> .  Wir befinden uns jedoch in C ++, wo unsere Möglichkeiten bisher sehr begrenzt sind: Wir können entweder eine Methode / ein Attribut direkt in der Klasse definieren oder die Methode / das Attribut von einer Basisklasse erben. </p><br><p>  Wir können abhängig von einer bestimmten Bedingung keine unterschiedlichen Methoden / Attribute innerhalb der Klasse definieren, weil  C ++ <code>if constexpr</code> kein D <code>static if</code> .  Folglich bleibt nur die Vererbung übrig. </p><br><blockquote>  <strong>Upd.</strong>  Wie in den Kommentaren vorgeschlagen, sollte ich hier genauer sprechen.  Da C ++ über SFINAE verfügt, können wir die Sichtbarkeit einzelner Methoden in der Klasse über SFINAE aktivieren / deaktivieren (d. H. Einen Effekt erzielen, der dem <code>static if</code> ähnelt).  Dieser Ansatz weist meiner Meinung nach zwei schwerwiegende Mängel auf.  Erstens, wenn solche Methoden nicht 1-2-3, sondern 4-5 oder mehr sind, ist es mühsam, jede mit SFINAE zu formatieren, was die Lesbarkeit des Codes beeinträchtigt.  Zweitens hilft uns SFINAE nicht beim Hinzufügen / Entfernen von Klassenattributen (Feldern). </blockquote><p>  In C ++ können wir mehrere Basisklassen definieren, von denen wir dann <code>message_holder_t</code> erben.  Die Auswahl der einen oder anderen Basisklasse erfolgt bereits in Abhängigkeit von den Werten der Vorlagenparameter unter Verwendung von <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u=">std :: conditional</a> . </p><br><p>  Der Trick ist jedoch, dass wir nicht nur eine Reihe von Basisklassen benötigen, sondern eine kleine Vererbungskette.  Zu Beginn wird es eine Klasse geben, die die allgemeine Funktionalität bestimmt, die in jedem Fall erforderlich ist.  Als nächstes folgen die Basisklassen, die die Logik des Verhaltens des "intelligenten Zeigers" bestimmen.  Und dann wird es eine Klasse geben, die die notwendigen Getter bestimmt.  In dieser Reihenfolge betrachten wir die implementierten Klassen. </p><br><p>  Unsere Aufgabe wird durch die Tatsache vereinfacht, dass SObjectizer bereits über eine vorgefertigte Vorlagenmagie verfügt <a href="">, die bestimmt, ob eine Nachricht von message_t geerbt wird</a> , sowie über <a href="">Mittel zum Überprüfen der Nachrichtenveränderlichkeit</a> .  Daher werden wir bei der Implementierung einfach diese vorgefertigte Magie verwenden und nicht auf die Details ihrer Arbeit eingehen. </p><br><h2 id="obschaya-baza-dlya-hraneniya-ukazatelya">  Gemeinsame Zeigerspeicherbasis </h2><br><p>  Beginnen wir mit einem gemeinsamen Basistyp, der den entsprechenden intrusive_ptr speichert und außerdem einen allgemeinen Satz von Methoden bereitstellt, die für jede der Implementierungen von <code>message_holder_t</code> erforderlich sind: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Payload, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Envelope &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">basic_message_holder_impl_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">protected</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt; Envelope &gt; m_msg; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> payload_type = Payload; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> envelope_type = Envelope; <span class="hljs-keyword"><span class="hljs-keyword">basic_message_holder_impl_t</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">basic_message_holder_impl_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt; Envelope &gt; msg ) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : m_msg{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(msg) } {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">reset</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ m_msg.reset(); } [[nodiscard]] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">bool</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">empty</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_cast</span></span>&lt;<span class="hljs-keyword"><span class="hljs-keyword">bool</span></span>&gt;( m_msg ); } [[nodiscard]] <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">operator</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">bool</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> !<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;empty(); } [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">bool</span></span> <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>!() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;empty(); } };</code> </pre> <br><p>  Diese Vorlagenklasse hat zwei Parameter.  Die erste, Payload, legt den Typ fest, den Getter-Methoden verwenden sollen.  Während der zweite, Envelope, den Typ für intrusive_ptr festlegt.  Wenn der Nachrichtentyp von <code>message_t</code> geerbt <code>message_t</code> beide Parameter denselben Wert.  Wenn die Nachricht jedoch nicht von <code>message_t</code> geerbt <code>message_t</code> , wird der Nachrichtentyp als Payload und <code>user_type_message_t&lt;Payload&gt;</code> als Envelope verwendet. </p><br><p>  Ich denke, dass der Inhalt dieser Klasse im Grunde keine Fragen aufwirft.  Zwei Dinge sollten jedoch getrennt beachtet werden. </p><br><p>  Erstens ist der Zeiger selbst, d.h.  Das Attribut m_msg wird im geschützten Abschnitt definiert, damit die Klassenvererben Zugriff darauf haben. </p><br><p>  Zweitens generiert der Compiler für diese Klasse selbst alle erforderlichen Konstruktoren und Kopier- / Verschiebungsoperatoren.  Und auf der Ebene dieser Klasse verbieten wir noch nichts. </p><br><h2 id="otdelnye-bazy-dlya-shared_ptr--i-unique_ptr-povedeniya">  Separate Basen für das Verhalten von shared_ptr und unique_ptr </h2><br><p>  Wir haben also eine Klasse, die einen Zeiger auf eine Nachricht speichert.  Jetzt können wir seine Erben definieren, die sich entweder als shared_ptr oder als unique_ptr verhalten. </p><br><p>  Beginnen wir mit dem Fall des Verhaltens von shared_ptr, weil  Hier ist der kleinste Code: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Payload, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Envelope &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">shared_message_holder_impl_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">basic_message_holder_impl_t</span></span>&lt;Payload, Envelope&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> direct_base_type = <span class="hljs-keyword"><span class="hljs-keyword">basic_message_holder_impl_t</span></span>&lt;Payload, Envelope&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> direct_base_type::direct_base_type; [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt; Envelope &gt; make_reference() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;m_msg; } };</code> </pre> <br><p>  Nichts Kompliziertes: Erben Sie von <code>basic_message_holder_impl_t</code> , erben Sie alle Konstruktoren und definieren Sie eine einfache, zerstörungsfreie Implementierung von <code>make_reference()</code> . </p><br><p>  Für den Fall von unique_ptr-Verhalten ist der Code größer, obwohl nichts Kompliziertes darin ist: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Payload, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Envelope &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">unique_message_holder_impl_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> <span class="hljs-keyword"><span class="hljs-keyword">basic_message_holder_impl_t</span></span>&lt;Payload, Envelope&gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> direct_base_type = <span class="hljs-keyword"><span class="hljs-keyword">basic_message_holder_impl_t</span></span>&lt;Payload, Envelope&gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> direct_base_type::direct_base_type; <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span> &amp; ) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span> &amp;&amp; ) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span> &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span> &amp; ) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span> &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=( <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span> &amp;&amp; ) = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt; Envelope &gt; make_reference() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(<span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;m_msg) }; } };</code> </pre> <br><p>  Wieder erben wir von <code>basic_message_holder_impl_t</code> und erben die Konstruktoren, die wir benötigen (dies ist der Standardkonstruktor und der initialisierende Konstruktor).  Gleichzeitig definieren wir die Konstruktoren und Kopier- / Verschiebungsoperatoren gemäß der Logik unique_ptr: Wir verbieten das Kopieren, wir implementieren die Verschiebung. </p><br><p>  Wir haben hier auch eine destruktive <code>make_reference()</code> -Methode. </p><br><p>  Das ist eigentlich alles.  Es bleibt nur die Wahl zwischen diesen beiden Basisklassen zu realisieren ... </p><br><h3 id="vybor-mezhdu-shared_ptr--i-unique_ptr-povedeniem">  Wählen Sie zwischen shared_ptr und unique_ptr </h3><br><p>  Um zwischen dem Verhalten von shared_ptr und unique_ptr zu wählen, benötigen Sie die folgende Metafunktion (Metafunktion, da sie mit Typen in der Kompilierungszeit "funktioniert"): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Msg, <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span> Ownership &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">impl_selector</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">static_assert</span></span>( !is_signal&lt;Msg&gt;::value, <span class="hljs-string"><span class="hljs-string">"Signals can't be used with message_holder"</span></span> ); <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> P = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> message_payload_type&lt; Msg &gt;::payload_type; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> E = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> message_payload_type&lt; Msg &gt;::envelope_type; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">conditional_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::autodetected == Ownership, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">conditional_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">message_mutability_t</span></span>::immutable_message == message_mutability_traits&lt;Msg&gt;::mutability, <span class="hljs-keyword"><span class="hljs-keyword">shared_message_holder_impl_t</span></span>&lt;P, E&gt;, <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span>&lt;P, E&gt; &gt;, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">conditional_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::shared == Ownership, <span class="hljs-keyword"><span class="hljs-keyword">shared_message_holder_impl_t</span></span>&lt;P, E&gt;, <span class="hljs-keyword"><span class="hljs-keyword">unique_message_holder_impl_t</span></span>&lt;P, E&gt; &gt; &gt;; };</code> </pre> <br><p>  Diese Metafunktion akzeptiert beide Parameter aus der Parameterliste <code>message_holder_t</code> und gibt als Ergebnis ( <code>message_holder_t</code> die Definition eines verschachtelten <code>type</code> ) den Typ zurück, von dem er geerbt werden soll.  Das heißt,  entweder <code>shared_message_holder_impl_t</code> oder <code>unique_message_holder_impl_t</code> . </p><br><p>  In der Definition von <code>impl_selector</code> Sie Spuren der oben erwähnten Magie, auf die wir nicht <code>message_payload_type&lt;Msg&gt;::payload_type</code> : <code>message_payload_type&lt;Msg&gt;::payload_type</code> , <code>message_payload_type&lt;Msg&gt;::envelope_type</code> und <code>message_mutability_traits&lt;Msg&gt;::mutability</code> . </p><br><p>  Und um die <code>impl_selector</code> einfacher nutzen zu können, definieren wir einen kürzeren Namen dafür: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Msg, <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span> Ownership &gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">impl_selector_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> impl_selector&lt;Msg, Ownership&gt;::type;</code> </pre> <br><h2 id="baza-dlya-getter-ov">  Basis für Getter </h2><br><p>  Wir haben also bereits die Möglichkeit, eine Basis auszuwählen, die einen Zeiger enthält und das Verhalten eines "intelligenten Zeigers" definiert.  Jetzt müssen wir diese Basis mit Getter-Methoden versehen.  Warum brauchen wir eine einfache Klasse: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Return_Type &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">msg_accessors_t</span></span></span><span class="hljs-class"> :</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> Base { <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> Base::Base; [[nodiscard]] <span class="hljs-function"><span class="hljs-function">Return_Type * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get_ptr( <span class="hljs-keyword"><span class="hljs-keyword">this</span></span>-&gt;m_msg ); } [[nodiscard]] Return_Type &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> * () <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *get(); } [[nodiscard]] Return_Type * <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-&gt;() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get(); } };</code> </pre> <br><p>  Dies ist eine Vorlagenklasse, die von zwei Parametern abhängt, deren Bedeutung jedoch völlig unterschiedlich ist.  Der Basisparameter ist das Ergebnis der oben gezeigten <code>impl_selector</code> impl_selector.  Das heißt,  Als Basisparameter wird die Basisklasse festgelegt, von der geerbt werden soll. </p><br><p>  Es ist wichtig zu beachten, dass der Compiler den Konstruktor und den <code>msg_accessors_t</code> für <code>msg_accessors_t</code> nicht generieren kann, wenn die Vererbung von <code>unique_message_holder_impl_t</code> stammt, für die der Konstruktor und der <code>unique_message_holder_impl_t</code> verboten sind.  Welches ist was wir brauchen. </p><br><p>  Der Typ der Nachricht, dessen Zeiger / Link von Gettern zurückgegeben wird, fungiert als Return_Type-Parameter.  Der Trick besteht darin, dass für eine unveränderliche Nachricht vom Typ <code>Msg</code> der Parameter Return_Type auf <code>const Msg</code> .  Während für eine veränderbare Nachricht vom Typ <code>Msg</code> Parameter Return_Type den Wert <code>Msg</code> .  Daher gibt die Methode <code>get()</code> <code>const Msg*</code> für unveränderliche Nachrichten und nur <code>Msg*</code> für veränderbare Nachrichten zurück. </p><br><p>  Mit der kostenlosen Funktion <code>get_ptr()</code> lösen <code>get_ptr()</code> das Problem der Arbeit mit Nachrichten, die nicht von <code>message_t</code> geerbt <code>message_t</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M &gt; <span class="hljs-function"><span class="hljs-function">M * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_ptr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">intrusive_ptr_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;M&gt; &amp; msg )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> msg.get(); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M &gt; <span class="hljs-function"><span class="hljs-function">M * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get_ptr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">intrusive_ptr_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt; </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">user_type_message_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">&lt;M&gt; &gt; &amp; msg )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::addressof(msg-&gt;m_payload); }</code> </pre> <br><p>  Das heißt,  Wenn die Nachricht nicht von <code>message_t</code> geerbt und als <code>user_type_message_t&lt;Msg&gt;</code> gespeichert wird, wird die zweite Überladung aufgerufen.  Und wenn es vererbt wird, dann die erste Überlastung. </p><br><h3 id="vybor-konkretnoy-bazy-dlya-getter-ov">  Auswahl einer bestimmten Basis für Getter </h3><br><p>  <code>msg_accessors_t</code> Vorlage <code>msg_accessors_t</code> erfordert also zwei Parameter.  Die erste wird durch die <code>impl_selector</code> impl_selector berechnet.  Um jedoch aus <code>msg_accessors_t</code> einen bestimmten Basistyp zu bilden, müssen wir den Wert des zweiten Parameters bestimmen.  Eine weitere Metafunktion ist dafür vorgesehen: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">message_mutability_t</span></span> Mutability, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">accessor_selector</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">conditional_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">message_mutability_t</span></span>::immutable_message == Mutability, <span class="hljs-keyword"><span class="hljs-keyword">msg_accessors_t</span></span>&lt;Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base::payload_type <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>&gt;, <span class="hljs-keyword"><span class="hljs-keyword">msg_accessors_t</span></span>&lt;Base, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base::payload_type&gt; &gt;; };</code> </pre> <br><p>  Sie können nur auf die Berechnung des Return_Type-Parameters achten.  Einer dieser wenigen Fälle, in denen East Const nützlich ist;) </p><br><p>  Um die Lesbarkeit des folgenden Codes zu verbessern, sollten Sie eine kompaktere Option für die Arbeit damit verwenden: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">message_mutability_t</span></span> Mutability, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Base &gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">accessor_selector_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> accessor_selector&lt;Mutability, Base&gt;::type;</code> </pre> <br><h2 id="itogovyy-naslednik-message_holder_t">  Letzter Nachfolger message_holder_t </h2><br><p>  Jetzt können Sie sich ansehen, was <code>message_holder_t</code> , für dessen Implementierung alle diese Basisklassen und Metafunktionen erforderlich waren (ein Teil der Methoden zum Erstellen einer Instanz der in message_holder gespeicherten Nachricht wird aus der Implementierung entfernt): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Msg, <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span> Ownership = <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::autodetected &gt; class <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> details::message_holder_details::<span class="hljs-keyword"><span class="hljs-keyword">accessor_selector_t</span></span>&lt; details::message_mutability_traits&lt;Msg&gt;::mutability, details::message_holder_details::<span class="hljs-keyword"><span class="hljs-keyword">impl_selector_t</span></span>&lt;Msg, Ownership&gt; &gt; { <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> base_type = details::message_holder_details::<span class="hljs-keyword"><span class="hljs-keyword">accessor_selector_t</span></span>&lt; details::message_mutability_traits&lt;Msg&gt;::mutability, details::message_holder_details::<span class="hljs-keyword"><span class="hljs-keyword">impl_selector_t</span></span>&lt;Msg, Ownership&gt; &gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> payload_type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> base_type::payload_type; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> envelope_type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> base_type::envelope_type; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> base_type::base_type; <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">friend</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">message_holder_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">message_holder_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; b )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap; swap( a.message_reference(), b.message_reference() ); } };</code> </pre> <br><p>  Tatsächlich war alles, was wir oben analysiert haben, erforderlich, um diesen „Aufruf“ von zwei Metafunktionen aufzuzeichnen: </p><br><pre> <code class="cpp hljs">details::message_holder_details::<span class="hljs-keyword"><span class="hljs-keyword">accessor_selector_t</span></span>&lt; details::message_mutability_traits&lt;Msg&gt;::mutability, details::message_holder_details::<span class="hljs-keyword"><span class="hljs-keyword">impl_selector_t</span></span>&lt;Msg, Ownership&gt; &gt;</code> </pre> <br><p>  Weil  Dies ist nicht die erste Option, aber das Ergebnis der Vereinfachung und Reduzierung des Codes kann ich sagen, dass kompakte Formen von Metafunktionen die Menge des Codes stark reduzieren und seine Verständlichkeit erhöhen (wenn es allgemein angebracht ist, hier über Verständlichkeit zu sprechen). </p><br><h1 id="a-chto-bylo-by-esli-by">  Und was würde passieren, wenn ... </h1><br><p>  Aber wenn in C ++ <code>if constexpr</code> so mächtig war wie <code>static if</code> in D, dann könnten Sie etwas schreiben wie: </p><br><div class="spoiler">  <b class="spoiler_title">Hypothetische Version mit fortgeschrittener wenn constexpr</b> <div class="spoiler_text"><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Msg, <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span> Ownership = <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::autodetected &gt; class <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">message_mutability_t</span></span> Mutability = details::message_mutability_traits&lt;Msg&gt;::mutability; <span class="hljs-keyword"><span class="hljs-keyword">static</span></span> <span class="hljs-keyword"><span class="hljs-keyword">constexpr</span></span> <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span> Actual_Ownership = (<span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::unique == Ownership || (<span class="hljs-keyword"><span class="hljs-keyword">message_mutability_t</span></span>::mutable_msg == Mutability &amp;&amp; <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::autodetected == Ownership)) ? <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::unique : <span class="hljs-keyword"><span class="hljs-keyword">message_ownership_t</span></span>::shared; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> payload_type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> message_payload_type&lt; Msg &gt;::payload_type; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> envelope_type = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> message_payload_type&lt; Msg &gt;::envelope_type; <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> getter_return_type = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-keyword"><span class="hljs-keyword">conditional_t</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">message_mutability_t</span></span>::immutable_msg == Mutability, payload_type <span class="hljs-keyword"><span class="hljs-keyword">const</span></span>, payload_type &gt;; <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt; envelope_type &gt; mf ) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> : m_msg{ <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(mf) } {} <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">message_ownership_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">::unique == Actual_Ownership )</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> &amp; ) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> &amp;&amp; ) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> &amp; ) = <span class="hljs-keyword"><span class="hljs-keyword">delete</span></span>; <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>=( <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span> &amp;&amp; ) <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">default</span></span>; } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">friend</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">swap</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">message_holder_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; a, </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">message_holder_t</span></span></span></span><span class="hljs-function"><span class="hljs-params"> &amp; b )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::swap; swap( a.m_msg, b.m_msg ); } [[nodiscard]] <span class="hljs-function"><span class="hljs-function">getter_return_type * </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">get</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">noexcept</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get_const_ptr( m_msg ); } [[nodiscard]] getter_return_type &amp; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span> * () <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> *get(); } [[nodiscard]] getter_return_type * <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>-&gt;() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> get(); } <span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">if</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">constexpr</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">message_ownership_t</span></span></span></span><span class="hljs-function"><span class="hljs-params">::shared == Actual_Ownership)</span></span></span><span class="hljs-function"> </span></span>{ [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt; envelope_type &gt; make_reference() <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_msg; } } <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> { [[nodiscard]] <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt; envelope_type &gt; make_reference() <span class="hljs-keyword"><span class="hljs-keyword">noexcept</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(m_msg) }; } } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">intrusive_ptr_t</span></span>&lt; envelope_type &gt; m_msg; };</code> </pre> </div></div><br><p>   ,     .       C++ :( <br> (  C++      ""   <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=de&amp;u="></a> ). </p><br><p>  ,       ,             ++.   ,  ,  ,           .   ,        <code>message_holder_t</code> .         ,             ,      <code>if constexpr</code> . </p><br><h1 id="zaklyuchenie">  Fazit </h1><br><p>   ,         C++. ,     .  ,    ,          . </p><br><p>                ,           . </p><br><p>   ,   ,   ++   ,   .      ,    . , ,            .  ,    .   C++98/03        ,     C++11       . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/de449122/">https://habr.com/ru/post/de449122/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../de449110/index.html">Es wurde ein Fehler behoben, der mit der Unfähigkeit zusammenhängt, das kyrillische Alphabet in den Namen von IMAP-Ordnern zu verwenden</a></li>
<li><a href="../de449112/index.html">Wir haben uns zurückgezogen - wir diskutieren über einst beliebte Audio-Gadgets, die bereits "veraltet" sind.</a></li>
<li><a href="../de449114/index.html">Reagiere auf λambda</a></li>
<li><a href="../de449118/index.html">Kreml-Dämonenpille</a></li>
<li><a href="../de449120/index.html">Mit Bart, in dunkler Brille und im Profil: schwierige Situationen für Computer Vision</a></li>
<li><a href="../de449124/index.html">So schwer zu finden, leicht zu übersehen und unmöglich auszugeben</a></li>
<li><a href="../de449128/index.html">Top-Spieleentwicklungsunternehmen der Welt</a></li>
<li><a href="../de449132/index.html">Top 17 Plugins für Android Studio</a></li>
<li><a href="../de449134/index.html">Zoo afl</a></li>
<li><a href="../de449138/index.html">5 Gründe für Crypto-Hat Warum IT-Leute Bitcoin nicht mögen</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>