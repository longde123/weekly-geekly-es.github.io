<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>üë®üèª‚Äçüéì ü•ä üëñ Un pipeline informatique d√©claratif au-dessus des acteurs? Pourquoi pas? üìó üî∞ ü§πüèΩ</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a quelque temps, lors d'une discussion sur l'une des versions de SObjectizer, on nous a demand√©: "Est-il possible de cr√©er une DSL pour d√©crire u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Un pipeline informatique d√©claratif au-dessus des acteurs? Pourquoi pas?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460123/"><p>  Il y a quelque temps, lors d'une discussion sur l'une des versions de SObjectizer, on nous a demand√©: "Est-il possible de cr√©er une DSL pour d√©crire un pipeline de traitement de donn√©es?"  En d'autres termes, est-il possible d'√©crire quelque chose comme √ßa: </p><br><p><code>A | B | C | D</code> </p> <br><p>  et obtenir un pipeline de travail o√π les messages vont de A √† B, puis √† C, puis √† D. Avec le contr√¥le que B re√ßoit exactement ce type que A renvoie.  Et C re√ßoit exactement ce type que B renvoie.  Et ainsi de suite. </p><br><p>  C'√©tait une t√¢che int√©ressante avec une solution √©tonnamment simple.  Par exemple, voici √† quoi peut ressembler la cr√©ation d'un pipeline: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pipeline = make_pipeline(env, stage(A) | stage(B) | stage(C) | stage(D));</code> </pre> <br><p>  Ou, dans un cas plus complexe (qui sera discut√© ci-dessous): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(archiving), stage(distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(alarm_initiator), stage( []( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> alarm_detected &amp; v ) { alarm_distribution( <span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span>, v ); } ) ) ) );</code> </pre> <br><p>  Dans cet article, nous parlerons de l'impl√©mentation d'un tel pipeline DSL.  Nous discuterons principalement des parties li√©es aux fonctions <code>stage()</code> , <code>broadcast()</code> et <code>operator|()</code> avec plusieurs exemples d'utilisation de mod√®les C ++.  J'esp√®re donc que ce sera int√©ressant m√™me pour les lecteurs qui ne connaissent pas SObjectizer (si vous n'avez jamais entendu parler de SObjectizer, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">voici</a> un aper√ßu de cet outil). </p><a name="habracut"></a><br><h1 id="a-couple-of-words-about-the-used-demo">  Quelques mots sur la d√©mo utilis√©e </h1><br><p>  L'exemple utilis√© dans l'article a √©t√© influenc√© par mon exp√©rience ancienne (et plut√¥t oubli√©e) dans le domaine SCADA. </p><br><p>  L'id√©e de la d√©mo est le traitement des donn√©es lues √† partir d'un capteur.  Les donn√©es sont acquises √† partir d'un capteur avec une certaine p√©riode, puis ces donn√©es doivent √™tre valid√©es (les donn√©es incorrectes doivent √™tre ignor√©es) et converties en certaines valeurs r√©elles.  Par exemple, les donn√©es brutes lues sur un capteur peuvent √™tre deux valeurs enti√®res de 8 bits et ces valeurs doivent √™tre converties en un nombre √† virgule flottante. </p><br><p>  Ensuite, les valeurs valides et converties doivent √™tre archiv√©es, distribu√©es quelque part (sur diff√©rents n≈ìuds pour la visualisation, par exemple), v√©rifi√©es pour les "alarmes" (si les valeurs sont hors des limites s√ªres, cela doit √™tre sp√©cialement g√©r√©).  Ces op√©rations sont ind√©pendantes et peuvent √™tre effectu√©es en parall√®le. </p><br><p>  Les op√©rations li√©es √† l'alarme d√©tect√©e peuvent √©galement √™tre effectu√©es en parall√®le: une "alarme" doit √™tre d√©clench√©e (pour que la partie de SCADA sur le n≈ìud actuel puisse y r√©agir) et les informations sur "l'alarme" doivent √™tre distribu√©es ailleurs (par exemple : stock√© dans une base de donn√©es historique et / ou visualis√© sur l'√©cran de l'op√©rateur SCADA). </p><br><p>  Cette logique peut √™tre exprim√©e sous forme textuelle de cette fa√ßon: </p><br><pre> <code class="plaintext hljs">optional(valid_raw_data) = validate(raw_data); if valid_raw_data is not empty then { converted_value = convert(valid_raw_data); do_async archive(converted_value); do_async distribute(converted_value); do_async { optional(suspicious_value) = check_range(converted_value); if suspicious_value is not empty then { optional(alarm) = detect_alarm(suspicious_value); if alarm is not empty then { do_async initiate_alarm(alarm); do_async distribute_alarm(alam); } } } }</code> </pre> <br><p>  Ou, sous forme graphique: </p><br><p><img src="https://habrastorage.org/webt/5z/nm/vv/5znmvvaqnou_qwh808t8vkbrdc8.jpeg"></p><br><p>  C'est un exemple plut√¥t artificiel, mais il a des choses int√©ressantes que je veux montrer.  Le premier est la pr√©sence d'√©tages parall√®les dans un pipeline (l'op√©ration <code>broadcast()</code> existe juste √† cause de cela).  La seconde est la pr√©sence d'un √©tat √† certains stades.  Par exemple, alarm_detector est une √©tape avec √©tat. </p><br><h1 id="pipeline-capabilities">  Capacit√©s de pipeline </h1><br><p>  Un pipeline est construit √† partir d'√©tapes distinctes.  Chaque √©tape est une fonction ou un foncteur du format suivant: </p><br><pre> <code class="cpp hljs">opt&lt;Out&gt; func(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> In &amp;);</code> </pre> <br><p>  ou </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> In &amp;)</span></span></span></span>;</code> </pre> <br><p>  Les √©tapes qui renvoient un <code>void</code> ne peuvent √™tre utilis√©es que comme la derni√®re √©tape d'un pipeline. </p><br><p>  Les √©tapes sont li√©es dans une cha√Æne.  Chaque √©tape suivante re√ßoit un objet retourn√© par l'√©tape pr√©c√©dente.  Si l'√©tape pr√©c√©dente renvoie une valeur <code>opt&lt;Out&gt;</code> vide, l'√©tape suivante n'est pas appel√©e. </p><br><p>  Il y a une √©tape de <code>broadcast</code> sp√©ciale.  Il est construit √† partir de plusieurs pipelines.  Une √©tape de <code>broadcast</code> re√ßoit un objet de l'√©tape pr√©c√©dente et le diffuse √† chaque pipeline subsidiaire. </p><br><p>  Du point de vue du pipeline, l'√©tape de <code>broadcast</code> ressemble √† une fonction du format suivant: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> In &amp;)</span></span></span></span>;</code> </pre> <br><p>  Puisqu'il n'y a pas de valeur de retour de l'√©tape de <code>broadcast</code> , une √©tape de <code>broadcast</code> ne peut √™tre que la derni√®re √©tape d'un pipeline. </p><br><h2 id="why-does-the-pipeline-stage-return-an-optional-value">  Pourquoi l'√©tape du pipeline renvoie-t-elle une valeur facultative? </h2><br><p>  C'est parce qu'il est n√©cessaire de supprimer certaines valeurs entrantes.  Par exemple, l'√©tape de <code>validate</code> ne renvoie rien si une valeur brute est incorrecte et il n'y a aucun sens √† la g√©rer. </p><br><p>  Autre exemple: l'√©tape <code>alarm_detector</code> ne renvoie rien si la valeur suspecte actuelle ne produit pas de nouveau cas d'alarme. </p><br><h1 id="implementation-details">  D√©tails d'impl√©mentation </h1><br><h2 id="types-and-functions-related-to-the-application-logic">  Types et fonctions li√©s √† la logique d'application </h2><br><p>  Commen√ßons par les types de donn√©es et les fonctions li√©es √† la logique d'application.  Dans l'exemple d√©crit, les types de donn√©es suivants sont utilis√©s pour transmettre des informations d'une √©tape √† une autre: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Raw data from a sensor. struct raw_measure { int m_meter_id; uint8_t m_high_bits; uint8_t m_low_bits; }; // Type of input for validation stage with raw data from a sensor. struct raw_value { raw_measure m_data; }; // Type of input for conversion stage with valid raw data from a sensor. struct valid_raw_value { raw_measure m_data; }; // Data from a sensor after conversion to Celsius degrees. struct calculated_measure { int m_meter_id; float m_measure; }; // The type for result of conversion stage with converted data from a sensor. struct sensor_value { calculated_measure m_data; }; // Type with value which could mean a dangerous level of temperature. struct suspicious_value { calculated_measure m_data; }; // Type with information about detected dangerous situation. struct alarm_detected { int m_meter_id; };</span></span></code> </pre> <br><p>  Une instance de <code>raw_value</code> va √† la premi√®re √©tape de notre pipeline.  Cette valeur <code>raw_value</code> contient des informations acquises √† partir d'un capteur sous la forme d' <code>raw_measure</code> objet mesure <code>raw_measure</code> .  Ensuite, <code>raw_value</code> est transform√© en <code>valid_raw_value</code> .  Puis <code>valid_raw_value</code> transform√© en <code>sensor_value</code> avec la valeur r√©elle d'un capteur sous la forme de <code>calulated_measure</code> .  Si une instance de <code>sensor_value</code> contient une valeur suspecte, alors une instance de <code>suspicious_value</code> est produite.  Et cette valeur <code>suspicious_value</code> peut √™tre transform√©e en instance <code>alarm_detected</code> plus tard. </p><br><p>  Ou, sous forme graphique: </p><br><p><img src="https://habrastorage.org/webt/dp/dx/rz/dpdxrzpp-rvo05zk-8rwdwucszo.jpeg"></p><br><p>  Maintenant, nous pouvons jeter un oeil √† la mise en ≈ìuvre de nos √©tapes de pipeline: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // The first stage of a pipeline. Validation of raw data from a sensor. // // Returns valid_raw_value or nothing if value is invalid. // stage_result_t&lt; valid_raw_value &gt; validation( const raw_value &amp; v ) { if( 0x7 &gt;= v.m_data.m_high_bits ) return make_result&lt; valid_raw_value &gt;( v.m_data ); else return make_empty&lt; valid_raw_value &gt;(); } // // The second stage of a pipeline. Conversion from raw data to a value // in Celsius degrees. // stage_result_t&lt; sensor_value &gt; conversion( const valid_raw_value &amp; v ) { return make_result&lt; sensor_value &gt;( calculated_measure{ v.m_data.m_meter_id, 0.5f * ((static_cast&lt; uint16_t &gt;( v.m_data.m_high_bits ) &lt;&lt; 8) + v.m_data.m_low_bits) } ); } // // Simulation of the data archiving. // void archiving( const sensor_value &amp; v ) { clog &lt;&lt; "archiving (" &lt;&lt; v.m_data.m_meter_id &lt;&lt; "," &lt;&lt; v.m_data.m_measure &lt;&lt; ")" &lt;&lt; endl; } // // Simulation of the data distribution. // void distribution( const sensor_value &amp; v ) { clog &lt;&lt; "distributing (" &lt;&lt; v.m_data.m_meter_id &lt;&lt; "," &lt;&lt; v.m_data.m_measure &lt;&lt; ")" &lt;&lt; endl; } // // The first stage of a child pipeline at third level of the main pipeline. // // Checking for to high value of the temperature. // // Returns suspicious_value message or nothing. // stage_result_t&lt; suspicious_value &gt; range_checking( const sensor_value &amp; v ) { if( v.m_data.m_measure &gt;= 45.0f ) return make_result&lt; suspicious_value &gt;( v.m_data ); else return make_empty&lt; suspicious_value &gt;(); } // // The next stage of a child pipeline. // // Checks for two suspicious_value-es in 25ms time window. // class alarm_detector { using clock = chrono::steady_clock; public : stage_result_t&lt; alarm_detected &gt; operator()( const suspicious_value &amp; v ) { if( m_previous ) if( *m_previous + chrono::milliseconds(25) &gt; clock::now() ) { m_previous = nullopt; return make_result&lt; alarm_detected &gt;( v.m_data.m_meter_id ); } m_previous = clock::now(); return make_empty&lt; alarm_detected &gt;(); } private : optional&lt; clock::time_point &gt; m_previous; }; // // One of last stages of a child pipeline. // Imitates beginning of the alarm processing. // void alarm_initiator( const alarm_detected &amp; v ) { clog &lt;&lt; "=== alarm (" &lt;&lt; v.m_meter_id &lt;&lt; ") ===" &lt;&lt; endl; } // // Another of last stages of a child pipeline. // Imitates distribution of the alarm. // void alarm_distribution( ostream &amp; to, const alarm_detected &amp; v ) { to &lt;&lt; "alarm_distribution (" &lt;&lt; v.m_meter_id &lt;&lt; ")" &lt;&lt; endl; }</span></span></code> </pre> <br><p>  <code>stage_result_t</code> simplement des choses comme <code>stage_result_t</code> , <code>make_result</code> et <code>make_empty</code> , nous en discuterons dans la section suivante. </p><br><p>  J'esp√®re que le code de ces √©tapes est plut√¥t trivial.  La seule partie qui n√©cessite des explications suppl√©mentaires est la mise en ≈ìuvre de l'√©tape <code>alarm_detector</code> . </p><br><p>  Dans cet exemple, une alarme n'est d√©clench√©e que s'il y a au moins deux valeurs <code>suspicious_values</code> dans une fen√™tre de temps de 25 ms.  Nous devons donc nous rappeler l'heure de la pr√©c√©dente instance <code>suspicious_value</code> au stade <code>alarm_detector</code> .  En effet, <code>alarm_detector</code> est impl√©ment√© en tant que foncteur avec √©tat avec un op√©rateur d'appel de fonction. </p><br><h2 id="stages-return-sobjectizers-type-instead-of-stdoptional">  Les √©tapes renvoient le type de SObjectizer au lieu de std :: optional </h2><br><p>  J'ai dit plus t√¥t que l'√©tape pouvait renvoyer une valeur facultative.  Mais <code>std::optional</code> n'est pas utilis√© dans le code, le type diff√©rent <code>stage_result_t</code> peut √™tre vu dans l'impl√©mentation des √©tapes. </p><br><p>  C'est parce que certains sp√©cificit√©s de SObjectizer jouent ici leur r√¥le.  Les valeurs retourn√©es seront distribu√©es sous forme de messages entre les agents de SObjectizer (alias acteurs).  Chaque message dans SObjectizer est envoy√© en tant qu'objet allou√© dynamiquement.  Nous avons donc ici une sorte d '"optimisation": au lieu de renvoyer <code>std::optional</code> puis d'allouer un nouvel objet message, nous allouons simplement un objet message et lui retournons un pointeur intelligent. </p><br><p>  En fait, <code>stage_result_t</code> n'est qu'un typedef pour l'analogue shared_ptr de SObjectizer: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M &gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>&lt; M &gt;;</code> </pre> <br><p>  Et <code>make_result</code> et <code>make_empty</code> sont que des fonctions d'assistance pour construire <code>stage_result_t</code> avec ou sans valeur r√©elle √† l'int√©rieur: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt; make_result( Args &amp;&amp;... args ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt;::make(forward&lt; Args &gt;(args)...); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt; make_empty() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt;(); }</code> </pre> <br><p>  Pour plus de simplicit√©, il est s√ªr de dire que l'√©tape de <code>validation</code> pourrait √™tre exprim√©e de cette fa√ßon: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt; valid_raw_value &gt; validation( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> raw_value &amp; v ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-number"><span class="hljs-number">0x7</span></span> &gt;= v.m_data.m_high_bits ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt; valid_raw_value &gt;( v.m_data ); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt; valid_raw_value &gt;{}; }</code> </pre> <br><p>  Mais, en raison de la sp√©cificit√© de SObjectizer, nous ne pouvons pas utiliser <code>std::shared_ptr</code> et <code>so_5::message_holder_t</code> type <code>so_5::message_holder_t</code> .  Et nous cachons ces √©l√©ments sp√©cifiques derri√®re les <code>stage_result_t</code> , <code>make_result</code> et <code>make_empty</code> . </p><br><h2 id="stage_handler_t-and-stage_builder_t-separation">  s√©paration stage_handler_t et stage_builder_t </h2><br><p>  Un point important de la mise en ≈ìuvre du pipeline est la s√©paration des concepts de <em>gestionnaire d'</em> <em>√©tape</em> et de <em>constructeur d'√©tape</em> .  Ceci est fait pour plus de simplicit√©.  La pr√©sence de ces concepts m'a permis d'avoir deux √©tapes dans la d√©finition du pipeline. </p><br><p>  √Ä la premi√®re √©tape, un utilisateur d√©crit les √©tapes du pipeline.  En cons√©quence, je re√ßois une instance de <code>stage_t</code> qui contient toutes les √©tapes du pipeline √† l'int√©rieur. </p><br><p>  √Ä la deuxi√®me √©tape, un ensemble d'agents SObjectizer sous-jacents est cr√©√©.  Ces agents re√ßoivent des messages avec les r√©sultats des √©tapes pr√©c√©dentes et appellent des <em>gestionnaires d'√©tape</em> r√©els, puis envoient les r√©sultats aux √©tapes suivantes. </p><br><p>  Mais pour cr√©er cet ensemble d'agents, chaque √©tape doit avoir un <em>constructeur d'√©tape</em> .  <em>Le g√©n√©rateur de sc√®ne</em> peut √™tre vu comme une fabrique qui cr√©e un agent SObjectizer sous-jacent. </p><br><p>  Nous avons donc la relation suivante: chaque √©tape du pipeline produit deux objets: le <em>gestionnaire d'√©tape</em> qui contient la logique li√©e √† l' <em>√©tape</em> et le <em>g√©n√©rateur d'√©tape</em> qui cr√©e un agent SObjectizer sous-jacent pour appeler le <em>gestionnaire d'√©tape</em> au moment appropri√©: </p><br><p><img src="https://habrastorage.org/webt/gl/tp/nn/gltpnnqhjqslsscxvellndh6n0u.jpeg"></p><br><p>  <em>Le gestionnaire de sc√®ne</em> est repr√©sent√© de la mani√®re suivante: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stage_handler_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> traits = <span class="hljs-keyword"><span class="hljs-keyword">handler_traits_t</span></span>&lt; In, Out &gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> func_type = function&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> traits::output(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> traits::input &amp;) &gt;; <span class="hljs-keyword"><span class="hljs-keyword">stage_handler_t</span></span>( func_type handler ) : m_handler( move(handler) ) {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Callable &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_handler_t</span></span>( Callable handler ) : m_handler( handler ) {} <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> traits::<span class="hljs-function"><span class="hljs-function">output </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> traits::input &amp; a )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_handler( a ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> : func_type m_handler; };</code> </pre> <br><p>  O√π <code>handler_traits_t</code> sont d√©finis de la mani√®re suivante: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // We have to deal with two types of stage handlers: // - intermediate handlers which will return some result (eg some new // message); // - terminal handlers which can return nothing (eg void instead of // stage_result_t&lt;M&gt;); // // This template with specialization defines `input` and `output` // aliases for both cases. // template&lt; typename In, typename Out &gt; struct handler_traits_t { using input = In; using output = stage_result_t&lt; Out &gt;; }; template&lt; typename In &gt; struct handler_traits_t&lt; In, void &gt; { using input = In; using output = void; };</span></span></code> </pre> <br><p>  <em>Le g√©n√©rateur de sc√®ne</em> est repr√©sent√© par juste <code>std::function</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> = function&lt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp;, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>) &gt;;</code> </pre> <br><h2 id="helper-types-lambda_traits_t-and-callable_traits_t">  Types d'assistance lambda_traits_t et callable_traits_t </h2><br><p>  √âtant donn√© que les √©tapes peuvent √™tre repr√©sent√©es par des fonctions ou des foncteurs libres (comme des instances de la classe <code>alarm_detector</code> ou des classes g√©n√©r√©es par le compilateur anonyme repr√©sentant des lambdas), nous avons besoin de quelques aides pour d√©tecter les types d'argument de l'√©tape et la valeur de retour.  J'ai utilis√© le code suivant √† cet effet: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // Helper type for `arg_type` and `result_type` alises definition. // template&lt; typename R, typename A &gt; struct callable_traits_typedefs_t { using arg_type = A; using result_type = R; }; // // Helper type for dealing with stateful objects with operator() // (they could be user-defined objects or generated by compiler // like lambdas). // template&lt; typename T &gt; struct lambda_traits_t; template&lt; typename M, typename A, typename T &gt; struct lambda_traits_t&lt; stage_result_t&lt; M &gt;(T::*)(const A &amp;) const &gt; : public callable_traits_typedefs_t&lt; M, A &gt; {}; template&lt; typename A, typename T &gt; struct lambda_traits_t&lt; void (T::*)(const A &amp;) const &gt; : public callable_traits_typedefs_t&lt; void, A &gt; {}; template&lt; typename M, typename A, typename T &gt; struct lambda_traits_t&lt; stage_result_t&lt; M &gt;(T::*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; M, A &gt; {}; template&lt; typename A, typename T &gt; struct lambda_traits_t&lt; void (T::*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; void, A &gt; {}; // // Main type for definition of `arg_type` and `result_type` aliases. // With specialization for various cases. // template&lt; typename T &gt; struct callable_traits_t : public lambda_traits_t&lt; decltype(&amp;T::operator()) &gt; {}; template&lt; typename M, typename A &gt; struct callable_traits_t&lt; stage_result_t&lt; M &gt;(*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; M, A &gt; {}; template&lt; typename A &gt; struct callable_traits_t&lt; void(*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; void, A &gt; {};</span></span></code> </pre> <br><p>  J'esp√®re que ce code sera tout √† fait compr√©hensible pour les lecteurs ayant une bonne connaissance de C ++.  Sinon, n'h√©sitez pas √† me demander dans les commentaires, je serai heureux d'expliquer la logique derri√®re <code>lambda_traits_t</code> et <code>callable_traits_t</code> en d√©tails. </p><br><h2 id="stage-broadcast-and-operator-functions">  fonctions stage (), broadcast () et op√©rateur | () </h2><br><p>  Maintenant, nous pouvons regarder √† l'int√©rieur des principales fonctions de construction de pipelines.  Mais avant cela, il est n√©cessaire de jeter un ≈ìil √† la d√©finition d'une classe de mod√®le <code>stage_t</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stage_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> m_builder; };</code> </pre> <br><p>  C'est une structure tr√®s simple qui contient juste <code>stage_bulder_t</code> instance <code>stage_bulder_t</code> .  Les param√®tres du mod√®le ne sont pas utilis√©s dans <code>stage_t</code> , alors pourquoi sont-ils pr√©sents ici? </p><br><p>  Ils sont n√©cessaires pour la v√©rification √† la compilation de la compatibilit√© des types entre les √©tapes du pipeline.  Nous verrons cela bient√¥t. </p><br><p>  Regardons la fonction de construction de pipeline la plus simple, la <code>stage()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Callable, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::arg_type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::result_type &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out &gt; stage( Callable handler ) { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [h = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(handler)]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">a_stage_point_t</span></span>&lt;In, Out&gt; &gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(h), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ) -&gt;so_direct_mbox(); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(builder) }; }</code> </pre> <br><p>  Il re√ßoit un <em>gestionnaire d'√©tape</em> r√©el en tant que param√®tre unique.  Il peut s'agir d'un pointeur vers une fonction ou une fonction lambda ou un foncteur.  Les types d'entr√©e et de sortie de la sc√®ne sont d√©duits automatiquement en raison de la ¬´magie du mod√®le¬ª derri√®re le mod√®le <code>callable_traits_t</code> . </p><br><p>  Une instance de <em>Stage Builder</em> est cr√©√©e √† l'int√©rieur et cette instance est renvoy√©e dans un nouvel objet <code>stage_t</code> comme r√©sultat de la fonction <code>stage()</code> .  Un <em>gestionnaire de sc√®ne</em> r√©el est captur√© par le <em>constructeur de sc√®nes</em> lambda, il sera ensuite utilis√© pour la construction d'un agent SObjectizer sous-jacent (nous en parlerons dans la section suivante). </p><br><p>  La prochaine fonction √† examiner est l' <code>operator|()</code> qui concat√®ne deux √©tapes ensemble et renvoie une nouvelle √©tape: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out2 &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out2 &gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>|( <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out1 &gt; &amp;&amp; prev, <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; Out1, Out2 &gt; &amp;&amp; next ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span>{ [prev, next]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage ) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> m = next.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prev.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(m) ); } } }; }</code> </pre> <br><p>  La fa√ßon la plus simple d'expliquer la logique de l' <code>operator|()</code> est d'essayer de dessiner une image.  Supposons que nous avons l'expression: </p><br><pre> <code class="cpp hljs">stage(A) | stage(B) | stage(C) | stage(B)</code> </pre> <br><p>  Cette expression sera transform√©e de cette fa√ßon: </p><br><p><img src="https://habrastorage.org/webt/jo/rr/aq/jorraqaawl6y7ju3om7zfq3java.jpeg"></p><br><p>  L√†, nous pouvons √©galement voir comment fonctionne la v√©rification de type √† la compilation: la d√©finition de l' <code>operator|()</code> n√©cessite que le type de sortie du premier √©tage soit l'entr√©e du deuxi√®me √©tage.  Si ce n'est pas le cas, le code ne sera pas compil√©. </p><br><p>  Et maintenant, nous pouvons jeter un ≈ìil √† la fonction de construction de pipeline la plus complexe, la <code>broadcast()</code> .  La fonction elle-m√™me est assez simple: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Rest &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> &gt; broadcast( <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out &gt; &amp;&amp; first, Rest &amp;&amp;... stages ) { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [broadcasts = collect_sink_builders( move(first), forward&lt; Rest &gt;(stages)...)] ( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> ) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> &gt; mboxes; mboxes.reserve( broadcasts.size() ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; b : broadcasts ) mboxes.emplace_back( b( coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>{} ) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">broadcast_mbox_t</span></span>::make( coop.environment(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(mboxes) ); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(builder) }; }</code> </pre> <br><p>  La principale diff√©rence entre une sc√®ne ordinaire et une sc√®ne de diffusion est que la sc√®ne de diffusion doit contenir un vecteur de <em>constructeurs de sc√®nes</em> subsidiaires.  Nous devons donc cr√©er ce vecteur et le transmettre au <em>g√©n√©rateur</em> de <em>sc√®ne</em> principal de la diffusion.  Pour cette raison, nous pouvons voir un appel √† <code>collect_sink_builders</code> dans la liste de capture d'un lambda √† l'int√©rieur de la fonction <code>broadcast()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [broadcasts = collect_sink_builders( move(first), forward&lt; Rest &gt;(stages)...)]</code> </pre> <br><p>  Si nous examinons <code>collect_sink_builder</code> nous verrons le code suivant: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // Serie of helper functions for building description for // `broadcast` stage. // // Those functions are used for collecting // `builders` functions for every child pipeline. // // Please note that this functions checks that each child pipeline has the // same In type. // template&lt; typename In, typename Out, typename... Rest &gt; void move_sink_builder_to( vector&lt; stage_builder_t &gt; &amp; receiver, stage_t&lt; In, Out &gt; &amp;&amp; first, Rest &amp;&amp;... rest ) { receiver.emplace_back( move( first.m_builder ) ); if constexpr( 0u != sizeof...(rest) ) move_sink_builder_to&lt;In&gt;( receiver, forward&lt; Rest &gt;(rest)... ); } template&lt; typename In, typename Out, typename... Rest &gt; vector&lt; stage_builder_t &gt; collect_sink_builders( stage_t&lt; In, Out &gt; &amp;&amp; first, Rest &amp;&amp;... stages ) { vector&lt; stage_builder_t &gt; receiver; receiver.reserve( 1 + sizeof...(stages) ); move_sink_builder_to&lt;In&gt;( receiver, move(first), std::forward&lt;Rest&gt;(stages)... ); return receiver; }</span></span></code> </pre> <br><p>  La v√©rification de type √† la compilation fonctionne ici aussi: c'est parce qu'un appel √† <code>move_sink_builder_to</code> explicitement param√©tr√© par le type 'In'.  Cela signifie qu'un appel sous la forme <code>collect_sink_builders(stage_t&lt;In1, Out1&gt;, stage_t&lt;In2, Out2&gt;, ...)</code> entra√Ænera une erreur de compilation car le compilateur interdit un appel <code>move_sink_builder_to&lt;In1&gt;(receiver, stage_t&lt;In2, Out2&gt;, ...)</code> . </p><br><p>  Je peux √©galement noter que parce que le nombre de pipelines subsidiaires pour <code>broadcast()</code> est connu au moment de la compilation, nous pouvons utiliser <code>std::array</code> au lieu de <code>std::vector</code> et pouvons √©viter certaines allocations de m√©moire.  Mais <code>std::vector</code> est utilis√© ici juste pour plus de simplicit√©. </p><br><h2 id="relation-between-stages-and-sobjectizers-agentsmboxes">  Relation entre les √©tapes et les agents / mbox de SObjectizer </h2><br><p>  L'id√©e derri√®re la mise en ≈ìuvre du pipeline est la cr√©ation d'un agent distinct pour chaque √©tape du pipeline.  Un agent re√ßoit un message entrant, le transmet au <em>gestionnaire d'√©tape</em> correspondant, analyse le r√©sultat et, si le r√©sultat n'est pas vide, envoie le r√©sultat sous forme de message entrant √† l'√©tape suivante.  Il peut √™tre illustr√© par le diagramme de s√©quence suivant: </p><br><p><img src="https://habrastorage.org/webt/om/pn/wy/ompnwye792gjgad7zzgphpv4ctu.png"></p><br><p>  Certaines choses li√©es √† SObjectizer doivent √™tre discut√©es, au moins bri√®vement.  Si vous n'√™tes pas int√©ress√© par ces d√©tails, vous pouvez ignorer les sections ci-dessous et aller directement √† la conclusion. </p><br><h3 id="coop-is-a-group-of-agents-to-work-together">  Coop est un groupe d'agents pour travailler ensemble </h3><br><p>  Les agents sont introduits dans SObjectizer non pas individuellement mais dans des groupes nomm√©s coops.  Une coop√©rative est un groupe d'agents qui devraient travailler ensemble et il est inutile de continuer le travail si l'un des agents du groupe est absent. </p><br><p>  Ainsi, l'introduction d'agents dans SObjectizer ressemble √† la cr√©ation d'une instance coop, remplissant cette instance avec les agents appropri√©s, puis enregistrant la coop√©rative dans SObjectizer. </p><br><p>  Pour cette raison, le premier argument pour un <em>constructeur de sc√®ne</em> est une r√©f√©rence √† une nouvelle coop√©rative.  Cette coop√©rative est cr√©√©e dans la fonction <code>make_pipeline()</code> (discut√©e ci-dessous), puis elle est remplie par <em>les constructeurs d'√©tapes</em> puis enregistr√©e (√† nouveau dans la fonction <code>make_pipeline()</code> ). </p><br><h3 id="message-boxes">  Bo√Ætes de messages </h3><br><p>  SObjectizer impl√©mente plusieurs mod√®les li√©s √† la concurrence.  Le mod√®le d'acteur n'est que l'un d'entre eux.  De ce fait, SObjectizer peut diff√©rer consid√©rablement des autres frameworks d'acteurs.  L'une des diff√©rences est le sch√©ma d'adressage des messages. </p><br><p>  Les messages dans SObjectizer ne s'adressent pas aux acteurs, mais aux <em>bo√Ætes de message</em> (mbox).  Les acteurs doivent s'abonner aux messages d'une mbox.  Si un acteur √©tait abonn√© √† un type de message particulier √† partir d'une mbox, il recevrait des messages de ce type: </p><br><p><img src="https://habrastorage.org/webt/o4/bf/ee/o4bfee0lp8hdvks68cas4yjlkgu.png"></p><br><p>  Ce fait est crucial car il est n√©cessaire d'envoyer des messages d'une √©tape √† l'autre.  Cela signifie que chaque √©tape doit avoir sa mbox et que la mbox doit √™tre connue pour l'√©tape pr√©c√©dente. </p><br><p>  Chaque acteur (alias agent) dans SObjectizer a <em>la mbox directe</em> .  Cette mbox n'est associ√©e qu'√† l'agent propri√©taire et ne peut √™tre utilis√©e par aucun autre agent.  Les mbox directs des agents cr√©√©s pour les √©tapes seront utilis√©s pour l'interaction des √©tapes. </p><br><p>  La fonctionnalit√© sp√©cifique de ce SObjectizer dicte certains d√©tails d'impl√©mentation du pipeline. </p><br><p>  Le premier est le fait que le <em>constructeur de sc√®nes</em> dispose du prototype suivant: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> builder(<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp;, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>);</code> </pre> <br><p>  Cela signifie que le <em>g√©n√©rateur d'√©tape</em> re√ßoit une mbox de l'√©tape suivante et doit cr√©er un nouvel agent qui enverra les r√©sultats de l'√©tape √† cette mbox.  Une mbox du nouvel agent doit √™tre retourn√©e par le <em>g√©n√©rateur de sc√®ne</em> .  Cette mbox sera utilis√©e pour la cr√©ation d'un agent pour l'√©tape pr√©c√©dente. </p><br><p>  Le second est le fait que les agents des √©tapes sont cr√©√©s dans l'ordre de r√©serve.  Cela signifie que si nous avons un pipeline: </p><br><pre> <code class="cpp hljs">stage(A) | stage(B) | stage(C)</code> </pre> <br><p>  Un agent pour l'√©tape C sera d'abord cr√©√©, puis sa mbox sera utilis√©e pour la cr√©ation d'un agent pour l'√©tape B, puis la mbox de l'agent de l'√©tape B sera utilis√©e pour la cr√©ation d'un agent pour l'√©tape A. </p><br><p>  Il convient √©galement de noter que l' <code>operator|()</code> ne cr√©e pas d'agents: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span>{ [prev, next]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage ) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> m = next.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prev.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(m) ); } }</code> </pre> <br><p>  L' <code>operator|()</code> cr√©e un g√©n√©rateur qui n'appelle que d'autres g√©n√©rateurs mais n'introduit pas d'agents suppl√©mentaires.  Donc pour le cas: </p><br><pre> <code class="cpp hljs">stage(A) | stage(B)</code> </pre> <br><p>  seuls deux agents seront cr√©√©s (pour A-stage et B-stage) puis ils seront li√©s ensemble dans le <em>g√©n√©rateur de sc√®ne</em> cr√©√© par l' <code>operator|()</code> . </p><br><h3 id="there-is-no-agent-for-broadcast-implementation">  Il n'y a pas d'agent pour la mise en ≈ìuvre de <code>broadcast()</code> </h3><br><p>  Une fa√ßon √©vidente de mettre en ≈ìuvre une √©tape de diffusion consiste √† cr√©er un agent sp√©cial qui recevra un message entrant, puis √† renvoyer ce message √† une liste de mbox de destination.  Cette m√©thode a <a href="">√©t√© utilis√©e dans la premi√®re impl√©mentation</a> du pipeline DSL d√©crit. </p><br><p>  Mais notre projet compagnon, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">so5extra</a> , a maintenant une variante sp√©ciale de mbox: en diffuser une.  Cette mbox fait exactement ce qui est requis ici: elle prend un nouveau message et le livre √† un ensemble de mbox de destination. </p><br><p>  Pour cette raison, il n'est pas n√©cessaire de cr√©er un agent de diffusion distinct, nous pouvons simplement utiliser la diffusion mbox de so5extra: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // A special mbox for broadcasting of a message to a set of destination // mboxes. // using broadcast_mbox_t = so_5::extra::mboxes::broadcast::fixed_mbox_template_t&lt;&gt;; ... // // Inside the broadcast() function: // stage_builder_t builder{ [broadcasts = collect_sink_builders( move(first), forward&lt; Rest &gt;(stages)...)] ( coop_t &amp; coop, mbox_t ) -&gt; mbox_t { vector&lt; mbox_t &gt; mboxes; mboxes.reserve( broadcasts.size() ); for( const auto &amp; b : broadcasts ) mboxes.emplace_back( b( coop, mbox_t{} ) ); // That is the creation of broadcasting mbox instance. return broadcast_mbox_t::make( coop.environment(), std::move(mboxes) ); } };</span></span></code> </pre> <br><h3 id="implementation-of-stage-agent">  Impl√©mentation de stage-agent </h3><br><p>  Maintenant, nous pouvons jeter un oeil √† la mise en ≈ìuvre de l'agent de sc√®ne: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // An agent which will be used as intermediate or terminal pipeline stage. // It will receive input message, call the stage handler and pass // handler result to the next stage (if any). // template&lt; typename In, typename Out &gt; class a_stage_point_t final : public agent_t { public : a_stage_point_t( context_t ctx, stage_handler_t&lt; In, Out &gt; handler, mbox_t next_stage ) : agent_t{ ctx } , m_handler{ move( handler ) } , m_next{ move(next_stage) } {} void so_define_agent() override { if( m_next ) // Because there is the next stage the appropriate // message handler will be used. so_subscribe_self().event( [=]( const In &amp; evt ) { auto r = m_handler( evt ); if( r ) so_5::send( m_next, r ); } ); else // There is no next stage. A very simple message handler // will be used for that case. so_subscribe_self().event( [=]( const In &amp; evt ) { m_handler( evt ); } ); } private : const stage_handler_t&lt; In, Out &gt; m_handler; const mbox_t m_next; }; // // A specialization of a_stage_point_t for the case of terminal stage of // a pipeline. This type will be used for stage handlers with void // return type. // template&lt; typename In &gt; class a_stage_point_t&lt; In, void &gt; final : public agent_t { public : a_stage_point_t( context_t ctx, stage_handler_t&lt; In, void &gt; handler, mbox_t next_stage ) : agent_t{ ctx } , m_handler{ move( handler ) } { if( next_stage ) throw std::runtime_error( "sink point cannot have next stage" ); } void so_define_agent() override { so_subscribe_self().event( [=]( const In &amp; evt ) { m_handler( evt ); } ); } private : const stage_handler_t&lt; In, void &gt; m_handler; };</span></span></code> </pre> <br><p>  C'est plut√¥t trivial si vous comprenez les bases du SObjectizer.  Sinon ce sera assez difficile √† expliquer en quelques mots (alors n'h√©sitez pas √† poser des questions dans les commentaires). </p><br><p>  L'impl√©mentation principale de l'agent <code>a_stage_point_t</code> cr√©e un abonnement √† un message de type In.  Lorsqu'un message de ce type arrive, le <em>gestionnaire d'√©tape</em> est appel√©.  Si le <em>gestionnaire d'√©tape</em> renvoie un r√©sultat r√©el, le r√©sultat est envoy√© √† l'√©tape suivante (si cette √©tape existe). </p><br><p>  Il existe √©galement une version de <code>a_stage_point_t</code> pour le cas o√π l'√©tape correspondante est l'√©tape terminale et il ne peut pas y avoir l'√©tape suivante. </p><br><p>  L'impl√©mentation de <code>a_stage_point_t</code> peut sembler un peu compliqu√© mais croyez-moi, c'est l'un des agents les plus simples que j'ai √©crits. </p><br><h2 id="make_pipeline-function">  Fonction make_pipeline () </h2><br><p>  Il est temps de discuter de la derni√®re fonction de construction de pipeline, la <code>make_pipeline()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> make_pipeline( <span class="hljs-comment"><span class="hljs-comment">// SObjectizer Environment to work in. so_5::environment_t &amp; env, // Definition of a pipeline. stage_t&lt; In, Out &gt; &amp;&amp; sink, // Optional args to be passed to make_coop() function. Args &amp;&amp;... args ) { auto coop = env.make_coop( forward&lt; Args &gt;(args)... ); auto mbox = sink.m_builder( *coop, mbox_t{} ); env.register_coop( move(coop) ); return mbox; }</span></span></code> </pre> <br><p>  Il n'y a pas de magie ni de surprise ici.  Nous avons juste besoin de cr√©er une nouvelle coop√©rative pour les agents sous-jacents du pipeline, de remplir cette coop√©rative avec des agents en appelant un <em>constructeur de</em> niveau sup√©rieur, puis d'enregistrer cette coop√©rative dans SObjectizer.  C'est tout. </p><br><p>  Le r√©sultat de <code>make_pipeline()</code> est la mbox de l'√©tape la plus √† gauche (la premi√®re) du pipeline.  Cette mbox doit √™tre utilis√©e pour envoyer des messages au pipeline. </p><br><h1 id="the-simulation-and-experiments-with-it">  La simulation et ses exp√©riences </h1><br><p>  Nous avons donc maintenant des types de donn√©es et des fonctions pour notre logique d'application et les outils pour encha√Æner ces fonctions dans un pipeline de traitement des donn√©es.  Faisons-le et voyons un r√©sultat: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Launch SObjectizer in a separate thread. wrapped_env_t sobj; // Make a pipeline. auto pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(archiving), stage(distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(alarm_initiator), stage( []( const alarm_detected &amp; v ) { alarm_distribution( cerr, v ); } ) ) ) ); // Send messages to a pipeline in a loop with 10ms delays. for( uint8_t i = 0; i &lt; static_cast&lt; uint8_t &gt;(250); i += 10 ) { send&lt; raw_value &gt;( pipeline, raw_measure{ 0, 0, i } ); std::this_thread::sleep_for( chrono::milliseconds{10} ); } }</span></span></code> </pre> <br><p>  Si nous ex√©cutons cet exemple, nous verrons la sortie suivante: </p><br><pre> <code class="plaintext hljs">archiving (0,0) distributing (0,0) archiving (0,5) distributing (0,5) archiving (0,10) distributing (0,10) archiving (0,15) distributing (0,15) archiving (0,20) distributing (0,20) archiving (0,25) distributing (0,25) archiving (0,30) distributing (0,30) ... archiving (0,105) distributing (0,105) archiving (0,110) distributing (0,110) === alarm (0) === alarm_distribution (0) archiving (0,115) distributing (0,115) archiving (0,120) distributing (0,120) === alarm (0) === alarm_distribution (0)</code> </pre> <br><p>  √áa marche. </p><br><p>  Mais il semble que les √©tapes de notre pipeline fonctionnent s√©quentiellement, l'une apr√®s l'autre, n'est-ce pas? </p><br><p>  Oui, √ßa l'est.  En effet, tous les agents de pipeline sont li√©s au r√©partiteur par d√©faut de SObjectizer.  Et ce r√©partiteur utilise un seul thread de travail pour le traitement des messages de tous les agents. </p><br><p>  Mais cela peut √™tre facilement chang√©.  <code>make_pipeline()</code> simplement un argument suppl√©mentaire √† l' <code>make_pipeline()</code> de <code>make_pipeline()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Make a pipeline. auto pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(archiving), stage(distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(alarm_initiator), stage( []( const alarm_detected &amp; v ) { alarm_distribution( cerr, v ); } ) ) ), disp::thread_pool::make_dispatcher( sobj.environment() ).binder( disp::thread_pool::bind_params_t{}.fifo( disp::thread_pool::fifo_t::individual ) ) );</span></span></code> </pre> <br><p>  Cela cr√©e un nouveau pool de threads et lie tous les agents de pipeline √† ce pool.  Chaque agent sera servi par la piscine ind√©pendamment des autres agents. </p><br><p>  Si nous ex√©cutons l'exemple modifi√©, nous pouvons voir quelque chose comme √ßa: </p><br><pre> <code class="plaintext hljs">archiving (0,0) distributing (0,0) distributing (0,5) archiving (0,5) archiving (0,10) distributing (0,10) distributing (archiving (0,15) 0,15) archiving (0,20) distributing (0,20) archiving (0,25) distributing (0,25) archiving (0,distributing (030) ,30) ... archiving (0,distributing (0,105) 105) archiving (0,alarm_distribution (0) distributing (0,=== alarm (0) === 110) 110) archiving (distributing (0,0,115) 115) archiving (distributing (=== alarm (0) === 0alarm_distribution (0) 0,120) ,120)</code> </pre> <br><p>  Nous pouvons donc voir que les diff√©rentes √©tapes du pipeline fonctionnent en parall√®le. </p><br><p>  Mais est-il possible d'aller plus loin et d'avoir la possibilit√© de lier des √©tapes √† diff√©rents r√©partiteurs? </p><br><p>  Oui, c'est possible, mais nous devons impl√©menter une autre surcharge pour la fonction <code>stage()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Callable, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::arg_type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::result_type &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out &gt; stage( <span class="hljs-keyword"><span class="hljs-keyword">disp_binder_shptr_t</span></span> disp_binder, Callable handler ) { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [binder = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(disp_binder), h = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(handler)]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> coop.make_agent_with_binder&lt; <span class="hljs-keyword"><span class="hljs-keyword">a_stage_point_t</span></span>&lt;In, Out&gt; &gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(binder), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(h), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ) -&gt;so_direct_mbox(); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(builder) }; }</code> </pre> <br><p>  Cette version de <code>stage()</code> accepte non seulement un <em>gestionnaire de stage</em> mais aussi un classeur de r√©partiteur. Dispatcher binder is a way to bind an agent to the particular dispatcher. So to assign a stage to a specific working context we can create an appropriate dispatcher and then pass the binder to that dispatcher to <code>stage()</code> function. Let's do that: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// An active_obj dispatcher to be used for some stages. auto ao_disp = disp::active_obj::make_dispatcher( sobj.environment() ); // Make a pipeline. auto pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(ao_disp.binder(), archiving), stage(ao_disp.binder(), distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(ao_disp.binder(), alarm_initiator), stage(ao_disp.binder(), []( const alarm_detected &amp; v ) { alarm_distribution( cerr, v ); } ) ) ), disp::one_thread::make_dispatcher( sobj.environment() ).binder() );</span></span></code> </pre> <br><p> In that case stages <code>archiving</code> , <code>distribution</code> , <code>alarm_initiator</code> and <code>alarm_distribution</code> will work on own worker threads. All other stages will work on the same single worker thread. </p><br><h1 id="the-conclusion"> The conclusion </h1><br><p> This was an interesting experiment and I was surprised how easy SObjectizer could be used in something like reactive programming or data-flow programming. </p><br><p> However, I don't think that pipeline DSL can be practically meaningful. It's too simple and, maybe not flexible enough. But, I hope, it can be a base for more interesting experiments for those why need to deal with different workflows and data-processing pipelines. At least as a base for some ideas in that area. C++ language a rather good here and some (not so complicated) template magic can help to catch various errors at compile-time. </p><br><p> In conclusion, I want to say that we see SObjectizer not as a specialized tool for solving a particular problem, but as a basic set of tools to be used in solutions for different problems. And, more importantly, that basic set can be extended for your needs. Just take a look at <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SObjectizer</a> , try it, and share your feedback. Maybe you missed something in SObjectizer? Perhaps you don't like something? <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tell us</a> , and we can try to help you. </p><br><p> If you want to help further development of SObjectizer, please share a reference to it or to this article somewhere you want (Reddit, HackerNews, LinkedIn, Facebook, Twitter, ...). The more attention and the more feedback, the more new features will be incorporated into SObjectizer. </p><br><p> And many thanks for reading this ;) </p><br><p>  PS. The source code for that example can be found in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">that repository</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr460123/">https://habr.com/ru/post/fr460123/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr460113/index.html">Quelques histoires de la vie de JSOC CERT, ou Unbanal forensics</a></li>
<li><a href="../fr460115/index.html">Dix ans de programmation √† Erlang</a></li>
<li><a href="../fr460117/index.html">Les plus gros clients en Russie sont-ils un gros jackpot ou un mal de t√™te? Exp√©rience AGIMA</a></li>
<li><a href="../fr460119/index.html">Erreurs que l'analyse de code statique ne trouve pas car il n'est pas utilis√©</a></li>
<li><a href="../fr460121/index.html">Erreurs que l'analyse de code statique ne trouve pas car il n'est pas utilis√©</a></li>
<li><a href="../fr460125/index.html">Node.js ou Java: performances, ressources, contr√¥le de flux, popularit√© et exp√©rience personnelle</a></li>
<li><a href="../fr460129/index.html">Robots et fraises: comment l'IA augmente les rendements sur le terrain</a></li>
<li><a href="../fr460131/index.html">Pare-feu Sophos XG: du ME classique au NGFW avec r√©ponse automatique aux incidents de s√©curit√© des informations</a></li>
<li><a href="../fr460133/index.html">Kotlin / Everywhere - Pratique vitrine: 31 juillet</a></li>
<li><a href="../fr460135/index.html">Semaine de s√©curit√© 29: Vuln√©rabilit√© li√©e au zoom, √† la s√©curit√© et aux drames</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>