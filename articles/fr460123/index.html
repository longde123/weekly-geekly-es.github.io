<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👨🏻‍🎓 🥊 👖 Un pipeline informatique déclaratif au-dessus des acteurs? Pourquoi pas? 📗 🔰 🤹🏽</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Il y a quelque temps, lors d'une discussion sur l'une des versions de SObjectizer, on nous a demandé: "Est-il possible de créer une DSL pour décrire u...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Un pipeline informatique déclaratif au-dessus des acteurs? Pourquoi pas?</h1><div class="post__body post__body_full"><div class="post__text post__text-html" id="post-content-body" data-io-article-url="https://habr.com/ru/post/460123/"><p>  Il y a quelque temps, lors d'une discussion sur l'une des versions de SObjectizer, on nous a demandé: "Est-il possible de créer une DSL pour décrire un pipeline de traitement de données?"  En d'autres termes, est-il possible d'écrire quelque chose comme ça: </p><br><p><code>A | B | C | D</code> </p> <br><p>  et obtenir un pipeline de travail où les messages vont de A à B, puis à C, puis à D. Avec le contrôle que B reçoit exactement ce type que A renvoie.  Et C reçoit exactement ce type que B renvoie.  Et ainsi de suite. </p><br><p>  C'était une tâche intéressante avec une solution étonnamment simple.  Par exemple, voici à quoi peut ressembler la création d'un pipeline: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pipeline = make_pipeline(env, stage(A) | stage(B) | stage(C) | stage(D));</code> </pre> <br><p>  Ou, dans un cas plus complexe (qui sera discuté ci-dessous): </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(archiving), stage(distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(alarm_initiator), stage( []( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> alarm_detected &amp; v ) { alarm_distribution( <span class="hljs-built_in"><span class="hljs-built_in">cerr</span></span>, v ); } ) ) ) );</code> </pre> <br><p>  Dans cet article, nous parlerons de l'implémentation d'un tel pipeline DSL.  Nous discuterons principalement des parties liées aux fonctions <code>stage()</code> , <code>broadcast()</code> et <code>operator|()</code> avec plusieurs exemples d'utilisation de modèles C ++.  J'espère donc que ce sera intéressant même pour les lecteurs qui ne connaissent pas SObjectizer (si vous n'avez jamais entendu parler de SObjectizer, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">voici</a> un aperçu de cet outil). </p><a name="habracut"></a><br><h1 id="a-couple-of-words-about-the-used-demo">  Quelques mots sur la démo utilisée </h1><br><p>  L'exemple utilisé dans l'article a été influencé par mon expérience ancienne (et plutôt oubliée) dans le domaine SCADA. </p><br><p>  L'idée de la démo est le traitement des données lues à partir d'un capteur.  Les données sont acquises à partir d'un capteur avec une certaine période, puis ces données doivent être validées (les données incorrectes doivent être ignorées) et converties en certaines valeurs réelles.  Par exemple, les données brutes lues sur un capteur peuvent être deux valeurs entières de 8 bits et ces valeurs doivent être converties en un nombre à virgule flottante. </p><br><p>  Ensuite, les valeurs valides et converties doivent être archivées, distribuées quelque part (sur différents nœuds pour la visualisation, par exemple), vérifiées pour les "alarmes" (si les valeurs sont hors des limites sûres, cela doit être spécialement géré).  Ces opérations sont indépendantes et peuvent être effectuées en parallèle. </p><br><p>  Les opérations liées à l'alarme détectée peuvent également être effectuées en parallèle: une "alarme" doit être déclenchée (pour que la partie de SCADA sur le nœud actuel puisse y réagir) et les informations sur "l'alarme" doivent être distribuées ailleurs (par exemple : stocké dans une base de données historique et / ou visualisé sur l'écran de l'opérateur SCADA). </p><br><p>  Cette logique peut être exprimée sous forme textuelle de cette façon: </p><br><pre> <code class="plaintext hljs">optional(valid_raw_data) = validate(raw_data); if valid_raw_data is not empty then { converted_value = convert(valid_raw_data); do_async archive(converted_value); do_async distribute(converted_value); do_async { optional(suspicious_value) = check_range(converted_value); if suspicious_value is not empty then { optional(alarm) = detect_alarm(suspicious_value); if alarm is not empty then { do_async initiate_alarm(alarm); do_async distribute_alarm(alam); } } } }</code> </pre> <br><p>  Ou, sous forme graphique: </p><br><p><img src="https://habrastorage.org/webt/5z/nm/vv/5znmvvaqnou_qwh808t8vkbrdc8.jpeg"></p><br><p>  C'est un exemple plutôt artificiel, mais il a des choses intéressantes que je veux montrer.  Le premier est la présence d'étages parallèles dans un pipeline (l'opération <code>broadcast()</code> existe juste à cause de cela).  La seconde est la présence d'un état à certains stades.  Par exemple, alarm_detector est une étape avec état. </p><br><h1 id="pipeline-capabilities">  Capacités de pipeline </h1><br><p>  Un pipeline est construit à partir d'étapes distinctes.  Chaque étape est une fonction ou un foncteur du format suivant: </p><br><pre> <code class="cpp hljs">opt&lt;Out&gt; func(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> In &amp;);</code> </pre> <br><p>  ou </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> In &amp;)</span></span></span></span>;</code> </pre> <br><p>  Les étapes qui renvoient un <code>void</code> ne peuvent être utilisées que comme la dernière étape d'un pipeline. </p><br><p>  Les étapes sont liées dans une chaîne.  Chaque étape suivante reçoit un objet retourné par l'étape précédente.  Si l'étape précédente renvoie une valeur <code>opt&lt;Out&gt;</code> vide, l'étape suivante n'est pas appelée. </p><br><p>  Il y a une étape de <code>broadcast</code> spéciale.  Il est construit à partir de plusieurs pipelines.  Une étape de <code>broadcast</code> reçoit un objet de l'étape précédente et le diffuse à chaque pipeline subsidiaire. </p><br><p>  Du point de vue du pipeline, l'étape de <code>broadcast</code> ressemble à une fonction du format suivant: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">void</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">func</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(</span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> In &amp;)</span></span></span></span>;</code> </pre> <br><p>  Puisqu'il n'y a pas de valeur de retour de l'étape de <code>broadcast</code> , une étape de <code>broadcast</code> ne peut être que la dernière étape d'un pipeline. </p><br><h2 id="why-does-the-pipeline-stage-return-an-optional-value">  Pourquoi l'étape du pipeline renvoie-t-elle une valeur facultative? </h2><br><p>  C'est parce qu'il est nécessaire de supprimer certaines valeurs entrantes.  Par exemple, l'étape de <code>validate</code> ne renvoie rien si une valeur brute est incorrecte et il n'y a aucun sens à la gérer. </p><br><p>  Autre exemple: l'étape <code>alarm_detector</code> ne renvoie rien si la valeur suspecte actuelle ne produit pas de nouveau cas d'alarme. </p><br><h1 id="implementation-details">  Détails d'implémentation </h1><br><h2 id="types-and-functions-related-to-the-application-logic">  Types et fonctions liés à la logique d'application </h2><br><p>  Commençons par les types de données et les fonctions liées à la logique d'application.  Dans l'exemple décrit, les types de données suivants sont utilisés pour transmettre des informations d'une étape à une autre: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Raw data from a sensor. struct raw_measure { int m_meter_id; uint8_t m_high_bits; uint8_t m_low_bits; }; // Type of input for validation stage with raw data from a sensor. struct raw_value { raw_measure m_data; }; // Type of input for conversion stage with valid raw data from a sensor. struct valid_raw_value { raw_measure m_data; }; // Data from a sensor after conversion to Celsius degrees. struct calculated_measure { int m_meter_id; float m_measure; }; // The type for result of conversion stage with converted data from a sensor. struct sensor_value { calculated_measure m_data; }; // Type with value which could mean a dangerous level of temperature. struct suspicious_value { calculated_measure m_data; }; // Type with information about detected dangerous situation. struct alarm_detected { int m_meter_id; };</span></span></code> </pre> <br><p>  Une instance de <code>raw_value</code> va à la première étape de notre pipeline.  Cette valeur <code>raw_value</code> contient des informations acquises à partir d'un capteur sous la forme d' <code>raw_measure</code> objet mesure <code>raw_measure</code> .  Ensuite, <code>raw_value</code> est transformé en <code>valid_raw_value</code> .  Puis <code>valid_raw_value</code> transformé en <code>sensor_value</code> avec la valeur réelle d'un capteur sous la forme de <code>calulated_measure</code> .  Si une instance de <code>sensor_value</code> contient une valeur suspecte, alors une instance de <code>suspicious_value</code> est produite.  Et cette valeur <code>suspicious_value</code> peut être transformée en instance <code>alarm_detected</code> plus tard. </p><br><p>  Ou, sous forme graphique: </p><br><p><img src="https://habrastorage.org/webt/dp/dx/rz/dpdxrzpp-rvo05zk-8rwdwucszo.jpeg"></p><br><p>  Maintenant, nous pouvons jeter un oeil à la mise en œuvre de nos étapes de pipeline: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // The first stage of a pipeline. Validation of raw data from a sensor. // // Returns valid_raw_value or nothing if value is invalid. // stage_result_t&lt; valid_raw_value &gt; validation( const raw_value &amp; v ) { if( 0x7 &gt;= v.m_data.m_high_bits ) return make_result&lt; valid_raw_value &gt;( v.m_data ); else return make_empty&lt; valid_raw_value &gt;(); } // // The second stage of a pipeline. Conversion from raw data to a value // in Celsius degrees. // stage_result_t&lt; sensor_value &gt; conversion( const valid_raw_value &amp; v ) { return make_result&lt; sensor_value &gt;( calculated_measure{ v.m_data.m_meter_id, 0.5f * ((static_cast&lt; uint16_t &gt;( v.m_data.m_high_bits ) &lt;&lt; 8) + v.m_data.m_low_bits) } ); } // // Simulation of the data archiving. // void archiving( const sensor_value &amp; v ) { clog &lt;&lt; "archiving (" &lt;&lt; v.m_data.m_meter_id &lt;&lt; "," &lt;&lt; v.m_data.m_measure &lt;&lt; ")" &lt;&lt; endl; } // // Simulation of the data distribution. // void distribution( const sensor_value &amp; v ) { clog &lt;&lt; "distributing (" &lt;&lt; v.m_data.m_meter_id &lt;&lt; "," &lt;&lt; v.m_data.m_measure &lt;&lt; ")" &lt;&lt; endl; } // // The first stage of a child pipeline at third level of the main pipeline. // // Checking for to high value of the temperature. // // Returns suspicious_value message or nothing. // stage_result_t&lt; suspicious_value &gt; range_checking( const sensor_value &amp; v ) { if( v.m_data.m_measure &gt;= 45.0f ) return make_result&lt; suspicious_value &gt;( v.m_data ); else return make_empty&lt; suspicious_value &gt;(); } // // The next stage of a child pipeline. // // Checks for two suspicious_value-es in 25ms time window. // class alarm_detector { using clock = chrono::steady_clock; public : stage_result_t&lt; alarm_detected &gt; operator()( const suspicious_value &amp; v ) { if( m_previous ) if( *m_previous + chrono::milliseconds(25) &gt; clock::now() ) { m_previous = nullopt; return make_result&lt; alarm_detected &gt;( v.m_data.m_meter_id ); } m_previous = clock::now(); return make_empty&lt; alarm_detected &gt;(); } private : optional&lt; clock::time_point &gt; m_previous; }; // // One of last stages of a child pipeline. // Imitates beginning of the alarm processing. // void alarm_initiator( const alarm_detected &amp; v ) { clog &lt;&lt; "=== alarm (" &lt;&lt; v.m_meter_id &lt;&lt; ") ===" &lt;&lt; endl; } // // Another of last stages of a child pipeline. // Imitates distribution of the alarm. // void alarm_distribution( ostream &amp; to, const alarm_detected &amp; v ) { to &lt;&lt; "alarm_distribution (" &lt;&lt; v.m_meter_id &lt;&lt; ")" &lt;&lt; endl; }</span></span></code> </pre> <br><p>  <code>stage_result_t</code> simplement des choses comme <code>stage_result_t</code> , <code>make_result</code> et <code>make_empty</code> , nous en discuterons dans la section suivante. </p><br><p>  J'espère que le code de ces étapes est plutôt trivial.  La seule partie qui nécessite des explications supplémentaires est la mise en œuvre de l'étape <code>alarm_detector</code> . </p><br><p>  Dans cet exemple, une alarme n'est déclenchée que s'il y a au moins deux valeurs <code>suspicious_values</code> dans une fenêtre de temps de 25 ms.  Nous devons donc nous rappeler l'heure de la précédente instance <code>suspicious_value</code> au stade <code>alarm_detector</code> .  En effet, <code>alarm_detector</code> est implémenté en tant que foncteur avec état avec un opérateur d'appel de fonction. </p><br><h2 id="stages-return-sobjectizers-type-instead-of-stdoptional">  Les étapes renvoient le type de SObjectizer au lieu de std :: optional </h2><br><p>  J'ai dit plus tôt que l'étape pouvait renvoyer une valeur facultative.  Mais <code>std::optional</code> n'est pas utilisé dans le code, le type différent <code>stage_result_t</code> peut être vu dans l'implémentation des étapes. </p><br><p>  C'est parce que certains spécificités de SObjectizer jouent ici leur rôle.  Les valeurs retournées seront distribuées sous forme de messages entre les agents de SObjectizer (alias acteurs).  Chaque message dans SObjectizer est envoyé en tant qu'objet alloué dynamiquement.  Nous avons donc ici une sorte d '"optimisation": au lieu de renvoyer <code>std::optional</code> puis d'allouer un nouvel objet message, nous allouons simplement un objet message et lui retournons un pointeur intelligent. </p><br><p>  En fait, <code>stage_result_t</code> n'est qu'un typedef pour l'analogue shared_ptr de SObjectizer: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M &gt; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span> = <span class="hljs-keyword"><span class="hljs-keyword">message_holder_t</span></span>&lt; M &gt;;</code> </pre> <br><p>  Et <code>make_result</code> et <code>make_empty</code> sont que des fonctions d'assistance pour construire <code>stage_result_t</code> avec ou sans valeur réelle à l'intérieur: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt; make_result( Args &amp;&amp;... args ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt;::make(forward&lt; Args &gt;(args)...); } <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> M &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt; make_empty() { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_result_t</span></span>&lt; M &gt;(); }</code> </pre> <br><p>  Pour plus de simplicité, il est sûr de dire que l'étape de <code>validation</code> pourrait être exprimée de cette façon: </p><br><pre> <code class="cpp hljs"><span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt; valid_raw_value &gt; validation( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> raw_value &amp; v ) { <span class="hljs-keyword"><span class="hljs-keyword">if</span></span>( <span class="hljs-number"><span class="hljs-number">0x7</span></span> &gt;= v.m_data.m_high_bits ) <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::make_shared&lt; valid_raw_value &gt;( v.m_data ); <span class="hljs-keyword"><span class="hljs-keyword">else</span></span> <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::<span class="hljs-built_in"><span class="hljs-built_in">shared_ptr</span></span>&lt; valid_raw_value &gt;{}; }</code> </pre> <br><p>  Mais, en raison de la spécificité de SObjectizer, nous ne pouvons pas utiliser <code>std::shared_ptr</code> et <code>so_5::message_holder_t</code> type <code>so_5::message_holder_t</code> .  Et nous cachons ces éléments spécifiques derrière les <code>stage_result_t</code> , <code>make_result</code> et <code>make_empty</code> . </p><br><h2 id="stage_handler_t-and-stage_builder_t-separation">  séparation stage_handler_t et stage_builder_t </h2><br><p>  Un point important de la mise en œuvre du pipeline est la séparation des concepts de <em>gestionnaire d'</em> <em>étape</em> et de <em>constructeur d'étape</em> .  Ceci est fait pour plus de simplicité.  La présence de ces concepts m'a permis d'avoir deux étapes dans la définition du pipeline. </p><br><p>  À la première étape, un utilisateur décrit les étapes du pipeline.  En conséquence, je reçois une instance de <code>stage_t</code> qui contient toutes les étapes du pipeline à l'intérieur. </p><br><p>  À la deuxième étape, un ensemble d'agents SObjectizer sous-jacents est créé.  Ces agents reçoivent des messages avec les résultats des étapes précédentes et appellent des <em>gestionnaires d'étape</em> réels, puis envoient les résultats aux étapes suivantes. </p><br><p>  Mais pour créer cet ensemble d'agents, chaque étape doit avoir un <em>constructeur d'étape</em> .  <em>Le générateur de scène</em> peut être vu comme une fabrique qui crée un agent SObjectizer sous-jacent. </p><br><p>  Nous avons donc la relation suivante: chaque étape du pipeline produit deux objets: le <em>gestionnaire d'étape</em> qui contient la logique liée à l' <em>étape</em> et le <em>générateur d'étape</em> qui crée un agent SObjectizer sous-jacent pour appeler le <em>gestionnaire d'étape</em> au moment approprié: </p><br><p><img src="https://habrastorage.org/webt/gl/tp/nn/gltpnnqhjqslsscxvellndh6n0u.jpeg"></p><br><p>  <em>Le gestionnaire de scène</em> est représenté de la manière suivante: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">class</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stage_handler_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">public</span></span> : <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> traits = <span class="hljs-keyword"><span class="hljs-keyword">handler_traits_t</span></span>&lt; In, Out &gt;; <span class="hljs-keyword"><span class="hljs-keyword">using</span></span> func_type = function&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> traits::output(<span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> traits::input &amp;) &gt;; <span class="hljs-keyword"><span class="hljs-keyword">stage_handler_t</span></span>( func_type handler ) : m_handler( move(handler) ) {} <span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Callable &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_handler_t</span></span>( Callable handler ) : m_handler( handler ) {} <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> traits::<span class="hljs-function"><span class="hljs-function">output </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">operator</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">( </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">const</span></span></span></span><span class="hljs-function"><span class="hljs-params"> </span></span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-params"><span class="hljs-keyword">typename</span></span></span></span><span class="hljs-function"><span class="hljs-params"> traits::input &amp; a )</span></span></span><span class="hljs-function"> </span><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">const</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> m_handler( a ); } <span class="hljs-keyword"><span class="hljs-keyword">private</span></span> : func_type m_handler; };</code> </pre> <br><p>  Où <code>handler_traits_t</code> sont définis de la manière suivante: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // We have to deal with two types of stage handlers: // - intermediate handlers which will return some result (eg some new // message); // - terminal handlers which can return nothing (eg void instead of // stage_result_t&lt;M&gt;); // // This template with specialization defines `input` and `output` // aliases for both cases. // template&lt; typename In, typename Out &gt; struct handler_traits_t { using input = In; using output = stage_result_t&lt; Out &gt;; }; template&lt; typename In &gt; struct handler_traits_t&lt; In, void &gt; { using input = In; using output = void; };</span></span></code> </pre> <br><p>  <em>Le générateur de scène</em> est représenté par juste <code>std::function</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">using</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> = function&lt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>(<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp;, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>) &gt;;</code> </pre> <br><h2 id="helper-types-lambda_traits_t-and-callable_traits_t">  Types d'assistance lambda_traits_t et callable_traits_t </h2><br><p>  Étant donné que les étapes peuvent être représentées par des fonctions ou des foncteurs libres (comme des instances de la classe <code>alarm_detector</code> ou des classes générées par le compilateur anonyme représentant des lambdas), nous avons besoin de quelques aides pour détecter les types d'argument de l'étape et la valeur de retour.  J'ai utilisé le code suivant à cet effet: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // Helper type for `arg_type` and `result_type` alises definition. // template&lt; typename R, typename A &gt; struct callable_traits_typedefs_t { using arg_type = A; using result_type = R; }; // // Helper type for dealing with stateful objects with operator() // (they could be user-defined objects or generated by compiler // like lambdas). // template&lt; typename T &gt; struct lambda_traits_t; template&lt; typename M, typename A, typename T &gt; struct lambda_traits_t&lt; stage_result_t&lt; M &gt;(T::*)(const A &amp;) const &gt; : public callable_traits_typedefs_t&lt; M, A &gt; {}; template&lt; typename A, typename T &gt; struct lambda_traits_t&lt; void (T::*)(const A &amp;) const &gt; : public callable_traits_typedefs_t&lt; void, A &gt; {}; template&lt; typename M, typename A, typename T &gt; struct lambda_traits_t&lt; stage_result_t&lt; M &gt;(T::*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; M, A &gt; {}; template&lt; typename A, typename T &gt; struct lambda_traits_t&lt; void (T::*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; void, A &gt; {}; // // Main type for definition of `arg_type` and `result_type` aliases. // With specialization for various cases. // template&lt; typename T &gt; struct callable_traits_t : public lambda_traits_t&lt; decltype(&amp;T::operator()) &gt; {}; template&lt; typename M, typename A &gt; struct callable_traits_t&lt; stage_result_t&lt; M &gt;(*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; M, A &gt; {}; template&lt; typename A &gt; struct callable_traits_t&lt; void(*)(const A &amp;) &gt; : public callable_traits_typedefs_t&lt; void, A &gt; {};</span></span></code> </pre> <br><p>  J'espère que ce code sera tout à fait compréhensible pour les lecteurs ayant une bonne connaissance de C ++.  Sinon, n'hésitez pas à me demander dans les commentaires, je serai heureux d'expliquer la logique derrière <code>lambda_traits_t</code> et <code>callable_traits_t</code> en détails. </p><br><h2 id="stage-broadcast-and-operator-functions">  fonctions stage (), broadcast () et opérateur | () </h2><br><p>  Maintenant, nous pouvons regarder à l'intérieur des principales fonctions de construction de pipelines.  Mais avant cela, il est nécessaire de jeter un œil à la définition d'une classe de modèle <code>stage_t</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out &gt; <span class="hljs-class"><span class="hljs-keyword"><span class="hljs-class"><span class="hljs-keyword">struct</span></span></span><span class="hljs-class"> </span><span class="hljs-title"><span class="hljs-class"><span class="hljs-title">stage_t</span></span></span><span class="hljs-class"> {</span></span> <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> m_builder; };</code> </pre> <br><p>  C'est une structure très simple qui contient juste <code>stage_bulder_t</code> instance <code>stage_bulder_t</code> .  Les paramètres du modèle ne sont pas utilisés dans <code>stage_t</code> , alors pourquoi sont-ils présents ici? </p><br><p>  Ils sont nécessaires pour la vérification à la compilation de la compatibilité des types entre les étapes du pipeline.  Nous verrons cela bientôt. </p><br><p>  Regardons la fonction de construction de pipeline la plus simple, la <code>stage()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Callable, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::arg_type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::result_type &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out &gt; stage( Callable handler ) { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [h = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(handler)]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> coop.make_agent&lt; <span class="hljs-keyword"><span class="hljs-keyword">a_stage_point_t</span></span>&lt;In, Out&gt; &gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(h), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ) -&gt;so_direct_mbox(); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(builder) }; }</code> </pre> <br><p>  Il reçoit un <em>gestionnaire d'étape</em> réel en tant que paramètre unique.  Il peut s'agir d'un pointeur vers une fonction ou une fonction lambda ou un foncteur.  Les types d'entrée et de sortie de la scène sont déduits automatiquement en raison de la «magie du modèle» derrière le modèle <code>callable_traits_t</code> . </p><br><p>  Une instance de <em>Stage Builder</em> est créée à l'intérieur et cette instance est renvoyée dans un nouvel objet <code>stage_t</code> comme résultat de la fonction <code>stage()</code> .  Un <em>gestionnaire de scène</em> réel est capturé par le <em>constructeur de scènes</em> lambda, il sera ensuite utilisé pour la construction d'un agent SObjectizer sous-jacent (nous en parlerons dans la section suivante). </p><br><p>  La prochaine fonction à examiner est l' <code>operator|()</code> qui concatène deux étapes ensemble et renvoie une nouvelle étape: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out1, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out2 &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out2 &gt; <span class="hljs-keyword"><span class="hljs-keyword">operator</span></span>|( <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out1 &gt; &amp;&amp; prev, <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; Out1, Out2 &gt; &amp;&amp; next ) { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span>{ [prev, next]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage ) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> m = next.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prev.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(m) ); } } }; }</code> </pre> <br><p>  La façon la plus simple d'expliquer la logique de l' <code>operator|()</code> est d'essayer de dessiner une image.  Supposons que nous avons l'expression: </p><br><pre> <code class="cpp hljs">stage(A) | stage(B) | stage(C) | stage(B)</code> </pre> <br><p>  Cette expression sera transformée de cette façon: </p><br><p><img src="https://habrastorage.org/webt/jo/rr/aq/jorraqaawl6y7ju3om7zfq3java.jpeg"></p><br><p>  Là, nous pouvons également voir comment fonctionne la vérification de type à la compilation: la définition de l' <code>operator|()</code> nécessite que le type de sortie du premier étage soit l'entrée du deuxième étage.  Si ce n'est pas le cas, le code ne sera pas compilé. </p><br><p>  Et maintenant, nous pouvons jeter un œil à la fonction de construction de pipeline la plus complexe, la <code>broadcast()</code> .  La fonction elle-même est assez simple: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Rest &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, <span class="hljs-keyword"><span class="hljs-keyword">void</span></span> &gt; broadcast( <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out &gt; &amp;&amp; first, Rest &amp;&amp;... stages ) { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [broadcasts = collect_sink_builders( move(first), forward&lt; Rest &gt;(stages)...)] ( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> ) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">vector</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> &gt; mboxes; mboxes.reserve( broadcasts.size() ); <span class="hljs-keyword"><span class="hljs-keyword">for</span></span>( <span class="hljs-keyword"><span class="hljs-keyword">const</span></span> <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> &amp; b : broadcasts ) mboxes.emplace_back( b( coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>{} ) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> <span class="hljs-keyword"><span class="hljs-keyword">broadcast_mbox_t</span></span>::make( coop.environment(), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(mboxes) ); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(builder) }; }</code> </pre> <br><p>  La principale différence entre une scène ordinaire et une scène de diffusion est que la scène de diffusion doit contenir un vecteur de <em>constructeurs de scènes</em> subsidiaires.  Nous devons donc créer ce vecteur et le transmettre au <em>générateur</em> de <em>scène</em> principal de la diffusion.  Pour cette raison, nous pouvons voir un appel à <code>collect_sink_builders</code> dans la liste de capture d'un lambda à l'intérieur de la fonction <code>broadcast()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [broadcasts = collect_sink_builders( move(first), forward&lt; Rest &gt;(stages)...)]</code> </pre> <br><p>  Si nous examinons <code>collect_sink_builder</code> nous verrons le code suivant: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // Serie of helper functions for building description for // `broadcast` stage. // // Those functions are used for collecting // `builders` functions for every child pipeline. // // Please note that this functions checks that each child pipeline has the // same In type. // template&lt; typename In, typename Out, typename... Rest &gt; void move_sink_builder_to( vector&lt; stage_builder_t &gt; &amp; receiver, stage_t&lt; In, Out &gt; &amp;&amp; first, Rest &amp;&amp;... rest ) { receiver.emplace_back( move( first.m_builder ) ); if constexpr( 0u != sizeof...(rest) ) move_sink_builder_to&lt;In&gt;( receiver, forward&lt; Rest &gt;(rest)... ); } template&lt; typename In, typename Out, typename... Rest &gt; vector&lt; stage_builder_t &gt; collect_sink_builders( stage_t&lt; In, Out &gt; &amp;&amp; first, Rest &amp;&amp;... stages ) { vector&lt; stage_builder_t &gt; receiver; receiver.reserve( 1 + sizeof...(stages) ); move_sink_builder_to&lt;In&gt;( receiver, move(first), std::forward&lt;Rest&gt;(stages)... ); return receiver; }</span></span></code> </pre> <br><p>  La vérification de type à la compilation fonctionne ici aussi: c'est parce qu'un appel à <code>move_sink_builder_to</code> explicitement paramétré par le type 'In'.  Cela signifie qu'un appel sous la forme <code>collect_sink_builders(stage_t&lt;In1, Out1&gt;, stage_t&lt;In2, Out2&gt;, ...)</code> entraînera une erreur de compilation car le compilateur interdit un appel <code>move_sink_builder_to&lt;In1&gt;(receiver, stage_t&lt;In2, Out2&gt;, ...)</code> . </p><br><p>  Je peux également noter que parce que le nombre de pipelines subsidiaires pour <code>broadcast()</code> est connu au moment de la compilation, nous pouvons utiliser <code>std::array</code> au lieu de <code>std::vector</code> et pouvons éviter certaines allocations de mémoire.  Mais <code>std::vector</code> est utilisé ici juste pour plus de simplicité. </p><br><h2 id="relation-between-stages-and-sobjectizers-agentsmboxes">  Relation entre les étapes et les agents / mbox de SObjectizer </h2><br><p>  L'idée derrière la mise en œuvre du pipeline est la création d'un agent distinct pour chaque étape du pipeline.  Un agent reçoit un message entrant, le transmet au <em>gestionnaire d'étape</em> correspondant, analyse le résultat et, si le résultat n'est pas vide, envoie le résultat sous forme de message entrant à l'étape suivante.  Il peut être illustré par le diagramme de séquence suivant: </p><br><p><img src="https://habrastorage.org/webt/om/pn/wy/ompnwye792gjgad7zzgphpv4ctu.png"></p><br><p>  Certaines choses liées à SObjectizer doivent être discutées, au moins brièvement.  Si vous n'êtes pas intéressé par ces détails, vous pouvez ignorer les sections ci-dessous et aller directement à la conclusion. </p><br><h3 id="coop-is-a-group-of-agents-to-work-together">  Coop est un groupe d'agents pour travailler ensemble </h3><br><p>  Les agents sont introduits dans SObjectizer non pas individuellement mais dans des groupes nommés coops.  Une coopérative est un groupe d'agents qui devraient travailler ensemble et il est inutile de continuer le travail si l'un des agents du groupe est absent. </p><br><p>  Ainsi, l'introduction d'agents dans SObjectizer ressemble à la création d'une instance coop, remplissant cette instance avec les agents appropriés, puis enregistrant la coopérative dans SObjectizer. </p><br><p>  Pour cette raison, le premier argument pour un <em>constructeur de scène</em> est une référence à une nouvelle coopérative.  Cette coopérative est créée dans la fonction <code>make_pipeline()</code> (discutée ci-dessous), puis elle est remplie par <em>les constructeurs d'étapes</em> puis enregistrée (à nouveau dans la fonction <code>make_pipeline()</code> ). </p><br><h3 id="message-boxes">  Boîtes de messages </h3><br><p>  SObjectizer implémente plusieurs modèles liés à la concurrence.  Le modèle d'acteur n'est que l'un d'entre eux.  De ce fait, SObjectizer peut différer considérablement des autres frameworks d'acteurs.  L'une des différences est le schéma d'adressage des messages. </p><br><p>  Les messages dans SObjectizer ne s'adressent pas aux acteurs, mais aux <em>boîtes de message</em> (mbox).  Les acteurs doivent s'abonner aux messages d'une mbox.  Si un acteur était abonné à un type de message particulier à partir d'une mbox, il recevrait des messages de ce type: </p><br><p><img src="https://habrastorage.org/webt/o4/bf/ee/o4bfee0lp8hdvks68cas4yjlkgu.png"></p><br><p>  Ce fait est crucial car il est nécessaire d'envoyer des messages d'une étape à l'autre.  Cela signifie que chaque étape doit avoir sa mbox et que la mbox doit être connue pour l'étape précédente. </p><br><p>  Chaque acteur (alias agent) dans SObjectizer a <em>la mbox directe</em> .  Cette mbox n'est associée qu'à l'agent propriétaire et ne peut être utilisée par aucun autre agent.  Les mbox directs des agents créés pour les étapes seront utilisés pour l'interaction des étapes. </p><br><p>  La fonctionnalité spécifique de ce SObjectizer dicte certains détails d'implémentation du pipeline. </p><br><p>  Le premier est le fait que le <em>constructeur de scènes</em> dispose du prototype suivant: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> builder(<span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp;, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span>);</code> </pre> <br><p>  Cela signifie que le <em>générateur d'étape</em> reçoit une mbox de l'étape suivante et doit créer un nouvel agent qui enverra les résultats de l'étape à cette mbox.  Une mbox du nouvel agent doit être retournée par le <em>générateur de scène</em> .  Cette mbox sera utilisée pour la création d'un agent pour l'étape précédente. </p><br><p>  Le second est le fait que les agents des étapes sont créés dans l'ordre de réserve.  Cela signifie que si nous avons un pipeline: </p><br><pre> <code class="cpp hljs">stage(A) | stage(B) | stage(C)</code> </pre> <br><p>  Un agent pour l'étape C sera d'abord créé, puis sa mbox sera utilisée pour la création d'un agent pour l'étape B, puis la mbox de l'agent de l'étape B sera utilisée pour la création d'un agent pour l'étape A. </p><br><p>  Il convient également de noter que l' <code>operator|()</code> ne crée pas d'agents: </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span>{ [prev, next]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage ) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">auto</span></span> m = next.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ); <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> prev.m_builder( coop, <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(m) ); } }</code> </pre> <br><p>  L' <code>operator|()</code> crée un générateur qui n'appelle que d'autres générateurs mais n'introduit pas d'agents supplémentaires.  Donc pour le cas: </p><br><pre> <code class="cpp hljs">stage(A) | stage(B)</code> </pre> <br><p>  seuls deux agents seront créés (pour A-stage et B-stage) puis ils seront liés ensemble dans le <em>générateur de scène</em> créé par l' <code>operator|()</code> . </p><br><h3 id="there-is-no-agent-for-broadcast-implementation">  Il n'y a pas d'agent pour la mise en œuvre de <code>broadcast()</code> </h3><br><p>  Une façon évidente de mettre en œuvre une étape de diffusion consiste à créer un agent spécial qui recevra un message entrant, puis à renvoyer ce message à une liste de mbox de destination.  Cette méthode a <a href="">été utilisée dans la première implémentation</a> du pipeline DSL décrit. </p><br><p>  Mais notre projet compagnon, <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">so5extra</a> , a maintenant une variante spéciale de mbox: en diffuser une.  Cette mbox fait exactement ce qui est requis ici: elle prend un nouveau message et le livre à un ensemble de mbox de destination. </p><br><p>  Pour cette raison, il n'est pas nécessaire de créer un agent de diffusion distinct, nous pouvons simplement utiliser la diffusion mbox de so5extra: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // A special mbox for broadcasting of a message to a set of destination // mboxes. // using broadcast_mbox_t = so_5::extra::mboxes::broadcast::fixed_mbox_template_t&lt;&gt;; ... // // Inside the broadcast() function: // stage_builder_t builder{ [broadcasts = collect_sink_builders( move(first), forward&lt; Rest &gt;(stages)...)] ( coop_t &amp; coop, mbox_t ) -&gt; mbox_t { vector&lt; mbox_t &gt; mboxes; mboxes.reserve( broadcasts.size() ); for( const auto &amp; b : broadcasts ) mboxes.emplace_back( b( coop, mbox_t{} ) ); // That is the creation of broadcasting mbox instance. return broadcast_mbox_t::make( coop.environment(), std::move(mboxes) ); } };</span></span></code> </pre> <br><h3 id="implementation-of-stage-agent">  Implémentation de stage-agent </h3><br><p>  Maintenant, nous pouvons jeter un oeil à la mise en œuvre de l'agent de scène: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// // An agent which will be used as intermediate or terminal pipeline stage. // It will receive input message, call the stage handler and pass // handler result to the next stage (if any). // template&lt; typename In, typename Out &gt; class a_stage_point_t final : public agent_t { public : a_stage_point_t( context_t ctx, stage_handler_t&lt; In, Out &gt; handler, mbox_t next_stage ) : agent_t{ ctx } , m_handler{ move( handler ) } , m_next{ move(next_stage) } {} void so_define_agent() override { if( m_next ) // Because there is the next stage the appropriate // message handler will be used. so_subscribe_self().event( [=]( const In &amp; evt ) { auto r = m_handler( evt ); if( r ) so_5::send( m_next, r ); } ); else // There is no next stage. A very simple message handler // will be used for that case. so_subscribe_self().event( [=]( const In &amp; evt ) { m_handler( evt ); } ); } private : const stage_handler_t&lt; In, Out &gt; m_handler; const mbox_t m_next; }; // // A specialization of a_stage_point_t for the case of terminal stage of // a pipeline. This type will be used for stage handlers with void // return type. // template&lt; typename In &gt; class a_stage_point_t&lt; In, void &gt; final : public agent_t { public : a_stage_point_t( context_t ctx, stage_handler_t&lt; In, void &gt; handler, mbox_t next_stage ) : agent_t{ ctx } , m_handler{ move( handler ) } { if( next_stage ) throw std::runtime_error( "sink point cannot have next stage" ); } void so_define_agent() override { so_subscribe_self().event( [=]( const In &amp; evt ) { m_handler( evt ); } ); } private : const stage_handler_t&lt; In, void &gt; m_handler; };</span></span></code> </pre> <br><p>  C'est plutôt trivial si vous comprenez les bases du SObjectizer.  Sinon ce sera assez difficile à expliquer en quelques mots (alors n'hésitez pas à poser des questions dans les commentaires). </p><br><p>  L'implémentation principale de l'agent <code>a_stage_point_t</code> crée un abonnement à un message de type In.  Lorsqu'un message de ce type arrive, le <em>gestionnaire d'étape</em> est appelé.  Si le <em>gestionnaire d'étape</em> renvoie un résultat réel, le résultat est envoyé à l'étape suivante (si cette étape existe). </p><br><p>  Il existe également une version de <code>a_stage_point_t</code> pour le cas où l'étape correspondante est l'étape terminale et il ne peut pas y avoir l'étape suivante. </p><br><p>  L'implémentation de <code>a_stage_point_t</code> peut sembler un peu compliqué mais croyez-moi, c'est l'un des agents les plus simples que j'ai écrits. </p><br><h2 id="make_pipeline-function">  Fonction make_pipeline () </h2><br><p>  Il est temps de discuter de la dernière fonction de construction de pipeline, la <code>make_pipeline()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span>... Args &gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> make_pipeline( <span class="hljs-comment"><span class="hljs-comment">// SObjectizer Environment to work in. so_5::environment_t &amp; env, // Definition of a pipeline. stage_t&lt; In, Out &gt; &amp;&amp; sink, // Optional args to be passed to make_coop() function. Args &amp;&amp;... args ) { auto coop = env.make_coop( forward&lt; Args &gt;(args)... ); auto mbox = sink.m_builder( *coop, mbox_t{} ); env.register_coop( move(coop) ); return mbox; }</span></span></code> </pre> <br><p>  Il n'y a pas de magie ni de surprise ici.  Nous avons juste besoin de créer une nouvelle coopérative pour les agents sous-jacents du pipeline, de remplir cette coopérative avec des agents en appelant un <em>constructeur de</em> niveau supérieur, puis d'enregistrer cette coopérative dans SObjectizer.  C'est tout. </p><br><p>  Le résultat de <code>make_pipeline()</code> est la mbox de l'étape la plus à gauche (la première) du pipeline.  Cette mbox doit être utilisée pour envoyer des messages au pipeline. </p><br><h1 id="the-simulation-and-experiments-with-it">  La simulation et ses expériences </h1><br><p>  Nous avons donc maintenant des types de données et des fonctions pour notre logique d'application et les outils pour enchaîner ces fonctions dans un pipeline de traitement des données.  Faisons-le et voyons un résultat: </p><br><pre> <code class="cpp hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">int</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">main</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">()</span></span></span><span class="hljs-function"> </span></span>{ <span class="hljs-comment"><span class="hljs-comment">// Launch SObjectizer in a separate thread. wrapped_env_t sobj; // Make a pipeline. auto pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(archiving), stage(distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(alarm_initiator), stage( []( const alarm_detected &amp; v ) { alarm_distribution( cerr, v ); } ) ) ) ); // Send messages to a pipeline in a loop with 10ms delays. for( uint8_t i = 0; i &lt; static_cast&lt; uint8_t &gt;(250); i += 10 ) { send&lt; raw_value &gt;( pipeline, raw_measure{ 0, 0, i } ); std::this_thread::sleep_for( chrono::milliseconds{10} ); } }</span></span></code> </pre> <br><p>  Si nous exécutons cet exemple, nous verrons la sortie suivante: </p><br><pre> <code class="plaintext hljs">archiving (0,0) distributing (0,0) archiving (0,5) distributing (0,5) archiving (0,10) distributing (0,10) archiving (0,15) distributing (0,15) archiving (0,20) distributing (0,20) archiving (0,25) distributing (0,25) archiving (0,30) distributing (0,30) ... archiving (0,105) distributing (0,105) archiving (0,110) distributing (0,110) === alarm (0) === alarm_distribution (0) archiving (0,115) distributing (0,115) archiving (0,120) distributing (0,120) === alarm (0) === alarm_distribution (0)</code> </pre> <br><p>  Ça marche. </p><br><p>  Mais il semble que les étapes de notre pipeline fonctionnent séquentiellement, l'une après l'autre, n'est-ce pas? </p><br><p>  Oui, ça l'est.  En effet, tous les agents de pipeline sont liés au répartiteur par défaut de SObjectizer.  Et ce répartiteur utilise un seul thread de travail pour le traitement des messages de tous les agents. </p><br><p>  Mais cela peut être facilement changé.  <code>make_pipeline()</code> simplement un argument supplémentaire à l' <code>make_pipeline()</code> de <code>make_pipeline()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// Make a pipeline. auto pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(archiving), stage(distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(alarm_initiator), stage( []( const alarm_detected &amp; v ) { alarm_distribution( cerr, v ); } ) ) ), disp::thread_pool::make_dispatcher( sobj.environment() ).binder( disp::thread_pool::bind_params_t{}.fifo( disp::thread_pool::fifo_t::individual ) ) );</span></span></code> </pre> <br><p>  Cela crée un nouveau pool de threads et lie tous les agents de pipeline à ce pool.  Chaque agent sera servi par la piscine indépendamment des autres agents. </p><br><p>  Si nous exécutons l'exemple modifié, nous pouvons voir quelque chose comme ça: </p><br><pre> <code class="plaintext hljs">archiving (0,0) distributing (0,0) distributing (0,5) archiving (0,5) archiving (0,10) distributing (0,10) distributing (archiving (0,15) 0,15) archiving (0,20) distributing (0,20) archiving (0,25) distributing (0,25) archiving (0,distributing (030) ,30) ... archiving (0,distributing (0,105) 105) archiving (0,alarm_distribution (0) distributing (0,=== alarm (0) === 110) 110) archiving (distributing (0,0,115) 115) archiving (distributing (=== alarm (0) === 0alarm_distribution (0) 0,120) ,120)</code> </pre> <br><p>  Nous pouvons donc voir que les différentes étapes du pipeline fonctionnent en parallèle. </p><br><p>  Mais est-il possible d'aller plus loin et d'avoir la possibilité de lier des étapes à différents répartiteurs? </p><br><p>  Oui, c'est possible, mais nous devons implémenter une autre surcharge pour la fonction <code>stage()</code> : </p><br><pre> <code class="cpp hljs"><span class="hljs-keyword"><span class="hljs-keyword">template</span></span>&lt; <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Callable, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> In = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::arg_type, <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> Out = <span class="hljs-keyword"><span class="hljs-keyword">typename</span></span> <span class="hljs-keyword"><span class="hljs-keyword">callable_traits_t</span></span>&lt; Callable &gt;::result_type &gt; <span class="hljs-keyword"><span class="hljs-keyword">stage_t</span></span>&lt; In, Out &gt; stage( <span class="hljs-keyword"><span class="hljs-keyword">disp_binder_shptr_t</span></span> disp_binder, Callable handler ) { <span class="hljs-keyword"><span class="hljs-keyword">stage_builder_t</span></span> builder{ [binder = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(disp_binder), h = <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(handler)]( <span class="hljs-keyword"><span class="hljs-keyword">coop_t</span></span> &amp; coop, <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> next_stage) -&gt; <span class="hljs-keyword"><span class="hljs-keyword">mbox_t</span></span> { <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> coop.make_agent_with_binder&lt; <span class="hljs-keyword"><span class="hljs-keyword">a_stage_point_t</span></span>&lt;In, Out&gt; &gt;( <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(binder), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(h), <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(next_stage) ) -&gt;so_direct_mbox(); } }; <span class="hljs-keyword"><span class="hljs-keyword">return</span></span> { <span class="hljs-built_in"><span class="hljs-built_in">std</span></span>::move(builder) }; }</code> </pre> <br><p>  Cette version de <code>stage()</code> accepte non seulement un <em>gestionnaire de stage</em> mais aussi un classeur de répartiteur. Dispatcher binder is a way to bind an agent to the particular dispatcher. So to assign a stage to a specific working context we can create an appropriate dispatcher and then pass the binder to that dispatcher to <code>stage()</code> function. Let's do that: </p><br><pre> <code class="cpp hljs"><span class="hljs-comment"><span class="hljs-comment">// An active_obj dispatcher to be used for some stages. auto ao_disp = disp::active_obj::make_dispatcher( sobj.environment() ); // Make a pipeline. auto pipeline = make_pipeline( sobj.environment(), stage(validation) | stage(conversion) | broadcast( stage(ao_disp.binder(), archiving), stage(ao_disp.binder(), distribution), stage(range_checking) | stage(alarm_detector{}) | broadcast( stage(ao_disp.binder(), alarm_initiator), stage(ao_disp.binder(), []( const alarm_detected &amp; v ) { alarm_distribution( cerr, v ); } ) ) ), disp::one_thread::make_dispatcher( sobj.environment() ).binder() );</span></span></code> </pre> <br><p> In that case stages <code>archiving</code> , <code>distribution</code> , <code>alarm_initiator</code> and <code>alarm_distribution</code> will work on own worker threads. All other stages will work on the same single worker thread. </p><br><h1 id="the-conclusion"> The conclusion </h1><br><p> This was an interesting experiment and I was surprised how easy SObjectizer could be used in something like reactive programming or data-flow programming. </p><br><p> However, I don't think that pipeline DSL can be practically meaningful. It's too simple and, maybe not flexible enough. But, I hope, it can be a base for more interesting experiments for those why need to deal with different workflows and data-processing pipelines. At least as a base for some ideas in that area. C++ language a rather good here and some (not so complicated) template magic can help to catch various errors at compile-time. </p><br><p> In conclusion, I want to say that we see SObjectizer not as a specialized tool for solving a particular problem, but as a basic set of tools to be used in solutions for different problems. And, more importantly, that basic set can be extended for your needs. Just take a look at <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">SObjectizer</a> , try it, and share your feedback. Maybe you missed something in SObjectizer? Perhaps you don't like something? <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Tell us</a> , and we can try to help you. </p><br><p> If you want to help further development of SObjectizer, please share a reference to it or to this article somewhere you want (Reddit, HackerNews, LinkedIn, Facebook, Twitter, ...). The more attention and the more feedback, the more new features will be incorporated into SObjectizer. </p><br><p> And many thanks for reading this ;) </p><br><p>  PS. The source code for that example can be found in <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">that repository</a> . </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr460123/">https://habr.com/ru/post/fr460123/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr460113/index.html">Quelques histoires de la vie de JSOC CERT, ou Unbanal forensics</a></li>
<li><a href="../fr460115/index.html">Dix ans de programmation à Erlang</a></li>
<li><a href="../fr460117/index.html">Les plus gros clients en Russie sont-ils un gros jackpot ou un mal de tête? Expérience AGIMA</a></li>
<li><a href="../fr460119/index.html">Erreurs que l'analyse de code statique ne trouve pas car il n'est pas utilisé</a></li>
<li><a href="../fr460121/index.html">Erreurs que l'analyse de code statique ne trouve pas car il n'est pas utilisé</a></li>
<li><a href="../fr460125/index.html">Node.js ou Java: performances, ressources, contrôle de flux, popularité et expérience personnelle</a></li>
<li><a href="../fr460129/index.html">Robots et fraises: comment l'IA augmente les rendements sur le terrain</a></li>
<li><a href="../fr460131/index.html">Pare-feu Sophos XG: du ME classique au NGFW avec réponse automatique aux incidents de sécurité des informations</a></li>
<li><a href="../fr460133/index.html">Kotlin / Everywhere - Pratique vitrine: 31 juillet</a></li>
<li><a href="../fr460135/index.html">Semaine de sécurité 29: Vulnérabilité liée au zoom, à la sécurité et aux drames</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>