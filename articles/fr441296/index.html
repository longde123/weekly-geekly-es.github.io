<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👩🏽‍🚀 🤘🏻 🐶 OpenStreetMap Part Medium: Visualisation de données cachées 🙏🏽 👨🏾‍🌾 👲🏿</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Nous sommes tous habitués, en regardant les substrats de base classiques sur Internet, à voir les colonies, les routes et leurs noms, les maisons avec...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>OpenStreetMap Part Medium: Visualisation de données cachées</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/441296/"><p>  Nous sommes tous habitués, en regardant les substrats de base classiques sur Internet, à voir les colonies, les routes et leurs noms, les maisons avec leur nombre.  Mais même ces objets de propriété ont plus qu'un nom ou un numéro.  Pour les bâtiments, il s'agit d'un certain nombre d'étages, pour les routes il y a un certain nombre de voies et pour les villes, d'un certain nombre d'habitants.  Mais ce n'est que la pointe de l'iceberg - OpenStreetMap est si riche en une variété de données spatiales que vous n'en avez tout simplement jamais vu.  Et sans rendus spécialisés, vous ne verrez jamais, sauf si, lors de la modification des données, vous êtes intéressé par le type de ligne avec des balises étranges.  Aujourd'hui, nous allons créer un rendu ultra-spécialisé pour montrer les quartiers forestiers. </p><br><p><img src="https://habrastorage.org/webt/ae/7r/_m/ae7r_mo4w4x-v8amg0uqh15vjii.png" alt="Quartiers forestiers"></p><a name="habracut"></a><br><p>  Étape 1. Enquêtes. <br>  Vous pouvez bien sûr deviner avec votre doigt dans le ciel comment ils pourraient être indiqués, mais il est plus sûr d’aller sur wiki-osm.  Et là, nous pouvons trouver ce qui suit: <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">border = forest_compartment</a> </p><br><p> Par conséquent, les blocs forestiers sont désignés par des polygones avec la balise <code>boundary=forest_compartment</code> .  Certes, il est précisé qu'au départ, il était désigné comme <code>boundary=forestry_compartment</code> , mais il était moins alphabétisé.  Et comme le nombre d'utilisations avec l'ancienne désignation est important (selon taginfo environ 4 000 fois), nous ne l'escompterons pas. </p><br><p>  Étape 2. Données. <br>  <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Prenez les</a> données de <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">Geofabrik</a> .  Téléchargez un fichier pour toute la Russie - <code>russia-latest.osm.pbf</code> .  En utilisant <code>osmconvert</code> nous obtenons les données au format o5m pour un filtrage ultérieur. </p><br><pre> <code class="plaintext hljs">osmconvert russia-latest.osm.pbf -o=russia-latest.o5m</code> </pre> <br><p>  Maintenant, nous <code>osmfilter</code> uniquement les données dont nous avons besoin avec <code>osmfilter</code> </p><br><pre> <code class="plaintext hljs">osmfilter russia-latest.o5m --keep="boundary=forest_compartment =forestry_compartment" -o=forest_compartment-local.o5m</code> </pre> <br><p>  Étape 3. Tuiles vectorielles. <br>  Une petite théorie brève.  L'ancienne approche consiste à demander des données à une grande base de données, à en obtenir une image, à la sauvegarder afin de la donner au client à l'avenir.  Dans la nouvelle, à partir d'une grande base de données, demandez un peu de données et enregistrez-les pour une transmission ultérieure au client.  Et laissez le client les transformer en image.  Profit pour ainsi dire sur le visage - nous avons transféré la charge du rendu de l'image sur les épaules du client.  Parmi les inconvénients - sur la cafetière, vous ne pourrez peut-être pas voir la carte, vous avez besoin du support WebGL. </p><br><p>  Mapbox a donc proposé un format pour les tuiles vectorielles et un conteneur pour celles-ci sous la forme d'une base de données sqlite.  Par conséquent, maintenant ce n'est pas une dispersion de fichiers dans des dossiers, mais un fichier solitaire soigné.  Une tuile vectorielle contient des couches logiques (maisons, routes, etc.) constituées de géométrie et d'attributs. </p><br><p>  Ici, nous les préparerons pour nos quartiers forestiers.  J'utiliserai l'outil <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">TileMaker</a> .  Il reçoit les données OSM au format pbf en entrée, donc après le filtrage, nous devons reconvertir ce format. </p><br><pre> <code class="plaintext hljs">osmconvert forest_compartment-local.o5m -o=forest_compartment-local.pbf</code> </pre> <br><p>  Nous devons maintenant expliquer à TileMaker quelles couches et avec quels attributs nous avons besoin, selon la <a href="">documentation</a> . </p><br><p>  Étape 4. Calques? <br>  Et de quelles couches avons-nous besoin?  Et cela dépend de ce que nous montrons.  C'est-à-dire  Tout d'abord, nous devons en quelque sorte imaginer la partie visuelle.  Et comment y parvenir à partir des données disponibles.  À partir des données OSM, nous avons une grille de polygones et leurs attributs.  Les attributs ont le nom de la forêt et le numéro du trimestre. </p><br><p><img src="https://habrastorage.org/webt/ii/mb/6v/iimb6vqew9cch0kpobg2ko4qej8.png" alt="Données OSM brutes"></p><br><p>  À partir de là, le moyen le plus simple consiste à afficher le trimestre et à le signer avec votre numéro.  C'est-à-dire  nous avons besoin d'une couche polygonale, au centre du polygone nous afficherons une inscription avec son numéro. <br>  Et puis la première fonctionnalité des tuiles vectorielles apparaît.  Lorsqu'un grand polygone source tombe dans différentes tuiles, seules ses parties tombent dans les tuiles.  Et lors du rendu, il s'avère qu'il s'agit de deux polygones différents, respectivement, pour eux, il y aura deux signatures au centre de leurs moitiés. </p><br><p><img src="https://habrastorage.org/webt/qp/av/s-/qpavs-uusqadrvzpisc2ukozii4.png"></p><br><p>  Par conséquent, pour les tuiles vectorielles, une couche séparée avec des inscriptions est préparée, quand il y a encore toutes les informations nécessaires sur la géométrie. </p><br><p>  Conclusion: nous avons besoin de deux couches, un polygone pour le remplissage et un point pour la signature.  Créez le fichier <code>config.json</code> . </p><br><pre> <code class="json hljs">{ <span class="hljs-attr"><span class="hljs-attr">"layers"</span></span>: { }, <span class="hljs-attr"><span class="hljs-attr">"settings"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"minzoom"</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-attr"><span class="hljs-attr">"maxzoom"</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-attr"><span class="hljs-attr">"basezoom"</span></span>: <span class="hljs-number"><span class="hljs-number">14</span></span>, <span class="hljs-attr"><span class="hljs-attr">"include_ids"</span></span>: <span class="hljs-literal"><span class="hljs-literal">false</span></span>, <span class="hljs-attr"><span class="hljs-attr">"author"</span></span>: <span class="hljs-string"><span class="hljs-string">"freeExec"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"name"</span></span>: <span class="hljs-string"><span class="hljs-string">"Forest Compartment RUS"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"license"</span></span>: <span class="hljs-string"><span class="hljs-string">"ODbL 1.0"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"version"</span></span>: <span class="hljs-string"><span class="hljs-string">"0.1"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Forest compartment from OpenStreetMap"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"compress"</span></span>: <span class="hljs-string"><span class="hljs-string">"gzip"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"metadata"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"attribution"</span></span>: <span class="hljs-string"><span class="hljs-string">"&lt;a href=\"http://www.openstreetmap.org/copyright/\" target=\"_blank\"&gt;&amp;copy;  OpenStreetMap&lt;/a&gt;"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"json"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"vector_layers"</span></span>: [ ] } } } }</code> </pre> <br><p>  Dans la section des calques, spécifiez ce dont nous avons besoin </p><br><pre> <code class="json hljs"> <span class="hljs-string"><span class="hljs-string">"layers"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"forest_compartment"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"minzoom"</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-attr"><span class="hljs-attr">"maxzoom"</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span> }, <span class="hljs-attr"><span class="hljs-attr">"forest_compartment_label"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"minzoom"</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span>, <span class="hljs-attr"><span class="hljs-attr">"maxzoom"</span></span>: <span class="hljs-number"><span class="hljs-number">11</span></span> } },</code> </pre> <br><p>  Les noms des couches sont indiqués et à quelle échelle nous allons les afficher. </p><br><pre> <code class="json hljs"> <span class="hljs-string"><span class="hljs-string">"json"</span></span>: { <span class="hljs-attr"><span class="hljs-attr">"vector_layers"</span></span>: [ { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"forest_compartment"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Compartment"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"fields"</span></span>: {}}, { <span class="hljs-attr"><span class="hljs-attr">"id"</span></span>: <span class="hljs-string"><span class="hljs-string">"forest_compartment_label"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"description"</span></span>: <span class="hljs-string"><span class="hljs-string">"Compartment"</span></span>, <span class="hljs-attr"><span class="hljs-attr">"fields"</span></span>: {<span class="hljs-attr"><span class="hljs-attr">"ref"</span></span>:<span class="hljs-string"><span class="hljs-string">"String"</span></span>}} ] }</code> </pre> <br><p>  Dans les métadonnées, nous indiquons au futur visualiseur quels attributs sont disponibles avec nous.  Pour la couche tag, nous aurons le numéro de trimestre en <code>ref</code> . </p><br><p>  Étape 5. Traitement des données. <br>  À cet effet, un script en langage <code>lua</code> est utilisé, qui décidera quels objets des données OSM nous avons besoin, dans quelle couche les envoyer et avec quels attributs. </p><br><p>  Commençons par le modèle de fichier <code>process.lua</code> . </p><br><pre> <code class="lua hljs"><span class="hljs-comment"><span class="hljs-comment">-- Nodes will only be processed if one of these keys is present node_keys = { } -- Initialize Lua logic function init_function() end -- Finalize Lua logic() function exit_function() end -- Assign nodes to a layer, and set attributes, based on OSM tags function node_function(node) end -- Similarly for ways function way_function(way) end</span></span></code> </pre> <br><p>  Ce que nous avons ici: </p><br><p>  node_keys - il y a beaucoup de points dans les données OSM, si nous poussons chacun ce script, alors le traitement prendra très longtemps.  Il s'agit d'un filtre qui nous indique les points clés qui nous intéressent. </p><br><p>  function node_function (node) - la fonction sera appelée sur chaque point intéressant pour nous à partir du paragraphe précédent.  Ici, nous devons décider quoi en faire. </p><br><p>  function way_function (way) - une fonction qui sera appelée sur n'importe quelle ligne et sur les relations avec les types multipolygone et limite, car  ils sont considérés comme des objets surfaciques. </p><br><p>  Nous commençons à écrire du code.  Tout d'abord, nous indiquons de quels points nous avons besoin: </p><br><pre> <code class="lua hljs">node_keys = { <span class="hljs-string"><span class="hljs-string">"boundary"</span></span> }</code> </pre> <br><p>  Maintenant, nous écrivons la fonction pour les traiter: </p><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">node_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(node)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> boundary = node:Find(<span class="hljs-string"><span class="hljs-string">"boundary"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> boundary == <span class="hljs-string"><span class="hljs-string">"forestry_compartment"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> boundary == <span class="hljs-string"><span class="hljs-string">"forest_compartment"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> ref = node:Find(<span class="hljs-string"><span class="hljs-string">"ref"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ref ~= <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> node:Layer(<span class="hljs-string"><span class="hljs-string">"forest_compartment_label"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) node:Attribute(<span class="hljs-string"><span class="hljs-string">"ref"</span></span>, ref) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Que se passe-t-il ici: nous lisons la valeur de la clé de <code>boundary</code> via le <code>node:Find("")</code> .  S'il s'agit de <code>forest_compartment</code> , lisez le numéro du trimestre dans la balise <code>ref</code> .  S'il n'est pas vide, cet objet est ajouté à notre calque avec des étiquettes, via <code>Layer("_", ___)</code> .  Dans l'attribut de la couche <code>ref</code> , nous enregistrons le numéro de trimestre. <br>  Presque aussi simple pour les blocs carrés: </p><br><pre> <code class="lua hljs"><span class="hljs-function"><span class="hljs-keyword"><span class="hljs-function"><span class="hljs-keyword">function</span></span></span><span class="hljs-function"> </span><span class="hljs-title"><span class="hljs-function"><span class="hljs-title">way_function</span></span></span><span class="hljs-params"><span class="hljs-function"><span class="hljs-params">(way)</span></span></span></span> <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> boundary = way:Find(<span class="hljs-string"><span class="hljs-string">"boundary"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> way:IsClosed() <span class="hljs-keyword"><span class="hljs-keyword">and</span></span> ( boundary == <span class="hljs-string"><span class="hljs-string">"forestry_compartment"</span></span> <span class="hljs-keyword"><span class="hljs-keyword">or</span></span> boundary == <span class="hljs-string"><span class="hljs-string">"forest_compartment"</span></span> ) <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> way:Layer(<span class="hljs-string"><span class="hljs-string">"forest_compartment"</span></span>, <span class="hljs-literal"><span class="hljs-literal">true</span></span>) way:AttributeNumeric(<span class="hljs-string"><span class="hljs-string">"nomerge"</span></span>, way:Id()) <span class="hljs-keyword"><span class="hljs-keyword">local</span></span> ref = way:Find(<span class="hljs-string"><span class="hljs-string">"ref"</span></span>) <span class="hljs-keyword"><span class="hljs-keyword">if</span></span> ref ~= <span class="hljs-string"><span class="hljs-string">""</span></span> <span class="hljs-keyword"><span class="hljs-keyword">then</span></span> way:LayerAsCentroid(<span class="hljs-string"><span class="hljs-string">"forest_compartment_label"</span></span>, <span class="hljs-literal"><span class="hljs-literal">false</span></span>) way:Attribute(<span class="hljs-string"><span class="hljs-string">"ref"</span></span>, ref) <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span> <span class="hljs-keyword"><span class="hljs-keyword">end</span></span></code> </pre> <br><p>  Ici, nous vérifions en outre que la ligne est fermée, car  il arrive que des balises soient présentes simplement sur des segments.  Il convient de noter que la couche <code>forest_compartment</code> zone (par conséquent, le deuxième argument de la fonction <code>Layer("", true))</code> , et nous prenons la place de la signature comme centre de la <code>LayerAsCentroid</code> . </p><br><p>  Il convient également de prêter attention à l'attribut que nous ajoutons, bien que nous ne l'ayons pas spécifié dans la configuration.  Il est nécessaire de vaincre une autre fonctionnalité, cette fois déjà le convertisseur TileMaker (bien que le paramètre pour le désactiver soit apparu dans la nouvelle version). </p><br><p>  La particularité est que pour l'optimisation, lorsqu'il y a plusieurs objets avec les mêmes attributs dans une couche, le convertisseur pour eux combine les géométries en une seule.  Par exemple, nous avons une rue composée de trois segments distincts, qui seront par conséquent envoyés trois fois pour être rendus.  C'est plus long, par rapport au fait que nous enverrions un objet au rendu, mais avec une géométrie légèrement plus complexe (en les unissant tous). </p><br><p>  Dans notre cas, tous les quartiers adjacents seraient réunis en un seul grand polygone, mais nous n'en avons pas besoin.  Par conséquent, nous ajoutons le numéro d'objet afin qu'ils soient différents et non combinés. </p><br><p>  Il est maintenant temps de commencer le processus de création de tuiles vectorielles. </p><br><pre> <code class="plaintext hljs">tilemaker forest_compartment-local.pbf --output forest_compartment-local.mbtiles</code> </pre> <br><p>  Par conséquent, nous devrions avoir le fichier <code>forest_compartment-local.mbtiles</code> </p><br><p>  Étape 6. Créez un style. <br>  Nous créons un compte sur <a href="https://translate.googleusercontent.com/translate_c?depth=1&amp;pto=nl&amp;rurl=translate.google.com&amp;sl=ru&amp;sp=nmt4&amp;tl=fr&amp;u=">mapbox.com</a> .  Dans Mapbox Studio, dans la section Ensemble de tuiles, créez un nouveau ensemble de tuiles en faisant glisser notre fichier créé précédemment dans la fenêtre de téléchargement.  En une minute, il doit être traité et ajouté à la liste. </p><br><p>  Maintenant, nous allons dans la section Styles et en créons un nouveau basé sur la lumière finie, afin que nous puissions voir les principaux éléments de la carte, tels que les routes, les colonies, etc.  Nous partons pour Cheboksary car on a vu des blocs forestiers. </p><br><p>  Nous descendons au niveau 11 de l'échelle (nous n'avons créé que des tuiles pour lui) et cliquez sur le bouton Ajouter une couche.  Dans l'onglet source de données, nous trouvons notre source de données <code>forest_compartment-local-XXXXX</code> , nous y sélectionnons la couche de polygones.  Il doit être surligné en vert à droite. </p><br><p><img src="https://habrastorage.org/webt/dq/ka/-h/dqka-h_wx2qcqz-xbncxutb1exo.png" alt="Ajout de calque"></p><br><p>  Ensuite, dans l'onglet Style, définissez la couleur de remplissage sur vert et le trait sur brun. </p><br><p><img src="https://habrastorage.org/webt/zb/h_/zp/zbh_zpmk7tmktabdpbfvxoekbeu.png" alt="Réglage des couleurs"></p><br><p>  Reste maintenant à ajouter la signature.  Ajoutez une nouvelle couche, mais cette fois, nous sélectionnons <code>forest_compartment_label</code> dans les données et sélectionnons le <code>symbol</code> type, les chiffres devraient apparaître à droite. </p><br><p><img src="https://habrastorage.org/webt/er/gh/_x/ergh_x_oj7bjv0redgs9bf9ylta.png" alt="Ajoutez un calque d'étiquette."></p><br><p>  Dans l'onglet style, spécifiez que nous devons afficher notre attribut <code>ref</code> . </p><br><p><img src="https://habrastorage.org/webt/zl/7r/nq/zl7rnqapwxl7qqtzyminooid1z4.png" alt="Attribut pour la signature"></p><br><p>  C'est comme ça, cliquez sur le côté droit de l'écran de publication et nous pouvons partager le lien afin que d'autres puissent regarder notre création.  MAIS l'affichage des cartes n'est pas gratuit, comme ailleurs, donc je ne vous donnerai pas mon lien, pour ne pas tomber dans l'effet habr. </p><br><p>  PS: Peut-être que dans un article supplémentaire, je vous dirai comment j'ai réalisé l'emplacement de la signature avec le nom de la forêt sur un groupe de blocs inclus. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr441296/">https://habr.com/ru/post/fr441296/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr441286/index.html">Yandex Neural Network Co-auteur d'une pièce pour alto et orchestre</a></li>
<li><a href="../fr441288/index.html">6 points de croissance de conversion ou techniques efficaces pour travailler avec le prix sur le site</a></li>
<li><a href="../fr441290/index.html">The Witcher 3: Wild Hunt: Comment les localisateurs ont traduit les noms</a></li>
<li><a href="../fr441292/index.html">Fintech digest: robot de la Banque centrale contre les pyramides financières, les banques vérifient les données des abonnés des opérateurs mobiles</a></li>
<li><a href="../fr441294/index.html">Smart Lock: pourquoi la paresse est un moteur de la progression de l'IoT</a></li>
<li><a href="../fr441298/index.html">Cisco Live EMEA 2019: remplacer l'ancien vélo informatique par BMW dans les nuages</a></li>
<li><a href="../fr441300/index.html">Anachronismes, craquements, mauvaise structure organisationnelle: trois douleurs de chef d'équipe dans une entreprise</a></li>
<li><a href="../fr441302/index.html">AMA avec Habr (ligne directe avec TM, v 6.0)</a></li>
<li><a href="../fr441306/index.html">Comment obtenir une offre à Moscou en 1 jour pour un ingénieur QA (et c'est cher de vivre ici)</a></li>
<li><a href="../fr441310/index.html">Expérience dans la construction d'infrastructures sur une architecture de microservices</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>