<!doctype html>
<html class="no-js" lang="en">

<head>
  <!-- Global site tag (gtag.js) - Google Analytics -->
  <script async src="https://www.googletagmanager.com/gtag/js?id=UA-134228602-6"></script>
  <script>
    window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());

    gtag('config', 'UA-134228602-6');
  </script>

  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <title>👳 🛒 ⛽️ Que sont les tests de composants et à quoi ressemble un SDET 🔆 💰 👩🏼‍🌾</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico" />
  <meta name="description" content="Annotation 


 L'article parle de la forme non conventionnelle mais utile des tests et résume également les résultats de sept années de travail dans l...">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">

  <link rel="stylesheet" href="../../css/main.css">

  <link href="https://fonts.googleapis.com/css?family=Quicksand&display=swap" rel="stylesheet">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
  <script>window.jQuery || document.write('<script src="../../js/vendors/jquery-3.3.1.min.js"><\/script>')</script>

  <script>document.write('<script src="//pagea' + 'd2.googles' + 'yndication.com/pagea' + 'd/js/a' + 'dsby' + 'google.js"><\/script>')</script>
  <script>
        var superSpecialObject = {};
        superSpecialObject['google_a' + 'd_client'] = 'ca-p' + 'ub-6974184241884155';
        superSpecialObject['enable_page_level_a' + 'ds'] = true;
       (window['a' + 'dsbygoogle'] = window['a' + 'dsbygoogle'] || []).push(superSpecialObject);
  </script>
</head>

<body>
  <!--[if lte IE 9]>
    <p class="browserupgrade">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience and security.</p>
  <![endif]-->
  <header class="page-header js-page-header">
    <a class="page-header-logo-container" href="https://weekly-geekly-es.github.io/index.html"></a>
    <div class="page-header-text">Geekly articles weekly</div>
  </header>
  <section class="page js-page"><h1>Que sont les tests de composants et à quoi ressemble un SDET</h1><div class="post__body post__body_full"><div class="post__text post__text-html post__text_v1" id="post-content-body" data-io-article-url="https://habr.com/ru/post/414563/"><h1 id="annotaciya">  Annotation </h1><br><p>  L'article parle de la forme non conventionnelle mais utile des tests et résume également les résultats de sept années de travail dans le développement de tests. </p><br><h1 id="zachem-nuzhny-komponentnye-testy">  Pourquoi avez-vous besoin de tests de composants? </h1><br><p>  Après tout, il y a, disons, des tests unitaires qui testent en détail les abats de composants.  Ils vérifient soigneusement que le composant fonctionne conformément à l'intention du développeur.  Mais souvent, il s'agit d'une vérification des boutons, et non de la façon dont le costume dans son ensemble se trouve.  Et pas toujours le comportement conçu par le programmeur coïncide avec ce que le client voulait. </p><br><p>  Et il y a, par exemple, des tests d'acceptation.  Et ils éliminent toutes ces lacunes.  Mais, malheureusement, ils en introduisent de nouveaux.  Ils sont lents, souvent instables et généralement apprivoisés.  Cependant, ils indiquent uniquement un problème, mais ne le localisent pas. </p><br><p>  De toute évidence, le besoin se fait sentir de tests intermédiaires, qui seront le juste milieu entre les tests unitaires et les tests d'acceptation.  Ce terrain d'entente peut être des tests de composants. </p><a name="habracut"></a><br><h1 id="chto-takoe-komponentnye-testy">  Que sont les tests de composants? </h1><br><p>  Ce sont des tests pour l'API du composant public.  En conséquence, ils sont écrits dans la même langue que le composant.  Objectif du test: </p><br><ul><li>  vérifier la conformité des composants avec vos contrats </li><li>  vérifier la conformité <br>  Ce dernier est particulièrement important car  les tests unitaires sont généralement écrits en fonction des attentes du développeur, mais ici, vous devez vérifier les attentes des clients. </li></ul><br><p>  De toute évidence, les tests de composants ont un sens lorsque vous avez des composants dédiés avec une interface étendue.  Par exemple, une bibliothèque dynamique ou un objet COM.  Ensuite, les tests de composants donneront l'effet maximum. </p><br><h1 id="plyusy-k-testov">  Avantages des k-tests: </h1><br><ul><li>  <strong>Donnez de la stabilité au développement.</strong>  De toute évidence, une vérification complète des interfaces publiques vous permet de conserver le composant sous une forme plus ou moins efficace. </li><li>  <strong>Localisez avec précision les problèmes.</strong>  Même si le test de composant lui-même est assez général, il peut toujours être débogué en profondeur, pour arriver rapidement au code de bataille.  Dans ce cas, l'environnement de test sera minimal et configuré automatiquement. </li><li>  <strong>Accélérez le développement avec un nombre critique de développeurs.</strong>  Les programmeurs sont connus pour être comme des chevaux.  Si un cheval tire un chariot d'une capacité de 1 litre.  s., puis huit chevaux sont tirés avec une capacité d'environ 4 litres seulement.  s  Et l'ajout d'un autre développeur à l'équipe (en particulier à la fin du projet) non seulement n'accélère pas, mais le ralentit également.  Bien que l'ajout d'un développeur de test de composants soit toujours un plus, car il agit relativement indépendamment de l'équipe: il effectue des tests (essentiellement externes), accélère la construction de la construction, optimise les fichiers d'assemblage, etc. </li><li>  <strong>Clarifier (puis vérifier) ​​les exigences des clients.</strong>  Le développeur des tests de composants n'étant pas lié à l'implémentation, il est moins affecté par l'effet "Je sais comment le faire moi-même".  Dans le cas d'une exigence ambiguë, le développeur ordinaire est enclin à faire aussi pratique (plus intéressant, plus rapide, plus facile).  Alors que le développeur ct dans ce cas est enclin à spécifier ce qui est exactement attendu par le client. </li><li>  <strong>Relativement stable et relativement rapide</strong> (par rapport aux tests manuels et aux tests automatisés via l'interface utilisateur). </li></ul><br><h1 id="minusy-k-testov">  Inconvénients des K-tests: </h1><br><ul><li>  <strong>Temps de développement et de support.</strong>  De toute évidence, la version alpha du produit, si une partie du temps est consacrée à la rédaction des tests de composants, apparaîtra plus tard.  Y aura-t-il un gain en général?  Y aura-t-il une sortie plus tôt?  C'est une bonne question.  Mon avis: lors du développement avec des tests de composants, la version sortira à peu près au même moment.  Mais - avec moins de rumeurs et plus prévisible en termes de temps.  Le temps de développement augmentera naturellement, le temps de correction de bogues et de stabilisation sera réduit.  Étant donné que la deuxième partie est beaucoup moins prévisible, sa réduction aura un effet bénéfique sur la quantité de traitement et les tracas.  Cependant, ce n'est que mon expérience, et la réalité peut être différente.  Il est possible que le temps alloué aux tests de composants soit inutilement consacré à la duplication de tests unitaires existants. </li><li>  <strong>Moins d'interchangeabilité.</strong>  La séparation des rôles augmente l'efficacité, mais réduit l'interchangeabilité.  Les développeurs souhaitent rarement approfondir les tests de composants, qui peuvent avoir (ou simuler) un environnement assez complexe.  Les développeurs de tests de composants sont loin de connaître si bien le code de bataille qu'il peut être facilement édité. </li><li>  <strong>Duplication ennuyeuse.</strong>  Avec de bons tests unitaires, les tests de composants s'avèrent souvent redondants.  C'est à la fois ennuyeux et remet en question leur besoin.  La coordination des plans unitaires et des tests des composants est utile, mais la duplication n'est généralement pas complètement éliminée. </li><li>  <strong>La nécessité de suivre le bon workflow.</strong>  Dès réception des exigences, la tâche doit être confiée simultanément au développeur et au développeur des tests.  Ensuite, ils terminent leur travail à peu près au même moment.  Le composant est soumis à des tests, les erreurs sont rapidement détectées et corrigées et un produit plus ou moins fini est utilisé pour quitter.  Dans ce cas, les avantages des tests de composants sont maximisés.  Mais il arrive souvent que les délais soient profanes depuis longtemps, tous sont abandonnés pour écrire uniquement du code, et le composant est envoyé à des tests manuels sans tests.  Et seulement alors, ils invitent le développeur des tests - ils disent que ce n'est pas bien que le code sans les tests ait été publié, il serait nécessaire de les ajouter.  Dans ce cas, la plupart des bogues sont détectés par des testeurs manuels, les développeurs apportent des corrections à l'aveugle (ou testent les modifications elles-mêmes à la main), et les tests post-factum ne détectent qu'un petit nombre d'erreurs (ce qui affecte négativement la morale de leur auteur).  Une telle utilisation des tests de composants est au mieux inutile et il est difficile de s'en assurer. </li><li>  <strong>Il y a peu de personnes appropriées.</strong>  Le développeur de tests de composants doit, d'une part, être capable d'écrire du code dans le langage du composant (et ce, par exemple, C ++).  De plus, si l'environnement de lancement du composant est étendu, le code peut être assez compliqué.  Et d'autre part, être capable de tester méticuleusement le travail de quelqu'un d'autre.  Il n'y a pas beaucoup de ces personnes, et elles vont généralement immédiatement aux développeurs.  Mais il y a encore de telles personnes, et la prochaine partie à leur sujet. </li></ul><br><h1 id="rezyume-1">  Résumé 1 </h1><br><p>  Les tests de composants sont bons, mais seulement si vous disposez de toutes les conditions: une large API publique, le bon flux de travail et les bonnes personnes dans l'équipe. </p><br><h1 id="kakovo-byt-sdetom">  Comment est-ce d'être un SDET? </h1><br><p>  De toute évidence, SDET - Software Development Engineer in Test est un candidat idéal pour écrire des tests de composants.  Il sait écrire du code et sait penser dans les tests.  Il fournit également un deuxième avis, ce qui améliore également la qualité des tests et du code.  Tout cela semble intéressant et tentant - peut-être que vous voulez déjà en être un.  Ici, je vais brièvement vous expliquer en quoi le travail de SDET diffère du travail d'un pur développeur. </p><br><h1 id="plyusy-raboty-sdetom">  Avantages de travailler avec SDET: </h1><br><ul><li>  <strong>Nouveau code.</strong>  Presque toujours, SDET écrit des tests à partir de zéro.  Et assez souvent, un environnement est écrit à partir de zéro.  Il est très agréable et laisse une grande place à la créativité. </li><li>  <strong>Faible dépendance à l'égard du code hérité.</strong>  Peu importe la gravité du code de bataille, les tests peuvent être effectués avec compétence et beauté.  Bien sûr, un code mal conçu génère des tests laids, mais ils peuvent toujours être améliorés d'un ordre de grandeur par rapport au code lui-même. </li><li>  <strong>Refactoring plus fréquent.</strong>  Les changements dans les tests sont beaucoup moins dangereux, par conséquent, ils sont convenus plus souvent.  C'est une bonne occasion de travailler sur les bugs et de pratiquer l'écriture de code propre par le refactoring. </li><li>  <strong>Le développement de la pensée critique.</strong>  Les autotests sont une recherche intéressante pour savoir comment casser le code de quelqu'un d'autre.  De plus, la recherche n'est pas stupide, ne pas s'asseoir et piquer, mais avec l'aide de la logique, de la combinatoire et de la capacité de voir les vulnérabilités.  De plus, une fois créé, un chèque continuera de fonctionner pour vous en permanence. </li><li>  <strong>Développer la capacité de tester le code.</strong>  Dans l'entraînement au combat au corps à corps, ils donnent souvent des mots d'introduction: "maintenant nous ne travaillons qu'avec nos pieds; maintenant nous ne travaillons qu'avec nos têtes."  L'utilisation d'un seul mécanisme (dans notre cas, les autotests) vous permet de l'affiner pour la maîtriser. </li><li>  <strong>Moins de rumeurs.</strong>  Les SDET sont beaucoup moins tirés pour le week-end.  Ils n'ont pas besoin de se mettre au travail de toute urgence pour corriger les bogues critiques.  Eh bien, ils ont beaucoup moins de chances de commettre une grave erreur. </li></ul><br><h1 id="minusy-raboty-sdetom">  Inconvénients de travailler avec SDET: </h1><br><ul><li>  <strong>Faible complexité de codage.</strong>  Le code de test est généralement encore plus simple que le code de bataille.  Conditions préalables, appel du code de bataille, postconditions - et ainsi de suite pour chaque test.  Le code pour créer l'environnement est plus compliqué, mais n'atteint toujours pas le combat.  Sélection d'algorithmes optimaux, conception de structures de données complexes, création de hiérarchies de classes - généralement, tout cela passe par le développeur de test. </li><li>  <strong>L'expérience gagne plus lentement</strong> .  La variété et la complexité des situations dans lesquelles tombe le développeur de test est bien moindre.  Échec de la chaîne de montage, tests rouges, parfois vidages - c'est l'ensemble principal avec lequel vous devez habituellement travailler.  Le développeur a beaucoup plus de problèmes: à partir des variations de liaison et d'assemblage, en continuant avec des problèmes chez un client particulier et en créant des vidages, en terminant par la recherche de bogues dans le compilateur et les bibliothèques tierces.  Et pas seulement ... </li><li>  <strong>Une différence majeure dans le style de test avec les développeurs.</strong>  Habituellement, les SDET préfèrent les tests expressifs compacts qui vous permettent de créer un environnement complexe en quelques lignes seulement, et les vérifications atomiques dans le style sont égales / non égales (c'est-à-dire que l'exigence est satisfaite ou non).  Parfois, il s'agit de sa DSL.  Simplement, les développeurs préfèrent les tests avec un réglage fin de l'environnement et de nombreux tests de divers aspects du comportement du programme, ce qui conduit à des tests assez multi-lignes.  Parfois, il s'agit de copier-coller (que même les meilleurs développeurs ne considèrent pas le péché dans ce cas).  Ici, vous pouvez discuter pendant longtemps de la meilleure façon ou même écrire un article séparé, mais le fait est que lorsqu'un développeur essaie de modifier les tests SDET (ou vice versa), cela conduit souvent à des discussions longues et inefficaces. </li><li>  <strong>Ci-dessous est le "grade".</strong>  Peut-être en raison d'un code plus simple et de moins de responsabilités, mais finalement pas important.  C'est généralement comme ça. </li><li>  <strong>Plus difficile de passer à un nouveau poste.</strong>  SDET pourrait bien poser la question sur le front: vous écrivez des tests depuis si longtemps, c'est-à-dire que vous venez d'appeler des fonctions et de comparer les résultats - pouvez-vous écrire du vrai code?  Connaissez-vous tous les pièges de la langue?  Avez-vous résolu des problèmes complexes?  Avez-vous dû démonter des bogues ou des décharges ornés?  Y a-t-il une expérience avec le multithreading?  Avez-vous, après tout, des ambitions? </li></ul><br><h1 id="rezyume-2">  Résumé 2 </h1><br><p>  En tant que personne qui a travaillé en tant que développeur pendant de nombreuses années, puis est allé aux SDET pendant plusieurs années, puis est retourné au développement, je peux dire ce qui suit. </p><br><p>  Je recommande fortement de passer un SDET pendant au moins un an ou deux.  C'est une expérience très enrichissante pour tout développeur.  Mais y rester, à mon avis, ne vaut pas la peine. </p></div></div><p>Source: <a rel="nofollow" href="https://habr.com/ru/post/fr414563/">https://habr.com/ru/post/fr414563/</a></p>
<section class="more-articles-navigation-panel js-more-articles-navigation-panel">
<h4>More articles:</h4>
<nav class="list-of-articles-container js-list-of-articles-container"><ul class="list-of-pages js-list-of-pages">
<li><a href="../fr414549/index.html">3000 yeux pour l'intelligence artificielle. Quel est le système de surveillance des structures du centre de Lakhta?</a></li>
<li><a href="../fr414551/index.html">Instructions d'admission au doctorat aux États-Unis</a></li>
<li><a href="../fr414555/index.html">Comment nous transférons 36 millions de clients vers un service d'assistance technique numérique</a></li>
<li><a href="../fr414557/index.html">Piratage de compteurs intelligents à PHDays 8: analyse du concours MeterH3cker</a></li>
<li><a href="../fr414561/index.html">Ecole française du jeu vidéo: Another World</a></li>
<li><a href="../fr414565/index.html">Lampe pour meubles, cuisine ou salle de bain</a></li>
<li><a href="../fr414567/index.html">Annonce de RamblerFront & # 5</a></li>
<li><a href="../fr414569/index.html">Les récifs coralliens gardent les secrets du passé et de l'avenir des océans</a></li>
<li><a href="../fr414571/index.html">La relativité inattendue du GPS intégré au cerveau</a></li>
<li><a href="../fr414573/index.html">IP DoorBell - Sonnette interactive</a></li>
</ul></nav>
</section><br />
<a href="../../allArticles.html"><strong>All Articles</strong></a>
<script src="../../js/main.js"></script>

<!-- Yandex.Metrika counter -->
<script type="text/javascript" >
  (function (d, w, c) {
      (w[c] = w[c] || []).push(function() {
          try {
              w.yaCounter57283870 = new Ya.Metrika({
                  id:57283870,
                  clickmap:true,
                  trackLinks:true,
                  accurateTrackBounce:true,
                  webvisor:true
              });
          } catch(e) { }
      });

      var n = d.getElementsByTagName("script")[0],
          s = d.createElement("script"),
          f = function () { n.parentNode.insertBefore(s, n); };
      s.type = "text/javascript";
      s.async = true;
      s.src = "https://mc.yandex.ru/metrika/watch.js";

      if (w.opera == "[object Opera]") {
          d.addEventListener("DOMContentLoaded", f, false);
      } else { f(); }
  })(document, window, "yandex_metrika_callbacks");
</script>
<noscript><div><img src="https://mc.yandex.ru/watch/57283870" style="position:absolute; left:-9999px;" alt="" /></div></noscript>

<!-- Google Analytics -->
  <script>
    window.ga = function () { ga.q.push(arguments) }; ga.q = []; ga.l = +new Date;
    ga('create', 'UA-134228602-6', 'auto'); ga('send', 'pageview')
  </script>
  <script src="https://www.google-analytics.com/analytics.js" async defer></script>

</section>

<footer class="page-footer">
  <div class="page-footer-legal-info-container page-footer-element">
    <p>
      Weekly-Geekly ES | <span class="page-footer-legal-info-year js-page-footer-legal-info-year">2019</span>
    </p>
  </div>
  <div class="page-footer-counters-container page-footer-element">
    <a class="page-footer-counter-clustrmap" href='#'  title='Visit tracker'><img src='https://clustrmaps.com/map_v2.png?cl=698e5a&w=271&t=t&d=9uU9J9pq8z7k8xEBHYSfs6DenIBAHs3vLIHcPIJW9d0&co=3a3a3a&ct=ffffff'/></a>
  </div>
</footer>
  
</body>

</html>